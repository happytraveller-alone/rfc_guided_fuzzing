static int h1_post_read_request(request_rec *r)
{
    const char *tenc;

    if (!r->main && !r->prev && r->proto_num <= HTTP_VERSION(1,1)) {
        if (r->proto_num >= HTTP_VERSION(1,0)) {
            tenc = apr_table_get(r->headers_in, "Transfer-Encoding");
            if (tenc) {
                r->body_indeterminate = 1;

                /* https://tools.ietf.org/html/rfc7230
                 * Section 3.3.3.3: "If a Transfer-Encoding header field is
                 * present in a request and the chunked transfer coding is not
                 * the final encoding ...; the server MUST respond with the 400
                 * (Bad Request) status code and then close the connection".
                 */
                if (!ap_is_chunked(r->pool, tenc)) {
                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02539)
                                  "client sent unknown Transfer-Encoding "
                                  "(%s): %s", tenc, r->uri);
                    return HTTP_BAD_REQUEST;
                }

                /* https://tools.ietf.org/html/rfc7230
                 * Section 3.3.3.3: "If a message is received with both a
                 * Transfer-Encoding and a Content-Length header field, the
                 * Transfer-Encoding overrides the Content-Length. ... A sender
                 * MUST remove the received Content-Length field".
                 */
                if (apr_table_get(r->headers_in, "Content-Length")) {
                    apr_table_unset(r->headers_in, "Content-Length");

                    /* Don't reuse this connection anyway to avoid confusion with
                     * intermediaries and request/reponse spltting.
                     */
                    r->connection->keepalive = AP_CONN_CLOSE;
                }
            }
        }
        /* HTTP1_BODY_IN takes care of chunked encoding and content-length.
         */
        ap_add_input_filter_handle(ap_h1_body_in_filter_handle,
                                   NULL, r, r->connection);
    }
    return OK;
}





AP_DECLARE(ap_condition_e) ap_condition_if_match(request_rec *r,
        apr_table_t *headers)
{
    const char *if_match, *etag;

    /* A server MUST use the strong comparison function (see section 13.3.3)
     * to compare the entity tags in If-Match.
     */
    if ((if_match = apr_table_get(r->headers_in, "If-Match")) != NULL) {
        if (if_match[0] == '*'
                || ((etag = apr_table_get(headers, "ETag")) != NULL
                        && ap_find_etag_strong(r->pool, if_match, etag))) {
            return AP_CONDITION_STRONG;
        }
        else {
            return AP_CONDITION_NOMATCH;
        }
    }

    return AP_CONDITION_NONE;
}