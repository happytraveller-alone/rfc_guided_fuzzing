
//----- (0000000180001010) ----------------------------------------------------
int __fastcall dynamic_initializer_for__g_cCipherMill__(CCipherMill *a1)
{
  CCipherMill::CCipherMill(a1);
  return atexit(dynamic_atexit_destructor_for__g_cCipherMill__);
}

//----- (0000000180001040) ----------------------------------------------------
int __fastcall dynamic_initializer_for__g_SslContextManager__(CSslContextManager *a1)
{
  CSslContextManager::CSslContextManager(a1);
  return atexit(dynamic_atexit_destructor_for__g_SslContextManager__);
}

//----- (0000000180001060) ----------------------------------------------------
__int64 __fastcall CSslContext::MakeSessionKeys(CSslContext *this, __int64 a2)
{
  _QWORD *v2; // rsi
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rax
  int v9; // eax
  unsigned int v10; // ebp
  __int64 *v11; // rax
  __int64 v12; // rcx
  int SessionKeys; // eax
  unsigned int v14; // edi
  int v16; // [rsp+40h] [rbp-88h] BYREF
  int v17[2]; // [rsp+48h] [rbp-80h] BYREF
  char *v18; // [rsp+50h] [rbp-78h]
  char v19; // [rsp+60h] [rbp-68h] BYREF

  v16 = 0;
  v2 = (_QWORD *)((char *)this + 160);
  v5 = *((_QWORD *)this + 20);
  if ( v5 )
  {
    SslFreeObject(v5, 0i64);
    *v2 = 0i64;
  }
  v6 = *((_QWORD *)this + 21);
  if ( v6 )
  {
    SslFreeObject(v6, 0i64);
    *((_QWORD *)this + 21) = 0i64;
  }
  if ( (*((_BYTE *)this + 32) & 1) == 0 )
    return 0i64;
  v7 = *((_QWORD *)this + 1);
  if ( !v7 || !*(_DWORD *)(v7 + 28) )
    return 0i64;
  v17[0] = 0;
  v18 = &v19;
  v8 = *(_QWORD *)this;
  v17[1] = 4;
  v9 = (*(__int64 (__fastcall **)(CSslContext *, _QWORD, int *, int *, _QWORD, _QWORD))(v8 + 128))(
         this,
         0i64,
         &v16,
         v17,
         0i64,
         0i64);
  v10 = v9;
  if ( v9 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 601, v9, 0x33u);
    return v10;
  }
  else
  {
    v11 = (__int64 *)*((_QWORD *)this + 1);
    if ( v11 )
      v12 = *v11;
    else
      v12 = 0i64;
    SessionKeys = SslGenerateSessionKeys(v12, a2, v2, (char *)this + 168, v17, 0);
    v14 = SessionKeys;
    if ( !SessionKeys )
      return 0i64;
    CSslContext::SetErrorAndFatalAlert((__int64)this, 600, SessionKeys, 0x33u);
    return v14;
  }
}
// 180098428: using guessed type __int64 __fastcall SslGenerateSessionKeys(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (00000001800011A0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::AllocateAndGenerateCcsAndFinish(CSsl3TlsContext *this, struct SPBuffer *a2)
{
  int v2; // r9d
  unsigned int v5; // ecx
  unsigned int v6; // r9d
  char v7; // al
  int v8; // ecx
  unsigned int v9; // ecx
  unsigned int v10; // r8d
  __int64 result; // rax

  v2 = 1;
  if ( (*((_BYTE *)this + 32) & 4) != 0 )
  {
    v5 = *((_DWORD *)this + 13);
    v6 = *((_DWORD *)this + 12) + 1;
    if ( v5 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v5 -= v6 % v5;
      v6 += v5;
    }
    v2 = *((_DWORD *)this + 11) + v6;
  }
  v7 = *((_BYTE *)this + 233);
  if ( (*((_BYTE *)this + 64) & 0x30) != 0 )
    v8 = v7 != 0 ? 48 : 40;
  else
    v8 = v7 != 0 ? 24 : 16;
  if ( (*((_BYTE *)this + 32) & 1) != 0 )
  {
    v9 = *((_DWORD *)this + 12) + v8;
    v10 = *((_DWORD *)this + 13);
    if ( v10 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v10 -= v9 % v10;
      v9 += v10;
    }
    v8 = *((_DWORD *)this + 11) + v9;
  }
  result = CSsl3TlsContext::AllocateOutputBuffer(this, a2, v2 + v8 + 2 * *((_DWORD *)this + 15));
  if ( !(_DWORD)result )
    return CSsl3TlsContext::GenerateCcsAndFinishMessage(this, a2);
  return result;
}

//----- (0000000180001268) ----------------------------------------------------
__int64 __fastcall VerifyServerCertificate(struct CSsl3TlsContext *a1, DWORD a2, int a3)
{
  __int64 v5; // r13
  __int64 v6; // r15
  unsigned __int16 *v7; // r14
  const CERT_CONTEXT *Ptr; // rsi
  __int64 v9; // r13
  DWORD v10; // eax
  unsigned int v11; // ebx
  __int64 v12; // rdx
  int v13; // eax
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 v24; // rcx
  DWORD dwErrorStatus; // edx
  unsigned __int8 v27; // r9
  int v28; // edx
  int v29; // r8d
  DWORD LastError; // eax
  DWORD v31; // eax
  unsigned __int8 v32; // r9
  char v33[8]; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v34; // [rsp+48h] [rbp-B8h] BYREF
  int v35; // [rsp+50h] [rbp-B0h] BYREF
  PCCERT_CHAIN_CONTEXT pChainContext; // [rsp+58h] [rbp-A8h] BYREF
  int v37; // [rsp+60h] [rbp-A0h]
  __int128 pvData; // [rsp+68h] [rbp-98h] BYREF
  __int128 v39; // [rsp+78h] [rbp-88h] BYREF
  unsigned __int16 *v40; // [rsp+88h] [rbp-78h]
  struct _CERT_CHAIN_POLICY_PARA pPolicyPara; // [rsp+90h] [rbp-70h] BYREF
  struct _CERT_CHAIN_POLICY_STATUS pPolicyStatus; // [rsp+A0h] [rbp-60h] BYREF
  struct _CERT_CHAIN_PARA pChainPara; // [rsp+C0h] [rbp-40h] BYREF
  struct _EVENT_DATA_DESCRIPTOR pCertContext; // [rsp+120h] [rbp+20h] BYREF
  __int64 v45[3]; // [rsp+130h] [rbp+30h] BYREF

  v37 = a3;
  v40 = 0i64;
  v39 = 0i64;
  pPolicyPara = 0i64;
  memset(&pPolicyStatus, 0, sizeof(pPolicyStatus));
  memset_0(&pChainPara, 0, 0x60ui64);
  v5 = *((_QWORD *)a1 + 17);
  v6 = *((_QWORD *)a1 + 10);
  v45[0] = (__int64)"1.3.6.1.5.5.7.3.1";
  pChainContext = 0i64;
  v45[1] = (__int64)"1.3.6.1.4.1.311.10.3.3";
  v7 = 0i64;
  v34 = 0i64;
  v45[2] = (__int64)"2.16.840.1.113730.4.1";
  Ptr = 0i64;
  pCertContext.Ptr = 0i64;
  v9 = v5 & 0x200000000i64;
  v35 = 0;
  v33[0] = 0;
  pvData = 0i64;
  if ( !v6 )
    return (unsigned int)-2146893052;
  (*(void (__fastcall **)(struct CSsl3TlsContext *, __int64 *))(*(_QWORD *)a1 + 224i64))(a1, &v34);
  if ( v34 )
  {
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(v34 + 72), 1u);
    v10 = SPLoadCertificate(
            *(unsigned __int8 **)(v34 + 24),
            *(_DWORD *)(v34 + 32),
            (const struct _CERT_CONTEXT **)&pCertContext);
    Ptr = (const CERT_CONTEXT *)pCertContext.Ptr;
    v11 = v10;
    if ( v10 )
    {
      v27 = 42;
      v28 = 550;
    }
    else
    {
      v12 = v34;
      LODWORD(pvData) = *(_DWORD *)(v34 + 344);
      *((_QWORD *)&pvData + 1) = *(_QWORD *)(v34 + 336);
      if ( (_DWORD)pvData )
      {
        if ( !CertSetCertificateContextProperty((PCCERT_CONTEXT)pCertContext.Ptr, 0x46u, 0, &pvData)
          && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        {
          LastError = GetLastError();
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            21i64,
            &WPP_145b996ecad4340088f3534b93eceddb_Traceguids,
            LastError);
        }
        v12 = v34;
      }
      v13 = *(_DWORD *)(v12 + 360);
      v14 = *(_QWORD *)(v12 + 352);
      *((_QWORD *)&pvData + 1) = v14;
      LODWORD(pvData) = v13;
      if ( v13
        && v14
        && !CertSetCertificateContextProperty(Ptr, 0x77u, 0, &pvData)
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      {
        v31 = GetLastError();
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids, v31);
      }
      if ( SslImpersonateClient(*(_QWORD *)(*((_QWORD *)a1 + 10) + 752i64), &v35) )
      {
        v11 = -2146893052;
LABEL_25:
        if ( v34 )
          RtlReleaseResource((PRTL_RESOURCE)(v34 + 72));
        goto LABEL_27;
      }
      pChainPara.cbSize = 96;
      pChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = (LPSTR *)v45;
      pChainPara.RequestedUsage.dwType = 1;
      pChainPara.RequestedUsage.Usage.cUsageIdentifier = 3;
      if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
        McGenEventWrite_EventWriteTransfer(v15, &ChainBuildStart, v16, v17, &pCertContext);
      if ( CertGetCertificateChain(0i64, Ptr, 0i64, Ptr->hCertStore, &pChainPara, a2, 0i64, &pChainContext) )
      {
        if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
          McGenEventWrite_EventWriteTransfer(v18, &ChainBuildStop, v19, v20, &pCertContext);
        if ( (*(_BYTE *)(v6 + 156) & 2) == 0 )
        {
          v7 = *(unsigned __int16 **)(v34 + 368);
          if ( !v7 || !lstrlenW(*(LPCWSTR *)(v34 + 368)) )
          {
            v11 = -2146893022;
            v28 = 553;
            v27 = 80;
            v29 = -2146893022;
            goto LABEL_40;
          }
        }
        pPolicyPara.dwFlags = 0;
        v39 = 0x200000018ui64;
        v40 = v7;
        pPolicyPara.cbSize = 16;
        pPolicyPara.pvExtraPolicyPara = &v39;
        pPolicyStatus.cbSize = 24;
        if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
          McGenEventWrite_EventWriteTransfer(v18, &ChainVerifyStart, v19, v20, &pCertContext);
        if ( CertVerifyCertificateChainPolicy((LPCSTR)4, pChainContext, &pPolicyPara, &pPolicyStatus) )
        {
          if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
            McGenEventWrite_EventWriteTransfer(v21, &ChainVerifyStop, v22, v23, &pCertContext);
          v24 = v34;
          dwErrorStatus = pChainContext->TrustStatus.dwErrorStatus;
          *(_DWORD *)(v34 + 216) = pPolicyStatus.dwError;
          *(_DWORD *)(v24 + 220) = dwErrorStatus;
          if ( !v9 && (v11 = I_MapWinTrustErrorAndAlert(pPolicyStatus.dwError, 0, v37, v33)) != 0 )
          {
            v32 = v33[0];
            if ( !v33[0] )
              v32 = 80;
            CSslContext::SetErrorAndFatalAlert((__int64)a1, 552, v11, v32);
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              WPP_SF_D(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                24i64,
                &WPP_145b996ecad4340088f3534b93eceddb_Traceguids,
                v11);
            }
            LogBogusServerCertEvent(*(_DWORD *)(v6 + 212), (const unsigned __int16 *)(v6 + 216), Ptr, v7, v11);
          }
          else
          {
            v11 = 0;
          }
          goto LABEL_25;
        }
        if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
          McGenEventWrite_EventWriteTransfer(v21, &ChainVerifyStop, v22, v23, &pCertContext);
        v10 = GetLastError();
        v27 = 80;
        v28 = 552;
        v11 = v10;
      }
      else
      {
        if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
          McGenEventWrite_EventWriteTransfer(v18, &ChainBuildStop, v19, v20, &pCertContext);
        v10 = GetLastError();
        v27 = 80;
        v28 = 551;
        v11 = v10;
      }
    }
    v29 = v10;
LABEL_40:
    CSslContext::SetErrorAndFatalAlert((__int64)a1, v28, v29, v27);
    goto LABEL_25;
  }
  v11 = -2146893052;
LABEL_27:
  if ( pChainContext )
    CertFreeCertificateChain(pChainContext);
  if ( Ptr )
    CertFreeCertificateContext(Ptr);
  if ( v35 )
    RevertToSelf();
  return v11;
}
// 18002B828: variable 'v15' is possibly undefined
// 18002B828: variable 'v16' is possibly undefined
// 18002B828: variable 'v17' is possibly undefined
// 18002B87E: variable 'v18' is possibly undefined
// 18002B87E: variable 'v19' is possibly undefined
// 18002B87E: variable 'v20' is possibly undefined
// 18002B8C5: variable 'v21' is possibly undefined
// 18002B8C5: variable 'v22' is possibly undefined
// 18002B8C5: variable 'v23' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180084C60: using guessed type EVENT_DESCRIPTOR ChainVerifyStop;
// 180084C70: using guessed type EVENT_DESCRIPTOR ChainVerifyStart;
// 180084C80: using guessed type EVENT_DESCRIPTOR ChainBuildStop;
// 180084C90: using guessed type EVENT_DESCRIPTOR ChainBuildStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 180001268: using guessed type char var_140[8];

//----- (0000000180001604) ----------------------------------------------------
ULONG __fastcall SslImpersonateClient(__int64 a1, int *a2)
{
  ULONG result; // eax
  int v4; // eax
  __int64 ThreadInformation; // [rsp+30h] [rbp+8h] BYREF

  ThreadInformation = a1;
  *a2 = 0;
  result = LsaTable;
  if ( LsaTable )
  {
    if ( a1 )
      v4 = NtSetInformationThread((HANDLE)0xFFFFFFFFFFFFFFFEi64, ThreadImpersonationToken, &ThreadInformation, 8u);
    else
      v4 = (*(__int64 (**)(void))(LsaTable + 88))();
    if ( v4 >= 0 )
      *a2 = 1;
    return RtlNtStatusToDosError(v4);
  }
  return result;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180001674) ----------------------------------------------------
__int64 __fastcall I_MapWinTrustErrorAndAlert(int a1, int a2, __int16 a3, char *a4)
{
  char v4; // bl
  CCipherMill *v7; // rcx
  __int64 v8; // rdx

  v4 = 0;
  if ( a1 == -2146885614 )
  {
    if ( (a3 & 0x800) == 0 )
      goto LABEL_32;
    v7 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) == 0 )
      goto LABEL_12;
    v8 = 17i64;
LABEL_26:
    WPP_SF_(*((_QWORD *)v7 + 2), v8, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids);
    goto LABEL_12;
  }
  if ( a1 == -2146885613 )
  {
    if ( (a3 & 0x1000) == 0 )
      goto LABEL_32;
    v7 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) == 0 )
      goto LABEL_12;
    v8 = 18i64;
    goto LABEL_26;
  }
  if ( (a1 & 0x1FFF0000) != 589824 )
  {
    if ( a1 < -2146762495 )
    {
LABEL_35:
      a1 = a2;
      if ( !a2 )
        a1 = -2146893017;
      goto LABEL_37;
    }
    if ( a1 <= -2146762494 )
    {
      a1 = -2146893016;
      v4 = 45;
      goto LABEL_13;
    }
    if ( a1 == -2146762487 )
    {
LABEL_16:
      a1 = -2146893019;
      v4 = 48;
      goto LABEL_13;
    }
    if ( a1 != -2146762484 )
    {
      switch ( a1 )
      {
        case -2146762481:
          a1 = -2146893022;
          break;
        case -2146762480:
          a1 = -2146892983;
          break;
        case -2146762478:
          goto LABEL_16;
        case 0:
LABEL_12:
          a1 = 0;
          goto LABEL_13;
        default:
          goto LABEL_35;
      }
LABEL_32:
      v4 = 43;
      goto LABEL_13;
    }
    a1 = -2146885616;
LABEL_34:
    v4 = 44;
    goto LABEL_13;
  }
  if ( a1 == -2146885616 )
    goto LABEL_34;
  if ( (unsigned int)(a1 + 2146885614) <= 1 )
    goto LABEL_32;
LABEL_37:
  v4 = 46;
LABEL_13:
  if ( a4 )
    *a4 = v4;
  return (unsigned int)a1;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000172C) ----------------------------------------------------
__int64 __fastcall TlsParseAlertMessage(unsigned __int8 *a1, int a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  unsigned int v4; // ebx
  CCipherMill *v8; // rcx
  unsigned int v9; // eax
  int v10; // ecx
  __int64 v12; // rdx
  __int64 v13; // rdx
  __int64 v14; // rdx

  v4 = 0;
  if ( a4 )
    *a4 = 0;
  if ( a2 != 2 || (unsigned __int8)(*a1 - 1) > 1u )
    return 2148074248i64;
  if ( a3 )
  {
    v8 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_L(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x47u,
          (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
          *a1);
        v8 = WPP_GLOBAL_Control;
      }
      if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 1) != 0 )
      {
        WPP_SF_L(*((_QWORD *)v8 + 2), 0x48u, (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, a1[1]);
        v8 = WPP_GLOBAL_Control;
      }
    }
    v9 = a1[1];
    if ( *a1 == 1 )
    {
      if ( (_BYTE)v9 )
      {
        if ( (_BYTE)v9 == 41 )
        {
          if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
            WPP_SF_(*((_QWORD *)v8 + 2), 73i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
          if ( a4 )
            *a4 = 1;
        }
        else if ( (_BYTE)v9 == 100 )
        {
          if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
            WPP_SF_(*((_QWORD *)v8 + 2), 75i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
          v4 = 590688;
        }
        else if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
        {
          WPP_SF_(*((_QWORD *)v8 + 2), 76i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
        }
      }
      else
      {
        if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)v8 + 2), 74i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
        v4 = 590615;
      }
      v10 = *a3;
      *a3 = v10 + 1;
      if ( (unsigned __int8)(v10 + 1) > 5u )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          *a3 = v10;
          WPP_SF_d(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x4Du,
            (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
            v10);
        }
        return 590615;
      }
      return v4;
    }
    if ( v9 > 0x2F )
    {
      if ( v9 > 0x46 )
      {
        switch ( v9 )
        {
          case 'G':
            if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v8 + 2), 94i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146893007;
          case 'P':
            if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v8 + 2), 95i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146893052;
          case 'n':
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893018;
            v12 = 96i64;
            goto LABEL_51;
          case 's':
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893018;
            v12 = 97i64;
            goto LABEL_51;
          case 'x':
            if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v8 + 2), 98i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146892953;
        }
      }
      else
      {
        switch ( v9 )
        {
          case 'F':
            if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v8 + 2), 93i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146893054;
          case '0':
            if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v8 + 2), 88i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146893019;
          case '1':
            if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v8 + 2), 89i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146893044;
          case '2':
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893018;
            v12 = 90i64;
            goto LABEL_51;
          case '3':
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893008;
            v13 = 91i64;
            goto LABEL_56;
          case '<':
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893018;
            v12 = 92i64;
            goto LABEL_51;
        }
      }
    }
    else
    {
      if ( v9 == 47 )
      {
        if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
          return (unsigned int)-2146893018;
        v12 = 87i64;
        goto LABEL_51;
      }
      if ( v9 <= 0x28 )
      {
        switch ( v9 )
        {
          case 0x28u:
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893018;
            v12 = 81i64;
            break;
          case 0xAu:
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893018;
            v12 = 78i64;
            break;
          case 0x14u:
            if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v8 + 2), 79i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146893041;
          case 0x15u:
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893008;
            v13 = 80i64;
LABEL_56:
            WPP_SF_(*((_QWORD *)v8 + 2), v13, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146893008;
          case 0x16u:
            return (unsigned int)-2146893018;
          case 0x1Eu:
            return (unsigned int)-2146893041;
          default:
            goto LABEL_48;
        }
LABEL_51:
        WPP_SF_(*((_QWORD *)v8 + 2), v12, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
        return (unsigned int)-2146893018;
      }
      switch ( v9 )
      {
        case '*':
          if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
            return (unsigned int)-2146893017;
          v14 = 82i64;
          goto LABEL_90;
        case '+':
          if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
            return (unsigned int)-2146893017;
          v14 = 83i64;
          goto LABEL_90;
        case ',':
          if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
            WPP_SF_(*((_QWORD *)v8 + 2), 84i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
          return (unsigned int)-2146885616;
        case '-':
          if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
            WPP_SF_(*((_QWORD *)v8 + 2), 85i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
          return (unsigned int)-2146893016;
        case '.':
          if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
            return (unsigned int)-2146893017;
          v14 = 86i64;
LABEL_90:
          WPP_SF_(*((_QWORD *)v8 + 2), v14, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
          return (unsigned int)-2146893017;
      }
    }
LABEL_48:
    if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
      return (unsigned int)-2146893018;
    v12 = 99i64;
    goto LABEL_51;
  }
  return 2148074333i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180001820) ----------------------------------------------------
__int64 __fastcall SpUserModeInitialize(int a1, _DWORD *a2, _QWORD *a3, _DWORD *a4)
{
  if ( a2 && a3 && a4 )
  {
    if ( a1 == 0x10000 )
    {
      *a2 = 0x10000;
      *a3 = &SslTable;
      *a4 = 2;
      return (unsigned int)SslInitContextManager() == 0 ? 0xC000009A : 0;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_d(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, a1);
  }
  return 3221225485i64;
}
// 1800912A0: using guessed type struct _SECPKG_USER_FUNCTION_TABLE near *SslTable;

//----- (000000018000187C) ----------------------------------------------------
__int64 SslInitContextManager(void)
{
  unsigned int v0; // ebx
  DWORD v1; // edi
  _QWORD *v2; // rax
  int v4; // eax
  int v5; // eax
  DWORD i; // esi
  DWORD v7; // [rsp+50h] [rbp-28h] BYREF
  HKEY hKey; // [rsp+58h] [rbp-20h] BYREF
  DWORD cbData; // [rsp+80h] [rbp+8h] BYREF
  DWORD Type; // [rsp+88h] [rbp+10h] BYREF
  int Data; // [rsp+90h] [rbp+18h] BYREF
  int v12; // [rsp+98h] [rbp+20h] BYREF

  v0 = 0;
  v1 = 0;
  hKey = 0i64;
  if ( dword_1800921C0 )
    return 1i64;
  if ( !RegCreateKeyExW(
          HKEY_LOCAL_MACHINE,
          L"System\\CurrentControlSet\\Control\\SecurityProviders\\Schannel",
          0,
          (LPWSTR)&Class,
          0,
          0x20019u,
          0i64,
          &hKey,
          &v7) )
  {
    cbData = 4;
    if ( !RegQueryValueExW(hKey, L"UserContextLockCount", 0i64, &Type, (LPBYTE)&Data, &cbData)
      && Type == 4
      && (unsigned int)(Data - 1) <= 0x1FF )
    {
      v4 = dwSslContextLockCount;
      if ( ((Data - 1) & Data) == 0 )
        v4 = Data;
      dwSslContextLockCount = v4;
    }
    cbData = 4;
    if ( !RegQueryValueExW(hKey, L"UserContextListCount", 0i64, &Type, (LPBYTE)&v12, &cbData) && Type == 4 && v12 )
    {
      v5 = dwSslContextListCount;
      if ( ((v12 - 1) & v12) == 0 )
        v5 = v12;
      dwSslContextListCount = v5;
    }
    RegCloseKey(hKey);
    hKey = 0i64;
  }
  SslContextLock = SPExternalAlloc(96 * dwSslContextLockCount);
  if ( !SslContextLock )
    goto LABEL_25;
  while ( 1 )
  {
    cbData = v1;
    if ( v1 >= dwSslContextLockCount )
      break;
    RtlInitializeResource((PRTL_RESOURCE)SslContextLock + v1++);
  }
  SslContextList = SPExternalAlloc(16 * dwSslContextListCount);
  if ( SslContextList )
  {
    while ( v0 < dwSslContextListCount )
    {
      v2 = (char *)SslContextList + 16 * v0;
      v2[1] = v2;
      *v2 = v2;
      ++v0;
    }
    dword_1800921C0 = 1;
    return 1;
  }
  else
  {
LABEL_25:
    if ( SslContextList )
    {
      SPExternalFree(SslContextList);
      SslContextList = 0i64;
    }
    if ( SslContextLock )
    {
      for ( i = 0; i < v1; ++i )
        RtlDeleteResource((PRTL_RESOURCE)SslContextLock + i);
      SPExternalFree(SslContextLock);
      SslContextLock = 0i64;
    }
  }
  return v0;
}
// 1800019FE: conditional instruction was optimized away because esi.4==0
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800919E0: using guessed type unsigned int dwSslContextListCount;
// 1800919E4: using guessed type unsigned int dwSslContextLockCount;
// 1800921C0: using guessed type int dword_1800921C0;

//----- (0000000180001A64) ----------------------------------------------------
__int64 WppInitUm()
{
  CCipherMill *v0; // rbx
  __int64 *v1; // rdi
  __int64 result; // rax
  __int64 v3; // rsi
  HMODULE ModuleHandleW; // rax
  __int64 v5[2]; // [rsp+40h] [rbp-258h] BYREF
  __int128 v6; // [rsp+50h] [rbp-248h] BYREF
  WCHAR v7; // [rsp+60h] [rbp-238h]
  WCHAR Filename[264]; // [rsp+70h] [rbp-228h] BYREF

  v0 = WPP_GLOBAL_Control;
  v1 = &WPP_REGISTRATION_GUIDS;
  memset_0(Filename, 0, 0x208ui64);
  result = SourceString[8];
  v7 = SourceString[8];
  v6 = *(_OWORD *)L"schannel";
  while ( v0 )
  {
    v3 = *v1;
    v5[0] = v3;
    ++v1;
    v5[1] = 0i64;
    *((_QWORD *)v0 + 4) = v3;
    ModuleHandleW = GetModuleHandleW(L"schannel");
    if ( ModuleHandleW )
    {
      GetModuleFileNameW(ModuleHandleW, Filename, 0x104u);
      Filename[259] = 0;
    }
    result = EtwRegisterTraceGuidsW(WppControlCallback, v0, v3, 1i64, v5, Filename, &v6, (char *)v0 + 8);
    v0 = *(CCipherMill **)v0;
  }
  return result;
}
// 180080E10: using guessed type __int64 __fastcall EtwRegisterTraceGuidsW(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 180092A88: using guessed type __int64 WPP_REGISTRATION_GUIDS;

//----- (0000000180001BA0) ----------------------------------------------------
__int64 __fastcall CSessionCacheManager::RunBalancer(CSessionCacheManager *this, int a2)
{
  if ( *((int *)this + 8) > 0 )
    CSessionCacheManager::CacheExpireElements(this, 1, a2 == CSslGlobals::m_dwCleanupIntervalInSeconds);
  return 0i64;
}

//----- (0000000180001BCC) ----------------------------------------------------
__int64 __fastcall VerifyEcdsaParams(
        struct CSsl3TlsClientContext *a1,
        unsigned __int8 *a2,
        unsigned int a3,
        enum _eTlsHashAlgorithm a4,
        unsigned __int8 *pbEncoded,
        DWORD cbEncoded)
{
  struct _RTL_RESOURCE *v7; // rcx
  char *v9; // r14
  const void **v10; // rdi
  BOOL v11; // eax
  struct _RTL_RESOURCE *v12; // rcx
  DWORD LastError; // eax
  DWORD v14; // ebx
  unsigned int v15; // ebx
  enum _eTlsHashAlgorithm v16; // ecx
  NTSTATUS v17; // eax
  NTSTATUS v18; // eax
  unsigned __int8 v20; // r9
  int v21; // r8d
  int v22; // edx
  BCRYPT_KEY_HANDLE *phKey; // [rsp+20h] [rbp-89h]
  __int64 dwFlags; // [rsp+28h] [rbp-81h]
  DWORD cbSignature; // [rsp+40h] [rbp-69h] BYREF
  UCHAR pbOutput[4]; // [rsp+44h] [rbp-65h] BYREF
  ULONG cbHash; // [rsp+48h] [rbp-61h] BYREF
  BCRYPT_KEY_HANDLE hObject; // [rsp+50h] [rbp-59h] BYREF
  ULONG pcbResult; // [rsp+58h] [rbp-51h] BYREF
  unsigned int v30; // [rsp+5Ch] [rbp-4Dh]
  unsigned __int8 *v31; // [rsp+60h] [rbp-49h]
  UCHAR pbHash[64]; // [rsp+70h] [rbp-39h] BYREF

  v31 = a2;
  v7 = (struct _RTL_RESOURCE *)(*((_QWORD *)a1 + 11) + 72i64);
  v30 = a3;
  cbHash = 0;
  hObject = 0i64;
  v9 = 0i64;
  pcbResult = 0;
  v10 = 0i64;
  *(_DWORD *)pbOutput = 0;
  cbSignature = 0;
  RtlAcquireResourceShared(v7, 1u);
  v11 = CryptImportPublicKeyInfoEx2(
          **(_DWORD **)(*((_QWORD *)a1 + 11) + 48i64),
          (PCERT_PUBLIC_KEY_INFO)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 11) + 48i64) + 24i64) + 96i64),
          0x80000000,
          0i64,
          &hObject);
  v12 = (struct _RTL_RESOURCE *)(*((_QWORD *)a1 + 11) + 72i64);
  if ( !v11 )
  {
    RtlReleaseResource(v12);
    LastError = GetLastError();
    v14 = LastError;
    v20 = 43;
LABEL_22:
    v21 = LastError;
    v22 = 1107;
    goto LABEL_34;
  }
  RtlReleaseResource(v12);
  LastError = BCryptGetProperty(hObject, L"KeyLength", pbOutput, 4u, &pcbResult, 0);
  v14 = LastError;
  if ( LastError )
  {
    v20 = 80;
    goto LABEL_22;
  }
  v15 = (*(_DWORD *)pbOutput >> 3) + ((pbOutput[0] & 7) != 0);
  v9 = (char *)SPExternalAlloc(2 * v15);
  if ( !v9 )
  {
    v14 = 14;
    goto LABEL_13;
  }
  if ( CryptDecodeObject(1u, (LPCSTR)0x2F, pbEncoded, cbEncoded, 0, 0i64, &cbSignature) )
  {
    v10 = (const void **)SPExternalAlloc(cbSignature);
    if ( !v10 )
    {
      v14 = -2146893056;
      goto LABEL_13;
    }
    if ( !CryptDecodeObject(1u, (LPCSTR)0x2F, pbEncoded, cbEncoded, 0, v10, &cbSignature) )
    {
      v14 = GetLastError();
      goto LABEL_13;
    }
    if ( *(_DWORD *)v10 <= v15 && *((_DWORD *)v10 + 4) <= v15 )
    {
      memcpy_0(v9, v10[1], *(unsigned int *)v10);
      memcpy_0(&v9[v15], v10[3], *((unsigned int *)v10 + 4));
      cbSignature = 2 * v15;
      ReverseInPlace((unsigned __int8 *)v9, v15);
      ReverseInPlace((unsigned __int8 *)&v9[(unsigned __int64)cbSignature >> 1], cbSignature >> 1);
      v16 = TlsHashAlgorithm_Sha1;
      if ( a4 )
        v16 = a4;
      v17 = GenerateTlsHash(v16, (UCHAR *)a1, v31, v30, pbHash, &cbHash);
      v14 = v17;
      if ( v17 )
      {
        v20 = 80;
        v21 = v17;
        v22 = 1109;
      }
      else
      {
        v18 = BCryptVerifySignature(hObject, 0i64, pbHash, cbHash, (PUCHAR)v9, cbSignature, 0);
        v14 = v18;
        if ( !v18 )
          goto LABEL_13;
        v20 = 51;
        v21 = v18;
        v22 = 1110;
      }
      goto LABEL_34;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      LODWORD(dwFlags) = v15;
      LODWORD(phKey) = *((_DWORD *)v10 + 4);
      WPP_SF_DDD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xAu,
        (__int64)&WPP_3e0ca11e9b65363ec3903422d835754d_Traceguids,
        *(_DWORD *)v10,
        phKey,
        dwFlags);
    }
    v14 = 13;
    v21 = 13;
  }
  else
  {
    v14 = GetLastError();
    v21 = v14;
  }
  v22 = 1108;
  v20 = 50;
LABEL_34:
  CSslContext::SetErrorAndFatalAlert((__int64)a1, v22, v21, v20);
LABEL_13:
  if ( hObject )
    BCryptDestroyKey(hObject);
  if ( v9 )
    SPExternalFree(v9);
  if ( v10 )
    SPExternalFree(v10);
  return v14;
}
// 18002BF6A: variable 'phKey' is possibly undefined
// 18002BF6A: variable 'dwFlags' is possibly undefined

//----- (0000000180001E7C) ----------------------------------------------------
void __fastcall ReverseInPlace(unsigned __int8 *a1, unsigned int a2)
{
  unsigned int v2; // ebx
  unsigned __int8 *v3; // r11
  unsigned __int8 v4; // r8
  unsigned int v5; // eax
  __int64 v6; // rax

  v2 = 0;
  if ( a2 >> 1 )
  {
    v3 = a1;
    do
    {
      v4 = *v3;
      v5 = a2 - v2++;
      v6 = v5 - 1;
      *v3++ = a1[v6];
      a1[(unsigned int)v6] = v4;
    }
    while ( v2 < a2 >> 1 );
  }
}

//----- (0000000180001ED0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::GenerateResponse(CSsl3TlsClientContext *this, struct SPBuffer *a2)
{
  unsigned int CcsAndFinish; // edi
  int v5; // ecx
  int v6; // ecx
  unsigned int ServerHelloResponse; // eax
  int v9; // ecx
  CCipherMill *v10; // rcx
  __int64 v11; // rdx
  unsigned __int8 v12; // [rsp+30h] [rbp+8h] BYREF

  CcsAndFinish = 0;
  v5 = *((_DWORD *)this + 17) - 4;
  if ( v5 )
  {
    v6 = v5 - 87;
    if ( !v6 )
    {
      v12 = 0;
      CcsAndFinish = CSsl3TlsClientContext::CheckForClientCertificatePrivateKeys(this, &v12);
      if ( !v12 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 34i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        ServerHelloResponse = CSsl3TlsClientContext::GenerateServerHelloResponse(this, a2);
        CcsAndFinish = ServerHelloResponse;
        if ( ServerHelloResponse )
        {
          if ( ServerHelloResponse == 590684 )
            *((_DWORD *)this + 17) = 49;
        }
        else
        {
          *((_DWORD *)this + 17) = CSsl3TlsClientContext::IsFalseStartAllowed(this) ? 51 : 46;
        }
      }
      return CcsAndFinish;
    }
    v9 = v6 - 1;
    if ( !v9 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 35i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      CcsAndFinish = CSsl3TlsContext::AllocateAndGenerateCcsAndFinish(this, a2);
      if ( !CcsAndFinish )
        (*(void (__fastcall **)(CSsl3TlsClientContext *))(*(_QWORD *)this + 448i64))(this);
      return CcsAndFinish;
    }
    if ( v9 != 5 )
      return CcsAndFinish;
    v10 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 38i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      v10 = WPP_GLOBAL_Control;
    }
    if ( !*((_BYTE *)this + 233) )
    {
      if ( v10 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v10 + 28) & 4) == 0 )
        return (unsigned int)-2146893018;
      v11 = 39i64;
LABEL_32:
      WPP_SF_(*((_QWORD *)v10 + 2), v11, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      return (unsigned int)-2146893018;
    }
    CcsAndFinish = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, struct SPBuffer *))(*(_QWORD *)this + 216i64))(
                     this,
                     a2);
    if ( !CcsAndFinish )
      *((_DWORD *)this + 17) = 40;
  }
  else
  {
    if ( CSslGlobals::m_fDisableRenegoOnClient )
    {
      v10 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
        return (unsigned int)-2146893018;
      v11 = 36i64;
      goto LABEL_32;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 37i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
    CSchannelTelemetryContext::LogRenegoStart(*((_QWORD *)this + 15), 0, *((_QWORD *)this + 17));
    CcsAndFinish = CSsl3TlsClientContext::GenerateRenegotiateClientHello(this, a2);
    if ( !CcsAndFinish )
    {
      *((_DWORD *)this + 17) = 40;
      if ( *((_BYTE *)this + 233) )
        *(_DWORD *)(*((_QWORD *)this + 73) + 36i64) = *(__int16 *)(*(_QWORD *)(*((_QWORD *)this + 73) + 40i64) + 192i64);
    }
    *((_QWORD *)this + 17) &= ~0x40000000ui64;
  }
  return CcsAndFinish;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800927C4: using guessed type int CSslGlobals::m_fDisableRenegoOnClient;

//----- (0000000180001FC8) ----------------------------------------------------
bool __fastcall CSsl3TlsClientContext::IsFalseStartAllowed(CSsl3TlsClientContext *this)
{
  bool result; // al
  __int64 v2; // rax
  unsigned int v3; // ecx

  result = 0;
  if ( *((_BYTE *)this + 556) )
  {
    if ( *((_DWORD *)this + 16) == 2048 && !*((_BYTE *)this + 1315) && (*((_BYTE *)this + 32) & 8) != 0 )
    {
      v2 = *((_QWORD *)this + 1);
      if ( v2 )
      {
        v3 = *(_DWORD *)(v2 + 28);
        if ( v3 >= 0xC023
          && (v3 <= 0xC024 || v3 > 0xC026 && (v3 <= 0xC028 || v3 > 0xC02A && (v3 <= 0xC02C || v3 - 49199 <= 1))) )
        {
          return 1;
        }
      }
    }
  }
  return result;
}

//----- (0000000180002040) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::GenerateServerHelloResponse(CSsl3TlsClientContext *this, struct SPBuffer *a2)
{
  unsigned int v4; // ebp
  unsigned int v5; // esi
  char v6; // r8
  int v7; // r14d
  __int64 v8; // rax
  __int64 v9; // r12
  unsigned int v10; // r13d
  char v11; // r11
  __int16 v12; // r10
  int v13; // ecx
  unsigned int v14; // ecx
  unsigned int v15; // r8d
  int v16; // ecx
  int v17; // ecx
  int v18; // r8d
  unsigned int v19; // r9d
  unsigned int v20; // r8d
  int v21; // r9d
  unsigned int v22; // r9d
  unsigned int v23; // r10d
  unsigned int OutputBuffer; // ebx
  unsigned int v25; // r14d
  unsigned int v26; // ecx
  __int64 v27; // rax
  __int16 v28; // r12
  _BYTE *v29; // rsi
  unsigned int v30; // r9d
  __int16 *v31; // rbp
  __int16 v32; // cx
  const void *v33; // r8
  __int64 v34; // r9
  unsigned __int8 *v35; // rsi
  unsigned int v36; // r14d
  __int64 v37; // rax
  __int64 v38; // rbx
  __int64 v39; // rax
  unsigned int CcsAndFinishMessage; // eax
  __int64 v42; // rbx
  int UserMappingDataMsg; // esi
  int v44; // edx
  int v45; // r8d
  CSsl3TlsClientContext *v46; // rcx
  __int64 v47; // rdx
  unsigned int v48; // ebx
  int v49; // ecx
  unsigned int v50; // r8d
  unsigned int v51; // ecx
  __int64 v52; // rcx
  int v53; // eax
  unsigned int v54; // r14d
  __int64 v55; // r9
  size_t v56; // r8
  unsigned int v57; // ebp
  bool v58; // zf
  unsigned int v59; // edx
  unsigned int v60; // ebp
  __int64 v61; // r9
  __int64 v62; // rax
  unsigned int CertVerify; // eax
  int v64; // edi
  int v65; // ebx
  __int64 v66; // r9
  int v67; // ebp
  __int16 v68; // cx
  _BYTE *v69; // rdx
  int v70; // eax
  unsigned int v71; // [rsp+30h] [rbp-68h] BYREF
  unsigned int v72; // [rsp+34h] [rbp-64h]
  int v73; // [rsp+38h] [rbp-60h]
  void *Src; // [rsp+40h] [rbp-58h]
  struct _UNICODE_STRING DestinationString; // [rsp+48h] [rbp-50h] BYREF
  size_t Size; // [rsp+A0h] [rbp+8h] BYREF
  unsigned int v77; // [rsp+B0h] [rbp+18h]
  unsigned int v78; // [rsp+B8h] [rbp+20h]

  v78 = 0;
  v4 = 0;
  v71 = 0;
  v5 = 0;
  v6 = *((_BYTE *)this + 233);
  v7 = 0;
  Src = 0i64;
  v77 = 0;
  v8 = *((_QWORD *)this + 1);
  v72 = 0;
  LODWORD(Size) = 0;
  v9 = v6 != 0 ? 13 : 5;
  v73 = v6 != 0 ? 13 : 5;
  v10 = v6 != 0 ? 12 : 4;
  if ( *(_DWORD *)(v8 + 48) == 4 )
  {
    if ( !*((_QWORD *)this + 106) )
      return 590624;
    goto LABEL_3;
  }
  if ( !*((_BYTE *)this + 1315) )
  {
LABEL_3:
    if ( (*((_DWORD *)this + 16) & 0x80800) != 0 )
      CSsl3TlsContext::FreeTlsClientAuthHandshakeHashes(this);
    goto LABEL_5;
  }
  v42 = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *))(*(_QWORD *)this + 248i64))(this);
  if ( v42 )
  {
    if ( *((_BYTE *)this + 922) )
    {
      UserMappingDataMsg = CreateUserMappingDataMsg(
                             0i64,
                             0,
                             *(unsigned __int16 **)(*((_QWORD *)this + 10) + 872i64),
                             *(unsigned __int16 **)(*((_QWORD *)this + 10) + 880i64));
      if ( !UserMappingDataMsg )
      {
        OutputBuffer = 1359;
        v44 = 151;
        v45 = 1359;
        goto LABEL_117;
      }
      v5 = v10 + UserMappingDataMsg;
      v72 = v5;
    }
    v4 = *(_DWORD *)(v42 + 448);
    v46 = this;
    Src = *(void **)(v42 + 440);
    v77 = v4;
    if ( v4 > 0x3FFF )
    {
      OutputBuffer = 1359;
      v44 = 150;
      v45 = 1359;
LABEL_118:
      CSslContext::SetErrorAndFatalAlert((__int64)v46, v44, v45, 0x50u);
      return OutputBuffer;
    }
    LODWORD(Size) = v4 + v10 + 3;
    OutputBuffer = CSsl3TlsClientContext::GenerateCertVerify(this, 0i64, &v71);
    if ( OutputBuffer )
      return OutputBuffer;
    v78 = v10 + v71;
  }
  else
  {
    v47 = *((_QWORD *)this + 10);
    v48 = *(_DWORD *)(v47 + 212);
    if ( (g_dwEventLogging & 2) != 0 )
    {
      RtlInitUnicodeString(&DestinationString, (PCWSTR)(v47 + 216));
      SchEventWrite(&SSLEVENT_NO_CLIENT_CERT_FOUND, L"du", v48, &DestinationString);
    }
    if ( (*((_BYTE *)this + 64) & 0x30) != 0 )
    {
      v49 = 2;
      if ( (*((_BYTE *)this + 32) & 4) != 0 )
      {
        v50 = *((_DWORD *)this + 13);
        v51 = *((_DWORD *)this + 12) + 2;
        if ( v50 )
        {
          if ( (*((_BYTE *)this + 56) & 1) != 0 )
            v50 -= v51 % v50;
          v51 += v50;
        }
        v49 = *((_DWORD *)this + 11) + v51;
      }
      v7 = v49 + *((_DWORD *)this + 15);
    }
    else
    {
      LODWORD(Size) = v10 + 3;
    }
  }
LABEL_5:
  v11 = *((_BYTE *)this + 233);
  v12 = *((_WORD *)this + 16);
  v13 = v5 + v78 + Size + v10 + *((_DWORD *)this + 240);
  if ( v11 )
  {
    v16 = v9 + v13;
  }
  else
  {
    if ( (v12 & 4) != 0 )
    {
      v14 = *((_DWORD *)this + 12) + v13;
      v15 = *((_DWORD *)this + 13);
      if ( v15 )
      {
        if ( (*((_BYTE *)this + 56) & 1) != 0 )
          v15 -= v14 % v15;
        v14 += v15;
      }
      v13 = *((_DWORD *)this + 11) + v14;
    }
    v16 = *((_DWORD *)this + 15) + v13;
  }
  v17 = v7 + v16;
  v18 = 1;
  if ( (v12 & 4) != 0 )
  {
    v19 = *((_DWORD *)this + 13);
    v20 = *((_DWORD *)this + 12) + 1;
    if ( v19 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v19 -= v20 % v19;
      v20 += v19;
    }
    v18 = *((_DWORD *)this + 11) + v20;
  }
  if ( (*((_BYTE *)this + 64) & 0x30) != 0 )
    v21 = v11 != 0 ? 48 : 40;
  else
    v21 = v11 != 0 ? 24 : 16;
  if ( (v12 & 1) != 0 )
  {
    v22 = *((_DWORD *)this + 12) + v21;
    v23 = *((_DWORD *)this + 13);
    if ( v23 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v23 -= v22 % v23;
      v22 += v23;
    }
    v21 = *((_DWORD *)this + 11) + v22;
  }
  OutputBuffer = CSsl3TlsContext::AllocateOutputBuffer(this, a2, v17 + v21 + v18 + 2 * *((_DWORD *)this + 15));
  if ( OutputBuffer )
    return OutputBuffer;
  if ( v7 )
  {
    v52 = *((_BYTE *)this + 233) && (*((_BYTE *)this + 32) & 4) != 0 ? *((unsigned int *)this + 11) : 0i64;
    *(_WORD *)(v52 + v9 + *((_QWORD *)a2 + 1) + *((unsigned int *)a2 + 1)) = 10497;
    v53 = CSsl3TlsContext::WrapMessage((__int64)this, (__int64)a2, 21, 2u);
    OutputBuffer = v53;
    if ( v53 )
    {
      CSslContext::SetError((__int64)this, 951, v53);
      return OutputBuffer;
    }
  }
  v25 = 0;
  if ( !*((_BYTE *)this + 233) && (*((_BYTE *)this + 32) & 4) != 0 )
    v26 = *((_DWORD *)this + 11);
  else
    v26 = 0;
  v27 = v9 + *((unsigned int *)a2 + 1);
  v28 = 0;
  v29 = (_BYTE *)(*((_QWORD *)a2 + 1) + v27 + v26);
  if ( v72 )
  {
    v54 = CreateUserMappingDataMsg(
            &v29[v10],
            v72,
            *(unsigned __int16 **)(*((_QWORD *)this + 10) + 872i64),
            *(unsigned __int16 **)(*((_QWORD *)this + 10) + 880i64));
    if ( !v54 )
      return 1359;
    SetHandshakeHeader((__int64)v29, 23, 0i64, v54, *((_WORD *)this + 110), *((unsigned __int8 *)this + 233));
    if ( *((_BYTE *)this + 233) )
    {
      ++*((_WORD *)this + 110);
      v28 = 1;
    }
    v25 = v10 + v54;
    if ( !*((_BYTE *)this + 1032) )
    {
      LOBYTE(v55) = 1;
      OutputBuffer = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, _BYTE *, _QWORD, __int64))(*(_QWORD *)this
                                                                                                  + 504i64))(
                       this,
                       v29,
                       v25,
                       v55);
    }
    if ( !OutputBuffer )
    {
      v29 += v25;
      goto LABEL_27;
    }
    v45 = OutputBuffer;
    v44 = 1001;
LABEL_117:
    v46 = this;
    goto LABEL_118;
  }
LABEL_27:
  if ( !(_DWORD)Size )
    goto LABEL_28;
  v56 = v4;
  v57 = HIWORD(v4);
  v58 = *((_BYTE *)this + 233) == 0;
  LODWORD(Size) = v77 >> 8;
  if ( v58 )
  {
    memcpy_0(v29 + 7, Src, v56);
    v59 = v77;
    v29[5] = Size;
    v29[6] = v59;
    v29[4] = v57;
  }
  else
  {
    memcpy_0(v29 + 15, Src, v56);
    v59 = v77;
    v29[13] = Size;
    v29[14] = v59;
    v29[12] = v57;
  }
  v60 = v59 + v10 + 3;
  SetHandshakeHeader((__int64)v29, 11, 0i64, v59 + 3, *((_WORD *)this + 110), *((unsigned __int8 *)this + 233));
  if ( *((_BYTE *)this + 233) )
  {
    ++v28;
    ++*((_WORD *)this + 110);
  }
  if ( !*((_BYTE *)this + 1032) )
  {
    LOBYTE(v61) = 1;
    OutputBuffer = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, _BYTE *, _QWORD, __int64))(*(_QWORD *)this
                                                                                                + 504i64))(
                     this,
                     v29,
                     v60,
                     v61);
  }
  if ( OutputBuffer )
  {
    v45 = OutputBuffer;
    v44 = 1002;
    goto LABEL_117;
  }
  v29 += v60;
  v25 += v60;
LABEL_28:
  v30 = *((_DWORD *)this + 240);
  v31 = (__int16 *)((char *)this + 220);
  v32 = *((_WORD *)this + 110);
  v33 = (const void *)*((_QWORD *)this + 119);
  LODWORD(Size) = v30 + v10;
  SetHandshakeHeader((__int64)v29, 16, v33, v30, v32, *((unsigned __int8 *)this + 233));
  if ( *((_BYTE *)this + 233) )
  {
    ++v28;
    ++*v31;
  }
  if ( !*((_BYTE *)this + 1032) )
  {
    LOBYTE(v34) = 1;
    OutputBuffer = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, _BYTE *, _QWORD, __int64))(*(_QWORD *)this
                                                                                                + 504i64))(
                     this,
                     v29,
                     (unsigned int)Size,
                     v34);
  }
  if ( OutputBuffer )
  {
    v45 = OutputBuffer;
    v44 = 1003;
    goto LABEL_117;
  }
  v35 = &v29[(unsigned int)Size];
  v36 = Size + v25;
  if ( (*((_DWORD *)this + 34) & 0x8000000) == 0 || *((_BYTE *)this + 1032) )
    goto LABEL_38;
  v37 = *(_QWORD *)this;
  if ( (unsigned int)(*(_DWORD *)(*((_QWORD *)this + 1) + 48i64) - 2) > 2 )
  {
    v62 = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *))(v37 + 160))(this);
    OutputBuffer = MakeRsaSessionKeysHelper(this, v62);
    (*(void (__fastcall **)(CSsl3TlsClientContext *, _QWORD))(*(_QWORD *)this + 168i64))(this, 0i64);
  }
  else
  {
    v38 = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *))(v37 + 144))(this);
    v39 = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *))(*(_QWORD *)this + 160i64))(this);
    OutputBuffer = MakeEccDhPskSessionKeysHelper(this, v39, v38, 0);
    (*(void (__fastcall **)(CSsl3TlsClientContext *, _QWORD))(*(_QWORD *)this + 168i64))(this, 0i64);
    (*(void (__fastcall **)(CSsl3TlsClientContext *, _QWORD))(*(_QWORD *)this + 152i64))(this, 0i64);
  }
  if ( !OutputBuffer )
  {
LABEL_38:
    if ( !v78 )
      goto LABEL_39;
    CertVerify = CSsl3TlsClientContext::GenerateCertVerify(this, &v35[v10], (unsigned int *)&Size);
    OutputBuffer = CertVerify;
    if ( CertVerify == 590684 )
    {
      v64 = Size;
      if ( (unsigned int)Size > *(_DWORD *)a2 )
      {
        OutputBuffer = 1359;
      }
      else
      {
        memcpy_0(*((void **)a2 + 1), v35, (unsigned int)Size);
        *((_DWORD *)a2 + 1) = v64;
      }
    }
    else if ( !CertVerify )
    {
      v65 = Size;
      SetHandshakeHeader((__int64)v35, 15, 0i64, Size, *v31, *((unsigned __int8 *)this + 233));
      if ( *((_BYTE *)this + 233) )
        ++*v31;
      v67 = v65 + v10;
      LOBYTE(v66) = 1;
      CcsAndFinishMessage = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, unsigned __int8 *, _QWORD, __int64))(*(_QWORD *)this + 504i64))(
                              this,
                              v35,
                              v65 + v10,
                              v66);
      OutputBuffer = CcsAndFinishMessage;
      if ( CcsAndFinishMessage )
      {
        v44 = 1004;
        goto LABEL_116;
      }
      v36 += v67;
LABEL_39:
      if ( *((_BYTE *)this + 233) )
      {
        v68 = *((_WORD *)this + 17);
        v69 = (_BYTE *)*((_QWORD *)a2 + 1);
        v69[1] = HIBYTE(v68);
        v69[11] = BYTE1(v36);
        v70 = v36 + v73;
        v69[2] = v68;
        *v69 = 22;
        v69[12] = v36;
        *((_DWORD *)a2 + 1) += v70;
        goto LABEL_41;
      }
      CcsAndFinishMessage = CSsl3TlsContext::WrapMessage((__int64)this, (__int64)a2, 22, v36);
      OutputBuffer = CcsAndFinishMessage;
      if ( !CcsAndFinishMessage )
      {
LABEL_41:
        CcsAndFinishMessage = CSsl3TlsContext::GenerateCcsAndFinishMessage(this, a2);
        OutputBuffer = CcsAndFinishMessage;
        if ( !CcsAndFinishMessage )
          return OutputBuffer;
        v44 = 152;
        goto LABEL_116;
      }
      v44 = 952;
LABEL_116:
      v45 = CcsAndFinishMessage;
      goto LABEL_117;
    }
    *v31 -= v28;
  }
  return OutputBuffer;
}
// 18000227D: variable 'v34' is possibly undefined
// 18002C3CB: variable 'v55' is possibly undefined
// 18002C4C8: variable 'v61' is possibly undefined
// 18002C5FC: variable 'v66' is possibly undefined

//----- (0000000180002410) ----------------------------------------------------
void __fastcall CSsl3TlsContext::FreeTlsClientAuthHandshakeHashes(CSsl3TlsContext *this)
{
  unsigned int v2; // edi
  __int64 v3; // rcx

  *((_DWORD *)this + 180) = 0;
  if ( *((_DWORD *)this + 137) > 1u )
  {
    v2 = 1;
    do
    {
      v3 = *((_QWORD *)this + v2 + 74);
      if ( v3 )
      {
        SslFreeObject(v3, 0i64);
        *((_QWORD *)this + v2 + 74) = 0i64;
      }
      ++v2;
    }
    while ( v2 < *((_DWORD *)this + 137) );
    *((_DWORD *)this + 137) = 1;
  }
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180002488) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::CheckForClientCertificatePrivateKeys(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2)
{
  __int64 result; // rax

  if ( !a2 )
    return 87i64;
  result = 0i64;
  *a2 = 0;
  if ( *((_BYTE *)this + 923) )
  {
    result = CSsl3TlsClientContext::CheckForClientCred(this);
    if ( *((_BYTE *)this + 923) )
    {
      *((_DWORD *)this + 18) = *((_DWORD *)this + 17);
      result = 590610i64;
      *((_DWORD *)this + 17) = 77;
    }
    else if ( *((_BYTE *)this + 924) || (_DWORD)result != -2146893024 )
    {
      if ( !(_DWORD)result || (_DWORD)result == 590624 || (_DWORD)result == -2146893024 )
        return result;
    }
    else
    {
      result = 590624i64;
    }
    *a2 = 1;
  }
  return result;
}

//----- (00000001800024D0) ----------------------------------------------------
__int64 __fastcall MakeEccDhPskSessionKeysHelper(struct CSsl3TlsContext *a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v8; // rcx
  _WORD *v9; // r9
  int v10; // eax
  unsigned int v11; // edi
  __int64 v12; // rax
  __int64 *v13; // rcx
  __int64 v14; // rcx
  int v15; // eax
  unsigned int v16; // edi
  __int64 v17; // r8
  __int64 *v18; // rdx
  int v19; // r8d
  int v20; // r9d
  __int64 v21; // rcx
  __int64 v22; // rcx
  unsigned int v23; // edi
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r15
  __int64 v29; // rcx
  __int64 v30; // rax
  int v31; // eax
  unsigned int v32; // esi
  __int64 *v33; // rax
  __int64 v34; // rcx
  __int64 v35; // rcx
  int v37; // edx
  unsigned int v38; // [rsp+60h] [rbp-A0h] BYREF
  int v39; // [rsp+64h] [rbp-9Ch] BYREF
  __int64 v40; // [rsp+68h] [rbp-98h] BYREF
  int v41; // [rsp+70h] [rbp-90h] BYREF
  int v42; // [rsp+74h] [rbp-8Ch]
  __int128 *v43; // [rsp+78h] [rbp-88h]
  struct _EVENT_DATA_DESCRIPTOR v44; // [rsp+80h] [rbp-80h] BYREF
  __int128 v45; // [rsp+90h] [rbp-70h] BYREF
  __int128 v46; // [rsp+A0h] [rbp-60h]
  __int128 v47; // [rsp+B0h] [rbp-50h]
  char v48; // [rsp+C0h] [rbp-40h] BYREF
  char v49[64]; // [rsp+100h] [rbp+0h] BYREF

  v40 = 0i64;
  v42 = 0;
  v45 = 0i64;
  v46 = 0i64;
  v47 = 0i64;
  memset_0(v49, 0, sizeof(v49));
  v38 = 0;
  if ( !a1 )
    return 87i64;
  v43 = &v45;
  v10 = *((_DWORD *)a1 + 34);
  v41 = 0;
  if ( (v10 & 0x8000000) != 0 )
  {
    v11 = *((unsigned __int16 *)a1 + 17);
    v12 = (*(__int64 (__fastcall **)(struct CSsl3TlsContext *, _QWORD))(*(_QWORD *)a1 + 512i64))(a1, 0i64);
    v13 = (__int64 *)*((_QWORD *)a1 + 1);
    if ( v13 )
      v14 = *v13;
    else
      v14 = 0i64;
    v15 = SslComputeSessionHash(v14, v12, v11, v49, 64, &v38, 0);
    v16 = v15;
    if ( v15 )
    {
      CSslContext::SetErrorAndFatalAlert((__int64)a1, 604, v15, 0x33u);
      return v16;
    }
    v17 = 1i64;
    *(_QWORD *)&v45 = v38 | 0x1900000000i64;
    *((_QWORD *)&v45 + 1) = v49;
  }
  else
  {
    *((_QWORD *)&v45 + 1) = (char *)a1 + 272;
    v17 = 2i64;
    *(_QWORD *)&v45 = 0x1400000020i64;
    *((_QWORD *)&v46 + 1) = (char *)a1 + 304;
    *(_QWORD *)&v46 = 0x1500000020i64;
  }
  v18 = (__int64 *)*((_QWORD *)a1 + 1);
  v42 = v17;
  if ( *((_DWORD *)v18 + 12) == 4 )
  {
    v9 = (_WORD *)*((_QWORD *)a1 + 106);
    if ( !v9 )
      return 590624i64;
    if ( !*v9 )
    {
      CSslContext::SetErrorAndFatalAlert((__int64)a1, 602, 87, 0x73u);
      return 87i64;
    }
    v8 = 2i64 * (unsigned int)v17;
    v17 = (unsigned int)(v17 + 1);
    *((_DWORD *)&v45 + 2 * v8 + 1) = 23;
    *((_DWORD *)&v45 + 2 * v8) = (unsigned __int16)*v9;
    *((_QWORD *)&v45 + v8 + 1) = v9 + 1;
    v42 = v17;
  }
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
  {
    McGenEventWrite_EventWriteTransfer(v8, &GenerateMasterKeyStart, v17, (__int64)v9, &v44);
    v18 = (__int64 *)*((_QWORD *)a1 + 1);
  }
  if ( (*((_BYTE *)a1 + 32) & 1) != 0 )
  {
    v18 = (__int64 *)*((_QWORD *)a1 + 1);
    if ( v18 )
    {
      v19 = *((_DWORD *)v18 + 7);
      v20 = *((unsigned __int16 *)a1 + 17);
LABEL_13:
      v21 = *v18;
      goto LABEL_14;
    }
  }
  v20 = *((unsigned __int16 *)a1 + 17);
  v19 = 0;
  if ( v18 )
    goto LABEL_13;
  v21 = 0i64;
LABEL_14:
  v23 = SslGenerateMasterKey(v21, a2, a3, &v40, v20, v19, &v41, 0i64, 0, &v38, (unsigned int)(a4 != 0) + 1);
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EventWriteTransfer(v22, &GenerateMasterKeyStop, v24, v25, &v44);
  if ( v23 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)a1, 602, v23, 0x33u);
    return v23;
  }
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)a1 + 11) + 72i64), 1u);
  v26 = *((_QWORD *)a1 + 11);
  v39 = 0;
  *(_QWORD *)(v26 + 16) = v40;
  v27 = *((_QWORD *)a1 + 20);
  v28 = v40;
  if ( v27 )
  {
    SslFreeObject(v27, 0i64);
    *((_QWORD *)a1 + 20) = 0i64;
  }
  v29 = *((_QWORD *)a1 + 21);
  if ( v29 )
  {
    SslFreeObject(v29, 0i64);
    *((_QWORD *)a1 + 21) = 0i64;
  }
  if ( (*((_BYTE *)a1 + 32) & 1) == 0 )
    goto LABEL_28;
  v30 = *((_QWORD *)a1 + 1);
  if ( !v30 || !*(_DWORD *)(v30 + 28) )
    goto LABEL_28;
  v44.Ptr = 0x400000000i64;
  *(_QWORD *)&v44.Size = &v48;
  v31 = (*(__int64 (__fastcall **)(struct CSsl3TlsContext *, _QWORD, int *, struct _EVENT_DATA_DESCRIPTOR *, _QWORD, _QWORD))(*(_QWORD *)a1 + 128i64))(
          a1,
          0i64,
          &v39,
          &v44,
          0i64,
          0i64);
  v32 = v31;
  if ( v31 )
  {
    v37 = 601;
LABEL_46:
    CSslContext::SetErrorAndFatalAlert((__int64)a1, v37, v31, 0x33u);
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)a1 + 11) + 72i64));
    return v32;
  }
  v33 = (__int64 *)*((_QWORD *)a1 + 1);
  if ( v33 )
    v34 = *v33;
  else
    v34 = 0i64;
  v31 = SslGenerateSessionKeys(v34, v28, (char *)a1 + 160, (char *)a1 + 168, &v44, 0);
  v32 = v31;
  if ( v31 )
  {
    v37 = 600;
    goto LABEL_46;
  }
LABEL_28:
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)a1 + 11) + 72i64));
  v35 = 8i64;
  if ( !a4 )
    v35 = 6i64;
  LsaIModifyPerformanceCounter(v35);
  return 0i64;
}
// 18002C76C: variable 'v8' is possibly undefined
// 18002C76C: variable 'v9' is possibly undefined
// 18002C78A: variable 'v22' is possibly undefined
// 18002C78A: variable 'v24' is possibly undefined
// 18002C78A: variable 'v25' is possibly undefined
// 180084BE0: using guessed type EVENT_DESCRIPTOR GenerateMasterKeyStop;
// 180084BF0: using guessed type EVENT_DESCRIPTOR GenerateMasterKeyStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);
// 180098428: using guessed type __int64 __fastcall SslGenerateSessionKeys(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 1800984A0: using guessed type __int64 __fastcall SslGenerateMasterKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 180098530: using guessed type __int64 __fastcall SslComputeSessionHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180002858) ----------------------------------------------------
__int64 __fastcall CSessionCacheClientItem::CloneCacheElement(
        CSessionCacheClientItem *this,
        struct CSessionCacheManager *a2,
        struct CSessionCacheClientItem **a3)
{
  __int64 result; // rax
  struct CSessionCacheClientItem *v6; // rcx
  struct CSessionCacheClientItem *v7; // [rsp+30h] [rbp+8h] BYREF

  v7 = 0i64;
  result = CSessionCacheManager::CacheRetrieveNewClientItem(a2, *((const unsigned __int16 **)this + 46), &v7);
  if ( !(_DWORD)result )
  {
    v6 = v7;
    *((_DWORD *)v7 + 42) = *((_DWORD *)this + 42);
    *(_QWORD *)((char *)v6 + 188) = *(_QWORD *)((char *)this + 188);
    result = 0i64;
    *((_QWORD *)v6 + 48) = this;
    *a3 = v6;
  }
  return result;
}

//----- (00000001800028C8) ----------------------------------------------------
void __fastcall CSessionCacheManager::PurgeCacheForProcessId(CSessionCacheManager *this, int a2)
{
  unsigned int v2; // edi

  v2 = 0;
  if ( *((_DWORD *)this + 8) )
  {
    if ( *((_DWORD *)this + 12) )
    {
      do
        CSessionCacheTable::ExpireItemsBoundToProcess((CSessionCacheTable *)(*((_QWORD *)this + 5) + 152i64 * v2++), a2);
      while ( v2 < *((_DWORD *)this + 12) );
    }
    CSessionCacheManager::CacheExpireElements(this, 0, 0);
  }
}

//----- (0000000180002928) ----------------------------------------------------
void __fastcall CSessionCacheTable::ExpireItemsBoundToProcess(CSessionCacheTable *this, int a2)
{
  struct _RTL_RESOURCE *v2; // rbp
  _QWORD **v4; // r14
  _QWORD *v5; // rdi
  _QWORD *v6; // rbx

  v2 = (struct _RTL_RESOURCE *)((char *)this + 48);
  v4 = (_QWORD **)((char *)this + 16);
  RtlAcquireResourceShared((PRTL_RESOURCE)((char *)this + 48), 1u);
  v5 = *v4;
  while ( v5 != v4 )
  {
    v6 = v5;
    v5 = (_QWORD *)*v5;
    RtlAcquireResourceShared((PRTL_RESOURCE)(v6 - 29), 1u);
    if ( *((_DWORD *)v6 - 8) == a2 )
    {
      RtlConvertSharedToExclusive((PRTL_RESOURCE)(v6 - 29));
      if ( *((_DWORD *)v6 - 8) == a2 )
      {
        *((_DWORD *)v6 - 8) = 0;
        *((_WORD *)v6 - 34) = 0;
      }
    }
    RtlReleaseResource((PRTL_RESOURCE)(v6 - 29));
  }
  RtlReleaseResource(v2);
}

//----- (00000001800029E8) ----------------------------------------------------
__int64 __fastcall MontgomeryGetEccPublicKeyBlob(
        unsigned __int8 *Src,
        size_t Size,
        struct _BCRYPT_ECCKEY_BLOB *a3,
        unsigned int a4)
{
  unsigned int v4; // ebx

  v4 = 0;
  if ( a3 && Src && (unsigned __int64)(unsigned int)(2 * Size) + 8 <= a4 )
    memcpy_0(&a3[1], Src, (unsigned int)Size);
  else
    return (unsigned int)-2146893048;
  return v4;
}

//----- (0000000180002A40) ----------------------------------------------------
__int64 __fastcall MontgomeryGetKeyExchangeBlob(
        struct _BCRYPT_ECCKEY_BLOB *a1,
        unsigned __int8 *a2,
        unsigned __int8 *a3)
{
  unsigned int cbKey_low; // ecx
  unsigned int v6; // ebx
  unsigned __int8 v7; // al

  if ( a1->cbKey > 0xFF )
  {
    return 87;
  }
  else
  {
    cbKey_low = LOBYTE(a1->cbKey);
    v6 = 0;
    if ( a2 )
    {
      v7 = *a3;
      *a3 = cbKey_low;
      if ( v7 < (unsigned __int8)cbKey_low )
        return (unsigned int)-2146893023;
      else
        memcpy_0(a2, &a1[1], cbKey_low);
    }
    else
    {
      *a3 = cbKey_low;
    }
  }
  return v6;
}

//----- (0000000180002A9C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::DigestNewSessionTicket(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  CCipherMill *v6; // rcx
  unsigned int v7; // ebx
  HLOCAL v8; // rsi
  unsigned __int8 v10; // r9
  int v11; // edx
  __int64 v12; // [rsp+20h] [rbp-48h]

  v6 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 61i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
    v6 = WPP_GLOBAL_Control;
  }
  if ( (*((_DWORD *)this + 34) & 0x400000) == 0 )
  {
    if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)v6 + 2), 62i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
    v10 = 10;
    v11 = 1402;
    goto LABEL_21;
  }
  if ( a3 < 6 )
  {
    if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)v6 + 2), 63i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids, a3);
    CSslContext::SetErrorAndFatalAlert((__int64)this, 1400, -2146893018, 0x32u);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x40u,
        (__int64)&WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
        -2146893018,
        -2146893018);
    return 2148074278i64;
  }
  if ( a3 > 0x10005 )
  {
    if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)v6 + 2), 65i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids, a3);
    v10 = 50;
    v11 = 1400;
    goto LABEL_21;
  }
  v7 = a2[5] | (a2[4] << 8);
  if ( a3 - 6 != v7 )
  {
    v10 = 50;
    v11 = 1401;
LABEL_21:
    CSslContext::SetErrorAndFatalAlert((__int64)this, v11, -2146893018, v10);
    return 2148074278i64;
  }
  v8 = SPExternalAlloc(v7);
  if ( !v8 )
    return 14i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 66i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids, v7);
  memcpy_0(v8, a2 + 6, v7);
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64), 1u);
  CSessionCacheClientItem::SetSessionTicket(
    *((CSessionCacheClientItem **)this + 165),
    (unsigned __int8 *)v8,
    v7,
    0i64,
    0,
    0,
    0,
    0,
    0);
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    LODWORD(v12) = 0;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x43u,
      (__int64)&WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
      0,
      v12);
  }
  return 0i64;
}
// 18002C94B: variable 'v12' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180002BF0) ----------------------------------------------------
void __fastcall CSessionCacheClientItem::SetSessionTicket(
        CSessionCacheClientItem *this,
        unsigned __int8 *a2,
        int a3,
        unsigned __int8 *a4,
        char a5,
        unsigned int a6,
        unsigned int a7,
        unsigned int a8,
        __int16 a9)
{
  void *v11; // rcx
  void *v14; // rcx
  DWORD TickCount; // eax
  int v16; // ebx
  unsigned int v17; // esi
  unsigned int ElapsedTime; // eax
  unsigned int v19; // ecx

  v11 = (void *)*((_QWORD *)this + 53);
  if ( v11 )
    SPExternalFree(v11);
  *((_DWORD *)this + 108) = a3;
  *((_QWORD *)this + 53) = a2;
  if ( (a9 & 0x2000) != 0 )
  {
    v14 = (void *)*((_QWORD *)this + 25);
    if ( v14 )
      SPExternalFree(v14);
    *((_BYTE *)this + 208) = a5;
    *((_DWORD *)this + 53) = a6;
    *((_DWORD *)this + 103) = a7;
    *((_QWORD *)this + 25) = a4;
    TickCount = GetTickCount();
    v16 = 1000 * *((_DWORD *)this + 103);
    v17 = a8;
    *((_DWORD *)this + 104) = TickCount;
    if ( CSslGlobals::m_dwClientLifespan < a8 )
      v17 = CSslGlobals::m_dwClientLifespan;
    ElapsedTime = GetElapsedTime(*((_DWORD *)this + 69));
    v19 = v16 + ElapsedTime;
    if ( v16 + ElapsedTime <= ElapsedTime )
    {
      v19 = v17;
    }
    else if ( v19 >= v17 )
    {
      v19 = v17;
    }
    *((_DWORD *)this + 70) = v19;
  }
}

//----- (0000000180002C5C) ----------------------------------------------------
char __fastcall CSessionCacheManager::CacheExpireElements(CSessionCacheManager *this, char a2, char a3)
{
  int v6; // eax
  char v7; // di
  unsigned int v8; // esi
  int v9; // edx
  char v10; // r9

  v6 = _InterlockedIncrement((volatile signed __int32 *)this + 25);
  v7 = 0;
  if ( !a2 || v6 <= 1 )
  {
    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 56));
    v8 = 0;
    if ( *((_DWORD *)this + 12) )
    {
      v9 = *((_DWORD *)this + 7);
      do
      {
        if ( !a2 || (v10 = 1, a3) )
          v10 = 0;
        CSessionCacheTable::ExpireAndPurgeItems(
          (CSessionCacheTable *)(*((_QWORD *)this + 5) + 152i64 * v8),
          (int *)this + 8,
          v9,
          v10);
        v9 = *((_DWORD *)this + 7);
        if ( *((_DWORD *)this + 8) < v9 && a2 && !a3 )
          break;
        ++v8;
      }
      while ( v8 < *((_DWORD *)this + 12) );
    }
    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 56));
    v7 = 1;
  }
  _InterlockedDecrement((volatile signed __int32 *)this + 25);
  return v7;
}

//----- (0000000180002D50) ----------------------------------------------------
unsigned __int8 __fastcall CSessionCacheTable::ExpireAndPurgeItems(CSessionCacheTable *this, int *a2, int a3, char a4)
{
  struct _RTL_RESOURCE *v8; // r12
  DWORD TickCount; // edi
  char *v10; // r14
  int *v11; // rbx
  __int64 *v12; // rbx
  int *v14; // rax
  int *v15; // r9
  unsigned int v16; // r8d
  unsigned int v17; // edx
  char v18; // cl
  __int64 v19; // rdx
  int *v20; // rcx
  int **v21; // r8
  __int64 **v22; // rsi
  __int64 v23; // rcx
  __int64 ***v24; // rax
  __int64 v25; // rcx
  int **v26; // rax
  __int64 **v27; // rax
  __int64 v28; // rax
  __int64 *v29; // rcx
  __int64 *v30; // r8
  __int64 *v31; // rdx
  __int64 *v32; // [rsp+20h] [rbp-38h] BYREF
  __int64 **v33; // [rsp+28h] [rbp-30h]

  v8 = (struct _RTL_RESOURCE *)((char *)this + 48);
  TickCount = GetTickCount();
  v33 = &v32;
  v32 = (__int64 *)&v32;
  RtlAcquireResourceExclusive(v8, 1u);
  v10 = (char *)this + 32;
  v11 = (int *)*((_QWORD *)this + 4);
  while ( v11 != (int *)v10 )
  {
    v14 = v11;
    v15 = v11;
    v11 = *(int **)v11;
    if ( *(v14 - 22) > 1 )
      continue;
    v16 = *(v14 - 10);
    v17 = TickCount - *(v14 - 11);
    if ( TickCount <= *(v14 - 11) )
    {
      if ( TickCount < *(v14 - 11) && v17 - 1 >= v16 )
      {
LABEL_34:
        *((_WORD *)v14 - 42) = 0;
        v18 = 0;
        goto LABEL_8;
      }
    }
    else if ( v17 > v16 )
    {
      goto LABEL_34;
    }
    v18 = *((_BYTE *)v14 - 84);
LABEL_8:
    if ( *a2 > a3 )
    {
      *((_WORD *)v14 - 42) = 0;
    }
    else if ( v18 == 1 )
    {
      continue;
    }
    if ( *((_BYTE *)v14 - 83) != 1 )
    {
      v19 = *((_QWORD *)v14 - 4);
      v20 = v14 - 8;
      if ( *(int **)(v19 + 8) != v14 - 8 )
        goto LABEL_32;
      v21 = (int **)*((_QWORD *)v20 + 1);
      if ( *v21 != v20 )
        goto LABEL_32;
      *v21 = (int *)v19;
      v22 = (__int64 **)(v14 - 4);
      *(_QWORD *)(v19 + 8) = v21;
      v23 = *((_QWORD *)v14 - 2);
      if ( *(int **)(v23 + 8) != v14 - 4 )
        goto LABEL_32;
      v24 = (__int64 ***)v22[1];
      if ( *v24 != v22 )
        goto LABEL_32;
      *v24 = (__int64 **)v23;
      *(_QWORD *)(v23 + 8) = v24;
      v25 = *(_QWORD *)v15;
      if ( *(int **)(*(_QWORD *)v15 + 8i64) != v15 )
        goto LABEL_32;
      v26 = (int **)*((_QWORD *)v15 + 1);
      if ( *v26 != v15 )
        goto LABEL_32;
      *v26 = (int *)v25;
      *(_QWORD *)(v25 + 8) = v26;
      _InterlockedDecrement(a2);
      LsaIModifyPerformanceCounter(4i64);
      v27 = v33;
      if ( *v33 != (__int64 *)&v32 )
        goto LABEL_32;
      v22[1] = (__int64 *)v33;
      *v22 = (__int64 *)&v32;
      *v27 = (__int64 *)v22;
      v33 = v22;
      if ( *a2 < a3 && a4 )
        break;
    }
  }
  RtlReleaseResource(v8);
  v12 = v32;
  if ( v32 != (__int64 *)&v32 )
  {
    while ( 1 )
    {
      v28 = *v12;
      v29 = v12 - 38;
      v30 = v12;
      v12 = (__int64 *)v28;
      if ( *(__int64 **)(v28 + 8) != v30 )
        break;
      v31 = (__int64 *)v30[1];
      if ( (__int64 *)*v31 != v30 )
        break;
      *v31 = v28;
      *(_QWORD *)(v28 + 8) = v31;
      if ( v29 )
        (*(void (__fastcall **)(__int64 *, __int64))(*v29 + 8))(v29, 1i64);
      if ( v12 == (__int64 *)&v32 )
        return 1;
    }
LABEL_32:
    __fastfail(3u);
  }
  return 1;
}
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);

//----- (0000000180002F90) ----------------------------------------------------
void __fastcall CSessionCacheManager::PurgeCacheForCredentialGroup(
        CSessionCacheManager *this,
        struct CCredentialGroup *a2)
{
  unsigned int v2; // edi

  v2 = 0;
  if ( *((_DWORD *)this + 8) )
  {
    if ( *((_DWORD *)this + 12) )
    {
      do
        CSessionCacheTable::ExpireItemsBoundToCred((CSessionCacheTable *)(*((_QWORD *)this + 5) + 152i64 * v2++), a2);
      while ( v2 < *((_DWORD *)this + 12) );
    }
    CSessionCacheManager::CacheExpireElements(this, 0, 0);
  }
}

//----- (0000000180003000) ----------------------------------------------------
void __fastcall CSessionCacheTable::ExpireItemsBoundToCred(CSessionCacheTable *this, struct CCredentialGroup *a2)
{
  struct _RTL_RESOURCE *v2; // r13
  _QWORD **v4; // r14
  _QWORD *v5; // rdi
  __int64 v6; // rbx
  _QWORD *v7; // rbp

  v2 = (struct _RTL_RESOURCE *)((char *)this + 48);
  v4 = (_QWORD **)((char *)this + 16);
  RtlAcquireResourceShared((PRTL_RESOURCE)((char *)this + 48), 1u);
  v5 = *v4;
  while ( v5 != v4 )
  {
    v6 = *((_QWORD *)a2 + 95);
    v7 = v5;
    v5 = (_QWORD *)*v5;
    RtlAcquireResourceShared((PRTL_RESOURCE)(v7 - 29), 1u);
    if ( v6 == *(_QWORD *)((char *)v7 - 116) )
    {
      RtlConvertSharedToExclusive((PRTL_RESOURCE)(v7 - 29));
      if ( v6 == *(_QWORD *)((char *)v7 - 116) )
        *((_WORD *)v7 - 34) = 0;
    }
    RtlReleaseResource((PRTL_RESOURCE)(v7 - 29));
  }
  RtlReleaseResource(v2);
}

//----- (00000001800030F0) ----------------------------------------------------
__int64 __fastcall SpFreeCredentialsHandle(struct CCredentialGroup *a1, __int64 a2, __int64 a3)
{
  int v4; // edi
  CCipherMill *v5; // rcx
  char v6; // al
  unsigned int v7; // eax
  __int64 v8; // rcx
  __int64 v9; // r8
  __int128 v11; // [rsp+30h] [rbp-48h] BYREF
  char v12[8]; // [rsp+40h] [rbp-38h] BYREF
  int v13; // [rsp+48h] [rbp-30h]
  char v14[16]; // [rsp+58h] [rbp-20h] BYREF

  v4 = 8;
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McTemplateU0p_EtwEventWriteTransfer((__int64)a1, a2, (__int64)a1);
  v5 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x43u, (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, a1);
  if ( a1 )
  {
    CSessionCacheManager::PurgeCacheForCredentialGroup(CSessionCacheManager::m_pSessionCacheManager, a1);
    if ( (*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v12) )
    {
      v6 = v13;
      if ( (v13 & 0x20) != 0 )
      {
        CSessionCacheManager::PurgeCacheForProcessId(CSessionCacheManager::m_pSessionCacheManager, *((_DWORD *)a1 + 53));
        v6 = v13;
      }
      if ( (v6 & 0x40) != 0 )
        v4 = 4;
    }
    v7 = *((_DWORD *)a1 + 184);
    if ( v7 > 1 )
    {
      v11 = 2 * v4 * v7;
      *((_QWORD *)&v11 + 1) = (*(__int64 (**)(void))(LsaTable + 384))();
      if ( *((_QWORD *)&v11 + 1) )
        (*(void (__fastcall **)(__int64, _QWORD, _QWORD, __int128 *, _BYTE))(LsaTable + 496))(5i64, 0i64, 0i64, &v11, 0);
    }
    CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, a1);
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McGenEventWrite_EtwEventWriteTransfer(v8, (__int64)&FchStop, v9, 1, (__int64)v14);
    return 0i64;
  }
  else
  {
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McGenEventWrite_EtwEventWriteTransfer((__int64)v5, (__int64)&FchStop, a3, 1, (__int64)v14);
    return 2148074241i64;
  }
}
// 180003262: variable 'v8' is possibly undefined
// 180003262: variable 'v9' is possibly undefined
// 18002CA46: variable 'v5' is possibly undefined
// 18002CA46: variable 'a3' is possibly undefined
// 180092620: using guessed type __int64 LsaTable;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 1800030F0: using guessed type char var_38[8];

//----- (00000001800032C4) ----------------------------------------------------
unsigned __int8 __fastcall HasTimeElapsed(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // eax

  v3 = a2 - a1;
  if ( a2 <= a1 )
  {
    if ( a2 >= a1 || v3 - 1 < a3 )
      return 0;
  }
  else if ( v3 <= a3 )
  {
    return 0;
  }
  return 1;
}

//----- (00000001800032F0) ----------------------------------------------------
CSessionCacheClientItem *__fastcall CSessionCacheClientItem::`vector deleting destructor'(
        CSessionCacheClientItem *this,
        char a2)
{
  CSessionCacheClientItem::~CSessionCacheClientItem(this);
  if ( (a2 & 1) != 0 )
    SPExternalFree(this);
  return this;
}

//----- (0000000180003328) ----------------------------------------------------
void __fastcall CSessionCacheClientItem::~CSessionCacheClientItem(CSessionCacheClientItem *this)
{
  void *v2; // rcx
  void *v3; // rcx
  void *v4; // rcx
  void *v5; // rcx
  __int64 v6; // rcx
  void *v7; // rcx

  *(_QWORD *)this = &CSessionCacheClientItem::`vftable';
  v2 = (void *)*((_QWORD *)this + 42);
  if ( v2 )
    SPExternalFree(v2);
  v3 = (void *)*((_QWORD *)this + 44);
  if ( v3 )
    CryptMemFree(v3);
  v4 = (void *)*((_QWORD *)this + 50);
  if ( v4 )
    SPExternalFree(v4);
  v5 = (void *)*((_QWORD *)this + 46);
  if ( v5 )
    SPExternalFree(v5);
  v6 = *((_QWORD *)this + 48);
  if ( v6 )
    CSessionCacheTable::DereferenceCacheItemInternal(
      *(CSessionCacheTable **)(v6 + 224),
      *((struct CSessionCacheItem **)this + 48),
      1,
      0);
  v7 = (void *)*((_QWORD *)this + 53);
  if ( v7 )
    SPExternalFree(v7);
  CSessionCacheItem::~CSessionCacheItem(this);
}
// 18007C210: using guessed type void *CSessionCacheClientItem::`vftable';

//----- (00000001800033E0) ----------------------------------------------------
struct CSessionCacheItem **__fastcall CSsl3TlsClientContext::`scalar deleting destructor'(
        struct CSessionCacheItem **this)
{
  CSsl3TlsClientContext::~CSsl3TlsClientContext(this);
  return this;
}

//----- (0000000180003400) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::~CSsl3TlsClientContext(struct CSessionCacheItem **this)
{
  struct CSessionCacheItem *v2; // rcx
  struct CSessionCacheItem *v3; // rdx
  bool v4; // zf
  struct CSessionCacheItem *v5; // rdi
  struct CSessionCacheItem *v6; // rdx
  struct CSessionCacheItem *v7; // rdx
  struct CSessionCacheItem *v8; // rdx
  struct CSessionCacheItem *v9; // rdx
  struct CSessionCacheItem *v10; // rdx
  void **v11; // rcx
  struct CSessionCacheItem *v12; // rdx
  struct CSessionCacheItem *v13; // rdx
  struct CSessionCacheItem *v14; // rdx
  struct CSessionCacheItem *v15; // rcx
  struct CSessionCacheItem *v16; // rcx
  struct CSessionCacheItem *v17; // rcx
  struct CSessionCacheItem *v18; // rcx
  struct CSessionCacheItem *v19; // rcx
  struct CSessionCacheItem *v20; // rdi
  __int64 v21; // rcx
  CSslServerKey *v22; // rcx
  int v23; // ecx
  struct CCredentialGroup *v24; // rdx
  struct CSessionCacheItem *v25; // rcx
  volatile signed __int32 *v26; // rcx
  struct CSessionCacheItem *v27; // rax
  struct CSessionCacheItem *v28; // rcx
  struct CSessionCacheItem *v29; // rdx
  struct CSessionCacheItem *v30; // rdi
  DTlsMsgMgr *v31; // rcx
  struct CSessionCacheItem *v32; // rdx

  *this = (struct CSessionCacheItem *)&CSsl3TlsClientContext::`vftable';
  CSsl3TlsClientContext::CleanupConnectedState((CSsl3TlsClientContext *)this);
  v2 = this[166];
  if ( v2 )
    SPExternalFree(v2);
  if ( ((_DWORD)this[17] & 0x80000) != 0 )
  {
    v28 = this[116];
    if ( v28 )
      (*(void (__fastcall **)(struct CSessionCacheItem *, __int64))(*(_QWORD *)v28 + 8i64))(v28, 1i64);
  }
  v3 = this[167];
  if ( v3 )
    CSslContext::FreeMemory((CSslContext *)this, v3);
  v4 = *((_BYTE *)this + 233) == 0;
  *this = (struct CSessionCacheItem *)&CSsl3TlsContext::`vftable';
  if ( v4 )
  {
    v5 = this[58];
    if ( v5 )
    {
      v32 = this[58];
      if ( *(_QWORD *)v5 && *((_QWORD *)v5 + 3) )
      {
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)v5 + 16i64))(*(_QWORD *)v5, *((_QWORD *)v5 + 3));
        *((_QWORD *)v5 + 3) = 0i64;
        *((_DWORD *)v5 + 4) = 0;
        v32 = this[58];
      }
      CSslContext::FreeMemory((CSslContext *)this, v32);
    }
  }
  else
  {
    v29 = this[71];
    if ( v29 )
      CSslContext::FreeMemory((CSslContext *)this, v29);
    v30 = this[73];
    if ( v30 )
    {
      DTlsHandshakeQueue::~DTlsHandshakeQueue(this[73]);
      operator delete(v30);
      this[73] = 0i64;
    }
    v31 = this[72];
    if ( v31 )
    {
      DTlsMsgMgr::`scalar deleting destructor'(v31);
      this[72] = 0i64;
    }
    CSsl3TlsContext::FreeSavedWriteCipherState((CSsl3TlsContext *)this);
  }
  v6 = this[98];
  if ( v6 )
    CSslContext::FreeMemory((CSslContext *)this, v6);
  v7 = this[99];
  if ( v7 )
    CSslContext::FreeMemory((CSslContext *)this, v7);
  v8 = this[100];
  if ( v8 )
    CSslContext::FreeMemory((CSslContext *)this, v8);
  CSsl3TlsContext::FreeSelectedSrtpParameters((CSsl3TlsContext *)this);
  v9 = this[102];
  if ( v9 )
    CSslContext::FreeMemory((CSslContext *)this, v9);
  CSsl3TlsContext::FreeSelectedTBParameters((CSsl3TlsContext *)this);
  v10 = this[104];
  if ( v10 )
  {
    if ( *((_QWORD *)v10 + 1) )
    {
      (*((void (__fastcall **)(struct CSessionCacheItem **, _QWORD))*this + 2))(this, *((_QWORD *)v10 + 1));
      v10 = this[104];
    }
    (*((void (__fastcall **)(struct CSessionCacheItem **, struct CSessionCacheItem *))*this + 2))(this, v10);
    this[104] = 0i64;
  }
  v11 = (void **)this[105];
  if ( v11 )
  {
    if ( v11[1] )
    {
      SPExternalFree(v11[1]);
      v11 = (void **)this[105];
    }
    if ( v11[3] )
    {
      SPExternalFree(v11[3]);
      v11 = (void **)this[105];
    }
    SPExternalFree(v11);
    this[105] = 0i64;
  }
  v12 = this[106];
  if ( v12 )
    CSslContext::FreeMemory((CSslContext *)this, v12);
  v13 = this[107];
  if ( v13 )
    CSslContext::FreeMemory((CSslContext *)this, v13);
  v14 = this[108];
  if ( v14 )
    CSslContext::FreeMemory((CSslContext *)this, v14);
  CSsl3TlsContext::FreeHandshakeHash((CSsl3TlsContext *)this);
  v15 = this[18];
  *this = (struct CSessionCacheItem *)&CSslContext::`vftable';
  if ( v15 )
    SslFreeObject(v15, 0i64);
  v16 = this[19];
  if ( v16 )
    SslFreeObject(v16, 0i64);
  v17 = this[20];
  if ( v17 )
    SslFreeObject(v17, 0i64);
  v18 = this[21];
  if ( v18 )
    SslFreeObject(v18, 0i64);
  v19 = this[14];
  if ( v19 )
    SslFreeObject(v19, 0i64);
  v20 = this[1];
  if ( v20 )
  {
    v21 = *((_QWORD *)v20 + 106);
    if ( v21 )
      CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v21 + 16));
    CMasterCipherInfo::Dereference(*((CMasterCipherInfo **)v20 + 107));
  }
  v22 = this[3];
  if ( v22 )
    CSslServerKey::Dereference(v22);
  v23 = *((_DWORD *)this + 17);
  if ( (unsigned int)(v23 - 3) > 1 && v23 != 79 && ((_DWORD)this[17] & 0x40000) == 0 )
  {
    v27 = this[11];
    if ( v27 )
      *((_BYTE *)v27 + 236) = 0;
  }
  v24 = this[10];
  if ( v24 )
    CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, v24);
  v25 = this[11];
  if ( v25 )
    CSessionCacheTable::DereferenceCacheItemInternal(*((CSessionCacheTable **)v25 + 28), this[11], 1, 0);
  v26 = (volatile signed __int32 *)this[15];
  if ( v26 && _InterlockedExchangeAdd(v26 + 5, 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(volatile signed __int32 *, __int64))(*(_QWORD *)v26 + 8i64))(v26, 1i64);
  *this = (struct CSessionCacheItem *)&ISslSerialize::`vftable';
}
// 18007C000: using guessed type void *CSsl3TlsClientContext::`vftable';
// 18007CBA8: using guessed type void *CSsl3TlsContext::`vftable';
// 18007CDB8: using guessed type void *CSslContext::`vftable';
// 18007CFB8: using guessed type void *ISslSerialize::`vftable';
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180003700) ----------------------------------------------------
void __fastcall CSslContext::FreeMemory(CSslContext *this, void *a2)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(*((_QWORD *)this + 16) + 24i64);
  if ( v2 )
  {
    (*(void (__fastcall **)(__int64, void *))(*(_QWORD *)v2 + 32i64))(v2, a2);
  }
  else if ( LsaTable )
  {
    (*(void (__fastcall **)(void *))(LsaTable + 48))(a2);
  }
  else
  {
    LocalFree(a2);
  }
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180003750) ----------------------------------------------------
CSsl3TlsClientContext *__fastcall CSsl3TlsClientContext::CSsl3TlsClientContext(
        CSsl3TlsClientContext *this,
        struct CSessionCacheClientItem *a2,
        int a3,
        const unsigned __int16 *a4)
{
  unsigned __int16 v8; // ax
  unsigned int v9; // ecx
  int v10; // eax
  _DWORD *v11; // rdi
  __int16 v12; // ax
  __int16 v13; // cx
  CSsl3TlsClientContext *result; // rax
  char v15[8]; // [rsp+20h] [rbp-28h] BYREF
  char v16; // [rsp+28h] [rbp-20h]

  *(_QWORD *)this = &CSslContext::`vftable';
  *((_QWORD *)this + 1) = 0i64;
  *((_QWORD *)this + 2) = 0i64;
  *((_QWORD *)this + 3) = 0i64;
  *((_WORD *)this + 16) = 0;
  *((_DWORD *)this + 9) = 0;
  *(_OWORD *)((char *)this + 40) = 0i64;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 16) = a3;
  *(_QWORD *)((char *)this + 68) = 0i64;
  *((_QWORD *)this + 10) = 0i64;
  *((_QWORD *)this + 11) = a2;
  *((_WORD *)this + 48) = 0;
  *((_QWORD *)this + 13) = 0i64;
  *((_QWORD *)this + 14) = 0i64;
  *((_QWORD *)this + 15) = 0i64;
  *((_QWORD *)this + 16) = 0i64;
  *((_QWORD *)this + 17) = 0i64;
  *((_QWORD *)this + 18) = 0i64;
  *((_QWORD *)this + 19) = 0i64;
  *((_QWORD *)this + 20) = 0i64;
  *((_QWORD *)this + 21) = 0i64;
  *((_QWORD *)this + 22) = 0i64;
  *((_QWORD *)this + 23) = 0i64;
  *((_DWORD *)this + 48) = 0;
  *((_QWORD *)this + 25) = 0i64;
  *((_QWORD *)this + 26) = 0i64;
  *((_DWORD *)this + 54) = 0;
  *((_WORD *)this + 110) = 0;
  *((_QWORD *)this + 28) = 0i64;
  *((_BYTE *)this + 232) = 0;
  *((_WORD *)this + 117) = 0;
  *((_QWORD *)this + 30) = 0i64;
  *((_QWORD *)this + 31) = 0i64;
  *((_QWORD *)this + 32) = 0i64;
  *((_WORD *)this + 132) = 0;
  *((_BYTE *)this + 266) = 0;
  if ( a2 )
    *((_DWORD *)this + 4) = *((_DWORD *)a2 + 46);
  if ( (*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v15) )
  {
    if ( (v16 & 1) != 0 )
      *((_QWORD *)this + 17) |= 0x20000000ui64;
    *((_BYTE *)this + 266) = (v16 & 0x11) == 0;
  }
  v8 = ConvertSchannelProtocolToSsl(*((_DWORD *)this + 16));
  v9 = v8;
  *((_WORD *)this + 17) = v8;
  if ( HIBYTE(v8) != 0xFE || (v10 = 13, v9 > 0xFEFF) )
    v10 = 5;
  *((_DWORD *)this + 15) = v10;
  *((_BYTE *)this + 233) = (a3 & 0xF0000) != 0;
  if ( dword_180091480
    && (qword_180091490 & 0x400000000000i64) != 0
    && (qword_180091498 & 0x400000000000i64) == qword_180091498
    && (v11 = SPExternalAlloc(0x700u)) != 0i64 )
  {
    v11[2] = 0;
    *(_QWORD *)v11 = &CSchannelTelemetryContext::`vftable';
    *((_BYTE *)v11 + 16) = 0;
    v11[5] = 1;
    memset_0(v11 + 6, 0, 0x6E8ui64);
  }
  else
  {
    v11 = 0i64;
  }
  *((_QWORD *)this + 15) = v11;
  memset_0((char *)this + 272, 0, 0x40ui64);
  *((_DWORD *)this + 84) = 0;
  *((_BYTE *)this + 340) = 0;
  memset_0((char *)this + 341, 0, 0x48ui64);
  *((_DWORD *)this + 104) = 0;
  *(_OWORD *)((char *)this + 420) = 0i64;
  *(_OWORD *)((char *)this + 436) = 0i64;
  *(_QWORD *)((char *)this + 452) = 0i64;
  *((_QWORD *)this + 58) = 0i64;
  *((_DWORD *)this + 118) = 0;
  *(_OWORD *)((char *)this + 476) = 0i64;
  *(_OWORD *)((char *)this + 492) = 0i64;
  *((_DWORD *)this + 127) = 0;
  *((_OWORD *)this + 32) = 0i64;
  *((_OWORD *)this + 33) = 0i64;
  *((_WORD *)this + 272) = 0;
  *(_QWORD *)((char *)this + 548) = 0i64;
  *((_BYTE *)this + 556) = 0;
  *((_OWORD *)this + 35) = 0i64;
  memset_0((char *)this + 592, 0, 0x80ui64);
  *((_DWORD *)this + 180) = 0;
  *(_OWORD *)((char *)this + 724) = 0i64;
  v12 = 0;
  *(_OWORD *)((char *)this + 740) = 0i64;
  *(_OWORD *)((char *)this + 756) = 0i64;
  *(_QWORD *)((char *)this + 772) = 0i64;
  *((_DWORD *)this + 195) = 0;
  *((_QWORD *)this + 98) = 0i64;
  *((_QWORD *)this + 99) = 0i64;
  *((_QWORD *)this + 100) = 0i64;
  *((_QWORD *)this + 101) = 0i64;
  *((_QWORD *)this + 102) = 0i64;
  *((_QWORD *)this + 103) = 0i64;
  *((_QWORD *)this + 104) = 0i64;
  *((_QWORD *)this + 105) = 0i64;
  *((_QWORD *)this + 106) = 0i64;
  *((_QWORD *)this + 107) = 0i64;
  *((_QWORD *)this + 108) = 0i64;
  *((_DWORD *)this + 218) = 0;
  *((_QWORD *)this + 110) = 0i64;
  *((_DWORD *)this + 222) = 0;
  *((_QWORD *)this + 112) = 0i64;
  *((_QWORD *)this + 113) = 0i64;
  *((_QWORD *)this + 114) = 0i64;
  *((_DWORD *)this + 230) = 0;
  *((_WORD *)this + 462) = 0;
  if ( *((_BYTE *)this + 233) )
  {
    v12 = 1083;
    v13 = 1096;
  }
  else
  {
    *((_DWORD *)this + 48) = -1;
    v13 = 0;
    *((_QWORD *)this + 25) = 0i64;
    *((_QWORD *)this + 26) = 0i64;
  }
  *((_WORD *)this + 108) = v13;
  *((_WORD *)this + 109) = v12;
  *((_QWORD *)this + 116) = 0i64;
  *(_QWORD *)this = &CSsl3TlsClientContext::`vftable';
  *((_QWORD *)this + 117) = 0i64;
  *((_DWORD *)this + 236) = 0;
  *((_QWORD *)this + 119) = 0i64;
  *((_DWORD *)this + 240) = 0;
  *((_QWORD *)this + 121) = 0i64;
  *((_DWORD *)this + 244) = 0;
  *((_WORD *)this + 490) = 0;
  *(_OWORD *)((char *)this + 982) = 0i64;
  *(_OWORD *)((char *)this + 998) = 0i64;
  *((_QWORD *)this + 127) = 0i64;
  *((_QWORD *)this + 128) = 0i64;
  *((_BYTE *)this + 1032) = 0;
  *((_QWORD *)this + 130) = 0i64;
  *((_DWORD *)this + 262) = 0;
  memset_0((char *)this + 1052, 0, 0xFFui64);
  *(_QWORD *)((char *)this + 1308) = 0i64;
  *((_QWORD *)this + 165) = a2;
  *((_QWORD *)this + 166) = a4;
  *((_QWORD *)this + 167) = 0i64;
  *((_BYTE *)this + 1344) = 0;
  *((_WORD *)this + 673) = 0;
  *((_DWORD *)this + 337) = 0;
  *((_QWORD *)this + 169) = 0i64;
  *((_DWORD *)this + 340) = 0;
  result = this;
  *((_DWORD *)this + 17) = 40;
  *((_QWORD *)this + 73) = 0i64;
  *((_QWORD *)this + 72) = 0i64;
  return result;
}
// 18007C000: using guessed type void *CSsl3TlsClientContext::`vftable';
// 18007CDB8: using guessed type void *CSslContext::`vftable';
// 18007CF58: using guessed type void *CSchannelTelemetryContext::`vftable';
// 180091490: using guessed type __int64 qword_180091490;
// 180091498: using guessed type __int64 qword_180091498;
// 180092620: using guessed type __int64 LsaTable;
// 180003750: using guessed type char var_28[8];

//----- (0000000180003C24) ----------------------------------------------------
void __fastcall CSessionCacheItem::ClearState(CSessionCacheItem *this)
{
  __int64 v2; // rcx
  void *v3; // rcx
  void *v4; // rcx
  const CERT_CONTEXT *v5; // rcx
  void *v6; // rcx
  __int64 v7; // rdi
  __int64 v8; // rcx
  void *v9; // rcx

  v2 = *((_QWORD *)this + 2);
  if ( v2 )
    SslFreeObject(v2, 0i64);
  v3 = (void *)*((_QWORD *)this + 3);
  if ( v3 )
    SPExternalFree(v3);
  v4 = (void *)*((_QWORD *)this + 5);
  if ( v4 )
    SPExternalFree(v4);
  v5 = (const CERT_CONTEXT *)*((_QWORD *)this + 6);
  if ( v5 )
    CertFreeCertificateContext(v5);
  v6 = (void *)*((_QWORD *)this + 7);
  if ( v6 )
    SPExternalFree(v6);
  v7 = *((_QWORD *)this + 22);
  if ( v7 )
  {
    v8 = *(_QWORD *)(v7 + 848);
    if ( v8 )
      CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v8 + 16));
    CMasterCipherInfo::Dereference(*(CMasterCipherInfo **)(v7 + 856));
  }
  v9 = (void *)*((_QWORD *)this + 25);
  if ( v9 )
    SPExternalFree(v9);
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180003CE4) ----------------------------------------------------
__int64 __fastcall CMasterCipherInfo::Dereference(CMasterCipherInfo *this)
{
  unsigned __int32 v1; // ebx

  v1 = _InterlockedDecrement((volatile signed __int32 *)this + 3);
  if ( !v1 )
  {
    _InterlockedDecrement(&CMasterCipherInfo::m_lMasterCiphersCount);
    FreeCipherSuiteData(*((_DWORD *)this + 2), *(NCRYPT_HANDLE **)this, this);
  }
  return v1;
}
// 180092D90: using guessed type int CMasterCipherInfo::m_lMasterCiphersCount;

//----- (0000000180003D20) ----------------------------------------------------
__int64 __fastcall CMasterEccCurveInfo::Dereference(CMasterEccCurveInfo *this)
{
  unsigned __int32 v1; // ebx

  v1 = _InterlockedDecrement((volatile signed __int32 *)this + 3);
  if ( !v1 )
    SPExternalFree(this);
  return v1;
}

//----- (0000000180003D4C) ----------------------------------------------------
void __fastcall CSslCredManager::DereferenceCredentialGroup(CSslCredManager *this, struct CCredentialGroup *a2)
{
  struct _RTL_CRITICAL_SECTION *v3; // rdi
  struct CCredentialGroup **v4; // r8
  struct CCredentialGroup **v5; // rdx

  if ( _InterlockedExchangeAdd((volatile signed __int32 *)a2 + 6, 0xFFFFFFFF) == 1 )
  {
    v3 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 8);
    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
    v4 = (struct CCredentialGroup **)*((_QWORD *)a2 + 1);
    if ( v4[1] != (struct CCredentialGroup *)((char *)a2 + 8)
      || (v5 = (struct CCredentialGroup **)*((_QWORD *)a2 + 2), *v5 != (struct CCredentialGroup *)((char *)a2 + 8)) )
    {
      __fastfail(3u);
    }
    *v5 = (struct CCredentialGroup *)v4;
    v4[1] = (struct CCredentialGroup *)v5;
    RtlLeaveCriticalSection(v3);
    if ( a2 )
      (*(void (__fastcall **)(struct CCredentialGroup *, __int64))(*(_QWORD *)a2 + 8i64))(a2, 1i64);
  }
}

//----- (0000000180003DF0) ----------------------------------------------------
void __fastcall CSsl3TlsContext::FreeHandshakeHash(CSsl3TlsContext *this)
{
  unsigned int v2; // edi
  char *v3; // rsi
  __int64 v4; // rcx

  v2 = 0;
  if ( *((_DWORD *)this + 137) )
  {
    do
    {
      v3 = (char *)this + 8 * v2;
      v4 = *((_QWORD *)v3 + 74);
      if ( v4 )
      {
        SslFreeObject(v4, 0i64);
        *((_QWORD *)v3 + 74) = 0i64;
      }
      ++v2;
    }
    while ( v2 < *((_DWORD *)this + 137) );
    *((_DWORD *)this + 180) = 0;
    *((_DWORD *)this + 137) = 0;
  }
  else
  {
    *((_DWORD *)this + 180) = 0;
    *((_DWORD *)this + 137) = 0;
  }
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180003E7C) ----------------------------------------------------
void __fastcall CSsl3TlsContext::FreeSelectedTBParameters(CSsl3TlsContext *this)
{
  __int64 v1; // rdx

  v1 = *((_QWORD *)this + 103);
  if ( v1 )
  {
    if ( *(_QWORD *)(v1 + 8) )
    {
      (*(void (__fastcall **)(CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 16i64))(this, *(_QWORD *)(v1 + 8));
      v1 = *((_QWORD *)this + 103);
    }
    (*(void (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 16i64))(this, v1);
    *((_QWORD *)this + 103) = 0i64;
  }
}

//----- (0000000180003EA4) ----------------------------------------------------
void __fastcall CSsl3TlsContext::FreeSelectedSrtpParameters(CSsl3TlsContext *this)
{
  __int64 v1; // rdx

  v1 = *((_QWORD *)this + 101);
  if ( v1 )
  {
    if ( *(_QWORD *)(v1 + 8) )
    {
      (*(void (__fastcall **)(CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 16i64))(this, *(_QWORD *)(v1 + 8));
      v1 = *((_QWORD *)this + 101);
    }
    (*(void (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 16i64))(this, v1);
    *((_QWORD *)this + 101) = 0i64;
  }
}

//----- (0000000180003ED0) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::CleanupConnectedState(CSsl3TlsClientContext *this)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  void *v4; // rcx
  void *v5; // rcx
  void *v6; // rcx
  __int64 v7; // rax
  CSslCredential *v8; // rax
  __int64 v9; // rdx
  int v10; // r8d

  v2 = *((_QWORD *)this + 128);
  if ( v2 )
    SslFreeObject(v2, 0i64);
  v3 = *((_QWORD *)this + 127);
  if ( v3 )
    SslFreeObject(v3, 0i64);
  v4 = (void *)*((_QWORD *)this + 119);
  if ( v4 )
  {
    SPExternalFree(v4);
    *((_QWORD *)this + 119) = 0i64;
  }
  v5 = (void *)*((_QWORD *)this + 121);
  if ( v5 )
  {
    SPExternalFree(v5);
    *((_QWORD *)this + 121) = 0i64;
  }
  v6 = (void *)*((_QWORD *)this + 117);
  if ( v6 )
  {
    SPExternalFree(v6);
    *((_QWORD *)this + 117) = 0i64;
  }
  *((_DWORD *)this + 236) = 0;
  CSsl3TlsClientContext::SetDefCredSearched((__int64)this, 0);
  v7 = *(_QWORD *)this;
  *((_BYTE *)this + 1032) = 0;
  if ( (*(__int64 (__fastcall **)(CSsl3TlsClientContext *))(v7 + 248))(this) && (*((_DWORD *)this + 34) & 0x80000) != 0 )
  {
    v8 = (CSslCredential *)(*(__int64 (__fastcall **)(CSsl3TlsClientContext *))(*(_QWORD *)this + 248i64))(this);
    CSslCredential::RemoteCloseKeyHandle(v8, v9, v10);
  }
  *((_WORD *)this + 255) = 0;
  *((_WORD *)this + 272) = 0;
  *((_BYTE *)this + 1313) = 0;
  CSsl3TlsContext::CleanupConnectedState(this);
}
// 18002CD3F: variable 'v9' is possibly undefined
// 18002CD3F: variable 'v10' is possibly undefined
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180003FB0) ----------------------------------------------------
void __fastcall CSsl3TlsContext::CleanupConnectedState(CSsl3TlsContext *this)
{
  void *v2; // rcx
  __int64 v3; // rdx
  _QWORD *v4; // rbx

  v2 = (void *)*((_QWORD *)this + 112);
  if ( v2 )
  {
    SPExternalFree(v2);
    *((_QWORD *)this + 112) = 0i64;
    *((_DWORD *)this + 222) = 0;
  }
  if ( *((_QWORD *)this + 110) )
  {
    (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 110) = 0i64;
  }
  v3 = *((_QWORD *)this + 114);
  *((_DWORD *)this + 218) = 0;
  if ( v3 )
  {
    (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 114) = 0i64;
    *((_WORD *)this + 460) = 0;
  }
  *(_WORD *)((char *)this + 923) = 0;
  *((_BYTE *)this + 472) = 0;
  v4 = (_QWORD *)*((_QWORD *)this + 58);
  if ( v4 && *v4 )
  {
    if ( v4[3] )
    {
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v4 + 16i64))(*v4);
      v4[3] = 0i64;
      *((_DWORD *)v4 + 4) = 0;
    }
  }
}

//----- (000000018000404C) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::SetDefCredSearched(__int64 a1, int a2)
{
  const CERT_CHAIN_CONTEXT *v3; // rcx

  *(_DWORD *)(a1 + 1048) = a2;
  v3 = *(const CERT_CHAIN_CONTEXT **)(a1 + 1040);
  if ( v3 )
    CertFreeCertificateChain(v3);
  *(_QWORD *)(a1 + 1040) = 0i64;
}

//----- (0000000180004080) ----------------------------------------------------
void __fastcall CSessionCacheItem::~CSessionCacheItem(CSessionCacheItem *this)
{
  *(_QWORD *)this = &CSessionCacheItem::`vftable';
  CSessionCacheItem::ClearState(this);
  if ( !*((_DWORD *)this + 17) )
    RtlDeleteResource((PRTL_RESOURCE)((char *)this + 72));
  *(_QWORD *)this = &IAllocate::`vftable';
}
// 18007C298: using guessed type void *IAllocate::`vftable';
// 18007C2C0: using guessed type void *CSessionCacheItem::`vftable';

//----- (00000001800040C8) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::DigestCertificateStatus(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  unsigned int v5; // ebx
  HLOCAL v6; // rax
  HLOCAL v7; // rbp
  __int64 v8; // rax
  unsigned __int8 v10; // r9
  int v11; // edx

  if ( (*((_DWORD *)this + 34) & 0x20000) == 0 )
  {
    v10 = 10;
    v11 = 200;
LABEL_11:
    CSslContext::SetErrorAndFatalAlert((__int64)this, v11, -2146893018, v10);
    return 2148074278i64;
  }
  if ( a3 < 4 )
    goto LABEL_10;
  if ( *a2 != 1 )
    return 0i64;
  v5 = a2[3] + (a2[1] << 16) + (a2[2] << 8);
  if ( v5 > a3 - 4 )
  {
LABEL_10:
    v10 = 50;
    v11 = 201;
    goto LABEL_11;
  }
  v6 = SPExternalAlloc(v5);
  v7 = v6;
  if ( v6 )
  {
    memcpy_0(v6, a2 + 4, v5);
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64), 1u);
    v8 = *((_QWORD *)this + 165);
    *(_DWORD *)(v8 + 344) = v5;
    *(_QWORD *)(v8 + 336) = v7;
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
    return 0i64;
  }
  return 14i64;
}

//----- (00000001800041B0) ----------------------------------------------------
__int64 __fastcall NonMontgomeryGetKeyExchangeBlob(
        struct _BCRYPT_ECCKEY_BLOB *a1,
        unsigned __int8 *a2,
        unsigned __int8 *a3)
{
  unsigned int v5; // ebx
  unsigned __int8 v6; // cl
  unsigned __int8 v7; // al

  if ( a1->cbKey > 0x7F )
  {
    return 1359;
  }
  else
  {
    v5 = 0;
    v6 = 2 * LOBYTE(a1->cbKey) + 1;
    if ( a2 )
    {
      v7 = *a3;
      *a3 = v6;
      if ( v7 < v6 )
      {
        return (unsigned int)-2146893023;
      }
      else
      {
        *a2 = 4;
        memcpy_0(a2 + 1, &a1[1], v6 - 1i64);
      }
    }
    else
    {
      *a3 = v6;
    }
  }
  return v5;
}

//----- (0000000180004214) ----------------------------------------------------
unsigned __int8 __fastcall CSessionCacheManager::FinishCacheAddItem(CSessionCacheManager *this, struct CSslContext *a2)
{
  __int64 *v2; // rsi
  __int64 v5; // rbp
  __int64 v6; // r9
  unsigned int v7; // edx
  unsigned int v8; // eax
  __int64 v9; // rax

  v2 = (__int64 *)*((_QWORD *)a2 + 11);
  if ( !v2 )
    return 0;
  v5 = *((_QWORD *)a2 + 10);
  if ( !v5 )
    return 0;
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(v2[28] + 48), 1u);
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(v2 + 9), 1u);
  v7 = *(_DWORD *)(v5 + 208);
  v8 = *((_DWORD *)v2 + 70);
  *((_BYTE *)v2 + 236) = 1;
  if ( v7 >= v8 )
    v7 = v8;
  v9 = *v2;
  *((_DWORD *)v2 + 70) = v7;
  LOBYTE(v6) = 1;
  (*(void (__fastcall **)(__int64 *, CSessionCacheManager *, struct CSslContext *, __int64))(v9 + 64))(v2, this, a2, v6);
  RtlReleaseResource((PRTL_RESOURCE)(v2 + 9));
  RtlReleaseResource((PRTL_RESOURCE)(v2[28] + 48));
  return 1;
}
// 1800042B3: variable 'v6' is possibly undefined

//----- (0000000180004308) ----------------------------------------------------
__int64 __fastcall VerifyRsaParams(
        UCHAR *a1,
        unsigned __int8 *a2,
        ULONG a3,
        const unsigned __int16 *a4,
        enum _eTlsHashAlgorithm a5,
        ULONG a6,
        PUCHAR pbSignature,
        ULONG cbSignature)
{
  unsigned int v12; // eax
  ULONG v14; // r14d
  unsigned int v15; // ebx
  BOOL v16; // eax
  struct _RTL_RESOURCE *v17; // rcx
  const unsigned __int16 **p_pPaddingInfo; // rdx
  DWORD LastError; // eax
  unsigned __int8 v21; // r9
  int v22; // r8d
  int v23; // edx
  ULONG cbHash; // [rsp+40h] [rbp-79h] BYREF
  BCRYPT_KEY_HANDLE hKey; // [rsp+48h] [rbp-71h] BYREF
  const unsigned __int16 *pPaddingInfo; // [rsp+50h] [rbp-69h] BYREF
  __int128 v27; // [rsp+58h] [rbp-61h] BYREF
  UCHAR pbHash[64]; // [rsp+70h] [rbp-49h] BYREF

  hKey = 0i64;
  memset_0(pbHash, 0, sizeof(pbHash));
  cbHash = 0;
  pPaddingInfo = 0i64;
  v27 = 0i64;
  if ( a5 )
  {
    v12 = GenerateTlsHash(a5, a1, a2, a3, pbHash, &cbHash);
    v14 = cbHash;
  }
  else
  {
    v14 = 36;
    v12 = CSsl3TlsContext::ComputeRsaServerExchangeHashes(a1, a2, a3, pbHash);
    a6 = 2;
  }
  v15 = v12;
  if ( v12 )
  {
    v21 = 80;
    v22 = v12;
    v23 = 1105;
LABEL_18:
    CSslContext::SetErrorAndFatalAlert((__int64)a1, v23, v22, v21);
    goto LABEL_9;
  }
  RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)a1 + 11) + 72i64), 1u);
  v16 = CryptImportPublicKeyInfoEx2(
          **(_DWORD **)(*((_QWORD *)a1 + 11) + 48i64),
          (PCERT_PUBLIC_KEY_INFO)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 11) + 48i64) + 24i64) + 96i64),
          0x80000000,
          0i64,
          &hKey);
  v17 = (struct _RTL_RESOURCE *)(*((_QWORD *)a1 + 11) + 72i64);
  if ( !v16 )
  {
    RtlReleaseResource(v17);
    LastError = GetLastError();
    v15 = LastError;
    v21 = 43;
LABEL_17:
    v22 = LastError;
    v23 = 1106;
    goto LABEL_18;
  }
  RtlReleaseResource(v17);
  if ( a6 == 8 )
  {
    p_pPaddingInfo = (const unsigned __int16 **)&v27;
    *(_QWORD *)&v27 = a4;
    DWORD2(v27) = v14;
    goto LABEL_8;
  }
  if ( a6 == 2 )
  {
    p_pPaddingInfo = &pPaddingInfo;
    pPaddingInfo = a4;
LABEL_8:
    LastError = BCryptVerifySignature(hKey, p_pPaddingInfo, pbHash, v14, pbSignature, cbSignature, a6);
    v15 = LastError;
    if ( !LastError )
      goto LABEL_9;
    v21 = 51;
    goto LABEL_17;
  }
  v15 = -2146893052;
LABEL_9:
  if ( hKey )
    BCryptDestroyKey(hKey);
  return v15;
}

//----- (0000000180004494) ----------------------------------------------------
NTSTATUS __fastcall GenerateTlsHash(
        enum _eTlsHashAlgorithm a1,
        UCHAR *a2,
        unsigned __int8 *a3,
        ULONG a4,
        unsigned __int8 *a5,
        unsigned int *a6)
{
  NTSTATUS result; // eax
  BCRYPT_ALG_HANDLE hAlgorithm; // [rsp+30h] [rbp-18h] BYREF

  hAlgorithm = 0i64;
  result = TlsGetBCryptHashProvider(a1, &hAlgorithm, a6);
  if ( !result )
    return GenerateHash(hAlgorithm, a2, a3, a4, a5, *a6);
  return result;
}

//----- (0000000180004510) ----------------------------------------------------
__int64 __fastcall TlsGetBCryptHashProvider(enum _eTlsHashAlgorithm a1, void **a2, unsigned int *a3)
{
  unsigned int v3; // r10d
  int v6; // ebx
  char *v7; // r9
  BCRYPT_ALG_HANDLE v8; // rax
  __int64 v9; // rcx
  const WCHAR *v10; // rdx
  unsigned int v11; // eax
  unsigned int v12; // ecx
  void *v14; // rbx
  unsigned int v15; // [rsp+48h] [rbp+10h]
  BCRYPT_ALG_HANDLE phAlgorithm; // [rsp+50h] [rbp+18h] BYREF
  const WCHAR *v17; // [rsp+58h] [rbp+20h]

  v3 = 0;
  v6 = g_dwHashInfoTotalCount;
  if ( g_dwHashInfoTotalCount )
  {
    v7 = (char *)g_pHashInfo;
    while ( !*(_QWORD *)v7 || *(_DWORD *)(*(_QWORD *)v7 + 20i64) != a1 )
    {
      ++v3;
      v7 += 8;
      if ( v3 >= g_dwHashInfoTotalCount )
        goto LABEL_8;
    }
    v6 = v3;
  }
LABEL_8:
  if ( v6 < 0 || v6 >= g_dwHashInfoTotalCount )
  {
    v6 = 0;
  }
  else
  {
    if ( v6 == 1 )
    {
      v8 = g_hMD5Provider;
      goto LABEL_13;
    }
    if ( v6 == 2 )
    {
      v8 = g_hSHAProvider;
      goto LABEL_13;
    }
  }
  v8 = (BCRYPT_ALG_HANDLE)qword_180092CF0[v6];
LABEL_13:
  phAlgorithm = v8;
  v15 = 0;
  if ( v6 >= (unsigned int)g_dwHashInfoTotalCount || (_mm_lfence(), (v9 = g_pHashInfo[v6]) == 0) )
  {
    v12 = 1168;
    goto LABEL_17;
  }
  v10 = *(const WCHAR **)v9;
  v11 = *(_DWORD *)(v9 + 8);
  v17 = *(const WCHAR **)v9;
  v15 = v11;
  if ( phAlgorithm )
    goto LABEL_16;
  if ( !v10 )
  {
    v12 = 1359;
    goto LABEL_17;
  }
  v12 = BCryptOpenAlgorithmProvider(&phAlgorithm, v10, 0i64, 0);
  if ( !v12 )
  {
    v14 = (void *)_InterlockedCompareExchange64(&qword_180092CF0[v6], (signed __int64)phAlgorithm, 0i64);
    if ( v14 )
    {
      BCryptCloseAlgorithmProvider(phAlgorithm, 0);
      phAlgorithm = v14;
    }
LABEL_16:
    v12 = 0;
  }
LABEL_17:
  *a2 = phAlgorithm;
  *a3 = v15;
  return v12;
}
// 180092324: using guessed type int g_dwHashInfoTotalCount;
// 180092330: using guessed type _QWORD g_pHashInfo[16];
// 180092CF0: using guessed type signed __int64 qword_180092CF0[1];

//----- (0000000180004658) ----------------------------------------------------
__int64 __fastcall CCipherMill::GetCurveInfo(CCipherMill *this, int a2, struct CEccCurveInfo **a3)
{
  unsigned int CurveInfo; // ebx

  RtlAcquireResourceShared(&Resource, 1u);
  if ( a2 && a3 && qword_1800925C8 )
    CurveInfo = CMasterEccCurveInfo::GetCurveInfo(qword_1800925C8, a2, a3);
  else
    CurveInfo = 87;
  RtlReleaseResource(&Resource);
  return CurveInfo;
}

//----- (00000001800046CC) ----------------------------------------------------
__int64 __fastcall CMasterEccCurveInfo::GetCurveInfo(CMasterEccCurveInfo *this, int a2, struct CEccCurveInfo **a3)
{
  unsigned int v3; // r10d
  unsigned int v4; // r9d
  __int64 v7; // rdi
  unsigned int v8; // edx
  __int64 v9; // rax
  unsigned int v10; // r8d
  __int64 v11; // rbx
  __int64 v12; // rax

  v3 = *((_DWORD *)this + 2);
  v4 = 0;
  if ( !v3 )
    return 1168i64;
  v7 = *(_QWORD *)this;
  while ( 1 )
  {
    v8 = 0;
    v9 = 32i64 * v4;
    v10 = *(_DWORD *)(v9 + v7 + 8);
    if ( v10 )
      break;
LABEL_10:
    if ( ++v4 >= v3 )
      return 1168i64;
  }
  v11 = *(_QWORD *)(v9 + v7);
  while ( 1 )
  {
    v12 = v11 + 780i64 * v8;
    if ( *(_DWORD *)(v12 + 772) == a2 )
      break;
    if ( ++v8 >= v10 )
      goto LABEL_10;
  }
  *a3 = (struct CEccCurveInfo *)v12;
  return 0i64;
}

//----- (0000000180004750) ----------------------------------------------------
__int64 __fastcall CreateServerCertificateSerialChainProperty(struct CSsl3TlsClientContext *a1)
{
  __int64 v1; // rcx
  __int64 v2; // rdx
  __int64 v3; // r10
  __int64 v4; // r9
  __int64 v5; // r8
  int v6; // eax
  __int64 v7; // rbx
  __int64 v8; // rdi
  int v9; // esi
  void *v10; // rcx
  int v12; // [rsp+50h] [rbp+20h] BYREF
  __int64 v13; // [rsp+58h] [rbp+28h] BYREF
  __int64 v14; // [rsp+60h] [rbp+30h] BYREF

  v13 = 0i64;
  v14 = 0i64;
  if ( !a1 )
    return 2148074244i64;
  (*(void (__fastcall **)(struct CSsl3TlsClientContext *, __int64 *))(*(_QWORD *)a1 + 224i64))(a1, &v13);
  if ( !v13 )
    return 2148074244i64;
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(v13 + 72), 1u);
  v1 = v13;
  v2 = *(unsigned int *)(v13 + 32);
  v3 = *(_QWORD *)(v13 + 24);
  v4 = *(unsigned int *)(v13 + 344);
  v5 = *(_QWORD *)(v13 + 336);
  v6 = *(_DWORD *)(v13 + 360);
  v12 = v6;
  if ( (_DWORD)v2 && !v6 )
  {
    if ( (unsigned int)I_CertProcessSslHandshake(v3, v2, v5, v4, &v14, &v12) )
    {
      v7 = v13;
      v8 = v14;
      v9 = v12;
      v10 = *(void **)(v13 + 352);
      if ( v10 )
        CryptMemFree(v10);
      *(_DWORD *)(v7 + 360) = v9;
      *(_QWORD *)(v7 + 352) = v8;
    }
    v1 = v13;
  }
  RtlReleaseResource((PRTL_RESOURCE)(v1 + 72));
  return 0i64;
}
// 180098180: using guessed type __int64 __fastcall I_CertProcessSslHandshake(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180004850) ----------------------------------------------------
__int64 __fastcall AutoVerifyServerCertificate(struct CSsl3TlsContext *a1)
{
  __int64 v3; // rax
  int v4; // r10d
  int v5; // edx
  int v6; // ecx
  int v7; // r9d
  int v8; // r8d
  unsigned int v9; // edx

  if ( !a1 )
    return 2148074244i64;
  if ( (*((_DWORD *)a1 + 34) & 0x4000i64) != 0 )
    return 0i64;
  v3 = *((_QWORD *)a1 + 10);
  if ( !v3 )
    return 2148074244i64;
  v4 = *(_DWORD *)(v3 + 160);
  v5 = ((v4 & 0x100) << 20) | 0x20000000;
  if ( (v4 & 0x200) == 0 )
    v5 = (v4 & 0x100) << 20;
  v6 = v5 | 0x40000000;
  if ( (v4 & 0x400) == 0 )
    v6 = v5;
  v7 = v6 | 4;
  if ( (v4 & 0x2000) == 0 )
    v7 = v6;
  v8 = v4 & 0x800 | 0x1000;
  if ( (v4 & 0x1000) == 0 )
    v8 = v4 & 0x800;
  v9 = v7 | 0x80000000;
  if ( (v4 & 0x4000) == 0 )
    v9 = v7;
  return VerifyServerCertificate(a1, v9, v8);
}

//----- (0000000180004900) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::DigestServerKeyX(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int8 *a4)
{
  unsigned int *v7; // rdi
  int v8; // ecx
  __int64 result; // rax
  unsigned __int8 *v10; // rax
  unsigned __int8 *v11; // r9
  int v12; // ecx

  *((_QWORD *)this + 17) |= 0x8000ui64;
  v7 = (unsigned int *)((char *)this + 960);
  v8 = *(_DWORD *)(*((_QWORD *)this + 1) + 48i64);
  switch ( v8 )
  {
    case 3:
      result = CSsl3TlsClientContext::EccGenerateClientExchangeValue(this, a2, a3, 0i64, v7);
      break;
    case 2:
      result = CSsl3TlsClientContext::DhGenerateClientExchangeValue(this, a2, a3, 0i64, v7);
      break;
    case 4:
      result = CSsl3TlsClientContext::PskGenerateClientExchangeValue(this, a2, a3, 0i64, v7);
      break;
    default:
      result = CSslContext::RsaGenerateClientExchangeValue(this, 0i64, v7, a4);
      break;
  }
  if ( !(_DWORD)result )
  {
    v10 = (unsigned __int8 *)SPExternalAlloc(*v7);
    *((_QWORD *)this + 119) = v10;
    if ( v10 )
    {
      v12 = *(_DWORD *)(*((_QWORD *)this + 1) + 48i64);
      switch ( v12 )
      {
        case 3:
          return CSsl3TlsClientContext::EccGenerateClientExchangeValue(this, a2, a3, v10, v7);
        case 2:
          return CSsl3TlsClientContext::DhGenerateClientExchangeValue(this, a2, a3, v10, v7);
        case 4:
          return CSsl3TlsClientContext::PskGenerateClientExchangeValue(this, a2, a3, v10, v7);
        default:
          return CSslContext::RsaGenerateClientExchangeValue(this, v10, v7, v11);
      }
    }
    else
    {
      return 14i64;
    }
  }
  return result;
}
// 18002CF53: variable 'v11' is possibly undefined

//----- (00000001800049B0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::EccGenerateClientExchangeValue(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int8 *a4,
        unsigned int *a5)
{
  __int64 v5; // rax
  CSsl3TlsClientContext *v7; // rdi
  struct _BCRYPT_ECCKEY_BLOB *p_Size_4; // rsi
  bool v9; // zf
  __int64 v10; // r13
  int v11; // r15d
  int v12; // r12d
  unsigned int v13; // eax
  __int64 v14; // r14
  unsigned int v15; // ecx
  unsigned int v16; // eax
  unsigned int v17; // edx
  CCipherMill *v18; // rcx
  unsigned __int8 *v19; // r14
  unsigned int v20; // r8d
  __int16 v21; // ax
  __int16 v22; // r12
  __int16 v23; // r12
  unsigned int *v24; // r9
  unsigned int v25; // edx
  int v26; // r15d
  unsigned int v27; // eax
  unsigned int EccBcryptKeyBlobFromKeyExchangeBlob; // ebx
  __int64 v29; // rax
  unsigned int v30; // edx
  __int64 v31; // rcx
  unsigned int EphemKey; // eax
  __int64 *v33; // rax
  __int64 v34; // rcx
  unsigned int EphemBlobFromKey; // eax
  struct _BCRYPT_ECCKEY_BLOB *v36; // r14
  unsigned int v37; // edx
  unsigned __int64 v38; // rcx
  unsigned __int64 v39; // rax
  void *v40; // rsp
  unsigned __int8 v41; // r8
  unsigned __int8 *v42; // rdx
  __int64 *v43; // rax
  __int64 v44; // rcx
  ULONG dwMagic; // ebx
  __int64 *v46; // rax
  __int64 v47; // rcx
  unsigned __int8 *v48; // r15
  int v49; // ecx
  int v50; // eax
  unsigned int EccDhPskSessionKeysHelper; // eax
  unsigned int v53; // eax
  unsigned __int8 v54; // r9
  int v55; // edx
  unsigned __int8 v56; // r9
  int v57; // r8d
  int v58; // edx
  int v59; // r8d
  int v60; // edx
  struct _BCRYPT_ECCKEY_BLOB *v61; // rax
  __int64 v62; // rcx
  __int64 v63; // [rsp+0h] [rbp-40h] BYREF
  int v64; // [rsp+40h] [rbp+0h] BYREF
  unsigned int Size; // [rsp+44h] [rbp+4h] BYREF
  enum _eTlsHashAlgorithm Size_4; // [rsp+48h] [rbp+8h] BYREF
  unsigned __int64 v67; // [rsp+50h] [rbp+10h] BYREF
  unsigned __int64 v68; // [rsp+58h] [rbp+18h] BYREF
  enum _eTlsSignatureAlgorithm v69; // [rsp+60h] [rbp+20h] BYREF
  ULONG v70; // [rsp+64h] [rbp+24h] BYREF
  unsigned int v71; // [rsp+68h] [rbp+28h] BYREF
  struct CEccCurveInfo *v72; // [rsp+70h] [rbp+30h] BYREF
  int v73; // [rsp+78h] [rbp+38h]
  unsigned __int8 v74[4]; // [rsp+7Ch] [rbp+3Ch]
  unsigned __int16 *v75; // [rsp+80h] [rbp+40h] BYREF
  struct _BCRYPT_ECCKEY_BLOB *v76; // [rsp+88h] [rbp+48h] BYREF
  unsigned __int8 *v77; // [rsp+90h] [rbp+50h]
  unsigned __int8 *v78; // [rsp+98h] [rbp+58h]

  v5 = *((_QWORD *)this + 1);
  v67 = 0i64;
  v68 = 0i64;
  v7 = this;
  v78 = a4;
  p_Size_4 = 0i64;
  v9 = *(_DWORD *)(v5 + 52) == 2;
  v10 = a3;
  v71 = 0;
  v76 = 0i64;
  v75 = 0i64;
  Size_4 = TlsHashAlgorithm_None;
  v70 = 0;
  if ( v9 )
  {
    v11 = 1;
  }
  else
  {
    if ( *(_DWORD *)(v5 + 52) != 4 )
      return 2148074248i64;
    v11 = 3;
  }
  if ( !a2 )
    return 2148074248i64;
  if ( a3 < 4 )
    goto LABEL_75;
  if ( *a2 != 3 )
  {
    v54 = 47;
    v55 = 800;
LABEL_77:
    EccBcryptKeyBlobFromKeyExchangeBlob = -2146893048;
    CSslContext::SetErrorAndFatalAlert((__int64)this, v55, -2146893048, v54);
    return EccBcryptKeyBlobFromKeyExchangeBlob;
  }
  v12 = a2[2] | (a2[1] << 8);
  v13 = a2[3];
  v73 = v12;
  *(_DWORD *)v74 = v13;
  if ( v13 < 2 )
    goto LABEL_75;
  v14 = v13 + 4;
  if ( (unsigned int)v14 > a3 )
    goto LABEL_75;
  v77 = a2 + 4;
  v15 = v13 + 6;
  if ( a4 )
  {
    if ( *a5 >= v15 )
    {
      v16 = *((unsigned __int16 *)v7 + 460);
      if ( (_WORD)v16 )
      {
        v17 = 0;
        while ( *(unsigned __int16 *)(*((_QWORD *)v7 + 114) + 2i64 * v17) != v12 )
        {
          if ( ++v17 >= v16 )
            goto LABEL_79;
        }
      }
      CSslContext::SetEccCurveInfo(v7, v12);
      if ( !*(_DWORD *)(*((_QWORD *)v7 + 10) + 196i64) )
        goto LABEL_18;
      v72 = 0i64;
      if ( (unsigned int)CCipherMill::GetCurveInfo(v18, v12, &v72) )
      {
        v56 = 80;
        EccBcryptKeyBlobFromKeyExchangeBlob = -2146893052;
        v58 = 800;
        goto LABEL_83;
      }
      if ( IsEcdheAlgorithmBlacklisted(
             *(struct _TLS_PARAMETERS **)(*((_QWORD *)v7 + 10) + 200i64),
             *(_DWORD *)(*((_QWORD *)v7 + 10) + 196i64),
             v72,
             0i64,
             1u) )
      {
LABEL_79:
        v56 = 40;
        EccBcryptKeyBlobFromKeyExchangeBlob = -2146893048;
        v58 = 801;
      }
      else
      {
LABEL_18:
        v19 = &a2[v14];
        v20 = (_DWORD)v19 - (_DWORD)a2;
        v9 = (*((_DWORD *)v7 + 16) & 0x80800) == 0;
        LODWORD(v72) = (_DWORD)v19 - (_DWORD)a2;
        if ( v9 )
        {
LABEL_23:
          if ( v19 + 2 <= &a2[v10] )
          {
            v25 = (*v19 << 8) | v19[1];
            if ( &v19[v25 + 2] <= &a2[v10] )
            {
              v26 = v11 - 1;
              if ( v26 )
              {
                if ( v26 == 2 )
                {
                  v53 = VerifyEcdsaParams(v7, a2, v20, Size_4, v19 + 2, v25);
                  EccBcryptKeyBlobFromKeyExchangeBlob = v53;
                  if ( v53 )
                  {
                    v56 = 51;
                    v57 = v53;
                    v58 = 803;
                    goto LABEL_85;
                  }
                }
              }
              else
              {
                v27 = VerifyRsaParams((UCHAR *)v7, a2, v20, v75, Size_4, v70, v19 + 2, v25);
                EccBcryptKeyBlobFromKeyExchangeBlob = v27;
                if ( v27 )
                {
                  v56 = 51;
                  v57 = v27;
                  v58 = 802;
                  goto LABEL_85;
                }
              }
              if ( (*((_BYTE *)v7 + 32) & 1) != 0 && (v29 = *((_QWORD *)v7 + 1)) != 0 )
              {
                v30 = *(_DWORD *)(v29 + 28);
              }
              else
              {
                v29 = *((_QWORD *)v7 + 1);
                v30 = 0;
                if ( !v29 )
                {
                  v31 = 0i64;
                  goto LABEL_31;
                }
              }
              v31 = *(_QWORD *)v29;
LABEL_31:
              EphemKey = EccGetEphemKey(v31, v30, *((unsigned __int16 *)v7 + 17), v12, &v68, &v71);
              EccBcryptKeyBlobFromKeyExchangeBlob = EphemKey;
              if ( !EphemKey )
              {
                *(_DWORD *)(*((_QWORD *)v7 + 165) + 8i64) = v71;
                v33 = (__int64 *)*((_QWORD *)v7 + 1);
                if ( v33 )
                  v34 = *v33;
                else
                  v34 = 0i64;
                EphemBlobFromKey = GetEphemBlobFromKey(v34, v68, L"ECCPUBLICBLOB", &Size, (unsigned __int8 **)&v76);
                v36 = v76;
                EccBcryptKeyBlobFromKeyExchangeBlob = EphemBlobFromKey;
                if ( EphemBlobFromKey )
                {
                  v59 = EphemBlobFromKey;
                  v60 = 806;
                  goto LABEL_91;
                }
                v37 = Size;
                p_Size_4 = 0i64;
                if ( Size )
                {
                  if ( Size <= (unsigned __int64)g_ulMaxStackAllocSize )
                  {
                    v38 = Size + g_ulAdditionalProbeSize + 8;
                    if ( v38 >= Size )
                    {
                      if ( !(unsigned int)VerifyStackAvailable(v38) )
                      {
LABEL_92:
                        v37 = Size;
                        goto LABEL_93;
                      }
                      v37 = Size;
                      v39 = Size + 8 + 15i64;
                      if ( v39 <= Size + 8 )
                        v39 = 0xFFFFFFFFFFFFFF0i64;
                      v40 = alloca(v39 & 0xFFFFFFFFFFFFFFF0ui64);
                      p_Size_4 = (struct _BCRYPT_ECCKEY_BLOB *)&v64;
                      if ( &v63 != (__int64 *)-64i64 )
                      {
                        v64 = 1801679955;
                        p_Size_4 = (struct _BCRYPT_ECCKEY_BLOB *)&Size_4;
                        if ( &Size_4 )
                        {
                          v37 = Size;
LABEL_44:
                          memset_0(p_Size_4, 0, v37);
                          v41 = v74[0];
                          v42 = v77;
                          *p_Size_4 = *v36;
                          EccBcryptKeyBlobFromKeyExchangeBlob = GetEccBcryptKeyBlobFromKeyExchangeBlob(
                                                                  *((_DWORD *)v7 + 5),
                                                                  v42,
                                                                  v41,
                                                                  p_Size_4,
                                                                  Size);
                          if ( EccBcryptKeyBlobFromKeyExchangeBlob )
                          {
LABEL_54:
                            if ( v36 )
                              SPExternalFree(v36);
                            if ( p_Size_4 && p_Size_4[-1].dwMagic == 1885431112 )
                              ((void (*)(void))g_pfnFree)();
                            goto LABEL_59;
                          }
                          v43 = (__int64 *)*((_QWORD *)v7 + 1);
                          v44 = v43[106];
                          if ( v44 && *(_BYTE *)(v44 + 24) )
                          {
                            dwMagic = p_Size_4->dwMagic;
                            p_Size_4->dwMagic = v12;
                            v46 = (__int64 *)*((_QWORD *)v7 + 1);
                            if ( v46 )
                              v47 = *v46;
                            else
                              v47 = 0i64;
                            if ( !(unsigned int)SslImportKey(v47, &v67, L"SSLECCPUBLICBLOB", p_Size_4, Size, 0) )
                              goto LABEL_50;
                            p_Size_4->dwMagic = dwMagic;
                            v43 = (__int64 *)*((_QWORD *)v7 + 1);
                          }
                          if ( v43 )
                            v62 = *v43;
                          else
                            v62 = 0i64;
                          EccBcryptKeyBlobFromKeyExchangeBlob = SslImportKey(
                                                                  v62,
                                                                  &v67,
                                                                  L"ECCPUBLICBLOB",
                                                                  p_Size_4,
                                                                  Size,
                                                                  0);
                          if ( !EccBcryptKeyBlobFromKeyExchangeBlob )
                          {
LABEL_50:
                            v48 = v78;
                            v49 = *((_DWORD *)v7 + 5);
                            LOBYTE(v64) = *(_BYTE *)a5 - 1;
                            if ( (unsigned int)GetEccKeyExchangeBlobFromBcryptKeyBlob(
                                                 v49,
                                                 v36,
                                                 v78 + 1,
                                                 (unsigned __int8 *)&v64) )
                            {
                              EccBcryptKeyBlobFromKeyExchangeBlob = -2146893048;
                            }
                            else
                            {
                              v50 = (unsigned __int8)v64;
                              *v48 = v64;
                              *a5 = v50 + 1;
                              if ( (*((_DWORD *)v7 + 34) & 0x8000000) != 0 )
                              {
                                (*(void (__fastcall **)(CSsl3TlsClientContext *, unsigned __int64))(*(_QWORD *)v7
                                                                                                  + 152i64))(
                                  v7,
                                  v67);
                                EccDhPskSessionKeysHelper = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, unsigned __int64))(*(_QWORD *)v7 + 168i64))(
                                                              v7,
                                                              v68);
                                v67 = 0i64;
                                v68 = 0i64;
                              }
                              else
                              {
                                EccDhPskSessionKeysHelper = MakeEccDhPskSessionKeysHelper(v7, v68, v67, 0);
                              }
                              EccBcryptKeyBlobFromKeyExchangeBlob = EccDhPskSessionKeysHelper;
                            }
                            goto LABEL_54;
                          }
                          v59 = EccBcryptKeyBlobFromKeyExchangeBlob;
                          v60 = 804;
LABEL_91:
                          CSslContext::SetErrorAndFatalAlert((__int64)v7, v60, v59, 0x33u);
                          goto LABEL_54;
                        }
                        goto LABEL_92;
                      }
                    }
                  }
                }
LABEL_93:
                if ( v37 + 8 >= v37 )
                {
                  v61 = (struct _BCRYPT_ECCKEY_BLOB *)((__int64 (__fastcall *)(_QWORD))g_pfnAllocate)(v37 + 8);
                  p_Size_4 = v61;
                  if ( !v61 )
                    goto LABEL_97;
                  v61->dwMagic = 1885431112;
                  p_Size_4 = v61 + 1;
                  v37 = Size;
                }
                if ( p_Size_4 )
                  goto LABEL_44;
LABEL_97:
                EccBcryptKeyBlobFromKeyExchangeBlob = 14;
                goto LABEL_54;
              }
              v56 = 51;
              v57 = EphemKey;
              v58 = 805;
LABEL_85:
              CSslContext::SetErrorAndFatalAlert((__int64)v7, v58, v57, v56);
LABEL_59:
              if ( v68 )
                SslFreeObject(v68, 0i64);
              if ( v67 )
                SslFreeObject(v67, 0i64);
              return EccBcryptKeyBlobFromKeyExchangeBlob;
            }
          }
LABEL_75:
          v54 = 50;
          v55 = 800;
LABEL_76:
          this = v7;
          goto LABEL_77;
        }
        if ( v19 + 2 > &a2[v10] )
        {
          v56 = 50;
        }
        else
        {
          v21 = *v19;
          v22 = v19[1];
          v19 += 2;
          v23 = v21 | (v22 << 8);
          if ( !CTlsSignatureSuiteList::IsSupportedCodePoint((CSsl3TlsClientContext *)((char *)v7 + 474), v23) )
          {
            v54 = 47;
            v55 = 821;
            goto LABEL_76;
          }
          v69 = TlsSignatureAlgorithm_Anonymous;
          GetSignatureSuiteInfoByCodePoint(v23, &v69, &Size_4, v24, (const unsigned __int16 **)&v75, 0i64, &v70);
          if ( v69 == v11 )
          {
            v20 = (unsigned int)v72;
            v12 = v73;
            goto LABEL_23;
          }
          v56 = 40;
        }
        EccBcryptKeyBlobFromKeyExchangeBlob = -2146893048;
        v58 = 821;
      }
LABEL_83:
      v57 = EccBcryptKeyBlobFromKeyExchangeBlob;
      goto LABEL_85;
    }
    return 2148074273i64;
  }
  else
  {
    *a5 = v15;
    return 0i64;
  }
}
// 180004AAE: conditional instruction was optimized away because eax.4 is in (1..FFFF)
// 180004AF5: variable 'v18' is possibly undefined
// 180004BB1: variable 'v24' is possibly undefined
// 180082258: using guessed type wchar_t aSsleccpublicbl[17];
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);
// 1800985A0: using guessed type __int64 __fastcall SslImportKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180004F90) ----------------------------------------------------
__int64 __fastcall GetEccKeyExchangeBlobFromBcryptKeyBlob(
        char a1,
        struct _BCRYPT_ECCKEY_BLOB *a2,
        unsigned __int8 *a3,
        unsigned __int8 *a4)
{
  if ( !a2 || !a4 )
    return 87i64;
  if ( (a1 & 8) != 0 )
    return MontgomeryGetKeyExchangeBlob(a2, a3, a4);
  return NonMontgomeryGetKeyExchangeBlob(a2, a3, a4);
}

//----- (0000000180004FC4) ----------------------------------------------------
__int64 __fastcall GetEccBcryptKeyBlobFromKeyExchangeBlob(
        char a1,
        unsigned __int8 *a2,
        unsigned __int8 a3,
        struct _BCRYPT_ECCKEY_BLOB *a4,
        unsigned int a5)
{
  unsigned int v5; // ebx

  v5 = 0;
  if ( !a2 || !a4 )
    return 87i64;
  if ( (a1 & 8) != 0 )
    return MontgomeryGetEccPublicKeyBlob(a2, a3, a4, a5);
  if ( *a2 == 4 && (unsigned __int64)a3 + 7 <= a5 )
    memcpy_0(&a4[1], a2 + 1, (unsigned int)a3 - 1);
  else
    return (unsigned int)-2146893048;
  return v5;
}

//----- (000000018000503C) ----------------------------------------------------
__int64 __fastcall EccGetEphemKey(
        __int64 a1,
        unsigned int a2,
        unsigned int a3,
        int a4,
        unsigned __int64 *a5,
        unsigned int *a6)
{
  unsigned int v8; // edi
  unsigned int PublicKeyLength; // eax
  unsigned int EphemeralKey; // ebx
  unsigned int v14; // [rsp+88h] [rbp+20h] BYREF

  v8 = 0;
  v14 = 0;
  RtlAcquireResourceShared(&Resource, 1u);
  if ( a4 && qword_1800925C8 )
  {
    PublicKeyLength = CMasterEccCurveInfo::GetPublicKeyLength(qword_1800925C8, a4, &v14);
    v8 = v14;
    EphemeralKey = PublicKeyLength;
  }
  else
  {
    EphemeralKey = 87;
  }
  RtlReleaseResource(&Resource);
  if ( !EphemeralKey )
  {
    EphemeralKey = SslCreateEphemeralKey(a1, a5, a3, a2, a4, v8, 0i64, 0, 0);
    if ( EphemeralKey
      && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        11i64,
        &WPP_3e0ca11e9b65363ec3903422d835754d_Traceguids,
        EphemeralKey);
    }
    if ( a6 )
      *a6 = v8;
  }
  return EphemeralKey;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098548: using guessed type __int64 __fastcall SslCreateEphemeralKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180005130) ----------------------------------------------------
__int64 __fastcall CMasterEccCurveInfo::GetPublicKeyLength(CMasterEccCurveInfo *this, int a2, unsigned int *a3)
{
  unsigned int v3; // r9d
  unsigned int v4; // r11d
  __int64 v6; // rdi
  unsigned int v7; // ecx
  __int64 v8; // rax
  unsigned int v9; // ebx
  __int64 v10; // r8
  __int64 result; // rax

  *a3 = 0;
  v3 = 0;
  v4 = *((_DWORD *)this + 2);
  if ( !v4 )
    return 1168i64;
  v6 = *(_QWORD *)this;
  while ( 1 )
  {
    v7 = 0;
    v8 = 32i64 * v3;
    v9 = *(_DWORD *)(v8 + v6 + 8);
    if ( v9 )
      break;
LABEL_10:
    if ( ++v3 >= v4 )
      return 1168i64;
  }
  v10 = *(_QWORD *)(v8 + v6);
  while ( *(_DWORD *)(780i64 * v7 + v10 + 772) != a2 )
  {
    if ( ++v7 >= v9 )
      goto LABEL_10;
  }
  result = 0i64;
  *a3 = *(_DWORD *)(780i64 * v7 + v10 + 768);
  return result;
}

//----- (00000001800051C0) ----------------------------------------------------
void __fastcall GetSignatureSuiteInfoByCodePoint(
        __int16 a1,
        enum _eTlsSignatureAlgorithm *a2,
        enum _eTlsHashAlgorithm *a3,
        unsigned int *a4,
        const unsigned __int16 **a5,
        unsigned int *a6,
        unsigned int *a7)
{
  enum _eTlsSignatureAlgorithm *v8; // rcx
  __int16 v9; // ax

  if ( a2 )
    *a2 = TlsSignatureAlgorithm_Anonymous;
  if ( a3 )
    *a3 = TlsHashAlgorithm_None;
  if ( a5 )
    *a5 = 0i64;
  if ( a7 )
    *a7 = 0;
  if ( a6 )
    *a6 = 0;
  if ( a4 )
    *a4 = 0;
  v8 = (enum _eTlsSignatureAlgorithm *)&unk_18007C390;
  v9 = __ROR2__(a1, 8);
  while ( v9 != *(_WORD *)v8 )
  {
    v8 += 18;
    if ( v8 >= (enum _eTlsSignatureAlgorithm *)&CSsl3TlsServerContext::`vftable' )
      return;
  }
  if ( a2 )
    *a2 = v8[7];
  if ( a3 )
    *a3 = *((enum _eTlsHashAlgorithm *)v8 + 10);
  if ( a5 )
    *a5 = (const unsigned __int16 *)*((_QWORD *)v8 + 6);
  if ( a6 )
    *a6 = *((unsigned __int8 *)v8 + 56);
  if ( a7 )
    *a7 = *((_DWORD *)v8 + 15);
  if ( a4 )
    *a4 = *((_DWORD *)v8 + 11);
}
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';

//----- (0000000180005298) ----------------------------------------------------
bool __fastcall CTlsSignatureSuiteList::IsSupportedCodePoint(CTlsSignatureSuiteList *this, __int16 a2)
{
  unsigned __int8 SignatureSuiteInfoRowByCodePoint; // al
  int v3; // r9d
  int v4; // r10d
  __int64 v5; // r11
  int v6; // ecx
  bool result; // al

  SignatureSuiteInfoRowByCodePoint = GetSignatureSuiteInfoRowByCodePoint(a2);
  result = SignatureSuiteInfoRowByCodePoint < 0xCu
        && (v6 = *(unsigned __int16 *)(v5 + 34), _bittest(&v6, SignatureSuiteInfoRowByCodePoint))
        && ((v4 & 0x3000) == 0
         || *((_DWORD *)&unk_18007C390 + 18 * SignatureSuiteInfoRowByCodePoint + 7) != 3
         || *((_DWORD *)&unk_18007C390 + 18 * SignatureSuiteInfoRowByCodePoint + 16) == v3)
        && (v4 & *((_DWORD *)&unk_18007C390 + 18 * SignatureSuiteInfoRowByCodePoint + 6)) != 0;
  return result;
}
// 1800052AE: variable 'v5' is possibly undefined
// 1800052C9: variable 'v4' is possibly undefined
// 18002D6BE: variable 'v3' is possibly undefined

//----- (00000001800052F0) ----------------------------------------------------
unsigned __int8 __fastcall GetSignatureSuiteInfoRowByCodePoint(__int16 a1)
{
  char v1; // dl
  void **v2; // rax
  __int16 v3; // cx

  v1 = 0;
  v2 = (void **)&unk_18007C390;
  v3 = __ROR2__(a1, 8);
  while ( v3 != *(_WORD *)v2 )
  {
    v2 += 9;
    ++v1;
    if ( v2 >= &CSsl3TlsServerContext::`vftable' )
      return -1;
  }
  return v1;
}
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';

//----- (0000000180005324) ----------------------------------------------------
void __fastcall CSslContext::SetEccCurveInfo(CSslContext *this, int a2)
{
  __int64 v2; // rax
  __int64 *v4; // r9
  unsigned int v5; // r10d
  unsigned int v6; // r8d
  __int64 v7; // r11
  __int64 v8; // rdx

  v2 = *((_QWORD *)this + 1);
  *((_DWORD *)this + 4) = a2;
  v4 = *(__int64 **)(v2 + 848);
  if ( v4 )
  {
    v5 = *((_DWORD *)v4 + 2);
    v6 = 0;
    if ( v5 )
    {
      v7 = *v4;
      while ( 1 )
      {
        v8 = 780i64 * v6;
        if ( *(_DWORD *)(v7 + v8 + 772) == a2 )
          break;
        if ( ++v6 >= v5 )
          return;
      }
      if ( v7 + v8 )
        *((_DWORD *)this + 5) = *(_DWORD *)(v7 + v8 + 776);
    }
  }
}

//----- (000000018000538C) ----------------------------------------------------
__int64 __fastcall CSessionCacheManager::CacheRetrieveNewClientItem(
        CSessionCacheManager *this,
        const unsigned __int16 *a2,
        struct CSessionCacheClientItem **a3)
{
  __int64 result; // rax
  bool v5; // zf
  struct CSessionCacheItem *v6; // [rsp+58h] [rbp+20h] BYREF

  result = CSessionCacheManager::CacheRetrieveNewItem(this, 0, a2, 0i64, &v6);
  if ( !(_DWORD)result )
  {
    v5 = v6 == 0i64;
    *a3 = v6;
    if ( v5 )
      return 87i64;
  }
  return result;
}

//----- (00000001800053D0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::ProcessHandshake(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int8 *a4)
{
  unsigned int SessionKeys; // ebx
  bool v5; // cf
  int v8; // ecx
  unsigned int v9; // r15d
  int v10; // eax
  unsigned int v11; // r12d
  unsigned int v12; // ecx
  unsigned __int8 *v13; // r14
  unsigned int v14; // ebp
  CCipherMill *v15; // rcx
  __int64 v16; // r8
  int v17; // r9d
  HLOCAL v18; // rax
  struct _RTL_RESOURCE *v19; // rcx
  int v20; // edx
  __int64 v22; // rax
  CCipherMill *v23; // rcx
  __int64 v24; // rdx
  struct CSessionCacheManager *v25; // rdx
  __int64 v26; // rcx
  struct CSessionCacheClientItem *v27; // rbx
  int v28; // eax
  __int64 v29; // rcx
  __int64 v30; // rcx
  CCipherMill *v31; // rcx
  void *v32; // rcx
  CCipherMill *v33; // rcx
  __int64 v34; // rax
  __int64 v35; // rax
  unsigned __int8 v36; // r9
  int v37; // edx
  __int64 v38; // rdx
  CCipherMill *v39; // rcx
  unsigned int v40; // eax
  struct CSessionCacheClientItem *v41; // [rsp+50h] [rbp-88h] BYREF
  unsigned __int8 *v42; // [rsp+58h] [rbp-80h]
  __int128 Src[2]; // [rsp+60h] [rbp-78h] BYREF

  SessionKeys = 0;
  v5 = *((_BYTE *)this + 233) != 0;
  v42 = a4;
  *(_DWORD *)a4 = 0;
  v8 = *a2;
  v9 = 32;
  v10 = *((unsigned __int16 *)this + 34);
  v41 = 0i64;
  v11 = v5 ? 12 : 4;
  v12 = v10 | (v8 << 16);
  v13 = &a2[v11];
  v14 = a3 - v11;
  memset(Src, 0, sizeof(Src));
  if ( v12 > 0xC0046 )
  {
    if ( v12 < 0xD0029 )
      goto LABEL_151;
    if ( v12 > 0xD002B )
    {
      if ( v12 <= 0xE0028 )
        goto LABEL_151;
      if ( v12 > 0xE002C )
      {
        if ( v12 == 1310765 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 32i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
          }
          SessionKeys = CSsl3TlsContext::DigestFinish(this, v13, v14);
          v19 = (struct _RTL_RESOURCE *)(*((_QWORD *)this + 165) + 72i64);
          if ( !SessionKeys )
          {
            RtlAcquireResourceExclusive(v19, 1u);
            UpdateServerCertificateSerialChainProperty(this, 0);
            RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
            *(_DWORD *)v42 = 1;
            (*(void (__fastcall **)(CSsl3TlsClientContext *))(*(_QWORD *)this + 448i64))(this);
            if ( (*((_DWORD *)this + 34) & 0x8000000) != 0 )
              CSessionCacheManager::FinishCacheAddItem(CSessionCacheManager::m_pSessionCacheManager, this);
            return SessionKeys;
          }
LABEL_130:
          RtlAcquireResourceExclusive(v19, 1u);
          CSessionCacheClientItem::SetSessionTicket(
            *((CSessionCacheClientItem **)this + 165),
            0i64,
            0,
            0i64,
            0,
            0,
            0,
            0,
            0);
          RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
          return SessionKeys;
        }
        if ( v12 == 1310768 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 31i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
          }
          SessionKeys = CSsl3TlsContext::DigestFinish(this, v13, v14);
          v19 = (struct _RTL_RESOURCE *)(*((_QWORD *)this + 165) + 72i64);
          if ( !SessionKeys )
          {
            RtlAcquireResourceExclusive(v19, 1u);
            UpdateServerCertificateSerialChainProperty(this, 1u);
            RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
            *((_DWORD *)this + 17) = 92;
            return SessionKeys;
          }
          goto LABEL_130;
        }
        if ( v12 != 917574 )
        {
          if ( v12 != 1441833 )
            goto LABEL_151;
          v33 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
            v33 = WPP_GLOBAL_Control;
          }
          if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) == 4 )
          {
            if ( v33 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v33 + 28) & 1) != 0 )
              WPP_SF_(*((_QWORD *)v33 + 2), 21i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
            v36 = 10;
            v37 = 200;
            goto LABEL_116;
          }
          SessionKeys = CSsl3TlsClientContext::DigestCertificateStatus(this, v13, v14);
          if ( !SessionKeys )
            *((_DWORD *)this + 17) = 42;
          return SessionKeys;
        }
      }
      v15 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 27i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        v15 = WPP_GLOBAL_Control;
      }
      if ( a3 > v11 )
        return (unsigned int)-2146893048;
      if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) != 4 )
      {
        if ( *((_WORD *)this + 34) == 70 )
        {
          if ( v15 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v15 + 28) & 1) == 0 )
            goto LABEL_155;
          v38 = 28i64;
          goto LABEL_154;
        }
        CreateServerCertificateSerialChainProperty(this);
        SessionKeys = AutoVerifyServerCertificate(this);
        if ( SessionKeys )
          return SessionKeys;
      }
      SessionKeys = CSsl3TlsClientContext::DigestServerKeyX(
                      this,
                      *((unsigned __int8 **)this + 121),
                      *((_DWORD *)this + 244),
                      a4);
      if ( !SessionKeys )
      {
        v32 = (void *)*((_QWORD *)this + 121);
        if ( v32 )
        {
          SPExternalFree(v32);
          *((_QWORD *)this + 121) = 0i64;
        }
        *((_DWORD *)this + 17) = 91;
        *((_BYTE *)this + 924) = 0;
        if ( *((_BYTE *)this + 1314) )
        {
          SessionKeys = CSsl3TlsClientContext::CheckForClientCred(this);
          *((_BYTE *)this + 1314) = 0;
        }
        if ( *((_BYTE *)this + 1313) )
          return 590624;
      }
      return SessionKeys;
    }
    v39 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 25i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      v39 = WPP_GLOBAL_Control;
    }
    if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) == 4 )
    {
      if ( v39 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v39 + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)v39 + 2), 26i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      v36 = 10;
      v37 = 400;
      goto LABEL_116;
    }
    SessionKeys = CSsl3TlsClientContext::DigestCertificateRequest(this, v13, v14);
    if ( SessionKeys )
      return SessionKeys;
    v40 = CSsl3TlsClientContext::CheckForClientCred(this);
    SessionKeys = v40;
    if ( v40 == -2146893024 )
    {
      *((_BYTE *)this + 1313) = 1;
    }
    else if ( v40 != 590624 )
    {
      if ( v40 )
        return SessionKeys;
      goto LABEL_147;
    }
    SessionKeys = 0;
LABEL_147:
    *((_BYTE *)this + 1315) = 1;
    *((_DWORD *)this + 17) = 44;
    return SessionKeys;
  }
  switch ( v12 )
  {
    case 0xC0046u:
LABEL_11:
      v15 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        v15 = WPP_GLOBAL_Control;
      }
      v16 = *((_QWORD *)this + 1);
      v17 = *(_DWORD *)(v16 + 48);
      if ( v17 == 4 )
      {
LABEL_17:
        *((_DWORD *)this + 244) = v14;
        v18 = SPExternalAlloc(v14);
        *((_QWORD *)this + 121) = v18;
        if ( v18 )
        {
          memcpy_0(v18, v13, *((unsigned int *)this + 244));
          *((_DWORD *)this + 17) = 43;
        }
        else
        {
          return 14;
        }
        return SessionKeys;
      }
      if ( *((_WORD *)this + 34) != 70 )
      {
        if ( (unsigned int)(v17 - 2) > 1 && !*(_BYTE *)(v16 + 72) )
        {
          if ( v15 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v15 + 28) & 1) != 0 )
            WPP_SF_(*((_QWORD *)v15 + 2), 24i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
          v36 = 10;
          v37 = 824;
LABEL_116:
          SessionKeys = -2146893018;
          CSslContext::SetErrorAndFatalAlert((__int64)this, v37, -2146893018, v36);
          return SessionKeys;
        }
        goto LABEL_17;
      }
      if ( v15 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v15 + 28) & 1) == 0 )
        goto LABEL_155;
      v38 = 23i64;
      goto LABEL_154;
    case 0x20028u:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      SessionKeys = CSsl3TlsClientContext::DigestServerHello(this, v13, v14, (int *)&v41);
      if ( SessionKeys )
        return SessionKeys;
      if ( (_DWORD)v41 )
      {
        v34 = *((_QWORD *)this + 17);
        if ( (v34 & 0x1000000) == 0 )
        {
          if ( (v34 & 0x8000000) == 0 )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
            }
            v36 = 40;
            v37 = 106;
            goto LABEL_116;
          }
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 16i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
          }
          v35 = *((_QWORD *)this + 15);
          if ( v35 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
          {
            *(_WORD *)(v35 + 64) |= 4u;
            *(_DWORD *)(v35 + 24) = 1;
          }
          RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64), 1u);
          SessionKeys = CSslContext::MakeSessionKeys(this, *(_QWORD *)(*((_QWORD *)this + 165) + 16i64));
          RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
          if ( SessionKeys )
            return SessionKeys;
        }
        v20 = 47;
      }
      else
      {
        v20 = 70;
      }
      *((_DWORD *)this + 17) = v20;
      *((_BYTE *)this + 1315) = 0;
      return SessionKeys;
    case 0x30028u:
      SessionKeys = CSsl3TlsClientContext::DigestServerHelloVerifyRequest(this, v13, v14);
      if ( !SessionKeys )
        *((_DWORD *)this + 17) = 97;
      return SessionKeys;
    case 0xB0046u:
      goto LABEL_47;
    case 0x4002Eu:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 29i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      SessionKeys = CSsl3TlsClientContext::DigestNewSessionTicket(this, v13, v14);
      if ( !SessionKeys )
        *((_DWORD *)this + 17) = 50;
      return SessionKeys;
    case 0xB002Fu:
      v22 = *((_QWORD *)this + 17);
      if ( (v22 & 0x1000000) != 0 )
      {
        v23 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_S(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x11u,
            (__int64)&WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
            *(const wchar_t **)(*((_QWORD *)this + 165) + 368i64));
          v22 = *((_QWORD *)this + 17);
        }
        v24 = *((_QWORD *)this + 165);
        *((_QWORD *)this + 17) = v22 & 0xFFFFFFFFFEFFFFFFui64;
        CSessionCacheManager::AcquireCacheTableLock((__int64)v23, *(const unsigned __int16 **)(v24 + 368), 0i64);
        RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64), 1u);
        v25 = CSessionCacheManager::m_pSessionCacheManager;
        *(_BYTE *)(*((_QWORD *)this + 165) + 236i64) = 0;
        SessionKeys = CSessionCacheClientItem::CloneCacheElement(*((CSessionCacheClientItem **)this + 165), v25, &v41);
        RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
        if ( SessionKeys )
        {
          CSessionCacheManager::ReleaseCacheTableLock(
            v26,
            *(const unsigned __int16 **)(*((_QWORD *)this + 165) + 368i64),
            0i64);
          return SessionKeys;
        }
        v27 = v41;
        RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)v41 + 72), 1u);
        v28 = *((_DWORD *)this + 16);
        *((_QWORD *)this + 165) = v27;
        *((_QWORD *)this + 11) = v27;
        *((_DWORD *)v27 + 42) = v28;
        if ( *((unsigned __int16 *)this + 490) > 0x20u
          || (v9 = *((unsigned __int16 *)this + 490),
              memcpy_0(Src, (char *)this + 982, *((unsigned __int16 *)this + 490)),
              v9) )
        {
          v29 = *((_QWORD *)this + 165);
          *(_WORD *)(v29 + 238) = v9;
          memcpy_0((void *)(v29 + 240), Src, v9);
        }
        RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
        CSessionCacheManager::ReleaseCacheTableLock(
          v30,
          *(const unsigned __int16 **)(*((_QWORD *)this + 165) + 368i64),
          0i64);
      }
LABEL_47:
      v31 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        v31 = WPP_GLOBAL_Control;
      }
      if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) == 4 )
      {
        if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v31 + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)v31 + 2), 19i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        v36 = 10;
        v37 = 250;
        goto LABEL_116;
      }
      SessionKeys = CSsl3TlsContext::DigestRemoteCertificate(this, v13, v14);
      if ( !SessionKeys )
      {
        if ( (*((_DWORD *)this + 34) & 0x20000000) == 0
          || (RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64), 1u),
              SessionKeys = CSessionCacheClientItem::UpdateRemoteEndpointBindings(*((CSessionCacheClientItem **)this
                                                                                  + 165)),
              RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64)),
              !SessionKeys) )
        {
          *((_DWORD *)this + 17) = 41;
        }
      }
      return SessionKeys;
  }
  if ( v12 != 262191 )
  {
    if ( v12 > 0xC0028 && v12 <= 0xC002A )
      goto LABEL_11;
LABEL_151:
    v15 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      goto LABEL_155;
    v38 = 33i64;
LABEL_154:
    WPP_SF_(*((_QWORD *)v15 + 2), v38, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
LABEL_155:
    if ( (*((_DWORD *)this + 16) & 0xF3FC0) != 0 )
    {
      *((_DWORD *)this + 17) = 96;
      *((_WORD *)this + 48) = 2562;
    }
    return (unsigned int)-2146893018;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 30i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
  SessionKeys = CSsl3TlsClientContext::DigestNewSessionTicket(this, v13, v14);
  if ( !SessionKeys )
    *((_DWORD *)this + 17) = 52;
  return SessionKeys;
}
// 1800056F2: variable 'v23' is possibly undefined
// 1800057F4: variable 'v30' is possibly undefined
// 1800058D0: variable 'a4' is possibly undefined
// 18002D70A: variable 'v26' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180005B10) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::DigestServerHello(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        int *a4)
{
  CSsl3TlsClientContext *v4; // rdi
  int v5; // r15d
  unsigned int v6; // esi
  int v7; // r8d
  size_t v8; // r14
  unsigned __int8 *v9; // r12
  unsigned __int8 *v10; // rbx
  unsigned int v11; // esi
  int v12; // eax
  __int64 v13; // rdx
  int v14; // eax
  __int64 v15; // rcx
  unsigned int v16; // r8d
  __int64 v17; // r9
  unsigned int v18; // r10d
  unsigned int v19; // eax
  int v20; // r8d
  unsigned int v21; // r8d
  int v22; // eax
  unsigned int v23; // ebx
  struct CSessionCacheClientItem *v24; // rbx
  __int64 v25; // rcx
  int v26; // esi
  __int64 v27; // rcx
  CCipherMill *v28; // rcx
  __int64 v29; // rdx
  __int64 result; // rax
  __int64 v31; // r9
  int *v32; // rax
  __int64 v33; // rdx
  __int64 v34; // rax
  __int64 v35; // rax
  struct CSessionCacheManager *v36; // rdx
  __int64 v37; // rcx
  int v38; // edx
  unsigned __int8 v39; // r9
  unsigned __int8 IsMaliciousDowngrade; // al
  CCipherMill *v41; // rcx
  __int64 v42; // rdx
  unsigned int v43; // [rsp+34h] [rbp-45h]
  struct CSessionCacheClientItem *v44; // [rsp+38h] [rbp-41h] BYREF
  int *v45; // [rsp+40h] [rbp-39h]
  __int64 Buf1[3]; // [rsp+50h] [rbp-29h] BYREF
  int v47; // [rsp+68h] [rbp-11h]
  char v48; // [rsp+70h] [rbp-9h]
  __int64 v49; // [rsp+78h] [rbp-1h]
  int v50; // [rsp+80h] [rbp+7h]
  char v51; // [rsp+84h] [rbp+Bh]
  CSsl3TlsClientContext *v52; // [rsp+88h] [rbp+Fh]

  v45 = a4;
  v4 = this;
  v44 = 0i64;
  v5 = 32;
  *((_BYTE *)this + 554) = 0;
  if ( a3 < 0x23 )
    goto LABEL_78;
  v6 = a3 - 35;
  v7 = a2[1] | (*a2 << 8);
  *((_OWORD *)this + 19) = *(_OWORD *)(a2 + 2);
  *((_OWORD *)this + 20) = *(_OWORD *)(a2 + 18);
  v8 = a2[34];
  if ( (unsigned int)v8 > 0x20 )
  {
    v38 = 103;
LABEL_79:
    v39 = 50;
    goto LABEL_80;
  }
  if ( v6 < (int)v8 + 3 )
  {
LABEL_78:
    v38 = 100;
    goto LABEL_79;
  }
  v9 = a2 + 35;
  v10 = &a2[v8 + 35];
  v43 = v10[1] | (*v10 << 8);
  if ( v10[2] )
  {
    v39 = 30;
    v38 = 104;
LABEL_80:
    v23 = -2146893018;
    goto LABEL_81;
  }
  v11 = -3 - v8 + v6;
  if ( !*((_QWORD *)this + 10) )
    return 2148074244i64;
  v12 = ConvertSslVersionToSchannelProtocol(v7);
  v14 = *(_DWORD *)(v13 + 152) & v12 & 0xA2AA0;
  if ( !v14 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)v4, 105, -2146893007, 0x46u);
    return 2148074289i64;
  }
  *((_DWORD *)v4 + 16) = v14;
  *((_WORD *)v4 + 17) = ConvertSchannelProtocolToSsl(v14);
  v19 = *((_DWORD *)v4 + 9);
  if ( *((_BYTE *)v4 + 233) == (_BYTE)v17 )
  {
    if ( v19 <= v16 || v19 < 0x303 )
      goto LABEL_9;
  }
  else if ( v19 > 0xFEFD || v19 >= v16 )
  {
    goto LABEL_9;
  }
  IsMaliciousDowngrade = CSsl3TlsClientContext::IsMaliciousDowngrade(v4, v16);
  v17 = 0i64;
  if ( IsMaliciousDowngrade )
    return 2148074248i64;
  v18 = 2;
LABEL_9:
  if ( v11 <= v18 )
  {
    *((_BYTE *)v4 + 922) = v17;
  }
  else
  {
    Buf1[2] = 0i64;
    v47 = 0;
    v20 = v10[3];
    Buf1[0] = (__int64)&CTlsExtClient::`vftable';
    Buf1[1] = (__int64)v4;
    v48 = v17;
    v49 = v17;
    v50 = v17;
    v52 = v4;
    v51 = *((_BYTE *)v4 + 922);
    v21 = v10[4] | (v20 << 8);
    if ( v11 - 2 < v21 )
    {
      *((_BYTE *)v4 + 922) = v17;
    }
    else
    {
      v22 = CTlsExt::ParseTlsExtensions((__int64)Buf1, v10 + 5, v21, v18);
      v23 = v22;
      if ( v22 )
      {
        if ( v22 != -2146892986 )
          CSslContext::SetErrorAndFatalAlert((__int64)v4, 106, v22, 0xAu);
        CTlsExtClient::~CTlsExtClient((CTlsExtClient *)Buf1);
        return v23;
      }
    }
    CTlsExtClient::~CTlsExtClient((CTlsExtClient *)Buf1);
    LODWORD(v17) = 0;
  }
  if ( *((_BYTE *)v4 + 554) == (_BYTE)v17 )
  {
    if ( *((_BYTE *)v4 + 553) == (_BYTE)v17 )
    {
      if ( g_fAllowInsecureRenegoServers != (_DWORD)v17 )
        goto LABEL_14;
      v41 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      {
LABEL_73:
        CSslContext::SetErrorAndFatalAlert((__int64)v4, 1207, -2146892986, 0x28u);
        result = 2148074310i64;
        *((_DWORD *)v4 + 17) = 96;
        *((_WORD *)v4 + 48) = 10242;
        return result;
      }
      v42 = 52i64;
    }
    else
    {
      v41 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        goto LABEL_73;
      v42 = 51i64;
    }
    WPP_SF_(*((_QWORD *)v41 + 2), v42, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
    goto LABEL_73;
  }
LABEL_14:
  CSessionCacheManager::AcquireCacheTableLock(v15, *(const unsigned __int16 **)(*((_QWORD *)v4 + 165) + 368i64), 0i64);
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)v4 + 165) + 72i64), 1u);
  v24 = (struct CSessionCacheClientItem *)*((_QWORD *)v4 + 165);
  if ( *((unsigned __int16 *)v24 + 119) <= 0x20u )
  {
    v5 = *((unsigned __int16 *)v24 + 119);
    memcpy_0(Buf1, (char *)v24 + 240, *((unsigned __int16 *)v24 + 119));
  }
  if ( !*((_QWORD *)v24 + 2) )
  {
LABEL_17:
    *((_DWORD *)v24 + 42) = *((_DWORD *)v4 + 16);
    if ( (_DWORD)v8 )
    {
      v25 = *((_QWORD *)v4 + 165);
      *(_WORD *)(v25 + 238) = v8;
      if ( v9 )
        memcpy_0((void *)(v25 + 240), v9, v8);
    }
    v26 = 0;
    goto LABEL_21;
  }
  if ( v5 && v5 == (_DWORD)v8 && !memcmp_0(Buf1, v9, v8) )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 53i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
    v35 = *((_QWORD *)v4 + 15);
    v26 = 1;
    if ( v35 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    {
      *(_WORD *)(v35 + 64) |= 1u;
      *(_DWORD *)(v35 + 24) = 1;
    }
  }
  else
  {
    v33 = *((_QWORD *)v4 + 17);
    if ( (v33 & 0xC00000) == 0 )
    {
      v36 = CSessionCacheManager::m_pSessionCacheManager;
      *((_BYTE *)v24 + 236) = 0;
      v23 = CSessionCacheClientItem::CloneCacheElement(*((CSessionCacheClientItem **)v4 + 165), v36, &v44);
      RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 165) + 72i64));
      if ( v23 )
      {
        CSessionCacheManager::ReleaseCacheTableLock(
          v37,
          *(const unsigned __int16 **)(*((_QWORD *)v4 + 165) + 368i64),
          0i64);
        return v23;
      }
      v24 = v44;
      RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)v44 + 72), 1u);
      *((_QWORD *)v4 + 165) = v24;
      *((_QWORD *)v4 + 11) = v24;
      goto LABEL_17;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 54i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      v33 = *((_QWORD *)v4 + 17);
    }
    *((_QWORD *)v4 + 17) = v33 | 0x1000000;
    v26 = 1;
    if ( (_DWORD)v8 )
    {
      *((_WORD *)v4 + 490) = v8;
      if ( v9 )
        memcpy_0((char *)v4 + 982, v9, v8);
    }
    v34 = *((_QWORD *)v4 + 15);
    if ( v34 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    {
      *(_DWORD *)(v34 + 24) = 1;
      *(_WORD *)(v34 + 64) |= 2u;
    }
  }
LABEL_21:
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 165) + 72i64));
  CSessionCacheManager::ReleaseCacheTableLock(v27, *(const unsigned __int16 **)(*((_QWORD *)v4 + 165) + 368i64), 0i64);
  v23 = CCipherMill::SetServerHelloCipher(v28, v4, v43);
  if ( v23 )
  {
    v39 = 40;
    v38 = 107;
    this = v4;
LABEL_81:
    CSslContext::SetErrorAndFatalAlert((__int64)this, v38, v23, v39);
    return v23;
  }
  LOBYTE(v29) = (*((_DWORD *)v4 + 16) & 0x80800) != 0;
  result = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, __int64))(*(_QWORD *)v4 + 496i64))(v4, v29);
  if ( (_DWORD)result )
    return result;
  *((_BYTE *)v4 + 340) = 0;
  LOBYTE(v31) = 1;
  v23 = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, _QWORD, _QWORD, __int64))(*(_QWORD *)v4 + 504i64))(
          v4,
          *((_QWORD *)v4 + 110),
          *((unsigned int *)v4 + 218),
          v31);
  if ( *((_QWORD *)v4 + 110) )
  {
    (*(void (__fastcall **)(CSsl3TlsClientContext *))(*(_QWORD *)v4 + 16i64))(v4);
    *((_QWORD *)v4 + 110) = 0i64;
  }
  v32 = v45;
  *((_DWORD *)v4 + 218) = 0;
  *v32 = v26;
  return v23;
}
// 180005F4A: conditional instruction was optimized away because rsi.8!=0
// 180005BF4: variable 'v13' is possibly undefined
// 180005C1D: variable 'v17' is possibly undefined
// 180005C26: variable 'v16' is possibly undefined
// 180005C2F: variable 'v18' is possibly undefined
// 180005CC6: variable 'v15' is possibly undefined
// 180005D7F: variable 'v27' is possibly undefined
// 180005D8B: variable 'v28' is possibly undefined
// 180005DBB: variable 'v29' is possibly undefined
// 180005DF3: variable 'v31' is possibly undefined
// 18002DD70: variable 'v37' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18007D048: using guessed type void *CTlsExtClient::`vftable';
// 1800919A8: using guessed type int g_fAllowInsecureRenegoServers;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180005FC4) ----------------------------------------------------
__int64 __fastcall ConvertSslVersionToSchannelProtocol(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx

  v1 = a1 - 2;
  if ( !v1 )
    return 12i64;
  v2 = v1 - 766;
  if ( !v2 )
    return 48i64;
  v3 = v2 - 1;
  if ( !v3 )
    return 192i64;
  v4 = v3 - 1;
  if ( !v4 )
    return 768i64;
  v5 = v4 - 1;
  if ( !v5 )
    return 3072i64;
  v7 = v5 - 1;
  if ( !v7 )
    return 12288i64;
  v8 = v7 - 64505;
  if ( !v8 )
    return 786432i64;
  if ( v8 == 2 )
    return 196608i64;
  return 0i64;
}

//----- (0000000180006034) ----------------------------------------------------
bool __fastcall CSessionCacheTable::LookupCacheByName(
        CSessionCacheTable *this,
        unsigned int a2,
        const unsigned __int16 *a3,
        struct CCredentialGroup *a4,
        struct CSessionCacheItem **a5)
{
  __int64 v6; // r13
  _QWORD *v8; // rdi
  int v9; // r15d
  __int64 v10; // r13
  _QWORD **v11; // rcx
  _QWORD *v12; // r14
  _QWORD *v14; // rsi
  struct CCredentialGroup *v15; // rbx
  CSessionCacheTable *v16; // rcx
  __int64 v17; // rcx
  _QWORD *v18; // rdx
  __int64 v19; // [rsp+30h] [rbp-58h] BYREF
  PRTL_RESOURCE Resource; // [rsp+38h] [rbp-50h]
  __int64 v21; // [rsp+90h] [rbp+8h] BYREF
  unsigned int TickCount; // [rsp+98h] [rbp+10h]
  const unsigned __int16 *v23; // [rsp+A0h] [rbp+18h]
  struct CCredentialGroup *v24; // [rsp+A8h] [rbp+20h]

  v24 = a4;
  v23 = a3;
  v6 = a2;
  v8 = 0i64;
  v9 = 0;
  TickCount = GetTickCount();
  v19 = *(_QWORD *)((char *)a4 + 740);
  Resource = (PRTL_RESOURCE)((char *)this + 48);
  RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)this + 48), 1u);
  v10 = 16 * v6;
  v11 = (_QWORD **)(v10 + *(_QWORD *)this);
  v12 = *v11;
  if ( *v11 == v11 )
    goto LABEL_2;
  do
  {
    v14 = v12 - 36;
    v12 = (_QWORD *)*v12;
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(v14 + 9), 1u);
    if ( *((_BYTE *)v14 + 236) )
    {
      if ( !HasTimeElapsed(*((_DWORD *)v14 + 69), TickCount, *((_DWORD *)v14 + 70)) )
      {
        v15 = v24;
        v21 = *((_QWORD *)v24 + 95);
        if ( (*(unsigned __int8 (__fastcall **)(_QWORD *, __int64 *, const unsigned __int16 *, __int64 *, _DWORD))(*v14 + 80i64))(
               v14,
               &v19,
               v23,
               &v21,
               *((_DWORD *)v24 + 38)) )
        {
          if ( CSessionCacheItem::DoesAppAllowCipher((CSessionCacheItem *)v14, v15) )
          {
            if ( !v8 )
            {
              v9 = CSessionCacheTable::ReferenceCacheItemInternal(v16, (struct CSessionCacheItem *)v14);
LABEL_9:
              v8 = v14;
              goto LABEL_10;
            }
            if ( *((_DWORD *)v14 + 69) > *((_DWORD *)v8 + 69) )
            {
              v9 = CSessionCacheTable::ReferenceCacheItemInternal(v16, (struct CSessionCacheItem *)v14);
              RtlAcquireResourceExclusive((PRTL_RESOURCE)(v8 + 9), 1u);
              *((_BYTE *)v8 + 236) = 0;
              CSessionCacheTable::DereferenceCacheItemInternal(this, (struct CSessionCacheItem *)v8, 0, 0);
              RtlReleaseResource((PRTL_RESOURCE)(v8 + 9));
              goto LABEL_9;
            }
            *((_BYTE *)v14 + 236) = 0;
          }
        }
      }
    }
LABEL_10:
    RtlReleaseResource((PRTL_RESOURCE)(v14 + 9));
  }
  while ( v12 != (_QWORD *)(v10 + *(_QWORD *)this) );
  if ( v8 )
  {
    *a5 = (struct CSessionCacheItem *)v8;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xBu, (__int64)&WPP_54aae497645f38b3b161e68e12f6f932_Traceguids, v8);
    if ( v9 == 2 )
    {
      v17 = v8[40];
      if ( *(_QWORD **)(v17 + 8) != v8 + 40 || (v18 = (_QWORD *)v8[41], (_QWORD *)*v18 != v8 + 40) )
        __fastfail(3u);
      *v18 = v17;
      *(_QWORD *)(v17 + 8) = v18;
    }
    LsaIModifyPerformanceCounter(7i64);
  }
LABEL_2:
  RtlReleaseResource(Resource);
  return v8 != 0i64;
}
// 18000618D: variable 'v16' is possibly undefined
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);

//----- (000000018000629C) ----------------------------------------------------
__int64 __fastcall CSessionCacheManager::AcquireCacheTableLock(
        __int64 a1,
        const unsigned __int16 *a2,
        unsigned __int8 *const a3)
{
  CSessionCacheManager *v3; // rbx
  unsigned int v4; // eax
  __int64 v5; // rcx

  v3 = CSessionCacheManager::m_pSessionCacheManager;
  v4 = 0;
  if ( !CSessionCacheManager::m_pSessionCacheManager )
    return 0i64;
  if ( a2 )
  {
    v4 = CSessionCacheManager::ComputeClientCacheIndex(CSessionCacheManager::m_pSessionCacheManager, a2);
  }
  else if ( a3 )
  {
    v4 = *(_DWORD *)a3 % *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 4);
  }
  v5 = *((_QWORD *)v3 + 5) + 152i64 * (v4 / *((_DWORD *)v3 + 13));
  if ( !v5 )
    return 0i64;
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(v5 + 48), 1u);
  return 1i64;
}

//----- (0000000180006300) ----------------------------------------------------
void __fastcall CSessionCacheManager::ReleaseCacheTableLock(
        __int64 a1,
        const unsigned __int16 *a2,
        unsigned __int8 *const a3)
{
  CSessionCacheManager *v3; // rbx
  unsigned int v4; // eax
  __int64 v5; // rcx

  v3 = CSessionCacheManager::m_pSessionCacheManager;
  v4 = 0;
  if ( CSessionCacheManager::m_pSessionCacheManager )
  {
    if ( a2 )
    {
      v4 = CSessionCacheManager::ComputeClientCacheIndex(CSessionCacheManager::m_pSessionCacheManager, a2);
    }
    else if ( a3 )
    {
      v4 = *(_DWORD *)a3 % *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 4);
    }
    v5 = *((_QWORD *)v3 + 5) + 152i64 * (v4 / *((_DWORD *)v3 + 13));
    if ( v5 )
      RtlReleaseResource((PRTL_RESOURCE)(v5 + 48));
  }
}

//----- (0000000180006358) ----------------------------------------------------
__int64 __fastcall CSessionCacheManager::ComputeClientCacheIndex(
        CSessionCacheManager *this,
        const unsigned __int16 *a2)
{
  unsigned int v4; // edx
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // r8
  unsigned __int64 v8; // r11
  __int64 v9; // rcx
  __int64 v10; // rax
  int v12; // r10d
  int v13; // r10d
  int v14; // r10d
  int v15; // r10d
  int v16; // r10d
  int v17; // r10d

  v4 = 0;
  if ( a2 )
  {
    v5 = -1i64;
    do
      ++v5;
    while ( a2[v5] );
    v6 = (unsigned int)(2 * v5);
    v7 = 314159i64;
    if ( (unsigned __int64)v6 >= 8 )
    {
      v8 = (unsigned __int64)(unsigned int)v6 >> 3;
      v6 -= 8 * v8;
      do
      {
        v9 = *((unsigned __int8 *)a2 + 6)
           + 37
           * (*((unsigned __int8 *)a2 + 5)
            + 37
            * (*((unsigned __int8 *)a2 + 4)
             + 37
             * (*((unsigned __int8 *)a2 + 3)
              + 37
              * (*((unsigned __int8 *)a2 + 2)
               + 37 * (*((unsigned __int8 *)a2 + 1) + 37 * (*(unsigned __int8 *)a2 + 37 * v7))))));
        v10 = *((unsigned __int8 *)a2 + 7);
        a2 += 4;
        v7 = v10 + 37 * v9;
        --v8;
      }
      while ( v8 );
    }
    if ( v6 < 1 || v6 > 7 )
      return (unsigned int)v7 % *((_DWORD *)this + 4);
    v12 = v6 - 1;
    if ( v12 )
    {
      v13 = v12 - 1;
      if ( v13 )
      {
        v14 = v13 - 1;
        if ( v14 )
        {
          v15 = v14 - 1;
          if ( v15 )
          {
            v16 = v15 - 1;
            if ( v16 )
            {
              v17 = v16 - 1;
              if ( v17 )
              {
                if ( v17 != 1 )
                  return (unsigned int)v7 % *((_DWORD *)this + 4);
                LODWORD(v7) = *(unsigned __int8 *)a2 + 37 * v7;
                a2 = (const unsigned __int16 *)((char *)a2 + 1);
              }
              LODWORD(v7) = *(unsigned __int8 *)a2 + 37 * v7;
              a2 = (const unsigned __int16 *)((char *)a2 + 1);
            }
            LODWORD(v7) = *(unsigned __int8 *)a2 + 37 * v7;
            a2 = (const unsigned __int16 *)((char *)a2 + 1);
          }
          LODWORD(v7) = *(unsigned __int8 *)a2 + 37 * v7;
          a2 = (const unsigned __int16 *)((char *)a2 + 1);
        }
        LODWORD(v7) = *(unsigned __int8 *)a2 + 37 * v7;
        a2 = (const unsigned __int16 *)((char *)a2 + 1);
      }
      LODWORD(v7) = *(unsigned __int8 *)a2 + 37 * v7;
      a2 = (const unsigned __int16 *)((char *)a2 + 1);
    }
    LODWORD(v7) = *(unsigned __int8 *)a2 + 37 * v7;
    return (unsigned int)v7 % *((_DWORD *)this + 4);
  }
  return v4;
}

//----- (0000000180006430) ----------------------------------------------------
__int64 __fastcall CTlsExt::ParseTlsExtensions(__int64 a1, unsigned __int8 *a2, unsigned int a3, int a4)
{
  __int64 v4; // rax
  char v5; // bp
  unsigned int v6; // ebx
  unsigned __int8 *v7; // rdi
  char v9; // r12
  CCipherMill *v10; // rcx
  unsigned __int16 v11; // r15
  unsigned int v12; // r14d
  unsigned __int8 *v13; // rdi
  unsigned int v14; // ebx
  unsigned __int8 *v15; // r8
  __int64 result; // rax

  v4 = *(_QWORD *)(a1 + 8);
  v5 = 0;
  v6 = a3;
  v7 = a2;
  v9 = *(_BYTE *)(v4 + 64) & 0x30;
  *(_DWORD *)(a1 + 16) = a4;
  *(_BYTE *)(v4 + 922) = 0;
  *(_BYTE *)(a1 + 27) = 0;
  if ( a3 )
  {
    v10 = WPP_GLOBAL_Control;
    while ( v6 >= 4 )
    {
      v11 = _byteswap_ushort(*((_WORD *)v7 + 1));
      v12 = v7[1] | (*v7 << 8);
      if ( v10 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v10 + 28) & 4) != 0 )
      {
        WPP_SF_D(*((_QWORD *)v10 + 2), 73i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids, v12);
        v10 = WPP_GLOBAL_Control;
      }
      v13 = v7 + 4;
      a2 = (unsigned __int8 *)v11;
      v14 = v6 - 4;
      if ( v14 < v11 )
      {
        if ( v10 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v10 + 28) & 2) != 0 )
          WPP_SF_(*((_QWORD *)v10 + 2), 74i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
        return 2148074278i64;
      }
      v15 = v13;
      v7 = &v13[v11];
      v6 = v14 - v11;
      if ( !v9 || v12 == 65281 )
      {
        result = (*(__int64 (__fastcall **)(__int64, _QWORD, unsigned __int8 *, _QWORD))(*(_QWORD *)a1 + 8i64))(
                   a1,
                   v12,
                   v15,
                   v11);
        if ( (_DWORD)result )
          return result;
        v10 = WPP_GLOBAL_Control;
        if ( v12 == 65281 )
          v5 = 1;
      }
      if ( !v6 )
        goto LABEL_13;
    }
    return 2148074278i64;
  }
  else
  {
LABEL_13:
    LOBYTE(a2) = v5;
    (*(void (__fastcall **)(_QWORD, unsigned __int8 *))(**(_QWORD **)(a1 + 8) + 352i64))(*(_QWORD *)(a1 + 8), a2);
    return 0i64;
  }
}
// 18000654D: variable 'a2' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000657C) ----------------------------------------------------
__int64 __fastcall UpdateServerCertificateSerialChainProperty(struct CSsl3TlsClientContext *a1, unsigned int a2)
{
  __int64 v4; // rdx
  __int64 v6; // [rsp+30h] [rbp+8h] BYREF

  v6 = 0i64;
  (*(void (__fastcall **)(struct CSsl3TlsClientContext *, __int64 *))(*(_QWORD *)a1 + 224i64))(a1, &v6);
  v4 = *(unsigned int *)(v6 + 360);
  if ( (_DWORD)v4 )
    I_CertFinishSslHandshake(
      *(_QWORD *)(v6 + 352),
      v4,
      *((unsigned __int8 *)a1 + 307) | ((*((unsigned __int8 *)a1 + 306) | ((*((unsigned __int8 *)a1 + 305) | (*((unsigned __int8 *)a1 + 304) << 8)) << 8)) << 8),
      a2);
  return 0i64;
}
// 180098188: using guessed type __int64 __fastcall I_CertFinishSslHandshake(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180006620) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::DigestFinish(CSsl3TlsContext *this, unsigned __int8 *Src, int a3)
{
  int v3; // r14d
  unsigned int v4; // esi
  int v7; // r14d
  __int64 v8; // rdi
  __int64 *v9; // rax
  unsigned int v10; // r15d
  CCipherMill *v11; // rdi
  char Buf1[40]; // [rsp+30h] [rbp-68h] BYREF

  v3 = *((_DWORD *)this + 16);
  v4 = 36;
  if ( (v3 & 0xF3FC0) != 0 )
    v4 = 12;
  if ( a3 == v4 )
  {
    v7 = v3 & 0xA2AA0;
    v8 = 0i64;
    RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
    v9 = (__int64 *)*((_QWORD *)this + 1);
    if ( v9 )
      v8 = *v9;
    v10 = SslComputeFinishedHash(
            v8,
            *(_QWORD *)(*((_QWORD *)this + 11) + 16i64),
            *((_QWORD *)this + 74),
            Buf1,
            v4,
            (unsigned int)(v7 != 0) + 1);
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
    if ( v10 )
    {
      CSslContext::SetErrorAndFatalAlert((__int64)this, 902, v10, 0x33u);
      return v10;
    }
    else
    {
      v11 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 61i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        v11 = WPP_GLOBAL_Control;
      }
      if ( !memcmp_0(Buf1, Src, v4) )
      {
        if ( v7 )
        {
          if ( v11 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)v11 + 7) & 0x800) != 0 )
            WPP_SF_(*((_QWORD *)v11 + 2), 63i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          memcpy_0((char *)this + 420, Src, v4);
          *((_DWORD *)this + 114) = v4;
        }
        else
        {
          if ( v11 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)v11 + 7) & 0x800) != 0 )
            WPP_SF_(*((_QWORD *)v11 + 2), 64i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          memcpy_0((char *)this + 377, Src, v4);
          *((_DWORD *)this + 104) = v4;
        }
        if ( !*((_BYTE *)this + 340) )
        {
          memcpy_0((char *)this + 341, Buf1, v4);
          *((_BYTE *)this + 340) = 1;
          CSsl3TlsContext::SetTokenBindingEKM(this);
        }
        if ( *((_BYTE *)this + 233) )
        {
          if ( (*((_DWORD *)this + 16) & 0xA0000) != 0 )
            CSsl3TlsContext::FreeSavedWriteCipherState(this);
        }
        return 0i64;
      }
      else
      {
        if ( v11 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v11 + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)v11 + 2), 62i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        CSslContext::SetErrorAndFatalAlert((__int64)this, 900, -2146893048, 0x33u);
        return 2148074248i64;
      }
    }
  }
  else
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 903, -2146893048, 0x32u);
    return 2148074248i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180098538: using guessed type __int64 __fastcall SslComputeFinishedHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180006808) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetTokenBindingEKM(CSsl3TlsContext *this)
{
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rdi
  void *v6; // rbp
  __int64 *v7; // rax
  __int64 v8; // rcx
  unsigned int v9; // esi
  __int64 v10; // rax
  void *v11; // rdi

  if ( !*((_QWORD *)this + 103) )
    return 6i64;
  v3 = *((_QWORD *)this + 11);
  if ( !v3 )
    return 1359i64;
  RtlAcquireResourceShared((PRTL_RESOURCE)(v3 + 72), 1u);
  v4 = *((_QWORD *)this + 11);
  v5 = *(_QWORD *)(v4 + 16);
  if ( !v5 )
  {
    RtlReleaseResource((PRTL_RESOURCE)(v4 + 72));
    return 6i64;
  }
  v6 = (void *)(*(__int64 (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 8i64))(this, 32i64);
  if ( !v6 )
  {
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
    return 14i64;
  }
  v7 = (__int64 *)*((_QWORD *)this + 1);
  if ( v7 )
    v8 = *v7;
  else
    v8 = 0i64;
  v9 = SslExportKeyingMaterial(v8, v5, "EXPORTER-Token-Binding", (char *)this + 272, 64, 0i64, 0, v6, 32, 0);
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
  if ( v9 )
    goto LABEL_16;
  v10 = *((_QWORD *)this + 104);
  if ( v10 )
  {
    v11 = *(void **)(v10 + 8);
    if ( v11 )
    {
      memset(v11, 0, 0x20ui64);
      (*(void (__fastcall **)(CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 16i64))(
        this,
        *(_QWORD *)(*((_QWORD *)this + 104) + 8i64));
      v10 = *((_QWORD *)this + 104);
    }
    goto LABEL_20;
  }
  v10 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 8i64))(this, 16i64);
  *((_QWORD *)this + 104) = v10;
  if ( v10 )
  {
LABEL_20:
    *(_DWORD *)v10 = 32;
    *(_QWORD *)(*((_QWORD *)this + 104) + 8i64) = v6;
    return v9;
  }
  v9 = 14;
LABEL_16:
  memset(v6, 0, 0x20ui64);
  (*(void (__fastcall **)(CSsl3TlsContext *, void *))(*(_QWORD *)this + 16i64))(this, v6);
  return v9;
}
// 180098560: using guessed type __int64 __fastcall SslExportKeyingMaterial(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD, _QWORD, _DWORD, _DWORD);

//----- (000000018000685C) ----------------------------------------------------
__int64 __fastcall CSessionCacheManager::CacheRetrieveNewItem(
        CSessionCacheManager *this,
        char a2,
        const unsigned __int16 *a3,
        unsigned __int8 *const a4,
        struct CSessionCacheItem **a5)
{
  __int64 v7; // rbx
  unsigned int v8; // ebx
  wchar_t *v9; // rax
  unsigned __int16 *v10; // rdi
  unsigned int v11; // r14d
  CSessionCacheClientItem *v12; // rax
  CSessionCacheClientItem *v13; // rdi
  unsigned int v14; // ebx
  unsigned int v15; // ebx
  CSessionCacheTable *v16; // rcx
  _QWORD *v17; // rbp
  __int64 *v18; // r8
  __int64 v19; // rcx
  __int64 **v20; // rax
  _QWORD *v21; // rdi
  _QWORD *v22; // rcx
  __int128 v24; // xmm0
  unsigned int v25; // eax
  int v26; // edx
  unsigned int v27; // ecx
  CSessionCacheItem *v28; // rax
  unsigned __int8 v29[16]; // [rsp+20h] [rbp-38h] BYREF
  __int128 v30; // [rsp+30h] [rbp-28h]

  if ( !a2 )
  {
    v7 = -1i64;
    do
      ++v7;
    while ( a3[v7] );
    v8 = v7 + 1;
    v9 = (wchar_t *)SPExternalAlloc(2 * v8);
    v10 = v9;
    if ( !v9 )
      return 14i64;
    wcscpy_s(v9, v8, a3);
    v11 = CSessionCacheManager::ComputeClientCacheIndex(this, v10);
    v12 = (CSessionCacheClientItem *)SPExternalAlloc(0x1B8u);
    if ( !v12 )
      return 14i64;
    v13 = CSessionCacheClientItem::CSessionCacheClientItem(v12, this, *((_DWORD *)this + 5), v10);
LABEL_7:
    if ( v13 )
      goto LABEL_8;
    return 14i64;
  }
  v24 = *((_OWORD *)a4 + 1);
  v25 = _mm_cvtsi128_si32(*(__m128i *)a4);
  *(_OWORD *)v29 = *(_OWORD *)a4;
  v26 = v25 % *((_DWORD *)this + 4);
  v27 = *(_DWORD *)&v29[4];
  v11 = v26;
  *(_DWORD *)v29 = v26;
  if ( g_SslMachineID != -1 )
    v27 = g_SslMachineID;
  *(_DWORD *)&v29[4] = v27;
  v30 = v24;
  v28 = (CSessionCacheItem *)(*(__int64 (__fastcall **)(struct IAllocate *, __int64))(*(_QWORD *)CSessionCacheServerItem::m_pServerCacheLookaside
                                                                                    + 24i64))(
                               CSessionCacheServerItem::m_pServerCacheLookaside,
                               360i64);
  v13 = v28;
  if ( !v28 )
  {
    v13 = 0i64;
    goto LABEL_7;
  }
  CSessionCacheItem::CSessionCacheItem(v28, *((_DWORD *)this + 6), v29);
  *((_QWORD *)v13 + 42) = 0i64;
  *(_QWORD *)v13 = &CSessionCacheServerItem::`vftable';
  *((_QWORD *)v13 + 43) = 0i64;
  *((_DWORD *)v13 + 88) = 0;
  *((_DWORD *)v13 + 54) = -2146893019;
LABEL_8:
  v14 = *((_DWORD *)v13 + 17);
  if ( v14 )
  {
    (*(void (__fastcall **)(CSessionCacheClientItem *, __int64))(*(_QWORD *)v13 + 8i64))(v13, 1i64);
    return v14;
  }
  else
  {
    v15 = *((_DWORD *)this + 13);
    *a5 = v13;
    v16 = (CSessionCacheTable *)(v11 / v15);
    v17 = (_QWORD *)(*((_QWORD *)this + 5) + 152i64 * (_QWORD)v16);
    CSessionCacheTable::ReferenceCacheItemInternal(v16, v13);
    *((_QWORD *)v13 + 28) = v17;
    v18 = (__int64 *)((char *)v13 + 288);
    v19 = *v17 + 16i64 * (v11 % v15);
    v20 = *(__int64 ***)(v19 + 8);
    if ( *v20 != (__int64 *)v19
      || (*((_QWORD *)v13 + 37) = v20,
          v21 = (_QWORD *)((char *)v13 + 304),
          *v18 = v19,
          *v20 = v18,
          *(_QWORD *)(v19 + 8) = v18,
          v22 = (_QWORD *)v17[3],
          (_QWORD *)*v22 != v17 + 2) )
    {
      __fastfail(3u);
    }
    *v21 = v17 + 2;
    v21[1] = v22;
    *v22 = v21;
    v17[3] = v21;
    _InterlockedIncrement((volatile signed __int32 *)this + 8);
    LsaIModifyPerformanceCounter(4i64);
    return 0i64;
  }
}
// 18007C330: using guessed type void *CSessionCacheServerItem::`vftable';
// 1800919F4: using guessed type unsigned int g_SslMachineID;
// 1800927F8: using guessed type struct IAllocate *CSessionCacheServerItem::m_pServerCacheLookaside;
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);

//----- (00000001800069C4) ----------------------------------------------------
__int64 __fastcall CSessionCacheTable::ReferenceCacheItemInternal(
        CSessionCacheTable *this,
        struct CSessionCacheItem *a2)
{
  unsigned __int32 v2; // ebx

  v2 = _InterlockedIncrement((volatile signed __int32 *)a2 + 58);
  if ( v2 == 2 )
    LsaIModifyPerformanceCounter(5i64);
  return v2;
}
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);

//----- (0000000180006A04) ----------------------------------------------------
CSessionCacheClientItem *__fastcall CSessionCacheClientItem::CSessionCacheClientItem(
        CSessionCacheClientItem *this,
        struct CSessionCacheManager *a2,
        int a3,
        unsigned __int16 *a4)
{
  CSessionCacheItem::CSessionCacheItem(this, a3, 0i64);
  *((_QWORD *)this + 46) = a4;
  *(_QWORD *)this = &CSessionCacheClientItem::`vftable';
  *((_QWORD *)this + 49) = a2;
  *((_QWORD *)this + 42) = 0i64;
  *((_DWORD *)this + 86) = 0;
  *((_QWORD *)this + 44) = 0i64;
  *((_DWORD *)this + 90) = 0;
  *((_QWORD *)this + 48) = 0i64;
  *((_QWORD *)this + 50) = 0i64;
  *((_QWORD *)this + 51) = 0i64;
  *((_DWORD *)this + 104) = 0;
  *((_QWORD *)this + 53) = 0i64;
  *((_DWORD *)this + 108) = 0;
  SslGetClientLogonId((struct _LUID *)this + 47);
  return this;
}
// 18007C210: using guessed type void *CSessionCacheClientItem::`vftable';

//----- (0000000180006AAC) ----------------------------------------------------
ULONG __fastcall SslGetClientLogonId(struct _LUID *a1)
{
  NTSTATUS v2; // eax
  struct _LUID v4; // [rsp+20h] [rbp-28h] BYREF

  *a1 = 0i64;
  v2 = (*(__int64 (__fastcall **)(struct _LUID *))(LsaTable + 128))(&v4);
  if ( v2 >= 0 )
    *a1 = v4;
  return RtlNtStatusToDosError(v2);
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180006B10) ----------------------------------------------------
CSchannelTelemetryContext *__fastcall CSchannelTelemetryContext::`vector deleting destructor'(
        CSchannelTelemetryContext *this,
        char a2)
{
  *(_QWORD *)this = &IAllocate::`vftable';
  if ( (a2 & 1) != 0 )
  {
    if ( LsaTable )
      (*(void (**)(void))(LsaTable + 48))();
    else
      LocalFree(this);
  }
  return this;
}
// 18007C298: using guessed type void *IAllocate::`vftable';
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180006B5C) ----------------------------------------------------
CSessionCacheItem *__fastcall CSessionCacheItem::CSessionCacheItem(
        CSessionCacheItem *this,
        int a2,
        unsigned __int8 *const a3)
{
  char v6; // al
  int v7; // ecx
  int v9[10]; // [rsp+20h] [rbp-28h] BYREF

  CSslBasicAllocator::CSslBasicAllocator(this);
  *(_QWORD *)this = &CSessionCacheItem::`vftable';
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = 0i64;
  *((_QWORD *)this + 3) = 0i64;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = 0i64;
  *((_QWORD *)this + 6) = 0i64;
  *((_QWORD *)this + 7) = 0i64;
  *((_DWORD *)this + 16) = 0;
  *((_DWORD *)this + 42) = 0;
  *((_QWORD *)this + 22) = 0i64;
  *((_DWORD *)this + 46) = 0;
  *((_QWORD *)this + 25) = 0i64;
  *((_BYTE *)this + 208) = 0;
  *((_DWORD *)this + 53) = 0;
  *((_DWORD *)this + 54) = -2146893042;
  *((_DWORD *)this + 55) = 0;
  *((_DWORD *)this + 58) = 1;
  *((_BYTE *)this + 236) = 0;
  *((_DWORD *)this + 69) = GetTickCount();
  *((_DWORD *)this + 70) = a2;
  if ( a3 )
  {
    *((_OWORD *)this + 15) = *(_OWORD *)a3;
    *((_OWORD *)this + 16) = *((_OWORD *)a3 + 1);
  }
  else
  {
    *((_OWORD *)this + 15) = 0i64;
    *((_OWORD *)this + 16) = 0i64;
  }
  if ( LsaTable )
  {
    v6 = (*(__int64 (__fastcall **)(int *))(LsaTable + 192))(v9);
    v7 = -1;
    if ( v6 )
      v7 = v9[0];
    *((_DWORD *)this + 68) = v7;
  }
  else
  {
    *((_DWORD *)this + 68) = GetCurrentProcessId();
  }
  *(_QWORD *)((char *)this + 188) = 0i64;
  RtlInitializeResource((PRTL_RESOURCE)((char *)this + 72));
  *((_DWORD *)this + 17) = 0;
  return this;
}
// 18007C2C0: using guessed type void *CSessionCacheItem::`vftable';
// 180092620: using guessed type __int64 LsaTable;
// 180006B5C: using guessed type int var_28[10];

//----- (0000000180006CCC) ----------------------------------------------------
char __fastcall CTlsSignatureSuiteList::AddBCryptSignatureSuites(
        CTlsSignatureSuiteList *this,
        const unsigned __int16 **const a2,
        unsigned int a3,
        char a4)
{
  char v4; // di
  __int64 i; // r15
  unsigned __int8 v9; // bl
  wchar_t **v10; // rsi
  int v11; // eax
  const wchar_t **v12; // rcx

  v4 = 0;
  if ( a3 )
  {
    for ( i = a3; i; --i )
    {
      v9 = 0;
      v10 = &off_18007C3A0;
      while ( v9 < 0xCu )
      {
        v11 = *((unsigned __int16 *)this + 17);
        if ( !_bittest(&v11, v9) )
          break;
        v4 = 1;
LABEL_9:
        v10 += 9;
        ++v9;
        if ( v10 - 2 >= (wchar_t **)&CSsl3TlsServerContext::`vftable' )
          goto LABEL_10;
      }
      v12 = (const wchar_t **)(v10 - 1);
      if ( !a4 )
        v12 = (const wchar_t **)v10;
      if ( wcsicmp(*v12, *a2) )
        goto LABEL_9;
      v4 |= CTlsSignatureSuiteList::AddSignatureSuite(this, v9);
      if ( !a4 )
        goto LABEL_9;
LABEL_10:
      ++a2;
    }
  }
  if ( a4 )
    CTlsSignatureSuiteList::SetRsaSignatureFlags();
  return v4;
}
// 18007C3A0: using guessed type wchar_t *off_18007C3A0;
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';

//----- (0000000180006DA4) ----------------------------------------------------
unsigned __int8 __fastcall CTlsSignatureSuiteList::AddSignatureSuite(CTlsSignatureSuiteList *this, unsigned __int8 a2)
{
  int v2; // eax
  __int16 v3; // ax

  if ( a2 < 0xCu )
  {
    v2 = *((unsigned __int16 *)this + 17);
    if ( _bittest(&v2, a2) )
      return 1;
    if ( *(_WORD *)this < 0x10u )
    {
      *((_WORD *)this + *(unsigned __int16 *)this + 1) = __ROR2__(*((_WORD *)&unk_18007C390 + 36 * a2), 8);
      v3 = *((_WORD *)this + 17);
      ++*(_WORD *)this;
      *((_WORD *)this + 17) = v3 | (1 << a2);
      return 1;
    }
  }
  return 0;
}

//----- (0000000180006E00) ----------------------------------------------------
__int64 __fastcall CTlsSignatureSuiteList::GetRunningHashList(
        CTlsSignatureSuiteList *this,
        const unsigned __int16 *a2,
        int a3,
        enum _eTlsHashAlgorithm *const a4,
        wchar_t **a5,
        unsigned int *a6)
{
  unsigned __int8 v6; // bl
  unsigned int v10; // ebp
  unsigned int v11; // r14d
  signed int v12; // edi
  unsigned int HashDetailsFromIndex; // eax
  wchar_t *v14; // rsi
  int v15; // eax
  char v16; // cl
  enum _eTlsHashAlgorithm *v17; // rdx
  unsigned __int16 v18; // r9
  __int64 v19; // r10
  int v20; // eax
  enum _eTlsHashAlgorithm v21; // r8d
  int v22; // eax
  __int64 v24; // rcx
  __int64 v25; // [rsp+20h] [rbp-48h]
  enum _eTlsHashAlgorithm v26; // [rsp+30h] [rbp-38h] BYREF
  wchar_t *String2; // [rsp+38h] [rbp-30h] BYREF

  v6 = 0;
  v26 = TlsHashAlgorithm_None;
  String2 = 0i64;
  v10 = -2146893007;
  v11 = 0;
  v12 = 4;
  if ( g_dwHashInfoTotalCount > 4 )
  {
    while ( 1 )
    {
      HashDetailsFromIndex = I_GetHashDetailsFromIndex(v12, &String2, 0i64, (__int64)a4, v25, &v26);
      v14 = String2;
      v10 = HashDetailsFromIndex;
      if ( !HashDetailsFromIndex && !wcsnicmp(a2, String2, 0x40ui64) )
        break;
      v15 = g_dwHashInfoTotalCount;
      if ( ++v12 >= g_dwHashInfoTotalCount )
        goto LABEL_5;
    }
    v15 = g_dwHashInfoTotalCount;
LABEL_5:
    if ( v12 < v15 && v14 )
    {
      v16 = v26;
      v17 = (enum _eTlsHashAlgorithm *)&unk_18007C3B8;
      v11 = 1;
      *a4 = v26;
      v10 = 0;
      v18 = 1 << v16;
      *a5 = v14;
      v19 = 12i64;
      do
      {
        if ( v6 < 0xCu )
        {
          v20 = *((unsigned __int16 *)this + 17);
          if ( _bittest(&v20, v6) )
          {
            if ( (a3 & *(v17 - 4)) != 0 )
            {
              v21 = *v17;
              v22 = v18;
              if ( !_bittest(&v22, *v17) )
              {
                v24 = v11;
                v18 |= 1 << v21;
                ++v11;
                a4[v24] = v21;
                a5[v24] = (wchar_t *)*((_QWORD *)v17 + 1);
              }
            }
          }
        }
        v17 += 18;
        ++v6;
        --v19;
      }
      while ( v19 );
    }
  }
  *a6 = v11;
  return v10;
}
// 180006E5D: variable 'a4' is possibly undefined
// 180006E5D: variable 'v25' is possibly undefined
// 180092324: using guessed type int g_dwHashInfoTotalCount;

//----- (0000000180006F5C) ----------------------------------------------------
__int64 __fastcall CTlsSignatureSuiteList::Blacklist(
        CTlsSignatureSuiteList *this,
        struct _TLS_PARAMETERS *a2,
        unsigned int a3)
{
  unsigned int v3; // ebx
  const wchar_t **v7; // r14
  unsigned __int8 v8; // di
  __int64 v9; // r12
  int v10; // eax

  v3 = 0;
  if ( !a2 || !a3 )
    return 0i64;
  *(_WORD *)this = 0;
  v7 = (const wchar_t **)&off_18007C3B0;
  v8 = 0;
  v9 = 12i64;
  do
  {
    if ( v8 < 0xCu )
    {
      v10 = *((unsigned __int16 *)this + 17);
      if ( _bittest(&v10, v8) )
      {
        *((_WORD *)this + 17) = v10 & ~(1 << v8);
        if ( !IsCngAlgorithmBlacklisted((unsigned __int64)a2, a3, 4, v7[2], 0i64, 0, 0i64, 1)
          && !IsCngAlgorithmBlacklisted((unsigned __int64)a2, a3, 4, *v7, 0i64, 0, 0i64, 1) )
        {
          CTlsSignatureSuiteList::AddSignatureSuite(this, v8);
        }
      }
    }
    v7 += 9;
    ++v8;
    --v9;
  }
  while ( v9 );
  if ( !*(_WORD *)this )
    return (unsigned int)-2146893007;
  return v3;
}
// 18007C3B0: using guessed type wchar_t *off_18007C3B0;

//----- (000000018000706C) ----------------------------------------------------
__int64 __fastcall CCipherMill::BuildCipherSuiteList(
        __int64 a1,
        unsigned int *a2,
        unsigned int a3,
        char a4,
        __int64 a5,
        unsigned int a6,
        __int64 a7,
        _DWORD *a8,
        _QWORD *a9,
        _WORD *a10)
{
  __int64 v11; // rbx
  __int64 v12; // r12
  unsigned int v13; // r13d
  struct _TLS_PARAMETERS *v14; // rdi
  unsigned int v15; // ebp
  _QWORD *v16; // r15
  HLOCAL v17; // rax
  CMasterCipherInfo *v18; // rax
  __int64 v19; // rsi
  __int64 v20; // rdi
  __int64 v21; // rcx
  __int64 v22; // r12
  unsigned int v23; // r15d
  __int64 v24; // rbp
  _WORD *v25; // rax
  unsigned int v26; // ecx
  __int64 v28; // r8
  unsigned int v29; // edx
  char v30; // [rsp+70h] [rbp-68h]
  int v31; // [rsp+74h] [rbp-64h]
  unsigned int v32; // [rsp+78h] [rbp-60h]
  struct _TLS_PARAMETERS *v33; // [rsp+80h] [rbp-58h]
  __int64 v34; // [rsp+88h] [rbp-50h]
  char v35; // [rsp+E0h] [rbp+8h]
  unsigned int v39; // [rsp+100h] [rbp+28h]

  v11 = 0i64;
  v12 = 0i64;
  v30 = 0;
  v13 = 0;
  v34 = 0i64;
  if ( !a5 )
    goto LABEL_57;
  v14 = *(struct _TLS_PARAMETERS **)(a5 + 200);
  v15 = *(_DWORD *)(a5 + 196);
  v33 = v14;
  v39 = v15;
  RtlAcquireResourceShared(&Resource, 1u);
  v16 = a9;
  if ( a9 )
  {
    v17 = SPExternalAlloc(2 * (unsigned int)(unsigned __int16)word_1800925D0);
    *a9 = v17;
    if ( !v17 )
    {
      v13 = 14;
      goto LABEL_46;
    }
  }
  if ( !v15 || (v35 = 1, !IsEcdsaAlgorithmBlacklisted(v14, v15, 0i64, 0, 0, 0i64, 1)) )
    v35 = 0;
  v18 = xmmword_1800925B0;
  if ( *(_BYTE *)(a5 + 172) )
    v18 = *(&xmmword_1800925B0 + 1);
  v19 = 0i64;
  if ( v18 )
  {
    v20 = *(_QWORD *)v18;
    v31 = 0;
    v32 = *((_DWORD *)v18 + 2);
    if ( v32 )
    {
      while ( (unsigned int)v11 < *a8 )
      {
        if ( CCipherMill::IsCipherSuiteAllowed(
               (__int64)g_cCipherMill,
               a2,
               a3,
               a4,
               (*(_DWORD *)(a5 + 156) >> 12) & 1,
               *(_DWORD *)(a5 + 156) & 0x800,
               *(_DWORD *)(a5 + 168),
               *(_DWORD *)(a5 + 164),
               a6,
               v20,
               0i64,
               (unsigned __int64)v33,
               v15,
               1) )
        {
          if ( !v16 || *(_DWORD *)(v20 + 48) != 3 && (*(_DWORD *)(v20 + 8) & 0x3000) == 0 || v12 == *(_QWORD *)v20 )
            goto LABEL_16;
          v22 = *(_QWORD *)(v20 + 848);
          if ( !v22 )
            goto LABEL_22;
          if ( !v30 )
          {
            v23 = 0;
            if ( *(_DWORD *)(v22 + 8) )
            {
              while ( 1 )
              {
                v24 = *(_QWORD *)v22 + 780i64 * v23;
                v25 = (_WORD *)*a9;
                if ( *a9 && (v26 = 0, (_DWORD)v19) )
                {
                  while ( (unsigned __int16)*(_DWORD *)(v24 + 772) != *v25 )
                  {
                    ++v26;
                    ++v25;
                    if ( v26 >= (unsigned int)v19 )
                      goto LABEL_35;
                  }
                }
                else
                {
LABEL_35:
                  if ( (unsigned int)v19 >= (unsigned __int16)word_1800925D0 )
                  {
                    v13 = 1359;
                    goto LABEL_46;
                  }
                  if ( !v39
                    || !IsEcdheAlgorithmBlacklisted(
                          v33,
                          v39,
                          (struct CEccCurveInfo *)(*(_QWORD *)v22 + 780i64 * v23),
                          0i64,
                          1u)
                    && (v35
                     || !IsEcdsaAlgorithmBlacklisted(
                           v33,
                           v39,
                           (const unsigned __int16 *)v24,
                           *(_DWORD *)(v24 + 772),
                           *(_DWORD *)(v24 + 768),
                           0i64,
                           1)) )
                  {
                    *(_WORD *)(*a9 + 2 * v19) = *(_WORD *)(v24 + 772);
                    v19 = (unsigned int)(v19 + 1);
                  }
                }
                if ( ++v23 >= *(_DWORD *)(v22 + 8) )
                {
                  v15 = v39;
                  break;
                }
              }
            }
            v16 = a9;
            v34 = *(_QWORD *)v20;
            v30 = 1;
LABEL_16:
            v21 = 0i64;
            if ( (_DWORD)v11 )
            {
              while ( *(_DWORD *)(v20 + 28) != *(_DWORD *)(a7 + 4 * v21) )
              {
                v21 = (unsigned int)(v21 + 1);
                if ( (unsigned int)v21 >= (unsigned int)v11 )
                  goto LABEL_19;
              }
            }
            else
            {
LABEL_19:
              if ( *(_DWORD *)(v20 + 48) != 3 && (*(_DWORD *)(v20 + 8) & 0x3000) == 0 || (_DWORD)v19 )
              {
                *(_DWORD *)(a7 + 4 * v11) = *(_DWORD *)(v20 + 28);
                v11 = (unsigned int)(v11 + 1);
              }
            }
            goto LABEL_22;
          }
          v28 = 0i64;
          if ( !(_DWORD)v19 )
            goto LABEL_16;
          while ( 1 )
          {
            v29 = 0;
            if ( !*(_DWORD *)(v22 + 8) )
              break;
            while ( *(unsigned __int16 *)(*v16 + 2 * v28) != *(_DWORD *)(780i64 * v29 + *(_QWORD *)v22 + 772) )
            {
              if ( ++v29 >= *(_DWORD *)(v22 + 8) )
                goto LABEL_22;
            }
            v28 = (unsigned int)(v28 + 1);
            if ( (unsigned int)v28 >= (unsigned int)v19 )
              goto LABEL_16;
          }
        }
LABEL_22:
        v20 += 864i64;
        if ( ++v31 >= v32 )
          break;
        v12 = v34;
      }
    }
  }
  *a8 = v11;
  if ( a10 )
    *a10 = v19;
LABEL_46:
  RtlReleaseResource(&Resource);
  if ( !(_DWORD)v11 )
  {
LABEL_57:
    v13 = -2146893007;
    LogCipherMismatchEvent(*(_DWORD *)(a5 + 212), (const unsigned __int16 *)(a5 + 216), a6);
  }
  return v13;
}
// 1800925D0: using guessed type __int16 word_1800925D0;
// 18000706C: using guessed type __int64 arg_20;

//----- (0000000180007410) ----------------------------------------------------
char __fastcall CCipherMill::IsCipherSuiteAllowed(
        __int64 a1,
        unsigned int *a2,
        unsigned int a3,
        char a4,
        int a5,
        int a6,
        unsigned int a7,
        unsigned int a8,
        int a9,
        __int64 a10,
        const UNICODE_STRING *a11,
        unsigned __int64 a12,
        unsigned int a13,
        char a14)
{
  const wchar_t *v17; // r13
  int v18; // r8d
  _DWORD *v19; // rax
  unsigned int v20; // ecx
  char *v21; // rax
  int v22; // edi
  _DWORD *v23; // rax
  unsigned int v24; // ecx
  _DWORD *v25; // rax
  int v26; // ebp
  _DWORD *v27; // rax
  unsigned int v28; // ecx
  _DWORD *v29; // rcx
  int v30; // esi
  _DWORD *v31; // rcx
  unsigned int v32; // eax
  _DWORD *v33; // rcx
  unsigned int v35; // eax
  CCipherMill *v36; // rcx
  unsigned int v37; // eax
  CCipherMill *v38; // rcx
  unsigned int v39; // eax
  unsigned int v40; // eax
  unsigned __int16 v41; // dx
  __int64 v42; // rcx
  unsigned __int16 v43; // dx
  bool v44; // bl
  int v45; // r8d
  int v46; // [rsp+20h] [rbp-48h]

  if ( !a10 )
  {
    v17 = L"<NULL>";
LABEL_46:
    v36 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v43 = 10;
    v46 = a9;
    goto LABEL_116;
  }
  v17 = (const wchar_t *)(a10 + 74);
  if ( (*(_DWORD *)(a10 + 8) & a9) == 0 )
    goto LABEL_46;
  if ( (*(_DWORD *)(a10 + 48) == 4) != a5 )
    return 0;
  if ( a6 )
  {
    v35 = *(_DWORD *)(a10 + 40);
    if ( v35 < 0x6604 || v35 >= 0x6801 )
    {
      v37 = v35 - 24576;
      if ( !v37 || (v39 = v37 - 1537) == 0 || (v40 = v39 - 2) == 0 || v40 == 510 )
      {
        v38 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          return 0;
        v41 = 11;
        goto LABEL_113;
      }
    }
    if ( *(_BYTE *)(a10 + 72) || *(_DWORD *)(a10 + 44) == 32771 )
      return 0;
  }
  if ( a8 )
  {
    if ( !a7 )
    {
LABEL_9:
      if ( *(_DWORD *)(a10 + 20) >= a8 )
        goto LABEL_10;
      v36 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
        return 0;
      v43 = 14;
      v46 = a8;
LABEL_116:
      v42 = *((_QWORD *)v36 + 2);
LABEL_117:
      WPP_SF_SD(v42, v43, (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids, v17, v46);
      return 0;
    }
  }
  else if ( !a7 )
  {
    if ( *(_DWORD *)(a10 + 40) != 24576 )
    {
      v38 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
        return 0;
      v41 = 12;
      goto LABEL_113;
    }
    goto LABEL_10;
  }
  if ( *(_DWORD *)(a10 + 20) > a7 )
  {
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v46 = a7;
    v43 = 13;
    v42 = *((_QWORD *)WPP_GLOBAL_Control + 2);
    goto LABEL_117;
  }
  if ( a8 )
    goto LABEL_9;
LABEL_10:
  v18 = *(_DWORD *)(a10 + 32);
  v19 = &g_AvailableExch;
  v20 = 0;
  while ( *v19 != v18 )
  {
    ++v20;
    v19 += 16;
    if ( v20 >= 4 )
      goto LABEL_16;
  }
  v21 = (char *)&g_AvailableExch + 64 * (unsigned __int64)v20;
  if ( v21 && (a9 & *((_DWORD *)v21 + 1)) == 0 )
  {
    v38 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v41 = 15;
    goto LABEL_113;
  }
LABEL_16:
  v22 = *(_DWORD *)(a10 + 44);
  v23 = &unk_180091028;
  v24 = 0;
  while ( *v23 != v22 )
  {
    ++v24;
    v23 += 10;
    if ( v24 >= 5 )
      goto LABEL_22;
  }
  v25 = (_DWORD *)((char *)&g_AvailableHashes + 40 * v24);
  if ( v25 && (a9 & *v25) == 0 )
  {
    v38 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v41 = 16;
    goto LABEL_113;
  }
LABEL_22:
  v26 = *(_DWORD *)(a10 + 40);
  v27 = &unk_180091100;
  v28 = 0;
  while ( *v27 != v26 )
  {
    ++v28;
    v27 += 14;
    if ( v28 >= 8 )
      goto LABEL_26;
  }
  v29 = (_DWORD *)((char *)&g_AvailableCiphers + 56 * v28);
  if ( v29 && (a9 & 0xF3FFFu & *v29) <= (a9 & 0xF3FFFu) >> 1 )
  {
    v36 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v43 = 17;
    v46 = a9 & 0xF3FFF;
    goto LABEL_116;
  }
LABEL_26:
  v30 = *(_DWORD *)(a10 + 36);
  v31 = &unk_1800913EC;
  v32 = 0;
  while ( *v31 != v30 )
  {
    ++v32;
    v31 += 8;
    if ( v32 >= 5 )
      goto LABEL_32;
  }
  v33 = (_DWORD *)((char *)&g_AvailableSigs + 32 * v32);
  if ( v33 && (a9 & *v33) == 0 )
  {
    v36 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v43 = 18;
    v46 = a9 & 0xF3FFF;
    goto LABEL_116;
  }
LABEL_32:
  if ( a3 )
  {
    v44 = (*(_DWORD *)(a10 + 8) & 0x3000) == 0;
    if ( (a4 & 4) == 0 || !v44 || DoesCredAllowAlgId(a2, a3, v18) )
    {
      if ( (a4 & 1) == 0 || !v44 || DoesCredAllowAlgId(a2, a3, v30) )
      {
        if ( (a4 & 8) == 0 || DoesCredAllowAlgId(a2, a3, v26) )
        {
          if ( (a4 & 2) == 0 || DoesCredAllowAlgId(a2, a3, v22) )
            return 1;
          v36 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          {
            return 0;
          }
          v43 = 22;
          v46 = v22;
        }
        else
        {
          v36 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          {
            return 0;
          }
          v43 = 21;
          v46 = v26;
        }
      }
      else
      {
        v36 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          return 0;
        v43 = 20;
        v46 = v30;
      }
    }
    else
    {
      v36 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
        return 0;
      v43 = 19;
      v46 = v45;
    }
    goto LABEL_116;
  }
  if ( !a13 )
    return 1;
  if ( IsCngAlgorithmBlacklisted(a12, a13, 0, (const wchar_t *)(a10 + 330), 0i64, 0, a11, a14) )
  {
    v38 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v41 = 23;
    goto LABEL_113;
  }
  if ( IsCngAlgorithmBlacklisted(a12, a13, 1, (const wchar_t *)(a10 + 458), 0i64, 0, a11, a14) )
  {
    v38 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v41 = 24;
    goto LABEL_113;
  }
  if ( IsCngAlgorithmBlacklisted(
         a12,
         a13,
         2,
         (const wchar_t *)(a10 + 202),
         (wchar_t *)(a10 + 714),
         *(_DWORD *)(a10 + 20),
         a11,
         a14) )
  {
    v38 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v41 = 25;
    goto LABEL_113;
  }
  if ( !IsCngAlgorithmBlacklisted(a12, a13, 3, (const wchar_t *)(a10 + 586), 0i64, 0, a11, a14) )
    return 1;
  v38 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    v41 = 26;
LABEL_113:
    WPP_SF_S(
      *((_QWORD *)v38 + 2),
      v41,
      (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
      (const wchar_t *)(a10 + 74));
  }
  return 0;
}
// 18003384F: variable 'v45' is possibly undefined
// 1800856E0: using guessed type wchar_t aNull_1[7];

//----- (00000001800077A0) ----------------------------------------------------
char __fastcall IsCngAlgorithmBlacklisted(
        unsigned __int64 a1,
        unsigned int a2,
        int a3,
        const wchar_t *a4,
        wchar_t *a5,
        unsigned int a6,
        const UNICODE_STRING *String2,
        char a8)
{
  int v9; // r15d
  unsigned __int64 v10; // rdi
  __int64 v11; // rax
  unsigned __int64 v12; // rbp
  unsigned int v14; // esi
  unsigned __int64 v15; // rsi
  unsigned __int64 v16; // r8
  __int64 v17; // rax
  __int64 v18; // rax
  unsigned int v19; // eax
  unsigned int v20; // eax
  const wchar_t **v21; // r15
  unsigned __int64 v22; // r8
  __int64 v23; // rax
  __int64 v24; // rdx
  __int64 v25; // r8

  v9 = a3;
  v10 = a1;
  if ( !a2 )
    return 0;
  if ( !a1 )
    return 0;
  if ( !a4 )
    return 0;
  v11 = -1i64;
  do
    ++v11;
  while ( a4[v11] );
  if ( !v11 )
    return 0;
  v12 = a1 + 40i64 * a2;
  if ( a1 >= v12 )
    return 0;
  while ( 1 )
  {
    if ( *(_DWORD *)(v10 + 20) )
    {
      if ( !*(_DWORD *)v10 )
        goto LABEL_15;
      if ( String2 )
        break;
    }
LABEL_11:
    v10 += 40i64;
    if ( v10 >= v12 )
      return 0;
  }
  v14 = 0;
  while ( RtlCompareUnicodeString((PCUNICODE_STRING)(*(_QWORD *)(v10 + 8) + 16i64 * v14), String2, 1u) )
  {
    if ( ++v14 >= *(_DWORD *)v10 )
      goto LABEL_11;
  }
LABEL_15:
  if ( a8 && (*(_BYTE *)(v10 + 32) & 1) != 0 )
    goto LABEL_11;
  v15 = *(_QWORD *)(v10 + 24);
  if ( v15 >= v15 + 48i64 * *(unsigned int *)(v10 + 20) )
    goto LABEL_11;
  while ( 1 )
  {
    if ( *(_DWORD *)v15 != v9 )
      goto LABEL_19;
    v16 = *(unsigned __int16 *)(v15 + 8);
    v17 = -1i64;
    do
      ++v17;
    while ( a4[v17] );
    if ( 2 * v17 != v16 || wcsncmp(*(const wchar_t **)(v15 + 16), a4, v16 >> 1) )
      goto LABEL_19;
    v18 = *(unsigned int *)(v15 + 24);
    if ( !(_DWORD)v18 && !*(_DWORD *)(v15 + 40) && !*(_DWORD *)(v15 + 44) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_Sd(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xCu,
          (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
          a4,
          v9);
      return 1;
    }
    if ( !a5 )
      goto LABEL_28;
    v21 = *(const wchar_t ***)(v15 + 32);
    if ( v21 < &v21[2 * v18] )
      break;
LABEL_39:
    v9 = a3;
LABEL_28:
    if ( a6 )
    {
      v19 = *(_DWORD *)(v15 + 40);
      if ( !v19 )
      {
        if ( !*(_DWORD *)(v15 + 44) )
          goto LABEL_19;
        v20 = *(_DWORD *)(v15 + 44);
LABEL_49:
        if ( v20 < a6 )
        {
LABEL_50:
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_Sdd(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xEu,
              (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
              a4,
              a6,
              v9);
          }
          return 1;
        }
        goto LABEL_19;
      }
      if ( v19 > a6 )
        goto LABEL_50;
      v20 = *(_DWORD *)(v15 + 44);
      if ( v20 )
        goto LABEL_49;
    }
LABEL_19:
    v15 += 48i64;
    if ( v15 >= *(_QWORD *)(v10 + 24) + 48 * (unsigned __int64)*(unsigned int *)(v10 + 20) )
      goto LABEL_11;
  }
  while ( 1 )
  {
    v22 = *(unsigned __int16 *)v21;
    v23 = -1i64;
    do
      ++v23;
    while ( a5[v23] );
    if ( 2 * v23 == v22 && !wcsncmp(v21[1], a5, v22 >> 1) )
      break;
    v21 += 2;
    if ( (unsigned __int64)v21 >= *(_QWORD *)(v15 + 32) + 16 * (unsigned __int64)*(unsigned int *)(v15 + 24) )
      goto LABEL_39;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_SSd(*((_QWORD *)WPP_GLOBAL_Control + 2), v24, v25, a4, a5, a3);
  return 1;
}
// 180033AB9: variable 'v24' is possibly undefined
// 180033AB9: variable 'v25' is possibly undefined

//----- (00000001800079EC) ----------------------------------------------------
char __fastcall IsEcdheAlgorithmBlacklisted(
        struct _TLS_PARAMETERS *a1,
        unsigned int a2,
        struct CEccCurveInfo *a3,
        struct _UNICODE_STRING *a4,
        unsigned __int8 a5)
{
  unsigned int v9; // r15d
  struct _TLS_PARAMETERS *v10; // rdi
  struct _TLS_PARAMETERS *v11; // rax
  const wchar_t *v12; // r9
  unsigned int v14; // ebx
  unsigned __int64 v15; // rbx
  unsigned __int64 i; // rcx
  struct _TLS_PARAMETERS *v17; // [rsp+40h] [rbp-38h]

  if ( !a2 || !a1 || !a3 )
    return 0;
  v9 = *((_DWORD *)a3 + 192);
  v10 = a1;
  v11 = (struct _TLS_PARAMETERS *)((char *)a1 + 40 * a2);
  v17 = v11;
  if ( a1 < v11 )
  {
    while ( 1 )
    {
      if ( !*((_DWORD *)v10 + 5) )
        goto LABEL_8;
      if ( *(_DWORD *)v10 )
      {
        if ( !a4 )
          goto LABEL_8;
        v14 = 0;
        while ( RtlCompareUnicodeString((PCUNICODE_STRING)(*((_QWORD *)v10 + 1) + 16i64 * v14), a4, 1u) )
        {
          if ( ++v14 >= *(_DWORD *)v10 )
          {
LABEL_35:
            v11 = v17;
            goto LABEL_8;
          }
        }
        v11 = v17;
      }
      if ( !a5 || (*((_BYTE *)v10 + 32) & 1) == 0 )
        break;
LABEL_8:
      v10 = (struct _TLS_PARAMETERS *)((char *)v10 + 40);
      if ( v10 >= v11 )
        goto LABEL_9;
    }
    v15 = *((_QWORD *)v10 + 3);
    for ( i = v15 + 48i64 * *((unsigned int *)v10 + 5); ; i = *((_QWORD *)v10 + 3) + 48i64 * *((unsigned int *)v10 + 5) )
    {
      if ( v15 >= i )
        goto LABEL_35;
      if ( !*(_DWORD *)v15 && *(_WORD *)(v15 + 8) == 8 && !wcsncmp(*(const wchar_t **)(v15 + 16), L"ECDH", 4ui64) )
      {
        if ( !*(_DWORD *)(v15 + 24) && !*(_DWORD *)(v15 + 40) && !*(_DWORD *)(v15 + 44) )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_Sd(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xCu,
              (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
              L"ECDH",
              0);
          }
          return 1;
        }
        if ( v9 )
        {
          if ( *(_DWORD *)(v15 + 40) )
          {
            if ( *(_DWORD *)(v15 + 40) > v9 )
              goto LABEL_46;
          }
          else if ( !*(_DWORD *)(v15 + 44) )
          {
            goto LABEL_25;
          }
          if ( *(_DWORD *)(v15 + 44) && *(_DWORD *)(v15 + 44) < v9 )
          {
LABEL_46:
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_Sdd(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0xEu,
                (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
                L"ECDH",
                v9,
                0);
            }
            return 1;
          }
        }
      }
LABEL_25:
      v15 += 48i64;
    }
  }
LABEL_9:
  if ( !IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 0, (const wchar_t *)a3, 0i64, 0, a4, a5) )
  {
    switch ( *((_DWORD *)a3 + 193) )
    {
      case 0x17:
        v12 = L"ECDH_P256";
        return IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 0, v12, 0i64, 0, a4, a5);
      case 0x18:
        v12 = L"ECDH_P384";
        return IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 0, v12, 0i64, 0, a4, a5);
      case 0x19:
        v12 = L"ECDH_P521";
        return IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 0, v12, 0i64, 0, a4, a5);
    }
    return 0;
  }
  return 1;
}

//----- (0000000180007C20) ----------------------------------------------------
char __fastcall IsEcdsaAlgorithmBlacklisted(
        struct _TLS_PARAMETERS *a1,
        unsigned int a2,
        const unsigned __int16 *a3,
        int a4,
        unsigned int a5,
        PCUNICODE_STRING String2,
        char a7)
{
  struct _TLS_PARAMETERS *v10; // rax
  struct _TLS_PARAMETERS *v11; // rdi
  int v12; // esi
  int v13; // esi
  const wchar_t *v15; // r9
  unsigned int v16; // ebx
  unsigned __int64 v17; // rbx
  unsigned __int64 i; // rcx
  struct _TLS_PARAMETERS *v19; // [rsp+40h] [rbp-38h]
  const unsigned __int16 *v20; // [rsp+90h] [rbp+18h]

  v20 = a3;
  if ( !a2 || !a1 )
    return 0;
  v10 = (struct _TLS_PARAMETERS *)((char *)a1 + 40 * a2);
  v19 = v10;
  v11 = a1;
  if ( a1 < v10 )
  {
    while ( 1 )
    {
      if ( !*((_DWORD *)v11 + 5) )
        goto LABEL_7;
      if ( *(_DWORD *)v11 )
      {
        if ( !String2 )
          goto LABEL_7;
        v16 = 0;
        while ( RtlCompareUnicodeString((PCUNICODE_STRING)(*((_QWORD *)v11 + 1) + 16i64 * v16), String2, 1u) )
        {
          if ( ++v16 >= *(_DWORD *)v11 )
          {
LABEL_36:
            v10 = v19;
            goto LABEL_7;
          }
        }
        v10 = v19;
      }
      if ( !a7 || (*((_BYTE *)v11 + 32) & 1) == 0 )
        break;
LABEL_7:
      v11 = (struct _TLS_PARAMETERS *)((char *)v11 + 40);
      if ( v11 >= v10 )
      {
        a3 = v20;
        goto LABEL_9;
      }
    }
    v17 = *((_QWORD *)v11 + 3);
    for ( i = v17 + 48i64 * *((unsigned int *)v11 + 5); ; i = *((_QWORD *)v11 + 3) + 48i64 * *((unsigned int *)v11 + 5) )
    {
      if ( v17 >= i )
        goto LABEL_36;
      if ( *(_DWORD *)v17 == 1 && *(_WORD *)(v17 + 8) == 10 && !wcsncmp(*(const wchar_t **)(v17 + 16), L"ECDSA", 5ui64) )
      {
        if ( !*(_DWORD *)(v17 + 24) && !*(_DWORD *)(v17 + 40) && !*(_DWORD *)(v17 + 44) )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_Sd(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xCu,
              (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
              L"ECDSA",
              1);
          }
          return 1;
        }
        if ( a5 )
        {
          if ( *(_DWORD *)(v17 + 40) )
          {
            if ( *(_DWORD *)(v17 + 40) > a5 )
              goto LABEL_47;
          }
          else if ( !*(_DWORD *)(v17 + 44) )
          {
            goto LABEL_26;
          }
          if ( *(_DWORD *)(v17 + 44) && *(_DWORD *)(v17 + 44) < a5 )
          {
LABEL_47:
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_Sdd(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0xEu,
                (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
                L"ECDSA",
                a5,
                1);
            }
            return 1;
          }
        }
      }
LABEL_26:
      v17 += 48i64;
    }
  }
LABEL_9:
  if ( a3 && IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 1, a3, 0i64, 0, String2, a7) )
    return 1;
  v12 = a4 - 23;
  if ( v12 )
  {
    v13 = v12 - 1;
    if ( v13 )
    {
      if ( v13 != 1 )
        return 0;
      v15 = L"ECDSA_P521";
    }
    else
    {
      v15 = L"ECDSA_P384";
    }
  }
  else
  {
    v15 = L"ECDSA_P256";
  }
  return IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 1, v15, 0i64, 0, String2, a7);
}
// 1800821D8: using guessed type wchar_t aEcdsaP384[11];
// 180082E10: using guessed type wchar_t aEcdsaP521[11];

//----- (0000000180007E50) ----------------------------------------------------
__int64 __fastcall I_GetHashDetailsFromIndex(
        unsigned int a1,
        _QWORD *a2,
        _DWORD *a3,
        __int64 a4,
        __int64 a5,
        _DWORD *a6)
{
  __int64 v6; // rcx

  if ( a3 )
    *a3 = 0;
  if ( a2 )
    *a2 = 0i64;
  if ( a6 )
    *a6 = 0;
  if ( a1 < g_dwHashInfoTotalCount && (v6 = g_pHashInfo[a1]) != 0 )
    return I_GetHashDetailsFromHashInfo(v6, a2, a3, (__int64)a2, 0i64, a6);
  else
    return 1168i64;
}
// 180092324: using guessed type int g_dwHashInfoTotalCount;
// 180092330: using guessed type _QWORD g_pHashInfo[16];

//----- (0000000180007EB0) ----------------------------------------------------
__int64 __fastcall I_GetHashDetailsFromHashInfo(__int64 a1, _QWORD *a2, _DWORD *a3, __int64 a4, _DWORD *a5, _DWORD *a6)
{
  if ( a3 )
    *a3 = *(_DWORD *)(a1 + 8);
  if ( a5 )
    *a5 = *(_DWORD *)(a1 + 16);
  if ( a2 )
    *a2 = *(_QWORD *)a1;
  if ( a6 )
    *a6 = *(_DWORD *)(a1 + 20);
  return 0i64;
}

//----- (0000000180007EF4) ----------------------------------------------------
char __fastcall CTlsSignatureSuiteList::AddCertificateSignatureSuite(
        CTlsSignatureSuiteList *this,
        PCCERT_CONTEXT pCertContext)
{
  BOOL CertificateContextProperty; // eax
  DWORD v4; // edx
  unsigned __int64 v5; // rdx
  DWORD pcbData; // [rsp+20h] [rbp-A8h] BYREF
  unsigned __int16 *v8; // [rsp+28h] [rbp-A0h] BYREF
  __int16 pvData[64]; // [rsp+30h] [rbp-98h] BYREF

  pcbData = 128;
  v8 = (unsigned __int16 *)pvData;
  CertificateContextProperty = CertGetCertificateContextProperty(pCertContext, 0x59u, pvData, &pcbData);
  v4 = pcbData >> 1;
  if ( !CertificateContextProperty || v4 - 1 > 0x3F )
    return 0;
  v5 = v4 - 1;
  if ( v5 >= 64 )
    _report_rangecheckfailure(0i64);
  pvData[v5] = 0;
  return CTlsSignatureSuiteList::AddBCryptSignatureSuites(this, (const unsigned __int16 **const)&v8, 1u, 0);
}
// 1800281B8: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD);

//----- (0000000180007FAC) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::DigestRemoteCertificate(
        CSsl3TlsContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  unsigned int v3; // edi
  CSsl3TlsContext *v4; // rsi
  unsigned __int8 *v5; // r14
  int v6; // ebp
  unsigned int v7; // ebp
  _QWORD *v8; // rax
  void *v9; // rcx
  void *v10; // rcx
  const CERT_CONTEXT *v11; // rcx
  int v12; // ebx
  unsigned __int8 *v13; // r9
  unsigned int v14; // ecx
  DWORD v15; // r8d
  __int64 v16; // rax
  PCCERT_CONTEXT CertificateContext; // rax
  const struct _CERT_CONTEXT *v18; // r14
  unsigned int PublicKeyFromCert; // ebx
  int *v20; // r13
  int v21; // r12d
  __int64 v22; // rcx
  struct _SecPkgContext_ApplicationProtocol *v23; // rax
  _DWORD *v24; // rax
  _DWORD *v25; // r14
  unsigned __int8 *v26; // r12
  _DWORD *v27; // r15
  const void *v28; // rdx
  size_t v29; // r8
  __int64 v30; // rbx
  __int64 v31; // rax
  __int64 v33; // rax
  __int64 v34; // rax
  const unsigned __int16 *v35; // rbx
  const wchar_t *v36; // r9
  int v37; // r8d
  int v38; // edx
  unsigned __int8 v39; // r9
  struct _SecPkgContext_ApplicationProtocol *v40; // [rsp+20h] [rbp-A8h]
  struct CCipherSuiteInfo *v41; // [rsp+28h] [rbp-A0h]
  unsigned int v42; // [rsp+40h] [rbp-88h]
  int v43; // [rsp+40h] [rbp-88h]
  int v44; // [rsp+44h] [rbp-84h]
  struct _PUBLICKEY *v45; // [rsp+48h] [rbp-80h] BYREF
  unsigned __int8 *v46; // [rsp+50h] [rbp-78h]
  unsigned __int8 *v47; // [rsp+58h] [rbp-70h]
  __int16 v48; // [rsp+60h] [rbp-68h] BYREF
  __int128 v49; // [rsp+62h] [rbp-66h]
  __int128 v50; // [rsp+72h] [rbp-56h]
  __int16 v51; // [rsp+82h] [rbp-46h]

  v3 = 0;
  v48 = 0;
  v4 = this;
  v49 = 0i64;
  v50 = 0i64;
  v51 = 0;
  if ( a3 < 3 )
    goto LABEL_66;
  v5 = a2 + 3;
  v6 = (*a2 << 16) + (a2[1] << 8);
  v47 = a2 + 3;
  v7 = a2[2] + v6;
  if ( a3 != v7 + 3 )
    goto LABEL_66;
  if ( v7 )
  {
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
    v8 = (_QWORD *)*((_QWORD *)v4 + 11);
    v9 = (void *)v8[3];
    if ( v9 )
    {
      SPExternalFree(v9);
      v33 = *((_QWORD *)v4 + 11);
      *(_DWORD *)(v33 + 32) = 0;
      *(_QWORD *)(v33 + 24) = 0i64;
      v8 = (_QWORD *)*((_QWORD *)v4 + 11);
    }
    v10 = (void *)v8[5];
    if ( v10 )
    {
      SPExternalFree(v10);
      *(_QWORD *)(*((_QWORD *)v4 + 11) + 40i64) = 0i64;
      v8 = (_QWORD *)*((_QWORD *)v4 + 11);
    }
    v11 = (const CERT_CONTEXT *)v8[6];
    if ( v11 )
    {
      CertFreeCertificateContext(v11);
      *(_QWORD *)(*((_QWORD *)v4 + 11) + 48i64) = 0i64;
    }
    v12 = 0;
    v44 = 0;
    v13 = v5;
    v14 = v7;
    while ( 1 )
    {
      if ( v14 <= 3
        || (v15 = v13[2] + (*v13 << 16) + (v13[1] << 8), v16 = v15 + 3, v14 < (unsigned int)v16)
        || (v46 = &v13[v16],
            v42 = -3 - v15 + v14,
            CertificateContext = CertCreateCertificateContext(1u, v13 + 3, v15),
            (v18 = CertificateContext) == 0i64) )
      {
        RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
        this = v4;
        goto LABEL_66;
      }
      if ( (*((_DWORD *)v4 + 16) & 0xC0C00) != 0 )
      {
        if ( v12
          && CertCompareCertificateName(
               CertificateContext->dwCertEncodingType,
               &CertificateContext->pCertInfo->Issuer,
               &CertificateContext->pCertInfo->Subject) )
        {
LABEL_36:
          CertFreeCertificateContext(v18);
          goto LABEL_28;
        }
        if ( !CTlsSignatureSuiteList::AddCertificateSignatureSuite((CTlsSignatureSuiteList *)&v48, v18) )
        {
          RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
          v3 = -2146893048;
          CSslContext::SetErrorAndFatalAlert((__int64)v4, 252, -2146893048, 0x2Bu);
          CertFreeCertificateContext(v18);
          return v3;
        }
      }
      if ( v12 )
        goto LABEL_36;
      v45 = 0i64;
      PublicKeyFromCert = GetPublicKeyFromCert(v18, &v45, 0i64);
      if ( PublicKeyFromCert )
      {
        RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
        v37 = -2146893048;
        goto LABEL_56;
      }
      v20 = (int *)*((_QWORD *)v4 + 1);
      v21 = *((_DWORD *)v4 + 16) & 0x40051555;
      if ( !v20 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 51i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
        PublicKeyFromCert = -1073741595;
        v39 = 80;
        v37 = -1073741595;
        v38 = 254;
        goto LABEL_58;
      }
      v22 = *((_QWORD *)v4 + 10);
      if ( *(_DWORD *)(v22 + 196) )
      {
        if ( v21 )
        {
          v23 = (struct _SecPkgContext_ApplicationProtocol *)(*(__int64 (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)v4 + 88i64))(v4);
          v22 = *((_QWORD *)v4 + 10);
        }
        else
        {
          v23 = 0i64;
        }
        PublicKeyFromCert = IsRemoteCertificateBlacklisted(
                              *(struct _TLS_PARAMETERS **)(v22 + 200),
                              *(_DWORD *)(v22 + 196),
                              v18,
                              v45,
                              v23,
                              (struct CCipherSuiteInfo *)v20,
                              v21 != 0);
        if ( PublicKeyFromCert )
        {
          RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
          if ( PublicKeyFromCert == -2146893007 )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 52i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
            }
            v37 = -2146893007;
LABEL_56:
            v38 = 251;
            v39 = 43;
LABEL_58:
            CSslContext::SetErrorAndFatalAlert((__int64)v4, v38, v37, v39);
          }
          CertFreeCertificateContext(v18);
          return PublicKeyFromCert;
        }
      }
      if ( !v21 && !(unsigned int)IsCertKeyUsageCompliant(v20[8], v20[9], v18) )
      {
        v34 = (*(__int64 (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)v4 + 320i64))(v4);
        v35 = (const unsigned __int16 *)v34;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          v36 = L"NULL";
          if ( v34 )
            v36 = (const wchar_t *)v34;
          LODWORD(v40) = v20[8];
          LODWORD(v41) = v20[9];
          WPP_SF_Sdd(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x35u,
            (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
            v36,
            v40,
            v41);
        }
        CSchannelTelemetryContext::LogCertKeyUsageError((unsigned int)v20[8], v20[9], v35);
      }
      v12 = v44;
      *(_QWORD *)(*((_QWORD *)v4 + 11) + 40i64) = v45;
      *(_QWORD *)(*((_QWORD *)v4 + 11) + 48i64) = v18;
LABEL_28:
      v14 = v42;
      v44 = ++v12;
      if ( !v42 )
      {
        if ( (*((_DWORD *)v4 + 16) & 0xC0C00) != 0
          && !CTlsSignatureSuiteList::IsSupportedSignatureSuiteList(
                (CSsl3TlsContext *)((char *)v4 + 474),
                (struct CTlsSignatureSuiteList *)&v48) )
        {
          RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
          v3 = -2146893048;
          CSslContext::SetErrorAndFatalAlert((__int64)v4, 252, -2146893048, 0x28u);
        }
        else
        {
          v43 = v12 + v7;
          v24 = SPExternalAlloc(v12 + v7);
          v25 = v24;
          if ( v24 )
          {
            v26 = v47;
            v27 = v24;
            do
            {
              v28 = v26 + 3;
              v29 = v26[2] + (*v26 << 16) + (v26[1] << 8);
              *v27 = v29;
              v7 += -3 - v29;
              v30 = (unsigned int)v29;
              v26 += (unsigned int)(v29 + 3);
              memcpy_0(v27 + 1, v28, v29);
              v27 = (_DWORD *)((char *)v27 + v30 + 4);
            }
            while ( v7 );
            v31 = *((_QWORD *)v4 + 11);
            *(_DWORD *)(v31 + 32) = v43;
            *(_QWORD *)(v31 + 24) = v25;
            RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
          }
          else
          {
            RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
            return 14;
          }
        }
        return v3;
      }
      v13 = v46;
    }
  }
  if ( (*((_DWORD *)this + 16) & 0x800A2AAA) != 0 )
  {
LABEL_66:
    v3 = -2146893048;
    CSslContext::SetErrorAndFatalAlert((__int64)this, 250, -2146893048, 0x2Au);
  }
  else
  {
    *((_BYTE *)this + 552) = 1;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 50i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
  }
  return v3;
}
// 180033D18: variable 'v40' is possibly undefined
// 180033D18: variable 'v41' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180083C60: using guessed type wchar_t aNull_0[5];

//----- (0000000180008310) ----------------------------------------------------
char __fastcall IsCertificateBlacklisted(
        struct _TLS_PARAMETERS *a1,
        unsigned int a2,
        int a3,
        unsigned int a4,
        struct CEccCurveInfo *a5,
        unsigned __int8 a6,
        unsigned __int8 a7,
        const unsigned __int16 *a8,
        const unsigned __int16 *a9,
        struct _UNICODE_STRING *String2,
        char a11)
{
  char v14; // si
  char v15; // al
  char v17; // al

  if ( a2 && a1 && a3 && a8 && a9 )
  {
    if ( a3 == 8707 )
    {
      if ( a5 )
      {
        v15 = IsEcdsaAlgorithmBlacklisted(a1, a2, (const unsigned __int16 *)a5, *((_DWORD *)a5 + 193), a4, String2, a11);
        goto LABEL_11;
      }
    }
    else
    {
      if ( a3 == 8704 )
      {
        v15 = IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 1, L"DSA", 0i64, a4, String2, a11);
        goto LABEL_11;
      }
      if ( ((a3 - 9216) & 0xFFFF7FFF) != 0 )
        goto LABEL_12;
      v14 = 0;
      if ( a6 )
      {
        if ( a3 == 41984 )
        {
          v17 = IsRsaAlgorithmBlacklisted((unsigned __int64)a1, a2, 0, a4, String2, a11);
          v14 = v17;
          if ( !a7 )
          {
            if ( v17 )
              return 1;
          }
        }
      }
      v15 = IsRsaAlgorithmBlacklisted((unsigned __int64)a1, a2, 1, a4, String2, a11);
      if ( !a7 || v14 )
      {
LABEL_11:
        if ( !v15 )
          goto LABEL_12;
        return 1;
      }
    }
LABEL_12:
    if ( !IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 4, a8, 0i64, 0, 0i64, 1) )
      return IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 4, a9, 0i64, 0, 0i64, 1);
    return 1;
  }
  return 0;
}

//----- (00000001800084B0) ----------------------------------------------------
char __fastcall CCipherMill::IsUserSpecifiedCipherAllowed(
        __int64 a1,
        unsigned int *a2,
        unsigned int a3,
        char a4,
        int a5,
        int a6,
        unsigned int a7,
        unsigned int a8,
        int a9,
        char a10,
        unsigned __int64 a11,
        unsigned int a12)
{
  char v12; // bl
  CMasterCipherInfo *v13; // rax
  unsigned int v14; // edi
  unsigned int v15; // esi
  __int64 i; // rbp
  char IsCipherSuiteAllowed; // al

  v12 = 0;
  RtlAcquireResourceShared(&Resource, 1u);
  v13 = xmmword_1800925B0;
  if ( a10 )
    v13 = *(&xmmword_1800925B0 + 1);
  if ( v13 )
  {
    v14 = *((_DWORD *)v13 + 2);
    v15 = 0;
    for ( i = *(_QWORD *)v13; v15 < v14; v12 = IsCipherSuiteAllowed )
    {
      if ( v12 )
        break;
      IsCipherSuiteAllowed = CCipherMill::IsCipherSuiteAllowed(
                               (__int64)g_cCipherMill,
                               a2,
                               a3,
                               a4,
                               a5,
                               a6,
                               a7,
                               a8,
                               a9,
                               i + 864i64 * v15++,
                               0i64,
                               a11,
                               a12,
                               1);
    }
  }
  RtlReleaseResource(&Resource);
  return v12;
}

//----- (0000000180008600) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::InitHandshakeHash(CSsl3TlsContext *this, char a2)
{
  __int64 *v2; // rax
  __int64 v5; // r14
  unsigned int v6; // r15d
  unsigned int v7; // ebp
  unsigned int i; // edi
  __int64 result; // rax
  unsigned int v10; // edi
  unsigned int CipherSuitePRFHashAlgorithm; // r13d
  int v12; // r8d
  unsigned int v13; // esi
  char *v14; // r12
  __int64 v15; // rcx
  unsigned int v16[4]; // [rsp+30h] [rbp-148h] BYREF
  unsigned __int16 *v17[16]; // [rsp+40h] [rbp-138h] BYREF
  unsigned __int16 v18[64]; // [rsp+C0h] [rbp-B8h] BYREF

  v2 = (__int64 *)*((_QWORD *)this + 1);
  if ( v2 )
    v5 = *v2;
  else
    v5 = 0i64;
  v6 = *((unsigned __int16 *)this + 17);
  if ( (*((_BYTE *)this + 32) & 1) != 0 && v2 )
    v7 = *((_DWORD *)v2 + 7);
  else
    v7 = 0;
  for ( i = 0; i < *((_DWORD *)this + 137); ++i )
  {
    v14 = (char *)this + 8 * i;
    v15 = *((_QWORD *)v14 + 74);
    if ( v15 )
    {
      SslFreeObject(v15, 0i64);
      *((_QWORD *)v14 + 74) = 0i64;
    }
  }
  *((_DWORD *)this + 180) = 0;
  *((_DWORD *)this + 137) = 0;
  result = SslCreateHandshakeHash(v5, (char *)this + 592, v6, v7, 0);
  if ( !(_DWORD)result )
  {
    v10 = 1;
    *((_DWORD *)this + 137) = 1;
    if ( !a2 )
      return 0i64;
    v16[0] = 0;
    CipherSuitePRFHashAlgorithm = SslGetCipherSuitePRFHashAlgorithm(v5, v6, v7, 0i64, v18, 0);
    if ( !CipherSuitePRFHashAlgorithm )
    {
      v12 = *((_DWORD *)this + 16);
      v18[63] = 0;
      CipherSuitePRFHashAlgorithm = CTlsSignatureSuiteList::GetRunningHashList(
                                      (CSsl3TlsContext *)((char *)this + 474),
                                      v18,
                                      v12,
                                      (enum _eTlsHashAlgorithm *const)this + 180,
                                      v17,
                                      v16);
      if ( !CipherSuitePRFHashAlgorithm )
      {
        v13 = v16[0];
        if ( v16[0] <= 1 )
          return 0i64;
        while ( 1 )
        {
          CipherSuitePRFHashAlgorithm = SslCreateClientAuthHash(v5, (char *)this + 8 * v10 + 592, v6, v7, v17[v10], 0);
          if ( CipherSuitePRFHashAlgorithm )
            break;
          *((_DWORD *)this + 137) = ++v10;
          if ( v10 >= v13 )
            return 0i64;
        }
      }
    }
    CSsl3TlsContext::FreeHandshakeHash(this);
    return CipherSuitePRFHashAlgorithm;
  }
  return result;
}
// 180098430: using guessed type __int64 __fastcall SslCreateClientAuthHash(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098438: using guessed type __int64 __fastcall SslGetCipherSuitePRFHashAlgorithm(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098440: using guessed type __int64 __fastcall SslCreateHandshakeHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);
// 180008600: using guessed type unsigned int var_148[4];

//----- (00000001800087D0) ----------------------------------------------------
__int64 __fastcall CCipherMill::SetServerHelloCipher(CCipherMill *this, struct CSsl3TlsClientContext *a2, int a3)
{
  __int64 v3; // rdi
  unsigned int v4; // ebp
  unsigned int *v7; // r15
  unsigned int v8; // r12d
  int v9; // r13d
  CMasterCipherInfo *v10; // rax
  unsigned int v11; // ecx
  __int64 v12; // rbx
  unsigned int v13; // eax
  __int64 v14; // rax
  unsigned int v15; // ebx

  v3 = *((_QWORD *)a2 + 10);
  v4 = *((_DWORD *)a2 + 16);
  v7 = *(unsigned int **)(v3 + 184);
  v8 = *(_DWORD *)(v3 + 176);
  v9 = *(_DWORD *)(v3 + 192);
  RtlAcquireResourceShared(&Resource, 1u);
  v10 = xmmword_1800925B0;
  if ( (*((_DWORD *)a2 + 34) & 0x20000000) != 0 )
    v10 = *(&xmmword_1800925B0 + 1);
  if ( !v10 )
    goto LABEL_15;
  v11 = *((_DWORD *)v10 + 2);
  v12 = *(_QWORD *)v10;
  v13 = 0;
  if ( !v11 )
    goto LABEL_15;
  while ( *(_DWORD *)(v12 + 28) != a3 )
  {
    ++v13;
    v12 += 864i64;
    if ( v13 >= v11 )
      goto LABEL_15;
  }
  if ( !CCipherMill::IsCipherSuiteAllowed(
          (__int64)g_cCipherMill,
          v7,
          v8,
          v9,
          (*(_DWORD *)(v3 + 156) >> 12) & 1,
          *(_DWORD *)(v3 + 156) & 0x800,
          *(_DWORD *)(v3 + 168),
          *(_DWORD *)(v3 + 164),
          v4,
          v12,
          0i64,
          0i64,
          0,
          1) )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 58i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
LABEL_15:
    RtlReleaseResource(&Resource);
    LogCipherMismatchEvent(*(_DWORD *)(v3 + 212), (const unsigned __int16 *)(v3 + 216), v4);
    return 2148074289i64;
  }
  v14 = *(_QWORD *)(v12 + 848);
  if ( v14 )
    _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v14 + 16) + 12i64));
  _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v12 + 856) + 12i64));
  v15 = CSslContext::SetCipherState(a2, (struct CCipherSuiteInfo *)v12);
  RtlReleaseResource(&Resource);
  return v15;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180008948) ----------------------------------------------------
__int64 __fastcall CSslContext::SetCipherState(CSslContext *this, struct CCipherSuiteInfo *a2)
{
  unsigned int v4; // ebp
  __int64 v5; // rax
  __int64 v6; // rsi
  CSslCredential *v7; // r14
  CSslServerKey *v8; // rcx
  int v9; // eax
  __int64 result; // rax
  __int64 v11; // rcx
  unsigned int v12; // ecx
  int v13; // eax
  _BYTE Source1[20]; // [rsp+40h] [rbp-38h] BYREF

  v4 = 0;
  v5 = (*(__int64 (__fastcall **)(CSslContext *))(*(_QWORD *)this + 248i64))(this);
  v6 = *((_QWORD *)this + 1);
  v7 = (CSslCredential *)v5;
  if ( v6 )
  {
    v11 = *(_QWORD *)(v6 + 848);
    if ( v11 )
      CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v11 + 16));
    CMasterCipherInfo::Dereference(*(CMasterCipherInfo **)(v6 + 856));
  }
  v8 = (CSslServerKey *)*((_QWORD *)this + 3);
  if ( v8 )
  {
    CSslServerKey::Dereference(v8);
    *((_QWORD *)this + 3) = 0i64;
  }
  if ( v7 )
    CSslCredential::GetProviderSpecificMasterKey(v7, *(_QWORD *)a2, (struct CSslServerKey **)this + 3);
  if ( (*((_DWORD *)this + 16) & 0xF3F00) != 0 )
  {
    v4 = SslLookupCipherLengths(
           *(_QWORD *)a2,
           *((unsigned __int16 *)this + 17),
           *((unsigned int *)a2 + 7),
           *((unsigned int *)this + 4),
           Source1,
           20,
           0);
    if ( v4 )
      goto LABEL_10;
  }
  else
  {
    *(_QWORD *)&Source1[12] = 0i64;
    v12 = *((_DWORD *)a2 + 3);
    v13 = *((_DWORD *)a2 + 4);
    *(_QWORD *)Source1 = 20i64;
    *(_DWORD *)&Source1[8] = v13;
    if ( v12 > 1 )
    {
      *(_DWORD *)&Source1[16] |= 1u;
      *(_DWORD *)&Source1[12] = v12;
    }
  }
  if ( (*((_BYTE *)this + 32) & 1) == 0 || RtlCompareMemory(Source1, (char *)this + 40, 0x14ui64) == 20 )
  {
    v9 = *(_DWORD *)&Source1[16];
    *(_OWORD *)((char *)this + 40) = *(_OWORD *)Source1;
    *((_DWORD *)this + 14) = v9;
  }
  else
  {
    v4 = -2146893007;
  }
LABEL_10:
  *((_WORD *)this + 16) |= 1u;
  result = v4;
  *((_QWORD *)this + 1) = a2;
  return result;
}
// 1800984F0: using guessed type __int64 __fastcall SslLookupCipherLengths(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180008A4C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::PackClientHello(
        CSsl3TlsClientContext *this,
        struct _Ssl2_Client_Hello *a2,
        struct SPBuffer *a3)
{
  unsigned int v6; // esi
  char v7; // al
  bool v8; // cf
  unsigned int v9; // eax
  __int64 v10; // rcx
  int v11; // r14d
  unsigned int ClientHelloExtensionsLength; // ebx
  char v13; // dl
  unsigned int v14; // r14d
  unsigned int v15; // r15d
  unsigned int v16; // ecx
  unsigned int v17; // r15d
  unsigned int v18; // r15d
  unsigned int v19; // esi
  _BYTE *v20; // rsi
  _BYTE *v21; // rsi
  __int64 v22; // rdx
  int v23; // ecx
  _BYTE *v24; // rsi
  _BYTE *i; // rsi
  _BYTE *v26; // rsi
  char v27; // al
  unsigned int v28; // eax
  __int64 v29; // rcx
  HLOCAL Memory; // rax
  __int64 v32; // rcx
  _BYTE *v33; // rsi
  __int16 v34; // cx
  _BYTE *v35; // rdx
  __int16 v36; // [rsp+20h] [rbp-60h]
  int v37; // [rsp+28h] [rbp-58h]
  unsigned int v38; // [rsp+30h] [rbp-50h]
  unsigned int Size; // [rsp+34h] [rbp-4Ch]
  unsigned int Size_4; // [rsp+38h] [rbp-48h]
  unsigned int v41; // [rsp+3Ch] [rbp-44h]
  __int64 v42[3]; // [rsp+40h] [rbp-40h] BYREF
  int v43; // [rsp+58h] [rbp-28h]
  char v44; // [rsp+60h] [rbp-20h]
  __int64 v45; // [rsp+68h] [rbp-18h]
  int v46; // [rsp+70h] [rbp-10h]
  char v47; // [rsp+74h] [rbp-Ch]
  CSsl3TlsClientContext *v48; // [rsp+78h] [rbp-8h]
  unsigned __int8 v49; // [rsp+C0h] [rbp+40h]
  unsigned int v50; // [rsp+D8h] [rbp+58h] BYREF

  v42[1] = (__int64)this;
  v42[2] = 0i64;
  v42[0] = (__int64)&CTlsExtClient::`vftable';
  v43 = 0;
  v44 = 0;
  v45 = 0i64;
  v6 = 0;
  v46 = 0;
  v48 = this;
  v47 = *((_BYTE *)this + 922);
  v7 = *((_BYTE *)this + 233);
  Size = 0;
  v50 = 0;
  if ( !v7 && (*((_BYTE *)this + 32) & 4) != 0 )
    v38 = *((_DWORD *)this + 11);
  else
    v38 = 0;
  v8 = v7 != 0;
  v49 = 0;
  v9 = *((_DWORD *)this + 15);
  v10 = *((_QWORD *)this + 165);
  Size_4 = v9;
  v11 = v8 ? 12 : 4;
  v41 = v11;
  if ( v10 )
    RtlAcquireResourceShared((PRTL_RESOURCE)(v10 + 72), 1u);
  ClientHelloExtensionsLength = CTlsExtClient::GetClientHelloExtensionsLength((CTlsExtClient *)v42, &v50);
  if ( ClientHelloExtensionsLength )
    goto LABEL_42;
  v13 = *((_BYTE *)this + 233);
  if ( v13 )
  {
    if ( *((_DWORD *)this + 327) )
    {
      v6 = *((unsigned __int8 *)this + 1312);
      Size = v6;
    }
    else
    {
      Size = 0;
    }
  }
  v14 = v50 + v11 + 2 * *((_DWORD *)a2 + 1) + *((_DWORD *)a2 + 2) + 39;
  if ( v13 )
    v14 += v6 + 1;
  if ( (*((_DWORD *)this + 16) & 0x2A88) == 0 && (*((_BYTE *)this + 64) & 0x20) != 0 && !v50 )
  {
    v14 += 2;
    v49 = 1;
  }
  v15 = v14;
  if ( v13 )
  {
    v19 = Size_4;
    v18 = v14 + Size_4;
  }
  else
  {
    if ( (*((_BYTE *)this + 32) & 4) != 0 )
    {
      v16 = *((_DWORD *)this + 13);
      v17 = v14 + *((_DWORD *)this + 12);
      if ( v16 )
      {
        if ( (*((_BYTE *)this + 56) & 1) != 0 )
          v16 -= v17 % v16;
        v17 += v16;
      }
      v15 = *((_DWORD *)this + 11) + v17;
    }
    v18 = *((_DWORD *)this + 15) + v15;
    v19 = Size_4;
  }
  ClientHelloExtensionsLength = CSsl3TlsContext::AllocateOutputBuffer(this, a3, v18);
  if ( ClientHelloExtensionsLength )
  {
LABEL_42:
    v32 = *((_QWORD *)this + 165);
    if ( v32 )
      RtlReleaseResource((PRTL_RESOURCE)(v32 + 72));
  }
  else
  {
    v20 = (_BYTE *)(*((_QWORD *)a3 + 1) + v19 + v38 + (unsigned __int64)v41);
    *v20++ = *((_BYTE *)a2 + 1);
    *v20++ = *(_BYTE *)a2;
    *(_OWORD *)v20 = *((_OWORD *)a2 + 3);
    *((_OWORD *)v20 + 1) = *((_OWORD *)a2 + 4);
    v20 += 32;
    *v20++ = *((_BYTE *)a2 + 8);
    memcpy_0(v20, (char *)a2 + 16, *((unsigned int *)a2 + 2));
    v21 = &v20[*((unsigned int *)a2 + 2)];
    if ( *((_BYTE *)this + 233) )
    {
      *v21++ = Size;
      if ( *((_DWORD *)this + 327) && Size )
      {
        memcpy_0(v21, (char *)this + 1052, Size);
        v21 += Size;
      }
      else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
             && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_13477250810f3961702f89c94d47ffd6_Traceguids);
      }
    }
    v22 = 0i64;
    v23 = 2 * (*((_DWORD *)a2 + 1) + v49);
    *v21 = (unsigned __int16)(*((_WORD *)a2 + 2) + v49) >> 7;
    v24 = v21 + 1;
    *v24 = v23;
    for ( i = v24 + 1; (unsigned int)v22 < *((_DWORD *)a2 + 1); i = v26 + 1 )
    {
      *i = *((_BYTE *)a2 + 4 * v22 + 81);
      v26 = i + 1;
      v27 = *((_BYTE *)a2 + 4 * v22 + 80);
      v22 = (unsigned int)(v22 + 1);
      *v26 = v27;
    }
    if ( v49 )
    {
      *i = 0;
      v33 = i + 1;
      *v33 = -1;
      i = v33 + 1;
    }
    *i = 1;
    i[1] = 0;
    v28 = CTlsExtClient::BuildClientHelloExtension((CTlsExtClient *)v42, v50, i + 2, &v50);
    v29 = *((_QWORD *)this + 165);
    ClientHelloExtensionsLength = v28;
    if ( v29 )
      RtlReleaseResource((PRTL_RESOURCE)(v29 + 72));
    if ( !ClientHelloExtensionsLength )
    {
      v37 = *((unsigned __int8 *)this + 233);
      v36 = *((_WORD *)this + 110);
      *((_WORD *)this + 110) = v36 + 1;
      SetHandshakeHeader(
        *((_QWORD *)a3 + 1) + v38 + (unsigned __int64)Size_4,
        1,
        0i64,
        (unsigned __int16)(v14 - v41),
        v36,
        v37);
      if ( *((_QWORD *)this + 110) )
      {
        (*(void (__fastcall **)(CSsl3TlsClientContext *))(*(_QWORD *)this + 16i64))(this);
        *((_QWORD *)this + 110) = 0i64;
      }
      *((_DWORD *)this + 218) = v14;
      Memory = CSslContext::GetMemory(this, v14);
      *((_QWORD *)this + 110) = Memory;
      if ( Memory )
      {
        memcpy_0(
          Memory,
          (const void *)(*((_QWORD *)a3 + 1) + v38 + (unsigned __int64)Size_4),
          *((unsigned int *)this + 218));
        if ( *((_BYTE *)this + 233) )
        {
          v34 = *((_WORD *)this + 17);
          ClientHelloExtensionsLength = 0;
          v35 = (_BYTE *)*((_QWORD *)a3 + 1);
          v35[12] = v14;
          v35[11] = BYTE1(v14);
          v35[1] = HIBYTE(v34);
          v35[2] = v34;
          *v35 = 22;
          *((_DWORD *)a3 + 1) += v18;
        }
        else
        {
          ClientHelloExtensionsLength = CSsl3TlsContext::WrapMessage((__int64)this, (__int64)a3, 22, v14);
        }
      }
      else
      {
        ClientHelloExtensionsLength = 14;
      }
    }
  }
  CTlsExtClient::~CTlsExtClient((CTlsExtClient *)v42);
  return ClientHelloExtensionsLength;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18007D048: using guessed type void *CTlsExtClient::`vftable';

//----- (0000000180008DA0) ----------------------------------------------------
void __fastcall CTlsExtClient::~CTlsExtClient(CTlsExtClient *this)
{
  void *v2; // rcx

  *(_QWORD *)this = &CTlsExtClient::`vftable';
  v2 = (void *)*((_QWORD *)this + 5);
  if ( v2 )
    SPExternalFree(v2);
  *(_QWORD *)this = &CTlsExt::`vftable';
}
// 18007D038: using guessed type void *CTlsExt::`vftable';
// 18007D048: using guessed type void *CTlsExtClient::`vftable';

//----- (0000000180008DE0) ----------------------------------------------------
__int64 __fastcall SpDeleteContext(void *a1)
{
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  const wchar_t *v5; // rbp
  __int64 v6; // rbx
  int v7; // esi
  unsigned int v8; // eax
  CCipherMill *v9; // rax
  __int64 v10; // rcx
  int v11; // esi
  int v12; // ebp
  int v13; // ebx
  __int64 v14; // rsi
  char v15; // bl
  __int64 v16; // rcx
  __int64 v17; // r8
  const wchar_t *v19; // r9
  unsigned int v20; // ecx
  unsigned int v21; // eax
  __int64 v22; // r14
  void *v23; // rax
  __int64 v24; // rax
  void *v25; // rax
  void (__fastcall *v26)(__int64, __int64); // rbx
  __int64 v27; // rax
  void *v28; // rax
  __int128 v29; // [rsp+40h] [rbp-48h] BYREF
  __int64 v30; // [rsp+50h] [rbp-38h]
  int v31[2]; // [rsp+58h] [rbp-30h] BYREF
  __int64 v32; // [rsp+60h] [rbp-28h]

  v2 = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)a1 + 1) + 320i64))(*((_QWORD *)a1 + 1));
  v4 = *((_QWORD *)a1 + 1);
  v5 = (const wchar_t *)v2;
  v6 = *(_QWORD *)(v4 + 80);
  if ( v6 && LsaTable )
  {
    v29 = 0i64;
    v30 = 0i64;
    v7 = 8;
    if ( (*(unsigned __int8 (__fastcall **)(__int128 *))(LsaTable + 192))(&v29) && (BYTE8(v29) & 0x40) != 0 )
      v7 = 4;
    v8 = *(_DWORD *)(v6 + 736);
    if ( v8 > 1 )
    {
      v32 = 0i64;
      v31[1] = 0;
      v31[0] = 2 * v7 * v8;
      v32 = (*(__int64 (**)(void))(LsaTable + 384))();
      if ( v32 )
        (*(void (__fastcall **)(__int64, _QWORD, _QWORD, int *, _BYTE))(LsaTable + 496))(5i64, 0i64, 0i64, v31, 0);
    }
  }
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
  {
    v19 = &Class;
    if ( v5 )
      v19 = v5;
    McTemplateU0pz_EtwEventWriteTransfer(v4, v3, (__int64)a1, v19);
  }
  v9 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x34u, (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids, a1);
    v9 = WPP_GLOBAL_Control;
  }
  v10 = *((_QWORD *)a1 + 1);
  v11 = *(_DWORD *)(v10 + 64);
  v12 = *(_DWORD *)(v10 + 68);
  if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
  {
    WPP_SF_q(*((_QWORD *)v9 + 2), 0x12u, (__int64)&WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids, a1);
    v10 = *((_QWORD *)a1 + 1);
  }
  if ( v10 )
  {
    v13 = *(_DWORD *)(v10 + 64);
    (**(void (__fastcall ***)(__int64, _QWORD))v10)(v10, 0i64);
    if ( (v13 & 0x800A2AAA) != 0 )
      SPExternalFree(*((void **)a1 + 1));
    *((_QWORD *)a1 + 1) = 0i64;
  }
  if ( (v11 & 0x51550) != 0 )
  {
    v14 = *((_QWORD *)a1 + 3);
    v15 = *((_BYTE *)a1 + 32);
    if ( !v14 )
    {
LABEL_20:
      *((_QWORD *)a1 + 3) = 0i64;
      (*(void (__fastcall **)(_QWORD, void *))(*(_QWORD *)xmmword_180092DD0 + 32i64))(xmmword_180092DD0, a1);
      goto LABEL_21;
    }
    if ( v12 == 4 )
    {
      v20 = (*(unsigned __int16 (__fastcall **)(__int64))(*(_QWORD *)v14 + 64i64))(v14);
      v21 = qword_180092DB8;
      if ( (unsigned int)qword_180092DB8 <= v20 )
        v21 = v20;
      LODWORD(qword_180092DB8) = v21;
      if ( _InterlockedIncrement((_DWORD *)&qword_180092DB0 + 1) == 100 )
      {
        v22 = *((_QWORD *)&xmmword_180092DD0 + 1);
        if ( !*((_QWORD *)&xmmword_180092DD0 + 1) )
          goto LABEL_44;
        LODWORD(qword_180092DC0) = qword_180092DB8;
        if ( dword_180092DE0 )
        {
          v23 = operator new(0x80ui64);
          if ( v23 )
          {
            v24 = CSslLookasidePreallocate::CSslLookasidePreallocate((__int64)v23, qword_180092DC0, dword_180092DE0);
LABEL_40:
            v22 = *((_QWORD *)&xmmword_180092DD0 + 1);
            if ( v24 )
              v22 = v24;
            *((_QWORD *)&xmmword_180092DD0 + 1) = v22;
            goto LABEL_44;
          }
        }
        else
        {
          v25 = operator new(0x50ui64);
          if ( v25 )
          {
            v24 = CSslLookaside::CSslLookaside((__int64)v25, qword_180092DC0, 1);
            goto LABEL_40;
          }
        }
      }
    }
    v22 = *((_QWORD *)&xmmword_180092DD0 + 1);
LABEL_44:
    if ( v15 )
    {
      v28 = (void *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 40i64))(v14);
      SPExternalFree(v28);
    }
    else
    {
      v26 = *(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v22 + 32i64);
      v27 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 40i64))(v14);
      v26(v22, v27);
    }
    goto LABEL_20;
  }
  SPExternalFree(a1);
LABEL_21:
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EtwEventWriteTransfer(v16, (__int64)&DscStop, v17, 1, (__int64)v31);
  return 0i64;
}
// 18003446B: variable 'v16' is possibly undefined
// 18003446B: variable 'v17' is possibly undefined
// 1800342C5: variable 'v4' is possibly undefined
// 1800342C5: variable 'v3' is possibly undefined
// 180092620: using guessed type __int64 LsaTable;
// 180092DB0: using guessed type __int64 qword_180092DB0;
// 180092DB8: using guessed type __int64 qword_180092DB8;
// 180092DC0: using guessed type __int64 qword_180092DC0;
// 180092DD0: using guessed type __int128 xmmword_180092DD0;
// 180092DE0: using guessed type int dword_180092DE0;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;

//----- (0000000180008FB8) ----------------------------------------------------
void __fastcall FreeTlsParameters(struct _TLS_PARAMETERS *a1, unsigned int a2)
{
  unsigned int v2; // r12d
  char *v5; // rbx
  unsigned int i; // edi
  void *v7; // rcx
  __int64 j; // r14
  __int64 v9; // rdi
  void *v10; // rcx
  void *v11; // rdx
  void *v12; // rcx
  __int64 v13; // rcx
  void *v14; // rcx
  unsigned int v15; // r15d
  void *v16; // rcx

  v2 = 0;
  if ( a2 )
  {
    v5 = (char *)a1 + 20;
    while ( a1 )
    {
      for ( i = 0; i < *((_DWORD *)v5 - 5); ++i )
      {
        v13 = *(_QWORD *)(v5 - 12);
        if ( v13 )
        {
          v14 = *(void **)(v13 + 16i64 * i + 8);
          if ( v14 )
            SPExternalFree(v14);
        }
      }
      v7 = *(void **)(v5 - 12);
      if ( v7 )
      {
        SPExternalFree(v7);
        *(_QWORD *)(v5 - 12) = 0i64;
        *((_DWORD *)v5 - 5) = 0;
      }
      for ( j = 0i64; (unsigned int)j < *(_DWORD *)v5; j = (unsigned int)(j + 1) )
      {
        v9 = *(_QWORD *)(v5 + 4);
        if ( !v9 )
          break;
        v10 = *(void **)(v9 + 48 * j + 16);
        if ( v10 )
          SPExternalFree(v10);
        v11 = *(void **)(v9 + 48 * j + 32);
        if ( v11 )
        {
          v15 = 0;
          if ( *(_DWORD *)(v9 + 48 * j + 24) )
          {
            do
            {
              v16 = v11;
              if ( v11 && *((_QWORD *)v11 + 2 * v15 + 1) )
              {
                SPExternalFree(*((void **)v11 + 2 * v15 + 1));
                v11 = *(void **)(v9 + 48 * j + 32);
                v16 = v11;
              }
              ++v15;
            }
            while ( v15 < *(_DWORD *)(v9 + 48 * j + 24) );
            if ( !v16 )
              continue;
          }
          else
          {
            v16 = *(void **)(v9 + 48 * j + 32);
          }
          SPExternalFree(v16);
          *(_QWORD *)(v9 + 48 * j + 32) = 0i64;
        }
      }
      v12 = *(void **)(v5 + 4);
      if ( v12 )
      {
        SPExternalFree(v12);
        *(_QWORD *)(v5 + 4) = 0i64;
        *(_DWORD *)v5 = 0;
      }
      ++v2;
      v5 += 40;
      if ( v2 >= a2 )
        goto LABEL_16;
    }
  }
  else
  {
LABEL_16:
    if ( a1 )
      SPExternalFree(a1);
  }
}

//----- (000000018000909C) ----------------------------------------------------
void __fastcall SPExternalFree(void *a1)
{
  if ( LsaTable )
    (*(void (__fastcall **)(void *))(LsaTable + 48))(a1);
  else
    LocalFree(a1);
}
// 180092620: using guessed type __int64 LsaTable;

//----- (00000001800090D0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::GenerateCcsAndFinishMessage(CSsl3TlsContext *this, struct SPBuffer *a2)
{
  __int64 v2; // rdi
  __int64 v5; // r14
  unsigned int v6; // edx
  __int64 v7; // r8
  int v8; // eax
  unsigned int v9; // edi
  char v10; // cl
  _BYTE *v11; // r13
  int v12; // r15d
  unsigned int v13; // ebp
  _BYTE *v14; // r14
  __int64 *v15; // rax
  __int64 v16; // rcx
  unsigned int v17; // edi
  size_t v18; // r12
  __int64 v19; // r9
  __int16 v20; // cx
  _BYTE *v21; // rdi
  bool v22; // zf
  char v23; // cl
  __int64 v24; // rdx
  unsigned int v25; // eax
  int v26; // r14d
  int v27; // eax
  unsigned int v28; // edi
  __int64 result; // rax
  __int16 v30; // cx
  __int64 v31; // rcx
  __int64 v32; // rcx
  __int64 v33; // rdi
  void *v34; // r12
  __int64 *v35; // rax
  __int64 v36; // rcx
  int v37; // edi
  __int64 v38; // rax
  void *v39; // rdi
  __int16 v40; // cx
  __int64 v41; // [rsp+58h] [rbp-60h]
  __int64 v42; // [rsp+60h] [rbp-58h]
  int v43; // [rsp+C8h] [rbp+10h]
  unsigned int v44; // [rsp+D0h] [rbp+18h]
  unsigned int v45; // [rsp+D8h] [rbp+20h]

  v2 = *((_QWORD *)a2 + 1) + *((unsigned int *)a2 + 1);
  v42 = *((_DWORD *)this + 34) & 0x8000;
  if ( *((_BYTE *)this + 233) )
  {
    v45 = *((_DWORD *)this + 15);
    v5 = 12i64;
    goto LABEL_3;
  }
  v45 = *((_DWORD *)this + 15);
  v5 = 4i64;
  if ( (*((_BYTE *)this + 32) & 4) == 0 )
  {
LABEL_3:
    v6 = 0;
    goto LABEL_4;
  }
  v6 = *((_DWORD *)this + 11);
LABEL_4:
  v7 = v45;
  v44 = v6;
  v43 = v5;
  *(_BYTE *)(v45 + (unsigned __int64)v6 + v2) = 1;
  if ( *((_BYTE *)this + 233) )
  {
    v30 = *((_WORD *)this + 17);
    *(_BYTE *)(v2 + 2) = v30;
    *(_BYTE *)(v2 + 1) = HIBYTE(v30);
    *(_BYTE *)v2 = 20;
    *(_WORD *)(v2 + 11) = 256;
    *((_DWORD *)a2 + 1) += v6 + v45 + 1;
  }
  else
  {
    v8 = CSsl3TlsContext::WrapMessage((__int64)this, (__int64)a2, 20, 1u);
    v9 = v8;
    if ( v8 )
    {
      CSslContext::SetErrorAndFatalAlert((__int64)this, 950, v8, 0x50u);
      return v9;
    }
    *((_WORD *)this + 16) |= 0xCu;
    v10 = *((_BYTE *)this + 233);
    if ( !v10 && *((_QWORD *)this + 19) )
    {
      SslFreeObject(*((_QWORD *)this + 19), 0i64);
      v10 = *((_BYTE *)this + 233);
    }
    *((_QWORD *)this + 19) = *((_QWORD *)this + 21);
    *((_QWORD *)this + 21) = 0i64;
    if ( !v10 )
      *((_QWORD *)this + 23) = 0i64;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 59i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    v7 = v45;
    if ( (*((_BYTE *)this + 32) & 4) != 0 )
      v6 = *((_DWORD *)this + 11);
    else
      v6 = 0;
    v44 = v6;
  }
  v11 = (_BYTE *)(*((_QWORD *)a2 + 1) + *((unsigned int *)a2 + 1));
  v12 = *((_DWORD *)this + 16) & 0xA2AA0;
  if ( (*((_DWORD *)this + 16) & 0xF3FC0) != 0 )
    v13 = 12;
  else
    v13 = 36;
  v41 = v6;
  v14 = &v11[v7 + v6 + v5];
  RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
  v15 = (__int64 *)*((_QWORD *)this + 1);
  if ( v15 )
    v16 = *v15;
  else
    v16 = 0i64;
  v17 = SslComputeFinishedHash(
          v16,
          *(_QWORD *)(*((_QWORD *)this + 11) + 16i64),
          *((_QWORD *)this + 74),
          v14,
          v13,
          2 - (unsigned int)(v12 != 0));
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
  if ( v17 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 901, v17, 0x50u);
    return v17;
  }
  if ( !*((_BYTE *)this + 340) )
  {
    memcpy_0((char *)this + 341, v14, v13);
    *((_BYTE *)this + 340) = 1;
    if ( *((_QWORD *)this + 103) )
    {
      v31 = *((_QWORD *)this + 11);
      if ( v31 )
      {
        RtlAcquireResourceShared((PRTL_RESOURCE)(v31 + 72), 1u);
        v32 = *((_QWORD *)this + 11);
        v33 = *(_QWORD *)(v32 + 16);
        if ( !v33 )
        {
LABEL_58:
          RtlReleaseResource((PRTL_RESOURCE)(v32 + 72));
          goto LABEL_24;
        }
        v34 = (void *)(*(__int64 (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 8i64))(this, 32i64);
        if ( !v34 )
        {
          v32 = *((_QWORD *)this + 11);
          goto LABEL_58;
        }
        v35 = (__int64 *)*((_QWORD *)this + 1);
        if ( v35 )
          v36 = *v35;
        else
          v36 = 0i64;
        v37 = SslExportKeyingMaterial(v36, v33, "EXPORTER-Token-Binding", (char *)this + 272, 64, 0i64, 0, v34, 32, 0);
        RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
        if ( v37 )
          goto LABEL_65;
        v38 = *((_QWORD *)this + 104);
        if ( v38 )
        {
          v39 = *(void **)(v38 + 8);
          if ( v39 )
          {
            memset(v39, 0, 0x20ui64);
            (*(void (__fastcall **)(CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 16i64))(
              this,
              *(_QWORD *)(*((_QWORD *)this + 104) + 8i64));
            v38 = *((_QWORD *)this + 104);
          }
        }
        else
        {
          v38 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 8i64))(this, 16i64);
          *((_QWORD *)this + 104) = v38;
          if ( !v38 )
          {
LABEL_65:
            memset(v34, 0, 0x20ui64);
            (*(void (__fastcall **)(CSsl3TlsContext *, void *))(*(_QWORD *)this + 16i64))(this, v34);
            goto LABEL_24;
          }
        }
        *(_DWORD *)v38 = 32;
        *(_QWORD *)(*((_QWORD *)this + 104) + 8i64) = v34;
      }
    }
  }
LABEL_24:
  if ( v12 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 65i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    v18 = v13;
    memcpy_0((char *)this + 377, v14, v13);
    *((_DWORD *)this + 104) = v13;
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 66i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    v18 = v13;
    memcpy_0((char *)this + 420, v14, v13);
    *((_DWORD *)this + 114) = v13;
  }
  v20 = *((_WORD *)this + 110);
  v21 = &v11[v41 + v45];
  v22 = *((_BYTE *)this + 233) == 0;
  *v21 = 20;
  if ( v22 )
  {
    v23 = v13;
    v24 = 4i64;
    v25 = HIWORD(v13);
  }
  else
  {
    v21[5] = v20;
    v24 = 12i64;
    v21[4] = HIBYTE(v20);
    v23 = v13;
    v25 = HIWORD(v13);
    v21[11] = v13;
    *(_WORD *)(v21 + 7) = 0;
    v21[6] = 0;
    *(_WORD *)(v21 + 9) = BYTE2(v13);
  }
  v21[1] = v25;
  v21[3] = v23;
  v21[2] = 0;
  if ( v14 )
    memcpy_0(&v21[v24], v14, v18);
  if ( *((_BYTE *)this + 233) )
    ++*((_WORD *)this + 110);
  if ( !v42 )
  {
    if ( !v12 )
      goto LABEL_37;
LABEL_41:
    v26 = v43;
    goto LABEL_38;
  }
  if ( !v12 )
    goto LABEL_41;
LABEL_37:
  v26 = v43;
  LOBYTE(v19) = 1;
  v27 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, _BYTE *, _QWORD, __int64))(*(_QWORD *)this + 504i64))(
          this,
          v21,
          v43 + v13,
          v19);
  v28 = v27;
  if ( v27 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 1000, v27, 0x50u);
    return v28;
  }
LABEL_38:
  if ( !*((_BYTE *)this + 233) )
    return CSsl3TlsContext::WrapMessage((__int64)this, (__int64)a2, 22, v26 + v13);
  *((_DWORD *)a2 + 1) += v44 + v45 + v26 + v13;
  v40 = *((_WORD *)this + 17);
  v11[2] = v40;
  v11[1] = HIBYTE(v40);
  v11[12] = v26 + v13;
  v11[11] = (unsigned __int16)(v26 + v13) >> 8;
  result = 0i64;
  *v11 = 22;
  return result;
}
// 1800093BF: variable 'v19' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180098538: using guessed type __int64 __fastcall SslComputeFinishedHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);
// 180098560: using guessed type __int64 __fastcall SslExportKeyingMaterial(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD, _QWORD, _DWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180009470) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::WrapMessage(__int64 a1, __int64 a2, int a3, unsigned int a4)
{
  _BYTE *v5; // rbx
  unsigned int v6; // r15d
  unsigned int v10; // ecx
  int v11; // r8d
  __int16 v12; // bp
  __int16 v13; // r10
  unsigned int v14; // r11d
  unsigned int v15; // ecx
  char v16; // al
  int v17; // r14d
  char v18; // cl
  __int64 result; // rax
  unsigned int v20; // r9d
  unsigned int v21; // ecx
  __int64 v22; // rdx
  __int64 *v23; // rax
  __int64 v24; // r10
  unsigned int v25; // eax
  unsigned int v26; // [rsp+50h] [rbp-48h]
  unsigned int v27; // [rsp+A0h] [rbp+8h] BYREF
  unsigned int v28; // [rsp+A8h] [rbp+10h]
  __int16 v29; // [rsp+B8h] [rbp+20h]

  v5 = (_BYTE *)(*(_QWORD *)(a2 + 8) + *(unsigned int *)(a2 + 4));
  v6 = 0;
  v10 = a4;
  v11 = *(_DWORD *)(a1 + 60);
  v12 = *(_WORD *)(a1 + 34);
  v13 = *(_WORD *)(a1 + 32) & 4;
  if ( v13 )
  {
    v20 = *(_DWORD *)(a1 + 52);
    v21 = a4 + *(_DWORD *)(a1 + 48);
    v14 = *(_DWORD *)(a1 + 44);
    v28 = v14;
    if ( v20 )
    {
      if ( (*(_BYTE *)(a1 + 56) & 1) != 0 )
        v20 -= v21 % v20;
      v21 += v20;
    }
    v10 = v14 + v21;
  }
  else
  {
    v14 = 0;
    v28 = 0;
  }
  v15 = v11 + v10;
  v16 = v12;
  v17 = v11;
  v29 = v12;
  v27 = v15;
  if ( v15 > *(_DWORD *)a2 )
    return 122i64;
  if ( !v13 || (v22 = *(_QWORD *)(a1 + 8)) == 0 || !*(_DWORD *)(v22 + 28) )
  {
    v18 = *(_BYTE *)(a1 + 233);
    if ( !v18 )
      ++*(_QWORD *)(a1 + 184);
    goto LABEL_7;
  }
  if ( *(_QWORD *)(a1 + 152) )
  {
LABEL_19:
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_Di(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xCu,
        (__int64)&WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids,
        a4,
        *(_QWORD *)(a1 + 184));
      v15 = v27;
      v14 = v28;
    }
    v23 = *(__int64 **)(a1 + 8);
    if ( v23 )
      v24 = *v23;
    else
      v24 = 0i64;
    v25 = SslEncryptPacket(v24, *(_QWORD *)(a1 + 152), &v5[v17 + v14], a4, v5, v15, &v27, *(_QWORD *)(a1 + 184), a3, 0);
    v6 = v25;
    if ( v25 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids, v25);
      v18 = *(_BYTE *)(a1 + 233);
      v6 = -2146893015;
    }
    else
    {
      v18 = *(_BYTE *)(a1 + 233);
      if ( !v18 )
        ++*(_QWORD *)(a1 + 184);
    }
    v16 = v29;
LABEL_7:
    *v5 = a3;
    v5[1] = HIBYTE(v12);
    v5[2] = v16;
    if ( v18 )
    {
      v5[3] = *(_BYTE *)(a1 + 191);
      v5[4] = *(_BYTE *)(a1 + 190);
      v5[5] = *(_BYTE *)(a1 + 189);
      v5[6] = *(_BYTE *)(a1 + 188);
      v5[7] = *(_BYTE *)(a1 + 187);
      v5[8] = *(_BYTE *)(a1 + 186);
      v5[9] = *(_BYTE *)(a1 + 185);
      v5[10] = *(_BYTE *)(a1 + 184);
      v5[11] = (unsigned __int16)(v27 - v17) >> 8;
      v5[12] = v27 - v17;
      *(_QWORD *)(a1 + 184) ^= (*(_QWORD *)(a1 + 184) ^ (*(_QWORD *)(a1 + 184) + 1i64)) & 0xFFFFFFFFFFFFi64;
    }
    else
    {
      v5[3] = (unsigned __int16)(v27 - v17) >> 8;
      v5[4] = v27 - v17;
    }
    *(_DWORD *)(a2 + 4) += v27;
    return v6;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids);
  result = RemotelyGetUserKeys((struct CSslContext *)a1, 2u);
  v26 = result;
  if ( !(_DWORD)result )
  {
    v15 = v27;
    v14 = v28;
    goto LABEL_19;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    WPP_SF_D(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      11i64,
      &WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids,
      (unsigned int)result);
    return v26;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098508: using guessed type __int64 __fastcall SslEncryptPacket(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180009670) ----------------------------------------------------
__int64 __fastcall CTlsExtClient::GetClientHelloExtensionsLength(CTlsExtClient *this, unsigned int *a2)
{
  __int64 v4; // rcx
  unsigned int v5; // edi
  __int64 v6; // rsi
  int v7; // edx
  int v8; // r8d
  int v9; // edx
  const unsigned __int16 *v10; // rax
  __int64 result; // rax
  __int64 v12; // rcx
  __int64 v13; // rax
  int v14; // ecx
  unsigned __int16 *v15; // r8
  unsigned __int16 *v16; // rax
  __int64 v17; // rcx
  __int64 v18; // rcx
  unsigned int v19; // edx
  __int64 v20; // rax
  __int64 v21; // r8
  unsigned int v22; // ecx
  __int64 v23; // rax
  __int64 v24; // rax
  unsigned __int16 *v25; // rax
  int v26; // ecx
  int v27; // r9d
  unsigned __int8 *v28; // rax
  __int64 v29; // [rsp+30h] [rbp+8h] BYREF

  v4 = *((_QWORD *)this + 7);
  v5 = 0;
  v6 = *(_QWORD *)(v4 + 80);
  v7 = *((_DWORD *)this + 5) + 5;
  v29 = 0i64;
  *((_BYTE *)this + 26) = 1;
  v8 = *(_DWORD *)(v4 + 416);
  v9 = v8 + v7;
  *((_DWORD *)this + 5) = v9;
  if ( (*(_DWORD *)(v4 + 64) & 0x2A88) == 0 && (*(_BYTE *)(v4 + 64) & 0x20) != 0 )
  {
    if ( *(_BYTE *)(*((_QWORD *)this + 1) + 553i64) && v8 )
      v5 = v9 + 2;
    else
      *((_BYTE *)this + 26) = 0;
    *((_DWORD *)this + 5) = v5;
    *a2 = v5;
    return 0i64;
  }
  if ( (*(_DWORD *)(v4 + 64) & 0xA2A80) != 0 )
  {
    if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 320i64))(v4) )
    {
      v10 = (const unsigned __int16 *)(*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 7) + 320i64))(*((_QWORD *)this + 7));
      result = CTlsExtClient::BuildServerNameString(this, v10);
      if ( (_DWORD)result )
        return result;
      v12 = *((_QWORD *)this + 5);
      if ( v12 )
      {
        v13 = -1i64;
        do
          ++v13;
        while ( *(_BYTE *)(v12 + v13) );
        *((_DWORD *)this + 12) = v13;
        *((_DWORD *)this + 5) += v13 + 9;
      }
    }
    v14 = *((_DWORD *)this + 5);
    if ( (*(_DWORD *)(v6 + 160) & 0x700) != 0 )
    {
      v14 += 9;
      *((_BYTE *)this + 24) = 1;
      *((_DWORD *)this + 5) = v14;
    }
    v15 = (unsigned __int16 *)*((_QWORD *)this + 7);
    if ( v15[460] )
    {
      *((_BYTE *)this + 32) = 1;
      *((_DWORD *)this + 5) = v14 + 2 * (v15[460] + 6);
    }
    v16 = (unsigned __int16 *)(*(__int64 (__fastcall **)(unsigned __int16 *))(*(_QWORD *)v15 + 320i64))(v15);
    if ( (unsigned int)CheckUserMappingTarget(v16) && (*(_QWORD *)(v6 + 872) || *(_QWORD *)(v6 + 880)) )
    {
      *((_DWORD *)this + 5) += 6;
      *((_BYTE *)this + 25) = 1;
    }
    v17 = *((_QWORD *)this + 7);
    if ( *(_BYTE *)(v17 + 925) )
      *((_DWORD *)this + 5) += 2 * *(unsigned __int16 *)(v17 + 474) + 6;
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v17 + 224i64))(v17, &v29);
    if ( v29 )
      *((_DWORD *)this + 5) += *(_DWORD *)(v29 + 432) + 4;
    v18 = *((_QWORD *)this + 1);
    v19 = *((_DWORD *)this + 5);
    v20 = *(_QWORD *)(v18 + 784);
    if ( v20 )
    {
      v19 += *(unsigned __int16 *)(v20 + 4) + 6;
      *((_DWORD *)this + 5) = v19;
    }
    if ( CSslGlobals::m_fDisableClientExtendedMS )
    {
      v24 = *(_QWORD *)(v18 + 120);
      if ( !v24 || !CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
        goto LABEL_23;
      *(_WORD *)(v24 + 66) |= 8u;
    }
    else
    {
      *(_BYTE *)(*((_QWORD *)this + 7) + 1344i64) = 1;
      *((_DWORD *)this + 5) += 4;
    }
    v19 = *((_DWORD *)this + 5);
LABEL_23:
    v21 = *((_QWORD *)this + 7);
    v22 = v19;
    if ( *(_BYTE *)(v21 + 233) )
    {
      v25 = *(unsigned __int16 **)(v21 + 800);
      if ( v25 )
      {
        v26 = *v25;
        v27 = 7;
        v28 = *(unsigned __int8 **)(v21 + 1336);
        if ( v28 )
          v27 = *v28 + 7;
        v22 = v27 + v19 + v26;
        *((_DWORD *)this + 5) = v22;
      }
    }
    v23 = *(_QWORD *)(v21 + 816);
    if ( v23 )
    {
      v22 += *(unsigned __int8 *)(v23 + 2) + 7;
      *((_DWORD *)this + 5) = v22;
    }
    if ( v22 )
    {
      v22 += 2;
      *((_DWORD *)this + 5) = v22;
    }
    *a2 = v22;
  }
  return 0i64;
}
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 1800927B8: using guessed type int CSslGlobals::m_fDisableClientExtendedMS;

//----- (000000018000988C) ----------------------------------------------------
__int64 __fastcall CheckUserMappingTarget(unsigned __int16 *a1)
{
  const wchar_t *v1; // rbx
  int v4; // edx
  CCipherMill *v5; // rcx
  __int64 v6; // rdx
  __int64 v7; // rax
  unsigned __int16 *v8; // rbp
  unsigned __int16 *v9; // rdi
  wchar_t *v10; // rdx
  __int64 v11; // rax
  const wchar_t *i; // rcx
  wchar_t v13; // ax

  v1 = (const wchar_t *)g_pszDomainList;
  if ( !a1 || !g_pszDomainList )
    return 0i64;
  v4 = *(unsigned __int16 *)g_pszDomainList - 42;
  if ( *(_WORD *)g_pszDomainList == 42 )
    v4 = *((unsigned __int16 *)g_pszDomainList + 1);
  if ( !v4 )
  {
    v5 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 1i64;
    v6 = 18i64;
    goto LABEL_33;
  }
  v7 = -1i64;
  do
    ++v7;
  while ( a1[v7] );
  v8 = &a1[v7];
  if ( !*(_WORD *)g_pszDomainList )
    return 0i64;
  while ( 1 )
  {
    v9 = v8 - 1;
    v10 = wcschr(v1, 0x2Cu);
    if ( !v10 )
    {
      v11 = -1i64;
      do
        ++v11;
      while ( v1[v11] );
      v10 = (wchar_t *)&v1[v11];
    }
    for ( i = v10 - 1; i >= v1 && v9 >= a1 && *i == *v9; --i )
      --v9;
    if ( i == v1 - 1 && (v9 == a1 - 1 || *v9 == 46) )
      break;
    v13 = *v10;
    if ( *v10 == 44 )
    {
      v1 = v10 + 1;
      v13 = v10[1];
    }
    else
    {
      v1 = v10;
    }
    if ( !v13 )
      return 0i64;
  }
  v5 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    v6 = 19i64;
LABEL_33:
    WPP_SF_(*((_QWORD *)v5 + 2), v6, &WPP_652d1bd98c7033c24f7b4105215d66be_Traceguids);
  }
  return 1i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (00000001800098E4) ----------------------------------------------------
__int64 __fastcall CTlsExtClient::BuildServerNameString(CTlsExtClient *this, const unsigned __int16 *a2)
{
  DWORD LastError; // esi
  __int64 v4; // r12
  __int64 v5; // rax
  size_t v6; // r15
  unsigned __int64 v7; // rdi
  CTlsExtClient **v8; // rbx
  unsigned __int64 v9; // rcx
  __int64 v10; // rcx
  signed __int64 v11; // rcx
  void *v12; // rsp
  void *v13; // rsp
  _BYTE *v14; // r13
  const WCHAR *v15; // rdi
  __int16 v16; // cx
  CTlsExtClient **v17; // rdx
  const WCHAR *v18; // rax
  HLOCAL v19; // rax
  _DWORD *v21; // rax
  __int64 v22; // [rsp+0h] [rbp-40h] BYREF
  CTlsExtClient *v23; // [rsp+40h] [rbp+0h] BYREF
  __int64 v24[5]; // [rsp+48h] [rbp+8h] BYREF

  v23 = this;
  LastError = 0;
  if ( a2 && *a2 )
  {
    if ( IsIpAddress(a2) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_S(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x10u,
          (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
          a2);
    }
    else
    {
      v4 = -1i64;
      v5 = -1i64;
      do
        ++v5;
      while ( a2[v5] );
      v6 = 2 * v5 + 2;
      if ( v6 <= 0x4000 )
      {
        v7 = 3 * v6;
        v8 = 0i64;
        if ( 3 * v6 )
        {
          if ( v7 <= g_ulMaxStackAllocSize )
          {
            v9 = v7 + g_ulAdditionalProbeSize + 8;
            if ( v9 >= v7 )
            {
              if ( (unsigned int)VerifyStackAvailable(v9) )
              {
                v10 = v7 + 23;
                if ( v7 + 23 <= v7 + 8 )
                  v10 = 0xFFFFFFFFFFFFFF0i64;
                v11 = v10 & 0xFFFFFFFFFFFFFFF0ui64;
                v12 = alloca(v11);
                v13 = alloca(v11);
                v8 = &v23;
                if ( &v22 != (__int64 *)-64i64 )
                {
                  LODWORD(v23) = 1801679955;
                  v8 = (CTlsExtClient **)v24;
                  if ( v24 )
                    goto LABEL_15;
                }
              }
            }
          }
        }
        if ( v7 + 8 >= v7 )
        {
          v21 = (_DWORD *)((__int64 (*)(void))g_pfnAllocate)();
          if ( !v21 )
            return 14;
          *v21 = 1885431112;
          v8 = (CTlsExtClient **)(v21 + 2);
        }
        if ( v8 )
        {
LABEL_15:
          v14 = (char *)v8 + v6;
          v15 = (const WCHAR *)v8;
          memcpy_0(v8, a2, v6);
          v16 = *(_WORD *)v8;
          v17 = v8;
          while ( v16 )
          {
            v17 = (CTlsExtClient **)((char *)v17 + 2);
            v18 = (const WCHAR *)v17;
            if ( v16 != 47 )
              v18 = v15;
            v16 = *(_WORD *)v17;
            v15 = v18;
          }
          if ( WideCharToMultiByte(0xFDE9u, 0, v15, -1, (LPSTR)v8 + v6, 2 * v6, 0i64, 0i64) )
          {
            if ( *v14 )
            {
              do
                ++v4;
              while ( v14[v4] );
              v19 = SPExternalAlloc((int)v4 + 1);
              *((_QWORD *)v23 + 5) = v19;
              if ( v19 )
                memcpy_0(v19, (char *)v8 + v6, (unsigned int)(v4 + 1));
              else
                LastError = 14;
            }
          }
          else
          {
            LastError = GetLastError();
          }
          if ( v8 )
          {
            if ( *((_DWORD *)v8 - 2) == 1885431112 )
              ((void (*)(void))g_pfnFree)();
          }
          return LastError;
        }
        return 14;
      }
    }
  }
  return 0i64;
}
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;

//----- (0000000180009AE4) ----------------------------------------------------
__int64 __fastcall CopyTlsParameters(
        struct _TLS_PARAMETERS *a1,
        unsigned int a2,
        int a3,
        char a4,
        struct _TLS_PARAMETERS **a5,
        unsigned int *a6)
{
  struct _TLS_PARAMETERS **v6; // r14
  char v7; // bl
  unsigned int *v8; // rdi
  unsigned int v10; // r15d
  struct _TLS_PARAMETERS *v11; // rsi
  struct _TLS_PARAMETERS *v12; // rax
  __int64 v13; // rdx
  char *v14; // rdi
  signed __int64 v15; // rcx
  unsigned __int64 v16; // r9
  __int64 v17; // rdx
  unsigned int v18; // ebx
  int v19; // eax
  unsigned int v20; // r13d
  int v21; // eax
  HLOCAL v22; // rax
  __int64 v23; // rcx
  __int64 v24; // rsi
  char v25; // r9
  __int64 v26; // r14
  __int64 v27; // r9
  __int64 v28; // rdx
  unsigned int v29; // eax
  unsigned int v30; // ecx
  __int64 v31; // rbx
  unsigned int v32; // edx
  unsigned int v33; // r14d
  __int128 v35; // xmm1
  __int64 v36; // rax
  HLOCAL v37; // rax
  int v38; // eax
  unsigned int v39; // esi
  int v40; // r14d
  __int64 v41; // rcx
  unsigned int v42; // eax
  HLOCAL v43; // rax
  unsigned int v44; // eax
  int v45; // edx
  __int64 v46; // rcx
  struct _UNICODE_STRING *v47; // r8
  unsigned int v48; // eax
  int v50; // [rsp+34h] [rbp-A5h]
  unsigned int v51; // [rsp+38h] [rbp-A1h]
  int v52; // [rsp+3Ch] [rbp-9Dh]
  int v53; // [rsp+40h] [rbp-99h]
  __int64 v54; // [rsp+48h] [rbp-91h]
  signed __int64 v55; // [rsp+50h] [rbp-89h]
  struct _TLS_PARAMETERS *v56; // [rsp+58h] [rbp-81h]
  __int128 v58; // [rsp+78h] [rbp-61h] BYREF
  __int128 v59; // [rsp+88h] [rbp-51h]
  __int64 v60; // [rsp+98h] [rbp-41h]
  __int128 v61; // [rsp+A0h] [rbp-39h] BYREF
  __int128 v62; // [rsp+B0h] [rbp-29h]
  __int128 v63; // [rsp+C0h] [rbp-19h]

  v6 = a5;
  v7 = a4;
  v8 = a6;
  v10 = a2;
  v11 = a1;
  if ( !a2 )
    return 0i64;
  if ( a5 && a6 && (a1 || a3) && a2 <= 0x10 )
  {
    v12 = (struct _TLS_PARAMETERS *)SPExternalAlloc(40 * a2);
    v56 = v12;
    if ( v12 )
    {
      v13 = 0i64;
      v53 = 0;
      if ( !v10 )
      {
LABEL_45:
        v18 = 0;
        goto LABEL_46;
      }
      v14 = (char *)v12 + 24;
      v15 = v11 - v12;
      v55 = v11 - v12;
      while ( 1 )
      {
        v60 = 0i64;
        v58 = 0i64;
        v59 = 0i64;
        if ( v7 )
        {
          if ( a3 )
          {
            v16 = (unsigned int)(a3 + 24 * v13);
            v17 = 24i64;
          }
          else
          {
            v16 = (unsigned __int64)v11 + 40 * v13;
            v17 = 40i64;
          }
          v18 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int128 *, unsigned __int64))(LsaTable + 80))(
                  0i64,
                  v17,
                  &v58,
                  v16);
          if ( v18 )
            goto LABEL_71;
          v7 = a4;
        }
        else
        {
          v35 = *(_OWORD *)&v14[v15 - 8];
          v58 = *(_OWORD *)&v14[v15 - 24];
          v60 = *(_QWORD *)&v14[v15 + 8];
          v59 = v35;
        }
        if ( (_DWORD)v58 )
        {
          if ( (unsigned int)v58 > 0x10 )
            goto LABEL_70;
          v37 = SPExternalAlloc(16 * (int)v58);
          *((_QWORD *)v14 - 2) = v37;
          if ( !v37 )
            goto LABEL_82;
          v38 = v58;
          v39 = 0;
          *((_DWORD *)v14 - 6) = v58;
          if ( v38 )
          {
            v40 = 0;
            do
            {
              v41 = 16i64 * v39;
              v42 = a3
                  ? Wow64CopyUnicodeString(v40 + DWORD1(v58), (struct _UNICODE_STRING *)(v41 + *((_QWORD *)v14 - 2)))
                  : CopyUnicodeString(
                      v7,
                      (struct _UNICODE_STRING *)(v41 + *((_QWORD *)&v58 + 1)),
                      (struct _UNICODE_STRING *)(v41 + *((_QWORD *)v14 - 2)));
              v18 = v42;
              if ( v42 )
                goto LABEL_71;
              v7 = a4;
              ++v39;
              v40 += 8;
            }
            while ( v39 < (unsigned int)v58 );
          }
        }
        v19 = DWORD2(v58);
        v20 = HIDWORD(v58);
        if ( !a3 )
          v19 = v59;
        *((_DWORD *)v14 - 2) = v19;
        v21 = DWORD1(v59);
        if ( !a3 )
          v20 = DWORD1(v59);
        if ( v20 )
          break;
LABEL_41:
        if ( !a3 )
          v21 = v60;
        v13 = (unsigned int)(v53 + 1);
        *((_DWORD *)v14 + 2) = v21;
        v14 += 40;
        v53 = v13;
        if ( (unsigned int)v13 >= v10 )
        {
          v12 = v56;
          v8 = a6;
          v6 = a5;
          goto LABEL_45;
        }
        v15 = v55;
        v7 = a4;
        v11 = a1;
      }
      if ( v20 > 0x10 )
      {
LABEL_70:
        v18 = -2146892963;
        goto LABEL_71;
      }
      v22 = SPExternalAlloc(48 * v20);
      *(_QWORD *)v14 = v22;
      if ( v22 )
      {
        v23 = 0i64;
        *((_DWORD *)v14 - 1) = v20;
        v50 = 0;
        v24 = 0i64;
        while ( 1 )
        {
          v25 = a4;
          v26 = *(_QWORD *)v14;
          v54 = *(_QWORD *)v14;
          v61 = 0i64;
          v62 = 0i64;
          v63 = 0i64;
          if ( a4 )
          {
            if ( a3 )
            {
              v27 = (unsigned int)(v59 + 28 * v23);
              v28 = 28i64;
            }
            else
            {
              v27 = *((_QWORD *)&v59 + 1) + 48 * v23;
              v28 = 48i64;
            }
            v18 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int128 *, __int64))(LsaTable + 80))(
                    0i64,
                    v28,
                    &v61,
                    v27);
            if ( v18 )
              goto LABEL_71;
            LODWORD(v23) = v50;
            v25 = a4;
          }
          else
          {
            v36 = *(_QWORD *)&v14[v55];
            v61 = *(_OWORD *)(v36 + v24);
            v62 = *(_OWORD *)(v36 + v24 + 16);
            v63 = *(_OWORD *)(v36 + v24 + 32);
          }
          if ( a3 )
            v29 = Wow64CopyUnicodeString((int)v59 + 4 + 28 * (int)v23, (struct _UNICODE_STRING *)(v24 + v26 + 8));
          else
            v29 = CopyUnicodeString(
                    v25,
                    (struct _UNICODE_STRING *)(48i64 * (unsigned int)v23 + *((_QWORD *)&v59 + 1) + 8i64),
                    (struct _UNICODE_STRING *)(v24 + v26 + 8));
          v18 = v29;
          if ( v29 )
            goto LABEL_71;
          v30 = DWORD2(v62);
          v31 = v26;
          if ( !a3 )
            v30 = HIDWORD(v63);
          *(_DWORD *)(v24 + v26 + 44) = v30;
          v32 = DWORD1(v62);
          if ( !a3 )
            v32 = DWORD2(v63);
          *(_DWORD *)(v24 + v26 + 40) = v32;
          *(_DWORD *)(v24 + v26) = v61;
          if ( v30 )
          {
            if ( v32 > v30 )
              goto LABEL_70;
          }
          v33 = HIDWORD(v61);
          if ( !a3 )
            v33 = DWORD2(v62);
          if ( v33 )
          {
            if ( v33 > 0x10 )
              goto LABEL_70;
            v43 = SPExternalAlloc(16 * v33);
            *(_QWORD *)(v24 + v31 + 32) = v43;
            if ( v43 )
            {
              v44 = 0;
              *(_DWORD *)(v24 + v31 + 24) = v33;
              v45 = 0;
              v51 = 0;
              v52 = 0;
              while ( 1 )
              {
                v46 = 16i64 * v44;
                v47 = (struct _UNICODE_STRING *)(v46 + *(_QWORD *)(v24 + v31 + 32));
                v48 = a3
                    ? Wow64CopyUnicodeString(v45 + (int)v62, v47)
                    : CopyUnicodeString(a4, (struct _UNICODE_STRING *)(v46 + v63), v47);
                v18 = v48;
                if ( v48 )
                  goto LABEL_71;
                v44 = v51 + 1;
                v31 = v54;
                v45 = v52 + 8;
                v51 = v44;
                v52 += 8;
                if ( v44 >= v33 )
                  goto LABEL_39;
              }
            }
            break;
          }
LABEL_39:
          v24 += 48i64;
          v23 = (unsigned int)(v50 + 1);
          v50 = v23;
          if ( (unsigned int)v23 >= v20 )
          {
            v21 = DWORD1(v59);
            goto LABEL_41;
          }
        }
      }
LABEL_82:
      v18 = -2146893056;
LABEL_71:
      FreeTlsParameters(v56, v10);
      v8 = a6;
      v6 = a5;
    }
    else
    {
      v18 = -2146893056;
    }
  }
  else
  {
    v18 = -2146892963;
  }
  v10 = 0;
  v12 = 0i64;
LABEL_46:
  *v6 = v12;
  *v8 = v10;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v18 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x44u,
      (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
      v18,
      v18);
  }
  return v18;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180009E8C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::AllocateOutputBuffer(CSsl3TlsContext *this, struct SPBuffer *a2, unsigned int a3)
{
  HLOCAL Memory; // rax

  if ( *((_QWORD *)a2 + 1) )
  {
    if ( *(_DWORD *)a2 >= a3 )
      goto LABEL_3;
    *((_DWORD *)a2 + 1) = a3;
    return 2148074273i64;
  }
  else
  {
    *(_DWORD *)a2 = a3;
    Memory = CSslContext::GetMemory(this, a3);
    *((_QWORD *)a2 + 1) = Memory;
    if ( Memory )
    {
LABEL_3:
      *((_DWORD *)a2 + 1) = 0;
      return 0i64;
    }
    return 14i64;
  }
}

//----- (0000000180009ED4) ----------------------------------------------------
__int64 __fastcall GetEphemBlobFromKey(
        __int64 a1,
        __int64 a2,
        const unsigned __int16 *a3,
        unsigned int *a4,
        unsigned __int8 **a5)
{
  unsigned int v9; // ebx
  unsigned __int8 *v10; // rax
  unsigned int v11; // edi

  v9 = SslExportKey(a1, a2, a3);
  if ( v9 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_8452d3335a5c3be980705cc51c40b5db_Traceguids, v9);
    return v9;
  }
  else
  {
    v10 = (unsigned __int8 *)SPExternalAlloc(*a4);
    *a5 = v10;
    if ( v10 )
    {
      v11 = SslExportKey(a1, a2, a3);
      if ( v11 )
      {
        SPExternalFree(*a5);
        *a5 = 0i64;
      }
      return v11;
    }
    else
    {
      return 14i64;
    }
  }
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098528: using guessed type __int64 __fastcall SslExportKey(_QWORD, _QWORD, _QWORD);

//----- (0000000180009F90) ----------------------------------------------------
__int64 __fastcall CSslContextManager::InstantiateClientContext(
        CSslContextManager *this,
        const unsigned __int16 *a2,
        struct CCredentialGroup *a3,
        struct CSslParentContext **a4,
        __int64 a5)
{
  CSessionCacheManager *v5; // rbx
  unsigned __int16 *v8; // rdi
  unsigned int v9; // eax
  __int64 v10; // r8
  struct CSessionCacheItem *v11; // rsi
  char v12; // r15
  CCipherMill *v13; // rcx
  unsigned int v14; // ebx
  __int64 v15; // rcx
  int v16; // ebx
  unsigned __int64 v17; // r12
  __int64 v18; // rbp
  unsigned int v19; // ebp
  wchar_t *v20; // rax
  CSsl3TlsClientContext *v21; // rax
  CTls13ClientContext *v22; // rax
  CTls13ClientContext *v23; // rdi
  unsigned int v24; // esi
  _QWORD *v25; // rax
  int v26; // ecx
  struct CSslParentContext **v27; // rax
  struct CSslParentContext *v28; // r8
  const char *v30; // rax
  unsigned __int8 *v31; // rax
  CTls13ClientContext *v32; // rbp
  struct CTlsRecord *Record; // rax
  void *v34; // rcx
  struct CSessionCacheItem *v35; // [rsp+60h] [rbp+8h] BYREF
  struct CSslParentContext **v36; // [rsp+78h] [rbp+20h]

  v36 = a4;
  v35 = this;
  v5 = CSessionCacheManager::m_pSessionCacheManager;
  v8 = 0i64;
  v9 = CSessionCacheManager::ComputeClientCacheIndex(CSessionCacheManager::m_pSessionCacheManager, a2);
  if ( CSessionCacheTable::LookupCacheByName(
         (CSessionCacheTable *)(*((_QWORD *)v5 + 5) + 152i64 * (v9 / *((_DWORD *)v5 + 13))),
         v9 % *((_DWORD *)v5 + 13),
         a2,
         a3,
         &v35) )
  {
    v11 = v35;
    v12 = 1;
  }
  else
  {
    v11 = 0i64;
    v35 = 0i64;
    v12 = 0;
  }
  v13 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    v30 = "FOUND";
    if ( !v12 )
      v30 = "NO ENTRY";
    WPP_SF_Ss(*((_QWORD *)WPP_GLOBAL_Control + 2), (__int64)"NO ENTRY", v10, a2, v30);
  }
  if ( !v12 )
  {
    CSessionCacheManager::AcquireCacheTableLock((__int64)v13, a2, 0i64);
    v14 = CSessionCacheManager::CacheRetrieveNewClientItem(CSessionCacheManager::m_pSessionCacheManager, a2, &v35);
    CSessionCacheManager::ReleaseCacheTableLock(v15, a2, 0i64);
    if ( v14 )
      return v14;
    v11 = v35;
  }
  v16 = *((_DWORD *)a3 + 38) & 0x800A2AAA;
  v17 = a5 & 0x100000000i64;
  if ( (a5 & 0x100000000i64) != 0 && (*((_DWORD *)a3 + 38) & 0x800A0AAA) != 0 )
    return 2148074333i64;
  if ( (*((_DWORD *)a3 + 38) & 0xA2AA0) == 0 )
    return 2148074289i64;
  if ( a2 )
  {
    v18 = -1i64;
    do
      ++v18;
    while ( a2[v18] );
    v19 = v18 + 1;
    v20 = (wchar_t *)SPExternalAlloc(2 * v19);
    v8 = v20;
    if ( !v20 )
      return 14i64;
    wcscpy_s(v20, v19, a2);
  }
  if ( (v16 & 0x2AA0) != 0 && (v16 & 0xA0000) != 0 )
  {
    if ( (a5 & 0x400) != 0 )
      v16 &= 0xF0000u;
    else
      v16 &= 0xFFF0FFFF;
  }
  if ( v12 && (*((_DWORD *)v11 + 42) & 0x2000) == 0 )
    v16 &= 0xFFFFCFFF;
  if ( (v16 & 0x2000) != 0 )
  {
    v31 = (unsigned __int8 *)SPExternalAlloc(v17 != 0 ? 1936 : 1952);
    v32 = (CTls13ClientContext *)v31;
    if ( v31 )
    {
      Record = CTlsRecord::MakeRecord(a5, v31 + 1856, (struct CSsl3TlsContext *)v31);
      if ( Record )
      {
        v22 = CTls13ClientContext::CTls13ClientContext(v32, Record, v11, v16, v8);
        goto LABEL_20;
      }
      if ( v8 )
        SPExternalFree(v8);
      v34 = v32;
      goto LABEL_40;
    }
LABEL_43:
    if ( !v8 )
      return 14i64;
    v34 = v8;
LABEL_40:
    SPExternalFree(v34);
    return 14i64;
  }
  v21 = (CSsl3TlsClientContext *)SPExternalAlloc(0x558u);
  if ( !v21 )
    goto LABEL_43;
  v22 = CSsl3TlsClientContext::CSsl3TlsClientContext(v21, v11, v16, v8);
LABEL_20:
  v23 = v22;
  v24 = (*(__int64 (__fastcall **)(CTls13ClientContext *))(*(_QWORD *)v22 + 184i64))(v22);
  if ( !v24 )
  {
    v25 = SPExternalAlloc(0x28u);
    if ( v25 )
    {
      v25[1] = v23;
      *((_QWORD *)v23 + 16) = v25;
      v26 = (unsigned __int16)ConvertSchannelProtocolToSsl(v16);
      v27 = v36;
      *((_DWORD *)v23 + 9) = v26;
      *v27 = v28;
      return 0i64;
    }
    (**(void (__fastcall ***)(void *, _QWORD))v23)(v23, 0i64);
    v24 = 14;
  }
  SPExternalFree(v23);
  return v24;
}
// 18000A02C: variable 'v13' is possibly undefined
// 18000A04D: variable 'v15' is possibly undefined
// 18000A17D: variable 'v28' is possibly undefined
// 180034E7F: variable 'v10' is possibly undefined

//----- (000000018000A1D0) ----------------------------------------------------
HLOCAL __fastcall CSslContext::GetMemory(CSslContext *this, unsigned int a2)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(*((_QWORD *)this + 16) + 24i64);
  if ( v2 )
    return (HLOCAL)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 48i64))(v2);
  else
    return SPExternalAlloc(a2);
}

//----- (000000018000A1F4) ----------------------------------------------------
HLOCAL __fastcall SPExternalAlloc(unsigned int a1)
{
  if ( LsaTable )
    return (HLOCAL)(*(__int64 (**)(void))(LsaTable + 40))();
  else
    return LocalAlloc(0x40u, a1);
}
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018000A230) ----------------------------------------------------
NTSTATUS __fastcall GenerateHash(
        BCRYPT_ALG_HANDLE hAlgorithm,
        UCHAR *a2,
        unsigned __int8 *a3,
        ULONG a4,
        unsigned __int8 *a5,
        ULONG cbOutput)
{
  NTSTATUS result; // eax
  __int64 v11; // rdx
  ULONG v12; // r9d
  UCHAR *p_phHash; // rbx
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rax
  void *v16; // rsp
  NTSTATUS v17; // edi
  _DWORD *v18; // rax
  __int64 v19; // [rsp+0h] [rbp-40h] BYREF
  UCHAR pbOutput[4]; // [rsp+40h] [rbp+0h] BYREF
  BCRYPT_HASH_HANDLE phHash; // [rsp+48h] [rbp+8h] BYREF
  ULONG pcbResult; // [rsp+50h] [rbp+10h] BYREF

  phHash = 0i64;
  result = BCryptGetProperty(hAlgorithm, L"ObjectLength", pbOutput, 4u, &pcbResult, 0);
  if ( result )
    return result;
  v12 = *(_DWORD *)pbOutput;
  p_phHash = 0i64;
  if ( *(_DWORD *)pbOutput )
  {
    v11 = *(unsigned int *)pbOutput;
    if ( *(unsigned int *)pbOutput <= (unsigned __int64)g_ulMaxStackAllocSize )
    {
      v14 = *(unsigned int *)pbOutput + g_ulAdditionalProbeSize + 8;
      if ( v14 >= *(unsigned int *)pbOutput )
      {
        if ( !(unsigned int)VerifyStackAvailable(v14) )
        {
LABEL_22:
          v12 = *(_DWORD *)pbOutput;
          goto LABEL_23;
        }
        v12 = *(_DWORD *)pbOutput;
        v15 = (unsigned int)(*(_DWORD *)pbOutput + 8) + 15i64;
        if ( v15 <= (unsigned int)(*(_DWORD *)pbOutput + 8) )
          v15 = 0xFFFFFFFFFFFFFF0i64;
        v16 = alloca(v15 & 0xFFFFFFFFFFFFFFF0ui64);
        p_phHash = pbOutput;
        if ( &v19 != (__int64 *)-64i64 )
        {
          *(_DWORD *)pbOutput = 1801679955;
          p_phHash = (UCHAR *)&phHash;
          if ( &phHash )
          {
            v12 = *(_DWORD *)pbOutput;
            goto LABEL_11;
          }
          goto LABEL_22;
        }
      }
    }
  }
LABEL_23:
  if ( v12 + 8 >= v12 )
  {
    v18 = (_DWORD *)((__int64 (__fastcall *)(_QWORD, __int64))g_pfnAllocate)(v12 + 8, v11);
    if ( !v18 )
      return 14;
    *v18 = 1885431112;
    p_phHash = (UCHAR *)(v18 + 2);
    v12 = *(_DWORD *)pbOutput;
  }
  if ( !p_phHash )
    return 14;
LABEL_11:
  v17 = BCryptCreateHash(hAlgorithm, &phHash, p_phHash, v12, 0i64, 0, 0);
  if ( !v17 )
  {
    v17 = BCryptHashData(phHash, a2 + 272, 0x40u, 0);
    if ( !v17 )
    {
      v17 = BCryptHashData(phHash, a3, a4, 0);
      if ( !v17 )
        v17 = BCryptFinishHash(phHash, a5, cbOutput, 0);
    }
  }
  if ( phHash )
    BCryptDestroyHash(phHash);
  if ( p_phHash )
  {
    if ( *((_DWORD *)p_phHash - 2) == 1885431112 )
      ((void (__fastcall *)(UCHAR *))g_pfnFree)(p_phHash - 8);
  }
  return v17;
}
// 180034FB4: variable 'v11' is possibly undefined
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;

//----- (000000018000A418) ----------------------------------------------------
__int64 __fastcall VerifyStackAvailable(unsigned __int64 a1)
{
  InternalVerifyStackAvailable(a1);
  return 1i64;
}

//----- (000000018000A444) ----------------------------------------------------
signed __int64 __fastcall InternalVerifyStackAvailable(unsigned __int64 a1)
{
  __int64 v1; // rax
  signed __int64 result; // rax
  void *v3; // rsp

  v1 = a1 + 15;
  if ( a1 + 15 <= a1 )
    v1 = 0xFFFFFFFFFFFFFF0i64;
  result = v1 & 0xFFFFFFFFFFFFFFF0ui64;
  v3 = alloca(result);
  return result;
}

//----- (000000018000A498) ----------------------------------------------------
_BOOL8 __fastcall IsIpAddress(PCWSTR AddressString)
{
  USHORT Port[2]; // [rsp+20h] [rbp-A8h] BYREF
  ULONG ScopeId[3]; // [rsp+24h] [rbp-A4h] BYREF
  char v5[4]; // [rsp+30h] [rbp-98h] BYREF
  struct in_addr Address; // [rsp+34h] [rbp-94h] BYREF
  struct in6_addr v7; // [rsp+38h] [rbp-90h] BYREF

  memset_0(v5, 0, 0x80ui64);
  return RtlIpv4StringToAddressExW(AddressString, 1u, &Address, Port) >= 0
      || RtlIpv6StringToAddressExW(AddressString, &v7, ScopeId, Port) >= 0;
}
// 18000A498: using guessed type char var_98[4];
// 18000A498: using guessed type ULONG ScopeId[3];

//----- (000000018000A534) ----------------------------------------------------
void *__fastcall SetHandshakeHeader(__int64 a1, char a2, const void *a3, unsigned int a4, __int16 a5, int a6)
{
  void *result; // rax

  *(_BYTE *)a1 = a2;
  if ( a6 )
  {
    *(_BYTE *)(a1 + 5) = a5;
    *(_BYTE *)(a1 + 4) = HIBYTE(a5);
    result = (void *)HIWORD(a4);
    *(_BYTE *)(a1 + 9) = BYTE2(a4);
    *(_WORD *)(a1 + 7) = 0;
    *(_BYTE *)(a1 + 6) = 0;
    *(_BYTE *)(a1 + 11) = a4;
    *(_BYTE *)(a1 + 10) = BYTE1(a4);
  }
  else
  {
    result = (void *)HIWORD(a4);
  }
  *(_BYTE *)(a1 + 1) = (_BYTE)result;
  *(_BYTE *)(a1 + 3) = a4;
  *(_BYTE *)(a1 + 2) = BYTE1(a4);
  if ( a3 )
    return memcpy_0((void *)(a1 + 4 + (a6 != 0 ? 8 : 0)), a3, a4);
  return result;
}

//----- (000000018000A590) ----------------------------------------------------
__int64 __fastcall CTlsExtClient::ParseExtension(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned __int16 a4)
{
  unsigned int v4; // ebp
  unsigned int v5; // edi
  unsigned __int8 *v8; // r9
  int v9; // r8d
  __int64 v10; // rax
  __int64 v11; // rcx
  unsigned int v12; // r13d
  int v13; // r9d
  CCipherMill *v14; // rcx
  __int64 result; // rax
  _DWORD *v16; // rax
  unsigned __int16 v17; // r8
  __int64 v18; // rcx
  int v19; // edx
  __int64 v20; // rax
  CCipherMill *v21; // rcx
  __int64 v22; // rdx
  char *v23; // r14
  CCipherMill *v24; // r15
  __int64 v25; // rdx
  CSsl3TlsClientContext *v26; // rcx
  __int64 v27; // rcx
  CSsl3TlsClientContext *v28; // r10
  __int16 v29; // cx
  unsigned __int16 v30; // ax
  unsigned __int8 *v31; // r14
  unsigned __int16 *v32; // rdx
  unsigned __int8 *v33; // r14
  unsigned __int16 v34; // cx
  unsigned __int8 *v35; // r14
  unsigned int v36; // ecx
  _BYTE *v37; // r14
  unsigned int Size; // [rsp+30h] [rbp-48h]
  void *Buf2; // [rsp+38h] [rbp-40h]
  void *v40; // [rsp+40h] [rbp-38h]

  v4 = 0;
  v5 = a4;
  v8 = 0i64;
  v9 = 5;
  switch ( (_DWORD)a2 )
  {
    case 5:
      *(_QWORD *)(*(_QWORD *)(a1 + 8) + 136i64) |= 0x20000ui64;
      goto LABEL_20;
    case 6:
      if ( (_WORD)v5 )
      {
        v36 = *a3;
        v37 = a3 + 1;
        if ( v36 == v5 - 1 )
        {
          if ( !*(_BYTE *)(a1 + 52) )
            return 0i64;
          if ( v36 )
          {
            while ( *v37 != 64 )
            {
              ++v4;
              ++v37;
              if ( v4 >= v36 )
                goto LABEL_80;
            }
            *(_BYTE *)(*(_QWORD *)(a1 + 8) + 922i64) = 1;
          }
LABEL_80:
          v9 = 6;
          goto LABEL_20;
        }
      }
      return 2148074278i64;
    case 0xE:
      v28 = *(CSsl3TlsClientContext **)(a1 + 56);
      if ( (*((_DWORD *)v28 + 34) & 0x2000i64) == 0 || (unsigned __int16)(v5 - 5) > 0xFFu )
      {
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v22 = 37i64;
        goto LABEL_126;
      }
      v29 = *a3;
      v30 = a3[1];
      v31 = a3 + 2;
      if ( (v30 | (unsigned __int16)(v29 << 8)) != 2 )
      {
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v22 = 38i64;
        goto LABEL_126;
      }
      v32 = (unsigned __int16 *)v31;
      v33 = v31 + 2;
      v34 = *v33;
      v35 = v33 + 1;
      if ( (_BYTE)v34 )
      {
        if ( (unsigned __int16)(v5 - 5) < v34 )
        {
          v21 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            return 2148074278i64;
          }
          v22 = 39i64;
          goto LABEL_126;
        }
        v8 = v35;
      }
      result = CSsl3TlsClientContext::SetNegotiatedSrtpParameters(v28, v32, 2u, v8, v34);
      if ( !(_DWORD)result )
      {
        v9 = 14;
        goto LABEL_20;
      }
      break;
    case 0x10:
      v16 = (_DWORD *)(*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD))(**(_QWORD **)(a1 + 8) + 88i64))(
                        *(_QWORD *)(a1 + 8),
                        a2,
                        5i64,
                        0i64);
      if ( v16 && *v16 )
      {
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v22 = 33i64;
        goto LABEL_126;
      }
      if ( (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 136i64) & 0x4000000) == 0 || (unsigned __int16)(v5 - 4) > 0xFEu )
      {
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v22 = 34i64;
        goto LABEL_126;
      }
      v17 = _byteswap_ushort(*(_WORD *)a3);
      if ( v17 != v5 - 2 )
      {
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v22 = 35i64;
        goto LABEL_126;
      }
      result = CSsl3TlsClientContext::SetSelectedApplicationProtocol(*(CSsl3TlsClientContext **)(a1 + 56), a3 + 2, v17);
      if ( !(_DWORD)result )
      {
        v9 = 16;
        goto LABEL_20;
      }
      break;
    case 0x17:
      if ( !*(_BYTE *)(*(_QWORD *)(a1 + 56) + 1344i64) )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 36i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
        v27 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 120i64);
        if ( v27 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
          *(_WORD *)(v27 + 66) |= 4u;
        return 2148074278i64;
      }
      v9 = 23;
      *(_QWORD *)(*(_QWORD *)(a1 + 8) + 136i64) |= 0x8000000ui64;
      goto LABEL_20;
    case 0x18:
      v26 = *(CSsl3TlsClientContext **)(a1 + 56);
      if ( (*((_DWORD *)v26 + 34) & 0x80000000) == 0 || v5 < 4 )
      {
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v22 = 40i64;
        goto LABEL_126;
      }
      if ( (unsigned __int16)(v5 - 3) < a3[2] || a3[2] != 1 )
      {
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v22 = 41i64;
        goto LABEL_126;
      }
      result = CSsl3TlsClientContext::SetNegotiatedTBParameters(v26, *a3, a3[1], a3 + 3, a3[2]);
      if ( !(_DWORD)result )
      {
        v9 = 24;
        goto LABEL_20;
      }
      break;
    case 0x23:
      v9 = 35;
      *(_QWORD *)(*(_QWORD *)(a1 + 8) + 136i64) |= 0x400000ui64;
LABEL_20:
      CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 120i64), 1, v9);
      return 0i64;
    case 0xFF01:
      v10 = *(_QWORD *)(a1 + 8);
      if ( *(_DWORD *)(v10 + 416) && !*(_BYTE *)(v10 + 553) )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 42i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
          v10 = *(_QWORD *)(a1 + 8);
        }
        CSslContext::SetErrorAndFatalAlert(v10, 1207, -2146892986, 0x28u);
        v18 = *(_QWORD *)(a1 + 8);
        *(_DWORD *)(v18 + 68) = 96;
        *(_WORD *)(v18 + 96) = 10242;
        return 2148074310i64;
      }
      *(_BYTE *)(v10 + 553) = 1;
      v11 = *(_QWORD *)(a1 + 8);
      v12 = *(_DWORD *)(v11 + 456);
      Buf2 = (void *)(v11 + 377);
      v40 = (void *)(v11 + 420);
      Size = *(_DWORD *)(v11 + 416);
      if ( (_WORD)v5 )
      {
        v13 = *a3;
        if ( v13 + 1 == v5 )
        {
          if ( (_WORD)v5 == 1 )
          {
            v14 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 45i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
              v14 = WPP_GLOBAL_Control;
            }
            if ( !v12 )
              return 0i64;
            if ( v14 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v14 + 28) & 1) != 0 )
              WPP_SF_DD(*((_QWORD *)v14 + 2), 0x2Eu, (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids, v5, v12);
            v19 = 1207;
            goto LABEL_38;
          }
          v23 = (char *)(a3 + 1);
          if ( v13 != *(_DWORD *)(v11 + 416) + v12 )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              WPP_SF_DD(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0x2Fu,
                (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
                v13,
                *(_DWORD *)(v11 + 416));
              v11 = *(_QWORD *)(a1 + 8);
            }
            v19 = 1207;
            goto LABEL_39;
          }
          v24 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
          {
            if ( (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 48i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
              v24 = WPP_GLOBAL_Control;
            }
            if ( v24 != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_DWORD *)v24 + 7) & 0x800) != 0 )
              {
                WPP_SF_(*((_QWORD *)v24 + 2), 49i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
                v24 = WPP_GLOBAL_Control;
              }
              if ( v24 != (CCipherMill *)&WPP_GLOBAL_Control )
              {
                if ( (*((_DWORD *)v24 + 7) & 0x800) != 0 )
                {
                  WPP_SF_(*((_QWORD *)v24 + 2), 50i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
                  v24 = WPP_GLOBAL_Control;
                }
                if ( v24 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)v24 + 7) & 0x800) != 0 )
                {
                  WPP_SF_(*((_QWORD *)v24 + 2), 51i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
                  v24 = WPP_GLOBAL_Control;
                }
              }
            }
          }
          if ( memcmp_0(v23, Buf2, Size) )
          {
            if ( v24 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v24 + 28) & 1) == 0 )
              goto LABEL_73;
            v25 = 52i64;
LABEL_72:
            WPP_SF_(*((_QWORD *)v24 + 2), v25, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
LABEL_73:
            v19 = 108;
LABEL_38:
            v11 = *(_QWORD *)(a1 + 8);
LABEL_39:
            CSslContext::SetErrorAndFatalAlert(v11, v19, -2146892986, 0x28u);
            v20 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v20 + 68) = 96;
            *(_WORD *)(v20 + 96) = 10242;
            return 2148074310i64;
          }
          if ( memcmp_0(&v23[Size], v40, v12) )
          {
            if ( v24 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v24 + 28) & 1) == 0 )
              goto LABEL_73;
            v25 = 53i64;
            goto LABEL_72;
          }
          v9 = 65281;
          goto LABEL_20;
        }
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
        {
          WPP_SF_DD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x2Cu,
            (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
            v13,
            v5);
        }
        return 2148074278i64;
      }
      v21 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074278i64;
      v22 = 43i64;
LABEL_126:
      WPP_SF_(*((_QWORD *)v21 + 2), v22, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
      return 2148074278i64;
    default:
      CSchannelTelemetryContext::LogUnknownTlsExtension(
        *(CSchannelTelemetryContext **)(*(_QWORD *)(a1 + 8) + 120i64),
        a2);
      return 0i64;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (000000018000A7D4) ----------------------------------------------------
__int64 __fastcall CTlsExtClient::BuildClientHelloExtension(
        CTlsExtClient *this,
        unsigned int a2,
        unsigned __int8 *a3,
        unsigned int *a4)
{
  unsigned int v4; // eax
  unsigned __int16 *v5; // r12
  unsigned __int8 *v7; // r13
  unsigned __int8 *v8; // rsi
  int v9; // r11d
  unsigned __int8 v10; // al
  __int64 v11; // rax
  unsigned __int8 *v12; // rbx
  unsigned __int8 *v13; // rbx
  __int64 v14; // rcx
  int v15; // edx
  __int64 v16; // rcx
  unsigned int v17; // r9d
  __int16 v18; // cx
  _BYTE *v19; // rbx
  bool i; // cf
  __int64 v21; // r8
  __int64 v22; // rcx
  int v23; // edx
  _BYTE *v24; // rcx
  CTlsSignatureSuiteList *v25; // rcx
  int v26; // eax
  unsigned int v27; // edi
  unsigned __int8 *v28; // rbx
  __int64 v29; // rcx
  CTlsExt *v30; // rcx
  size_t v31; // rdi
  const void *v32; // r15
  unsigned int v33; // eax
  __int64 v34; // r15
  size_t v35; // rdi
  __int64 v36; // rax
  __int64 v37; // rax
  __int64 v38; // rcx
  __int64 v39; // rax
  __int16 v40; // r11
  __int64 v41; // rbx
  __int64 v42; // rbx
  __int64 result; // rax
  __int64 v44; // rax
  size_t v45; // rbx
  const void *v46; // rdi
  __int64 v47; // rcx
  __int64 v48; // rax
  size_t v49; // rbx
  unsigned __int8 *v50; // r15
  unsigned __int8 v51; // di
  __int16 v52; // ax
  __int16 v53; // cx
  char *v54; // rsi
  char *v55; // rbx
  __int64 v56; // rax
  __int64 v57; // [rsp+80h] [rbp+40h] BYREF
  unsigned __int8 *v58; // [rsp+90h] [rbp+50h] BYREF

  v4 = *((_DWORD *)this + 5);
  LOBYTE(v5) = 0;
  v7 = &a3[a2];
  v57 = 0i64;
  if ( v4 )
  {
    if ( a2 < v4 )
      return 234i64;
    *a4 = a2;
    v8 = a3 + 2;
    *a3 = (unsigned __int16)(v4 - 2) >> 8;
    v9 = 1;
    v10 = *((_BYTE *)this + 20) - 2;
    v58 = a3 + 2;
    a3[1] = v10;
    v11 = *((_QWORD *)this + 1);
    if ( (*(_DWORD *)(v11 + 64) & 0x2A88) != 0 || (*(_BYTE *)(v11 + 64) & 0x20) == 0 )
    {
      v12 = a3 + 2;
      if ( *((_QWORD *)this + 5) )
      {
        *(_WORD *)v8 = 0;
        v13 = a3 + 11;
        a3[4] = (unsigned __int16)(*((_WORD *)this + 24) + 5) >> 8;
        a3[5] = *((_BYTE *)this + 48) + 5;
        a3[6] = (unsigned __int16)(*((_WORD *)this + 24) + 3) >> 8;
        a3[7] = *((_BYTE *)this + 48) + 3;
        a3[8] = 0;
        a3[9] = *((_BYTE *)this + 49);
        a3[10] = *((_BYTE *)this + 48);
        memcpy_0(a3 + 11, *((const void **)this + 5), *((unsigned int *)this + 12));
        v14 = *((_QWORD *)this + 1);
        v58 = &v13[*((unsigned int *)this + 12)];
        v8 = v58;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v14 + 120), 0, 0);
        v12 = v8;
        v9 = v15 + 1;
      }
      if ( *((_BYTE *)this + 24) )
      {
        *v8 = 0;
        *(_QWORD *)(v12 + 1) = 17104901i64;
        v8 = v12 + 9;
        v16 = *((_QWORD *)this + 1);
        v58 = v12 + 9;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v16 + 120), 0, 5);
        v12 += 9;
      }
      if ( *((_BYTE *)this + 25) )
      {
        *v8 = 0;
        *(_DWORD *)(v12 + 1) = 16908294;
        v8 = v12 + 6;
        v12[5] = 64;
        v48 = *((_QWORD *)this + 1);
        v58 = v12 + 6;
        *(_BYTE *)(v48 + 922) = v9;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 6);
        v12 += 6;
      }
      if ( *((_BYTE *)this + 32) )
      {
        v17 = 0;
        v18 = *(_WORD *)(*((_QWORD *)this + 7) + 920i64);
        *v8 = 0;
        v18 *= 2;
        v12[1] = 10;
        v12[2] = (unsigned __int16)(v18 + 2) >> 8;
        v12[3] = v18 + 2;
        v12[4] = HIBYTE(v18);
        v12[5] = v18;
        v19 = v12 + 6;
        for ( i = *(_WORD *)(*((_QWORD *)this + 7) + 920i64) != 0;
              i;
              i = v17 < *(unsigned __int16 *)(*((_QWORD *)this + 7) + 920i64) )
        {
          v21 = v17;
          v17 += v9;
          *v19 = *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 7) + 912i64) + 2 * v21 + 1);
          v19[1] = *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 7) + 912i64) + 2 * v21);
          v19 += 2;
        }
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 10);
        *v19 = 0;
        *(_DWORD *)(v19 + 1) = 16908299;
        v8 = v19 + 6;
        v19[5] = 0;
        v22 = *((_QWORD *)this + 1);
        v58 = v19 + 6;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v22 + 120), v23, v23 + 11);
        v12 = v19 + 6;
      }
      v24 = (_BYTE *)*((_QWORD *)this + 7);
      if ( v24[925] )
      {
        v25 = (CTlsSignatureSuiteList *)(v24 + 474);
        v26 = *(unsigned __int16 *)v25;
        *v8 = 0;
        v12[1] = 13;
        v27 = 2 * v26 + 2;
        v12[2] = BYTE1(v27);
        v12[3] = 2 * v26 + 2;
        v28 = v12 + 4;
        CTlsSignatureSuiteList::BuildSupportedSignatureAlgorithms(v25, v28, v27);
        v29 = *((_QWORD *)this + 1);
        v8 = &v28[v27];
        v58 = v8;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v29 + 120), 0, 13);
        v24 = (_BYTE *)*((_QWORD *)this + 7);
        v12 = v8;
      }
      (*(void (__fastcall **)(_BYTE *, __int64 *))(*(_QWORD *)v24 + 224i64))(v24, &v57);
      if ( v57 )
      {
        v32 = *(const void **)(v57 + 424);
        v33 = *(_DWORD *)(v57 + 432);
        v31 = v33;
        *v8 = 0;
        v8 = v12 + 4;
        v12[1] = 35;
        v12[2] = BYTE1(v33);
        v12[3] = v33;
        v58 = v12 + 4;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids, v33);
        v12 += 4;
        if ( (_DWORD)v31 )
        {
          *(_QWORD *)(*((_QWORD *)this + 1) + 136i64) |= 0x800000ui64;
          v47 = *(_QWORD *)(*((_QWORD *)this + 1) + 120i64);
          if ( v47 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
          {
            *(_WORD *)(v47 + 64) |= 2u;
            *(_DWORD *)(v47 + 24) = 1;
          }
          memcpy_0(v8, v32, v31);
          v12 = &v8[v31];
          v8 = v12;
          v58 = v12;
        }
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 35);
      }
      v34 = *(_QWORD *)(*((_QWORD *)this + 1) + 784i64);
      if ( v34 )
      {
        v35 = *(unsigned __int16 *)(v34 + 4);
        *v8 = 0;
        v12[1] = 16;
        v12[2] = (unsigned __int16)(v35 + 2) >> 8;
        v12[3] = v35 + 2;
        v12[4] = BYTE1(v35);
        v12[5] = v35;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            11i64,
            &WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
            (unsigned int)v35);
        memcpy_0(v12 + 6, (const void *)(v34 + 6), v35);
        v36 = *((_QWORD *)this + 1);
        v8 = &v12[v35 + 6];
        v58 = v8;
        *(_QWORD *)(v36 + 136) |= 0x4000000ui64;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 16);
        v12 = v8;
      }
      v37 = *((_QWORD *)this + 7);
      if ( *(_BYTE *)(v37 + 1344) )
      {
        *v8 = 0;
        v8 = v12 + 4;
        v58 = v12 + 4;
        v12[1] = 23;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
        v38 = *((_QWORD *)this + 1);
        v39 = *(_QWORD *)(v38 + 120);
        if ( v39 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
        {
          *(_WORD *)(v39 + 66) |= 1u;
          v38 = *((_QWORD *)this + 1);
        }
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v38 + 120), 0, 23);
        v37 = *((_QWORD *)this + 7);
      }
      else
      {
        v40 = 1;
      }
      v41 = v37;
      if ( *(_BYTE *)(v37 + 233) )
      {
        v5 = *(unsigned __int16 **)(v37 + 800);
        if ( v5 )
        {
          v49 = *v5;
          v50 = *(unsigned __int8 **)(v37 + 1336);
          if ( v50 )
          {
            v51 = *v50;
            v52 = v40 + *v50;
          }
          else
          {
            v52 = 1;
            v51 = 0;
          }
          v53 = v52 + v49 + 2;
          *(_WORD *)v8 = 3584;
          v8[2] = HIBYTE(v53);
          v8[3] = v53;
          v8[4] = BYTE1(v49);
          v8[5] = v49;
          v54 = (char *)(v8 + 6);
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_DD(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xDu,
              (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
              v49,
              v51);
          }
          memcpy_0(v54, v5 + 1, v49);
          v54[v49] = v51;
          LOBYTE(v5) = 0;
          v55 = &v54[v49 + 1];
          if ( v50 )
            memcpy_0(v55, v50 + 1, v51);
          v56 = *((_QWORD *)this + 7);
          v8 = (unsigned __int8 *)&v55[v51];
          v58 = v8;
          *(_QWORD *)(v56 + 136) |= 0x2000ui64;
          CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 14);
          v41 = *((_QWORD *)this + 7);
        }
      }
      v42 = *(_QWORD *)(v41 + 816);
      if ( v42 )
      {
        result = CTlsExt::BuildTBExtension(
                   v30,
                   *(_BYTE *)v42,
                   *(_BYTE *)(v42 + 1),
                   (unsigned __int8 *const)(v42 + 4),
                   *(_BYTE *)(v42 + 2),
                   v7,
                   &v58);
        if ( (_DWORD)result )
          return result;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            14i64,
            &WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
            *(unsigned __int16 *)(v42 + 2));
        *(_QWORD *)(*((_QWORD *)this + 7) + 136i64) |= 0x80000000ui64;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 24);
        v8 = v58;
      }
      LOBYTE(v9) = 1;
    }
    if ( *((_BYTE *)this + 26) != (_BYTE)v5 )
    {
      v44 = *((_QWORD *)this + 7);
      v45 = *(unsigned int *)(v44 + 416);
      v46 = (const void *)(v44 + 377);
      *(_WORD *)v8 = 511;
      v8[2] = (unsigned __int16)(v45 + 1) >> 8;
      v8[3] = v9 + v45;
      v8[4] = v45;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
      }
      if ( (_DWORD)v45 )
        memcpy_0(v8 + 5, v46, v45);
      CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 65281);
    }
  }
  return 0i64;
}
// 18000A8C1: variable 'v15' is possibly undefined
// 18003564D: variable 'v9' is possibly undefined
// 18000A9C1: variable 'v23' is possibly undefined
// 18000ABFE: variable 'v30' is possibly undefined
// 1800356F6: variable 'v40' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (000000018000AD34) ----------------------------------------------------
__int64 __fastcall CSchannelTelemetryContext::LogTlsExtensionTelemetry(__int64 a1, int a2, int a3)
{
  char v3; // r9
  int v4; // r8d
  int v5; // r8d
  int v6; // r8d
  int v7; // r8d
  int v8; // r8d
  int v9; // r8d
  int v10; // r8d
  int v11; // r8d
  __int64 result; // rax

  v3 = a3;
  if ( a1 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
  {
    v4 = a3 - 10;
    if ( v4 )
    {
      v5 = v4 - 1;
      if ( v5 )
      {
        v6 = v5 - 2;
        if ( v6 )
        {
          v7 = v6 - 1;
          if ( v7 )
          {
            v8 = v7 - 2;
            if ( v8 )
            {
              v9 = v8 - 7;
              if ( v9 )
              {
                v10 = v9 - 1;
                if ( v10 )
                {
                  v11 = v10 - 11;
                  if ( v11 )
                  {
                    if ( v11 == 65246 )
                      v3 = 16;
                  }
                  else
                  {
                    v3 = 13;
                  }
                }
                else
                {
                  v3 = 15;
                }
              }
              else
              {
                v3 = 12;
              }
            }
            else
            {
              v3 = 11;
            }
          }
          else
          {
            v3 = 10;
          }
        }
        else
        {
          v3 = 9;
        }
      }
      else
      {
        v3 = 8;
      }
    }
    else
    {
      v3 = 7;
    }
    result = 1i64;
    if ( a2 )
    {
      if ( a2 == 1 )
      {
        result = (unsigned int)(1 << v3);
        *(_DWORD *)(a1 + 72) |= result;
      }
    }
    else
    {
      result = (unsigned int)(1 << v3);
      *(_DWORD *)(a1 + 68) |= result;
    }
  }
  return result;
}
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (000000018000ADF4) ----------------------------------------------------
void __fastcall CTlsSignatureSuiteList::BuildSupportedSignatureAlgorithms(
        CTlsSignatureSuiteList *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  size_t v4; // rdx

  if ( a2 )
  {
    v4 = 2 * (unsigned int)*(unsigned __int16 *)this;
    if ( a3 >= v4 + 2 )
    {
      *a2 = BYTE1(v4);
      a2[1] = v4;
      memcpy_0(a2 + 2, (char *)this + 2, v4);
    }
  }
}

//----- (000000018000AE3C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::GenerateSsl3TlsClientHello(CSsl3TlsClientContext *this, struct SPBuffer *a2)
{
  CSsl3TlsClientContext *v3; // rbx
  ULONG Random; // eax
  __int64 v5; // rdx
  unsigned int v6; // r8d
  __int64 result; // rax
  int v8; // ecx
  __int64 v9; // rax
  unsigned int v10; // [rsp+20h] [rbp-1B8h]
  __int128 v11; // [rsp+40h] [rbp-198h] BYREF
  char v12[352]; // [rsp+50h] [rbp-188h] BYREF

  v3 = this;
  v11 = 0i64;
  if ( !*((_DWORD *)this + 327) || *((_DWORD *)this + 17) == 4 )
  {
    Random = CSsl3TlsContext::TlsGenerateRandom(this);
    this = (CSsl3TlsClientContext *)Random;
    if ( Random )
    {
LABEL_12:
      if ( *((_BYTE *)v3 + 233) )
      {
        if ( (_DWORD)this )
          return (unsigned int)this;
        v9 = *((_QWORD *)&v11 + 1);
        if ( !*((_QWORD *)&v11 + 1) )
          return (unsigned int)this;
        if ( !*((_DWORD *)v3 + 327) || *((_DWORD *)v3 + 17) == 4 )
        {
          LODWORD(this) = CSsl3TlsContext::DtlsGetOutgoingRecord(v3, (struct SPBuffer *)&v11, a2);
          return (unsigned int)this;
        }
      }
      else
      {
        v9 = *((_QWORD *)&v11 + 1);
      }
      *((_QWORD *)a2 + 1) = v9;
      *(_QWORD *)a2 = v11;
      return (unsigned int)this;
    }
  }
  if ( (*((_DWORD *)v3 + 16) & 0x80800) == 0 )
  {
LABEL_8:
    if ( *((_BYTE *)v3 + 233) )
      v8 = *((_DWORD *)v3 + 16);
    else
      v8 = 2720;
    LODWORD(this) = CSslContext::GenerateHelloMessage(
                      v3,
                      (struct _Ssl2_Client_Hello *)v12,
                      (unsigned int)v8 & *(_DWORD *)(*((_QWORD *)v3 + 10) + 152i64),
                      (unsigned __int8 *)v3 + 272,
                      v10,
                      (unsigned __int16 **)v3 + 114,
                      (unsigned __int16 *)v3 + 460);
    if ( !(_DWORD)this )
      LODWORD(this) = CSsl3TlsClientContext::PackClientHello(
                        v3,
                        (struct _Ssl2_Client_Hello *)v12,
                        (struct SPBuffer *)&v11);
    goto LABEL_12;
  }
  CCipherMill::GetSignatureSuiteList(this, (CSsl3TlsClientContext *)((char *)v3 + 474));
  v5 = *((_QWORD *)v3 + 10);
  v6 = *(_DWORD *)(v5 + 196);
  if ( !v6 )
    goto LABEL_7;
  result = CTlsSignatureSuiteList::Blacklist(
             (CSsl3TlsClientContext *)((char *)v3 + 474),
             *(struct _TLS_PARAMETERS **)(v5 + 200),
             v6);
  if ( (_DWORD)result )
    return result;
  if ( *((_WORD *)v3 + 237) )
  {
LABEL_7:
    *((_BYTE *)v3 + 925) = 1;
    goto LABEL_8;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_13477250810f3961702f89c94d47ffd6_Traceguids);
  return 2148074289i64;
}
// 18000AF1E: variable 'v10' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000AF8C) ----------------------------------------------------
__int64 __fastcall CSslContext::GenerateHelloMessage(
        CSslContext *this,
        struct _Ssl2_Client_Hello *a2,
        unsigned int a3,
        unsigned __int8 *a4,
        unsigned int a5,
        unsigned __int16 **a6,
        unsigned __int16 *a7)
{
  __int64 v7; // rbx
  unsigned int *v12; // rdx
  unsigned int v13; // r8d
  int v14; // r9d
  __int64 result; // rax
  unsigned __int16 v16; // ax
  int v17; // r8d
  int v18; // ecx
  unsigned int v19; // ebx
  __int64 v20; // rax
  __int64 v21; // rdx
  unsigned int v22; // eax

  v7 = *((_QWORD *)this + 10);
  v12 = *(unsigned int **)(v7 + 184);
  v13 = *(_DWORD *)(v7 + 176);
  v14 = *(_DWORD *)(v7 + 192);
  *((_DWORD *)a2 + 1) = 68;
  result = CCipherMill::BuildCipherSuiteList(
             (__int64)this,
             v12,
             v13,
             v14,
             v7,
             a3,
             (__int64)a2 + 80,
             (_DWORD *)a2 + 1,
             a6,
             a7);
  if ( !(_DWORD)result )
  {
    v16 = ConvertSchannelProtocolToSsl(a3);
    v18 = v16;
    v19 = v17 + 32;
    *((_DWORD *)a2 + 2) = v17;
    if ( !v16 )
      v18 = 768;
    *(_DWORD *)a2 = v18;
    v20 = *((_QWORD *)this + 11);
    if ( v20 && *(_WORD *)(v20 + 238) > (unsigned __int16)v17 )
    {
      *((_DWORD *)a2 + 2) = v19;
      v21 = *((_QWORD *)this + 11);
      v22 = *(unsigned __int16 *)(v21 + 238);
      if ( v22 <= v19 )
      {
        *((_DWORD *)a2 + 2) = v22;
        memcpy_0((char *)a2 + 16, (const void *)(v21 + 240), *(unsigned __int16 *)(v21 + 238));
      }
    }
    result = 0i64;
    *((_OWORD *)a2 + 3) = *(_OWORD *)a4;
    *((_OWORD *)a2 + 4) = *((_OWORD *)a4 + 1);
    *((_DWORD *)a2 + 3) = v19;
  }
  return result;
}
// 18000B01E: variable 'v17' is possibly undefined

//----- (000000018000B0B0) ----------------------------------------------------
__int64 __fastcall SpInitUserModeContext(__int64 a1, struct _SecBuffer *a2)
{
  unsigned int v4; // ebx
  CCipherMill *v6; // rcx
  int v7; // [rsp+20h] [rbp-18h]
  unsigned int v8; // [rsp+20h] [rbp-18h]

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
  if ( (unsigned int)SchannelInit(1) )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_q(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x10u,
        (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids,
        a1);
    v4 = SslAddUserContext(a1, 0i64, a2, 0);
    if ( g_pFreeContextBuffer )
    {
      g_pFreeContextBuffer(a2->pvBuffer);
      a2->pvBuffer = 0i64;
      a2->cbBuffer = 0;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
      && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v4 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
    {
      v8 = v4;
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x11u,
        (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids,
        v4,
        v8);
    }
    return v4;
  }
  else
  {
    v6 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
        v6 = WPP_GLOBAL_Control;
      }
      if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 5) != 0 )
      {
        v7 = -2146893052;
        WPP_SF_DD(*((_QWORD *)v6 + 2), 0xFu, (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, -2146893052, v7);
      }
    }
    return 2148074244i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800921A0: using guessed type int (__stdcall *g_pFreeContextBuffer)(void *);

//----- (000000018000B190) ----------------------------------------------------
__int64 __fastcall SslAddUserContext(__int64 a1, void *a2, struct _SecBuffer *a3, int a4)
{
  CCipherMill *v8; // rcx
  struct CSslUserContext *v9; // rdi
  unsigned int v10; // ebx
  unsigned int v11; // ebx
  __int64 v12; // rsi
  char *v13; // rax
  char *v14; // rcx
  char **v15; // rdx
  __int64 v17; // [rsp+20h] [rbp-48h]
  __int128 v18; // [rsp+30h] [rbp-38h] BYREF
  __int64 v19; // [rsp+40h] [rbp-28h]
  int v20; // [rsp+48h] [rbp-20h]
  int v21; // [rsp+4Ch] [rbp-1Ch]
  struct CSslUserContext *v22; // [rsp+80h] [rbp+18h] BYREF

  v19 = 0i64;
  v20 = 0;
  v21 = 0;
  v18 = 0i64;
  v8 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_ba773d91511536867a821af0ee22c47a_Traceguids);
      v8 = WPP_GLOBAL_Control;
    }
    if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
      WPP_SF_q(*((_QWORD *)v8 + 2), 0xCu, (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids, a1);
  }
  if ( !a4 )
    SslDeleteUserContext(a1);
  if ( (unsigned int)CSslSerializeHelper::DeserializeContext(
                       (CSslSerializeHelper *)&v18,
                       (unsigned __int8 *)a3->pvBuffer,
                       a3->cbBuffer,
                       &v22) )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xDu,
        (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids,
        -2146893008,
        -2146893008);
    return 2148074288i64;
  }
  else
  {
    v9 = v22;
    if ( a2 || a4 )
      *((_QWORD *)v22 + 33) = a2;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_qq(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xEu,
        (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids,
        v9,
        a1);
    *((_QWORD *)v9 + 36) = a1;
    v10 = BYTE3(a1) + a1 + WORD1(a1) + ((unsigned int)a1 >> 8);
    v11 = (dwSslContextListCount - 1) & ((v10 >> 4) + v10);
    v12 = 96i64 * (v11 & (dwSslContextLockCount - 1));
    RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)SslContextLock + v12), 1u);
    v13 = (char *)v9 + 304;
    v14 = (char *)SslContextList + 16 * v11;
    v15 = (char **)*((_QWORD *)v14 + 1);
    if ( *v15 != v14 )
      __fastfail(3u);
    *(_QWORD *)v13 = v14;
    *((_QWORD *)v9 + 39) = v15;
    *v15 = v13;
    *((_QWORD *)v14 + 1) = v13;
    RtlReleaseResource((PRTL_RESOURCE)((char *)SslContextLock + v12));
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      LODWORD(v17) = 0;
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xFu,
        (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids,
        0,
        v17);
    }
    return 0i64;
  }
}
// 180035A1F: variable 'v17' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800919E0: using guessed type unsigned int dwSslContextListCount;
// 1800919E4: using guessed type unsigned int dwSslContextLockCount;

//----- (000000018000B32C) ----------------------------------------------------
__int64 __fastcall CSslSerializeHelper::DeserializeContext(
        CSslSerializeHelper *this,
        unsigned __int8 *a2,
        int a3,
        struct CSslUserContext **a4)
{
  unsigned int v4; // ebx
  unsigned __int8 *v7; // r8
  unsigned int v8; // eax
  unsigned int v9; // ecx
  int v10; // r9d
  unsigned int v11; // ebx
  struct CSslUserContext *UserContext; // rax

  *a4 = 0i64;
  v4 = 0;
  *((_DWORD *)this + 6) = a3;
  v7 = &a2[a3];
  *((_QWORD *)this + 1) = a2;
  while ( 1 )
  {
    if ( a2 + 16 > v7 )
      goto LABEL_11;
    v8 = *((_DWORD *)a2 + 2);
    v9 = *((_DWORD *)a2 + 1);
    if ( v8 > v9 )
      goto LABEL_11;
    v10 = *(_DWORD *)a2;
    if ( !*(_DWORD *)a2 )
      break;
    if ( v10 == 1 )
    {
      if ( v9 < 0xC8 )
        goto LABEL_11;
      v4 = 464;
    }
    else
    {
      if ( v10 <= 1 )
        goto LABEL_18;
      if ( v10 > 3 )
      {
        if ( v10 > 17 )
        {
          if ( v10 > 20 )
          {
LABEL_18:
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              WPP_SF_d(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0xBu,
                (__int64)&WPP_3fd35671b5b538c236a2a452323fc10e_Traceguids,
                v10);
            }
LABEL_11:
            v11 = -2146893052;
            goto LABEL_22;
          }
        }
        else
        {
          v4 += (v8 + 7) & 0xFFFFFFF8;
        }
      }
    }
    a2 += v9 + 16;
  }
  UserContext = CreateUserContext(v4);
  *a4 = UserContext;
  if ( UserContext )
  {
    v11 = CSslSerializeHelper::DeserializeContextWorker(this, UserContext);
    if ( !v11 )
      return v11;
  }
  else
  {
    v11 = -2146893056;
  }
LABEL_22:
  if ( *a4 )
    DeleteUserContext(*a4);
  return v11;
}

//----- (000000018000B400) ----------------------------------------------------
void __fastcall SslDeleteUserContext(__int64 a1)
{
  struct CSslUserContext *v2; // rax

  v2 = SslReferenceUserContext(a1, 1u);
  if ( v2 )
  {
    DeleteUserContext(v2);
  }
  else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x1Bu, (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids, a1);
  }
}

//----- (000000018000B448) ----------------------------------------------------
__int64 __fastcall CSslSerializeHelper::DeserializeContextWorker(CSslSerializeHelper *this, struct CSslUserContext *a2)
{
  __int64 v2; // rdi
  unsigned int SslProvHandle; // ebp
  int v5; // r9d
  __int128 *v6; // rbx
  __int128 *v7; // rcx
  __int64 v8; // rax
  __int128 *v10; // rdx
  __int64 v11; // rax
  __int128 v12; // xmm0
  __int64 v13; // rax
  __int64 v14; // rdx
  const wchar_t *v15; // r9
  CCipherMill *v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // [rsp+20h] [rbp-18h]

  v2 = *((_QWORD *)this + 1);
  SslProvHandle = 0;
  v5 = *(_DWORD *)v2;
  if ( *(_DWORD *)v2 == 1 )
  {
    v6 = (__int128 *)((char *)a2 + 464);
    while ( 1 )
    {
      v7 = (__int128 *)(v2 + 16);
      if ( v5 > 10 )
      {
        if ( v5 <= 15 )
        {
          switch ( v5 )
          {
            case 15:
              *((_QWORD *)a2 + 51) = v6;
              break;
            case 11:
              *((_QWORD *)a2 + 31) = v6;
              memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
              *((_DWORD *)a2 + 64) = *(_DWORD *)(v2 + 8);
              goto LABEL_24;
            case 12:
              *((_QWORD *)a2 + 49) = v6;
              v10 = v6;
              v11 = 2i64;
              do
              {
                v12 = *v7;
                v7 += 8;
                *v10 = v12;
                v10 += 8;
                *(v10 - 7) = *(v7 - 7);
                *(v10 - 6) = *(v7 - 6);
                *(v10 - 5) = *(v7 - 5);
                *(v10 - 4) = *(v7 - 4);
                *(v10 - 3) = *(v7 - 3);
                *(v10 - 2) = *(v7 - 2);
                *(v10 - 1) = *(v7 - 1);
                --v11;
              }
              while ( v11 );
              *(_QWORD *)v10 = *(_QWORD *)v7;
              goto LABEL_24;
            case 13:
              *((_QWORD *)a2 + 50) = v6;
              break;
            default:
              v13 = *((_QWORD *)a2 + 50);
LABEL_63:
              *(_QWORD *)(v13 + 8) = v6;
              memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
              goto LABEL_24;
          }
          *v6 = *v7;
          goto LABEL_24;
        }
        switch ( v5 )
        {
          case 16:
            v13 = *((_QWORD *)a2 + 51);
            goto LABEL_63;
          case 17:
            *((_QWORD *)a2 + 53) = v6;
            memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
            *((_DWORD *)a2 + 104) = *(_DWORD *)(v2 + 8);
            goto LABEL_24;
          case 18:
            goto LABEL_11;
        }
        if ( v5 > 20 )
        {
LABEL_67:
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            WPP_SF_d(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xFu,
              (__int64)&WPP_3fd35671b5b538c236a2a452323fc10e_Traceguids,
              v5);
          }
          return 2148074244i64;
        }
        if ( !a2 || !*((_QWORD *)a2 + 11) )
          return SslProvHandle;
        v14 = 440i64;
        if ( v5 != 19 )
          v14 = 448i64;
        SslProvHandle = SslImportKey(
                          *((_QWORD *)a2 + 11),
                          (char *)a2 + v14,
                          L"OpaqueKeyBlob",
                          v2 + 16,
                          *(_DWORD *)(v2 + 8),
                          0);
        if ( SslProvHandle )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            v15 = L"read";
            if ( *(_DWORD *)v2 != 19 )
              v15 = L"write";
            LODWORD(v18) = SslProvHandle;
            WPP_SF_SD(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xEu,
              (__int64)&WPP_3fd35671b5b538c236a2a452323fc10e_Traceguids,
              v15,
              v18);
          }
          return SslProvHandle;
        }
      }
      else
      {
        if ( v5 == 10 )
        {
          *((_QWORD *)a2 + 29) = v6;
          memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
          *((_DWORD *)a2 + 60) = *(_DWORD *)(v2 + 8);
          goto LABEL_24;
        }
        if ( v5 <= 5 )
        {
          switch ( v5 )
          {
            case 5:
              *((_QWORD *)a2 + 21) = v6;
              memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
              *((_DWORD *)a2 + 44) = *(_DWORD *)(v2 + 8);
              goto LABEL_24;
            case 0:
              return 0i64;
            case 1:
              *((_DWORD *)a2 + 2) = *(_DWORD *)v7;
              *((_QWORD *)a2 + 2) = *(_QWORD *)(v2 + 24);
              *((_DWORD *)a2 + 6) = *(_DWORD *)(v2 + 32);
              *((_BYTE *)a2 + 32) = *(_BYTE *)(v2 + 60);
              *((_DWORD *)a2 + 7) = *(_DWORD *)(v2 + 44);
              *((_QWORD *)a2 + 12) = *(_QWORD *)(v2 + 64);
              *((_QWORD *)a2 + 13) = *(_QWORD *)(v2 + 72);
              *((_DWORD *)a2 + 14) = *(_DWORD *)(v2 + 36);
              *((_DWORD *)a2 + 15) = *(_DWORD *)(v2 + 40);
              *((_DWORD *)a2 + 16) = *(_DWORD *)(v2 + 48);
              *((_DWORD *)a2 + 18) = *(_DWORD *)(v2 + 52);
              *((_DWORD *)a2 + 17) = *(_DWORD *)(v2 + 168);
              *((_DWORD *)a2 + 29) = *(_DWORD *)(v2 + 192);
              *((_QWORD *)a2 + 15) = *(_QWORD *)(v2 + 176);
              *((_QWORD *)a2 + 16) = *(_QWORD *)(v2 + 184);
              *((_WORD *)a2 + 68) = *(_WORD *)(v2 + 196);
              *((_WORD *)a2 + 69) = *(_WORD *)(v2 + 198);
              *((_DWORD *)a2 + 36) = *(_DWORD *)(v2 + 200);
              *((_DWORD *)a2 + 115) = *(_DWORD *)(v2 + 204);
              *((_BYTE *)a2 + 456) = *(_BYTE *)(v2 + 208);
              *((_DWORD *)a2 + 49) = *(_DWORD *)(v2 + 56);
              *((_DWORD *)a2 + 95) = *(_DWORD *)(v2 + 164);
              *((_DWORD *)a2 + 94) = *(_DWORD *)(v2 + 160);
              *((_QWORD *)a2 + 33) = *(_QWORD *)(v2 + 80);
              *((_DWORD *)a2 + 68) = *(_DWORD *)(v2 + 88);
              *((_QWORD *)a2 + 37) = *(_QWORD *)(v2 + 96);
              *((_DWORD *)a2 + 80) = *(_DWORD *)(v2 + 104);
              memcpy_0((char *)a2 + 324, (const void *)(v2 + 108), *(unsigned int *)(v2 + 104));
              goto LABEL_25;
          }
          if ( v5 <= 1 )
            goto LABEL_67;
          if ( v5 > 3 )
          {
            *((_QWORD *)a2 + 19) = v6;
            memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
            *((_DWORD *)a2 + 40) = *(_DWORD *)(v2 + 8);
LABEL_24:
            v6 = (__int128 *)((char *)v6 + ((*(unsigned int *)(v2 + 8) + 7i64) & 0xFFFFFFFFFFFFFFF8ui64));
            goto LABEL_25;
          }
LABEL_11:
          if ( !a2 || !*((_QWORD *)a2 + 11) )
            return SslProvHandle;
          if ( v5 == 2 )
          {
            v8 = 40i64;
          }
          else
          {
            v8 = 432i64;
            if ( v5 == 3 )
              v8 = 48i64;
          }
          SslProvHandle = SslImportKey(
                            *((_QWORD *)a2 + 11),
                            (char *)a2 + v8,
                            L"OpaqueKeyBlob",
                            v2 + 16,
                            *(_DWORD *)(v2 + 8),
                            0);
          if ( SslProvHandle )
          {
            v16 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v17 = 13i64;
LABEL_74:
              WPP_SF_D(*((_QWORD *)v16 + 2), v17, &WPP_3fd35671b5b538c236a2a452323fc10e_Traceguids, SslProvHandle);
            }
            return SslProvHandle;
          }
          goto LABEL_25;
        }
        switch ( v5 )
        {
          case 6:
            *((_QWORD *)a2 + 23) = v6;
            memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
            *((_DWORD *)a2 + 48) = *(_DWORD *)(v2 + 8);
            goto LABEL_24;
          case 7:
            *((_QWORD *)a2 + 25) = v6;
            memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
            *((_DWORD *)a2 + 52) = *(_DWORD *)(v2 + 8);
            goto LABEL_24;
          case 8:
            *((_QWORD *)a2 + 27) = v6;
            memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
            *((_DWORD *)a2 + 56) = *(_DWORD *)(v2 + 8);
            goto LABEL_24;
        }
        *((_QWORD *)a2 + 10) = v6;
        memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
        v6 = (__int128 *)((char *)v6 + ((*(unsigned int *)(v2 + 8) + 7i64) & 0xFFFFFFFFFFFFFFF8ui64));
        SslProvHandle = GetSslProvHandle(*((const unsigned __int16 **)a2 + 10), (unsigned __int64 *)a2 + 11);
        if ( SslProvHandle )
        {
          v16 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            v17 = 12i64;
            goto LABEL_74;
          }
          return SslProvHandle;
        }
      }
LABEL_25:
      v2 += (unsigned int)(*(_DWORD *)(v2 + 4) + 16);
      v5 = *(_DWORD *)v2;
    }
  }
  return 2148074244i64;
}
// 18000B58E: conditional instruction was optimized away because r9d.4==4
// 180035B6A: conditional instruction was optimized away because r9d.4>=13
// 18000B54B: conditional instruction was optimized away because r9d.4==9
// 180035B1E: conditional instruction was optimized away because r9d.4==E
// 180035C1C: variable 'v18' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082320: using guessed type wchar_t aOpaquekeyblob[14];
// 180085368: using guessed type wchar_t aRead[5];
// 180085378: using guessed type wchar_t aWrite[6];
// 1800985A0: using guessed type __int64 __fastcall SslImportKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (000000018000B810) ----------------------------------------------------
__int64 __fastcall SpInitLsaModeContext(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int a4,
        __int64 a5,
        struct _SecBufferDesc *a6,
        struct CSslParentContext **a7,
        struct _SecBufferDesc *a8,
        _DWORD *a9,
        union _LARGE_INTEGER *a10,
        unsigned __int8 *a11,
        struct _SecBuffer *a12)
{
  unsigned __int64 v15; // rsi
  struct CSslParentContext *v17; // r14
  unsigned __int64 v18; // r13
  CCipherMill *v19; // rcx
  unsigned int v20; // ebx
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // rax
  unsigned __int64 v24; // rax
  __int64 v25; // rdi
  __int64 v26; // r12
  struct _SecBuffer *v27; // rbx
  __int64 v28; // rdi
  __int64 v29; // rbx
  char v30; // al
  unsigned __int64 v31; // r9
  __int64 v32; // r8
  int v33; // ebx
  __int64 v34; // rax
  struct _SecBuffer *v35; // r14
  struct _SecBuffer *v36; // rdx
  const unsigned __int16 *v38; // rdx
  unsigned int v39; // eax
  __int64 v40; // rdi
  struct _SecBuffer *v41; // r15
  __int64 *pvBuffer; // rbx
  __int64 v43; // r9
  _QWORD *v44; // rax
  void *v45; // rcx
  __int64 v46; // rcx
  int v47; // ebx
  struct _SecBuffer **v48; // [rsp+28h] [rbp-E0h]
  struct CSslParentContext *v49; // [rsp+78h] [rbp-90h] BYREF
  char v50[4]; // [rsp+80h] [rbp-88h] BYREF
  unsigned int v51; // [rsp+84h] [rbp-84h]
  void *Src; // [rsp+88h] [rbp-80h]
  struct _SecBuffer *v53; // [rsp+90h] [rbp-78h] BYREF
  struct _SecBuffer *v54; // [rsp+98h] [rbp-70h] BYREF
  struct _SecBuffer *v55; // [rsp+A0h] [rbp-68h] BYREF
  struct _SecBuffer *v56; // [rsp+A8h] [rbp-60h] BYREF
  struct _SecBuffer *v57; // [rsp+B0h] [rbp-58h] BYREF
  struct _SecBuffer *v58; // [rsp+B8h] [rbp-50h] BYREF
  struct _SecBuffer *v59; // [rsp+C0h] [rbp-48h] BYREF
  struct _SecBuffer *v60; // [rsp+C8h] [rbp-40h] BYREF
  struct _SecBuffer *v61; // [rsp+D0h] [rbp-38h] BYREF
  struct _SecBuffer *v62; // [rsp+D8h] [rbp-30h] BYREF
  struct _SecBuffer *v63; // [rsp+E0h] [rbp-28h] BYREF
  struct _SecBuffer *v64; // [rsp+E8h] [rbp-20h] BYREF
  struct _SecBuffer *v65; // [rsp+F0h] [rbp-18h] BYREF
  unsigned __int64 *v66; // [rsp+F8h] [rbp-10h]
  __int128 v67; // [rsp+100h] [rbp-8h] BYREF
  struct _SecBuffer *v68; // [rsp+110h] [rbp+8h] BYREF
  struct _SecBuffer *v69; // [rsp+118h] [rbp+10h] BYREF
  char v70[16]; // [rsp+120h] [rbp+18h] BYREF
  struct _SecBuffer *v71; // [rsp+130h] [rbp+28h] BYREF
  int v74; // [rsp+190h] [rbp+88h]

  v62 = 0i64;
  v53 = 0i64;
  v55 = 0i64;
  v15 = 28i64;
  v54 = 0i64;
  v56 = 0i64;
  v58 = 0i64;
  v17 = 0i64;
  v57 = 0i64;
  v65 = 0i64;
  v60 = 0i64;
  v59 = 0i64;
  v63 = 0i64;
  v64 = 0i64;
  v67 = 0i64;
  v49 = 0i64;
  v74 = 0;
  v66 = 0i64;
  v18 = a4;
  v19 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 23i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
      v19 = WPP_GLOBAL_Control;
    }
    if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v19 + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)v19 + 2), 24i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
        v19 = WPP_GLOBAL_Control;
      }
      if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)v19 + 28) & 4) != 0 )
        {
          WPP_SF_q(*((_QWORD *)v19 + 2), 0x19u, (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids, a1);
          v19 = WPP_GLOBAL_Control;
        }
        if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)v19 + 28) & 4) != 0 )
          {
            WPP_SF_q(*((_QWORD *)v19 + 2), 0x1Au, (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids, a2);
            v19 = WPP_GLOBAL_Control;
          }
          if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v19 + 28) & 4) != 0 )
          {
            WPP_SF_D(*((_QWORD *)v19 + 2), 27i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids, a4);
            v19 = WPP_GLOBAL_Control;
          }
        }
      }
    }
  }
  if ( a3 && v19 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v19 + 28) & 4) != 0 )
  {
    WPP_SF_S(
      *((_QWORD *)v19 + 2),
      0x1Cu,
      (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
      *(const wchar_t **)(a3 + 8));
    v19 = WPP_GLOBAL_Control;
  }
  if ( !a1 )
  {
    v20 = -2146893055;
    goto LABEL_69;
  }
  if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)v19 + 28) & 4) != 0 )
    {
      WPP_SF_D(
        *((_QWORD *)v19 + 2),
        29i64,
        &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
        *(unsigned int *)(a1 + 212));
      v19 = WPP_GLOBAL_Control;
    }
    if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v19 + 28) & 4) != 0 )
      WPP_SF_S(
        *((_QWORD *)v19 + 2),
        0x1Eu,
        (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
        (const wchar_t *)(a1 + 216));
  }
  v20 = ParseOutputBufferDesc(a8, v18, &v61, (struct SPBuffer *)v50, &v62, (struct SPBuffer *)&v67, &v65, &v60, &v64);
  if ( v20 )
    goto LABEL_66;
  v21 = ((-(__int64)((v18 & 0x4000) != 0) & 0x4000) + 28) | 0x100;
  v22 = (v18 & 0x4000) != 0 ? 0x200 : 0;
  if ( (v18 & 0x100) == 0 )
    v21 = (-(__int64)((v18 & 0x4000) != 0) & 0x4000) + 28;
  if ( (v18 & 0x800) != 0 )
    v22 |= 0x1000ui64;
  v15 = v21 | ((-(__int64)((v18 & 0x800) != 0) & 0xFFFFFFFFFFFF8800ui64) + 0x8000);
  v23 = v18 & 0x80000;
  if ( (v18 & 2) != 0 )
  {
    v15 |= 2ui64;
    v22 |= 0x100ui64;
    if ( v23 )
    {
      v20 = 120;
      goto LABEL_66;
    }
  }
  else
  {
    if ( v23 )
    {
      v15 |= 0x80000ui64;
      v22 |= 0x4000ui64;
    }
    if ( g_fManualCredValidation )
      v22 |= 0x4000ui64;
  }
  v24 = v15;
  v15 |= 0x80ui64;
  if ( (v18 & 0x80) == 0 )
    v15 = v24;
  v25 = v22 | 0x400;
  if ( (v18 & 0x80) == 0 )
    v25 = v22;
  if ( (v18 & 0x400) != 0 )
  {
    v15 |= 0x400ui64;
    if ( (v18 & 0x800) != 0
      && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 31i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
    }
  }
  v20 = ParseInputBufferDesc(
          a6,
          &v68,
          (struct SPBuffer *)v70,
          &v69,
          &v71,
          &v53,
          &v55,
          &v54,
          &v56,
          &v58,
          &v57,
          &v59,
          &v63);
  if ( v20 )
    goto LABEL_66;
  v26 = v25;
  if ( v63 )
  {
    pvBuffer = (__int64 *)v63->pvBuffer;
    if ( !pvBuffer || v63->cbBuffer < 8 )
    {
      v20 = 87;
      goto LABEL_66;
    }
    v43 = *pvBuffer;
    v26 = v25;
    if ( (*pvBuffer & 0x100000000i64) != 0 )
    {
      v26 = v25 | 0x100000000i64;
      v15 |= 0x100000000ui64;
    }
    if ( (v43 & 0x200000000i64) != 0 )
    {
      v19 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 32i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
        v43 = *pvBuffer;
        v19 = WPP_GLOBAL_Control;
      }
      v26 |= 0x200000000ui64;
      v15 |= 0x200000000ui64;
    }
    else
    {
      v19 = WPP_GLOBAL_Control;
    }
    if ( (v43 & ~v26 & 0xFFFFFFFF00000000ui64) != 0 )
    {
      if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v19 + 28) & 4) != 0 )
      {
        WPP_SF_i(
          *((_QWORD *)v19 + 2),
          0x21u,
          (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
          v43 & ~v26 & 0xFFFFFFFF00000000ui64);
        v19 = WPP_GLOBAL_Control;
      }
      goto LABEL_121;
    }
    v18 |= v43;
    if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v19 + 28) & 4) != 0 )
      WPP_SF_i(*((_QWORD *)v19 + 2), 0x22u, (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
  }
  v27 = v64;
  if ( v64 )
  {
    v44 = v64->pvBuffer;
    if ( !v44 )
    {
      v44 = SPExternalAlloc(8u);
      v27->pvBuffer = v44;
      if ( !v44 )
      {
        v20 = -2146893056;
        goto LABEL_66;
      }
      v27->cbBuffer = 8;
    }
    v66 = v44;
  }
  if ( !a2 )
  {
    if ( a3 )
      v38 = *(const unsigned __int16 **)(a3 + 8);
    else
      v38 = &Class;
    v39 = CSslContextManager::InstantiateClientContext(v19, v38, (struct CCredentialGroup *)a1, &v49, v18);
    v17 = v49;
    v20 = v39;
    if ( v39 )
      goto LABEL_66;
    v40 = *((_QWORD *)v49 + 1);
    *(_QWORD *)(v40 + 136) |= v26;
    CSslContext::SetCredentialGroup((CSslContext *)v40, (struct CCredentialGroup *)a1);
    v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v40 + 296i64))(v40, v53);
    if ( v20 )
      goto LABEL_66;
    v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *, struct _SecBuffer *))(*(_QWORD *)v40 + 304i64))(
            v40,
            v55,
            v54);
    if ( v20 )
      goto LABEL_66;
    v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v40 + 312i64))(v40, v56);
    if ( v20 )
      goto LABEL_66;
    v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *, struct _SecBuffer *))(*(_QWORD *)v40 + 328i64))(
            v40,
            v58,
            v57);
    if ( v20 )
      goto LABEL_66;
    v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v40 + 344i64))(v40, v59);
    if ( v20 )
      goto LABEL_66;
    v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBufferDesc *, struct _SecBuffer *))(*(_QWORD *)v40 + 368i64))(
            v40,
            a6,
            v60);
    if ( v20 )
      goto LABEL_66;
    v20 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v40 + 216i64))(v40, v50);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 36i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
    if ( v20 && (HIBYTE(*(_WORD *)(v40 + 34)) != 0xFE || v20 != 590692) )
    {
      if ( (v18 & 0x100) != 0 && Src )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 16i64))(v40);
LABEL_140:
      CSslContextManager::DeleteFullSslContext((CSslContextManager *)&g_SslContextManager, v17);
      goto LABEL_66;
    }
    *a7 = v17;
    CSchannelTelemetryContext::LogHandshakeStart(*(_QWORD *)(v40 + 120), 0, v18, a1, (__int64)v17);
    v41 = v61;
    if ( (v18 & 0x100) != 0 )
    {
      v61->pvBuffer = Src;
    }
    else
    {
      v45 = v61->pvBuffer;
      if ( v45 != Src )
      {
        if ( v61->cbBuffer < v51 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            LODWORD(v48) = v51;
            WPP_SF_dd(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x25u,
              (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
              v61->cbBuffer,
              v48);
          }
          v20 = -2146893023;
          goto LABEL_140;
        }
        memcpy_0(v45, Src, v51);
        (*(void (__fastcall **)(__int64, void *))(*(_QWORD *)v40 + 16i64))(v40, Src);
      }
    }
    v41->cbBuffer = v51;
    v19 = WPP_GLOBAL_Control;
    if ( v20 != 590692 )
      v20 = 590610;
    goto LABEL_67;
  }
  v28 = *(_QWORD *)(a2 + 8);
  v74 = 1;
  v49 = (struct CSslParentContext *)a2;
  if ( _InterlockedIncrement((volatile signed __int32 *)a2) != 1 )
  {
    v17 = v49;
    v20 = 120;
    goto LABEL_66;
  }
  *(_WORD *)(a2 + 34) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  *(_QWORD *)(v28 + 136) |= v26;
  CSslContext::SetCredentialGroup((CSslContext *)v28, (struct CCredentialGroup *)a1);
  if ( (*(_QWORD *)(v28 + 136) & 0x200004000i64) != 0x200004000i64 )
  {
    if ( *(_DWORD *)(v28 + 68) != 4
      || (v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v28 + 296i64))(v28, v53)) == 0
      && (v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *, struct _SecBuffer *))(*(_QWORD *)v28 + 304i64))(
                  v28,
                  v55,
                  v54)) == 0
      && (v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v28 + 312i64))(v28, v56)) == 0 )
    {
      v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *, struct _SecBuffer *))(*(_QWORD *)v28 + 328i64))(
              v28,
              v58,
              v57);
      if ( !v20 )
      {
        v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v28 + 344i64))(v28, v59);
        if ( !v20 )
        {
          v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBufferDesc *, struct _SecBuffer *))(*(_QWORD *)v28
                                                                                                 + 368i64))(
                  v28,
                  a6,
                  v60);
          if ( !v20 )
          {
            v29 = *(_QWORD *)v28;
            v30 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v28 + 384i64))(v28);
            v31 = v18 >> 8;
            LOBYTE(v31) = BYTE1(v18) & 1;
            LOBYTE(v32) = v30;
            v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBufferDesc *, __int64, unsigned __int64))(v29 + 376))(
                    v28,
                    a8,
                    v32,
                    v31);
            if ( !v20 )
            {
              v33 = (*(__int64 (__fastcall **)(__int64, char *, char *))(*(_QWORD *)v28 + 192i64))(v28, v70, v50);
              if ( (*(_DWORD *)(v28 + 136) & 0x40000) == 0 )
              {
LABEL_54:
                v34 = *(_QWORD *)(v28 + 136);
                if ( (v34 & 0x10000000) != 0 )
                {
                  v15 |= 0x4000ui64;
                  *(_QWORD *)(v28 + 136) = v34 & 0xFFFFFFFFEFFFFFFFui64;
                }
                if ( v33 && !*(_DWORD *)(a2 + 36) )
                  *(_DWORD *)(a2 + 36) = v33;
                if ( v62 )
                  GenerateFatalAlertMessage(v33, v28, v18, (__int64)&v67);
                v35 = v61;
                if ( v33 == 590624 )
                {
                  if ( v65 )
                    GeneratePSKExchangeMessage(v28, (__int64)v65);
                }
                else if ( v33 == 590684 )
                {
                  v61->BufferType = 3;
                }
                if ( !IsFatalError(v33) )
                  *a7 = (struct CSslParentContext *)a2;
                v20 = AscIscPostProcessing(
                        v33,
                        (struct CSslContext *)v28,
                        (struct CSslParentContext *)a2,
                        a12,
                        v69,
                        v68,
                        (struct SPBuffer *)v70,
                        v35,
                        (struct SPBuffer *)v50,
                        v18,
                        a11,
                        a10);
                goto LABEL_65;
              }
              v46 = *(_QWORD *)(a2 + 8);
              v47 = *(_DWORD *)(v46 + 64);
              (**(void (__fastcall ***)(__int64, _QWORD))v46)(v46, 0i64);
              if ( (v47 & 0x800A2AAA) != 0 )
                SPExternalFree(*(void **)(a2 + 8));
              v28 = *(_QWORD *)(a2 + 16);
              *(_QWORD *)(a2 + 8) = v28;
              *(_QWORD *)(a2 + 16) = 0i64;
              if ( v28 )
              {
                v33 = (*(__int64 (__fastcall **)(__int64, char *, char *))(*(_QWORD *)v28 + 192i64))(v28, v70, v50);
                goto LABEL_54;
              }
              v20 = 1359;
            }
          }
        }
      }
    }
LABEL_65:
    v17 = v49;
LABEL_66:
    v19 = WPP_GLOBAL_Control;
    goto LABEL_67;
  }
  v19 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 38i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
    v19 = WPP_GLOBAL_Control;
  }
  v17 = v49;
LABEL_121:
  v20 = -2146892963;
LABEL_67:
  v36 = v62;
  if ( v62 )
  {
    v62->pvBuffer = (void *)*((_QWORD *)&v67 + 1);
    v36->cbBuffer = DWORD1(v67);
    v19 = WPP_GLOBAL_Control;
  }
LABEL_69:
  if ( a9 )
  {
    *a9 = v15;
    v19 = WPP_GLOBAL_Control;
  }
  if ( v66 )
  {
    *v66 = v15 & 0xFFFFFFFF00000000ui64;
    v19 = WPP_GLOBAL_Control;
  }
  if ( v74 && v17 )
  {
    _InterlockedDecrement((volatile signed __int32 *)v17);
    v19 = WPP_GLOBAL_Control;
  }
  if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v19 + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)v19 + 2), 39i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids, v20);
  return TranslateToSecurityStatus(v20);
}
// 180036081: conditional instruction was optimized away because ecx.4 is in (FE00..FEFF)
// 18000BC28: variable 'v32' is possibly undefined
// 18000BDF0: variable 'v19' is possibly undefined
// 1800360CF: variable 'v48' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092DA0: using guessed type __int64 g_SslContextManager;
// 180092F04: using guessed type int g_fManualCredValidation;

//----- (000000018000BFE0) ----------------------------------------------------
__int64 __fastcall SpSealMessage(__int64 a1, int a2, struct _SecBufferDesc *a3)
{
  struct CSslUserContext *UserContext; // rax
  struct CSslUserContext *v7; // rcx
  int v9; // eax
  unsigned int v10; // eax
  int v11; // edx
  unsigned int v12; // eax
  unsigned int v13; // ebx
  CCipherMill *v14; // r10
  __int64 v15; // r10
  int v16; // [rsp+20h] [rbp-18h]

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
  UserContext = SslFindUserContext(a1);
  v7 = UserContext;
  if ( UserContext )
  {
    v9 = *((_DWORD *)UserContext + 2);
    if ( v9 == 4 || (v10 = v9 - 51, v10 <= 0x1B) && (v11 = 167772161, _bittest(&v11, v10)) )
    {
      if ( (*((_DWORD *)v7 + 4) & 0x1000i64) != 0 )
        v12 = SslSealMessageConnection(v7, a2, a3);
      else
        v12 = SslSealMessageStream(v7, a2, a3);
      v13 = v12;
      v14 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && (unsigned int)TranslateToSecurityStatus(v12)
         || (*((_BYTE *)v14 + 28) & 4) != 0) )
      {
        v16 = TranslateToSecurityStatus(v13);
        WPP_SF_DD(*(_QWORD *)(v15 + 16), 0x15u, (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, v16, v16);
      }
      return TranslateToSecurityStatus(v13);
    }
    else
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
        WPP_SF_DD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x14u,
          (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids,
          -2146893033,
          -2146893033);
      return 2148074263i64;
    }
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x13u,
        (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids,
        -2146893055,
        -2146893055);
    return 2148074241i64;
  }
}
// 18000C102: variable 'v14' is possibly undefined
// 18000C110: variable 'v15' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000C160) ----------------------------------------------------
__int64 __fastcall SpUserQueryContextAttributes(__int64 a1, unsigned int a2, struct _SecPkgContext_TokenBinding *a3)
{
  struct CSslUserContext *UserContext; // rax
  struct CSslUserContext *v6; // rcx
  struct CSslUserContext *v7; // rbx
  unsigned int v9; // ecx
  __int64 v11; // rax

  UserContext = SslFindUserContext(a1);
  v7 = UserContext;
  if ( !UserContext )
    return 2148074241i64;
  if ( a2 > 0x24 )
  {
    if ( a2 > 0x6C )
    {
      switch ( a2 )
      {
        case 'm':
          return (unsigned int)SpQueryTokenBinding(UserContext, a3);
        case 'n':
          return (unsigned int)SpQueryConnectionInfoEx(UserContext, (struct _SecPkgContext_ConnectionInfoEx *)a3);
        case 'o':
          return (unsigned int)SpQueryTokenBindingEKM(UserContext, (struct _SecPkgContext_KeyingMaterial *)a3);
        case 'p':
          return (unsigned int)SpQueryKeyingMaterial(UserContext, (struct _SecPkgContext_KeyingMaterial_Inproc *)a3);
        case 'r':
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 19i64, &WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids);
          }
          return (unsigned int)SpQueryCertificateValidationResult(
                                 *((_QWORD *)v7 + 2),
                                 *((_DWORD *)v7 + 95),
                                 *((_DWORD *)v7 + 94),
                                 (struct _SecPkgContext_CertificateValidationResult *)a3);
      }
    }
    else
    {
      switch ( a2 )
      {
        case 'l':
          return (unsigned int)SpQuerySrtpParameters(UserContext, (struct _SecPkgContext_SrtpParameters *)a3);
        case 'Z':
          return (unsigned int)GetOldConnectionInfo(UserContext, (struct _SecPkgContext_ConnectionInfo *)a3);
        case 'S':
          return SpQueryRemoteCertContext(UserContext, (const CERT_CONTEXT **)a3);
        case ']':
          return (unsigned int)SpQuerySessionInfo(UserContext, (struct _SecPkgContext_SessionInfo *)a3);
        case 'Q':
          return SpQueryRemoteCred(UserContext, a3);
        case 'd':
          return (unsigned int)GetCipherInfo(UserContext, (struct _SecPkgContext_CipherInfo *)a3);
      }
    }
  }
  else
  {
    if ( a2 == 36 )
      return (unsigned int)SpQueryNegotiatedTlsExtensions(
                             UserContext,
                             (struct _SecPkgContext_NegotiatedTlsExtensions *)a3);
    if ( a2 > 7 )
    {
      switch ( a2 )
      {
        case 0xAu:
          return (unsigned int)SpQueryPackageInfo(v6, a3);
        case 0x12u:
          v11 = *((_QWORD *)UserContext + 33);
          if ( v11 )
          {
            *(_QWORD *)&a3->MajorVersion = v11;
            return 0;
          }
          else
          {
            v9 = -2146893045;
            if ( *((_DWORD *)v7 + 68) )
              return *((unsigned int *)v7 + 68);
          }
          return v9;
        case 0x19u:
          return (unsigned int)SpQueryUniqueBindings(UserContext, (struct _SecPkgContext_Bindings *)a3);
        case 0x1Au:
          return (unsigned int)SpQueryEndpointBindings(UserContext, (struct _SecPkgContext_Bindings *)a3);
        case 0x23u:
          return (unsigned int)SpQueryApplicationProtocol(UserContext, (struct _SecPkgContext_ApplicationProtocol *)a3);
      }
    }
    else
    {
      switch ( a2 )
      {
        case 7u:
          return (unsigned int)SpQueryProtoInfo(UserContext, a3);
        case 0u:
          return (unsigned int)SpQuerySizes(UserContext, (struct _SecPkgContext_Sizes *)a3);
        case 1u:
          return SpQueryNames(UserContext, (struct _SecPkgContext_NamesW *)a3);
        case 2u:
          return (unsigned int)SpQueryLifespan(UserContext, (struct _SecPkgContext_Lifespan *)a3);
        case 4u:
          return (unsigned int)SpQueryStreamSizes(UserContext, (struct _SecPkgContext_StreamSizes *)a3);
        case 5u:
          return (unsigned int)SpQueryKeyInfo(UserContext, a3);
      }
    }
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    WPP_SF_d(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x14u, (__int64)&WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids, a2);
  return 2148074242i64;
}
// 1800363C3: variable 'v6' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000C2D0) ----------------------------------------------------
__int64 __fastcall SpUnsealMessage(__int64 a1, struct _SecBufferDesc *a2)
{
  struct CSslUserContext *UserContext; // rax
  unsigned int v5; // eax
  unsigned int v6; // ebx
  CCipherMill *v7; // r10
  unsigned int v9; // eax
  __int64 v10; // r10
  __int64 v11; // r10
  int v12; // [rsp+20h] [rbp-18h]

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
  UserContext = SslFindUserContext(a1);
  if ( UserContext )
  {
    if ( *((_DWORD *)UserContext + 2) == 4 || *((_DWORD *)UserContext + 2) == 79 )
    {
      if ( (*((_DWORD *)UserContext + 4) & 0x1000i64) != 0 )
        v5 = SslUnsealMessageConnection(UserContext, a2);
      else
        v5 = SslUnsealMessageStream(UserContext, a2);
      v6 = v5;
      v7 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        v9 = TranslateToSecurityStatus(v5);
        WPP_SF_D(*(_QWORD *)(v10 + 16), 25i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, v9);
        v7 = WPP_GLOBAL_Control;
      }
      if ( v6 == -2146893008 )
      {
        SslUnsealHideDecryptErrorDelay();
        v7 = WPP_GLOBAL_Control;
      }
      if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control
        && ((*((_BYTE *)v7 + 28) & 1) != 0 && (unsigned int)TranslateToSecurityStatus(v6)
         || (*((_BYTE *)v7 + 28) & 4) != 0) )
      {
        v12 = TranslateToSecurityStatus(v6);
        WPP_SF_DD(*(_QWORD *)(v11 + 16), 0x1Au, (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, v12, v12);
      }
      return TranslateToSecurityStatus(v6);
    }
    else
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
        WPP_SF_DD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x18u,
          (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids,
          -2146893033,
          -2146893033);
      return 2148074263i64;
    }
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x17u,
        (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids,
        -2146893055,
        -2146893055);
    return 2148074241i64;
  }
}
// 180036574: variable 'v10' is possibly undefined
// 18000C373: variable 'v7' is possibly undefined
// 1800365BB: variable 'v11' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000C3A8) ----------------------------------------------------
__int64 __fastcall TranslateToSecurityStatus(unsigned int a1)
{
  if ( (a1 & 0x1FFF0000) == 589824 )
  {
    if ( a1 + 2146893823 <= 0x2E )
      return 2148074244i64;
    if ( a1 + 2146889727 > 0x100E && a1 + 2146885612 > 0xFEC && a1 != -2146885615 )
      return a1;
  }
  else if ( !a1 )
  {
    return 0i64;
  }
  if ( a1 > 0x80092004 )
  {
    switch ( a1 )
    {
      case 0x800B0101:
      case 0x800B0102:
        return 2148074280i64;
      case 0x800B0109:
        return 2148074277i64;
      case 0x800B010C:
        return 2148081680i64;
      case 0x800B010F:
        return 2148074274i64;
      default:
        return 2148074244i64;
    }
  }
  else
  {
    switch ( a1 )
    {
      case 0x80092004:
        return 2148074253i64;
      case 0xEu:
        return 2148074240i64;
      case 0x57u:
        return 2148074333i64;
      case 0x78u:
        return 2148074242i64;
      case 0x7Au:
        return 2148074273i64;
      default:
        return 2148074244i64;
    }
  }
}

//----- (000000018000C40C) ----------------------------------------------------
__int64 __fastcall SslUnsealMessageStream(struct CSslUserContext *a1, struct _SecBufferDesc *a2)
{
  struct _SecBuffer *v2; // rdi
  struct _SecBuffer *v3; // rsi
  struct _SecBuffer *v4; // r12
  struct _SecBuffer *v5; // r14
  CCipherMill *v8; // r10
  unsigned int cBuffers; // r11d
  unsigned int v10; // ecx
  PSecBuffer pBuffers; // rdx
  unsigned int *p_BufferType; // r9
  __int64 v13; // r8
  _BYTE *pvBuffer; // rdx
  unsigned int v15; // ecx
  unsigned int v16; // r11d
  int v17; // r9d
  unsigned int v18; // r15d
  int v19; // r8d
  int v20; // eax
  unsigned int v21; // r9d
  unsigned int v22; // eax
  unsigned int v23; // ebx
  unsigned int v25; // eax
  unsigned __int16 v26; // dx
  bool v27; // zf
  int v28; // ecx
  int v29; // eax
  unsigned int v30; // r11d
  __int64 v31; // [rsp+20h] [rbp-30h]
  unsigned int v32; // [rsp+30h] [rbp-20h] BYREF
  unsigned int cbBuffer; // [rsp+34h] [rbp-1Ch]
  unsigned __int8 *v34; // [rsp+38h] [rbp-18h]
  __int128 v35; // [rsp+40h] [rbp-10h] BYREF
  unsigned __int8 v36; // [rsp+98h] [rbp+48h] BYREF
  struct _SecBuffer *v37; // [rsp+A0h] [rbp+50h]

  v2 = 0i64;
  v3 = 0i64;
  v4 = 0i64;
  v5 = 0i64;
  v37 = 0i64;
  v36 = 0;
  v35 = 0i64;
  v8 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 72i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
    v8 = WPP_GLOBAL_Control;
  }
  cBuffers = a2->cBuffers;
  v10 = 0;
  if ( !cBuffers )
    goto LABEL_95;
  pBuffers = a2->pBuffers;
  p_BufferType = &pBuffers->BufferType;
  do
  {
    v13 = *p_BufferType;
    if ( (_DWORD)v13 )
    {
      v13 = (unsigned int)(v13 - 1);
      if ( (_DWORD)v13 )
      {
        if ( (_DWORD)v13 == 16 )
          v37 = &pBuffers[v10];
      }
      else
      {
        v2 = &pBuffers[v10];
      }
    }
    else if ( v3 )
    {
      if ( v4 )
      {
        if ( !v5 )
          v5 = &pBuffers[v10];
      }
      else
      {
        v4 = &pBuffers[v10];
      }
    }
    else
    {
      v3 = &pBuffers[v10];
    }
    ++v10;
    p_BufferType += 4;
  }
  while ( v10 < cBuffers );
  if ( !v2 || !v3 || !v4 || !v5 )
  {
LABEL_95:
    if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 5) == 0 )
      return 2148074248i64;
    v26 = 73;
    goto LABEL_97;
  }
  pvBuffer = v2->pvBuffer;
  if ( !pvBuffer )
  {
    if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 5) == 0 )
      return 2148074248i64;
    v26 = 74;
LABEL_97:
    WPP_SF_DD(
      *((_QWORD *)v8 + 2),
      v26,
      (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
      -2146893048,
      -2146893048);
    return 2148074248i64;
  }
  v15 = *((_DWORD *)a1 + 6);
  v34 = (unsigned __int8 *)v2->pvBuffer;
  cbBuffer = v2->cbBuffer;
  v16 = v2->cbBuffer;
  v32 = v2->cbBuffer;
  if ( v15 > 0x800 )
  {
    if ( v15 == 4096 || v15 == 0x2000 || v15 == 0x10000 || v15 == 0x20000 || v15 == 0x40000 )
      goto LABEL_20;
    v27 = v15 == 0x80000;
  }
  else
  {
    if ( v15 == 2048 || v15 == 16 || v15 == 32 || v15 == 64 || v15 == 128 || v15 == 256 || v15 == 512 )
      goto LABEL_20;
    v27 = v15 == 1024;
  }
  if ( !v27 )
  {
    v23 = -2146893055;
    goto LABEL_34;
  }
LABEL_20:
  v17 = *((_DWORD *)a1 + 17);
  v18 = v17 + *((_DWORD *)a1 + 16);
  if ( v16 < v18 )
  {
    if ( (v15 & 0x50000) != 0 && !*((_BYTE *)a1 + 140) )
    {
      if ( pvBuffer[1] == 0xFE && ((unsigned __int8)pvBuffer[2] | ((unsigned __int8)pvBuffer[1] << 8)) <= 0xFEFFu )
      {
        v28 = (unsigned __int8)pvBuffer[11];
        v29 = (unsigned __int8)pvBuffer[12];
      }
      else
      {
        v28 = (unsigned __int8)pvBuffer[3];
        v29 = (unsigned __int8)pvBuffer[4];
      }
      if ( v17 + (v29 | (unsigned int)(v28 << 8)) < v18
        && *pvBuffer == 20
        && ((unsigned __int8)pvBuffer[4] | ((unsigned __int8)pvBuffer[3] << 8)) < *((_DWORD *)a1 + 29) )
      {
        v23 = -2146893005;
        goto LABEL_34;
      }
    }
    cbBuffer = v17 + *((_DWORD *)a1 + 16);
    goto LABEL_44;
  }
  if ( pvBuffer[1] == 0xFE && ((unsigned __int8)pvBuffer[2] | ((unsigned __int8)pvBuffer[1] << 8)) <= 0xFEFFu )
  {
    v19 = (unsigned __int8)pvBuffer[11];
    v20 = (unsigned __int8)pvBuffer[12];
  }
  else
  {
    v19 = (unsigned __int8)pvBuffer[3];
    v20 = (unsigned __int8)pvBuffer[4];
  }
  v13 = v20 | (unsigned int)(v19 << 8);
  v21 = v13 + v17;
  if ( v21 < v18 )
  {
    v23 = -2146893048;
    v36 = 50;
    goto LABEL_34;
  }
  LODWORD(v35) = v16;
  *((_QWORD *)&v35 + 1) = &pvBuffer[v18];
  DWORD1(v35) = v21 - v18;
  if ( v16 < v21 )
  {
    cbBuffer = v21;
LABEL_44:
    v23 = -2146893032;
    goto LABEL_45;
  }
  if ( (v15 & 0x3000) != 0 )
    v22 = Tls13DecryptHandler(a1, (struct SPBuffer *)&v32, (struct SPBuffer *)&v35, &v36);
  else
    v22 = TlsDecryptHandler(a1, (struct SPBuffer *)&v32, (struct SPBuffer *)&v35, &v36);
  v23 = v22;
  if ( (*((_DWORD *)a1 + 6) & 0xF0000) != 0 )
  {
    if ( !v22 )
    {
      if ( !CSslUserContext::DTLSCheckRecordValidity(
              a1,
              v34[10] | ((v34[9] | ((v34[8] | ((v34[7] | ((v34[6] | ((v34[5] | ((v34[4] | ((unsigned __int64)v34[3] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) )
      {
        v8 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 76i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v30);
          v8 = WPP_GLOBAL_Control;
        }
        v23 = -2146893040;
        goto LABEL_34;
      }
      goto LABEL_30;
    }
  }
  else if ( !v22 )
  {
LABEL_30:
    if ( cbBuffer < v2->cbBuffer )
    {
      v5->BufferType = 5;
      v5->cbBuffer = v2->cbBuffer - cbBuffer;
      v5->pvBuffer = (char *)v2->pvBuffer + cbBuffer;
    }
    v2->BufferType = 7;
    v2->cbBuffer = v18;
    v3->BufferType = 1;
    v3->pvBuffer = (void *)*((_QWORD *)&v35 + 1);
    v3->cbBuffer = DWORD1(v35);
    v4->BufferType = 6;
    v4->pvBuffer = (char *)v3->pvBuffer + DWORD1(v35);
    v4->cbBuffer = v32 - DWORD1(v35) - v18;
    goto LABEL_33;
  }
  if ( v22 == 590625 )
    goto LABEL_30;
  if ( v22 == -2146893032 )
  {
LABEL_45:
    v3->BufferType = 4;
    v25 = cbBuffer - v2->cbBuffer;
    v3->cbBuffer = v25;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_ddd(*((_QWORD *)WPP_GLOBAL_Control + 2), (__int64)pvBuffer, v13, v2->cbBuffer, cbBuffer, v25);
    v2->BufferType = 4;
    v2->cbBuffer = cbBuffer - v2->cbBuffer;
    v8 = WPP_GLOBAL_Control;
    goto LABEL_34;
  }
LABEL_33:
  v8 = WPP_GLOBAL_Control;
LABEL_34:
  if ( v37 )
  {
    GenerateUserFatalAlertMessage(a1, (__int64)v37, v36);
    v8 = WPP_GLOBAL_Control;
  }
  if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)v8 + 28) & 1) != 0 && v23 || (*((_BYTE *)v8 + 28) & 4) != 0) )
  {
    LODWORD(v31) = v23;
    WPP_SF_DD(*((_QWORD *)v8 + 2), 0x52u, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v23, v31);
  }
  return v23;
}
// 1800368C6: variable 'pvBuffer' is possibly undefined
// 1800368C6: variable 'v13' is possibly undefined
// 180036894: variable 'v30' is possibly undefined
// 180036908: variable 'v31' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000C710) ----------------------------------------------------
struct CSslUserContext *__fastcall SslFindUserContext(__int64 a1)
{
  struct CSslUserContext *v2; // rax
  struct CSslUserContext *v3; // rbx

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_ba773d91511536867a821af0ee22c47a_Traceguids);
  v2 = SslReferenceUserContext(a1, 0);
  v3 = v2;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x17u, (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids, v2);
  return v3;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000C774) ----------------------------------------------------
struct CSslUserContext *__fastcall SslReferenceUserContext(__int64 a1, unsigned __int8 a2)
{
  int v2; // r14d
  _QWORD *v4; // rbx
  CCipherMill *v5; // r10
  unsigned int v6; // ebp
  __int64 v7; // rdi
  __int64 v8; // rdi
  struct _RTL_RESOURCE *v9; // rcx
  _QWORD **v10; // rdx
  _QWORD *v11; // rax
  CCipherMill *v12; // rcx
  __int64 v14; // rcx
  _QWORD *v15; // rdx
  __int64 v16; // [rsp+20h] [rbp-28h]

  v2 = a2;
  v4 = 0i64;
  v5 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 16i64, &WPP_ba773d91511536867a821af0ee22c47a_Traceguids);
    v5 = WPP_GLOBAL_Control;
  }
  v6 = (dwSslContextListCount - 1) & (BYTE3(a1)
                                    + a1
                                    + WORD1(a1)
                                    + ((unsigned int)a1 >> 8)
                                    + ((BYTE3(a1) + (_DWORD)a1 + WORD1(a1) + ((unsigned int)a1 >> 8)) >> 4));
  v7 = v6 & (dwSslContextLockCount - 1);
  if ( v5 != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)v5 + 28) & 4) != 0 )
    {
      WPP_SF_qd(*((_QWORD *)v5 + 2), 0x11u, (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids, a1, v2);
      v5 = WPP_GLOBAL_Control;
    }
    if ( v5 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v5 + 28) & 4) != 0 )
    {
      LODWORD(v16) = v7;
      WPP_SF_dd(*((_QWORD *)v5 + 2), 0x12u, (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids, v6, v16);
    }
  }
  v8 = 96 * v7;
  v9 = (struct _RTL_RESOURCE *)((char *)SslContextLock + v8);
  if ( (_BYTE)v2 )
    RtlAcquireResourceExclusive(v9, 1u);
  else
    RtlAcquireResourceShared(v9, 1u);
  v10 = (_QWORD **)((char *)SslContextList + 16 * v6);
  v11 = *v10;
  while ( v11 != v10 )
  {
    v4 = v11 - 38;
    if ( *(v11 - 2) == a1 )
    {
      if ( (_BYTE)v2 )
      {
        v14 = *v11;
        if ( *(_QWORD **)(*v11 + 8i64) != v11 || (v15 = (_QWORD *)v11[1], (_QWORD *)*v15 != v11) )
          __fastfail(3u);
        *v15 = v14;
        *(_QWORD *)(v14 + 8) = v15;
      }
      break;
    }
    v11 = (_QWORD *)*v11;
    v4 = 0i64;
  }
  RtlReleaseResource((PRTL_RESOURCE)((char *)SslContextLock + v8));
  v12 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_q(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x13u,
        (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids,
        v4);
      v12 = WPP_GLOBAL_Control;
    }
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v12 + 28) & 4) != 0 )
      {
        WPP_SF_qq(*((_QWORD *)v12 + 2), 0x14u, (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids, a1, v4);
        v12 = WPP_GLOBAL_Control;
      }
      if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
        WPP_SF_q(*((_QWORD *)v12 + 2), 0x15u, (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids, v4);
    }
  }
  return (struct CSslUserContext *)v4;
}
// 1800369DF: variable 'v16' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800919E0: using guessed type unsigned int dwSslContextListCount;
// 1800919E4: using guessed type unsigned int dwSslContextLockCount;

//----- (000000018000C91C) ----------------------------------------------------
__int64 __fastcall TlsDecryptHandler(
        struct CSslUserContext *a1,
        struct SPBuffer *a2,
        struct SPBuffer *a3,
        unsigned __int8 *a4)
{
  int v4; // eax
  int v5; // r14d
  unsigned __int8 *v10; // r8
  int v11; // edx
  bool v12; // zf
  int v13; // ecx
  unsigned int v14; // ebp
  int v15; // ecx
  int v16; // ecx
  CCipherMill *v17; // rcx
  unsigned int v18; // eax
  CCipherMill *v19; // rcx
  unsigned __int64 v21; // r14
  unsigned int v22; // eax
  unsigned int v23; // r15d
  int v24; // eax
  unsigned int v25; // esi
  CCipherMill *v26; // rcx
  unsigned __int16 v27; // dx
  unsigned __int16 v28; // dx
  CCipherMill *v29; // r10
  int v30; // r14d
  int v31; // r8d
  unsigned int v32; // eax
  unsigned int v33; // r12d
  CCipherMill *v34; // rcx
  unsigned int v35; // r12d
  unsigned __int8 *v36; // r8
  unsigned __int64 v37; // r14
  unsigned int v38; // eax
  unsigned int v39; // r15d
  CCipherMill *v40; // rcx
  CCipherMill *v41; // rcx
  unsigned __int16 v42; // dx
  _BYTE *v43; // rax
  unsigned __int8 *v44; // rcx
  unsigned __int64 v45; // rbp
  __int64 v46; // rcx
  int v47; // r9d
  _BYTE *v48; // r14
  unsigned int v49; // eax
  unsigned int v50; // ebp
  CCipherMill *v51; // rcx
  unsigned __int64 *v52; // [rsp+20h] [rbp-78h]
  struct SPBuffer *v53; // [rsp+28h] [rbp-70h]
  unsigned int v54; // [rsp+28h] [rbp-70h]
  struct SPBuffer *v55; // [rsp+30h] [rbp-68h]
  unsigned __int8 *v56; // [rsp+38h] [rbp-60h]
  unsigned __int8 *v57; // [rsp+38h] [rbp-60h]
  __int64 v58; // [rsp+40h] [rbp-58h]
  unsigned int v59; // [rsp+50h] [rbp-48h] BYREF
  unsigned int v60; // [rsp+54h] [rbp-44h] BYREF
  int v61; // [rsp+58h] [rbp-40h]
  unsigned int v62; // [rsp+A0h] [rbp+8h] BYREF
  int v63; // [rsp+A8h] [rbp+10h]
  unsigned __int8 *v64; // [rsp+B8h] [rbp+20h]

  v64 = a4;
  v4 = 4;
  v5 = *((_DWORD *)a1 + 17) + *((_DWORD *)a1 + 16);
  v61 = v5;
  v10 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
  v11 = *((_DWORD *)a1 + 6) & 0xF0000;
  v62 = v11;
  if ( v11 )
    v4 = 12;
  v12 = *((_DWORD *)a1 + 2) == 4;
  v63 = v4;
  if ( !v12 )
  {
    v26 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
      return 2148074248i64;
    v27 = 34;
    goto LABEL_102;
  }
  v13 = *v10;
  if ( ((v13 - 20) & 0xFFFFFFFC) == 0 && v13 != 21 )
    *((_BYTE *)a1 + 112) = 0;
  v14 = -2146893008;
  v15 = v13 - 21;
  if ( v15 )
  {
    v16 = v15 - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        v17 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 35i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            v17 = WPP_GLOBAL_Control;
          }
          if ( v17 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v17 + 28) & 4) != 0 )
            WPP_SF_(*((_QWORD *)v17 + 2), 36i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
        }
        v18 = TlsDecryptMessage(
                *((_QWORD *)a1 + 11),
                *((_QWORD *)a1 + 5),
                v5 - *((_DWORD *)a1 + 17),
                *((_DWORD *)a1 + 17),
                (unsigned __int64 *)a1 + 12,
                a2,
                a3,
                a4);
        v14 = v18;
        v19 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 37i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v18);
            v19 = WPP_GLOBAL_Control;
          }
          if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v19 + 28) & 4) != 0 )
          {
            WPP_SF_i(
              *((_QWORD *)v19 + 2),
              0x26u,
              (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
              *((_QWORD *)a1 + 12));
            v19 = WPP_GLOBAL_Control;
          }
        }
        if ( v62 && !*((_BYTE *)a1 + 140) )
        {
          *((_BYTE *)a1 + 140) = 1;
          v19 = WPP_GLOBAL_Control;
        }
        if ( v19 == (CCipherMill *)&WPP_GLOBAL_Control
          || ((*((_BYTE *)v19 + 28) & 1) == 0 || !v14) && (*((_BYTE *)v19 + 28) & 4) == 0 )
        {
          return v14;
        }
        v28 = 39;
LABEL_56:
        LODWORD(v52) = v14;
        WPP_SF_DD(*((_QWORD *)v19 + 2), v28, (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v14, v52);
        return v14;
      }
      v26 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 62i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
        v26 = WPP_GLOBAL_Control;
      }
      *a4 = 10;
      if ( v26 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v26 + 28) & 5) == 0 )
        return 2148074248i64;
      v27 = 63;
      goto LABEL_102;
    }
    v29 = WPP_GLOBAL_Control;
    v30 = 40;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 40i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
      v29 = WPP_GLOBAL_Control;
      v11 = v62;
    }
    v31 = *((_DWORD *)a1 + 6);
    if ( (v31 & 0x800A2AAA) != 0 )
    {
      v32 = QueryStreamSizes(*((_QWORD *)a1 + 11), *((_DWORD *)a1 + 14), v31, *((_DWORD *)a1 + 15), 0i64, &v60, &v59);
      v33 = v32;
      if ( v32 )
      {
        v34 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 41i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v32);
            v34 = WPP_GLOBAL_Control;
          }
          if ( v34 != (CCipherMill *)&WPP_GLOBAL_Control
            && ((*((_BYTE *)v34 + 28) & 1) != 0 || (*((_BYTE *)v34 + 28) & 4) != 0) )
          {
            LODWORD(v52) = v33;
            WPP_SF_DD(*((_QWORD *)v34 + 2), 0x2Au, (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v33, v52);
          }
        }
        return v33;
      }
      if ( *(_DWORD *)a2 > v61 + v63 + v59 + v60 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 43i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
        goto LABEL_142;
      }
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 44i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
      v35 = v62;
      v36 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
      if ( v62 )
        v37 = v36[10] | ((v36[9] | ((v36[8] | ((v36[7] | ((v36[6] | ((v36[5] | ((v36[4] | ((unsigned __int64)v36[3] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      else
        v37 = *((_QWORD *)a1 + 12);
      LODWORD(v58) = 0;
      v56 = (unsigned __int8 *)v37;
      v55 = (struct SPBuffer *)((char *)a3 + 4);
      LODWORD(v53) = *(_DWORD *)a3;
      v52 = (unsigned __int64 *)*((_QWORD *)a3 + 1);
      v38 = SslDecryptPacket(*((_QWORD *)a1 + 11), *((_QWORD *)a1 + 5), v36);
      v39 = v38;
      v40 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 45i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v38);
          v40 = WPP_GLOBAL_Control;
        }
        if ( v40 != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)v40 + 28) & 4) != 0 )
          {
            WPP_SF_D(
              *((_QWORD *)v40 + 2),
              46i64,
              &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
              *((unsigned int *)a3 + 1));
            v40 = WPP_GLOBAL_Control;
          }
          if ( v40 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v40 + 28) & 4) != 0 )
            WPP_SF_i(
              *((_QWORD *)v40 + 2),
              0x2Fu,
              (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
              *((_QWORD *)a1 + 12),
              v52,
              v53,
              v55,
              v37,
              0);
        }
      }
      if ( v35 )
        *((_QWORD *)a1 + 12) = v37;
      else
        ++*((_QWORD *)a1 + 12);
      if ( !v39 )
      {
        if ( *((_DWORD *)a3 + 1) != v63 || (v43 = (_BYTE *)*((_QWORD *)a3 + 1), *v43) )
        {
          *v64 = 10;
          v26 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
          {
            return 2148074248i64;
          }
          v27 = 49;
LABEL_102:
          LODWORD(v52) = -2146893048;
          WPP_SF_DD(
            *((_QWORD *)v26 + 2),
            v27,
            (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
            -2146893048,
            v52);
          return 2148074248i64;
        }
        v30 = 76;
        *((_DWORD *)a1 + 36) = (unsigned __int8)v43[5] + 1 + ((unsigned __int8)v43[4] << 8);
LABEL_143:
        *((_DWORD *)a1 + 2) = v30;
        *((_DWORD *)a3 + 1) = 0;
        v19 = WPP_GLOBAL_Control;
        v14 = 590625;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
          return v14;
        v28 = 57;
        goto LABEL_56;
      }
      *v64 = 20;
      v41 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
        return v14;
      v42 = 48;
      goto LABEL_109;
    }
    if ( !v11 )
    {
      v30 = 76;
LABEL_142:
      *((_DWORD *)a2 + 1) = 0;
      goto LABEL_143;
    }
    v44 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
    v45 = v44[10] | ((v44[9] | ((v44[8] | ((v44[7] | ((v44[6] | ((v44[5] | ((v44[4] | ((unsigned __int64)v44[3] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
    if ( HIWORD(v45) < (unsigned int)*((int *)a1 + 29) )
    {
      v14 = -2146893005;
      if ( v29 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v29 + 28) & 5) == 0 )
        return v14;
      v46 = *((_QWORD *)v29 + 2);
      v42 = 50;
      v47 = -2146893005;
      goto LABEL_110;
    }
    v62 = *((_DWORD *)a2 + 1);
    v48 = LocalAlloc(0x40u, v62);
    if ( !v48 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
        WPP_SF_DD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x33u,
          (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
          -2146893056,
          -2146893056);
      return 2148074240i64;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 52i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
    v57 = (unsigned __int8 *)v45;
    v54 = v62;
    HIDWORD(v52) = HIDWORD(v48);
    v49 = SslDecryptPacket(*((_QWORD *)a1 + 11), *((_QWORD *)a1 + 5), *((_QWORD *)a2 + 1));
    v50 = v49;
    v51 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 53i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v49);
        v51 = WPP_GLOBAL_Control;
      }
      if ( v51 != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)v51 + 28) & 4) != 0 )
        {
          WPP_SF_D(
            *((_QWORD *)v51 + 2),
            54i64,
            &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
            *((unsigned int *)a3 + 1));
          v51 = WPP_GLOBAL_Control;
        }
        if ( v51 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v51 + 28) & 4) != 0 )
          WPP_SF_i(
            *((_QWORD *)v51 + 2),
            0x37u,
            (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
            *((_QWORD *)a1 + 12),
            v48,
            v54,
            &v62,
            v57,
            0);
      }
    }
    if ( v50 )
    {
      *a4 = 20;
      v14 = -2146893008;
      goto LABEL_137;
    }
    if ( v62 >= 0xC )
    {
      if ( !*((_BYTE *)a1 + 140) )
      {
        if ( *v48 != 1 )
        {
          v14 = -2146893005;
          goto LABEL_137;
        }
        goto LABEL_135;
      }
      if ( *v48 == 1 )
      {
LABEL_135:
        v14 = 590625;
        *((_DWORD *)a1 + 36) = (unsigned __int8)v48[5] + ((unsigned __int8)v48[4] << 8);
        goto LABEL_137;
      }
    }
    v14 = -2146893048;
    *a4 = 10;
LABEL_137:
    LocalFree(v48);
    *((_DWORD *)a3 + 1) = 0;
    *((_DWORD *)a2 + 1) = 0;
    v19 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
      || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
    {
      return v14;
    }
    v28 = 56;
    goto LABEL_56;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 58i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
    v10 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
  }
  if ( (*((_DWORD *)a1 + 6) & 0xF0000) != 0 )
    v21 = v10[10] | ((v10[9] | ((v10[8] | ((v10[7] | ((v10[6] | ((v10[5] | ((v10[4] | ((unsigned __int64)v10[3] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
  else
    v21 = *((_QWORD *)a1 + 12);
  LODWORD(v58) = 0;
  v56 = (unsigned __int8 *)v21;
  v55 = (struct SPBuffer *)((char *)a3 + 4);
  LODWORD(v53) = *(_DWORD *)a3;
  v52 = (unsigned __int64 *)*((_QWORD *)a3 + 1);
  v22 = SslDecryptPacket(*((_QWORD *)a1 + 11), *((_QWORD *)a1 + 5), v10);
  v23 = v22;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 59i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v22);
  if ( (*((_DWORD *)a1 + 6) & 0xF0000) != 0 )
    *((_QWORD *)a1 + 12) = v21;
  else
    ++*((_QWORD *)a1 + 12);
  if ( v23 )
  {
    *a4 = 20;
    v41 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
      return v14;
    v42 = 60;
LABEL_109:
    v46 = *((_QWORD *)v41 + 2);
    v47 = -2146893008;
LABEL_110:
    LODWORD(v52) = v14;
    WPP_SF_Dd(v46, v42, (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v47, v52, v53, v55, v56, v58);
    return v14;
  }
  v24 = TlsParseAlertMessage(*((unsigned __int8 **)a3 + 1), *((_DWORD *)a3 + 1), (unsigned __int8 *)a1 + 112, 0i64);
  *((_DWORD *)a3 + 1) = 0;
  v25 = v24;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v24 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    LODWORD(v52) = v24;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x3Du,
      (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
      v24,
      v52,
      (_DWORD)v53,
      v55,
      v21,
      0);
  }
  return v25;
}
// 180036B8D: variable 'v52' is possibly undefined
// 180036E06: variable 'v53' is possibly undefined
// 180036F74: variable 'v55' is possibly undefined
// 180036F74: variable 'v56' is possibly undefined
// 180036F74: variable 'v58' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800984E0: using guessed type __int64 __fastcall SslDecryptPacket(_QWORD, _QWORD, _QWORD);

//----- (000000018000CB70) ----------------------------------------------------
__int64 __fastcall TlsDecryptMessage(
        __int64 a1,
        __int64 a2,
        int a3,
        int a4,
        unsigned __int64 *a5,
        struct SPBuffer *a6,
        struct SPBuffer *a7,
        unsigned __int8 *a8)
{
  int v9; // r14d
  CCipherMill *v12; // rcx
  unsigned __int8 *v13; // r8
  unsigned int v14; // edi
  int v15; // edx
  int v16; // eax
  unsigned __int8 *v17; // r10
  int v18; // r9d
  unsigned int v19; // edx
  unsigned __int8 *v20; // rax
  unsigned int v21; // eax
  unsigned int v22; // ebx
  __int64 v24; // [rsp+20h] [rbp-68h]
  unsigned int Size; // [rsp+54h] [rbp-34h]
  unsigned __int8 *Size_4; // [rsp+58h] [rbp-30h]

  v9 = a3 + a4;
  v12 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 64i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
    v12 = WPP_GLOBAL_Control;
  }
  v13 = (unsigned __int8 *)*((_QWORD *)a6 + 1);
  *((_DWORD *)a6 + 1) = a4;
  v14 = v13[2] | (v13[1] << 8);
  if ( v14 - 768 > 3 && v14 != 65277 && v14 != 65279 )
  {
    v22 = -2146893048;
    *a8 = 70;
    goto LABEL_21;
  }
  if ( BYTE1(v14) == 0xFE && v14 <= 0xFEFF )
  {
    v15 = v13[11];
    v16 = v13[12];
  }
  else
  {
    v15 = v13[3];
    v16 = v13[4];
  }
  v17 = &v13[v9];
  Size_4 = v17;
  v18 = (v16 | (v15 << 8)) + a4;
  v19 = *(_DWORD *)a6 - v9;
  *((_DWORD *)a6 + 1) = v18;
  Size = v19;
  v20 = v13;
  if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)v12 + 2), 65i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
    v13 = (unsigned __int8 *)*((_QWORD *)a6 + 1);
    v20 = v13;
    HIDWORD(v17) = HIDWORD(Size_4);
  }
  if ( BYTE1(v14) != 0xFE || v14 > 0xFEFF )
    v13 = v20;
  HIDWORD(v24) = HIDWORD(v17);
  v21 = SslDecryptPacket(a1, a2, v13);
  v22 = v21;
  v12 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 66i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v21);
    v12 = WPP_GLOBAL_Control;
  }
  if ( v22 )
  {
    if ( v12 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v12 + 28) & 1) == 0 )
      goto LABEL_38;
    WPP_SF_D(*((_QWORD *)v12 + 2), 67i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v22);
    goto LABEL_37;
  }
  if ( BYTE1(v14) != 0xFE || v14 > 0xFEFF )
  {
    ++*a5;
    v12 = WPP_GLOBAL_Control;
  }
  if ( *((unsigned __int8 **)a7 + 1) == Size_4 )
    goto LABEL_20;
  if ( *(_DWORD *)a7 >= Size )
  {
    memcpy_0(*((void **)a7 + 1), Size_4, Size);
LABEL_20:
    *((_DWORD *)a7 + 1) = Size;
    v12 = WPP_GLOBAL_Control;
    goto LABEL_21;
  }
  if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 1) != 0 )
  {
    WPP_SF_(*((_QWORD *)v12 + 2), 68i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
LABEL_37:
    v12 = WPP_GLOBAL_Control;
  }
LABEL_38:
  v22 = -2146893008;
  *a8 = 20;
LABEL_21:
  if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)v12 + 28) & 4) != 0 )
    {
      WPP_SF_D(*((_QWORD *)v12 + 2), 69i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v22);
      v12 = WPP_GLOBAL_Control;
    }
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control
      && ((*((_BYTE *)v12 + 28) & 1) != 0 && v22 || (*((_BYTE *)v12 + 28) & 4) != 0) )
    {
      LODWORD(v24) = v22;
      WPP_SF_DD(*((_QWORD *)v12 + 2), 0x46u, (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v22, v24);
    }
  }
  return v22;
}
// 18003743D: variable 'v24' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800984E0: using guessed type __int64 __fastcall SslDecryptPacket(_QWORD, _QWORD, _QWORD);

//----- (000000018000CD3C) ----------------------------------------------------
__int64 __fastcall SslSealMessageStream(struct CSslUserContext *a1, int a2, struct _SecBufferDesc *a3)
{
  struct _SecBuffer *v3; // rdi
  struct _SecBuffer *v4; // rsi
  struct _SecBuffer *v5; // r15
  CCipherMill *v9; // r10
  unsigned int cBuffers; // r11d
  unsigned int v11; // edx
  PSecBuffer pBuffers; // r8
  unsigned int *p_BufferType; // r9
  unsigned __int8 *pvBuffer; // rbx
  __int64 cbBuffer; // rdx
  __int64 v16; // r8
  BOOL v17; // r9d
  unsigned int v18; // r12d
  unsigned int v19; // ecx
  unsigned int v20; // edx
  int v21; // r8d
  bool v22; // zf
  __int64 v23; // rdx
  unsigned __int8 *v24; // r13
  unsigned int v25; // ebx
  unsigned int KeyUpdateRecord; // ebx
  unsigned int v27; // ecx
  unsigned __int64 v28; // rdx
  unsigned int v29; // ecx
  unsigned int v30; // eax
  unsigned int v31; // ecx
  unsigned int v32; // eax
  unsigned int v33; // ecx
  CCipherMill *v34; // rcx
  unsigned __int16 v36; // dx
  unsigned int v37; // edx
  char *v38; // rax
  char *v39; // rcx
  __int64 v40; // rax
  size_t v41; // r8
  void *v42; // rdx
  __int64 v43; // rdx
  _BYTE *v44; // r13
  unsigned int v45; // ebx
  CCipherMill *v46; // rcx
  __int64 v47; // rbx
  unsigned int v48; // eax
  __int64 v49; // rdx
  __int64 v50; // r9
  __int64 v51; // rcx
  unsigned __int8 v52; // cl
  __int64 v53; // rax
  char v54; // r8
  unsigned int v55; // edx
  const wchar_t *v56; // r9
  char *v57; // r14
  __int64 v58; // [rsp+20h] [rbp-49h]
  BOOL v59; // [rsp+50h] [rbp-19h]
  __int64 v60; // [rsp+58h] [rbp-11h] BYREF
  unsigned __int8 *v61; // [rsp+60h] [rbp-9h]
  void *Src; // [rsp+68h] [rbp-1h]
  unsigned int v63; // [rsp+70h] [rbp+7h]
  unsigned int v64; // [rsp+74h] [rbp+Bh] BYREF
  char *v65; // [rsp+78h] [rbp+Fh]
  __int128 v66[4]; // [rsp+80h] [rbp+17h] BYREF
  unsigned int v67; // [rsp+E0h] [rbp+77h]
  int v68; // [rsp+E8h] [rbp+7Fh]

  v3 = 0i64;
  v4 = 0i64;
  Src = 0i64;
  v5 = 0i64;
  v63 = 0;
  v68 = 23;
  LODWORD(v60) = 23;
  v66[0] = 0i64;
  v9 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
    v9 = WPP_GLOBAL_Control;
  }
  cBuffers = a3->cBuffers;
  v11 = 0;
  if ( !cBuffers )
    goto LABEL_181;
  pBuffers = a3->pBuffers;
  p_BufferType = &pBuffers->BufferType;
  do
  {
    switch ( *p_BufferType )
    {
      case 1u:
        v5 = &pBuffers[v11];
        if ( !v3 )
          v3 = &pBuffers[v11];
        break;
      case 2u:
        if ( !v3 )
          goto LABEL_9;
        if ( !v4 )
LABEL_76:
          v4 = &pBuffers[v11];
        break;
      case 6u:
        goto LABEL_76;
      case 7u:
LABEL_9:
        v3 = &pBuffers[v11];
        break;
    }
    ++v11;
    p_BufferType += 4;
  }
  while ( v11 < cBuffers );
  if ( !v3 || !v5 )
  {
LABEL_181:
    if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)v9 + 2),
        0xEu,
        (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
        -2146893048,
        -2146893048);
    return 2148074248i64;
  }
  pvBuffer = (unsigned __int8 *)v5->pvBuffer;
  cbBuffer = v3->cbBuffer;
  v16 = (__int64)v3->pvBuffer;
  v61 = pvBuffer;
  v17 = pvBuffer != (unsigned __int8 *)(v16 + cbBuffer);
  v59 = v17;
  if ( v4 )
  {
    if ( v4->pvBuffer != &pvBuffer[v5->cbBuffer] )
      v17 = 1;
    v59 = v17;
  }
  v18 = v5->cbBuffer;
  v19 = v5->cbBuffer + cbBuffer;
  if ( v19 < (unsigned int)cbBuffer )
  {
    if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 5) != 0 )
    {
      v36 = 18;
      goto LABEL_91;
    }
    return 2148074333i64;
  }
  if ( !v17 )
  {
    v64 = 0;
    v65 = (char *)v16;
    v20 = v3->cbBuffer + v5->cbBuffer;
    v67 = v18;
    v63 = v20;
    if ( !v4 )
      goto LABEL_22;
    if ( v20 + v4->cbBuffer >= v20 )
    {
      v63 = v20 + v4->cbBuffer;
      v67 = v18 + v4->cbBuffer;
      goto LABEL_22;
    }
    if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 5) != 0 )
    {
      v36 = 19;
      goto LABEL_91;
    }
    return 2148074333i64;
  }
  v63 = v5->cbBuffer + cbBuffer;
  if ( !v4 )
  {
LABEL_94:
    v38 = (char *)LocalAlloc(0x40u, v19);
    Src = v38;
    v39 = v38;
    if ( !v38 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
        WPP_SF_DD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x15u,
          (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
          -2146893056,
          -2146893056);
      return 2148074240i64;
    }
    v64 = 0;
    v65 = v38;
    v40 = v3->cbBuffer;
    v41 = v5->cbBuffer;
    v42 = v5->pvBuffer;
    v18 = v5->cbBuffer;
    pvBuffer = (unsigned __int8 *)&v39[v40];
    v61 = (unsigned __int8 *)&v39[v40];
    v67 = v63 - v40;
    memcpy_0(&v39[v40], v42, v41);
    v9 = WPP_GLOBAL_Control;
LABEL_22:
    if ( a2 == 0x40000000 )
    {
      KeyUpdateRecord = HandleSpecialMessage(a1, pvBuffer, v18, (enum eTlsRecordType *)&v60);
      if ( KeyUpdateRecord )
      {
        v34 = WPP_GLOBAL_Control;
LABEL_167:
        if ( !v59 )
        {
LABEL_68:
          if ( v34 != (CCipherMill *)&WPP_GLOBAL_Control
            && ((*((_BYTE *)v34 + 28) & 1) != 0 && KeyUpdateRecord || (*((_BYTE *)v34 + 28) & 4) != 0) )
          {
            LODWORD(v58) = KeyUpdateRecord;
            WPP_SF_DD(
              *((_QWORD *)v34 + 2),
              0x31u,
              (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
              KeyUpdateRecord,
              v58);
          }
          return KeyUpdateRecord;
        }
        v57 = (char *)Src;
        goto LABEL_178;
      }
      v21 = v60;
      v9 = WPP_GLOBAL_Control;
      v68 = v60;
    }
    else
    {
      v21 = 23;
    }
    v22 = (*((_DWORD *)a1 + 6) & 0xF0000) == 0;
    v23 = *((_QWORD *)a1 + 13);
    v60 = v23;
    if ( !v22 )
      v60 = ((__int64)*((int *)a1 + 29) << 48) | v23;
    if ( (*((_BYTE *)a1 + 24) & 0x30) == 0 && (*((_BYTE *)a1 + 24) & 0xC0) == 0 )
      goto LABEL_28;
    v43 = *((unsigned int *)a1 + 17);
    if ( v3->cbBuffer <= (unsigned int)(v43 + *((_DWORD *)a1 + 16)) )
    {
      if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)v9 + 2), 31i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
        v9 = WPP_GLOBAL_Control;
LABEL_28:
        v24 = v61;
        v25 = v67;
        goto LABEL_29;
      }
      v25 = v67;
      v24 = v61;
    }
    else if ( v21 == 23 && v18 > 1 )
    {
      v44 = (char *)v3->pvBuffer + (unsigned int)v43;
      v45 = v3->cbBuffer - v43;
      *((_QWORD *)&v66[0] + 1) = v65;
      *(_QWORD *)&v66[0] = v63;
      *v44 = *(_BYTE *)v5->pvBuffer;
      v46 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
          v46 = WPP_GLOBAL_Control;
        }
        if ( v46 != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)v46 + 28) & 4) != 0 )
          {
            WPP_SF_D(*((_QWORD *)v46 + 2), 23i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, 1i64);
            v46 = WPP_GLOBAL_Control;
          }
          if ( v46 != (CCipherMill *)&WPP_GLOBAL_Control )
          {
            if ( (*((_BYTE *)v46 + 28) & 4) != 0 )
            {
              WPP_SF_D(*((_QWORD *)v46 + 2), 24i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v45);
              v46 = WPP_GLOBAL_Control;
            }
            if ( v46 != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_BYTE *)v46 + 28) & 4) != 0 )
              {
                WPP_SF_q(*((_QWORD *)v46 + 2), 0x19u, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v44);
                v46 = WPP_GLOBAL_Control;
              }
              if ( v46 != (CCipherMill *)&WPP_GLOBAL_Control )
              {
                if ( (*((_BYTE *)v46 + 28) & 4) != 0 )
                {
                  WPP_SF_D(
                    *((_QWORD *)v46 + 2),
                    26i64,
                    &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
                    DWORD1(v66[0]));
                  v46 = WPP_GLOBAL_Control;
                }
                if ( v46 != (CCipherMill *)&WPP_GLOBAL_Control )
                {
                  if ( (*((_BYTE *)v46 + 28) & 4) != 0 )
                  {
                    WPP_SF_D(
                      *((_QWORD *)v46 + 2),
                      27i64,
                      &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
                      LODWORD(v66[0]));
                    v46 = WPP_GLOBAL_Control;
                  }
                  if ( v46 != (CCipherMill *)&WPP_GLOBAL_Control )
                  {
                    if ( (*((_BYTE *)v46 + 28) & 4) != 0 )
                    {
                      WPP_SF_q(
                        *((_QWORD *)v46 + 2),
                        0x1Cu,
                        (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
                        *((_QWORD *)&v66[0] + 1));
                      v46 = WPP_GLOBAL_Control;
                    }
                    if ( v46 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v46 + 28) & 4) != 0 )
                      WPP_SF_D(
                        *((_QWORD *)v46 + 2),
                        29i64,
                        &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
                        *((unsigned int *)a1 + 26));
                  }
                }
              }
            }
          }
        }
      }
      v47 = v60;
      v48 = SslEncryptPacket(
              *((_QWORD *)a1 + 11),
              *((_QWORD *)a1 + 6),
              v44,
              1i64,
              *((_QWORD *)&v66[0] + 1),
              v66[0],
              (char *)v66 + 4,
              v60,
              23,
              0);
      if ( v48 )
      {
        v34 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          goto LABEL_166;
        v49 = 30i64;
        v50 = v48;
        goto LABEL_164;
      }
      v51 = DWORD1(v66[0]);
      ++*((_QWORD *)a1 + 13);
      v65 += v51;
      v24 = v61 + 1;
      v9 = WPP_GLOBAL_Control;
      --v18;
      v60 = v47 + 1;
      v25 = v67 - 1;
      v63 -= v51;
    }
    else
    {
      v24 = (unsigned __int8 *)v3->pvBuffer + v43;
      v25 = v63 - v43;
      if ( v18 )
      {
        memmove_0(v24, v5->pvBuffer, v18);
        v9 = WPP_GLOBAL_Control;
      }
    }
LABEL_29:
    if ( (*((_DWORD *)a1 + 6) & 0x3000) != 0 )
    {
      v52 = v68;
      v53 = v18++;
      v68 = 23;
      v24[v53] = v52;
      v9 = WPP_GLOBAL_Control;
    }
    if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)v9 + 2), 32i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
        v9 = WPP_GLOBAL_Control;
      }
      if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
        {
          WPP_SF_D(*((_QWORD *)v9 + 2), 33i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v18);
          v9 = WPP_GLOBAL_Control;
        }
        if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
          {
            WPP_SF_D(*((_QWORD *)v9 + 2), 34i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v25);
            v9 = WPP_GLOBAL_Control;
          }
          if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
          {
            if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
            {
              WPP_SF_q(*((_QWORD *)v9 + 2), 0x23u, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v24);
              v9 = WPP_GLOBAL_Control;
            }
            if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
              {
                WPP_SF_D(*((_QWORD *)v9 + 2), 36i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v64);
                v9 = WPP_GLOBAL_Control;
              }
              if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
              {
                if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
                {
                  WPP_SF_D(*((_QWORD *)v9 + 2), 37i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v63);
                  v9 = WPP_GLOBAL_Control;
                }
                if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
                {
                  if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
                  {
                    WPP_SF_q(*((_QWORD *)v9 + 2), 0x26u, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v65);
                    v9 = WPP_GLOBAL_Control;
                  }
                  if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
                    WPP_SF_D(
                      *((_QWORD *)v9 + 2),
                      39i64,
                      &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
                      *((unsigned int *)a1 + 26));
                }
              }
            }
          }
        }
      }
    }
    KeyUpdateRecord = SslEncryptPacket(*((_QWORD *)a1 + 11), *((_QWORD *)a1 + 6), v24, v18, v65, v63, &v64, v60, v68, 0);
    if ( !KeyUpdateRecord )
    {
      v27 = v64;
      if ( (*((_DWORD *)a1 + 6) & 0xF0000) != 0 && v64 > *((unsigned __int16 *)a1 + 68) )
      {
        v34 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          goto LABEL_166;
        v49 = 41i64;
        v50 = 0i64;
        goto LABEL_164;
      }
      v28 = *((_QWORD *)a1 + 13) + 1i64;
      v22 = (*((_DWORD *)a1 + 6) & 0x3000) == 0;
      *((_QWORD *)a1 + 13) = v28;
      if ( !v22 )
      {
        v54 = *((_BYTE *)a1 + 456);
        if ( v54 || v28 >= *((unsigned int *)a1 + 115) )
        {
          v55 = v63;
          if ( v63 < v27 )
          {
            v34 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
            {
              goto LABEL_166;
            }
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 42i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
LABEL_165:
            v34 = WPP_GLOBAL_Control;
LABEL_166:
            KeyUpdateRecord = -2146893015;
            goto LABEL_167;
          }
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            v56 = L"peer request";
            if ( !v54 )
              v56 = L"write counter";
            WPP_SF_S(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x2Bu,
              (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
              v56);
            v27 = v64;
            v55 = v63;
          }
          *(_QWORD *)&v66[0] = v55 - v27;
          *((_QWORD *)&v66[0] + 1) = &v65[v27];
          KeyUpdateRecord = CSslUserContext::GenerateKeyUpdateRecord(a1, (struct SPBuffer *)v66);
          if ( KeyUpdateRecord )
          {
            v34 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
            {
              goto LABEL_166;
            }
            v49 = 44i64;
            goto LABEL_163;
          }
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 45i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
          }
          v27 = v64;
          *((_BYTE *)a1 + 456) = 0;
        }
      }
      v29 = DWORD1(v66[0]) + v27;
      v30 = v29;
      if ( v29 >= v3->cbBuffer )
        v30 = v3->cbBuffer;
      v31 = v29 - v30;
      v3->cbBuffer = v30;
      if ( v4 )
      {
        v32 = v31;
        if ( v31 >= v5->cbBuffer )
          v32 = v5->cbBuffer;
        v5->cbBuffer = v32;
        v33 = v31 - v32;
        if ( v33 >= v4->cbBuffer )
          v33 = v4->cbBuffer;
        v4->cbBuffer = v33;
      }
      else
      {
        if ( v31 >= v5->cbBuffer )
          v31 = v5->cbBuffer;
        v5->cbBuffer = v31;
      }
      if ( !v59 )
        goto LABEL_67;
      v57 = (char *)Src;
      memcpy_0(v3->pvBuffer, Src, v3->cbBuffer);
      memcpy_0(v5->pvBuffer, &v57[v3->cbBuffer], v5->cbBuffer);
      if ( v4 )
        memcpy_0(v4->pvBuffer, &v57[v5->cbBuffer + v3->cbBuffer], v4->cbBuffer);
LABEL_178:
      LocalFree(v57);
LABEL_67:
      v34 = WPP_GLOBAL_Control;
      goto LABEL_68;
    }
    v34 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      goto LABEL_166;
    v49 = 40i64;
LABEL_163:
    v50 = KeyUpdateRecord;
LABEL_164:
    WPP_SF_D(*((_QWORD *)v34 + 2), v49, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v50);
    goto LABEL_165;
  }
  v37 = v19 + v4->cbBuffer;
  if ( v37 >= v19 )
  {
    v19 += v4->cbBuffer;
    v63 = v37;
    goto LABEL_94;
  }
  if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 5) != 0 )
  {
    v36 = 20;
LABEL_91:
    WPP_SF_DD(
      *((_QWORD *)v9 + 2),
      v36,
      (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
      -2146892963,
      -2146892963);
  }
  return 2148074333i64;
}
// 180037C6F: variable 'v58' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180085398: using guessed type wchar_t aPeerRequest[13];
// 1800853B8: using guessed type wchar_t aWriteCounter[14];
// 180098508: using guessed type __int64 __fastcall SslEncryptPacket(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (000000018000D0A8) ----------------------------------------------------
__int64 __fastcall SpQueryStreamSizes(struct CSslUserContext *a1, struct _SecPkgContext_StreamSizes *a2)
{
  int v4; // ebp
  unsigned int v5; // eax
  unsigned int v6; // edi
  unsigned int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // r10d
  unsigned int v10; // r11d
  __int64 v11; // r8
  __int64 v12; // rdx
  unsigned int v13; // r9d
  unsigned int v14; // eax
  CCipherMill *v15; // rcx
  CCipherMill *v17; // rcx
  unsigned int v18; // eax
  unsigned int v19; // eax
  unsigned int v20; // eax
  unsigned int v21; // eax
  unsigned int v22; // eax
  unsigned int v23; // eax
  bool v24; // zf
  unsigned int *v25; // [rsp+20h] [rbp-48h]
  unsigned int *v26; // [rsp+28h] [rbp-40h]
  unsigned int *v27; // [rsp+30h] [rbp-38h]
  unsigned int v28; // [rsp+70h] [rbp+8h] BYREF
  unsigned int v29; // [rsp+80h] [rbp+18h] BYREF
  unsigned int v30; // [rsp+88h] [rbp+20h] BYREF

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 98i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
  v4 = *((_DWORD *)a1 + 6) & 0xF0000;
  v5 = QueryStreamSizes(
         *((_QWORD *)a1 + 11),
         *((_DWORD *)a1 + 14),
         *((_DWORD *)a1 + 6),
         *((_DWORD *)a1 + 15),
         &v30,
         &v28,
         &v29);
  v6 = v5;
  if ( !v5 )
  {
    a2->cbHeader = 0;
    v7 = *((_DWORD *)a1 + 6);
    v8 = 0;
    if ( v7 > 0x800 )
    {
      if ( v7 == 4096 || v7 == 0x2000 || v7 == 0x10000 || v7 == 0x20000 || v7 == 0x40000 )
        goto LABEL_7;
      v24 = v7 == 0x80000;
    }
    else
    {
      if ( v7 == 2048 )
        goto LABEL_7;
      v18 = v7 - 16;
      if ( !v18 || (v19 = v18 - 16) == 0 || (v20 = v19 - 32) == 0 || (v21 = v20 - 64) == 0 )
      {
        v8 = *((_DWORD *)a1 + 18);
        a2->cbHeader = v8;
        goto LABEL_7;
      }
      v22 = v21 - 128;
      if ( !v22 )
        goto LABEL_7;
      v23 = v22 - 256;
      if ( !v23 )
        goto LABEL_7;
      v24 = v23 == 512;
    }
    if ( !v24 )
    {
      a2->cbTrailer = 0;
      v12 = 0x4000i64;
      v11 = 0i64;
      a2->cbMaximumMessage = 0x4000;
      v13 = 0;
LABEL_11:
      v14 = v30;
      a2->cbBlockSize = v30;
      a2->cBuffers = 4;
      v15 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          LODWORD(v27) = 4;
          LODWORD(v26) = v12;
          LODWORD(v25) = v11;
          WPP_SF_DDDDD(*((_QWORD *)WPP_GLOBAL_Control + 2), v12, v11, v13, v25, v26, v27, v14);
          v15 = WPP_GLOBAL_Control;
        }
        if ( v15 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v15 + 28) & 4) != 0 )
        {
          LODWORD(v25) = 0;
          WPP_SF_DD(*((_QWORD *)v15 + 2), 0x66u, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, 0, v25);
        }
      }
      return 0i64;
    }
LABEL_7:
    v9 = v28;
    v10 = v29;
    v11 = v28 + v29;
    a2->cbTrailer = v11;
    if ( v4 )
      v12 = *((unsigned __int16 *)a1 + 68);
    else
      v12 = 0x4000i64;
    a2->cbMaximumMessage = v12;
    v13 = v8 + *((_DWORD *)a1 + 16) + *((_DWORD *)a1 + 17);
    a2->cbHeader = v13;
    if ( (*((_DWORD *)a1 + 6) & 0x3000) != 0 )
    {
      v11 = v9 + (_DWORD)v11 + v13 + v10 + 7;
      a2->cbTrailer = v11;
    }
    goto LABEL_11;
  }
  v17 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 99i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v5);
      v17 = WPP_GLOBAL_Control;
    }
    if ( v17 != (CCipherMill *)&WPP_GLOBAL_Control
      && ((*((_BYTE *)v17 + 28) & 1) != 0 || (*((_BYTE *)v17 + 28) & 4) != 0) )
    {
      LODWORD(v25) = v6;
      WPP_SF_DD(*((_QWORD *)v17 + 2), 0x64u, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v6, v25);
    }
  }
  return v6;
}
// 180037DF4: variable 'v25' is possibly undefined
// 180037DF4: variable 'v26' is possibly undefined
// 180037DF4: variable 'v27' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000D1CC) ----------------------------------------------------
__int64 __fastcall QueryStreamSizes(
        __int64 a1,
        unsigned int a2,
        int a3,
        unsigned int a4,
        unsigned int *a5,
        unsigned int *a6,
        unsigned int *a7)
{
  __int64 v11; // r13
  __int64 result; // rax
  unsigned int v13; // ecx
  unsigned int v14; // eax
  __int128 v15; // [rsp+40h] [rbp-328h] BYREF
  int v16; // [rsp+50h] [rbp-318h]
  char v17[272]; // [rsp+60h] [rbp-308h] BYREF
  unsigned int v18; // [rsp+170h] [rbp-1F8h]
  unsigned int v19; // [rsp+1F4h] [rbp-174h]

  memset_0(v17, 0, 0x2A4ui64);
  v11 = (unsigned __int16)ConvertSchannelProtocolToSsl(a3);
  result = SslLookupCipherSuiteInfo(a1, v11, a2, a4, v17, 0);
  if ( !(_DWORD)result )
  {
    v13 = v18;
    if ( a5 )
      *a5 = v18;
    if ( a6 )
      *a6 = v19 >> 3;
    if ( a7 )
    {
      v14 = 0;
      if ( v13 > 1 )
        v14 = v13;
      *a7 = v14;
    }
    if ( (a3 & 0x3F00) != 0 )
    {
      v16 = 0;
      v15 = 0i64;
      if ( !(unsigned int)SslLookupCipherLengths(a1, (unsigned int)v11, a2, a4, &v15, 20, 0) )
      {
        if ( a6 )
          *a6 = DWORD2(v15);
        if ( a7 )
          *a7 = HIDWORD(v15);
      }
    }
    return 0i64;
  }
  return result;
}
// 1800984F0: using guessed type __int64 __fastcall SslLookupCipherLengths(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);
// 180098510: using guessed type __int64 __fastcall SslLookupCipherSuiteInfo(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);

//----- (000000018000D31C) ----------------------------------------------------
__int64 __fastcall ConvertSchannelProtocolToSsl(int a1)
{
  __int64 result; // rax

  if ( (a1 & 0x3FFC) != 0 && (a1 & 0xF0000) != 0 )
    return 0i64;
  if ( (a1 & 0xC0000) != 0 )
    return 65277i64;
  if ( (a1 & 0x30000) != 0 )
    return 65279i64;
  if ( (a1 & 0x3000) != 0 )
    return 772i64;
  if ( (a1 & 0xC00) != 0 )
    return 771i64;
  result = 768i64;
  if ( (a1 & 0x300) != 0 )
    return 770i64;
  if ( (a1 & 0xC0) != 0 )
    return 769i64;
  if ( (a1 & 0x30) == 0 )
  {
    if ( (a1 & 0xC) != 0 )
      return 2i64;
    return 0i64;
  }
  return result;
}

//----- (000000018000D37C) ----------------------------------------------------
void __fastcall CSslContext::SetCredentialGroup(CSslContext *this, struct CCredentialGroup *a2)
{
  struct CCredentialGroup *v4; // rdx
  int v5; // eax
  __int64 v6; // rcx

  v4 = (struct CCredentialGroup *)*((_QWORD *)this + 10);
  if ( v4 != a2 )
  {
    if ( v4 )
    {
      CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, v4);
      (*(void (__fastcall **)(CSslContext *, _QWORD))(*(_QWORD *)this + 256i64))(this, 0i64);
    }
    _InterlockedIncrement((volatile signed __int32 *)a2 + 6);
    *((_QWORD *)this + 10) = a2;
    v5 = *((_DWORD *)a2 + 39);
    if ( (v5 & 4) != 0 )
    {
      v6 = *((_QWORD *)this + 17);
      if ( (v6 & 0x100) == 0 )
      {
        *((_QWORD *)this + 17) = v6 | 0x4000;
        v5 = *((_DWORD *)a2 + 39);
      }
    }
    if ( (v5 & 0x4000) != 0 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_c955f13c15ab3d9e41a0e2d56db0bfe4_Traceguids);
      *((_QWORD *)this + 17) |= 0x200000000ui64;
    }
    if ( *((_DWORD *)this + 17) == 91 || *((_DWORD *)this + 17) == 101 )
    {
      if ( *((_BYTE *)this + 266) )
      {
        *((_BYTE *)this + 923) = 1;
        CSsl3TlsClientContext::SetDefCredSearched((__int64)this, 0);
      }
      else
      {
        CSsl3TlsClientContext::CheckForClientCred(this);
      }
    }
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000D410) ----------------------------------------------------
__int64 __fastcall ParseInputBufferDesc(
        struct _SecBufferDesc *a1,
        struct _SecBuffer **a2,
        struct SPBuffer *a3,
        struct _SecBuffer **a4,
        struct _SecBuffer **a5,
        struct _SecBuffer **a6,
        struct _SecBuffer **a7,
        struct _SecBuffer **a8,
        struct _SecBuffer **a9,
        struct _SecBuffer **a10,
        struct _SecBuffer **a11,
        struct _SecBuffer **a12,
        struct _SecBuffer **a13)
{
  unsigned int cBuffers; // r11d
  unsigned int cbBuffer; // r10d
  struct SPBuffer *v15; // rsi
  struct _SecBuffer *v16; // rbx
  struct _SecBuffer *v17; // rdi
  struct _SecBuffer *v18; // rbp
  struct _SecBuffer *v19; // r14
  struct _SecBuffer *v20; // r15
  struct _SecBuffer *v21; // r12
  struct _SecBuffer *v22; // r13
  unsigned int v23; // eax
  PSecBuffer pBuffers; // r9
  unsigned int *p_BufferType; // r8
  int v26; // ecx
  struct _SecBuffer *v28; // [rsp+20h] [rbp-68h]
  struct _SecBuffer *v29; // [rsp+28h] [rbp-60h]
  struct _SecBuffer *v30; // [rsp+30h] [rbp-58h]
  struct _SecBuffer *v31; // [rsp+38h] [rbp-50h]
  struct _SecBuffer *v32; // [rsp+90h] [rbp+8h]

  cBuffers = a1->cBuffers;
  cbBuffer = 0;
  v32 = 0i64;
  v15 = a3;
  v28 = 0i64;
  v16 = 0i64;
  v29 = 0i64;
  v17 = 0i64;
  v30 = 0i64;
  v18 = 0i64;
  v31 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0;
  if ( !cBuffers )
    goto LABEL_22;
  pBuffers = a1->pBuffers;
  p_BufferType = &pBuffers->BufferType;
  do
  {
    v26 = *p_BufferType & 0xFFFFFFF;
    if ( v26 )
    {
      if ( v26 == 2 )
        goto LABEL_12;
      if ( v26 == 18 )
      {
        v19 = &pBuffers[v23];
      }
      else
      {
        switch ( v26 )
        {
          case 3:
            v32 = &pBuffers[v23];
            break;
          case 5:
            v18 = &pBuffers[v23];
            break;
          case 19:
            v20 = &pBuffers[v23];
            break;
          case 20:
            v21 = &pBuffers[v23];
            break;
          case 21:
            v28 = &pBuffers[v23];
            break;
          case 22:
            v22 = &pBuffers[v23];
            break;
          case 23:
            v29 = &pBuffers[v23];
            break;
          case 24:
            v30 = &pBuffers[v23];
            break;
          case 27:
            v31 = &pBuffers[v23];
            break;
          default:
            break;
        }
      }
    }
    else
    {
      if ( !v16 && !v32 && (*p_BufferType & 0x40000000) == 0 )
      {
LABEL_12:
        v16 = &pBuffers[v23];
        goto LABEL_13;
      }
      if ( !v17 )
        v17 = &pBuffers[v23];
    }
LABEL_13:
    ++v23;
    p_BufferType += 4;
  }
  while ( v23 < cBuffers );
  v15 = a3;
  cbBuffer = 0;
  if ( v16 )
    goto LABEL_15;
  if ( v32 )
  {
    v16 = v32;
LABEL_15:
    *((_QWORD *)a3 + 1) = v16->pvBuffer;
    *(_DWORD *)a3 = v16->cbBuffer;
    cbBuffer = v16->cbBuffer;
  }
  else
  {
LABEL_22:
    *((_QWORD *)v15 + 1) = 0i64;
    *(_DWORD *)v15 = 0;
  }
  *((_DWORD *)v15 + 1) = cbBuffer;
  if ( !v17
    && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
  }
  *a2 = v16;
  *a4 = v17;
  *a5 = v18;
  *a6 = v19;
  *a7 = v20;
  *a8 = v21;
  *a9 = v28;
  *a10 = v22;
  *a11 = v29;
  *a12 = v30;
  *a13 = v31;
  return 0i64;
}
// 18000D5F0: conditional instruction was optimized away because rbx.8==0
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000D6A8) ----------------------------------------------------
__int64 __fastcall ParseOutputBufferDesc(
        struct _SecBufferDesc *a1,
        __int16 a2,
        struct _SecBuffer **a3,
        struct SPBuffer *a4,
        struct _SecBuffer **a5,
        struct SPBuffer *a6,
        struct _SecBuffer **a7,
        struct _SecBuffer **a8,
        struct _SecBuffer **a9)
{
  unsigned int cBuffers; // r15d
  unsigned int v11; // ebx
  struct _SecBuffer *v12; // r10
  struct _SecBuffer *v13; // rdi
  struct _SecBuffer *v14; // rsi
  struct _SecBuffer *v15; // r14
  struct _SecBuffer *v16; // r11
  unsigned int v17; // ebp
  PSecBuffer pBuffers; // rcx
  unsigned int *p_BufferType; // r8
  __int64 v20; // rdx
  void *v21; // rax
  __int64 result; // rax
  void *pvBuffer; // rax

  cBuffers = a1->cBuffers;
  v11 = 0;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0;
  if ( !cBuffers )
    goto LABEL_8;
  pBuffers = a1->pBuffers;
  p_BufferType = &pBuffers->BufferType;
  do
  {
    if ( (*p_BufferType & 0xFFFFFFF) != 0 )
    {
      switch ( *p_BufferType & 0xFFFFFFF )
      {
        case 2u:
          goto LABEL_5;
        case 0x11u:
          v13 = &pBuffers[v17];
          break;
        case 0x17u:
          v14 = &pBuffers[v17];
          break;
        case 0x1Au:
          v15 = &pBuffers[v17];
          break;
        case 0x1Bu:
          v16 = &pBuffers[v17];
          break;
      }
    }
    else if ( !v12 && (a2 & 0x100) != 0 )
    {
LABEL_5:
      v12 = &pBuffers[v17];
    }
    ++v17;
    p_BufferType += 4;
  }
  while ( v17 < cBuffers );
  if ( v14 )
  {
    if ( (a2 & 0x100) != 0 )
    {
      v14->pvBuffer = 0i64;
      v14->cbBuffer = 0;
    }
    else if ( !v14->pvBuffer )
    {
      v11 = 14;
    }
  }
LABEL_8:
  *a7 = v14;
  if ( v15 )
  {
    if ( (a2 & 0x100) != 0 )
    {
      v15->pvBuffer = 0i64;
      v15->cbBuffer = 0;
    }
    else if ( !v15->pvBuffer )
    {
      v11 = 14;
    }
  }
  *a8 = v15;
  if ( v16 )
  {
    if ( (a2 & 0x100) != 0 )
    {
      v16->pvBuffer = 0i64;
      v16->cbBuffer = 0;
    }
    else if ( v16->pvBuffer )
    {
      if ( v16->cbBuffer < 8 )
      {
        v16->cbBuffer = 8;
        v11 = -2146893023;
      }
    }
    else
    {
      v11 = 14;
    }
  }
  v20 = a2 & 0x100;
  *a9 = v16;
  if ( v13 )
  {
    if ( v20 )
    {
      v13->pvBuffer = 0i64;
      v13->cbBuffer = 0;
    }
    else
    {
      pvBuffer = v13->pvBuffer;
      if ( pvBuffer )
      {
LABEL_49:
        *((_QWORD *)a6 + 1) = pvBuffer;
        *(_QWORD *)a6 = v13->cbBuffer;
        goto LABEL_11;
      }
      v11 = 14;
    }
    pvBuffer = 0i64;
    goto LABEL_49;
  }
LABEL_11:
  *a5 = v13;
  if ( !v12 )
    return 2148074248i64;
  v12->BufferType = 2;
  if ( v20 )
  {
    v12->pvBuffer = 0i64;
    v21 = 0i64;
    v12->cbBuffer = 0;
    goto LABEL_14;
  }
  v21 = v12->pvBuffer;
  if ( !v21 )
    return 14i64;
LABEL_14:
  *((_QWORD *)a4 + 1) = v21;
  result = v11;
  *(_QWORD *)a4 = v12->cbBuffer;
  *a3 = v12;
  return result;
}

//----- (000000018000D7D0) ----------------------------------------------------
__int64 __fastcall AscIscPostProcessing(
        int a1,
        struct CSslContext *a2,
        struct CSslParentContext *a3,
        struct _SecBuffer *a4,
        struct _SecBuffer *a5,
        struct _SecBuffer *a6,
        struct SPBuffer *a7,
        struct _SecBuffer *a8,
        struct SPBuffer *a9,
        unsigned __int64 a10,
        unsigned __int8 *a11,
        union _LARGE_INTEGER *a12)
{
  int v12; // r8d
  unsigned int v13; // r13d
  unsigned int v15; // edi
  int v16; // esi
  int v17; // eax
  int v18; // edi
  __int64 v19; // rax
  int v20; // eax
  const WCHAR *v21; // rdi
  WCHAR *v22; // r14
  __int64 v23; // rsi
  __int64 v24; // r12
  const WCHAR *v25; // rsi
  __int64 v26; // r15
  const WCHAR *v27; // r15
  __int64 v28; // rax
  int v29; // r12d
  int v30; // ecx
  unsigned int v31; // r9d
  __int64 v33; // rbx
  __int64 v34; // rax
  struct _RTL_RESOURCE *v35; // rcx
  DWORD v36; // eax
  WCHAR *v37; // rax
  __int64 v38; // rcx
  CCipherMill *v39; // rcx
  unsigned int v40; // edi
  const WCHAR *v41; // rdx
  __int64 v42; // rdx
  __int64 csz; // [rsp+20h] [rbp-A1h]
  const WCHAR *SourceString; // [rsp+50h] [rbp-71h]
  struct _UNICODE_STRING v45; // [rsp+58h] [rbp-69h] BYREF
  struct _UNICODE_STRING v46; // [rsp+68h] [rbp-59h] BYREF
  struct _UNICODE_STRING v47; // [rsp+78h] [rbp-49h] BYREF
  struct _UNICODE_STRING v48; // [rsp+88h] [rbp-39h] BYREF
  char DestinationString[24]; // [rsp+98h] [rbp-29h] BYREF
  __int64 v50; // [rsp+B0h] [rbp-11h]
  DWORD v51; // [rsp+118h] [rbp+57h]
  DWORD v52; // [rsp+118h] [rbp+57h]

  v12 = 0;
  v13 = 590610;
  v15 = a1;
  if ( a1 == 590610 && a2 && *((_DWORD *)a2 + 17) == 77 )
  {
    v16 = 1;
  }
  else
  {
    v16 = 0;
    if ( a1 == -2146893032 )
    {
      if ( a5 && a6 )
      {
        a5->BufferType = 1073741828;
        v31 = *((_DWORD *)a7 + 1) - a6->cbBuffer;
        a5->cbBuffer = v31;
        a5->pvBuffer = 0i64;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_8;
        WPP_SF_d(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x10u,
          (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
          v31);
      }
      else
      {
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_8;
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 17i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
      }
      v12 = 0;
      goto LABEL_8;
    }
  }
  if ( (a10 & 0x100) != 0 || !v16 )
  {
    a8->pvBuffer = (void *)*((_QWORD *)a9 + 1);
    a8->cbBuffer = *((_DWORD *)a9 + 1);
  }
  if ( a1 != -2146893023 )
  {
    if ( !a1 )
      goto LABEL_8;
    if ( a1 < 0 )
    {
      if ( a1 != -2146892950 && a1 != -2146892949 )
        goto LABEL_64;
LABEL_8:
      if ( a8->cbBuffer && !v16 )
        goto LABEL_10;
      goto LABEL_64;
    }
    if ( (a1 & 0x1FFF0000) == 589824 )
      goto LABEL_8;
  }
LABEL_64:
  if ( (a10 & 0x100) != 0 && a8->pvBuffer )
  {
    if ( !a2 )
      return v15;
    (*(void (__fastcall **)(struct CSslContext *, void *))(*(_QWORD *)a2 + 16i64))(a2, a8->pvBuffer);
    v12 = 0;
    *(_QWORD *)&a8->cbBuffer = 0i64;
    a8->pvBuffer = 0i64;
    goto LABEL_11;
  }
LABEL_10:
  if ( !a2 )
    return v15;
LABEL_11:
  if ( !v16 )
  {
    if ( !v15 || v15 == 590614 || v15 == -2146892950 )
    {
      if ( a6 )
      {
        if ( *((_DWORD *)a7 + 1) < a6->cbBuffer )
        {
          if ( a5 )
          {
            a5->BufferType = 1073741829;
            a5->cbBuffer = a6->cbBuffer - *((_DWORD *)a7 + 1);
            a5->pvBuffer = 0i64;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 19i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
              v12 = 0;
            }
          }
        }
      }
      if ( !v15 )
      {
        v17 = *((_DWORD *)a2 + 17);
        if ( v17 != 4 && v17 != 51 && v17 != 79 || (*((_DWORD *)a2 + 34) & 0x40000000) != 0 )
          goto LABEL_44;
        *(_QWORD *)DestinationString = a2;
        *(_OWORD *)&DestinationString[8] = 0i64;
        v50 = 0i64;
        *a11 = 1;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
        v15 = CSslSerializeHelper::SerializeContextWorker(
                (CSslSerializeHelper *)DestinationString,
                (void (__fastcall *)(__int64, __int64 *))SslRelocateToken);
        if ( !v15 )
        {
          v18 = v50;
          v19 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)DestinationString + 8i64))(
                  *(_QWORD *)DestinationString,
                  (unsigned int)v50);
          *(_QWORD *)&DestinationString[8] = v19;
          if ( v19 )
          {
            HIDWORD(v50) = v18;
            *(_QWORD *)&DestinationString[16] = v19;
            v15 = CSslSerializeHelper::SerializeContextWorker(
                    (CSslSerializeHelper *)DestinationString,
                    (void (__fastcall *)(__int64, __int64 *))SslRelocateToken);
            if ( !v15 )
            {
              a4->pvBuffer = *(void **)&DestinationString[8];
              a4->cbBuffer = v50;
              *((_QWORD *)a2 + 17) |= 0x40000000ui64;
              v20 = *((_DWORD *)a2 + 17);
              if ( v20 != 4 && v20 != 79 )
              {
                v38 = *((_QWORD *)a2 + 19);
                if ( v38 )
                {
                  SslFreeObject(v38, 0i64);
                  *((_QWORD *)a2 + 19) = 0i64;
                }
                v12 = 1;
LABEL_44:
                v30 = *((_DWORD *)a2 + 17);
                if ( (unsigned int)(v30 - 3) <= 1 || v30 == 79 )
                {
                  v13 = 0;
                  goto LABEL_58;
                }
                if ( v12 )
                {
                  v39 = WPP_GLOBAL_Control;
                  if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
                    || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
                  {
                    goto LABEL_82;
                  }
                  v42 = 21i64;
                }
                else
                {
                  if ( (*(unsigned __int8 (__fastcall **)(struct CSslContext *, CCipherMill **))(*(_QWORD *)a2 + 384i64))(
                         a2,
                         &WPP_GLOBAL_Control)
                    || (*((_DWORD *)a2 + 16) & 0x1000) == 0
                    || *((_DWORD *)a2 + 17) != 70 )
                  {
LABEL_58:
                    if ( a12 )
                    {
                      v33 = *((_QWORD *)a2 + 11);
                      if ( v33 )
                      {
                        RtlAcquireResourceShared((PRTL_RESOURCE)(v33 + 72), 1u);
                        v34 = *(_QWORD *)(v33 + 48);
                        v35 = (struct _RTL_RESOURCE *)(v33 + 72);
                        if ( v34 )
                        {
                          *a12 = *(union _LARGE_INTEGER *)(*(_QWORD *)(v34 + 24) + 72i64);
                          RtlReleaseResource(v35);
                          return v13;
                        }
                        RtlReleaseResource(v35);
                      }
                      a12->QuadPart = 0x7FFFFF36D5969FFFi64;
                    }
                    return v13;
                  }
                  v39 = WPP_GLOBAL_Control;
                  if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
                    || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
                  {
LABEL_82:
                    v13 = 590694;
                    goto LABEL_58;
                  }
                  v42 = 22i64;
                }
                WPP_SF_(*((_QWORD *)v39 + 2), v42, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
                goto LABEL_82;
              }
              (*(void (__fastcall **)(struct CSslContext *))(*(_QWORD *)a2 + 264i64))(a2);
              if ( *((_BYTE *)a2 + 265) )
              {
                *((_BYTE *)a2 + 265) = 0;
LABEL_43:
                v12 = 0;
                goto LABEL_44;
              }
              v21 = 0i64;
              v22 = 0i64;
              v23 = (*(__int64 (__fastcall **)(struct CSslContext *))(*(_QWORD *)a2 + 248i64))(a2);
              v24 = (*(__int64 (__fastcall **)(struct CSslContext *))(*(_QWORD *)a2 + 320i64))(a2);
              if ( v23 )
                v21 = *(const WCHAR **)(v23 + 400);
              RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)a2 + 11) + 72i64), 1u);
              v25 = &Class;
              v26 = *(_QWORD *)(*((_QWORD *)a2 + 11) + 48i64);
              if ( v26
                && (v36 = CertNameToStrW(
                            *(_DWORD *)v26,
                            (PCERT_NAME_BLOB)(*(_QWORD *)(v26 + 24) + 80i64),
                            0x20000003u,
                            0i64,
                            0),
                    (v52 = v36) != 0)
                && (v37 = (WCHAR *)SPExternalAlloc(2 * v36), (v22 = v37) != 0i64) )
              {
                CertNameToStrW(*(_DWORD *)v26, (PCERT_NAME_BLOB)(*(_QWORD *)(v26 + 24) + 80i64), 0x20000003u, v37, v52);
                RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)a2 + 11) + 72i64));
              }
              else
              {
                RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)a2 + 11) + 72i64));
                if ( !v22 )
                {
                  SourceString = &Class;
LABEL_33:
                  v27 = &Class;
                  if ( v21 )
                    v27 = v21;
                  if ( v24 )
                    v25 = (const WCHAR *)v24;
                  v51 = *(_DWORD *)(*((_QWORD *)a2 + 11) + 8i64);
                  if ( (*((_BYTE *)a2 + 32) & 8) != 0 && (v28 = *((_QWORD *)a2 + 1)) != 0 )
                    v29 = *(_DWORD *)(v28 + 28);
                  else
                    v29 = 0;
                  if ( (g_dwEventLogging & 4) != 0 )
                  {
                    v40 = *((_DWORD *)a2 + 16);
                    MapProtocolToString(v40, &v48);
                    v41 = (const WCHAR *)pszClientString;
                    if ( (v40 & 0x40051555) != 0 )
                      v41 = pszServerString;
                    RtlInitUnicodeString((PUNICODE_STRING)DestinationString, v41);
                    RtlInitUnicodeString(&v47, v25);
                    RtlInitUnicodeString(&v46, v27);
                    RtlInitUnicodeString(&v45, SourceString);
                    LODWORD(csz) = v29;
                    SchEventWrite(
                      &SSLEVENT_HANDSHAKE_INFO,
                      L"uuddpuuu",
                      (__int64)DestinationString,
                      &v48,
                      csz,
                      v51,
                      a3,
                      &v47,
                      &v46,
                      &v45);
                  }
                  if ( v22 )
                    SPExternalFree(v22);
                  goto LABEL_43;
                }
              }
              SourceString = v22;
              goto LABEL_33;
            }
            (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)DestinationString + 16i64))(
              *(_QWORD *)DestinationString,
              *(_QWORD *)&DestinationString[8]);
          }
          else
          {
            return 14;
          }
        }
      }
    }
    return v15;
  }
  return 0i64;
}
// 18000DD53: conditional instruction was optimized away because ecx.4 is in (<-7FF6FCE8|80090319..80090320|>=80090322u)
// 1800382AA: variable 'csz' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018000DDA0) ----------------------------------------------------
__int64 __fastcall CSslSerializeHelper::SerializeContextWorker(
        CSslSerializeHelper *this,
        void (__fastcall *a2)(__int64, __int64 *))
{
  __int64 result; // rax
  __int64 v5; // rax
  unsigned int v7; // edx
  unsigned int v8; // edi
  __int64 v9; // rdx
  __int64 v10; // rsi
  _DWORD *v11; // rdi
  int v12; // eax
  int v13; // edx
  __int64 v14; // rdx
  _DWORD *v15; // rdi
  int v16; // eax
  int v17; // edx
  __int64 v18; // rcx
  void *v19; // r9
  unsigned int v20; // edi
  void *v21; // r9
  unsigned int v22; // edi
  void *v23; // rdx
  size_t v24; // r8
  unsigned int v25; // edi
  void *v26; // r9
  unsigned int v27; // edi
  __int128 *v28; // rcx
  const void **v29; // rax
  const void **v30; // rdi
  const void **v31; // rax
  const void **v32; // rdi
  __int64 v33; // rax
  __int64 v34; // rax
  bool v35; // cf
  __int64 v36; // rax
  __int64 v37; // rsi
  _DWORD *v38; // rcx
  _DWORD *v39; // rcx
  size_t v40; // r8
  __int64 v41; // rax
  _DWORD *v42; // rcx
  size_t v43; // r8
  _DWORD *v44; // rcx
  size_t v45; // r8
  _DWORD *v46; // rcx
  _DWORD *v47; // rax
  _QWORD *v48; // rdx
  __int128 v49; // xmm0
  const void *v50; // r8
  __int64 v51; // [rsp+70h] [rbp-90h] BYREF
  size_t v52; // [rsp+78h] [rbp-88h] BYREF
  unsigned int v53; // [rsp+80h] [rbp-80h] BYREF
  size_t Size; // [rsp+84h] [rbp-7Ch] BYREF
  __int64 v55; // [rsp+90h] [rbp-70h] BYREF
  unsigned int v56; // [rsp+98h] [rbp-68h] BYREF
  unsigned int v57; // [rsp+9Ch] [rbp-64h] BYREF
  __int64 v58; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v59; // [rsp+A8h] [rbp-58h] BYREF
  const void *v60; // [rsp+B0h] [rbp-50h] BYREF
  const void *v61; // [rsp+B8h] [rbp-48h] BYREF
  const void *v62; // [rsp+C0h] [rbp-40h] BYREF
  void *v63; // [rsp+C8h] [rbp-38h] BYREF
  void *v64; // [rsp+D0h] [rbp-30h] BYREF
  __int64 v65; // [rsp+D8h] [rbp-28h] BYREF
  __int64 v66; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v67; // [rsp+E8h] [rbp-18h] BYREF
  void *v68; // [rsp+F0h] [rbp-10h] BYREF
  void *v69; // [rsp+F8h] [rbp-8h] BYREF
  _WORD Src[256]; // [rsp+100h] [rbp+0h] BYREF

  v52 = 0i64;
  v60 = 0i64;
  v61 = 0i64;
  v62 = 0i64;
  v53 = 0;
  v63 = 0i64;
  Size = 0i64;
  v64 = 0i64;
  if ( *((_QWORD *)this + 1) )
  {
    v35 = *((_DWORD *)this + 7) < 0xD8u;
    v51 = 0i64;
    if ( v35 )
      return 2148074244i64;
    v36 = *((_QWORD *)this + 2);
    *(_DWORD *)v36 = 1;
    v37 = v36 + 16;
    *(_QWORD *)(v36 + 4) = 200i64;
    result = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)this + 24i64))(*(_QWORD *)this, v36 + 16);
    if ( (_DWORD)result )
      return result;
    (*(void (__fastcall **)(_QWORD, __int64 *, __int64))(**(_QWORD **)this + 72i64))(*(_QWORD *)this, &v65, v37 + 72);
    if ( v65 )
    {
      if ( a2 )
        a2(v65, &v51);
      *(_QWORD *)(v37 + 64) = v51;
    }
    *((_QWORD *)this + 2) += 216i64;
    *((_DWORD *)this + 7) -= 216;
  }
  else
  {
    *((_DWORD *)this + 6) += 216;
  }
  result = (*(__int64 (__fastcall **)(_QWORD, _WORD *, __int64 *))(**(_QWORD **)this + 32i64))(
             *(_QWORD *)this,
             Src,
             &v55);
  if ( (_DWORD)result )
    return result;
  v5 = -1i64;
  while ( Src[++v5] != 0 )
    ;
  v7 = 2 * v5 + 2;
  v8 = (2 * v5 + 25) & 0xFFFFFFF8;
  if ( *((_QWORD *)this + 1) )
  {
    if ( *((_DWORD *)this + 7) < v8 )
      return 1359i64;
    v38 = (_DWORD *)*((_QWORD *)this + 2);
    v38[2] = v7;
    *v38 = 9;
    v38[1] = v8 - 16;
    memcpy_0((void *)(*((_QWORD *)this + 2) + 16i64), Src, v7);
    *((_QWORD *)this + 2) += v8;
    *((_DWORD *)this + 7) -= v8;
  }
  else
  {
    *((_DWORD *)this + 6) += v8;
  }
  (*(void (__fastcall **)(_QWORD, __int64 *, __int64 *))(**(_QWORD **)this + 40i64))(*(_QWORD *)this, &v66, &v67);
  v9 = v66;
  v10 = 2i64;
  if ( v66 )
  {
    v11 = (_DWORD *)*((_QWORD *)this + 2);
    v12 = *((_DWORD *)this + 7);
    if ( *((_QWORD *)this + 1) )
    {
      v12 -= 16;
      *((_QWORD *)this + 2) = v11 + 4;
      *((_DWORD *)this + 7) = v12;
    }
    LODWORD(v51) = v12;
    result = SslExportKey(v55, v9, L"OpaqueKeyBlob");
    if ( (_DWORD)result && (_DWORD)result != -2146893784 )
      return result;
    v13 = (v51 + 23) & 0xFFFFFFF8;
    if ( *((_QWORD *)this + 1) )
    {
      *v11 = 2;
      v11[1] = v13 - 16;
      v11[2] = v51;
      *((_QWORD *)this + 2) += (unsigned int)(v13 - 16);
      *((_DWORD *)this + 7) += 16 - v13;
    }
    else
    {
      *((_DWORD *)this + 6) += v13;
    }
  }
  v14 = v67;
  if ( !v67 )
    goto LABEL_20;
  v15 = (_DWORD *)*((_QWORD *)this + 2);
  v16 = *((_DWORD *)this + 7);
  if ( *((_QWORD *)this + 1) )
  {
    v16 -= 16;
    *((_QWORD *)this + 2) = v15 + 4;
    *((_DWORD *)this + 7) = v16;
  }
  LODWORD(v51) = v16;
  result = SslExportKey(v55, v14, L"OpaqueKeyBlob");
  if ( !(_DWORD)result || (_DWORD)result == -2146893784 )
  {
    v17 = (v51 + 23) & 0xFFFFFFF8;
    if ( *((_QWORD *)this + 1) )
    {
      *v15 = 3;
      v15[1] = v17 - 16;
      v15[2] = v51;
      *((_QWORD *)this + 2) += (unsigned int)(v17 - 16);
      *((_DWORD *)this + 7) += 16 - v17;
    }
    else
    {
      *((_DWORD *)this + 6) += v17;
    }
LABEL_20:
    v18 = *(_QWORD *)this;
    v58 = 0i64;
    v59 = 0i64;
    (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v18 + 48i64))(v18, &v58, &v59);
    if ( v58 )
    {
      result = CSslSerializeHelper::SerializeEncryptionKey((__int64)this, 19, v55, v58);
      if ( (_DWORD)result )
        return result;
    }
    if ( v59 )
    {
      result = CSslSerializeHelper::SerializeEncryptionKey((__int64)this, 20, v55, v59);
      if ( (_DWORD)result )
        return result;
    }
    (*(void (__fastcall **)(_QWORD, const void **, unsigned int *, void **, size_t *, void **, char *, const void **, unsigned int *, const void **, unsigned int *, void **, size_t *))(**(_QWORD **)this + 56i64))(
      *(_QWORD *)this,
      &v60,
      &v56,
      &v68,
      &v52,
      &v69,
      (char *)&v52 + 4,
      &v61,
      &v57,
      &v62,
      &v53,
      &v63,
      &Size);
    if ( v60 )
    {
      result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 4, v60, v56);
      if ( (_DWORD)result )
        return result;
    }
    if ( (_DWORD)v52 )
    {
      v19 = v68;
      v20 = (v52 + 23) & 0xFFFFFFF8;
      if ( *((_QWORD *)this + 1) )
      {
        if ( *((_DWORD *)this + 7) < v20 )
          return 1359i64;
        v42 = (_DWORD *)*((_QWORD *)this + 2);
        v43 = (unsigned int)v52;
        v42[2] = v52;
        *v42 = 5;
        v42[1] = v20 - 16;
        memcpy_0((void *)(*((_QWORD *)this + 2) + 16i64), v19, v43);
        *((_QWORD *)this + 2) += v20;
        *((_DWORD *)this + 7) -= v20;
      }
      else
      {
        *((_DWORD *)this + 6) += v20;
      }
    }
    if ( HIDWORD(v52) )
    {
      v21 = v69;
      v22 = (HIDWORD(v52) + 23) & 0xFFFFFFF8;
      if ( *((_QWORD *)this + 1) )
      {
        if ( *((_DWORD *)this + 7) < v22 )
          return 1359i64;
        v44 = (_DWORD *)*((_QWORD *)this + 2);
        v45 = HIDWORD(v52);
        v44[2] = HIDWORD(v52);
        *v44 = 6;
        v44[1] = v22 - 16;
        memcpy_0((void *)(*((_QWORD *)this + 2) + 16i64), v21, v45);
        *((_QWORD *)this + 2) += v22;
        *((_DWORD *)this + 7) -= v22;
      }
      else
      {
        *((_DWORD *)this + 6) += v22;
      }
    }
    if ( v61 )
    {
      result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 7, v61, v57);
      if ( (_DWORD)result )
        return result;
    }
    if ( v62 )
    {
      if ( v53 )
      {
        result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 8, v62, v53);
        if ( (_DWORD)result )
          return result;
      }
    }
    v23 = v63;
    if ( v63 )
    {
      v24 = (unsigned int)Size;
      v25 = (Size + 23) & 0xFFFFFFF8;
      if ( *((_QWORD *)this + 1) )
      {
        if ( *((_DWORD *)this + 7) < v25 )
          return 1359i64;
        v46 = (_DWORD *)*((_QWORD *)this + 2);
        *v46 = 10;
        v46[1] = v25 - 16;
        v46[2] = v24;
        memcpy_0((void *)(*((_QWORD *)this + 2) + 16i64), v23, v24);
        *((_QWORD *)this + 2) += v25;
        *((_DWORD *)this + 7) -= v25;
      }
      else
      {
        *((_DWORD *)this + 6) += v25;
      }
    }
    (*(void (__fastcall **)(_QWORD, void **, char *))(**(_QWORD **)this + 80i64))(
      *(_QWORD *)this,
      &v64,
      (char *)&Size + 4);
    if ( HIDWORD(Size) )
    {
      v26 = v64;
      v27 = (HIDWORD(Size) + 23) & 0xFFFFFFF8;
      if ( *((_QWORD *)this + 1) )
      {
        if ( *((_DWORD *)this + 7) < v27 )
          return 1359i64;
        v39 = (_DWORD *)*((_QWORD *)this + 2);
        v40 = HIDWORD(Size);
        v39[2] = HIDWORD(Size);
        *v39 = 11;
        v39[1] = v27 - 16;
        memcpy_0((void *)(*((_QWORD *)this + 2) + 16i64), v26, v40);
        *((_QWORD *)this + 2) += v27;
        *((_DWORD *)this + 7) -= v27;
      }
      else
      {
        *((_DWORD *)this + 6) += v27;
      }
    }
    v28 = (__int128 *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)this + 88i64))(*(_QWORD *)this);
    if ( v28 )
    {
      if ( *((_QWORD *)this + 1) )
      {
        if ( *((_DWORD *)this + 7) < 0x118u )
          return 1359i64;
        v47 = (_DWORD *)*((_QWORD *)this + 2);
        *v47 = 12;
        v47[1] = 264;
        v47[2] = 264;
        v48 = (_QWORD *)(*((_QWORD *)this + 2) + 16i64);
        do
        {
          v48 += 16;
          v49 = *v28;
          v28 += 8;
          *((_OWORD *)v48 - 8) = v49;
          *((_OWORD *)v48 - 7) = *(v28 - 7);
          *((_OWORD *)v48 - 6) = *(v28 - 6);
          *((_OWORD *)v48 - 5) = *(v28 - 5);
          *((_OWORD *)v48 - 4) = *(v28 - 4);
          *((_OWORD *)v48 - 3) = *(v28 - 3);
          *((_OWORD *)v48 - 2) = *(v28 - 2);
          *((_OWORD *)v48 - 1) = *(v28 - 1);
          --v10;
        }
        while ( v10 );
        *v48 = *(_QWORD *)v28;
        *((_QWORD *)this + 2) += 280i64;
        *((_DWORD *)this + 7) -= 280;
      }
      else
      {
        *((_DWORD *)this + 6) += 280;
      }
    }
    v29 = (const void **)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)this + 96i64))(*(_QWORD *)this);
    v30 = v29;
    if ( v29 )
    {
      result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 13, v29, 0x10u);
      if ( (_DWORD)result )
        return result;
      if ( *((_BYTE *)v30 + 2) )
      {
        result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 14, v30[1], *((unsigned __int8 *)v30 + 2));
        if ( (_DWORD)result )
          return result;
      }
    }
    v31 = (const void **)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)this + 104i64))(*(_QWORD *)this);
    v32 = v31;
    if ( v31 )
    {
      result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 15, v31, 0x10u);
      if ( (_DWORD)result )
        return result;
      if ( *((_WORD *)v32 + 1) )
      {
        result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 16, v32[1], *((unsigned __int16 *)v32 + 1));
        if ( (_DWORD)result )
          return result;
      }
    }
    v33 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)this + 112i64))(*(_QWORD *)this);
    if ( v33 )
    {
      v50 = *(const void **)(v33 + 8);
      if ( v50 )
      {
        result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 17, v50, *(_DWORD *)v33);
        if ( (_DWORD)result )
          return result;
      }
    }
    v34 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)this + 120i64))(*(_QWORD *)this);
    if ( v34 )
    {
      result = CSslSerializeHelper::SerializeEncryptionKey((__int64)this, 18, v55, v34);
      if ( (_DWORD)result )
        return result;
    }
    if ( !*((_QWORD *)this + 1) )
    {
      *((_DWORD *)this + 6) += 16;
      return 0i64;
    }
    if ( *((_DWORD *)this + 7) >= 0x10u )
    {
      v41 = *((_QWORD *)this + 2);
      *(_QWORD *)v41 = 0i64;
      *(_DWORD *)(v41 + 8) = 0;
      *((_QWORD *)this + 2) += 16i64;
      *((_DWORD *)this + 7) -= 16;
      return 0i64;
    }
    return 1359i64;
  }
  return result;
}
// 180082320: using guessed type wchar_t aOpaquekeyblob[14];
// 180098528: using guessed type __int64 __fastcall SslExportKey(_QWORD, _QWORD, _QWORD);
// 18000DDA0: using guessed type _WORD Src[256];

//----- (000000018000E544) ----------------------------------------------------
__int64 __fastcall CSslSerializeHelper::SerializeDataBlob(__int64 a1, int a2, const void *a3, unsigned int a4)
{
  unsigned int v4; // edi
  _DWORD *v7; // rcx

  v4 = (a4 + 23) & 0xFFFFFFF8;
  if ( !*(_QWORD *)(a1 + 8) )
  {
    *(_DWORD *)(a1 + 24) += v4;
    return 0i64;
  }
  if ( *(_DWORD *)(a1 + 28) >= v4 )
  {
    v7 = *(_DWORD **)(a1 + 16);
    *v7 = a2;
    v7[1] = v4 - 16;
    v7[2] = a4;
    memcpy_0((void *)(*(_QWORD *)(a1 + 16) + 16i64), a3, a4);
    *(_QWORD *)(a1 + 16) += v4;
    *(_DWORD *)(a1 + 28) -= v4;
    return 0i64;
  }
  return 1359i64;
}

//----- (000000018000E5B4) ----------------------------------------------------
bool __fastcall IsFatalError(int a1)
{
  if ( !a1 )
    return 0;
  if ( a1 < 0 )
    return a1 != -2146893032 && a1 != -2146893023 && (unsigned int)(a1 + 2146892950) > 1;
  return (a1 & 0x1FFF0000) != 589824;
}

//----- (000000018000E5E4) ----------------------------------------------------
__int64 __fastcall GetSslProvHandle(const unsigned __int16 *a1, unsigned __int64 *a2)
{
  int v4; // ebp
  unsigned __int64 SslProvHandleInCache; // rdi
  unsigned int v6; // eax
  unsigned int v7; // ebx
  CCipherMill *v8; // rcx
  unsigned int CachedSslProv; // eax
  __int64 v11; // rdx
  __int64 v12; // r8
  __int64 v13; // [rsp+20h] [rbp-38h]
  __int64 v14[5]; // [rsp+30h] [rbp-28h] BYREF

  v4 = 0;
  RtlAcquireResourceShared(g_pSslProvCacheRWLock, 1u);
  SslProvHandleInCache = FindSslProvHandleInCache(a1);
  RtlReleaseResource(g_pSslProvCacheRWLock);
  if ( SslProvHandleInCache )
    goto LABEL_2;
  CachedSslProv = CreateCachedSslProv((struct CACHED_SSL_PROVIDER *)v14, a1);
  v7 = CachedSslProv;
  if ( !CachedSslProv )
  {
    v4 = 1;
    RtlAcquireResourceExclusive(g_pSslProvCacheRWLock, 1u);
    SslProvHandleInCache = FindSslProvHandleInCache(a1);
    if ( SslProvHandleInCache )
    {
      DestroyCachedSslProv((struct CACHED_SSL_PROVIDER *)v14);
      v4 = 0;
    }
    else
    {
      SslProvHandleInCache = v14[0];
      CacheClientSideSslProv((struct CACHED_SSL_PROVIDER *)v14);
    }
    RtlReleaseResource(g_pSslProvCacheRWLock);
LABEL_2:
    v6 = SslIncrementProviderReferenceCount(SslProvHandleInCache);
    v7 = v6;
    if ( v6 )
    {
      v8 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_qD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x18u,
          &WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids,
          SslProvHandleInCache,
          v6);
        v8 = WPP_GLOBAL_Control;
      }
      if ( !v4 )
        goto LABEL_5;
      DestroyCachedSslProv((struct CACHED_SSL_PROVIDER *)v14);
    }
    else
    {
      *a2 = SslProvHandleInCache;
    }
    goto LABEL_4;
  }
  v8 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control )
    return v7;
  if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    WPP_SF_qSD(*((_QWORD *)WPP_GLOBAL_Control + 2), v11, v12, v14, a1, CachedSslProv);
LABEL_4:
    v8 = WPP_GLOBAL_Control;
  }
LABEL_5:
  if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)v8 + 28) & 1) != 0 && v7 || (*((_BYTE *)v8 + 28) & 4) != 0) )
  {
    LODWORD(v13) = v7;
    WPP_SF_DD(*((_QWORD *)v8 + 2), 0x19u, (__int64)&WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids, v7, v13);
  }
  return v7;
}
// 1800384E4: variable 'v11' is possibly undefined
// 1800384E4: variable 'v12' is possibly undefined
// 18003855B: variable 'v13' is possibly undefined
// 1800984E8: using guessed type __int64 __fastcall SslIncrementProviderReferenceCount(_QWORD);

//----- (000000018000E714) ----------------------------------------------------
unsigned __int64 __fastcall FindSslProvHandleInCache(const unsigned __int16 *a1)
{
  __int64 v1; // rax
  _QWORD *i; // r8
  const unsigned __int16 *v4; // rdx
  int v5; // r11d
  int v6; // ecx

  v1 = 0i64;
  if ( !g_cCachedPagedSslProvs )
    return 0i64;
  for ( i = &unk_180092AA8; ; i += 2 )
  {
    v4 = a1;
    do
    {
      v5 = *(const unsigned __int16 *)((char *)v4 + *i - (_QWORD)a1);
      v6 = *v4 - v5;
      if ( v6 )
        break;
      ++v4;
    }
    while ( v5 );
    if ( !v6 )
      break;
    v1 = (unsigned int)(v1 + 1);
    if ( (unsigned int)v1 >= g_cCachedPagedSslProvs )
      return 0i64;
  }
  return *((_QWORD *)&g_rgCachedPagedSslProvs + 2 * v1);
}
// 180092A90: using guessed type unsigned int g_cCachedPagedSslProvs;

//----- (000000018000E778) ----------------------------------------------------
struct CSslUserContext *__fastcall CreateUserContext(size_t Size)
{
  unsigned int v1; // edi
  _DWORD *v2; // rax
  _DWORD *v3; // rbx

  if ( (unsigned int)Size < 0x1D0 )
    return 0i64;
  v1 = Size;
  v2 = LocalAlloc(0x40u, (unsigned int)Size);
  v3 = v2;
  if ( !v2 )
    return 0i64;
  memset_0(v2, 0, v1);
  v3[95] = 0;
  *((_QWORD *)v3 + 49) = 0i64;
  *((_QWORD *)v3 + 50) = 0i64;
  *((_QWORD *)v3 + 51) = 0i64;
  *((_QWORD *)v3 + 54) = 0i64;
  *((_QWORD *)v3 + 55) = 0i64;
  *(_QWORD *)v3 = &CSslUserContext::`vftable';
  *((_QWORD *)v3 + 56) = 0i64;
  v3[36] = -1;
  *((_BYTE *)v3 + 32) = 0;
  *((_BYTE *)v3 + 112) = 0;
  *((_BYTE *)v3 + 140) = 0;
  *((_BYTE *)v3 + 456) = 0;
  v3[115] = 23726566;
  *((_OWORD *)v3 + 26) = 0i64;
  v3[96] = -1;
  return (struct CSslUserContext *)v3;
}
// 18007D058: using guessed type void *CSslUserContext::`vftable';

//----- (000000018000E850) ----------------------------------------------------
__int64 __fastcall SchannelInit(int a1)
{
  unsigned int v2; // ebx
  __int64 v4; // r8
  CCipherMill *v5; // rcx
  CSessionCacheManager *CacheManager; // rax
  CSslCredManager *v7; // rax
  unsigned int LastError; // edi
  unsigned __int16 *v9; // rcx

  v2 = 1;
  if ( !CSslGlobals::m_bSchannelInitialized )
  {
    RtlEnterCriticalSection(&CSslGlobals::m_InitCriticalSection);
    if ( CSslGlobals::m_bSchannelInitialized )
    {
LABEL_7:
      RtlLeaveCriticalSection(&CSslGlobals::m_InitCriticalSection);
      return v2;
    }
    DisableThreadLibraryCalls(CSslGlobals::m_hInstance);
    SafeAllocaInitialize();
    if ( !a1 )
    {
      if ( BCryptOpenAlgorithmProvider(&g_hSHAProvider, L"SHA1", 0i64, 0)
        || BCryptOpenAlgorithmProvider(&g_hMD5Provider, L"MD5", 0i64, 0)
        || BCryptOpenAlgorithmProvider(&g_hDSAProvider, L"DSA", 0i64, 0)
        || BCryptOpenAlgorithmProvider(&g_hRSAProvider, L"RSA", 0i64, 0)
        || (unsigned int)CCipherMill::BuildCipherMill(v5) )
      {
        goto LABEL_33;
      }
      if ( !CryptAcquireContextW(&g_hDhSchannelProv, 0i64, 0i64, 0x12u, 0xF0000000) )
      {
        g_hDhSchannelProv = 0i64;
        LastError = GetLastError();
        v9 = (unsigned __int16 *)WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            10i64,
            &WPP_60bc9b1becfd3dd8c20089fcdaea9e65_Traceguids,
            LastError);
        LogGlobalAcquireContextFailedEvent(v9, LastError);
      }
      if ( !(unsigned int)LoadSslRegistryOptions() )
        goto LABEL_33;
      SchInitializeEvents();
      CacheManager = CSessionCacheManager::CreateCacheManager();
      if ( !CacheManager
        || (unsigned int)CSessionCacheManager::InitializeSessionCache(CacheManager)
        || (unsigned int)InitializeIssuerCache() )
      {
        goto LABEL_33;
      }
      v7 = CSslCredManager::m_pCredManager;
      if ( !CSslCredManager::m_pCredManager )
      {
        v7 = (CSslCredManager *)SPExternalAlloc(0x60u);
        if ( v7 )
          *(_QWORD *)v7 = &CSslCredManager::`vftable';
        CSslCredManager::m_pCredManager = v7;
        if ( !v7 )
          goto LABEL_33;
      }
      if ( !CSslCredManager::InitCredentialManager(v7) )
        goto LABEL_33;
      SslInitSystemMapper();
      if ( (unsigned int)InitializeSslMemoryOptions()
        || (unsigned int)CSslGlobals::InitializePeriodicCleanupHandler()
        || (unsigned int)CSslGlobals::InitializeCryptLocatorEvents() )
      {
        goto LABEL_33;
      }
      I_CertWnfEnableFlushCache();
    }
    if ( !(unsigned int)InitializeClientSideSslProvCache() )
    {
      LoadSecurityDll();
      CSslGlobals::m_bSchannelInitialized = 1;
      if ( a1 )
        goto LABEL_7;
      if ( (g_dwEventLogging & 4) != 0 )
        SchEventWrite(&SSLEVENT_SCHANNEL_STARTED, 0i64, v4);
      if ( !(unsigned int)TlgRegisterAggregateProviderEx() )
      {
        CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized = 1;
        QueryPerformanceFrequency(&CSchannelTelemetryContext::m_liPerfCtrFreq);
      }
LABEL_31:
      if ( !CSslGlobals::m_bSchannelInitialized )
        SchannelShutdown();
      goto LABEL_7;
    }
LABEL_33:
    v2 = 0;
    goto LABEL_31;
  }
  return v2;
}
// 18000E98F: variable 'v5' is possibly undefined
// 1800385D6: variable 'v4' is possibly undefined
// 1800385C2: variable 'v9' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 18007D478: using guessed type void *CSslCredManager::`vftable';
// 1800921D8: using guessed type int CSslGlobals::m_bSchannelInitialized;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 180098170: using guessed type __int64 I_CertWnfEnableFlushCache(void);

//----- (000000018000EABC) ----------------------------------------------------
void __fastcall CCipherMill::GetSignatureSuiteList(CCipherMill *this, struct CTlsSignatureSuiteList *a2)
{
  RtlAcquireResourceShared(&Resource, 1u);
  CTlsSignatureSuiteList::SetSignatureSuiteList(a2, (const struct CTlsSignatureSuiteList *)&word_1800925E8);
  RtlReleaseResource(&Resource);
}
// 1800925E8: using guessed type __int16 word_1800925E8;

//----- (000000018000EB08) ----------------------------------------------------
void __fastcall CTlsSignatureSuiteList::SetSignatureSuiteList(
        CTlsSignatureSuiteList *this,
        const struct CTlsSignatureSuiteList *a2)
{
  __int64 v2; // r8

  *(_WORD *)this = 0;
  *((_WORD *)this + 17) = 0;
  v2 = *(unsigned __int16 *)a2;
  if ( (unsigned int)v2 <= 0x10 )
  {
    *(_WORD *)this = v2;
    *((_WORD *)this + 17) = *((_WORD *)a2 + 17);
    memcpy_0((char *)this + 2, (char *)a2 + 2, 2 * v2);
  }
}

//----- (000000018000EB48) ----------------------------------------------------
ULONG __fastcall CSsl3TlsContext::TlsGenerateRandom(CSsl3TlsContext *this)
{
  unsigned __int64 v2; // rdx
  __time32_t Time; // [rsp+30h] [rbp+8h] BYREF

  time32_0(&Time);
  v2 = (-(__int64)((*((_DWORD *)this + 16) & 0xA2AA0) != 0) & 0xFFFFFFFFFFFFFFE0ui64) + 304;
  *(_DWORD *)((char *)this + v2) = _byteswap_ulong(Time);
  return GenerateRandomBits((PUCHAR)this + v2 + 4, 0x1Cu);
}

//----- (000000018000EB9C) ----------------------------------------------------
ULONG __fastcall GenerateRandomBits(PUCHAR pbBuffer, ULONG cbBuffer)
{
  int v2; // ecx
  ULONG result; // eax

  v2 = BCryptGenRandom(0i64, pbBuffer, cbBuffer, 2u);
  result = 0;
  if ( v2 < 0 )
    return RtlNtStatusToDosError(v2);
  return result;
}

//----- (000000018000EBEC) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::LogHandshakeStart(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5)
{
  bool v8; // zf

  if ( a1 )
  {
    if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    {
      *(_DWORD *)(a1 + 12) = a2;
      QueryPerformanceCounter((LARGE_INTEGER *)(a1 + 80));
      *(_DWORD *)(a1 + 24) = 0;
      v8 = *(_DWORD *)(a1 + 12) == 1;
      *(_QWORD *)(a1 + 120) = a3;
      *(_QWORD *)(a1 + 136) = a4;
      *(_BYTE *)(a1 + 28) = v8;
      *(_QWORD *)(a1 + 144) = a5;
      CSchannelTelemetryContext::LogAppName((CSchannelTelemetryContext *)a1);
    }
  }
}
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (000000018000EC6C) ----------------------------------------------------
void __fastcall CSslUserContext::~CSslUserContext(CSslUserContext *this)
{
  *(_QWORD *)this = &CSslUserContext::`vftable';
  CSslUserContext::CleanupUserContext(this);
  *(_QWORD *)this = &ISslSerialize::`vftable';
}
// 18007CFB8: using guessed type void *ISslSerialize::`vftable';
// 18007D058: using guessed type void *CSslUserContext::`vftable';

//----- (000000018000EC9C) ----------------------------------------------------
void __fastcall CSslUserContext::CleanupUserContext(CSslUserContext *this)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  void *v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx

  if ( *((_QWORD *)this + 11) )
    SslDecrementProviderReferenceCount();
  v2 = *((_QWORD *)this + 5);
  if ( v2 )
    SslFreeObject(v2, 0i64);
  v3 = *((_QWORD *)this + 6);
  if ( v3 )
    SslFreeObject(v3, 0i64);
  v4 = (void *)*((_QWORD *)this + 33);
  if ( v4 )
    NtClose(v4);
  v5 = *((_QWORD *)this + 54);
  if ( v5 )
    SslFreeObject(v5, 0i64);
  v6 = *((_QWORD *)this + 55);
  if ( v6 )
    SslFreeObject(v6, 0i64);
  v7 = *((_QWORD *)this + 56);
  if ( v7 )
    SslFreeObject(v7, 0i64);
}
// 180098518: using guessed type __int64 SslDecrementProviderReferenceCount(void);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018000ED40) ----------------------------------------------------
CSslUserContext *__fastcall CSslUserContext::`vector deleting destructor'(CSslUserContext *this)
{
  CSslUserContext::~CSslUserContext(this);
  return this;
}

//----- (000000018000ED60) ----------------------------------------------------
void __fastcall DeleteUserContext(struct CSslUserContext *a1)
{
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x7Eu, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, a1);
  (**(void (__fastcall ***)(struct CSslUserContext *, _QWORD))a1)(a1, 0i64);
  LocalFree(a1);
}

//----- (000000018000EDBC) ----------------------------------------------------
__int64 __fastcall GetCipherInfo(struct CSslUserContext *a1, struct _SecPkgContext_CipherInfo *a2)
{
  unsigned __int16 v4; // ax
  unsigned int v5; // r14d
  __int64 v6; // rdi
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  int v12[3]; // [rsp+30h] [rbp-D0h] BYREF
  _WORD Src[64]; // [rsp+3Ch] [rbp-C4h] BYREF
  _WORD v14[64]; // [rsp+BCh] [rbp-44h] BYREF
  DWORD v15; // [rsp+13Ch] [rbp+3Ch]
  DWORD v16; // [rsp+140h] [rbp+40h]
  _WORD v17[64]; // [rsp+144h] [rbp+44h] BYREF
  DWORD v18; // [rsp+1C4h] [rbp+C4h]
  _WORD v19[64]; // [rsp+1C8h] [rbp+C8h] BYREF
  DWORD v20; // [rsp+248h] [rbp+148h]
  DWORD v21; // [rsp+24Ch] [rbp+14Ch]
  _WORD v22[72]; // [rsp+250h] [rbp+150h] BYREF

  memset_0(v12, 0, 0x2A4ui64);
  v4 = ConvertSchannelProtocolToSsl(*((_DWORD *)a1 + 6));
  v5 = SslLookupCipherSuiteInfo(
         *((_QWORD *)a1 + 11),
         v4,
         *((unsigned int *)a1 + 14),
         *((unsigned int *)a1 + 15),
         v12,
         0);
  if ( !v5 )
  {
    v6 = -1i64;
    a2->dwProtocol = v12[0];
    v7 = -1i64;
    a2->dwCipherSuite = v12[1];
    a2->dwBaseCipherSuite = v12[2];
    a2->dwVersion = 1;
    do
      ++v7;
    while ( Src[v7] );
    memcpy_0(a2->szCipherSuite, Src, 2i64 * (unsigned int)(v7 + 1));
    v8 = -1i64;
    do
      ++v8;
    while ( v14[v8] );
    memcpy_0(a2->szCipher, v14, 2i64 * (unsigned int)(v8 + 1));
    a2->dwCipherLen = v15;
    a2->dwCipherBlockLen = v16;
    v9 = -1i64;
    do
      ++v9;
    while ( v17[v9] );
    memcpy_0(a2->szHash, v17, 2i64 * (unsigned int)(v9 + 1));
    a2->dwHashLen = v18;
    v10 = -1i64;
    do
      ++v10;
    while ( v19[v10] );
    memcpy_0(a2->szExchange, v19, 2i64 * (unsigned int)(v10 + 1));
    a2->dwMinExchangeLen = v20;
    a2->dwMaxExchangeLen = v21;
    do
      ++v6;
    while ( v22[v6] );
    memcpy_0(a2->szCertificate, v22, 2i64 * (unsigned int)(v6 + 1));
    a2->dwKeyType = *((_DWORD *)a1 + 15);
  }
  return v5;
}
// 180098510: using guessed type __int64 __fastcall SslLookupCipherSuiteInfo(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 18000EDBC: using guessed type _WORD Src[64];
// 18000EDBC: using guessed type _WORD var_254[64];
// 18000EDBC: using guessed type _WORD var_1CC[64];
// 18000EDBC: using guessed type _WORD var_148[64];
// 18000EDBC: using guessed type _WORD var_C0[72];

//----- (000000018000EFA0) ----------------------------------------------------
__int64 __fastcall GetOldConnectionInfo(struct CSslUserContext *a1, struct _SecPkgContext_ConnectionInfo *a2)
{
  unsigned __int16 v4; // ax
  unsigned int v5; // esi
  ALG_ID v6; // eax
  ALG_ID v7; // eax
  __int64 v8; // rdx
  ALG_ID v9; // eax
  int v11; // [rsp+30h] [rbp-348h] BYREF
  char v12[268]; // [rsp+34h] [rbp-344h] BYREF
  DWORD v13; // [rsp+140h] [rbp-238h]
  DWORD v14; // [rsp+1C8h] [rbp-1B0h]

  v11 = 1;
  memset_0(v12, 0, 0x324ui64);
  v4 = ConvertSchannelProtocolToSsl(*((_DWORD *)a1 + 6));
  v5 = SslLookupCipherSuiteInfo(
         *((_QWORD *)a1 + 11),
         v4,
         *((unsigned int *)a1 + 14),
         *((unsigned int *)a1 + 15),
         v12,
         0);
  if ( !v5 )
  {
    a2->dwProtocol = *((_DWORD *)a1 + 6);
    v6 = LookupSymmetricCipherAlg((struct _NCRYPT_SSL_CIPHER_SUITE_EX *)&v11);
    a2->aiCipher = v6;
    if ( v6 - 28672 <= 0xF )
      a2->aiCipher = 28672;
    a2->dwCipherStrength = v13;
    v7 = LookupChecksumAlg((wchar_t *)&v11);
    a2->aiHash = v7;
    if ( v7 - 36864 <= 0xF )
      a2->aiHash = 36864;
    a2->dwHashStrength = v14;
    v9 = LookupExchangeAlg((wchar_t *)&v11, v8);
    a2->aiExch = v9;
    if ( v9 - 45056 <= 4 )
      a2->aiExch = 45056;
    a2->dwExchStrength = *((_DWORD *)a1 + 7);
  }
  return v5;
}
// 18000F069: variable 'v8' is possibly undefined
// 180098510: using guessed type __int64 __fastcall SslLookupCipherSuiteInfo(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);

//----- (000000018000F0CC) ----------------------------------------------------
__int64 __fastcall LookupExchangeAlg(wchar_t *a1, __int64 a2)
{
  const wchar_t *v2; // rbx
  unsigned int v4; // [rsp+30h] [rbp+8h] BYREF

  v4 = 0;
  v2 = a1 + 206;
  if ( (unsigned int)I_GetKeyExchangeDetailsFromAlgorithmName(a1 + 206, a2, &v4)
    && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids, v2);
  }
  return v4;
}

//----- (000000018000F120) ----------------------------------------------------
__int64 __fastcall LookupChecksumAlg(wchar_t *a1)
{
  const wchar_t *v1; // rsi
  unsigned int v3; // ebx
  __int64 HashInfoFromAlgorithmName; // rax
  __int64 v5; // r9
  int v6; // eax
  int v7; // edx
  int HashDetailsFromHashInfo; // eax
  unsigned int v10; // [rsp+40h] [rbp+8h] BYREF

  v1 = a1 + 140;
  v3 = 0;
  v10 = 0;
  HashInfoFromAlgorithmName = I_GetHashInfoFromAlgorithmName(a1 + 140);
  if ( HashInfoFromAlgorithmName )
  {
    HashDetailsFromHashInfo = I_GetHashDetailsFromHashInfo(HashInfoFromAlgorithmName, 0i64, 0i64, v5, &v10, 0i64);
    v3 = v10;
    if ( !HashDetailsFromHashInfo )
      return v3;
  }
  v6 = *((_DWORD *)a1 + 2);
  if ( v6 == 49199 )
    return 32780;
  v7 = 4101;
  if ( (unsigned int)(v6 - 156) <= 0xC )
  {
    if ( _bittest(&v7, v6 - 156) )
      return 32780;
  }
  if ( v6 == 49200 || v6 == 49196 )
    return 32781;
  if ( v6 == 49195 || v6 == 4865 || v6 == 4867 )
    return 32780;
  if ( (unsigned int)(v6 - 157) <= 0xC && _bittest(&v7, v6 - 157) || v6 == 4866 )
    return 32781;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xEu, (__int64)&WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids, v1);
  return v3;
}
// 18000F1A5: variable 'v5' is possibly undefined

//----- (000000018000F1FC) ----------------------------------------------------
__int64 __fastcall LookupSymmetricCipherAlg(struct _NCRYPT_SSL_CIPHER_SUITE_EX *a1)
{
  wchar_t *v1; // rdi
  unsigned int v3; // ebx
  int v4; // eax
  __int64 v6; // rdx
  __int64 v7; // r8
  unsigned int v8; // [rsp+30h] [rbp+8h] BYREF

  v1 = (wchar_t *)((char *)a1 + 144);
  v3 = 0;
  if ( !wcscmp_0((const wchar_t *)a1 + 72, L"AES") )
  {
    v4 = *((_DWORD *)a1 + 68);
    if ( v4 == 256 )
    {
      return 26128;
    }
    else
    {
      v3 = 26129;
      if ( v4 == 128 )
        return 26126;
    }
  }
  else if ( !wcscmp_0(v1, L"DES") )
  {
    return 26113;
  }
  else if ( !wcscmp_0(v1, L"RC4") )
  {
    return 26625;
  }
  else if ( !wcscmp_0(v1, L"3DES") )
  {
    return 26115;
  }
  else if ( *v1 )
  {
    v8 = 0;
    if ( wcscmp_0(v1, L"CHACHA20_POLY1305") )
    {
      if ( (unsigned int)I_GetCipherDetailsFromAlgorithmName(v1, v6, v7, &v8)
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_S(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xDu,
          (__int64)&WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids,
          v1);
      }
      return v8;
    }
  }
  else
  {
    return 24576;
  }
  return v3;
}
// 1800386FD: variable 'v6' is possibly undefined
// 1800386FD: variable 'v7' is possibly undefined

//----- (000000018000F2C0) ----------------------------------------------------
__int64 __fastcall SpQueryEndpointBindings(struct CSslUserContext *a1, struct _SecPkgContext_Bindings *a2)
{
  unsigned __int8 *v2; // rdi
  unsigned int v4; // ebx
  unsigned __int8 *v5; // rbp
  unsigned int v6; // ebx
  unsigned int v7; // r14d
  SEC_CHANNEL_BINDINGS *v8; // rax
  SEC_CHANNEL_BINDINGS *Bindings; // rcx
  unsigned int v11; // [rsp+50h] [rbp+8h] BYREF
  unsigned __int8 *v12; // [rsp+58h] [rbp+10h] BYREF

  v2 = 0i64;
  a2->BindingsLength = 0;
  a2->Bindings = 0i64;
  if ( (*((_BYTE *)a1 + 24) & 0xC) != 0 )
  {
    v6 = -2146893054;
    goto LABEL_13;
  }
  v4 = *((_DWORD *)a1 + 60);
  v5 = (unsigned __int8 *)*((_QWORD *)a1 + 29);
  v12 = v5;
  v11 = v4;
  if ( !v4 )
  {
    v6 = GenerateRemoteEndpointBindingsHash((__int64)a1, &v12, &v11);
    if ( v6 )
      goto LABEL_13;
    v2 = v12;
    v4 = v11;
    v5 = v12;
  }
  if ( !v5 || !v4 )
    goto LABEL_10;
  v7 = v4 + 53;
  if ( v4 + 53 < v4 )
  {
    v6 = -2146893052;
  }
  else
  {
    v8 = (SEC_CHANNEL_BINDINGS *)LocalAlloc(0x40u, v7);
    a2->Bindings = v8;
    if ( v8 )
    {
      v8->cbApplicationDataLength = v4 + 21;
      a2->Bindings->dwApplicationDataOffset = 32;
      Bindings = a2->Bindings;
      qmemcpy(&Bindings[1], "tls-server-end-point:", 21);
      memcpy_0((char *)&Bindings[1].dwAcceptorOffset + 1, v5, v4);
      a2->BindingsLength = v7;
LABEL_10:
      v6 = 0;
      goto LABEL_11;
    }
    v6 = -2146893056;
  }
LABEL_11:
  if ( v2 )
    SPExternalFree(v2);
LABEL_13:
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v6 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x67u,
      (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
      v6,
      v6);
  }
  return v6;
}

//----- (000000018000F3F4) ----------------------------------------------------
__int64 __fastcall GenerateRemoteEndpointBindingsHash(__int64 a1, unsigned __int8 **a2, unsigned int *a3)
{
  DWORD CertEndpointBindings; // ebx
  PCCERT_CONTEXT pCertContext; // [rsp+30h] [rbp+8h] BYREF

  *a2 = 0i64;
  *a3 = 0;
  pCertContext = 0i64;
  if ( (*(_DWORD *)(a1 + 24) & 0x40051555) != 0 || !*(_QWORD *)(a1 + 152) )
    return 0i64;
  CertEndpointBindings = SPLoadCertificate(*(unsigned __int8 **)(a1 + 152), *(_DWORD *)(a1 + 160), &pCertContext);
  if ( !CertEndpointBindings )
  {
    CertEndpointBindings = GetCertEndpointBindings(pCertContext, a2, a3);
    CertFreeCertificateContext(pCertContext);
  }
  return CertEndpointBindings;
}

//----- (000000018000F484) ----------------------------------------------------
DWORD __fastcall GetCertEndpointBindings(const struct _CERT_CONTEXT *a1, unsigned __int8 **a2, unsigned int *a3)
{
  PCCRYPT_OID_INFO OIDInfo; // rax
  const wchar_t *v7; // rbx
  unsigned __int8 *pbComputedHash; // rdi
  DWORD v9; // eax
  DWORD LastError; // ebx
  DWORD pcbComputedHash; // [rsp+60h] [rbp+8h] BYREF

  pcbComputedHash = 0;
  OIDInfo = CryptFindOIDInfo(1u, a1->pCertInfo->SignatureAlgorithm.pszObjId, 0x40000004u);
  if ( !OIDInfo
    || OIDInfo->dwValue != -1
    || (v7 = *(const wchar_t **)&OIDInfo[1].cbSize) == 0i64
    || !wcscmp_0(*(const wchar_t **)&OIDInfo[1].cbSize, L"SHA1")
    || !wcscmp_0(v7, L"MD5") )
  {
    v7 = L"SHA256";
  }
  if ( !CryptHashCertificate2(v7, 0, 0i64, a1->pbCertEncoded, a1->cbCertEncoded, 0i64, &pcbComputedHash) )
    return GetLastError();
  pbComputedHash = (unsigned __int8 *)SPExternalAlloc(pcbComputedHash);
  if ( !pbComputedHash )
    return -2146893056;
  if ( CryptHashCertificate2(v7, 0, 0i64, a1->pbCertEncoded, a1->cbCertEncoded, pbComputedHash, &pcbComputedHash) )
  {
    v9 = pcbComputedHash;
    *a2 = pbComputedHash;
    *a3 = v9;
    return 0;
  }
  else
  {
    LastError = GetLastError();
    SPExternalFree(pbComputedHash);
    return LastError;
  }
}

//----- (000000018000F5C0) ----------------------------------------------------
DWORD __fastcall SPLoadCertificate(unsigned __int8 *a1, DWORD LastError, const struct _CERT_CONTEXT **a3)
{
  HCERTSTORE v6; // r14
  int v7; // r15d
  __int64 v8; // rbp
  unsigned int v9; // ebx
  const BYTE *v10; // rsi
  PCCERT_CONTEXT pCertContext; // [rsp+60h] [rbp+18h] BYREF

  pCertContext = 0i64;
  if ( !a3 )
    return -2146893052;
  if ( *a3 )
    CertFreeCertificateContext(*a3);
  *a3 = 0i64;
  v6 = CertOpenStore((LPCSTR)2, 0, 0i64, 4u, 0i64);
  if ( !v6 )
    return GetLastError();
  v7 = 1;
  while ( LastError >= 4 )
  {
    v8 = *(unsigned int *)a1;
    v9 = LastError - 4;
    v10 = a1 + 4;
    if ( (unsigned int)v8 > v9 )
      break;
    if ( !CertAddEncodedCertificateToStore(v6, 1u, v10, v8, 2u, &pCertContext) )
    {
      LastError = GetLastError();
      goto LABEL_12;
    }
    a1 = (unsigned __int8 *)&v10[v8];
    LastError = v9 - v8;
    if ( v7 )
    {
      v7 = 0;
      *a3 = pCertContext;
    }
    else
    {
      CertFreeCertificateContext(pCertContext);
    }
    pCertContext = 0i64;
    if ( !LastError )
      goto LABEL_12;
  }
  LastError = -2146893052;
LABEL_12:
  CertCloseStore(v6, 0);
  if ( LastError )
  {
    if ( pCertContext )
      CertFreeCertificateContext(pCertContext);
    if ( *a3 )
    {
      CertFreeCertificateContext(*a3);
      *a3 = 0i64;
    }
  }
  return LastError;
}

//----- (000000018000F6EC) ----------------------------------------------------
__int64 __fastcall SpQueryApplicationProtocol(
        struct CSslUserContext *a1,
        struct _SecPkgContext_ApplicationProtocol *a2)
{
  _OWORD *v4; // rax
  __int64 v5; // rcx
  __int128 v6; // xmm1

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 108i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
  v4 = (_OWORD *)*((_QWORD *)a1 + 49);
  if ( v4 )
  {
    v5 = 2i64;
    do
    {
      *(_OWORD *)&a2->ProtoNegoStatus = *v4;
      *(_OWORD *)&a2->ProtocolId[7] = v4[1];
      *(_OWORD *)&a2->ProtocolId[23] = v4[2];
      *(_OWORD *)&a2->ProtocolId[39] = v4[3];
      *(_OWORD *)&a2->ProtocolId[55] = v4[4];
      *(_OWORD *)&a2->ProtocolId[71] = v4[5];
      *(_OWORD *)&a2->ProtocolId[87] = v4[6];
      a2 = (struct _SecPkgContext_ApplicationProtocol *)((char *)a2 + 128);
      v6 = v4[7];
      v4 += 8;
      *(_OWORD *)&a2[-1].ProtocolId[239] = v6;
      --v5;
    }
    while ( v5 );
    *(_QWORD *)&a2->ProtoNegoStatus = *(_QWORD *)v4;
  }
  else
  {
    memset_0(a2, 0, sizeof(struct _SecPkgContext_ApplicationProtocol));
  }
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000F7A4) ----------------------------------------------------
__int64 __fastcall GetUserKeysCallback(
        struct CSslUserContext *a1,
        void *(__stdcall *a2)(unsigned int),
        void (__stdcall *a3)(void *),
        char a4,
        struct _SecBuffer *a5)
{
  char v5; // di
  unsigned int v8; // ebx
  __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 v11; // rdx
  __int64 v12; // rdx
  _QWORD *v13; // rax
  __int64 v14; // rdx
  __int64 v15; // rdx
  __int64 v16; // rdx
  __int64 v17; // rdx
  CCipherMill *v19; // rcx
  __int64 v20; // rdx
  void *pvBuffer; // rcx
  CCipherMill *v22; // rcx
  __int64 v23; // rdx
  char v24; // [rsp+B0h] [rbp+58h]

  v5 = a4 & 8;
  a5->pvBuffer = 0i64;
  v8 = 0;
  v24 = a4 & 8;
  if ( *((_DWORD *)a1 + 14) )
  {
    if ( (a4 & 1) != 0 )
    {
      v9 = *((_QWORD *)a1 + 5);
      if ( v9 )
      {
        v8 = SslExportKey(*((_QWORD *)a1 + 11), v9, L"OpaqueKeyBlob");
        if ( v8 )
        {
          v19 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_27;
          }
          v20 = 127i64;
LABEL_26:
          WPP_SF_D(*((_QWORD *)v19 + 2), v20, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v8);
          goto LABEL_27;
        }
      }
    }
    if ( (a4 & 2) != 0 )
    {
      v10 = *((_QWORD *)a1 + 6);
      if ( v10 )
      {
        v8 = SslExportKey(*((_QWORD *)a1 + 11), v10, L"OpaqueKeyBlob");
        if ( v8 )
        {
          v19 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_27;
          }
          v20 = 128i64;
          goto LABEL_26;
        }
      }
    }
    v11 = *((_QWORD *)a1 + 55);
    if ( v11 )
    {
      v8 = SslExportKey(*((_QWORD *)a1 + 11), v11, L"OpaqueKeyBlob");
      if ( v8 )
      {
        v19 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          goto LABEL_27;
        v20 = 129i64;
        goto LABEL_26;
      }
    }
    v12 = *((_QWORD *)a1 + 56);
    if ( v12 )
    {
      v8 = SslExportKey(*((_QWORD *)a1 + 11), v12, L"OpaqueKeyBlob");
      if ( v8 )
      {
        v19 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          goto LABEL_27;
        v20 = 130i64;
        goto LABEL_26;
      }
    }
  }
  if ( v5 )
    v13 = SPExternalAlloc(0x3Du);
  else
    v13 = PvExtVirtualAlloc(0x3Du);
  if ( v13 )
  {
    a5->pvBuffer = v13;
    a5->cbBuffer = 61;
    a5->BufferType = 1;
    *v13 = *((_QWORD *)a1 + 12);
    v13[1] = *((_QWORD *)a1 + 13);
    *((_DWORD *)v13 + 4) = *((_DWORD *)a1 + 29);
    *(_QWORD *)((char *)v13 + 20) = *((_QWORD *)a1 + 15);
    *(_QWORD *)((char *)v13 + 28) = *((_QWORD *)a1 + 16);
    *((_WORD *)v13 + 18) = *((_WORD *)a1 + 68);
    *((_WORD *)v13 + 19) = *((_WORD *)a1 + 69);
    *((_DWORD *)v13 + 10) = *((_DWORD *)a1 + 36);
    *((_BYTE *)v13 + 44) = *((_BYTE *)a1 + 456);
    *(_DWORD *)((char *)v13 + 45) = 0;
    *(_DWORD *)((char *)v13 + 49) = 0;
    *(_DWORD *)((char *)v13 + 53) = 0;
    *(_DWORD *)((char *)v13 + 57) = 0;
    if ( *((_DWORD *)a1 + 14) )
    {
      if ( (a4 & 1) != 0 )
      {
        v14 = *((_QWORD *)a1 + 5);
        if ( v14 )
        {
          v8 = SslExportKey(*((_QWORD *)a1 + 11), v14, L"OpaqueKeyBlob");
          if ( v8 )
          {
            v22 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
            {
              goto LABEL_21;
            }
            v23 = 131i64;
            goto LABEL_47;
          }
        }
      }
      if ( (a4 & 2) != 0 )
      {
        v15 = *((_QWORD *)a1 + 6);
        if ( v15 )
        {
          v8 = SslExportKey(*((_QWORD *)a1 + 11), v15, L"OpaqueKeyBlob");
          if ( v8 )
          {
            v22 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
            {
              goto LABEL_21;
            }
            v23 = 132i64;
            goto LABEL_47;
          }
        }
      }
      v16 = *((_QWORD *)a1 + 55);
      if ( v16 )
      {
        v8 = SslExportKey(*((_QWORD *)a1 + 11), v16, L"OpaqueKeyBlob");
        if ( v8 )
        {
          v22 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_21;
          }
          v23 = 133i64;
          goto LABEL_47;
        }
      }
      v17 = *((_QWORD *)a1 + 56);
      if ( v17 )
      {
        v8 = SslExportKey(*((_QWORD *)a1 + 11), v17, L"OpaqueKeyBlob");
        if ( v8 )
        {
          v22 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_21;
          }
          v23 = 134i64;
LABEL_47:
          WPP_SF_D(*((_QWORD *)v22 + 2), v23, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v8);
LABEL_21:
          v5 = v24;
LABEL_27:
          pvBuffer = a5->pvBuffer;
          if ( pvBuffer )
          {
            if ( v5 )
              SPExternalFree(pvBuffer);
            else
              FreeExtVirtualAlloc(pvBuffer);
            a5->pvBuffer = 0i64;
          }
          *(_QWORD *)&a5->cbBuffer = 0i64;
        }
      }
    }
    return v8;
  }
  return 2148074240i64;
}
// 18000F9D0: conditional instruction was optimized away because ebx.4==0
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082320: using guessed type wchar_t aOpaquekeyblob[14];
// 180098528: using guessed type __int64 __fastcall SslExportKey(_QWORD, _QWORD, _QWORD);

//----- (000000018000F9F8) ----------------------------------------------------
DWORD __fastcall SpQueryRemoteCertContext(struct CSslUserContext *a1, const CERT_CONTEXT **a2)
{
  unsigned __int8 *v4; // rcx
  DWORD result; // eax
  const CERT_CONTEXT *v6; // rdi
  __int64 v7; // rax
  DWORD LastError; // eax
  DWORD v9; // eax
  int pvData; // [rsp+20h] [rbp-18h] BYREF
  __int64 v11; // [rsp+28h] [rbp-10h]
  PCCERT_CONTEXT pCertContext; // [rsp+40h] [rbp+8h] BYREF

  pCertContext = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids);
  v4 = (unsigned __int8 *)*((_QWORD *)a1 + 19);
  if ( !v4 )
    return -2146893042;
  result = SPLoadCertificate(v4, *((_DWORD *)a1 + 40), &pCertContext);
  if ( !result )
  {
    v6 = pCertContext;
    if ( *((_QWORD *)a1 + 25) )
    {
      v11 = *((_QWORD *)a1 + 25);
      pvData = *((_DWORD *)a1 + 52);
      if ( !CertSetCertificateContextProperty(pCertContext, 0x46u, 0, &pvData)
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      {
        LastError = GetLastError();
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          13i64,
          &WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids,
          LastError);
      }
    }
    v7 = *((_QWORD *)a1 + 27);
    if ( v7 )
    {
      if ( *((_DWORD *)a1 + 56) )
      {
        pvData = *((_DWORD *)a1 + 56);
        v11 = v7;
        if ( !CertSetCertificateContextProperty(v6, 0x77u, 0, &pvData)
          && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        {
          v9 = GetLastError();
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids, v9);
        }
      }
    }
    *a2 = v6;
    return 0;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000FB04) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::InitializeCredentialGroup(
        CCredentialGroup *this,
        unsigned int a2,
        struct _LUID *a3,
        __int64 a4,
        struct LSA_SCHANNEL_CRED *a5,
        unsigned __int16 *a6)
{
  int v9; // r15d
  unsigned int v10; // esi
  int v11; // eax
  unsigned int RandomBits; // esi
  unsigned int v13; // edx
  int v14; // eax
  __int64 v15; // rax
  __int64 v16; // rax
  const WCHAR *v18; // rdx
  CSslCredential *v19; // rax
  CSslCredential *v20; // r13
  CCredentialGroup *v21; // rdx
  CCredentialGroup **v22; // rcx
  unsigned int v23; // r8d
  int v24; // edx
  char v25; // si
  char v26; // r10
  unsigned int v27; // r15d
  PCCERT_CONTEXT *v28; // rcx
  void *v29; // rcx
  HCERTSTORE v30; // rax
  DWORD LastError; // eax
  void *v32; // rcx
  __int64 v33; // rax
  char pvData[4]; // [rsp+50h] [rbp-88h] BYREF
  unsigned int i; // [rsp+54h] [rbp-84h]
  DWORD pcbData; // [rsp+58h] [rbp-80h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+60h] [rbp-78h] BYREF
  struct _UNICODE_STRING v38; // [rsp+70h] [rbp-68h] BYREF
  int v39; // [rsp+80h] [rbp-58h] BYREF
  char v40; // [rsp+88h] [rbp-50h]

  pcbData = 0;
  v9 = 0;
  RtlInitializeResource((PRTL_RESOURCE)((char *)this + 48));
  *((_DWORD *)this + 36) = 1;
  if ( (*(unsigned __int8 (__fastcall **)(int *))(LsaTable + 192))(&v39) )
  {
    *((_DWORD *)this + 53) = v39;
    *((_BYTE *)this + 172) = v40 & 1;
    *((_BYTE *)this + 173) = (v40 & 0x11) == 0;
  }
  StringCchCopyW((char *)this + 216, 260i64, (char *)a6);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_qD(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x15u, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, this, a2);
  v10 = *((_DWORD *)this + 53);
  if ( (g_dwEventLogging & 4) != 0 )
  {
    v18 = (const WCHAR *)pszClientString;
    if ( (a2 & 0x40051555) != 0 )
      v18 = pszServerString;
    RtlInitUnicodeString(&DestinationString, v18);
    RtlInitUnicodeString(&v38, (PCWSTR)this + 108);
    SchEventWrite(&SSLEVENT_CREATE_CRED, L"duub", v10, &v38, &DestinationString, 80i64, a5);
  }
  v11 = CopyTlsParameters(
          *((struct _TLS_PARAMETERS **)a5 + 13),
          *((_DWORD *)a5 + 24),
          0,
          0,
          (struct _TLS_PARAMETERS **)this + 25,
          (unsigned int *)this + 49);
  if ( v11 )
  {
    RandomBits = 87;
    if ( v11 == -2146893056 )
      RandomBits = 14;
    v9 = 10017;
    goto LABEL_35;
  }
  RandomBits = CCredentialGroup::InitializeEnabledProtocols(
                 this,
                 *(_DWORD *)a5,
                 *((_DWORD *)a5 + 18),
                 *((_DWORD *)a5 + 22),
                 a2);
  if ( RandomBits )
  {
    v9 = 10013;
    goto LABEL_35;
  }
  *(struct _LUID *)((char *)this + 740) = *a3;
  *((_QWORD *)this + 94) = a4;
  if ( (a2 & 0x800A2AAA) != 0 )
  {
    if ( bDomainJoined )
    {
      RandomBits = CCredentialGroup::InitializeClientNameInfo(this, a4);
      if ( RandomBits )
        goto LABEL_35;
    }
  }
  RandomBits = GenerateRandomBits((PUCHAR)this + 760, 8u);
  if ( RandomBits )
    goto LABEL_35;
  for ( i = 0; i < *((_DWORD *)a5 + 1); ++i )
  {
    v19 = (CSslCredential *)SPExternalAlloc(0x498u);
    if ( v19 )
      v20 = CSslCredential::CSslCredential(v19);
    else
      v20 = 0i64;
    if ( !v20 )
    {
      RandomBits = 14;
      goto LABEL_35;
    }
    v21 = (CSslCredential *)((char *)v20 + 8);
    v22 = (CCredentialGroup **)*((_QWORD *)this + 5);
    if ( *v22 != (CCredentialGroup *)((char *)this + 32) )
      __fastfail(3u);
    *(_QWORD *)v21 = (char *)this + 32;
    *((_QWORD *)v20 + 2) = v22;
    *v22 = v21;
    *((_QWORD *)this + 5) = v21;
    ++*((_DWORD *)this + 7);
    v23 = *((_DWORD *)a5 + 22);
    v24 = HIWORD(v23) & 1 | 4;
    if ( (v23 & 0x20000) == 0 )
      v24 = HIWORD(*((_DWORD *)a5 + 22)) & 1;
    v25 = v24 | 8;
    if ( (v23 & 0x40000) == 0 )
      v25 = v24;
    if ( g_fDisableOcsp )
    {
      v26 = v25 | 0x10;
    }
    else
    {
      v26 = v25;
      if ( (v23 & 0x180000) == 0x80000 && !g_fEnableOcspForSni )
      {
        v27 = i;
        v28 = (PCCERT_CONTEXT *)(*((_QWORD *)a5 + 1) + 56i64 * i);
        pvData[0] = 0;
        pcbData = 1;
        if ( !CertGetCertificateContextProperty(*v28, 0x79u, pvData, &pcbData) || (v26 = v25, !pvData[0]) )
          v26 = v25 | 0x10;
        goto LABEL_53;
      }
    }
    v27 = i;
LABEL_53:
    RandomBits = CSslCredential::CreateCredential(
                   v20,
                   *((_DWORD *)this + 53),
                   (char *)this + 216,
                   a4,
                   (struct LSA_SCHANNEL_SUB_CRED *)(*((_QWORD *)a5 + 1) + 56i64 * v27),
                   v26,
                   1u,
                   *((_QWORD *)a5 + 3) != 0i64,
                   *((struct _TLS_PARAMETERS **)this + 25),
                   *((_DWORD *)this + 49));
    pcbData = *((unsigned __int8 *)v20 + 76);
    v9 = *((_DWORD *)v20 + 18);
    if ( RandomBits )
      goto LABEL_35;
    if ( *((_DWORD *)v20 + 35) )
      *((_BYTE *)this + 900) = 1;
  }
  CCredentialGroup::InitializeFlags(this, *((_DWORD *)a5 + 22));
  if ( (a2 & 0x40051555) != 0 && (*((_DWORD *)this + 39) & 0x4000) != 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids);
    RandomBits = 87;
    v9 = 10019;
    goto LABEL_35;
  }
  if ( (*((_DWORD *)this + 39) & 0x2000) != 0 )
  {
    *((_DWORD *)a5 + 19) = -1;
    v13 = -1;
  }
  else
  {
    v13 = *((_DWORD *)a5 + 19);
  }
  RandomBits = CCredentialGroup::InitializeMinMaxStrengths(this, v13, *((_DWORD *)a5 + 20));
  if ( RandomBits )
  {
    v9 = 10010;
LABEL_35:
    if ( !pcbData )
      LogCreateCredFailedEvent(*((_DWORD *)this + 53), (const WCHAR *)this + 108, (a2 & 0x40051555) != 0, v9);
    *((_QWORD *)this + 94) = 0i64;
    return RandomBits;
  }
  if ( !BuildUserRequestedAlgList(
          this,
          *((_BYTE *)this + 172),
          *((unsigned int **)a5 + 8),
          *((_DWORD *)a5 + 14),
          (unsigned int **)this + 23,
          (unsigned int *)this + 44,
          (CCredentialGroup *)((char *)this + 192)) )
  {
    RandomBits = -2146893007;
    v9 = 10011;
    goto LABEL_35;
  }
  if ( *((_DWORD *)a5 + 21) )
  {
    v14 = 0;
    if ( *((_DWORD *)a5 + 21) != -1 )
      v14 = *((_DWORD *)a5 + 21);
  }
  else if ( (*((_DWORD *)this + 38) & 0x800A2AAA) != 0 )
  {
    v14 = *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 5);
  }
  else
  {
    v14 = *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 6);
  }
  *((_DWORD *)this + 52) = v14;
  if ( (a2 & 0x40051555) != 0 )
  {
    v29 = (void *)*((_QWORD *)a5 + 2);
    if ( v29 )
    {
      v30 = CertDuplicateStore(v29);
      *((_QWORD *)this + 96) = v30;
      if ( !v30
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        LastError = GetLastError();
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          23i64,
          &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids,
          LastError);
      }
    }
  }
  v15 = *((_QWORD *)a5 + 3);
  if ( v15 )
    *((_QWORD *)this + 100) = v15;
  else
    v15 = *((_QWORD *)this + 100);
  if ( v15 )
  {
    v32 = (void *)*((_QWORD *)a5 + 4);
    if ( v32 )
      CertCloseStore(v32, 0);
  }
  v16 = *((_QWORD *)a5 + 5);
  if ( v16 )
  {
    *((_QWORD *)this + 101) = v16;
    v33 = *((_QWORD *)a5 + 6);
    if ( v33 )
      *((_QWORD *)this + 102) = v33;
  }
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082B38: using guessed type GUID WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids;
// 180092620: using guessed type __int64 LsaTable;
// 180092648: using guessed type int bDomainJoined;
// 1800927A4: using guessed type int g_fDisableOcsp;
// 1800927A8: using guessed type int g_fEnableOcspForSni;
// 18000FB04: using guessed type char pvData[4];

//----- (000000018000FDD4) ----------------------------------------------------
char __fastcall BuildUserRequestedAlgList(
        struct CCredentialGroup *a1,
        char a2,
        unsigned int *a3,
        unsigned int a4,
        unsigned int **a5,
        unsigned int *a6,
        enum efAlgFlags *a7)
{
  int v7; // ebp
  unsigned int *v8; // r14
  char IsUserSpecifiedCipherAllowed; // di
  __int64 v13; // r15
  unsigned int v14; // r8d
  __int64 v16; // r12
  unsigned int *v17; // rax
  unsigned int v18; // esi
  unsigned int v19; // ecx
  _DWORD *v20; // rax
  CCipherMill *v21; // rcx
  __int64 v22; // r9
  __int64 v23; // rdx
  int v24; // eax
  struct kexch *KeyExchangeInfo; // rax
  struct hsel *HashInfo; // rax
  struct csel *CipherInfo; // rax
  unsigned int v28; // ecx
  struct sigsel *SigInfo; // rax
  unsigned int *v30; // [rsp+A0h] [rbp+8h]

  v7 = 0;
  v8 = 0i64;
  IsUserSpecifiedCipherAllowed = 1;
  if ( a1 )
  {
    v13 = 0i64;
    if ( !a3 )
    {
      v14 = *((_DWORD *)a1 + 49);
      if ( !v14 )
        return IsUserSpecifiedCipherAllowed;
LABEL_4:
      IsUserSpecifiedCipherAllowed = CCipherMill::IsUserSpecifiedCipherAllowed(
                                       *((_DWORD *)a1 + 39) & 0x800,
                                       v8,
                                       v13,
                                       v7,
                                       (*((_DWORD *)a1 + 39) >> 12) & 1,
                                       *((_DWORD *)a1 + 39) & 0x800,
                                       *((_DWORD *)a1 + 42),
                                       *((_DWORD *)a1 + 41),
                                       *((_DWORD *)a1 + 38),
                                       a2,
                                       *((_QWORD *)a1 + 25),
                                       v14);
      if ( !IsUserSpecifiedCipherAllowed && !v8 )
        SPExternalFree(0i64);
      return IsUserSpecifiedCipherAllowed;
    }
    v8 = (unsigned int *)SPExternalAlloc(0x44u);
    if ( v8 )
    {
      v16 = 0i64;
      if ( a4 )
      {
        v17 = a3;
        v30 = a3;
        while ( 1 )
        {
          v18 = *v17;
          v19 = 0;
          v20 = &unk_180085640;
          do
          {
            if ( v18 == *v20 )
              goto LABEL_17;
            ++v19;
            ++v20;
          }
          while ( v19 < 0x11 );
          if ( v19 == 17 )
            break;
LABEL_17:
          v24 = v18 & 0xE000;
          switch ( v24 )
          {
            case 8192:
              SigInfo = GetSigInfo(v18);
              if ( !SigInfo || (*((_DWORD *)a1 + 38) & *(_DWORD *)SigInfo) == 0 )
              {
LABEL_42:
                v21 = WPP_GLOBAL_Control;
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                {
                  v23 = 12i64;
                  v22 = v18;
LABEL_40:
                  WPP_SF_D(*((_QWORD *)v21 + 2), v23, &WPP_f57d92ef57843aa8f0882fb6fd501a9b_Traceguids, v22);
                }
                return 0;
              }
              v7 |= 1u;
              break;
            case 24576:
              CipherInfo = GetCipherInfo(v18);
              if ( !CipherInfo )
                goto LABEL_42;
              if ( *((_DWORD *)CipherInfo + 8) != v18 )
                goto LABEL_42;
              v28 = *((_DWORD *)CipherInfo + 10);
              if ( v28 < *((_DWORD *)a1 + 41)
                || v28 > *((_DWORD *)a1 + 42)
                || (*((_DWORD *)a1 + 38) & *(_DWORD *)CipherInfo) == 0 )
              {
                goto LABEL_42;
              }
              v7 |= 8u;
              break;
            case 32768:
              HashInfo = GetHashInfo(v18);
              if ( !HashInfo || (*((_DWORD *)a1 + 38) & *(_DWORD *)HashInfo) == 0 )
                goto LABEL_42;
              v7 |= 2u;
              break;
            case 40960:
              KeyExchangeInfo = GetKeyExchangeInfo(v18);
              if ( !KeyExchangeInfo || (*((_DWORD *)a1 + 38) & *((_DWORD *)KeyExchangeInfo + 1)) == 0 )
                goto LABEL_42;
              v7 |= 4u;
              break;
            default:
              goto LABEL_42;
          }
          if ( !DoesCredAllowAlgId(v8, v13, v18) )
          {
            v8[v13] = v18;
            v13 = (unsigned int)(v13 + 1);
          }
          v16 = (unsigned int)(v16 + 1);
          v17 = ++v30;
          if ( (unsigned int)v16 >= a4 )
            goto LABEL_39;
        }
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          v22 = a3[v16];
          v23 = 11i64;
          goto LABEL_40;
        }
        return 0;
      }
LABEL_39:
      *a5 = v8;
      *a6 = v13;
      *(_DWORD *)a7 = v7;
      v14 = *((_DWORD *)a1 + 49);
      goto LABEL_4;
    }
  }
  return 0;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000FEC0) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::InitializeMinMaxStrengths(
        CCredentialGroup *this,
        unsigned int a2,
        unsigned int a3)
{
  unsigned int *v3; // rdi
  unsigned int *v5; // r14

  v3 = (unsigned int *)((char *)this + 168);
  v5 = (unsigned int *)((char *)this + 164);
  CCipherMill::GetBaseCipherSizes(this, *((_BYTE *)this + 172), (unsigned int *)this + 41, (unsigned int *)this + 42);
  if ( a2 )
  {
    if ( a2 == -1 )
    {
      a2 = 0;
    }
    else if ( a2 > *v3 )
    {
      return 2148074289i64;
    }
  }
  else
  {
    a2 = *v5;
    if ( *v5 < 0x28 )
      a2 = 40;
  }
  *v5 = a2;
  if ( a3 )
  {
    if ( a3 == -1 )
    {
      *v3 = 0;
    }
    else
    {
      if ( a3 < a2 )
        return 2148074289i64;
      *v3 = a3;
    }
  }
  if ( *v3 >= a2 )
    return 0i64;
  return 2148074289i64;
}

//----- (000000018000FF48) ----------------------------------------------------
void __fastcall CCipherMill::GetBaseCipherSizes(CCipherMill *this, char a2, unsigned int *a3, unsigned int *a4)
{
  CMasterCipherInfo *v7; // rax
  unsigned int v8; // r8d
  unsigned int v9; // edx
  unsigned int *v10; // rcx
  unsigned int v11; // eax
  unsigned int v12; // eax

  *a3 = 0;
  *a4 = 0;
  RtlAcquireResourceShared(&Resource, 1u);
  v7 = xmmword_1800925B0;
  if ( a2 )
    v7 = *(&xmmword_1800925B0 + 1);
  if ( v7 )
  {
    v8 = *((_DWORD *)v7 + 2);
    v9 = 0;
    if ( v8 )
    {
      v10 = (unsigned int *)(*(_QWORD *)v7 + 20i64);
      do
      {
        if ( v9 )
        {
          v11 = *a3;
          if ( *a3 >= *v10 )
            v11 = *v10;
        }
        else
        {
          v11 = *v10;
        }
        *a3 = v11;
        v12 = *a4;
        if ( *a4 <= *v10 )
          v12 = *v10;
        ++v9;
        v10 += 216;
        *a4 = v12;
      }
      while ( v9 < v8 );
    }
  }
  RtlReleaseResource(&Resource);
}

//----- (000000018000FFF4) ----------------------------------------------------
void __fastcall CCredentialGroup::InitializeFlags(CCredentialGroup *this, int a2)
{
  int v2; // eax

  if ( (a2 & 2) != 0 )
    *((_DWORD *)this + 39) |= 1u;
  if ( (a2 & 4) != 0 )
    *((_DWORD *)this + 39) |= 2u;
  if ( (a2 & 8) != 0 )
    *((_DWORD *)this + 39) |= 4u;
  if ( (a2 & 0x4000000) != 0 )
    *((_DWORD *)this + 39) |= 0x4000u;
  if ( (a2 & 0x10) != 0 )
    *((_DWORD *)this + 39) |= 8u;
  if ( (a2 & 0x20) != 0 )
    *((_DWORD *)this + 39) &= ~4u;
  if ( (a2 & 0x40) != 0 )
    *((_DWORD *)this + 39) &= ~8u;
  if ( (a2 & 0x80u) != 0 )
    *((_DWORD *)this + 39) |= 0x20u;
  if ( (a2 & 0x40000) != 0 )
    *((_DWORD *)this + 39) |= 0x80u;
  if ( (a2 & 0x80000) != 0 )
  {
    v2 = *((_DWORD *)this + 39) | 0x100;
    *((_DWORD *)this + 39) = v2;
    if ( (a2 & 0x100000) == 0 )
      *((_DWORD *)this + 39) = v2 | 0x200;
  }
  if ( (a2 & 0x200000) != 0 )
    *((_DWORD *)this + 39) |= 0x400u;
  if ( (a2 & 0x400000) != 0 )
    *((_DWORD *)this + 39) |= 0x800u;
  if ( (a2 & 0x800000) != 0 )
    *((_DWORD *)this + 39) |= 0x1000u;
  if ( (a2 & 0x2000000) != 0 )
    *((_DWORD *)this + 39) |= 0x2000u;
  if ( (a2 & 0x8000) != 0 )
    *((_DWORD *)this + 40) |= 0x2000u;
  if ( (a2 & 0x100) != 0 )
    *((_DWORD *)this + 40) |= 0x100u;
  if ( (a2 & 0x200) != 0 )
    *((_DWORD *)this + 40) |= 0x200u;
  if ( (a2 & 0x400) != 0 )
    *((_DWORD *)this + 40) |= 0x400u;
  if ( (a2 & 0x800) != 0 )
    *((_DWORD *)this + 40) |= 0x800u;
  if ( (a2 & 0x1000) != 0 )
    *((_DWORD *)this + 40) |= 0x1000u;
  if ( (a2 & 0x4000) != 0 )
    *((_DWORD *)this + 40) |= 0x4000u;
}

//----- (000000018001011C) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::InitializeEnabledProtocols(
        CCredentialGroup *this,
        unsigned int a2,
        int a3,
        int a4,
        unsigned int a5)
{
  __int64 v6; // r9
  CCipherMill *v10; // rcx
  unsigned int ProtocolsWithCipherSuitesEnabled; // eax
  __int64 v12; // rcx
  unsigned int v13; // esi
  int v14; // eax
  int v15; // ebp
  unsigned __int64 v16; // r8
  unsigned int v17; // edx
  __int64 v18; // rax
  unsigned __int64 v19; // r9
  int v20; // eax
  __int64 v21; // r9
  int v22; // eax

  v6 = CSslGlobals::m_ProtEnabled;
  if ( CSslGlobals::m_bFipsMode )
    v6 = CSslGlobals::m_ProtEnabled & 0xBFFFFFCF;
  *((_DWORD *)this + 38) = v6;
  v10 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, v6);
    v10 = WPP_GLOBAL_Control;
  }
  ProtocolsWithCipherSuitesEnabled = CCipherMill::GetProtocolsWithCipherSuitesEnabled(v10, *((_BYTE *)this + 172));
  v13 = ProtocolsWithCipherSuitesEnabled;
  if ( (CCipherMill **)v12 != &WPP_GLOBAL_Control && (*(_BYTE *)(v12 + 28) & 4) != 0 )
    WPP_SF_D(
      *(_QWORD *)(v12 + 16),
      12i64,
      &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids,
      ProtocolsWithCipherSuitesEnabled);
  v14 = v13 & *((_DWORD *)this + 38);
  v15 = a4 & 0x1000000;
  if ( v15 )
    v14 &= 0xF0000u;
  if ( a3 )
  {
    v17 = a3 & v14;
  }
  else
  {
    v16 = *((_QWORD *)this + 25);
    v17 = v14 & ~CSslGlobals::m_ProtDisabledByDefault;
    v18 = *((unsigned int *)this + 49);
    *((_DWORD *)this + 38) = v17;
    v19 = v16 + 40 * v18;
    if ( v16 < v19 )
    {
      do
      {
        if ( !*(_DWORD *)v16 )
        {
          v20 = *(_DWORD *)(v16 + 16);
          if ( v20 )
          {
            if ( (*(_BYTE *)(v16 + 32) & 1) == 0 )
              *((_DWORD *)this + 38) &= ~v20;
          }
        }
        v16 += 40i64;
      }
      while ( v16 < v19 );
      v17 = *((_DWORD *)this + 38);
    }
  }
  if ( a2 >= 5 )
  {
    if ( !v15 )
      v17 &= 0x3FF0u;
  }
  else
  {
    v17 &= 0xFFFFCFFF;
  }
  if ( (v17 & 0x3000) != 0 )
    v17 &= 0xFFFFFFCF;
  v21 = v17 & ((a5 & 0x40051555) != 0 ? 1074074965 : -2146817366);
  *((_DWORD *)this + 38) = v21;
  v22 = v17 & ((a5 & 0x40051555) != 0 ? 1074074965 : -2146817366);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, v21);
    v22 = *((_DWORD *)this + 38);
  }
  return v22 == 0 ? 0x80090331 : 0;
}
// 1800101A3: variable 'v12' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800919F8: using guessed type unsigned int CSslGlobals::m_ProtEnabled;
// 1800919FC: using guessed type unsigned int CSslGlobals::m_ProtDisabledByDefault;
// 180092F18: using guessed type int CSslGlobals::m_bFipsMode;

//----- (00000001800102DC) ----------------------------------------------------
__int64 __fastcall IsRemoteCertificateBlacklisted(
        struct _TLS_PARAMETERS *a1,
        unsigned int a2,
        const struct _CERT_CONTEXT *a3,
        struct _PUBLICKEY *a4,
        struct _SecPkgContext_ApplicationProtocol *a5,
        struct CCipherSuiteInfo *a6,
        unsigned __int8 a7)
{
  unsigned int v7; // ebx
  struct CEccCurveInfo *v11; // r13
  PCERT_INFO pCertInfo; // rdx
  unsigned int PublicKeyLength; // r12d
  int v15; // edi
  DWORD CngHashAndSignatureString; // eax
  __int64 v17; // r9
  unsigned int EccCurveType; // eax
  CCipherMill *v20; // rcx
  unsigned int CurveInfo; // eax
  ULONG v22; // eax
  CCipherMill *v23; // rcx
  __int64 v24; // rdx
  DWORD v25; // [rsp+20h] [rbp-E0h]
  bool v26; // [rsp+60h] [rbp-A0h]
  unsigned int v27; // [rsp+64h] [rbp-9Ch] BYREF
  unsigned int v28; // [rsp+68h] [rbp-98h]
  struct CEccCurveInfo *v29; // [rsp+70h] [rbp-90h] BYREF
  struct _UNICODE_STRING *v30; // [rsp+78h] [rbp-88h]
  struct _UNICODE_STRING v31; // [rsp+80h] [rbp-80h] BYREF
  struct _TLS_PARAMETERS *v32; // [rsp+90h] [rbp-70h]
  unsigned __int16 v33[64]; // [rsp+A0h] [rbp-60h] BYREF
  unsigned __int16 v34[64]; // [rsp+120h] [rbp+20h] BYREF
  char v35[512]; // [rsp+1A0h] [rbp+A0h] BYREF

  v7 = 0;
  v28 = a2;
  v32 = a1;
  v27 = 0;
  v29 = 0i64;
  v26 = 0;
  v11 = 0i64;
  memset_0(v34, 0, sizeof(v34));
  memset_0(v33, 0, sizeof(v33));
  memset_0(v35, 0, 0x1FEui64);
  *(_DWORD *)&v31.Length = 33423360;
  v31.Buffer = (PWSTR)v35;
  v30 = 0i64;
  if ( !a1 || !a2 || !a3 || !a6 || !a4 || !*(_QWORD *)a4 || !a3->pCertInfo )
    return 2148074244i64;
  pCertInfo = a3->pCertInfo;
  if ( a5
    && a5->ProtoNegoStatus == SecApplicationProtocolNegotiationStatus_Success
    && a5->ProtoNegoExt == SecApplicationProtocolNegotiationExt_ALPN )
  {
    v22 = CreateUnicodeStringFromAlpnId(a5->ProtocolId, a5->ProtocolIdSize, 1, &v31);
    v17 = v22;
    if ( v22 )
    {
      v23 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074244i64;
      v24 = 16i64;
      goto LABEL_38;
    }
    pCertInfo = a3->pCertInfo;
    v30 = &v31;
  }
  PublicKeyLength = CertGetPublicKeyLength(1u, &pCertInfo->SubjectPublicKeyInfo);
  v15 = *(_DWORD *)(*(_QWORD *)a4 + 4i64);
  if ( !PublicKeyLength || !v15 )
    return 2148074244i64;
  if ( v15 == 8707 )
  {
    EccCurveType = CertGetEccCurveType((__int64)a3, &v27);
    v17 = EccCurveType;
    if ( EccCurveType )
    {
      v23 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074244i64;
      v24 = 17i64;
      goto LABEL_38;
    }
    CurveInfo = CCipherMill::GetCurveInfo(v20, v27, &v29);
    v17 = CurveInfo;
    if ( CurveInfo )
    {
      v23 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074244i64;
      v24 = 18i64;
      goto LABEL_38;
    }
    v11 = v29;
  }
  v27 = 64;
  CngHashAndSignatureString = GetCngHashAndSignatureString(a3, v33, &v27, (char *)v34, v25);
  v17 = CngHashAndSignatureString;
  if ( CngHashAndSignatureString )
  {
    v23 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074244i64;
    v24 = 19i64;
LABEL_38:
    WPP_SF_D(*((_QWORD *)v23 + 2), v24, &WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids, v17);
    return 2148074244i64;
  }
  if ( !a7 && v15 == 41984 )
    v26 = *((_DWORD *)a6 + 8) == 41984;
  if ( IsCertificateBlacklisted(v32, v28, v15, PublicKeyLength, v11, v26, 0, v34, v33, v30, 1) )
    return (unsigned int)-2146893007;
  return v7;
}
// 18001042C: variable 'v25' is possibly undefined
// 1800104EC: variable 'v20' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018001050C) ----------------------------------------------------
DWORD __fastcall GetCngHashAndSignatureString(
        const struct _CERT_CONTEXT *a1,
        unsigned __int16 *a2,
        unsigned int *a3,
        char *a4,
        DWORD a5)
{
  unsigned int v8; // ebx
  bool v9; // zf
  DWORD v10; // edx
  unsigned __int16 *v11; // rax
  __int64 v13; // rbx

  v8 = 0;
  if ( !a1 || !a2 || !a3 || 2 * (unsigned __int64)*a3 > 0xFFFFFFFF )
    return 87;
  a5 = 2 * *a3;
  if ( CertGetCertificateContextProperty(a1, 0x59u, a2, &a5) )
  {
    v9 = a5 >> 1 == 0;
    v10 = a5 >> 1;
    a2[(a5 >> 1) - 1] = 0;
    if ( v9 )
    {
LABEL_10:
      if ( v8 == v10 )
        return 1359;
    }
    else
    {
      v11 = a2;
      while ( *v11 != 47 )
      {
        ++v8;
        ++v11;
        if ( v8 >= v10 )
          goto LABEL_10;
      }
      *a3 = v8;
      a2[v8] = 0;
    }
    v13 = v8 + 1;
    if ( (_DWORD)v13 != v10
      && (!a4 || v10 - (unsigned int)v13 >= 0x40 || !(unsigned int)StringCchCopyW(a4, 64i64, (char *)&a2[v13])) )
    {
      return 0;
    }
    return 1359;
  }
  *a3 = a5 >> 1;
  return GetLastError();
}

//----- (0000000180010610) ----------------------------------------------------
__int64 __fastcall StringCchCopyW(char *a1, __int64 a2, char *a3)
{
  __int64 v3; // r9
  signed __int64 v4; // r10
  unsigned __int16 v5; // ax
  unsigned __int16 *v6; // rax
  __int64 result; // rax

  if ( (unsigned __int64)(a2 - 1) > 0x7FFFFFFE )
  {
    result = 2147942487i64;
    if ( a2 )
      *(_WORD *)a1 = 0;
  }
  else
  {
    v3 = 2147483646 - a2;
    v4 = a3 - a1;
    do
    {
      if ( !(v3 + a2) )
        break;
      v5 = *(_WORD *)&a1[v4];
      if ( !v5 )
        break;
      *(_WORD *)a1 = v5;
      a1 += 2;
      --a2;
    }
    while ( a2 );
    v6 = (unsigned __int16 *)(a1 - 2);
    if ( a2 )
      v6 = (unsigned __int16 *)a1;
    *v6 = 0;
    return a2 == 0 ? 0x8007007A : 0;
  }
  return result;
}

//----- (0000000180010674) ----------------------------------------------------
__int64 __fastcall CSslCredManager::CreateCredentialGroup(
        CSslCredManager *this,
        struct CCredentialGroup **a2,
        __int64 a3,
        struct _LUID *a4,
        void *a5,
        struct LSA_SCHANNEL_CRED *a6,
        unsigned __int16 *a7)
{
  unsigned int v9; // r13d
  CCredentialGroup *v11; // rax
  CCredentialGroup *v12; // rax
  struct CCredentialGroup *v13; // rdi
  unsigned int v14; // ebx
  CSslCredManager **v15; // rdx
  CSslCredManager *v16; // rax
  __int64 v18; // r8
  unsigned int v19; // ebp
  CCipherMill *v20; // rcx
  unsigned int v21; // edi
  __int64 v22; // rsi
  int v23; // r9d
  int v24; // r9d
  int v25; // r9d
  CCipherMill *v26; // rcx
  __int64 v27; // r9
  __int64 v28; // r9
  struct LSA_SCHANNEL_CRED *v29; // [rsp+20h] [rbp-38h]

  v9 = a3;
  if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
    goto LABEL_2;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_d(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x10u,
        (__int64)&WPP_d7209deee65a328fe195e0fa91b71573_Traceguids,
        *(_DWORD *)a6);
  }
  DbgDumpSubCreds(*((struct LSA_SCHANNEL_SUB_CRED **)a6 + 1), *((_DWORD *)a6 + 1), a3);
  v19 = *((_DWORD *)a6 + 14);
  if ( v19 && *((_QWORD *)a6 + 8) )
  {
    v20 = WPP_GLOBAL_Control;
    v21 = 0;
    v22 = 0i64;
    do
    {
      if ( v20 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v20 + 28) & 4) != 0 )
      {
        LODWORD(v29) = *(_DWORD *)(v22 + *((_QWORD *)a6 + 8));
        WPP_SF_dD(*((_QWORD *)v20 + 2), 0x11u, v18, v21, v29);
        v20 = WPP_GLOBAL_Control;
      }
      ++v21;
      v22 += 4i64;
    }
    while ( v21 < v19 );
  }
  else
  {
    v20 = WPP_GLOBAL_Control;
  }
  if ( v20 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v20 + 28) & 4) != 0 )
  {
    WPP_SF_D(*((_QWORD *)v20 + 2), 18i64, &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids, *((unsigned int *)a6 + 18));
    v20 = WPP_GLOBAL_Control;
  }
  v23 = *((_DWORD *)a6 + 19);
  if ( v23 && v20 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v20 + 28) & 4) != 0 )
  {
    WPP_SF_d(*((_QWORD *)v20 + 2), 0x13u, (__int64)&WPP_d7209deee65a328fe195e0fa91b71573_Traceguids, v23);
    v20 = WPP_GLOBAL_Control;
  }
  v24 = *((_DWORD *)a6 + 20);
  if ( v24 && v20 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v20 + 28) & 4) != 0 )
    WPP_SF_d(*((_QWORD *)v20 + 2), 0x14u, (__int64)&WPP_d7209deee65a328fe195e0fa91b71573_Traceguids, v24);
  DbgDumpTlsParams(*((struct _TLS_PARAMETERS **)a6 + 13), *((unsigned int *)a6 + 24), v18);
  v25 = *((_DWORD *)a6 + 21);
  if ( v25 )
  {
    v26 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      goto LABEL_37;
    WPP_SF_d(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x15u, (__int64)&WPP_d7209deee65a328fe195e0fa91b71573_Traceguids, v25);
  }
  v26 = WPP_GLOBAL_Control;
LABEL_37:
  v27 = *((unsigned int *)a6 + 22);
  if ( (_DWORD)v27 && v26 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v26 + 28) & 4) != 0 )
  {
    WPP_SF_D(*((_QWORD *)v26 + 2), 22i64, &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids, v27);
    v26 = WPP_GLOBAL_Control;
  }
  v28 = *((unsigned int *)a6 + 23);
  if ( (_DWORD)v28 && v26 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v26 + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)v26 + 2), 23i64, &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids, v28);
LABEL_2:
  v11 = (CCredentialGroup *)SPExternalAlloc(0x388u);
  if ( v11 && (v12 = CCredentialGroup::CCredentialGroup(v11), (v13 = v12) != 0i64) )
  {
    v14 = CCredentialGroup::InitializeCredentialGroup(v12, v9, a4, (__int64)a5, a6, a7);
    if ( v14 )
    {
      (*(void (__fastcall **)(struct CCredentialGroup *, __int64))(*(_QWORD *)v13 + 8i64))(v13, 1i64);
    }
    else
    {
      RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
      v15 = (CSslCredManager **)*((_QWORD *)this + 7);
      v16 = (struct CCredentialGroup *)((char *)v13 + 8);
      if ( *v15 != (CSslCredManager *)((char *)this + 48) )
        __fastfail(3u);
      *(_QWORD *)v16 = (char *)this + 48;
      *((_QWORD *)v13 + 2) = v15;
      *v15 = v16;
      *((_QWORD *)this + 7) = v16;
      RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
      _InterlockedIncrement((volatile signed __int32 *)v13 + 6);
      *a2 = v13;
    }
  }
  else
  {
    return 14;
  }
  return v14;
}
// 180039487: variable 'a3' is possibly undefined
// 1800394CE: variable 'v18' is possibly undefined
// 1800394CE: variable 'v29' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180010780) ----------------------------------------------------
CCredentialGroup *__fastcall CCredentialGroup::CCredentialGroup(CCredentialGroup *this)
{
  CCredentialGroup *result; // rax

  *(_QWORD *)this = &CCredentialGroup::`vftable';
  *((_DWORD *)this + 36) = 0;
  *(_QWORD *)((char *)this + 156) = 0i64;
  *((_WORD *)this + 86) = 0;
  *((_DWORD *)this + 44) = 0;
  *((_QWORD *)this + 23) = 0i64;
  *((_QWORD *)this + 24) = 0i64;
  *((_QWORD *)this + 25) = 0i64;
  *(_QWORD *)((char *)this + 212) = 0i64;
  memset_0((char *)this + 220, 0, 0x204ui64);
  *((_QWORD *)this + 94) = 0i64;
  *((_QWORD *)this + 5) = (char *)this + 32;
  *((_QWORD *)this + 4) = (char *)this + 32;
  result = this;
  *((_QWORD *)this + 96) = 0i64;
  *((_QWORD *)this + 97) = 0i64;
  *((_QWORD *)this + 98) = 0i64;
  *((_QWORD *)this + 99) = 0i64;
  *((_QWORD *)this + 102) = 0i64;
  *((_QWORD *)this + 103) = 0i64;
  *((_QWORD *)this + 104) = 0i64;
  *((_QWORD *)this + 105) = 0i64;
  *((_QWORD *)this + 106) = 0i64;
  *((_QWORD *)this + 108) = 0i64;
  *((_QWORD *)this + 109) = 0i64;
  *((_QWORD *)this + 110) = 0i64;
  *((_QWORD *)this + 111) = 0i64;
  *((_DWORD *)this + 224) = 0;
  *((_BYTE *)this + 900) = 0;
  return result;
}
// 18007D0D8: using guessed type void *CCredentialGroup::`vftable';

//----- (0000000180010874) ----------------------------------------------------
__int64 __fastcall SpCommonAcquireCredentialsHandle(
        struct _UNICODE_STRING *a1,
        unsigned int a2,
        struct _LUID *a3,
        struct _SCHANNEL_CRED *a4,
        unsigned __int64 *a5,
        union _LARGE_INTEGER *a6)
{
  int ProcessImageName; // eax
  __int64 v10; // rdx
  __int64 v11; // r8
  __int64 v12; // r9
  CCipherMill *v13; // rcx
  int v14; // r12d
  char v15; // r15
  NTSTATUS v16; // eax
  CCipherMill *v17; // rax
  signed int v18; // eax
  int v19; // ecx
  char v20; // r15
  bool v21; // zf
  unsigned int v22; // ebx
  unsigned int DefaultMachineCred; // ebx
  union _LARGE_INTEGER *v24; // r14
  CCredentialGroup **v25; // rsi
  int v26; // eax
  unsigned int v27; // ecx
  unsigned int v28; // ebx
  char v29; // al
  unsigned int cbBuffer; // edx
  CCredentialGroup *v32; // rcx
  unsigned int updated; // ebx
  NTSTATUS v34; // ecx
  unsigned __int16 v35; // dx
  _DWORD *v36; // rax
  struct _SCHANNEL_CRED **v37; // rax
  signed int v38; // eax
  void *pvBuffer; // rcx
  __int64 DesiredAccess; // [rsp+20h] [rbp-E0h]
  char v41; // [rsp+41h] [rbp-BFh]
  unsigned int v42; // [rsp+50h] [rbp-B0h] BYREF
  struct _SecBuffer v43; // [rsp+58h] [rbp-A8h] BYREF
  void *TargetHandle; // [rsp+68h] [rbp-98h] BYREF
  struct _SecBuffer v45; // [rsp+70h] [rbp-90h] BYREF
  CCredentialGroup *v46; // [rsp+80h] [rbp-80h] BYREF
  unsigned int v47; // [rsp+88h] [rbp-78h] BYREF
  unsigned int v48; // [rsp+8Ch] [rbp-74h]
  struct _LUID v49; // [rsp+90h] [rbp-70h] BYREF
  __int64 v50; // [rsp+98h] [rbp-68h] BYREF
  struct _SECPKG_CALL_INFO v51; // [rsp+A0h] [rbp-60h] BYREF
  struct _LUID v52; // [rsp+B8h] [rbp-48h] BYREF
  char v53; // [rsp+C8h] [rbp-38h]
  int v54; // [rsp+CCh] [rbp-34h]
  HANDLE SourceHandle; // [rsp+D0h] [rbp-30h]
  int v56[18]; // [rsp+E0h] [rbp-20h] BYREF
  int v57; // [rsp+128h] [rbp+28h]
  unsigned __int16 v58[264]; // [rsp+150h] [rbp+50h] BYREF

  v48 = a2;
  *(_QWORD *)&v43.cbBuffer = a5;
  v46 = 0i64;
  memset_0(v56, 0, 0x70ui64);
  TargetHandle = 0i64;
  v42 = 0;
  v45 = 0i64;
  v50 = 0i64;
  v41 = 0;
  if ( (unsigned int)SchannelInit(0)
    && (*(unsigned __int8 (__fastcall **)(struct _SECPKG_CALL_INFO *))(LsaTable + 192))(&v51) )
  {
    memset_0(v58, 0, 0x208ui64);
    ProcessImageName = GetProcessImageName(v58, &v51);
    v12 = (unsigned int)ProcessImageName;
    if ( ProcessImageName < 0 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_DD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x32u,
          (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
          ProcessImageName,
          v51.ProcessId);
    }
    else
    {
      v13 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            51i64,
            &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
            v51.ProcessId);
          v13 = WPP_GLOBAL_Control;
        }
        if ( v13 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v13 + 28) & 4) != 0 )
          WPP_SF_S(*((_QWORD *)v13 + 2), 0x34u, (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, v58);
      }
    }
    v14 = v51.Attributes & 0x40;
    v15 = v51.Attributes & 1;
    if ( (v51.Attributes & 0x11) == 0 )
    {
      v41 = 1;
      if ( (*(int (__fastcall **)(unsigned int *, _QWORD, _QWORD, struct _SecBuffer *, _QWORD))(LsaTable + 488))(
             &v42,
             0i64,
             0i64,
             &v45,
             0i64) < 0 )
        goto LABEL_61;
      if ( v42 == 4 )
      {
        v25 = *(CCredentialGroup ***)&v43.cbBuffer;
        cbBuffer = v45.cbBuffer;
        v43.BufferType = 1;
        v32 = *(CCredentialGroup **)v45.pvBuffer;
        v43.pvBuffer = (char *)v45.pvBuffer + 8;
        v43.cbBuffer = v45.cbBuffer - 8;
        *v25 = v32;
        v46 = v32;
        if ( v32 )
        {
          if ( cbBuffer != 8 )
          {
            v24 = a6;
            updated = UpdatePrivateKeysForCreds(v32, &v43, v14 != 0);
            CCredentialGroup::GetCredentialExpirationTime(v46, a6);
            v28 = TranslateToSecurityStatus(updated);
LABEL_124:
            v20 = v41;
            goto LABEL_45;
          }
          v28 = -2146893043;
        }
        else
        {
          v28 = -2146893052;
        }
LABEL_123:
        v24 = a6;
        goto LABEL_124;
      }
    }
    if ( (*(int (__fastcall **)(struct _LUID *, __int64, __int64, __int64))(LsaTable + 128))(&v52, v10, v11, v12) >= 0 )
    {
      if ( a3 && (a3->LowPart || a3->HighPart) )
      {
        if ( !v53 )
        {
          v34 = -1073741727;
LABEL_120:
          v18 = RtlNtStatusToDosError(v34);
          goto LABEL_121;
        }
        v49 = *a3;
        v16 = (*(__int64 (__fastcall **)(struct _LUID *, void **))(LsaTable + 368))(a3, &TargetHandle);
        if ( v16 >= 0 )
        {
          v17 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          {
            goto LABEL_21;
          }
          v35 = 53;
          goto LABEL_75;
        }
      }
      else
      {
        if ( (char *)SourceHandle - 1 > (char *)0xFFFFFFFFFFFFFFFDi64 )
        {
          v34 = -1073741670;
          goto LABEL_120;
        }
        v49 = v52;
        v16 = NtDuplicateObject(
                (HANDLE)0xFFFFFFFFFFFFFFFFi64,
                SourceHandle,
                (HANDLE)0xFFFFFFFFFFFFFFFFi64,
                &TargetHandle,
                0,
                0,
                2u);
        if ( v16 >= 0 )
        {
          v17 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          {
            goto LABEL_21;
          }
          v35 = 54;
LABEL_75:
          WPP_SF_q(*((_QWORD *)v17 + 2), v35, (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, TargetHandle);
LABEL_21:
          if ( v54 > 1 )
          {
            v56[0] = 4;
            if ( !a4 )
            {
LABEL_34:
              v20 = v41;
LABEL_35:
              if ( (v57 & 0xF0000) != 0 && (v57 & 0xFFF0FFFF) != 0 )
              {
                v28 = -2146893007;
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
                {
                  LODWORD(DesiredAccess) = -2146893007;
                  WPP_SF_Dd(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    0x3Au,
                    (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                    -2146893007,
                    DesiredAccess);
                }
                return v28;
              }
              v21 = a4 == 0i64;
              v22 = v48;
              if ( v21 && (v48 & 0x40051555) != 0 )
              {
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
                {
                  WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 59i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
                }
                DefaultMachineCred = FindDefaultMachineCred(&v46, v22, &v49, TargetHandle, v51.ProcessId, v58);
              }
              else
              {
                DefaultMachineCred = CSslCredManager::CreateCredentialGroup(
                                       CSslCredManager::m_pCredManager,
                                       &v46,
                                       v48,
                                       &v49,
                                       TargetHandle,
                                       (struct LSA_SCHANNEL_CRED *)v56,
                                       v58);
                FreeSchannelCred((struct LSA_SCHANNEL_CRED *)v56, 0);
              }
              v24 = a6;
              if ( DefaultMachineCred )
              {
                v25 = *(CCredentialGroup ***)&v43.cbBuffer;
                goto LABEL_43;
              }
              CCredentialGroup::GetCredentialExpirationTime(v46, a6);
              v25 = *(CCredentialGroup ***)&v43.cbBuffer;
              **(_QWORD **)&v43.cbBuffer = v46;
              if ( v20 )
              {
                if ( !LsaTable )
                {
                  v28 = -2146893052;
                  goto LABEL_45;
                }
                v26 = (*(__int64 (__fastcall **)(unsigned int *, __int64 *, _QWORD, struct _SecBuffer *, _QWORD))(LsaTable + 488))(
                        &v42,
                        &v50,
                        0i64,
                        &v45,
                        0i64);
                DefaultMachineCred = v26;
                if ( v26 >= 0 )
                {
                  if ( v42 != 4 )
                    goto LABEL_43;
                  *(_QWORD *)v45.pvBuffer = *v25;
                  LOBYTE(DesiredAccess) = 1;
                  v26 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, struct _SecBuffer *, _DWORD))(LsaTable + 496))(
                          v42,
                          v50,
                          4i64,
                          &v45,
                          DesiredAccess);
                  if ( v26 >= 0 )
                  {
                    v28 = -2146893055;
                    v29 = 1;
                    goto LABEL_46;
                  }
                }
                v27 = v26;
                goto LABEL_44;
              }
LABEL_43:
              v27 = DefaultMachineCred;
LABEL_44:
              v28 = TranslateToSecurityStatus(v27);
LABEL_45:
              v29 = 0;
LABEL_46:
              if ( !TargetHandle || v29 )
              {
                if ( !v28 )
                  goto LABEL_49;
              }
              else
              {
                if ( !v28 )
                {
LABEL_49:
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v28
                     || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
                  {
                    LODWORD(DesiredAccess) = v28;
                    WPP_SF_DD(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      0x3Du,
                      (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                      v28,
                      DesiredAccess);
                  }
                  return v28;
                }
                NtClose(TargetHandle);
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
                {
                  WPP_SF_q(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    0x3Cu,
                    (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                    TargetHandle);
                }
              }
              if ( v28 != -2146893055 )
              {
                pvBuffer = 0i64;
                if ( !v20 )
                  pvBuffer = v45.pvBuffer;
                CleanupAppModeInfo(pvBuffer);
                if ( v46 )
                  CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, v46);
                if ( v25 )
                  *v25 = 0i64;
                if ( v24 )
                  v24->QuadPart = 0i64;
              }
              goto LABEL_49;
            }
            if ( v15 )
            {
              if ( a4->dwVersion == 4 )
              {
                v18 = MapKernelAuthDataV4(a4, a1, TargetHandle, (struct LSA_SCHANNEL_CRED *)v56);
              }
              else
              {
                if ( a4->dwVersion != 5 )
                  goto LABEL_34;
                v18 = MapKernelAuthDataV5(a4, a1, TargetHandle, (struct LSA_SCHANNEL_CRED *)v56);
              }
              if ( v18 >= 0 )
                goto LABEL_34;
            }
            else
            {
              v18 = (*(__int64 (__fastcall **)(_QWORD, __int64, unsigned int *, struct _SCHANNEL_CRED *))(LsaTable + 80))(
                      0i64,
                      4i64,
                      &v47,
                      a4);
              if ( v18 >= 0 )
              {
                v19 = v47;
                if ( v47 < 3 )
                  goto LABEL_103;
                if ( v47 <= 5 )
                {
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
                  {
                    WPP_SF_d(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      0x38u,
                      (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                      v47);
                    v19 = v47;
                  }
                  if ( v14 )
                    v18 = SpWow64MapVersion3Certificate(a4, v19, &v45, (struct LSA_SCHANNEL_CRED *)v56);
                  else
                    v18 = SpMapVersion3Certificate(a4, v19, &v45, (struct LSA_SCHANNEL_CRED *)v56);
                  if ( v18 != 590610 )
                  {
                    if ( v18 >= 0 )
                      goto LABEL_34;
                    goto LABEL_121;
                  }
                  v20 = v41;
                  if ( !v41 )
                    goto LABEL_35;
                  if ( !LsaTable )
                  {
                    v28 = -2146893052;
LABEL_93:
                    v25 = *(CCredentialGroup ***)&v43.cbBuffer;
                    v24 = a6;
                    goto LABEL_45;
                  }
                  v42 = 10;
                  if ( v14 )
                  {
                    v45.cbBuffer = 4;
                    v36 = (_DWORD *)(*(__int64 (__fastcall **)(__int64))(LsaTable + 384))(4i64);
                    v45.pvBuffer = v36;
                    if ( v36 )
                    {
                      *v36 = (_DWORD)a4;
                      goto LABEL_100;
                    }
                  }
                  else
                  {
                    v45.cbBuffer = 8;
                    v37 = (struct _SCHANNEL_CRED **)(*(__int64 (__fastcall **)(__int64))(LsaTable + 384))(8i64);
                    v45.pvBuffer = v37;
                    if ( v37 )
                    {
                      *v37 = a4;
LABEL_100:
                      v45.BufferType = 1;
                      LOBYTE(DesiredAccess) = 1;
                      v38 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, struct _SecBuffer *, _DWORD))(LsaTable + 496))(
                              v42,
                              0i64,
                              8i64,
                              &v45,
                              DesiredAccess);
                      if ( v38 >= 0 )
                        v28 = -2146893055;
                      else
                        v28 = TranslateToSecurityStatus(v38);
                      goto LABEL_93;
                    }
                  }
                  v28 = -2146893056;
                  goto LABEL_93;
                }
                if ( v47 != 512 )
                {
LABEL_103:
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                  {
                    WPP_SF_d(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      0x39u,
                      (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                      v47);
                  }
                  v28 = -2146893043;
                  goto LABEL_122;
                }
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
                {
                  WPP_SF_d(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    0x37u,
                    (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                    512);
                }
                v18 = SpMapAuthIdentity(a4, (struct LSA_SCHANNEL_CRED *)v56, (__int64)TargetHandle);
                if ( !v18 )
                  goto LABEL_34;
              }
            }
LABEL_121:
            v28 = TranslateToSecurityStatus(v18);
            goto LABEL_122;
          }
          v28 = -2146893042;
LABEL_122:
          v25 = *(CCredentialGroup ***)&v43.cbBuffer;
          goto LABEL_123;
        }
      }
      v34 = v16;
      goto LABEL_120;
    }
LABEL_61:
    v28 = -2146893052;
    goto LABEL_122;
  }
  return 2148074244i64;
}
// 180010A07: variable 'v10' is possibly undefined
// 180010A07: variable 'v11' is possibly undefined
// 180010A07: variable 'v12' is possibly undefined
// 18003998D: variable 'DesiredAccess' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180010CB0) ----------------------------------------------------
void __fastcall CCredentialGroup::GetCredentialExpirationTime(CCredentialGroup *this, union _LARGE_INTEGER *a2)
{
  struct _RTL_RESOURCE *v4; // rsi
  _QWORD *v5; // rdi
  _QWORD *v6; // rcx
  __int64 v7; // rax

  if ( a2 )
  {
    a2->QuadPart = 0x7FFFFF36D5969FFFi64;
    if ( *((_DWORD *)this + 7) )
    {
      v4 = (struct _RTL_RESOURCE *)((char *)this + 48);
      RtlAcquireResourceShared((PRTL_RESOURCE)((char *)this + 48), 1u);
      v5 = (_QWORD *)((char *)this + 32);
      v6 = (_QWORD *)*v5;
      while ( v6 != v5 )
      {
        v7 = v6[3];
        v6 = (_QWORD *)*v6;
        if ( v7 )
        {
          *a2 = *(union _LARGE_INTEGER *)(*(_QWORD *)(v7 + 24) + 72i64);
          break;
        }
      }
      RtlReleaseResource(v4);
    }
  }
}

//----- (0000000180010CF8) ----------------------------------------------------
void __fastcall FreeSchannelCred(struct LSA_SCHANNEL_CRED *a1, char a2)
{
  void *v4; // rcx
  void *v5; // rcx
  struct _TLS_PARAMETERS *v6; // rcx
  unsigned int i; // ebp
  __int64 v8; // rsi
  _WORD *v9; // rdi
  __int64 v10; // rcx
  void *v11; // rcx
  void *v12; // rcx
  void *v13; // rcx
  void *v14; // rcx

  if ( *((_QWORD *)a1 + 1) )
  {
    for ( i = 0; i < *((_DWORD *)a1 + 1); *(_QWORD *)(v8 + 48) = 0i64 )
    {
      v8 = *((_QWORD *)a1 + 1) + 56i64 * i;
      if ( *(_QWORD *)v8 )
        CertFreeCertificateContext(*(PCCERT_CONTEXT *)v8);
      v9 = *(_WORD **)(v8 + 8);
      if ( v9 )
      {
        v10 = -1i64;
        do
          ++v10;
        while ( v9[v10] );
        memset(v9, 0, 2 * v10);
        SPExternalFree(*(void **)(v8 + 8));
      }
      *(_OWORD *)v8 = 0i64;
      ++i;
      *(_OWORD *)(v8 + 16) = 0i64;
      *(_OWORD *)(v8 + 32) = 0i64;
    }
    SPExternalFree(*((void **)a1 + 1));
    *((_QWORD *)a1 + 1) = 0i64;
  }
  v4 = (void *)*((_QWORD *)a1 + 2);
  if ( v4 )
  {
    CertCloseStore(v4, 0);
    *((_QWORD *)a1 + 2) = 0i64;
  }
  v5 = (void *)*((_QWORD *)a1 + 8);
  if ( v5 )
  {
    SPExternalFree(v5);
    *((_QWORD *)a1 + 8) = 0i64;
  }
  v6 = (struct _TLS_PARAMETERS *)*((_QWORD *)a1 + 13);
  if ( v6 )
  {
    FreeTlsParameters(v6, *((_DWORD *)a1 + 24));
    *((_QWORD *)a1 + 13) = 0i64;
    *((_DWORD *)a1 + 24) = 0;
  }
  if ( a2 )
  {
    v11 = (void *)*((_QWORD *)a1 + 3);
    if ( v11 )
      CryptObjectLocatorFree(v11);
    v12 = (void *)*((_QWORD *)a1 + 4);
    if ( v12 )
      CertCloseStore(v12, 0);
    v13 = (void *)*((_QWORD *)a1 + 5);
    if ( v13 )
      CryptObjectLocatorFree(v13);
    v14 = (void *)*((_QWORD *)a1 + 6);
    if ( v14 )
      CertCloseStore(v14, 0);
  }
  memset(a1, 0, 0x70ui64);
}
// 180098018: using guessed type void __stdcall CryptObjectLocatorFree(void *);

//----- (0000000180010D8C) ----------------------------------------------------
__int64 __fastcall GetProcessImageName(unsigned __int16 *a1, struct _SECPKG_CALL_INFO *a2)
{
  unsigned int v2; // ebx
  DWORD ProcessId; // r15d
  HANDLE v5; // r13
  int v6; // eax
  __int64 v7; // rsi
  int v9; // eax
  HLOCAL v10; // r15
  int v11; // eax
  void *v12; // rcx
  const wchar_t *v13; // r8
  DWORD LastError; // eax
  DWORD v15; // eax
  CCipherMill *v16; // rcx
  __int64 v17; // rdx
  CCipherMill *v18; // rcx
  DWORD dwSize; // [rsp+50h] [rbp-B0h] BYREF
  _QWORD v20[3]; // [rsp+58h] [rbp-A8h] BYREF
  DWORD v21; // [rsp+70h] [rbp-90h] BYREF
  HLOCAL hMem; // [rsp+78h] [rbp-88h]
  __int128 v23; // [rsp+80h] [rbp-80h]
  wchar_t String1[256]; // [rsp+A0h] [rbp-60h] BYREF
  wchar_t v25[264]; // [rsp+2A0h] [rbp+1A0h] BYREF
  WCHAR ExeName[264]; // [rsp+4B0h] [rbp+3B0h] BYREF

  v2 = 0;
  if ( !a2 || !a1 )
    return 87i64;
  ProcessId = a2->ProcessId;
  if ( (a2->Attributes & 0x2000) != 0 )
  {
    v13 = L"SYSTEM";
  }
  else
  {
    if ( ProcessId )
    {
      v5 = OpenProcess(0x1000u, 0, ProcessId);
      if ( !v5 )
      {
        LastError = GetLastError();
        v2 = LastError;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            10i64,
            &WPP_0dcdb9265ec2314c20be99baf3bba51a_Traceguids,
            LastError);
        return v2;
      }
      memset_0(ExeName, 0, 0x208ui64);
      dwSize = 260;
      if ( !QueryFullProcessImageNameW(v5, 0, ExeName, &dwSize) )
      {
        v15 = GetLastError();
        v2 = v15;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_0dcdb9265ec2314c20be99baf3bba51a_Traceguids, v15);
        goto LABEL_14;
      }
      memset_0(String1, 0, sizeof(String1));
      v6 = wsplitpath_s(ExeName, 0i64, 0i64, 0i64, 0i64, String1, 0x100ui64, 0i64, 0i64);
      if ( v6 )
      {
        v16 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) == 0 )
          goto LABEL_57;
        v17 = 12i64;
        goto LABEL_56;
      }
      memset_0(v25, 0, 0x208ui64);
      v7 = -1i64;
      if ( wcsnicmp(String1, L"svchost", 7ui64) )
        goto LABEL_9;
      LODWORD(v20[0]) = ProcessId;
      memset((char *)v20 + 4, 0, 20);
      HIDWORD(v20[0]) = NtCurrentTeb()->SubProcessTag;
      if ( (unsigned int)I_QueryTagInformation(0i64, 1i64, v20) )
      {
        v21 = ProcessId;
        hMem = 0i64;
        v9 = I_QueryTagInformation(0i64, 3i64, &v21);
        if ( v9 )
        {
          if ( v9 < 0
            && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
          {
            WPP_SF_D(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              13i64,
              &WPP_0dcdb9265ec2314c20be99baf3bba51a_Traceguids,
              (unsigned int)v9);
          }
          goto LABEL_9;
        }
        v10 = hMem;
        if ( !hMem )
        {
          do
LABEL_9:
            ++v7;
          while ( v25[v7] );
          if ( v7 )
            v6 = StringCchPrintfW(a1, 260i64, L"%ls[%ls]", String1, v25);
          else
            v6 = StringCchCopyW((char *)a1, 260i64, (char *)String1);
          if ( v6 == -2147024774 )
          {
            v18 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
              {
                WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &WPP_0dcdb9265ec2314c20be99baf3bba51a_Traceguids);
                v18 = WPP_GLOBAL_Control;
              }
              if ( v18 != (CCipherMill *)&WPP_GLOBAL_Control )
              {
                if ( (*((_BYTE *)v18 + 28) & 2) != 0 )
                {
                  WPP_SF_S(
                    *((_QWORD *)v18 + 2),
                    0xFu,
                    (__int64)&WPP_0dcdb9265ec2314c20be99baf3bba51a_Traceguids,
                    String1);
                  v18 = WPP_GLOBAL_Control;
                }
                if ( v18 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v18 + 28) & 2) != 0 )
                  WPP_SF_S(*((_QWORD *)v18 + 2), 0x10u, (__int64)&WPP_0dcdb9265ec2314c20be99baf3bba51a_Traceguids, v25);
              }
            }
            goto LABEL_14;
          }
          if ( v6 >= 0 )
          {
LABEL_14:
            CloseHandle(v5);
            return v2;
          }
          v16 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
LABEL_57:
            v2 = 1359;
            goto LABEL_14;
          }
          v17 = 17i64;
LABEL_56:
          WPP_SF_D(*((_QWORD *)v16 + 2), v17, &WPP_0dcdb9265ec2314c20be99baf3bba51a_Traceguids, (unsigned int)v6);
          goto LABEL_57;
        }
        if ( *(_DWORD *)hMem == 1 )
        {
          v11 = _mm_cvtsi128_si32(*(__m128i *)*((_QWORD *)hMem + 1));
          v23 = *(_OWORD *)*((_QWORD *)hMem + 1);
          if ( v11 == 1 )
          {
            if ( *((_QWORD *)&v23 + 1) )
              o_wcsncpy_s_0(v25, 260i64, *((_QWORD *)&v23 + 1), -1i64);
          }
        }
        v12 = v10;
      }
      else
      {
        if ( !v20[2] )
          goto LABEL_9;
        o_wcsncpy_s_0(v25, 260i64, v20[2], -1i64);
        v12 = (void *)v20[2];
      }
      LocalFree(v12);
      goto LABEL_9;
    }
    v13 = L"<UNKNOWN>";
  }
  o_wcsncpy_s_0(a1, 260i64, v13, -1i64);
  return 0i64;
}
// 180028D84: using guessed type __int64 __fastcall o_wcsncpy_s_0(_QWORD, _QWORD, _QWORD, _QWORD);
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080DC0: using guessed type __int64 __fastcall I_QueryTagInformation(_QWORD, _QWORD, _QWORD);
// 180085478: using guessed type wchar_t aSystem[7];
// 180085488: using guessed type wchar_t aUnknown_0[10];
// 180010D8C: using guessed type wchar_t var_460[264];

//----- (0000000180011040) ----------------------------------------------------
__int64 __fastcall SpUniAcquireCredentialsHandle(
        struct _UNICODE_STRING *a1,
        __int64 a2,
        struct _LUID *a3,
        struct _SCHANNEL_CRED *a4,
        int a5,
        int a6,
        unsigned __int64 *a7,
        union _LARGE_INTEGER *a8)
{
  unsigned int v10; // ebx
  CCipherMill *v12; // rcx
  char v13; // al
  unsigned int v14; // edx
  __int64 v15; // rdx
  unsigned int v16; // ebx
  CCipherMill *v17; // rcx
  unsigned __int64 *v19; // [rsp+20h] [rbp-68h]
  char v20[16]; // [rsp+30h] [rbp-58h] BYREF

  v10 = a2;
  v12 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 62i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
      v12 = WPP_GLOBAL_Control;
    }
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v12 + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)v12 + 2), 63i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
        v12 = WPP_GLOBAL_Control;
      }
      if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
      {
        WPP_SF_D(*((_QWORD *)v12 + 2), 64i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, v10);
        v12 = WPP_GLOBAL_Control;
      }
    }
  }
  v13 = Microsoft_Windows_Schannel_EventsEnableBits;
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
  {
    McGenEventWrite_EtwEventWriteTransfer((__int64)v12, (__int64)&AchStart, (__int64)a3, 1, (__int64)v20);
    v12 = WPP_GLOBAL_Control;
    v13 = Microsoft_Windows_Schannel_EventsEnableBits;
  }
  if ( (v10 & 1) != 0 )
  {
    v14 = 0x40000000;
LABEL_15:
    v16 = SpCommonAcquireCredentialsHandle(a1, v14, a3, a4, a7, a8);
    v17 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 66i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McTemplateU0d_EtwEventWriteTransfer((__int64)v17, v15, v16);
    return v16;
  }
  if ( (v10 & 2) != 0 )
  {
    v14 = 0x80000000;
    goto LABEL_15;
  }
  v16 = -2146893042;
  if ( (v13 & 1) != 0 )
  {
    McTemplateU0d_EtwEventWriteTransfer((__int64)v12, a2, 2148074254i64);
    v12 = WPP_GLOBAL_Control;
  }
  if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 5) != 0 )
  {
    LODWORD(v19) = -2146893042;
    WPP_SF_DD(*((_QWORD *)v12 + 2), 0x41u, (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, -2146893042, v19);
  }
  return v16;
}
// 180039FDF: variable 'a3' is possibly undefined
// 18003A014: variable 'v17' is possibly undefined
// 18003A014: variable 'v15' is possibly undefined
// 18003A02B: variable 'a2' is possibly undefined
// 18003A06C: variable 'v19' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 180011040: using guessed type char var_58[16];

//----- (0000000180011144) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::LogAppName(CSchannelTelemetryContext *this)
{
  __int64 v1; // r8

  if ( this && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
  {
    v1 = *((_QWORD *)this + 17);
    if ( v1 )
      o_wcsncpy_s_0((char *)this + 664, 256i64, v1 + 216, -1i64);
  }
}
// 180028D84: using guessed type __int64 __fastcall o_wcsncpy_s_0(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (000000018001118C) ----------------------------------------------------
__int64 __fastcall SpMapVersion3Certificate(void *a1, int a2, struct _SecBuffer *a3, struct LSA_SCHANNEL_CRED *a4)
{
  unsigned int v7; // ebx
  void *v8; // r12
  void *v9; // r15
  int v10; // r14d
  int v11; // ebx
  __int64 v12; // r15
  __int64 v13; // rax
  unsigned int v14; // r12d
  struct _SecBuffer *v15; // rbx
  unsigned int *pvBuffer; // rsi
  unsigned int cbBuffer; // r14d
  unsigned int *v18; // rbx
  int v19; // r13d
  int v20; // eax
  void *v21; // rcx
  unsigned int v23; // eax
  unsigned int v24; // eax
  _QWORD *v25; // rax
  HLOCAL v26; // rax
  unsigned int v27; // r15d
  __int64 v28; // r8
  __int64 v29; // rcx
  unsigned int *v30; // rdx
  __int64 ppvContext; // r9
  DWORD v32; // r8d
  int v33; // eax
  __int64 v34; // rcx
  int *v35; // r8
  HCERTSTORE v36; // r14
  const CERT_CONTEXT *i; // rdx
  DWORD v38; // eax
  const CERT_CONTEXT *v39; // rax
  const CERT_CONTEXT *v40; // rsi
  DWORD LastError; // eax
  __int64 v42; // rcx
  HCERTSTORE v43; // rax
  unsigned int v44; // ebx
  HLOCAL v45; // rax
  void *pvPara; // [rsp+28h] [rbp-A9h]
  HCERTSTORE hCertStore; // [rsp+48h] [rbp-89h]
  HLOCAL v48; // [rsp+50h] [rbp-81h]
  unsigned int v49; // [rsp+58h] [rbp-79h]
  struct _SecBuffer v50; // [rsp+60h] [rbp-71h] BYREF
  __int64 v51; // [rsp+70h] [rbp-61h]
  unsigned int v52; // [rsp+78h] [rbp-59h] BYREF
  int *v53; // [rsp+80h] [rbp-51h]
  char v54[4]; // [rsp+88h] [rbp-49h] BYREF
  unsigned int v55; // [rsp+8Ch] [rbp-45h]
  __int64 v56; // [rsp+90h] [rbp-41h]
  __int64 v57; // [rsp+98h] [rbp-39h]
  __int64 v58; // [rsp+A0h] [rbp-31h]
  unsigned int v59; // [rsp+B0h] [rbp-21h]
  __int64 v60; // [rsp+B8h] [rbp-19h]
  unsigned int v61; // [rsp+C0h] [rbp-11h]
  int v62; // [rsp+C4h] [rbp-Dh]
  struct _TLS_PARAMETERS *v63; // [rsp+C8h] [rbp-9h]
  __int64 v64; // [rsp+D0h] [rbp-1h]
  __int128 v65; // [rsp+D8h] [rbp+7h] BYREF
  __int64 v66; // [rsp+E8h] [rbp+17h]

  v48 = 0i64;
  hCertStore = 0i64;
  v7 = 80;
  v8 = 0i64;
  v9 = 0i64;
  memset_0(v54, 0, 0x50ui64);
  v65 = 0i64;
  v66 = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
  if ( !LsaTable )
    return 2148074333i64;
  if ( !(*(unsigned __int8 (__fastcall **)(__int128 *))(LsaTable + 192))(&v65) )
    return 2148074244i64;
  v10 = BYTE8(v65) & 0x11;
  if ( a2 == 3 )
  {
    v11 = (*(__int64 (__fastcall **)(_QWORD, __int64, char *, void *))(LsaTable + 80))(0i64, 72i64, v54, a1);
    if ( v11 < 0 )
      goto LABEL_26;
    v64 = 0i64;
  }
  else
  {
    if ( a2 != 4 )
      v7 = 72;
    v11 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, char *, void *))(LsaTable + 80))(0i64, v7, v54, a1);
    if ( v11 < 0 )
      goto LABEL_26;
  }
  memset_0((char *)a4 + 4, 0, 0x6Cui64);
  *(_DWORD *)a4 = a2;
  if ( a2 == 4 )
  {
    v12 = v56;
    v13 = v57;
    v14 = v55;
  }
  else
  {
    v12 = v57;
    v13 = v58;
    v14 = v56;
  }
  v51 = v13;
  if ( v14 > 0x64 )
  {
    v9 = 0i64;
    v11 = -2146893056;
    v8 = 0i64;
    goto LABEL_26;
  }
  v15 = a3;
  pvBuffer = (unsigned int *)a3->pvBuffer;
  if ( pvBuffer )
    goto LABEL_64;
  if ( v14 && v12 || (pvBuffer = 0i64, v13) )
  {
    if ( !v10 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
      v9 = 0i64;
      v11 = 590610;
      v8 = 0i64;
      goto LABEL_26;
    }
    v50.cbBuffer = 8;
    v50.BufferType = 1;
    v25 = SPExternalAlloc(8u);
    v50.pvBuffer = v25;
    if ( !v25 )
    {
      v11 = -2146893056;
LABEL_59:
      v9 = 0i64;
      v8 = 0i64;
      goto LABEL_26;
    }
    *v25 = a1;
    v11 = PerformApplicationCallback(10i64, 0i64, 0i64, &v50, a3, 1, 0, 1);
    if ( v50.pvBuffer )
      SPExternalFree(v50.pvBuffer);
    if ( v11 < 0 )
      goto LABEL_59;
    v15 = a3;
    pvBuffer = (unsigned int *)a3->pvBuffer;
    if ( !pvBuffer )
    {
      v11 = -2146893052;
      goto LABEL_59;
    }
LABEL_64:
    cbBuffer = v15->cbBuffer;
    goto LABEL_17;
  }
  cbBuffer = 0;
LABEL_17:
  v18 = pvBuffer;
  if ( v14 && v12 )
  {
    v48 = SPExternalAlloc(8 * v14);
    if ( !v48 )
    {
      v9 = 0i64;
      v11 = -2146893056;
      v8 = 0i64;
      goto LABEL_26;
    }
    v11 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, HLOCAL, __int64))(LsaTable + 80))(0i64, 8 * v14, v48, v12);
    if ( v11 < 0 )
      goto LABEL_72;
    *((_DWORD *)a4 + 1) = v14;
    v26 = SPExternalAlloc(56 * v14);
    *((_QWORD *)a4 + 1) = v26;
    if ( !v26 )
    {
      v11 = -2146893056;
LABEL_72:
      v9 = hCertStore;
LABEL_74:
      v8 = v48;
      goto LABEL_26;
    }
    hCertStore = CertOpenStore((LPCSTR)2, 0, 0i64, 4u, 0i64);
    v9 = hCertStore;
    if ( !hCertStore )
    {
      GetLastError();
      v11 = -2146893056;
      goto LABEL_74;
    }
    v27 = 0;
    v28 = 0i64;
    *(_QWORD *)&v50.cbBuffer = 0i64;
    v18 = pvBuffer;
    while ( 1 )
    {
      v29 = *v18;
      v30 = v18 + 1;
      cbBuffer += -4 - v29;
      v18 = (unsigned int *)((char *)v18 + v29 + 4);
      if ( !v30 )
        break;
      if ( (unsigned int)v29 < 0xC )
        break;
      ppvContext = v28 + *((_QWORD *)a4 + 1);
      *(_QWORD *)(ppvContext + 16) = *(_QWORD *)v30;
      v32 = v30[2];
      if ( (int)v29 - 12 < v32 )
        break;
      if ( !CertAddSerializedElementToStore(
              hCertStore,
              (const BYTE *)v30 + 12,
              v32,
              4u,
              0,
              2u,
              0i64,
              (const void **)ppvContext) )
        goto LABEL_99;
      v33 = HIDWORD(v60);
      if ( a2 == 4 )
        v33 = v64;
      if ( (v33 & 0x10000) != 0 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
        v34 = *v18;
        v35 = (int *)(v18 + 1);
        v18 = (unsigned int *)((char *)v18 + v34 + 4);
        v49 = -4 - v34 + cbBuffer;
        if ( v35 )
        {
          if ( (unsigned int)v34 >= 4 )
          {
            v52 = *v35;
            v53 = v35 + 1;
            if ( v34 - 4 >= (unsigned __int64)v52 )
            {
              v36 = CertOpenStore((LPCSTR)6, 1u, 0i64, 0, &v52);
              if ( !v36 )
                goto LABEL_109;
              for ( i = 0i64; ; i = v40 )
              {
                v39 = CertEnumCertificatesInStore(v36, i);
                v40 = v39;
                if ( !v39 )
                {
                  if ( !CertCloseStore(v36, 2u)
                    && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
                  {
                    LastError = GetLastError();
                    WPP_SF_D(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      15i64,
                      &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                      LastError);
                  }
                  cbBuffer = v49;
                  goto LABEL_107;
                }
                if ( !CertAddCertificateContextToStore(hCertStore, v39, 1u, 0i64) && GetLastError() != -2146885627 )
                  break;
              }
              if ( !CertCloseStore(v36, 2u)
                && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
              {
                v38 = GetLastError();
                WPP_SF_D(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  14i64,
                  &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                  v38);
              }
              CertFreeCertificateContext(v40);
LABEL_99:
              v11 = -2146893043;
              goto LABEL_72;
            }
          }
        }
        goto LABEL_110;
      }
LABEL_107:
      ++v27;
      v28 = *(_QWORD *)&v50.cbBuffer + 56i64;
      *(_QWORD *)&v50.cbBuffer += 56i64;
      if ( v27 >= v14 )
        goto LABEL_18;
    }
LABEL_71:
    v11 = -2146893052;
    goto LABEL_72;
  }
LABEL_18:
  if ( v51 )
  {
    v42 = *v18;
    if ( v18 == (unsigned int *)-4i64 || (unsigned int)v42 < 4 )
      goto LABEL_71;
    v52 = v18[1];
    v53 = (int *)(v18 + 2);
    if ( v42 - 4 < (unsigned __int64)v52 )
    {
LABEL_110:
      v11 = -2146893052;
      goto LABEL_25;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 16i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
    v43 = CertOpenStore((LPCSTR)6, 1u, 0i64, 0, &v52);
    *((_QWORD *)a4 + 2) = v43;
    if ( !v43 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 17i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
LABEL_109:
      v11 = -2146893043;
      goto LABEL_25;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_q(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x12u,
        (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
        v43);
  }
  v19 = a2 - 4;
  if ( v19 )
  {
    if ( v19 != 1 )
    {
LABEL_24:
      v11 = 0;
      goto LABEL_25;
    }
    v11 = CopyTlsParameters(v63, v61, 0, 1, (struct _TLS_PARAMETERS **)a4 + 13, (unsigned int *)a4 + 24);
    if ( !v11 )
    {
      *(_QWORD *)((char *)a4 + 84) = v60;
      v20 = v55;
LABEL_23:
      *((_DWORD *)a4 + 23) = v20;
      goto LABEL_24;
    }
  }
  else
  {
    v23 = v59;
    if ( !v59 || !v60 )
      goto LABEL_41;
    if ( v59 > 0x100
      || (v44 = 4 * v59, *((_DWORD *)a4 + 14) = v59, v45 = SPExternalAlloc(4 * v23), (*((_QWORD *)a4 + 8) = v45) == 0i64) )
    {
      v11 = -2146893056;
      goto LABEL_25;
    }
    v11 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, HLOCAL, __int64))(LsaTable + 80))(0i64, v44, v45, v60);
    if ( v11 >= 0 )
    {
LABEL_41:
      v24 = v61;
      if ( v61 == -1 )
        v24 = 0;
      *((_DWORD *)a4 + 18) = v24 & 0x3FFFFFFF;
      *((_DWORD *)a4 + 19) = v62;
      *((_QWORD *)a4 + 10) = v63;
      *((_DWORD *)a4 + 22) = v64;
      v20 = HIDWORD(v64);
      goto LABEL_23;
    }
  }
LABEL_25:
  v9 = hCertStore;
  v8 = v48;
LABEL_26:
  if ( a3 )
  {
    v21 = a3->pvBuffer;
    if ( v21 && (BYTE8(v65) & 0x10) != 0 )
      SPExternalFree(v21);
    a3->pvBuffer = 0i64;
    *(_QWORD *)&a3->cbBuffer = 0i64;
    CleanupAppModeInfo(0i64);
  }
  if ( v8 )
    SPExternalFree(v8);
  if ( v9 )
    CertCloseStore(v9, 0);
  if ( v11 < 0 )
    FreeSchannelCred(a4, 1);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v11 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    LODWORD(pvPara) = v11;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x13u,
      (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
      v11,
      pvPara);
  }
  return (unsigned int)v11;
}
// 18003A716: variable 'pvPara' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180011434) ----------------------------------------------------
void __fastcall CleanupAppModeInfo(void *a1)
{
  char v1; // [rsp+20h] [rbp-18h]

  if ( a1 )
    (*(void (**)(void))(LsaTable + 392))();
  v1 = 0;
  (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, char))(LsaTable + 496))(0i64, 0i64, 0i64, 0i64, v1);
}
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018001147C) ----------------------------------------------------
__int64 __fastcall ParseKeyBuffer(struct CSslContext *a1, __int64 a2, unsigned __int8 *a3, unsigned int a4)
{
  unsigned int v4; // esi
  char v7; // r14
  int v9; // ebp
  unsigned __int8 *v10; // rbx
  __int64 v11; // rax
  _QWORD *v12; // rbx
  _QWORD *v13; // r14
  _QWORD *v14; // rbx
  unsigned int v15; // eax
  unsigned int v16; // eax
  CCipherMill *v17; // rcx
  _DWORD *v18; // rbx
  unsigned int v19; // r14d
  unsigned int *v20; // rax
  _BYTE *v21; // rbx
  __int64 v22; // r9
  __int64 v23; // r14
  __int64 v24; // r15
  unsigned int v25; // r12d
  _BYTE *v26; // rbx
  _BYTE *v27; // r8
  _BYTE *v28; // r13
  _BYTE *v29; // rbx
  _QWORD *v30; // rax
  __int64 v31; // rcx
  __int64 *v33; // rax
  __int64 v34; // rcx
  CCipherMill *v35; // rcx
  __int64 v36; // rdx
  __int64 *v37; // rax
  __int64 v38; // rdx
  CCipherMill *v39; // rcx
  const wchar_t *v40; // r9
  unsigned __int16 v41; // dx
  _QWORD *v42; // rax
  __int64 v43; // rdx
  __int64 v44; // [rsp+20h] [rbp-58h]
  int v45; // [rsp+80h] [rbp+8h]
  int v46; // [rsp+88h] [rbp+10h]

  v4 = 0;
  v45 = *((_DWORD *)a1 + 16) & 0x40051555;
  v7 = a2;
  if ( !a3 || a4 < 0x3D )
    return 87;
  v9 = a2 & 1;
  if ( (a2 & 1) != 0 )
  {
    *((_QWORD *)a1 + 22) = *(_QWORD *)a3;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_i(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x1Du, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
  }
  v46 = v7 & 2;
  if ( (v7 & 2) != 0 )
  {
    *((_QWORD *)a1 + 23) = *((_QWORD *)a3 + 1);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_i(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x1Eu, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
  }
  v10 = a3 + 16;
  if ( v9
    && (v11 = *(int *)v10, *((_DWORD *)a1 + 48) = v11, WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control)
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_i(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x1Fu, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v11);
    v12 = v10 + 4;
    v13 = v12;
  }
  else
  {
    v12 = v10 + 4;
    v13 = v12;
    if ( !v9 )
      goto LABEL_17;
  }
  *((_QWORD *)a1 + 25) = *v12;
  if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
  {
LABEL_17:
    v14 = v12 + 1;
    if ( !v9 )
      goto LABEL_21;
    goto LABEL_18;
  }
  WPP_SF_i(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x20u, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
  v14 = v13 + 1;
LABEL_18:
  *((_QWORD *)a1 + 26) = *v14;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_i(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x21u, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
LABEL_21:
  v15 = *((unsigned __int16 *)v14 + 4);
  *((_WORD *)a1 + 108) = v15;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 34i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v15);
  v16 = *((unsigned __int16 *)v14 + 5);
  *((_WORD *)a1 + 109) = v16;
  v17 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 35i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v16);
    v17 = WPP_GLOBAL_Control;
  }
  v18 = (_DWORD *)v14 + 3;
  if ( v9 )
  {
    v19 = *v18;
    if ( v17 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v17 + 28) & 4) != 0 )
      WPP_SF_D(*((_QWORD *)v17 + 2), 36i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v19);
    v20 = (unsigned int *)*((_QWORD *)a1 + 28);
    if ( v20 )
    {
      *v20 = v19;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          37i64,
          &WPP_66cada2652f531372f2ad4492a08a619_Traceguids,
          **((unsigned int **)a1 + 28));
    }
  }
  v21 = v18 + 1;
  LOBYTE(a2) = *v21;
  (*(void (__fastcall **)(struct CSslContext *, __int64))(*(_QWORD *)a1 + 408i64))(a1, a2);
  v22 = *(unsigned int *)++v21;
  v21 += 4;
  v23 = *(unsigned int *)v21;
  v21 += 4;
  v24 = *(unsigned int *)v21;
  v21 += 4;
  v25 = *(_DWORD *)v21;
  v26 = v21 + 4;
  if ( (unsigned int)v22 > 0x10000 || (unsigned int)v23 > 0x10000 || (unsigned int)v24 > 0x10000 || v25 > 0x10000 )
    return 87;
  if ( a4 - 61 != (_DWORD)v22 + (_DWORD)v23 + v25 + (_DWORD)v24 )
  {
    v4 = 1359;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 38i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
    return v4;
  }
  v27 = v26;
  v28 = &v26[v22];
  v29 = &v26[v22 + v23];
  if ( v9 )
  {
    if ( (_DWORD)v22 )
    {
      v33 = (__int64 *)*((_QWORD *)a1 + 1);
      if ( v33 )
        v34 = *v33;
      else
        v34 = 0i64;
      v4 = SslImportKey(v34, (char *)a1 + 144, L"OpaqueKeyBlob", v27, v22, 0);
      if ( v4 )
      {
        v35 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return v4;
        v36 = 39i64;
LABEL_65:
        WPP_SF_D(*((_QWORD *)v35 + 2), v36, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v4);
        return v4;
      }
    }
    else
    {
      *((_QWORD *)a1 + 18) = 0i64;
    }
  }
  if ( v46 )
  {
    if ( !(_DWORD)v23 )
    {
      *((_QWORD *)a1 + 19) = 0i64;
      goto LABEL_45;
    }
    v30 = (_QWORD *)*((_QWORD *)a1 + 1);
    v31 = v30 ? *v30 : 0i64;
    v4 = SslImportKey(v31, (char *)a1 + 152, L"OpaqueKeyBlob", v28, v23, 0);
    if ( v4 )
    {
      v35 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return v4;
      v36 = 40i64;
      goto LABEL_65;
    }
  }
LABEL_45:
  if ( (_DWORD)v24
    && ((v37 = (__int64 *)*((_QWORD *)a1 + 1)) == 0i64 ? (v38 = 0i64) : (v38 = *v37),
        LOBYTE(v27) = 1,
        (v4 = (*(__int64 (__fastcall **)(struct CSslContext *, __int64, _BYTE *, _BYTE *, _DWORD))(*(_QWORD *)a1 + 400i64))(
                a1,
                v38,
                v27,
                v29,
                v24)) != 0) )
  {
    v39 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      v40 = L"server";
      v41 = 41;
      if ( v45 )
        v40 = L"client";
      goto LABEL_81;
    }
  }
  else if ( v25 )
  {
    v42 = (_QWORD *)*((_QWORD *)a1 + 1);
    v43 = v42 ? *v42 : 0i64;
    v4 = (*(__int64 (__fastcall **)(struct CSslContext *, __int64, _QWORD, _BYTE *, unsigned int))(*(_QWORD *)a1 + 400i64))(
           a1,
           v43,
           0i64,
           &v29[v24],
           v25);
    if ( v4 )
    {
      v39 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        v40 = L"server";
        v41 = 42;
        if ( !v45 )
          v40 = L"client";
LABEL_81:
        LODWORD(v44) = v4;
        WPP_SF_SD(*((_QWORD *)v39 + 2), v41, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v40, v44);
      }
    }
  }
  return v4;
}
// 180011622: variable 'a2' is possibly undefined
// 18003A9A2: variable 'v27' is possibly undefined
// 18003AA20: variable 'v44' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082320: using guessed type wchar_t aOpaquekeyblob[14];
// 180084B40: using guessed type wchar_t aServer_1[7];
// 180084B50: using guessed type wchar_t aClient[7];
// 1800985A0: using guessed type __int64 __fastcall SslImportKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180011740) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::ProcessAppModeInfo(CSsl3TlsContext *this)
{
  unsigned int v2; // ebx
  int v3; // esi
  unsigned int v4; // r9d
  CCipherMill *v6; // rcx
  unsigned __int16 v7; // dx
  unsigned __int64 v8; // rcx
  __int64 v9; // r9
  __int64 v10; // r10
  __int64 v11; // rax
  int v12; // eax
  HLOCAL v13; // rax
  void *Src[2]; // [rsp+30h] [rbp-30h] BYREF
  char v15[32]; // [rsp+40h] [rbp-20h] BYREF
  int v16; // [rsp+80h] [rbp+20h] BYREF
  __int64 v17; // [rsp+88h] [rbp+28h] BYREF

  v17 = 0i64;
  v16 = 0;
  v2 = -1073741595;
  *(_OWORD *)Src = 0i64;
  if ( LsaTable )
  {
    if ( (*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v15) )
    {
      v3 = v15[8] & 0x40;
      v2 = (*(__int64 (__fastcall **)(int *, _QWORD, __int64 *, void **, _QWORD))(LsaTable + 488))(
             &v16,
             0i64,
             &v17,
             Src,
             0i64);
      if ( v2 )
        goto LABEL_12;
      v4 = (unsigned int)Src[0];
      if ( (!Src[1] || !LODWORD(Src[0])) && v16 != 4 )
        goto LABEL_12;
      switch ( v16 )
      {
        case 1:
          v12 = *((_DWORD *)this + 16) & 0x2000;
          *((_DWORD *)this + 236) = Src[0];
          *((_DWORD *)this + 18) = v12 != 0 ? 101 : 91;
          v13 = SPExternalAlloc(v4);
          *((_QWORD *)this + 117) = v13;
          if ( v13 )
          {
            memcpy_0(v13, Src[1], LODWORD(Src[0]));
            *((_BYTE *)this + 1032) = 1;
            goto LABEL_10;
          }
          break;
        case 4:
          if ( !this )
            v2 = 1359;
          if ( Src[1] )
          {
            if ( LODWORD(Src[0]) == (v3 != 0 ? 28 : 36) )
            {
              v8 = -(__int64)(v3 != 0) & 0xFFFFFFFFFFFFFFFCui64;
              if ( v3 )
              {
                v9 = *((unsigned int *)Src[1] + 5);
                v10 = *(unsigned int *)((char *)Src[1] + v8 + 28);
              }
              else
              {
                v9 = *(_QWORD *)((char *)Src[1] + 20);
                v10 = *(_QWORD *)((char *)Src[1] + v8 + 28);
              }
              v11 = *((_QWORD *)this + 116);
              if ( !v11 )
                v2 = 1359;
              *(_QWORD *)(v11 + 104) = v9;
              *(_QWORD *)(v11 + 112) = v10;
              *((_BYTE *)this + 923) = 0;
              CSsl3TlsClientContext::SetDefCredSearched((__int64)this, 0);
            }
            else
            {
              v2 = 1359;
            }
          }
          else
          {
            CSsl3TlsClientContext::SetActiveClientCred(this, 0i64, 0);
          }
          goto LABEL_10;
        case 7:
          v2 = ParseKeyBuffer(this, (unsigned int)v17, (unsigned __int8 *)Src[1], (unsigned int)Src[0]);
          if ( !v2 )
          {
LABEL_10:
            *((_DWORD *)this + 17) = *((_DWORD *)this + 18);
            *((_DWORD *)this + 18) = 77;
            CleanupAppModeInfo(0i64);
            return v2;
          }
LABEL_12:
          v2 = -1073741595;
          goto LABEL_10;
        case 9:
          *((_BYTE *)this + 472) = *(_BYTE *)Src[1];
          goto LABEL_10;
      }
      v2 = 1359;
      goto LABEL_10;
    }
    v6 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
    {
      v7 = 99;
      goto LABEL_21;
    }
  }
  else
  {
    v6 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
    {
      v7 = 98;
LABEL_21:
      WPP_SF_DD(
        *((_QWORD *)v6 + 2),
        v7,
        (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
        -1073741595,
        -1073741595);
    }
  }
  return v2;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180011860) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SslProtocolHandler(CSsl3TlsContext *this, struct SPBuffer *a2, struct SPBuffer *a3)
{
  unsigned int v6; // ebp
  char v7; // al
  unsigned int v8; // eax
  unsigned int v9; // ecx
  __int64 result; // rax
  __int64 v11; // rcx
  unsigned int v12; // edx
  DTlsMsgMgr *v13; // rcx
  CSsl3TlsContext *v14; // rcx
  int v15; // edx
  int v16; // eax
  unsigned int v17; // eax
  int v18; // [rsp+20h] [rbp-18h] BYREF
  int v19; // [rsp+24h] [rbp-14h]
  __int64 v20; // [rsp+28h] [rbp-10h]

  v6 = 0;
  if ( *((_DWORD *)this + 17) == 77 && (unsigned int)CSsl3TlsContext::ProcessAppModeInfo(this) )
    return 3221225701i64;
  v7 = *((_BYTE *)this + 266);
  if ( !v7 && (*((_DWORD *)this + 16) & 0x3000) == 0 )
    goto LABEL_50;
  v11 = *((_QWORD *)this + 17);
  if ( (v11 & 0x40000000) == 0 && !*((_BYTE *)this + 265) )
    goto LABEL_50;
  v12 = 0;
  if ( !*((_QWORD *)this + 19) )
    v12 = 2;
  if ( !*((_QWORD *)this + 18) )
    v12 |= 1u;
  if ( !v12 )
    goto LABEL_50;
  *((_QWORD *)this + 17) = v11 & 0xFFFFFFFFBFFFFFFFui64;
  if ( v7 )
  {
    *((_DWORD *)this + 18) = *((_DWORD *)this + 17);
    *((_DWORD *)this + 17) = 77;
    return RemotelyGetUserKeys(this, v12);
  }
  result = RemotelyGetUserKeys(this, v12);
  if ( !(_DWORD)result )
  {
LABEL_50:
    if ( *((_BYTE *)this + 233) )
    {
      v13 = (DTlsMsgMgr *)*((_QWORD *)this + 72);
      if ( *((DTlsMsgMgr **)v13 + 7) != (DTlsMsgMgr *)((char *)v13 + 56) )
        return CSsl3TlsContext::PrepareNextOutgoingRecord(this, a3);
      if ( *((_DWORD *)this + 17) != 4 && !*(_DWORD *)a2 && !*((_DWORD *)a2 + 1) && !*((_QWORD *)a2 + 1) )
      {
        result = DTlsMsgMgr::swapSaveAndOutgoing(v13);
        if ( !(_DWORD)result )
        {
          LogDtlsRetransmitRequested(
            *(_DWORD *)(*((_QWORD *)this + 10) + 212i64),
            (const unsigned __int16 *)(*((_QWORD *)this + 10) + 216i64));
          result = CSsl3TlsContext::RestoreWriteCipherState(this);
          if ( !(_DWORD)result )
            return CSsl3TlsContext::PrepareNextOutgoingRecord(v14, a3);
        }
        return result;
      }
    }
    if ( (*(unsigned __int8 (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 384i64))(this) )
    {
      if ( (*((_DWORD *)this + 34) & 0x1000i64) != 0 )
      {
        v15 = *((_DWORD *)a2 + 1);
        do
        {
          v20 = *((_QWORD *)a2 + 1) + v6;
          v16 = *(_DWORD *)a2 - v6;
          v19 = v15 - v6;
          v18 = v16;
          v17 = CSsl3TlsContext::TlsProtocolHandlerWorker(this, (struct SPBuffer *)&v18, a3);
          v6 += v19;
          v9 = v17;
          if ( *((_DWORD *)this + 17) == 4 )
            break;
          if ( v17 )
            break;
          v15 = *((_DWORD *)a2 + 1);
        }
        while ( v15 != v6 );
        *((_DWORD *)a2 + 1) = v6;
LABEL_9:
        if ( *((_DWORD *)this + 16) == 4096
          && *((_DWORD *)this + 17) == 4
          && (*((_DWORD *)this + 34) & 0x100i64) != 0
          && !*((_BYTE *)this + 552)
          && !v9 )
        {
          v9 = (*(__int64 (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 472i64))(this);
          if ( v9 == 590614 && *((_DWORD *)this + 17) == 4 )
            return 0;
        }
        return v9;
      }
      v8 = CSsl3TlsContext::TlsProtocolHandlerWorker(this, a2, a3);
    }
    else
    {
      v8 = CSsl3TlsContext::TlsNulRecordHandlerWorker(this, a2, a3);
    }
    v9 = v8;
    goto LABEL_9;
  }
  return result;
}
// 18003AC8B: variable 'v14' is possibly undefined

//----- (00000001800119B0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::TlsProtocolHandlerWorker(
        CSsl3TlsContext *this,
        struct SPBuffer *a2,
        struct SPBuffer *a3)
{
  int v3; // edi
  struct SPBuffer *v5; // r15
  unsigned int v7; // r12d
  __int64 v8; // rax
  __int64 result; // rax
  unsigned int v10; // r8d
  int v11; // edx
  CCipherMill *v12; // rcx
  unsigned __int8 *v13; // r14
  unsigned int v14; // esi
  __int64 v15; // r8
  unsigned int v16; // esi
  int v17; // esi
  int v18; // eax
  unsigned int v19; // esi
  int v20; // ecx
  __int64 v21; // rdx
  unsigned int v22; // r11d
  unsigned __int8 *v23; // rsi
  unsigned int v24; // r15d
  unsigned int v25; // r14d
  __int64 v26; // rdx
  unsigned int v27; // esi
  __int64 v28; // r8
  unsigned int v29; // esi
  int v30; // edx
  __int64 v31; // rax
  __int64 v32; // rcx
  int v33; // esi
  __int64 v34; // r14
  bool v35; // r9
  __int64 v36; // rax
  __int64 v37; // r11
  int v38; // r10d
  __int64 v39; // rcx
  __int64 v40; // r11
  __int64 v41; // rax
  unsigned int v42; // eax
  int v43; // edx
  int v44; // r14d
  int v45; // eax
  unsigned int AppDataStatus; // eax
  CCipherMill *v47; // rcx
  __int64 v48; // rdx
  unsigned __int8 *v49; // rdx
  int v50; // r9d
  int v51; // r15d
  unsigned __int64 v52; // r11
  CCipherMill *v53; // r10
  unsigned int v54; // eax
  bool v55; // zf
  __int64 v56; // rax
  __int64 v57; // rdx
  int v58; // r15d
  int v59; // eax
  __int64 v60; // rax
  __int64 v61; // rdx
  int v62; // r15d
  int v63; // eax
  int v64; // eax
  unsigned int v65; // r15d
  struct DTlsMessage *NextReadyHandshakeMsg; // rax
  unsigned int v67; // ecx
  int v68; // eax
  struct DTlsMessage *v69; // rax
  unsigned int ResponseCommon; // eax
  __int64 v71; // rdx
  CCipherMill *v72; // rcx
  __int64 v73; // rdx
  unsigned int v74; // edi
  unsigned int UserKeys; // eax
  struct kexch *KeyExchangeInfo; // rax
  int v77; // r10d
  _DWORD *v78; // r11
  __int64 v79; // [rsp+20h] [rbp-100h]
  __int64 v80; // [rsp+28h] [rbp-F8h]
  unsigned int v81; // [rsp+A0h] [rbp-80h]
  unsigned int v82; // [rsp+A0h] [rbp-80h]
  int v83; // [rsp+A0h] [rbp-80h]
  unsigned int v84; // [rsp+A4h] [rbp-7Ch]
  DTlsMessage *v85; // [rsp+A8h] [rbp-78h]
  DTlsMessage *v86; // [rsp+A8h] [rbp-78h]
  int v87; // [rsp+B0h] [rbp-70h]
  unsigned int v88; // [rsp+B4h] [rbp-6Ch]
  unsigned __int64 v89; // [rsp+B8h] [rbp-68h]
  unsigned __int8 *v90; // [rsp+C0h] [rbp-60h]
  __int64 v91; // [rsp+C8h] [rbp-58h] BYREF
  __int64 v92; // [rsp+D0h] [rbp-50h]
  int v93; // [rsp+D8h] [rbp-48h]
  int v94; // [rsp+DCh] [rbp-44h]
  unsigned __int64 v95; // [rsp+E0h] [rbp-40h]
  int v96[2]; // [rsp+E8h] [rbp-38h] BYREF
  unsigned __int8 *v97; // [rsp+F0h] [rbp-30h]
  int v98[2]; // [rsp+F8h] [rbp-28h] BYREF
  unsigned __int8 *v99; // [rsp+100h] [rbp-20h]
  int v100[2]; // [rsp+108h] [rbp-18h] BYREF
  unsigned __int8 *v101; // [rsp+110h] [rbp-10h]
  char v102[8]; // [rsp+120h] [rbp+0h] BYREF
  int v103; // [rsp+128h] [rbp+8h]
  int v104; // [rsp+12Ch] [rbp+Ch]
  bool v105; // [rsp+860h] [rbp+740h]
  unsigned int v108; // [rsp+878h] [rbp+758h]

  v3 = 0;
  v5 = a2;
  v87 = 0;
  v94 = *((_DWORD *)a2 + 1);
  v7 = 5;
  if ( *((_BYTE *)this + 233) )
    v7 = 13;
  v8 = *(_QWORD *)this;
  v105 = 0;
  v92 = 0i64;
  v91 = 0i64;
  result = (*(__int64 (__fastcall **)(CSsl3TlsContext *))(v8 + 432))(this);
  v81 = result;
  v10 = result;
  if ( (_DWORD)result )
    return result;
  v11 = *((_DWORD *)this + 17);
  if ( (v11 < 6 || v11 >= 91) && v11 >= 2 )
  {
    switch ( v11 )
    {
      case 2:
      case 4:
      case 5:
      case 91:
      case 93:
      case 95:
      case 96:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        if ( *((_BYTE *)this + 233) && *((_DWORD *)this + 17) == 91 )
        {
          result = CSsl3TlsContext::GenerateResponseCommon(this, (struct SPBuffer *)&v91);
          if ( !(_DWORD)result && v92 )
            result = CSsl3TlsContext::DtlsGetOutgoingRecord(this, (struct SPBuffer *)&v91, a3);
        }
        else
        {
          result = CSsl3TlsContext::GenerateResponseCommon(this, a3);
        }
        break;
      default:
        goto LABEL_6;
    }
    return result;
  }
LABEL_6:
  if ( v11 == 76 && !*((_BYTE *)this + 555) && *((_QWORD *)v5 + 1) && (*((_DWORD *)this + 16) & 0x50000) != 0 )
  {
    v12 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
      v12 = WPP_GLOBAL_Control;
      v10 = 0;
    }
    if ( *((_BYTE *)this + 266) )
    {
      if ( *((_DWORD *)this + 18) == 77 )
      {
LABEL_136:
        v105 = *((_BYTE *)this + 472) == 0;
        goto LABEL_8;
      }
      *((_DWORD *)this + 18) = *((_DWORD *)this + 17);
    }
    AppDataStatus = RemotelyGetAppDataStatus(this);
    v81 = AppDataStatus;
    v10 = AppDataStatus;
    if ( AppDataStatus == 590610 )
    {
      *((_DWORD *)this + 17) = 77;
      v47 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        v48 = 12i64;
        goto LABEL_296;
      }
      return 590610i64;
    }
    if ( AppDataStatus )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        return v81;
      }
      return v10;
    }
    v12 = WPP_GLOBAL_Control;
    goto LABEL_136;
  }
  v12 = WPP_GLOBAL_Control;
LABEL_8:
  v13 = (unsigned __int8 *)*((_QWORD *)v5 + 1);
  v14 = *((_DWORD *)v5 + 1);
  v90 = v13;
  v88 = v14;
  while ( 1 )
  {
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)v12 + 2), 14i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
      v12 = WPP_GLOBAL_Control;
      v10 = v81;
    }
    if ( v14 < v7 )
      break;
    v15 = *v13;
    v108 = v15;
    if ( (unsigned int)(v15 - 20) > 3 )
    {
      CSslContext::SetErrorAndFatalAlert((__int64)this, 10, -2146893048, 0xAu);
      return 2148074248i64;
    }
    v16 = v13[2] | (v13[1] << 8);
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
    {
      WPP_SF_D(*((_QWORD *)v12 + 2), 15i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids, v16);
      v12 = WPP_GLOBAL_Control;
      v15 = v108;
    }
    if ( v16 < 0x300 )
    {
      if ( *((_DWORD *)this + 9) >= 0x302u && (*((_DWORD *)this + 16) & 0x800A00AA) != 0 )
      {
        v74 = -2146893018;
        CSslContext::SetError((__int64)this, 11, -2146893018);
      }
      else
      {
        v74 = -2146893048;
        CSslContext::SetErrorAndFatalAlert((__int64)this, 11, -2146893048, 0x46u);
      }
      return v74;
    }
    if ( v13[1] == 0xFE && (v13[2] | (v13[1] << 8)) <= 0xFEFFu )
    {
      v17 = v13[11];
      v18 = v13[12];
    }
    else
    {
      v17 = v13[3];
      v18 = v13[4];
    }
    v19 = v18 | (v17 << 8);
    v84 = v19;
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
    {
      WPP_SF_D(*((_QWORD *)v12 + 2), 16i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids, v19);
      v15 = v108;
    }
    v20 = v19 + v7;
    v93 = v19 + v7;
    if ( v19 + v7 > v88 )
    {
      if ( !v87 )
      {
        *((_DWORD *)v5 + 1) = v20;
        CSslContext::SetError((__int64)this, 13, -2146893032);
        return 2148074264i64;
      }
      v10 = v81;
LABEL_104:
      if ( *((_BYTE *)this + 233) && !v10 )
      {
        if ( v92 )
          return (unsigned int)CSsl3TlsContext::DtlsGetOutgoingRecord(this, (struct SPBuffer *)&v91, a3);
      }
      return v10;
    }
    *((_DWORD *)v5 + 1) = v20 + v87;
    v87 += v20;
    if ( *((_BYTE *)this + 233) )
    {
      v49 = 0i64;
      v50 = 0;
      v51 = 0;
      v83 = 0;
      v86 = 0i64;
      v95 = v13[10] | ((v13[9] | ((v13[8] | ((v13[7] | ((v13[6] | ((v13[5] | ((v13[4] | ((unsigned __int64)v13[3] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v52 = HIWORD(v95);
      v89 = HIWORD(v95);
      v53 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          LODWORD(v79) = v95;
          WPP_SF_DD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x11u,
            (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
            v52,
            v79);
          v53 = WPP_GLOBAL_Control;
          v20 = v19 + v7;
          LOBYTE(v15) = v108;
          v49 = 0i64;
          LODWORD(v52) = v89;
          v50 = 0;
        }
        if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
        {
          LODWORD(v80) = **((_DWORD **)this + 28);
          LODWORD(v79) = *((unsigned __int16 *)this + 110);
          WPP_SF_DDD(
            *((_QWORD *)v53 + 2),
            0x12u,
            (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
            *((_DWORD *)this + 48),
            v79,
            v80);
          v53 = WPP_GLOBAL_Control;
          v20 = v19 + v7;
          LOBYTE(v15) = v108;
          v49 = 0i64;
          LODWORD(v52) = v89;
          v50 = 0;
        }
      }
      if ( v105 )
      {
        if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
        {
          WPP_SF_(*((_QWORD *)v53 + 2), 19i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          v53 = WPP_GLOBAL_Control;
          v20 = v19 + v7;
          LOBYTE(v15) = v108;
          v49 = 0i64;
          LODWORD(v52) = v89;
          v50 = 0;
        }
        v54 = *((_DWORD *)this + 48);
        v55 = (_DWORD)v52 == v54;
        if ( (unsigned int)v52 < v54 )
        {
          if ( (_BYTE)v15 == 20 )
          {
            if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_BYTE *)v53 + 28) & 4) != 0 )
              {
                v71 = 20i64;
                goto LABEL_272;
              }
              goto LABEL_273;
            }
            goto LABEL_276;
          }
          v55 = (_DWORD)v52 == v54;
        }
        if ( v55 )
        {
          if ( (_BYTE)v15 == 23 )
          {
            if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_BYTE *)v53 + 28) & 4) != 0 )
              {
                v71 = 21i64;
LABEL_272:
                WPP_SF_(*((_QWORD *)v53 + 2), v71, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
                v53 = WPP_GLOBAL_Control;
              }
LABEL_273:
              if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
                WPP_SF_(*((_QWORD *)v53 + 2), 27i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
            }
LABEL_276:
            LogDtlsRetransmitRequested(
              *(_DWORD *)(*((_QWORD *)this + 10) + 212i64),
              (const unsigned __int16 *)(*((_QWORD *)this + 10) + 216i64));
            DTlsMsgMgr::swapSaveAndOutgoing(*((DTlsMsgMgr **)this + 72));
            v74 = CSsl3TlsContext::RestoreWriteCipherState(this);
            if ( v74 )
            {
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 28i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
                return v74;
              }
            }
            else
            {
              *((_QWORD *)this + 17) &= ~0x40000000ui64;
              *((_BYTE *)this + 265) = 1;
              *((_DWORD *)this + 17) = 4;
              if ( v83 || *((_BYTE *)this + 266) )
                return CSsl3TlsContext::PrepareNextOutgoingRecord(this, a3);
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
              {
                WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 29i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
              }
              UserKeys = RemotelyGetUserKeys(this, 1u);
              v74 = UserKeys;
              if ( !UserKeys )
                return CSsl3TlsContext::PrepareNextOutgoingRecord(this, a3);
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                WPP_SF_D(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  30i64,
                  &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
                  UserKeys);
                return v74;
              }
            }
            return v74;
          }
          if ( (_BYTE)v15 == 22 && (*((_BYTE *)this + 32) & 2) != 0 )
          {
            v56 = *((_QWORD *)this + 1);
            if ( v56 )
            {
              if ( *(_DWORD *)(v56 + 28) )
              {
                if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
                {
                  WPP_SF_(*((_QWORD *)v53 + 2), 22i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
                  v20 = v19 + v7;
                }
                v96[0] = v20;
                v96[1] = v20;
                v97 = v13;
                if ( (unsigned int)CSsl3TlsContext::UnwrapMessage(this, (struct SPBuffer *)v96) )
                {
                  v47 = WPP_GLOBAL_Control;
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                  {
                    v48 = 23i64;
                    goto LABEL_296;
                  }
                  return 590610i64;
                }
                v50 = 1;
                v83 = 1;
                if ( (*((_BYTE *)this + 32) & 2) != 0 )
                  v57 = *((unsigned int *)this + 11);
                else
                  v57 = 0i64;
                if ( v13[1] == 0xFE && (v13[2] | (v13[1] << 8)) <= 0xFEFFu )
                {
                  v58 = v13[11];
                  v59 = v13[12];
                }
                else
                {
                  v58 = v13[3];
                  v59 = v13[4];
                }
                v51 = v59 | (v58 << 8);
                if ( v19 < (unsigned int)v57 + v51 + v7 )
                {
                  v72 = WPP_GLOBAL_Control;
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                  {
                    v73 = 24i64;
                    goto LABEL_310;
                  }
                  return 2148074278i64;
                }
                v49 = &v13[v7 + v57];
                v86 = (DTlsMessage *)v49;
                if ( !v51 )
                {
                  v72 = WPP_GLOBAL_Control;
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                  {
                    v73 = 25i64;
                    goto LABEL_310;
                  }
                  return 2148074278i64;
                }
                if ( *v49 == 20 )
                {
                  v53 = WPP_GLOBAL_Control;
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
                  {
                    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
                    {
                      v71 = 26i64;
                      goto LABEL_272;
                    }
                    goto LABEL_273;
                  }
                  goto LABEL_276;
                }
                v53 = WPP_GLOBAL_Control;
                v20 = v19 + v7;
                LODWORD(v52) = v89;
              }
            }
          }
        }
      }
      if ( *((_DWORD *)this + 17) == 76 && *((_BYTE *)this + 233) )
      {
        if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
        {
          WPP_SF_(*((_QWORD *)v53 + 2), 31i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          v50 = v83;
          LODWORD(v52) = v89;
        }
        *(_DWORD *)(*((_QWORD *)this + 73) + 36i64) = *(__int16 *)(*(_QWORD *)(*((_QWORD *)this + 73) + 40i64) + 192i64);
        v20 = v19 + v7;
        v53 = WPP_GLOBAL_Control;
        v49 = (unsigned __int8 *)v86;
      }
      if ( (*((_BYTE *)this + 32) & 2) != 0 && (v60 = *((_QWORD *)this + 1)) != 0 && *(_DWORD *)(v60 + 28) )
      {
        if ( !v50 )
        {
          if ( (_DWORD)v52 == *(_DWORD *)(*((_QWORD *)this + 73) + 36i64) )
          {
            if ( (unsigned int)v52 < *((_DWORD *)this + 48) )
            {
              if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
                WPP_SF_(*((_QWORD *)v53 + 2), 32i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
              LogDtlsRecordOutOfRecvWindow(
                *(_DWORD *)(*((_QWORD *)this + 10) + 212i64),
                (const unsigned __int16 *)(*((_QWORD *)this + 10) + 216i64));
              return 590610i64;
            }
            if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
            {
              WPP_SF_(*((_QWORD *)v53 + 2), 33i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
              v20 = v19 + v7;
            }
            v98[0] = v20;
            v98[1] = v20;
            v99 = v13;
            if ( (unsigned int)CSsl3TlsContext::UnwrapMessage(this, (struct SPBuffer *)v98) )
            {
              v47 = WPP_GLOBAL_Control;
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                v48 = 34i64;
LABEL_296:
                WPP_SF_(*((_QWORD *)v47 + 2), v48, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
              }
              return 590610i64;
            }
            if ( (*((_BYTE *)this + 32) & 2) != 0 )
              v61 = *((unsigned int *)this + 11);
            else
              v61 = 0i64;
            if ( v13[1] == 0xFE && (v13[2] | (v13[1] << 8)) <= 0xFEFFu )
            {
              v62 = v13[11];
              v63 = v13[12];
            }
            else
            {
              v62 = v13[3];
              v63 = v13[4];
            }
            v51 = v63 | (v62 << 8);
            if ( v19 < (unsigned int)v61 + v51 + v7 )
            {
              v72 = WPP_GLOBAL_Control;
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                v73 = 35i64;
                goto LABEL_310;
              }
              return 2148074278i64;
            }
            v49 = &v13[v7 + v61];
            goto LABEL_202;
          }
LABEL_198:
          if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
            WPP_SF_(*((_QWORD *)v53 + 2), 36i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          v51 = v19;
          v49 = &v13[v7];
        }
      }
      else if ( !v50 )
      {
        goto LABEL_198;
      }
LABEL_202:
      DTlsHandshakeQueue::DtlsReorderHandshake(*((_QWORD *)this + 73), v108, (__int64)v49, v51, v95);
      v15 = v108;
      v20 = v93;
    }
    v21 = 0i64;
    v85 = 0i64;
    v22 = v15;
    v82 = v15;
    v23 = 0i64;
    v24 = 0;
    if ( (*((_DWORD *)this + 16) & 0x3000) != 0 && (_BYTE)v15 == 20 )
    {
      v29 = v84;
      v64 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, unsigned __int8 *, _QWORD, _QWORD))(*(_QWORD *)this + 488i64))(
              this,
              v13,
              v7,
              v84);
      v65 = v64;
      if ( v64 )
      {
        if ( v64 == -2146893018 || v64 == -2146893048 )
          CSslContext::SetErrorAndFatalAlert((__int64)this, 904, v64, 0xAu);
        return v65;
      }
      v12 = WPP_GLOBAL_Control;
      v24 = 0;
    }
    else
    {
      if ( *((_BYTE *)this + 233) )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 54i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        NextReadyHandshakeMsg = DTlsHandshakeQueue::GetNextReadyHandshakeMsg(*((DTlsMsgMgr ***)this + 73), v21, v15);
        v85 = NextReadyHandshakeMsg;
        v21 = (__int64)NextReadyHandshakeMsg;
        if ( NextReadyHandshakeMsg )
        {
          v22 = *((_DWORD *)NextReadyHandshakeMsg + 16);
          v23 = (unsigned __int8 *)*((_QWORD *)NextReadyHandshakeMsg + 5);
          v24 = *((_DWORD *)NextReadyHandshakeMsg + 5);
          v82 = v22;
        }
        else
        {
          v22 = v82;
        }
        v12 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 55i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids, v22);
          v12 = WPP_GLOBAL_Control;
          v22 = v82;
          v21 = (__int64)v85;
        }
        LODWORD(v15) = v108;
      }
      else
      {
        v24 = v20;
        v23 = v13;
        v12 = WPP_GLOBAL_Control;
      }
      if ( v23 )
      {
        v25 = v24;
        while ( 1 )
        {
          if ( (*((_BYTE *)this + 32) & 2) != 0
            && (v41 = *((_QWORD *)this + 1)) != 0
            && *(_DWORD *)(v41 + 28)
            && (!*((_BYTE *)this + 233) || v21 && *(_DWORD *)(v21 + 68)) )
          {
            v42 = *((_DWORD *)this + 17) - 78;
            v100[0] = v24;
            v100[1] = v24;
            v101 = v23;
            if ( v42 <= 1 && v25 > v7 && *v23 == 22 )
            {
              if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
              {
                WPP_SF_(*((_QWORD *)v12 + 2), 37i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
                LODWORD(v15) = v108;
                v22 = v82;
              }
              v67 = *(unsigned __int16 *)&v23[v25 - 2];
              if ( v67 > v25 - v7 )
                return 2148074248i64;
              if ( *((_BYTE *)this + 233) )
              {
                v23[11] = BYTE1(v67);
                v23[12] = v67;
              }
              else
              {
                v23[3] = BYTE1(v67);
                v23[4] = v67;
              }
            }
            else
            {
              if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
                WPP_SF_(*((_QWORD *)v12 + 2), 38i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
              result = CSsl3TlsContext::UnwrapMessage(this, (struct SPBuffer *)v100);
              if ( (_DWORD)result )
              {
                if ( !*((_BYTE *)this + 233) )
                  return result;
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                {
                  WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 39i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
                }
              }
              if ( (*((_DWORD *)this + 16) & 0x3000) != 0 )
              {
                LODWORD(v15) = *v23;
                v108 = v15;
                v22 = v15;
                if ( (_DWORD)v15 == 20 )
                {
                  CSslContext::SetErrorAndFatalAlert((__int64)this, 904, -2146893018, 0xAu);
                  return 2148074278i64;
                }
              }
              else
              {
                LODWORD(v15) = v108;
                v22 = v82;
              }
            }
            if ( (*((_BYTE *)this + 32) & 2) != 0 )
              v43 = *((_DWORD *)this + 11);
            else
              v43 = 0;
            if ( v23[1] == 0xFE && (v23[2] | (v23[1] << 8)) <= 0xFEFFu )
            {
              v44 = v23[11];
              v45 = v23[12];
            }
            else
            {
              v44 = v23[3];
              v45 = v23[4];
            }
            v25 = v45 | (v44 << 8);
            if ( v24 < v43 + v25 + v7 )
            {
              v72 = WPP_GLOBAL_Control;
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                v73 = 40i64;
LABEL_310:
                WPP_SF_(*((_QWORD *)v72 + 2), v73, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
              }
              return 2148074278i64;
            }
            v23 += v7 + v43;
          }
          else if ( !*((_BYTE *)this + 233) || v22 == 20 )
          {
            v23 += v7;
            v25 -= v7;
          }
          if ( (((_DWORD)v15 - 20) & 0xFFFFFFFC) == 0 && (_DWORD)v15 != 21 )
            *((_BYTE *)this + 473) = 0;
          v27 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, _QWORD, unsigned __int8 *, _QWORD))(*(_QWORD *)this
                                                                                                + 464i64))(
                  this,
                  v22,
                  v23,
                  v25);
          if ( v27 )
            break;
          if ( v85 )
            DTlsMessage::`scalar deleting destructor'(v85);
          v23 = 0i64;
          v24 = 0;
          v82 = v108;
          if ( (*((_DWORD *)this + 16) & 0x3000) != 0 && v108 == 20 )
          {
            v68 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 488i64))(
                    this,
                    0i64,
                    0i64,
                    0i64);
            v27 = v68;
            if ( !v68 )
            {
LABEL_42:
              v12 = WPP_GLOBAL_Control;
LABEL_44:
              v13 = v90;
              goto LABEL_45;
            }
            if ( v68 == -2146893018 || v68 == -2146893048 )
            {
              CSslContext::SetErrorAndFatalAlert((__int64)this, 904, v68, 0xAu);
              return v27;
            }
            return v27;
          }
          if ( !*((_BYTE *)this + 233) )
            goto LABEL_42;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 54i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          }
          v69 = DTlsHandshakeQueue::GetNextReadyHandshakeMsg(*((DTlsMsgMgr ***)this + 73), v26, v28);
          v85 = v69;
          v21 = (__int64)v69;
          if ( v69 )
          {
            v22 = *((_DWORD *)v69 + 16);
            v23 = (unsigned __int8 *)*((_QWORD *)v69 + 5);
            v24 = *((_DWORD *)v69 + 5);
            v82 = v22;
          }
          else
          {
            v22 = v108;
          }
          v12 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 55i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids, v22);
            v12 = WPP_GLOBAL_Control;
            v22 = v82;
            v21 = (__int64)v85;
          }
          v25 = v24;
          if ( !v23 )
            goto LABEL_44;
          LODWORD(v15) = v108;
        }
        if ( (*((_DWORD *)this + 34) & 0x40000) != 0 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 41i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          }
          *((_DWORD *)a2 + 1) = v94;
        }
        else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
               && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 42i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids, v27);
        }
        return v27;
      }
LABEL_45:
      v29 = v84;
    }
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
    {
      WPP_SF_d(*((_QWORD *)v12 + 2), 0x2Bu, (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids, v24);
      v12 = WPP_GLOBAL_Control;
    }
    v30 = *((_DWORD *)this + 17);
    v13 += v29 + v7;
    v14 = v88 - (v29 + v7);
    v90 = v13;
    v88 = v14;
    if ( (unsigned int)(v30 - 91) <= 0xB )
    {
      if ( !*((_BYTE *)this + 233) )
        return CSsl3TlsContext::GenerateResponseCommon(this, a3);
      ResponseCommon = CSsl3TlsContext::GenerateResponseCommon(this, (struct SPBuffer *)&v91);
      v30 = *((_DWORD *)this + 17);
      v10 = ResponseCommon;
      v12 = WPP_GLOBAL_Control;
    }
    else
    {
      v10 = 0;
    }
    v81 = v10;
    if ( v30 == 4 || v30 == 79 || !v14 )
      goto LABEL_104;
    v5 = a2;
  }
  if ( v87 )
    goto LABEL_104;
  *((_DWORD *)v5 + 1) = v7;
  v31 = *((_QWORD *)this + 16);
  if ( !*(_WORD *)(v31 + 34) )
  {
    *(_WORD *)(v31 + 34) = 13;
    *(_DWORD *)(v31 + 36) = -2146893032;
  }
  memset_0(v102, 0, 0x6E8ui64);
  v32 = *((_QWORD *)this + 1);
  if ( v32 )
    v3 = *(_DWORD *)(v32 + 28);
  v33 = *((unsigned __int16 *)this + 17);
  v34 = *((_QWORD *)this + 17);
  v35 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
  v104 = *((_DWORD *)this + 4);
  v103 = v3;
  if ( v32 )
  {
    v36 = *((_QWORD *)this + 11);
    if ( v36 )
    {
      v37 = *((_QWORD *)this + 15);
      v38 = *(_DWORD *)(v32 + 32);
      if ( v37 )
      {
        if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
        {
          *(_DWORD *)(v37 + 48) = *(_DWORD *)(v36 + 8);
          if ( v38 == 43522 || v38 == 41984 )
          {
            KeyExchangeInfo = GetKeyExchangeInfo(v38);
            if ( KeyExchangeInfo )
            {
              v78[13] = *((_DWORD *)KeyExchangeInfo + 8);
              v78[14] = *((_DWORD *)KeyExchangeInfo + 10);
              if ( v77 == 43522 )
                v78[15] = *((_DWORD *)KeyExchangeInfo + 12);
            }
          }
        }
      }
    }
  }
  v39 = *((_QWORD *)this + 15);
  v40 = v39;
  if ( v39 && v35 )
  {
    *(_DWORD *)(v39 + 36) = v104;
    *(_DWORD *)(v39 + 104) = -2146893032;
    *(_DWORD *)(v39 + 112) = 13;
    *(_DWORD *)(v39 + 32) = v3;
    *(_DWORD *)(v39 + 40) = v33;
    *(_QWORD *)(v39 + 128) = v34;
    v40 = *((_QWORD *)this + 15);
  }
  if ( v40
    && v35
    && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_SSSdiiDDDDDddiDDd(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      *(unsigned __int16 *)(v40 + 66),
      *(unsigned __int16 *)(v40 + 64),
      L"Error",
      (const wchar_t *)(v40 + 152),
      (const wchar_t *)(v40 + 664),
      *(_DWORD *)(v40 + 24),
      *(_QWORD *)(v40 + 120),
      *(_QWORD *)(v40 + 128),
      *(_DWORD *)(v40 + 32),
      *(_DWORD *)(v40 + 36),
      *(_DWORD *)(v40 + 40),
      *(_DWORD *)(v40 + 44),
      *(_DWORD *)(v40 + 48),
      *(_WORD *)(v40 + 64),
      *(_WORD *)(v40 + 66),
      *(_QWORD *)(v40 + 96),
      *(_DWORD *)(v40 + 104),
      *(unsigned __int8 *)(v40 + 108),
      *(_DWORD *)(v40 + 112));
  }
  return 2148074264i64;
}
// 18003B4F3: conditional instruction was optimized away because rsi.8!=0
// 180011D98: variable 'v35' is possibly undefined
// 18003B056: variable 'v79' is possibly undefined
// 18003B0B2: variable 'v80' is possibly undefined
// 18003B464: variable 'v21' is possibly undefined
// 18003B464: variable 'v15' is possibly undefined
// 18003B6C0: variable 'v26' is possibly undefined
// 18003B6C0: variable 'v28' is possibly undefined
// 18003BB51: variable 'v78' is possibly undefined
// 18003BB63: variable 'v77' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 1800119B0: using guessed type char var_730[8];

//----- (0000000180011F40) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::GenerateResponseCommon(CSsl3TlsContext *this, struct SPBuffer *a2)
{
  __int64 result; // rax
  __int64 v5; // r8
  int v6; // ecx
  unsigned int v7; // edi
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  CCipherMill *v12; // rcx
  __int64 v13; // rdx

  if ( !*((_QWORD *)this + 11) )
    return 1359i64;
  result = (*(__int64 (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 472i64))(this);
  if ( !(_DWORD)result )
  {
    v6 = *((_DWORD *)this + 17);
    if ( v6 >= 80 && v6 < 96 )
      goto LABEL_5;
    v8 = v6 - 2;
    if ( v8 )
    {
      v9 = v8 - 1;
      if ( !v9 )
      {
        v12 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_27;
        v13 = 47i64;
        goto LABEL_26;
      }
      v10 = v9 - 2;
      if ( v10 )
      {
        v11 = v10 - 74;
        if ( v11 )
        {
          if ( v11 != 17 )
          {
LABEL_5:
            v7 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, struct SPBuffer *))(*(_QWORD *)this + 424i64))(this, a2);
LABEL_6:
            if ( !v7 )
              return v7;
            if ( (v7 & 0x80000000) == 0 )
            {
              if ( (v7 & 0x1FFF0000) == 589824 )
                return v7;
            }
            else if ( v7 == -2146893032 || v7 == -2146893023 || v7 == -2146892950 || v7 == -2146892949 )
            {
              return v7;
            }
            v12 = WPP_GLOBAL_Control;
LABEL_42:
            if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v12 + 2), 49i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
            *((_DWORD *)this + 17) = 96;
            return v7;
          }
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 45i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          }
          v7 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, struct SPBuffer *, _QWORD, _QWORD))(*(_QWORD *)this + 392i64))(
                 this,
                 a2,
                 *((unsigned __int8 *)this + 96),
                 *((unsigned __int8 *)this + 97));
          *((_WORD *)this + 48) = 0;
LABEL_19:
          *((_DWORD *)this + 17) = 3;
          goto LABEL_6;
        }
        v12 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
        {
LABEL_27:
          v7 = -2146893033;
          goto LABEL_42;
        }
        v13 = 48i64;
LABEL_26:
        WPP_SF_(*((_QWORD *)v12 + 2), v13, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        v12 = WPP_GLOBAL_Control;
        goto LABEL_27;
      }
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 46i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    LOBYTE(v5) = 1;
    v7 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, struct SPBuffer *, __int64, _QWORD))(*(_QWORD *)this + 392i64))(
           this,
           a2,
           v5,
           0i64);
    if ( (*((_DWORD *)this + 16) & 0x3000) != 0 && *((_DWORD *)this + 17) == 2 )
    {
      *((_DWORD *)this + 17) = 79;
      goto LABEL_6;
    }
    goto LABEL_19;
  }
  return result;
}
// 18003BDFC: variable 'v5' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180011FF0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::UnwrapMessage(CSsl3TlsContext *this, struct SPBuffer *a2)
{
  __int16 v4; // r9
  int v5; // r8d
  int v6; // r10d
  _BYTE *v7; // rdx
  _BYTE *v8; // rbp
  int v9; // ecx
  int v10; // eax
  unsigned __int64 v11; // r14
  __int64 *v12; // rax
  __int64 v13; // rcx
  unsigned int v14; // eax
  int v15; // esi
  _BYTE *v16; // rcx
  __int64 v18; // rcx
  __int64 v19; // rax
  int UserKeys; // eax
  unsigned int v21; // r14d
  unsigned __int8 *v22; // rcx
  bool v23; // zf
  char v24; // cl
  __int16 v25; // [rsp+80h] [rbp+8h]

  v25 = 0;
  v4 = *((_WORD *)this + 16) & 2;
  if ( v4 )
  {
    v5 = *((_DWORD *)this + 11);
    v6 = *((_DWORD *)this + 12);
  }
  else
  {
    v5 = 0;
    v6 = 0;
  }
  v7 = (_BYTE *)*((_QWORD *)a2 + 1);
  v8 = &v7[*((unsigned int *)this + 15) + v5];
  if ( v7[1] == 0xFE && ((unsigned __int8)v7[2] | ((unsigned __int8)v7[1] << 8)) <= 0xFEFFu )
  {
    v9 = (unsigned __int8)v7[11];
    v10 = (unsigned __int8)v7[12];
  }
  else
  {
    v9 = (unsigned __int8)v7[3];
    v10 = (unsigned __int8)v7[4];
  }
  if ( (v10 | (unsigned int)(v9 << 8)) < v6 + v5 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 959, -2146893018, 0x32u);
    return 2148074278i64;
  }
  if ( !*((_QWORD *)this + 18) )
  {
    if ( v4 )
    {
      v19 = *((_QWORD *)this + 1);
      if ( v19 )
      {
        if ( *(_DWORD *)(v19 + 28) )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids);
          }
          UserKeys = RemotelyGetUserKeys(this, 1u);
          v21 = UserKeys;
          if ( UserKeys )
          {
            CSslContext::SetErrorAndFatalAlert((__int64)this, 961, UserKeys, 0x50u);
            return v21;
          }
        }
      }
    }
  }
  if ( *((_BYTE *)this + 233) )
  {
    v22 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
    v11 = v22[10] | ((v22[9] | ((v22[8] | ((v22[7] | ((v22[6] | ((v22[5] | ((v22[4] | ((unsigned __int64)v22[3] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
  }
  else
  {
    v11 = *((_QWORD *)this + 22);
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_Di(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x10u,
      (__int64)&WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids,
      *(_DWORD *)a2,
      v11);
  v12 = (__int64 *)*((_QWORD *)this + 1);
  if ( v12 )
    v13 = *v12;
  else
    v13 = 0i64;
  v14 = SslDecryptPacket(v13, *((_QWORD *)this + 18), *((_QWORD *)a2 + 1));
  v15 = v14;
  if ( v14 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 17i64, &WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids, v14);
    if ( *((_DWORD *)this + 9) >= 0x302u && (*((_DWORD *)this + 16) & 0x800A00AA) != 0 )
    {
      CSslContext::SetError((__int64)this, 962, v15);
      return 2148074278i64;
    }
    else
    {
      CSslContext::SetErrorAndFatalAlert((__int64)this, 960, v15, 0x14u);
      return 2148074288i64;
    }
  }
  else
  {
    if ( (*((_DWORD *)this + 16) & 0x3000) != 0 )
    {
      LODWORD(v18) = 0;
      do
      {
        v23 = (_DWORD)v18 == 1;
        v18 = (unsigned int)(v18 - 1);
        v25 = v18;
      }
      while ( !v23 && !v8[v18] );
      v24 = v8[v18];
      if ( !v24 )
      {
        CSslContext::SetErrorAndFatalAlert((__int64)this, 960, -2146893048, 0xAu);
        return 2148074248i64;
      }
      **((_BYTE **)a2 + 1) = v24;
    }
    v16 = (_BYTE *)*((_QWORD *)a2 + 1);
    if ( *((_BYTE *)this + 233) )
    {
      v16[11] = HIBYTE(v25);
      v16[12] = v25;
    }
    else
    {
      v16[3] = HIBYTE(v25);
      v16[4] = v25;
      ++*((_QWORD *)this + 22);
    }
    return 0i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800984E0: using guessed type __int64 __fastcall SslDecryptPacket(_QWORD, _QWORD, _QWORD);

//----- (0000000180012184) ----------------------------------------------------
void __fastcall CSslContext::SetError(__int64 a1, int a2, int a3)
{
  __int64 v3; // rax
  __int64 v7; // r8
  __int64 v8; // rcx
  int v9; // edi
  int v10; // r14d
  __int64 v11; // r15
  __int64 v12; // rcx
  unsigned __int64 v13; // rax
  __int64 v14; // rax
  char v15[8]; // [rsp+20h] [rbp-708h] BYREF
  unsigned __int64 v16; // [rsp+28h] [rbp-700h]

  v3 = *(_QWORD *)(a1 + 128);
  if ( !*(_WORD *)(v3 + 34) )
  {
    *(_WORD *)(v3 + 34) = a2;
    *(_DWORD *)(v3 + 36) = a3;
  }
  memset_0(v15, 0, 0x6E8ui64);
  v8 = *(_QWORD *)(a1 + 8);
  if ( v8 )
  {
    v9 = *(_DWORD *)(v8 + 28);
    LODWORD(v16) = v9;
  }
  else
  {
    v9 = 0;
    LODWORD(v16) = 0;
  }
  v10 = *(unsigned __int16 *)(a1 + 34);
  v11 = *(_QWORD *)(a1 + 136);
  HIDWORD(v16) = *(_DWORD *)(a1 + 16);
  if ( v8 )
  {
    v14 = *(_QWORD *)(a1 + 88);
    if ( v14 )
      CSchannelTelemetryContext::LogKeyExchange(
        *(CSchannelTelemetryContext **)(a1 + 120),
        *(_DWORD *)(v8 + 32),
        *(_DWORD *)(v14 + 8));
  }
  v12 = *(_QWORD *)(a1 + 120);
  if ( v12 )
  {
    if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    {
      v13 = HIDWORD(v16);
      *(_DWORD *)(v12 + 104) = a3;
      *(_DWORD *)(v12 + 112) = a2;
      *(_DWORD *)(v12 + 32) = v9;
      *(_DWORD *)(v12 + 36) = v13;
      *(_DWORD *)(v12 + 40) = v10;
      *(_QWORD *)(v12 + 128) = v11;
      if ( a3 != -2146893032 )
        CSchannelTelemetryContext::WriteEvent((CSchannelTelemetryContext *)v12, 1, v7);
    }
  }
  CSchannelTelemetryContext::LogDebugTraceHandshakeInfo(*(CSchannelTelemetryContext **)(a1 + 120), L"Error");
}
// 18001229B: variable 'v7' is possibly undefined
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 180012184: using guessed type char var_708[8];

//----- (00000001800122B0) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::SetStateConnected(CSchannelTelemetryContext **this)
{
  CSchannelTelemetryContext *v2; // rcx
  CSchannelTelemetryContext *v3; // rax
  char Src[8]; // [rsp+20h] [rbp-DE8h] BYREF
  int v5; // [rsp+28h] [rbp-DE0h]
  int v6; // [rsp+2Ch] [rbp-DDCh]
  int v7; // [rsp+30h] [rbp-DD8h]
  CSchannelTelemetryContext *v8; // [rsp+88h] [rbp-D80h]
  LARGE_INTEGER v9[223]; // [rsp+710h] [rbp-6F8h] BYREF

  CSsl3TlsContext::SetStateConnected((CSsl3TlsContext *)this);
  memset_0(Src, 0, 0x6E8ui64);
  v2 = this[1];
  if ( v2 )
    v5 = *((_DWORD *)v2 + 7);
  v6 = *((_DWORD *)this + 4);
  v7 = *((unsigned __int16 *)this + 17);
  v8 = this[17];
  if ( v2 )
  {
    v3 = this[11];
    if ( v3 )
      CSchannelTelemetryContext::LogKeyExchange(this[15], *((_DWORD *)v2 + 8), *((_DWORD *)v3 + 2));
  }
  memcpy_0(v9, Src, 0x6E8ui64);
  CSchannelTelemetryContext::LogHandshakeEnd((LARGE_INTEGER *)this[15], v9);
  CSchannelTelemetryContext::LogDebugTraceHandshakeInfo(this[15], L"Client");
}
// 1800122B0: using guessed type char Src[8];
// 1800122B0: using guessed type LARGE_INTEGER var_6F8[223];

//----- (0000000180012368) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::LogDebugTraceHandshakeInfo(
        CSchannelTelemetryContext *this,
        unsigned __int16 *const a2)
{
  int v2; // [rsp+88h] [rbp-20h]
  int v3; // [rsp+90h] [rbp-18h]
  int v4; // [rsp+98h] [rbp-10h]

  if ( this
    && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized
    && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    v4 = *((_DWORD *)this + 28);
    v3 = *((unsigned __int8 *)this + 108);
    v2 = *((_DWORD *)this + 26);
    WPP_SF_SSSdiiDDDDDddiDDd(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      *((unsigned __int16 *)this + 33),
      *((unsigned __int16 *)this + 32),
      a2,
      (const wchar_t *)this + 76,
      (const wchar_t *)this + 332,
      *((_DWORD *)this + 6),
      *((_QWORD *)this + 15),
      *((_QWORD *)this + 16),
      *((_DWORD *)this + 8),
      *((_DWORD *)this + 9),
      *((_DWORD *)this + 10),
      *((_DWORD *)this + 11),
      *((_DWORD *)this + 12),
      *((_WORD *)this + 32),
      *((_WORD *)this + 33),
      *((_QWORD *)this + 12),
      v2,
      v3,
      v4);
  }
}
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (00000001800123C0) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::LogHandshakeEnd(LARGE_INTEGER *a1, LARGE_INTEGER *a2)
{
  __int64 v3; // r8
  __int64 v4; // rax
  bool v5; // zf

  if ( a1 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
  {
    a1[4].LowPart = a2[1].LowPart;
    a1[4].HighPart = a2[1].HighPart;
    a1[5].LowPart = a2[2].LowPart;
    a1[16] = a2[13];
    QueryPerformanceCounter(a1 + 11);
    v4 = 1000 * (a1[11].QuadPart - a1[10].QuadPart);
    a1[12].QuadPart = v4;
    v5 = a1[13].LowPart == -2146893032;
    a1[12].QuadPart = v4 / CSchannelTelemetryContext::m_liPerfCtrFreq.QuadPart;
    if ( v5 )
    {
      a1[13].LowPart = 0;
      a1[14].LowPart = 0;
    }
    CSchannelTelemetryContext::WriteEvent((CSchannelTelemetryContext *)a1, 0, v3);
  }
}
// 180012440: variable 'v3' is possibly undefined
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180012458) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::LogKeyExchange(CSchannelTelemetryContext *this, int a2, int a3)
{
  struct kexch *KeyExchangeInfo; // rax
  _DWORD *v4; // r9
  int v5; // r10d
  int v6; // r11d

  if ( this )
  {
    if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    {
      *((_DWORD *)this + 12) = a3;
      if ( a2 == 43522 || a2 == 41984 )
      {
        KeyExchangeInfo = GetKeyExchangeInfo(a2);
        if ( KeyExchangeInfo )
        {
          v4[13] = *((_DWORD *)KeyExchangeInfo + 8);
          v4[14] = *((_DWORD *)KeyExchangeInfo + 10);
          if ( v5 == v6 )
            v4[15] = *((_DWORD *)KeyExchangeInfo + 12);
        }
      }
    }
  }
}
// 18003C168: variable 'v4' is possibly undefined
// 18003C176: variable 'v5' is possibly undefined
// 18003C176: variable 'v6' is possibly undefined
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (00000001800124A0) ----------------------------------------------------
void __fastcall CSsl3TlsContext::SetStateConnected(CSsl3TlsContext *this)
{
  __int64 v1; // rax
  unsigned __int16 v3; // ax
  DTlsHandshakeQueue *v4; // rcx

  v1 = *(_QWORD *)this;
  *((_DWORD *)this + 17) = 4;
  (*(void (**)(void))(v1 + 456))();
  if ( *((_BYTE *)this + 233) )
  {
    v3 = CSslContext::computeMaxPayload(this, *((unsigned __int16 *)this + 108));
    v4 = (DTlsHandshakeQueue *)*((_QWORD *)this + 73);
    *((_WORD *)this + 109) = v3;
    DTlsHandshakeQueue::DtlsHandshakeDone(v4);
    **((_DWORD **)this + 72) = 0;
    *((_WORD *)this + 110) = 0;
  }
}

//----- (00000001800124F0) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::WriteEvent(CSchannelTelemetryContext *this, char a2, __int64 a3)
{
  const WCHAR *v3; // rdi
  int v6; // eax
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int16 v10; // [rsp+F0h] [rbp-80h] BYREF
  __int16 v11; // [rsp+F2h] [rbp-7Eh] BYREF
  int v12; // [rsp+F4h] [rbp-7Ch] BYREF
  int v13; // [rsp+F8h] [rbp-78h] BYREF
  int v14; // [rsp+FCh] [rbp-74h] BYREF
  int v15; // [rsp+100h] [rbp-70h] BYREF
  int v16; // [rsp+104h] [rbp-6Ch] BYREF
  int v17; // [rsp+108h] [rbp-68h] BYREF
  int v18; // [rsp+10Ch] [rbp-64h] BYREF
  int v19; // [rsp+110h] [rbp-60h] BYREF
  int v20; // [rsp+114h] [rbp-5Ch] BYREF
  int v21; // [rsp+118h] [rbp-58h] BYREF
  int v22; // [rsp+11Ch] [rbp-54h] BYREF
  int v23; // [rsp+120h] [rbp-50h] BYREF
  __int64 v24; // [rsp+128h] [rbp-48h] BYREF
  const WCHAR *v25; // [rsp+130h] [rbp-40h] BYREF
  __int64 v26; // [rsp+138h] [rbp-38h] BYREF
  __int64 v27; // [rsp+140h] [rbp-30h] BYREF
  __int64 v28; // [rsp+148h] [rbp-28h] BYREF
  __int16 v29; // [rsp+150h] [rbp-20h]
  __int64 v30; // [rsp+158h] [rbp-18h] BYREF
  const WCHAR *v31; // [rsp+160h] [rbp-10h] BYREF
  const WCHAR *v32; // [rsp+168h] [rbp-8h] BYREF
  const WCHAR *v33; // [rsp+170h] [rbp+0h] BYREF
  __int16 v34; // [rsp+178h] [rbp+8h]
  char v35; // [rsp+1A0h] [rbp+30h] BYREF
  char v36; // [rsp+1B0h] [rbp+40h] BYREF
  __int16 v37; // [rsp+1B8h] [rbp+48h] BYREF

  v3 = (const WCHAR *)((char *)this + 152);
  if ( this == (CSchannelTelemetryContext *)-152i64
    || !wcsstr(v3, L".data.microsoft.com") && !wcsstr(v3, L".telemetry.microsoft.com") )
  {
    v6 = *((_DWORD *)this + 3);
    if ( a2 )
    {
      if ( v6 )
      {
        if ( v6 == 1
          && (unsigned int)dword_180091480 > 5
          && (qword_180091490 & 0x400000000000i64) != 0
          && (qword_180091498 & 0x400000000000i64) == qword_180091498 )
        {
          v23 = *((_DWORD *)this + 395);
          v28 = (__int64)this + 1176;
          v29 = *((_WORD *)this + 788);
          v22 = *((_DWORD *)this + 11);
          v21 = *((_DWORD *)this + 28);
          v9 = *((unsigned __int16 *)this + 892);
          v35 = *((_BYTE *)this + 108);
          v20 = *((_DWORD *)this + 26);
          v19 = *((_DWORD *)this + 15);
          v18 = *((_DWORD *)this + 14);
          v17 = *((_DWORD *)this + 13);
          v16 = *((_DWORD *)this + 12);
          v15 = *((_DWORD *)this + 10);
          v14 = *((_DWORD *)this + 9);
          v33 = (const WCHAR *)((char *)this + 1584);
          v13 = *((_DWORD *)this + 18);
          v12 = *((_DWORD *)this + 17);
          v11 = *((_WORD *)this + 33);
          v10 = *((_WORD *)this + 32);
          v27 = *((_QWORD *)this + 16);
          v26 = *((_QWORD *)this + 15);
          v36 = *((_BYTE *)this + 24);
          v37 = v9;
          v34 = v9;
          v25 = (const WCHAR *)((char *)this + 664);
          v24 = 1i64;
          _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteAgg(_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),void const *>::Write<_tlgWrapperByVal<8>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<1>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<2>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperArray<4>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<1>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperArray<4>,_tlgWrapperByVal<4>>(
            v9,
            byte_1800847A6,
            a3,
            (__int64)&v24,
            &v25,
            (__int64)&v36,
            (__int64)&v26,
            (__int64)&v27,
            (__int64)&v10,
            (__int64)&v11,
            (__int64)&v12,
            (__int64)&v13,
            (__int64)&v33,
            (__int64)&v37,
            (__int64)&v14,
            (__int64)&v15,
            (__int64)&v16,
            (__int64)&v17,
            (__int64)&v18,
            (__int64)&v19,
            (__int64)&v20,
            (__int64)&v35,
            (__int64)&v21,
            (__int64)&v22,
            (__int64)&v28,
            (__int64)&v23);
        }
      }
      else if ( (unsigned int)dword_180091480 > 5
             && (qword_180091490 & 0x400000000000i64) != 0
             && (qword_180091498 & 0x400000000000i64) == qword_180091498 )
      {
        v12 = *((_DWORD *)this + 28);
        v35 = *((_BYTE *)this + 108);
        v13 = *((_DWORD *)this + 26);
        v14 = *((_DWORD *)this + 15);
        v15 = *((_DWORD *)this + 14);
        v8 = *((unsigned __int16 *)this + 892);
        v16 = *((_DWORD *)this + 13);
        v17 = *((_DWORD *)this + 12);
        v18 = *((_DWORD *)this + 10);
        v19 = *((_DWORD *)this + 9);
        v28 = (__int64)this + 1584;
        v20 = *((_DWORD *)this + 18);
        v21 = *((_DWORD *)this + 17);
        v10 = *((_WORD *)this + 33);
        v11 = *((_WORD *)this + 32);
        v30 = *((_QWORD *)this + 16);
        v31 = (const WCHAR *)*((_QWORD *)this + 15);
        v36 = *((_BYTE *)this + 24);
        v32 = (const WCHAR *)((char *)this + 664);
        v22 = *((_DWORD *)this + 8);
        v23 = bDomainJoined;
        v24 = *((_QWORD *)this + 12);
        v25 = (const WCHAR *)v24;
        v26 = v24;
        v37 = v8;
        v29 = v8;
        v33 = v3;
        v27 = 1i64;
        _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteAgg(_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),void const *>::Write<_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<1>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<2>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperArray<4>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<1>,_tlgWrapperByVal<4>>(
          v8,
          byte_1800843DE,
          a3,
          (__int64)&v27,
          (__int64)&v26,
          (__int64)&v25,
          (__int64)&v24,
          &v33,
          (__int64)&v23,
          (__int64)&v22,
          &v32,
          (__int64)&v36,
          (__int64)&v31,
          (__int64)&v30,
          (__int64)&v11,
          (__int64)&v10,
          (__int64)&v21,
          (__int64)&v20,
          (__int64)&v28,
          (__int64)&v37,
          (__int64)&v19,
          (__int64)&v18,
          (__int64)&v17,
          (__int64)&v16,
          (__int64)&v15,
          (__int64)&v14,
          (__int64)&v13,
          (__int64)&v35,
          (__int64)&v12);
      }
    }
    else if ( v6 )
    {
      if ( v6 == 1 )
        CSchannelTelemetryContext::WriteServerEvent(this);
    }
    else if ( (unsigned int)dword_180091480 > 5
           && (qword_180091490 & 0x400000000000i64) != 0
           && (qword_180091498 & 0x400000000000i64) == qword_180091498 )
    {
      v23 = *((_DWORD *)this + 28);
      v35 = *((_BYTE *)this + 108);
      v22 = *((_DWORD *)this + 26);
      v21 = *((_DWORD *)this + 15);
      v20 = *((_DWORD *)this + 14);
      v7 = *((unsigned __int16 *)this + 892);
      v19 = *((_DWORD *)this + 13);
      v18 = *((_DWORD *)this + 12);
      v17 = *((_DWORD *)this + 10);
      v16 = *((_DWORD *)this + 9);
      v28 = (__int64)this + 1584;
      v15 = *((_DWORD *)this + 18);
      v14 = *((_DWORD *)this + 17);
      v11 = *((_WORD *)this + 33);
      v10 = *((_WORD *)this + 32);
      v27 = *((_QWORD *)this + 16);
      v26 = *((_QWORD *)this + 15);
      v36 = *((_BYTE *)this + 24);
      v25 = (const WCHAR *)((char *)this + 664);
      v13 = *((_DWORD *)this + 8);
      v12 = bDomainJoined;
      v33 = (const WCHAR *)*((_QWORD *)this + 12);
      v32 = v33;
      v31 = v33;
      v37 = v7;
      v29 = v7;
      v24 = (__int64)v3;
      v30 = 1i64;
      _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteAgg(_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),void const *>::Write<_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<1>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<2>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperArray<4>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<1>,_tlgWrapperByVal<4>>(
        v7,
        byte_1800845BE,
        a3,
        (__int64)&v30,
        (__int64)&v31,
        (__int64)&v32,
        (__int64)&v33,
        (const WCHAR **)&v24,
        (__int64)&v12,
        (__int64)&v13,
        &v25,
        (__int64)&v36,
        (__int64)&v26,
        (__int64)&v27,
        (__int64)&v10,
        (__int64)&v11,
        (__int64)&v14,
        (__int64)&v15,
        (__int64)&v28,
        (__int64)&v37,
        (__int64)&v16,
        (__int64)&v17,
        (__int64)&v18,
        (__int64)&v19,
        (__int64)&v20,
        (__int64)&v21,
        (__int64)&v22,
        (__int64)&v35,
        (__int64)&v23);
    }
  }
}
// 18001277C: variable 'a3' is possibly undefined
// 1800843DE: using guessed type unsigned __int8 byte_1800843DE[480];
// 1800845BE: using guessed type unsigned __int8 byte_1800845BE[488];
// 1800847A6: using guessed type unsigned __int8 byte_1800847A6[437];
// 180091490: using guessed type __int64 qword_180091490;
// 180091498: using guessed type __int64 qword_180091498;
// 180092648: using guessed type int bDomainJoined;

//----- (000000018001278C) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteAgg(_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),void const *>::Write<_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<1>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<2>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperArray<4>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<1>,_tlgWrapperByVal<4>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        const WCHAR **a8,
        __int64 a9,
        __int64 a10,
        const WCHAR **a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16,
        __int64 a17,
        __int64 a18,
        __int64 a19,
        __int64 a20,
        __int64 a21,
        __int64 a22,
        __int64 a23,
        __int64 a24,
        __int64 a25,
        __int64 a26,
        __int64 a27,
        __int64 a28,
        __int64 a29)
{
  __int64 v30; // rcx
  const WCHAR *v31; // rdx
  __int64 v32; // rax
  int v33; // r8d
  const WCHAR *v34; // rdx
  int v35; // eax
  ULONG result; // eax
  unsigned __int8 AggregateFieldTypes; // al
  EVENT_DESCRIPTOR EventDescriptor; // [rsp+38h] [rbp-D0h] BYREF
  unsigned int v39; // [rsp+48h] [rbp-C0h]
  struct _EVENT_DATA_DESCRIPTOR UserData; // [rsp+58h] [rbp-B0h] BYREF
  unsigned __int8 *v41; // [rsp+68h] [rbp-A0h]
  int v42; // [rsp+70h] [rbp-98h]
  int v43; // [rsp+74h] [rbp-94h]
  __int64 v44; // [rsp+78h] [rbp-90h]
  __int64 v45; // [rsp+80h] [rbp-88h]
  __int64 v46; // [rsp+88h] [rbp-80h]
  __int64 v47; // [rsp+90h] [rbp-78h]
  __int64 v48; // [rsp+98h] [rbp-70h]
  __int64 v49; // [rsp+A0h] [rbp-68h]
  __int64 v50; // [rsp+A8h] [rbp-60h]
  __int64 v51; // [rsp+B0h] [rbp-58h]
  const WCHAR *v52; // [rsp+B8h] [rbp-50h]
  int v53; // [rsp+C0h] [rbp-48h]
  int v54; // [rsp+C4h] [rbp-44h]
  __int64 v55; // [rsp+C8h] [rbp-40h]
  __int64 v56; // [rsp+D0h] [rbp-38h]
  __int64 v57; // [rsp+D8h] [rbp-30h]
  __int64 v58; // [rsp+E0h] [rbp-28h]
  const WCHAR *v59; // [rsp+E8h] [rbp-20h]
  int v60; // [rsp+F0h] [rbp-18h]
  int v61; // [rsp+F4h] [rbp-14h]
  __int64 v62; // [rsp+F8h] [rbp-10h]
  __int64 v63; // [rsp+100h] [rbp-8h]
  __int64 v64; // [rsp+108h] [rbp+0h]
  __int64 v65; // [rsp+110h] [rbp+8h]
  __int64 v66; // [rsp+118h] [rbp+10h]
  __int64 v67; // [rsp+120h] [rbp+18h]
  __int64 v68; // [rsp+128h] [rbp+20h]
  __int64 v69; // [rsp+130h] [rbp+28h]
  __int64 v70; // [rsp+138h] [rbp+30h]
  __int64 v71; // [rsp+140h] [rbp+38h]
  __int64 v72; // [rsp+148h] [rbp+40h]
  __int64 v73; // [rsp+150h] [rbp+48h]
  __int64 v74; // [rsp+158h] [rbp+50h]
  __int64 v75; // [rsp+160h] [rbp+58h]
  __int64 v76; // [rsp+168h] [rbp+60h]
  __int64 v77; // [rsp+170h] [rbp+68h]
  __int64 v78; // [rsp+178h] [rbp+70h]
  int v79; // [rsp+180h] [rbp+78h]
  int v80; // [rsp+184h] [rbp+7Ch]
  __int64 v81; // [rsp+188h] [rbp+80h]
  __int64 v82; // [rsp+190h] [rbp+88h]
  __int64 v83; // [rsp+198h] [rbp+90h]
  __int64 v84; // [rsp+1A0h] [rbp+98h]
  __int64 v85; // [rsp+1A8h] [rbp+A0h]
  __int64 v86; // [rsp+1B0h] [rbp+A8h]
  __int64 v87; // [rsp+1B8h] [rbp+B0h]
  __int64 v88; // [rsp+1C0h] [rbp+B8h]
  __int64 v89; // [rsp+1C8h] [rbp+C0h]
  __int64 v90; // [rsp+1D0h] [rbp+C8h]
  __int64 v91; // [rsp+1D8h] [rbp+D0h]
  __int64 v92; // [rsp+1E0h] [rbp+D8h]
  __int64 v93; // [rsp+1E8h] [rbp+E0h]
  __int64 v94; // [rsp+1F0h] [rbp+E8h]
  __int64 v95; // [rsp+1F8h] [rbp+F0h]
  __int64 v96; // [rsp+200h] [rbp+F8h]
  __int64 v97; // [rsp+208h] [rbp+100h]
  __int64 v98; // [rsp+210h] [rbp+108h]
  __int64 v99; // [rsp+218h] [rbp+110h]
  __int64 v100; // [rsp+220h] [rbp+118h]

  v99 = a29;
  v97 = a28;
  v95 = a27;
  v93 = a26;
  v91 = a25;
  v89 = a24;
  v87 = a23;
  v85 = a22;
  v83 = a21;
  v81 = a20;
  v100 = 4i64;
  v98 = 1i64;
  v96 = 4i64;
  v94 = 4i64;
  v78 = *(_QWORD *)a19;
  v79 = 4 * *(unsigned __int16 *)(a19 + 8);
  v74 = a18;
  v72 = a17;
  v70 = a16;
  v68 = a15;
  v66 = a14;
  v64 = a13;
  v62 = a12;
  v76 = a19 + 8;
  v30 = -1i64;
  v92 = 4i64;
  v90 = 4i64;
  v31 = *a11;
  v88 = 4i64;
  v86 = 4i64;
  v84 = 4i64;
  v82 = 2i64;
  v77 = 2i64;
  v80 = 0;
  v75 = 4i64;
  v73 = 4i64;
  v71 = 2i64;
  v69 = 2i64;
  v67 = 8i64;
  v65 = 8i64;
  v63 = 1i64;
  if ( v31 )
  {
    v32 = -1i64;
    do
      ++v32;
    while ( v31[v32] );
    v33 = 2 * v32 + 2;
  }
  else
  {
    v31 = &Class;
    v33 = 2;
  }
  v57 = a10;
  v55 = a9;
  v59 = v31;
  v60 = v33;
  v61 = 0;
  v34 = *a8;
  v58 = 4i64;
  v56 = 4i64;
  if ( v34 )
  {
    do
      ++v30;
    while ( v34[v30] );
    v35 = 2 * v30 + 2;
  }
  else
  {
    v34 = &Class;
    v35 = 2;
  }
  v53 = v35;
  v50 = a7;
  v48 = a6;
  v46 = a5;
  *(_DWORD *)&EventDescriptor.Id = *a2 << 24;
  *(_DWORD *)&EventDescriptor.Level = *(unsigned __int16 *)(a2 + 1);
  v52 = v34;
  v54 = 0;
  EventDescriptor.Keyword = *(_QWORD *)(a2 + 3);
  UserData.Ptr = (ULONGLONG)off_180091488;
  v51 = 8i64;
  v49 = 8i64;
  v47 = 8i64;
  v44 = a4;
  v45 = 8i64;
  UserData.Size = *(unsigned __int16 *)off_180091488;
  v42 = *(unsigned __int16 *)(a2 + 11);
  v41 = a2 + 11;
  UserData.Reserved = 2;
  v43 = 1;
  v39 = (unsigned int)&TraceLoggingMetadataEnd - (unsigned int)&TraceLoggingMetadata;
  result = -1073741811;
  if ( (void (__fastcall *)(const struct _GUID *, unsigned int, __int64, __int64, unsigned __int64, struct _EVENT_FILTER_DESCRIPTOR *, _QWORD *))qword_1800914A8 == TlgAggregateInternalRegisteredProviderEtwCallback )
  {
    AggregateFieldTypes = ExtractAggregateFieldTypes(
                            (__int64)TlgAggregateInternalRegisteredProviderEtwCallback,
                            (__int64)&UserData);
    if ( AggregateFieldTypes )
      return InsertEventEntryInLookUpTable(
               (__int64)&dword_180091480,
               (__int128 *)&EventDescriptor,
               0x1Du,
               (__int64)&UserData,
               AggregateFieldTypes);
    else
      return EventWriteTransfer_0(RegHandle, &EventDescriptor, 0i64, 0i64, 0x1Du, &UserData);
  }
  return result;
}
// 180091488: using guessed type void *off_180091488;
// 1800914A8: using guessed type __int64 qword_1800914A8;

//----- (0000000180012AF0) ----------------------------------------------------
__int64 __fastcall InsertEventEntryInLookUpTable(
        __int64 a1,
        __int128 *a2,
        unsigned __int8 a3,
        __int64 a4,
        unsigned __int8 a5)
{
  __int64 v5; // rbx
  signed __int64 v7; // rdi
  unsigned int v9; // ebp
  int v10; // r14d
  volatile signed __int64 *i; // rsi
  unsigned int v12; // eax
  unsigned int v13; // eax
  __int64 v15; // rsi
  int v16; // eax
  unsigned __int8 v17; // dl
  unsigned int v18; // r10d
  signed __int64 v19; // r8
  __int64 v20; // rax
  int v21; // r11d
  volatile signed __int64 *v22; // r9
  volatile signed __int64 v23; // rtt
  __int64 v24; // [rsp+70h] [rbp+8h] BYREF
  __int128 *v25; // [rsp+78h] [rbp+10h]

  v25 = a2;
  v5 = *(_QWORD *)(a1 + 48);
  v7 = 0i64;
  v24 = 0i64;
  v9 = 0;
  v10 = ComputeEventEntryHash(a5, a3, a4);
  AcquireSRWLockShared((PSRWLOCK)(v5 + 264));
  for ( i = (volatile signed __int64 *)(v5 + 8i64 * (v10 & 0x1F));
        ;
        i = (volatile signed __int64 *)((((__int64)v16 >> 63) & 0xFFFFFFFFFFFFFFF8ui64) + v15 + 32) )
  {
    if ( !*i )
    {
      if ( *(_DWORD *)(v5 + 256) >= 0x400u )
      {
        ++*(_DWORD *)(v5 + 300);
        v9 = 234;
        goto LABEL_11;
      }
      if ( !v7 )
      {
        v12 = CreateNewEventEntry(v25, a3, a4, a5, v10, &v24);
        v7 = v24;
        v9 = v12;
        if ( !v24 )
        {
          if ( v12 == 8 )
            ++*(_DWORD *)(v5 + 304);
          else
            ++*(_DWORD *)(v5 + 308);
          goto LABEL_11;
        }
      }
      if ( !_InterlockedCompareExchange64(i, v7, 0i64) )
      {
        v24 = 0i64;
        if ( _InterlockedIncrement((volatile signed __int32 *)(v5 + 256)) == 1 )
          EnableFlushTimer(*(struct _TP_TIMER **)(v5 + 344), *(_DWORD *)(v5 + 352));
        v13 = *(_DWORD *)(v5 + 256);
        v7 = v24;
        if ( *(_DWORD *)(v5 + 288) < v13 )
          *(_DWORD *)(v5 + 288) = v13;
        goto LABEL_11;
      }
      v7 = v24;
    }
    v15 = *i;
    v16 = v10 == *(_DWORD *)(v15 + 40) ? CompareEventEntry(a3, a4, v15) : v10 - *(_DWORD *)(v15 + 40);
    if ( !v16 )
      break;
  }
  if ( v15 )
  {
    v17 = 2;
    v18 = a5 + 2;
    if ( v18 > 2 )
    {
      do
      {
        v19 = **(_QWORD **)(a4 + 16i64 * v17);
        v20 = *(_QWORD *)(v15 + 16);
        v21 = *(unsigned __int8 *)(v20 + 16i64 * v17 + 13);
        v22 = *(volatile signed __int64 **)(v20 + 16i64 * v17);
        if ( v21 == 113 )
        {
          _InterlockedExchangeAdd64(v22, v19);
        }
        else if ( (unsigned int)(v21 - 114) <= 1 )
        {
          do
          {
            if ( (_BYTE)v21 == 114 )
            {
              if ( v19 >= *v22 )
                break;
            }
            else if ( v19 <= *v22 )
            {
              break;
            }
            v23 = *v22;
          }
          while ( v23 != _InterlockedCompareExchange64(v22, v19, *v22) );
        }
        ++v17;
      }
      while ( v17 < v18 );
      v7 = v24;
    }
  }
LABEL_11:
  ReleaseSRWLockShared((PSRWLOCK)(v5 + 264));
  if ( v7 )
    DestroyEventEntry(v7);
  return v9;
}

//----- (0000000180012D04) ----------------------------------------------------
__int64 __fastcall ComputeEventEntryHash(char a1, unsigned __int8 a2, __int64 a3)
{
  unsigned __int8 v6; // bl
  __int64 v7; // r11
  __int64 v8; // rbx
  __int64 v9; // r11
  int v11; // [rsp+30h] [rbp+8h] BYREF

  v11 = 0;
  RunningHash(&v11, a3 + 16, 8ui64);
  v6 = a1 + 2;
  if ( v6 < a2 )
  {
    v7 = a3 + 16i64 * v6;
    v8 = (unsigned __int8)(a2 - v6);
    do
    {
      RunningHash(&v11, *(_QWORD *)v7, *(unsigned int *)(v7 + 8));
      v7 = v9 + 16;
      --v8;
    }
    while ( v8 );
  }
  return 32769 * ((9 * v11) ^ ((unsigned int)(9 * v11) >> 11));
}
// 180012D5E: variable 'v9' is possibly undefined

//----- (0000000180012D94) ----------------------------------------------------
__int64 __fastcall RunningHash(_DWORD *a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 i; // r10
  int v4; // eax
  __int64 result; // rax

  for ( i = 0i64; i < a3; *a1 = result )
  {
    v4 = *(unsigned __int8 *)(i + a2);
    ++i;
    result = (1025 * (*a1 + v4)) ^ ((unsigned int)(1025 * (*a1 + v4)) >> 6);
  }
  return result;
}

//----- (0000000180012DC8) ----------------------------------------------------
unsigned __int8 __fastcall ExtractAggregateFieldTypes(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  unsigned __int8 v3; // r8
  unsigned __int64 v5; // r10
  char *v6; // rcx
  char v7; // al
  __int64 v9; // rax
  char v11; // al
  char v12; // r9
  char v13; // dl

  v2 = *(_QWORD *)(a2 + 16);
  v3 = 0;
  v5 = v2 + *(unsigned int *)(a2 + 24);
  v6 = (char *)(v2 + 2);
  do
    v7 = *v6++;
  while ( v7 < 0 );
  while ( *v6++ )
    ;
  while ( (unsigned __int64)v6 < v5 )
  {
    while ( *v6++ )
      ;
    if ( *v6 >= 0 )
      break;
    v11 = v6[1];
    v12 = *v6 & 0x7F;
    v6 += 2;
    if ( v11 >= 0 )
      break;
    while ( 1 )
    {
      v13 = *v6;
      if ( *v6 >= 0 )
        break;
      if ( v13 != (char)0x80 )
        return v3;
      ++v6;
    }
    if ( v12 != 9 || (unsigned __int8)(v13 - 113) > 2u )
      break;
    v9 = 2i64 * v3++;
    *(_BYTE *)(a2 + 8 * v9 + 45) = v13;
  }
  return v3;
}

//----- (0000000180012E50) ----------------------------------------------------
__int64 __fastcall RemotelyGetUserKeys(struct CSslContext *a1, unsigned int a2)
{
  int v2; // edi
  unsigned int v3; // esi
  unsigned __int8 **v5; // rax
  int v6; // eax
  unsigned int v7; // ebx
  void *v9; // rax
  struct _SecBuffer Size; // [rsp+40h] [rbp-40h] BYREF
  unsigned __int8 *v11[2]; // [rsp+50h] [rbp-30h] BYREF
  char v12[32]; // [rsp+60h] [rbp-20h] BYREF

  v2 = *((unsigned __int8 *)a1 + 266);
  v3 = a2 | 8;
  *(_OWORD *)v11 = 0i64;
  if ( !(_BYTE)v2 )
    v3 = a2;
  if ( !LsaTable )
    return 87i64;
  if ( !(*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v12) )
    return 1359i64;
  Size.BufferType = 1;
  if ( (v12[8] & 0x40) != 0 )
  {
    Size.cbBuffer = 8;
    if ( (_BYTE)v2 )
    {
      v9 = (void *)(*(__int64 (__fastcall **)(__int64))(LsaTable + 384))(8i64);
      Size.pvBuffer = v9;
      if ( !v9 )
        return 14i64;
      memcpy_0(v9, (char *)a1 + 128, Size.cbBuffer);
    }
    else
    {
      Size.pvBuffer = (char *)a1 + 128;
    }
  }
  else
  {
    Size.cbBuffer = 0;
    Size.pvBuffer = 0i64;
  }
  v5 = v11;
  if ( (_BYTE)v2 )
    v5 = 0i64;
  v6 = PerformApplicationCallback(7i64, *((_QWORD *)a1 + 16), v3, &Size, (struct _SecBuffer *)v5, (_BYTE)v2 == 0, v2, 1);
  if ( v6 < 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        28i64,
        &WPP_66cada2652f531372f2ad4492a08a619_Traceguids,
        (unsigned int)v6);
    v7 = -2146893052;
    if ( (_BYTE)v2 && Size.pvBuffer )
      (*(void (**)(void))(LsaTable + 392))();
  }
  else if ( (_BYTE)v2 )
  {
    v7 = 590610;
  }
  else
  {
    v7 = ParseKeyBuffer(a1, v3, v11[1], (unsigned int)v11[0]);
  }
  if ( v11[1] )
    SPExternalFree(v11[1]);
  return v7;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180012FC4) ----------------------------------------------------
__int64 __fastcall PerformApplicationCallback(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        struct _SecBuffer *a4,
        struct _SecBuffer *a5,
        int a6,
        int a7,
        char a8)
{
  __int64 v8; // rax
  unsigned int v9; // ebx
  void *pvBuffer; // rcx

  v8 = LsaTable;
  if ( LsaTable )
  {
    if ( a7 )
    {
      v9 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, struct _SecBuffer *, char))(LsaTable + 496))(
             a1,
             a2,
             a3,
             a4,
             a8);
      if ( (v9 & 0x80000000) != 0 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v9);
        CleanupAppModeInfo(0i64);
      }
      return v9;
    }
    if ( a5 )
    {
      a5->BufferType = 0;
      a5->pvBuffer = 0i64;
      a5->cbBuffer = 0;
      v9 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, struct _SecBuffer *, struct _SecBuffer *))(v8 + 280))(
             (unsigned int)a1,
             a2,
             a3,
             a4,
             a5);
      if ( (v9 & 0x80000000) != 0 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v9);
        return v9;
      }
      pvBuffer = a5->pvBuffer;
      if ( pvBuffer && a5->cbBuffer )
      {
        if ( !a6 )
          v9 = -2146893052;
        if ( (v9 & 0x80000000) == 0 )
          return v9;
      }
      else
      {
        if ( !a6 )
          return v9;
        v9 = -2146893052;
      }
      if ( pvBuffer )
        SPExternalFree(pvBuffer);
      a5->BufferType = 0;
      a5->pvBuffer = 0i64;
      a5->cbBuffer = 0;
      return v9;
    }
  }
  return 2148074244i64;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180013030) ----------------------------------------------------
void __fastcall CCredentialGroup::~CCredentialGroup(CCredentialGroup *this)
{
  *(_QWORD *)this = &CCredentialGroup::`vftable';
  CCredentialGroup::DeleteCredentialGroup(this);
  *(_QWORD *)this = &IAllocate::`vftable';
}
// 18007C298: using guessed type void *IAllocate::`vftable';
// 18007D0D8: using guessed type void *CCredentialGroup::`vftable';

//----- (0000000180013060) ----------------------------------------------------
void __fastcall CCredentialGroup::DeleteCredentialGroup(CCredentialGroup *this)
{
  struct _RTL_RESOURCE *v2; // rbp
  void *v3; // rcx
  struct _TLS_PARAMETERS *v4; // rcx
  void *v5; // rcx
  _QWORD *v6; // rdi
  CCredentialGroup *v7; // rcx
  void *v8; // rcx
  void *v9; // rcx
  void *v10; // rcx
  void *v11; // rcx
  CCredentialGroup *v12; // rcx
  CCredentialGroup *v13; // rcx
  void *v14; // rcx
  void *v15; // rcx
  _QWORD *v16; // rsi
  _QWORD *v17; // rdi
  _QWORD *v18; // rcx
  const CTL_CONTEXT *v19; // rcx
  CCredentialGroup *v20; // rcx
  int v21; // [rsp+40h] [rbp+8h] BYREF

  v21 = 0;
  if ( *((_DWORD *)this + 36) )
  {
    v2 = (struct _RTL_RESOURCE *)((char *)this + 48);
    RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)this + 48), 1u);
    if ( *((_DWORD *)this + 7) )
    {
      v16 = (_QWORD *)((char *)this + 32);
      v17 = (_QWORD *)*((_QWORD *)this + 4);
      while ( v17 != v16 )
      {
        v18 = v17 - 1;
        v17 = (_QWORD *)*v17;
        if ( v18 )
          (*(void (__fastcall **)(_QWORD *, __int64))(*v18 + 8i64))(v18, 1i64);
      }
      *((_DWORD *)this + 7) = 0;
      *v16 = 0i64;
      *((_QWORD *)this + 5) = 0i64;
    }
    v3 = (void *)*((_QWORD *)this + 23);
    if ( v3 )
      SPExternalFree(v3);
    v4 = (struct _TLS_PARAMETERS *)*((_QWORD *)this + 25);
    if ( v4 )
    {
      FreeTlsParameters(v4, *((_DWORD *)this + 49));
      *((_QWORD *)this + 25) = 0i64;
      *((_DWORD *)this + 49) = 0;
    }
    v5 = (void *)*((_QWORD *)this + 108);
    if ( v5 )
      LocalFree(v5);
    v6 = (_QWORD *)*((_QWORD *)this + 106);
    if ( v6 )
    {
      v19 = (const CTL_CONTEXT *)v6[5];
      if ( v19 )
        CertFreeCTLContext(v19);
      SPExternalFree(v6);
    }
    v7 = (CCredentialGroup *)*((_QWORD *)this + 96);
    if ( v7 )
    {
      if ( *((_QWORD *)this + 97) )
      {
        CCredentialGroup::UnsubscribeCertStoreChangeNotification(v7, *((void **)this + 96), (void **)this + 97);
        v7 = (CCredentialGroup *)*((_QWORD *)this + 96);
      }
      CertCloseStore(v7, 0);
    }
    v8 = (void *)*((_QWORD *)this + 109);
    if ( v8 )
      SPExternalFree(v8);
    v9 = (void *)*((_QWORD *)this + 110);
    if ( v9 )
      SPExternalFree(v9);
    if ( *((_QWORD *)this + 98) )
    {
      if ( !SslImpersonateClient(*((_QWORD *)this + 94), &v21) && *((_QWORD *)this + 99) )
        CCredentialGroup::UnsubscribeCertStoreChangeNotification(v20, *((void **)this + 98), (void **)this + 99);
      CertCloseStore(*((HCERTSTORE *)this + 98), 0);
      if ( v21 )
        RevertToSelf();
    }
    v10 = (void *)*((_QWORD *)this + 100);
    if ( v10 )
      CryptObjectLocatorFree(v10);
    v11 = (void *)*((_QWORD *)this + 101);
    if ( v11 )
      CryptObjectLocatorFree(v11);
    v12 = (CCredentialGroup *)*((_QWORD *)this + 102);
    if ( v12 )
    {
      if ( *((_QWORD *)this + 103) )
      {
        CCredentialGroup::UnsubscribeCertStoreChangeNotification(v12, *((void **)this + 102), (void **)this + 103);
        v12 = (CCredentialGroup *)*((_QWORD *)this + 102);
      }
      CertCloseStore(v12, 0);
    }
    v13 = (CCredentialGroup *)*((_QWORD *)this + 104);
    if ( v13 )
    {
      if ( *((_QWORD *)this + 105) )
      {
        CCredentialGroup::UnsubscribeCertStoreChangeNotification(v13, *((void **)this + 104), (void **)this + 105);
        v13 = (CCredentialGroup *)*((_QWORD *)this + 104);
      }
      CertCloseStore(v13, 0);
    }
    v14 = (void *)*((_QWORD *)this + 94);
    if ( v14 )
    {
      NtClose(v14);
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_q(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x18u,
          (__int64)&WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids,
          *((_QWORD *)this + 94));
      *((_QWORD *)this + 94) = 0i64;
    }
    v15 = (void *)*((_QWORD *)this + 111);
    if ( v15 )
      LocalFree(v15);
    RtlReleaseResource(v2);
    RtlDeleteResource(v2);
  }
}
// 18003C915: variable 'v20' is possibly undefined
// 180082B38: using guessed type GUID WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids;
// 180098018: using guessed type void __stdcall CryptObjectLocatorFree(void *);

//----- (0000000180013210) ----------------------------------------------------
CCredentialGroup *__fastcall CCredentialGroup::`vector deleting destructor'(CCredentialGroup *this, char a2)
{
  CCredentialGroup::~CCredentialGroup(this);
  if ( (a2 & 1) != 0 )
    SPExternalFree(this);
  return this;
}

//----- (0000000180013248) ----------------------------------------------------
signed int __fastcall SslTransferCertChainToClientProcess(PCCERT_CONTEXT *a1, const struct _CERT_CONTEXT *a2)
{
  signed int result; // eax
  unsigned __int8 *v5; // rax
  int v6; // ebx
  __int64 v7; // rax
  NTSTATUS v8; // ebx
  PCCERT_CONTEXT v9; // rax
  unsigned int v10[2]; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int8 *v11; // [rsp+38h] [rbp-30h]
  char v12[40]; // [rsp+40h] [rbp-28h] BYREF

  if ( !a2 )
    return -2146893042;
  if ( !a1 )
    return 87;
  if ( !LsaTable || !(*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v12) )
    return 1359;
  if ( (v12[8] & 0x10) != 0 )
  {
    v9 = CertDuplicateCertificateContext(a2);
    if ( v9 )
    {
      *a1 = v9;
      return 0;
    }
    return 1359;
  }
  result = SerializeCertContext(a2, 0i64, v10);
  if ( result < 0 )
    return result;
  v5 = (unsigned __int8 *)(*(__int64 (__fastcall **)(_QWORD))(LsaTable + 384))(v10[0]);
  v11 = v5;
  if ( !v5 )
    return 14;
  v6 = SerializeCertContext(a2, v5, v10);
  if ( v6 < 0 )
  {
    (*(void (__fastcall **)(unsigned __int8 *))(LsaTable + 392))(v11);
    return v6;
  }
  v7 = LsaTable;
  v10[1] = 1;
  if ( !LsaTable )
  {
    v8 = -2146893052;
LABEL_24:
    (*(void (__fastcall **)(unsigned __int8 *))(v7 + 392))(v11);
    return RtlNtStatusToDosError(v8);
  }
  v8 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, unsigned int *, _BYTE))(LsaTable + 496))(
         6i64,
         0i64,
         0i64,
         v10,
         0);
  if ( v8 < 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        10i64,
        &WPP_66cada2652f531372f2ad4492a08a619_Traceguids,
        (unsigned int)v8);
    CleanupAppModeInfo(0i64);
    v7 = LsaTable;
    goto LABEL_24;
  }
  return 0;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018001336C) ----------------------------------------------------
__int64 __fastcall SerializeCertContext(PCCERT_CONTEXT pCertContext, unsigned __int8 *a2, unsigned int *a3)
{
  HCERTSTORE hCertStore; // rcx
  int v7; // esi
  DWORD v8; // ecx
  unsigned int v9; // eax
  HCERTSTORE v11; // rcx
  int pvSaveToPara; // [rsp+30h] [rbp-10h] BYREF
  unsigned __int8 *v13; // [rsp+38h] [rbp-8h]
  DWORD pcbElement; // [rsp+60h] [rbp+20h] BYREF

  pcbElement = 0;
  if ( !pCertContext )
  {
    *a3 = 0;
    return 0i64;
  }
  if ( !CertSerializeCertificateStoreElement(pCertContext, 0, 0i64, &pcbElement) )
    return 2148074253i64;
  hCertStore = pCertContext->hCertStore;
  if ( hCertStore )
  {
    pvSaveToPara = 0;
    v13 = 0i64;
    if ( !CertSaveStore(hCertStore, 1u, 1u, 2u, &pvSaveToPara, 0) )
      return 2148074253i64;
    v7 = pvSaveToPara;
  }
  else
  {
    v7 = 0;
  }
  v8 = pcbElement;
  v9 = v7 + pcbElement + 8;
  if ( !a2 )
  {
    *a3 = v9;
    return 0i64;
  }
  if ( *a3 >= v9 )
  {
    *a3 = v9;
    *(_DWORD *)a2 = v7;
    if ( !pCertContext->hCertStore )
      goto LABEL_13;
    v11 = pCertContext->hCertStore;
    v13 = a2 + 4;
    pvSaveToPara = v7;
    if ( CertSaveStore(v11, 1u, 1u, 2u, &pvSaveToPara, 0) )
    {
      v8 = pcbElement;
LABEL_13:
      *(_DWORD *)&a2[v7 + 4] = v8;
      if ( CertSerializeCertificateStoreElement(pCertContext, 0, &a2[v7 + 8], &pcbElement) )
        return 0i64;
    }
    return 2148074253i64;
  }
  return 2148074273i64;
}

//----- (00000001800134AC) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::QueryRemoteCertificateChain(CSsl3TlsContext *this, PCCERT_CONTEXT *a2)
{
  __int64 v3; // rcx
  __int64 v5; // rcx
  unsigned __int8 *v6; // rbx
  DWORD v7; // edi
  DWORD v8; // edi
  unsigned int v9; // eax
  CCipherMill *v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // r9
  DWORD LastError; // eax
  DWORD v15; // eax
  __int64 v16; // [rsp+20h] [rbp-20h] BYREF
  __int64 v17; // [rsp+28h] [rbp-18h] BYREF
  int pvData; // [rsp+30h] [rbp-10h] BYREF
  __int64 v19; // [rsp+38h] [rbp-8h]
  int v20; // [rsp+70h] [rbp+30h] BYREF
  int v21; // [rsp+80h] [rbp+40h] BYREF
  PCCERT_CONTEXT pCertContext; // [rsp+88h] [rbp+48h] BYREF

  v16 = 0i64;
  v3 = *((_QWORD *)this + 11);
  v17 = 0i64;
  v20 = 0;
  v21 = 0;
  pCertContext = 0i64;
  RtlAcquireResourceShared((PRTL_RESOURCE)(v3 + 72), 1u);
  v5 = *((_QWORD *)this + 11);
  v6 = *(unsigned __int8 **)(v5 + 24);
  v7 = *(_DWORD *)(v5 + 32);
  if ( v6 )
  {
    (*(void (__fastcall **)(CSsl3TlsContext *, __int64 *, int *))(*(_QWORD *)this + 272i64))(this, &v16, &v20);
    v8 = SPLoadCertificate(v6, v7, &pCertContext);
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
    if ( v8 )
    {
      v11 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      {
LABEL_9:
        if ( pCertContext )
          CertFreeCertificateContext(pCertContext);
        return v8;
      }
      v12 = 14i64;
      v13 = v8;
    }
    else
    {
      RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
      if ( v16 )
      {
        v19 = v16;
        pvData = v20;
        if ( !CertSetCertificateContextProperty(pCertContext, 0x46u, 0, &pvData)
          && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        {
          LastError = GetLastError();
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            15i64,
            &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids,
            LastError);
        }
      }
      (*(void (__fastcall **)(CSsl3TlsContext *, __int64 *, int *))(*(_QWORD *)this + 280i64))(this, &v17, &v21);
      if ( v17 )
      {
        if ( v21 )
        {
          v19 = v17;
          pvData = v21;
          if ( !CertSetCertificateContextProperty(pCertContext, 0x77u, 0, &pvData)
            && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
          {
            v15 = GetLastError();
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 16i64, &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids, v15);
          }
        }
      }
      RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
      v9 = SslTransferCertChainToClientProcess(a2, pCertContext);
      v8 = v9;
      if ( !v9 )
        goto LABEL_9;
      v11 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        goto LABEL_9;
      v12 = 17i64;
      v13 = v9;
    }
    WPP_SF_D(*((_QWORD *)v11 + 2), v12, &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids, v13);
    goto LABEL_9;
  }
  RtlReleaseResource((PRTL_RESOURCE)(v5 + 72));
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids);
  return (DWORD)-2146893042;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180013660) ----------------------------------------------------
signed int __fastcall CSsl3TlsContext::QueryContextAttributesA(CSsl3TlsContext *this, int a2, void *a3)
{
  switch ( a2 )
  {
    case '"':
      return CSsl3TlsContext::QuerySupportedMTU(this, a3);
    case 'Y':
      return CSsl3TlsContext::QueryIssuerList(this, a3);
    case '[':
      return CSsl3TlsContext::QueryEapKeyBlock(this, a3);
    case 'f':
      return CSsl3TlsContext::QuerySupportedSignatures(this, a3);
    case 'g':
      return CSsl3TlsContext::QueryRemoteCertificateChain(this, (PCCERT_CONTEXT *)a3);
    case 'k':
      return (*(__int64 (__fastcall **)(CSsl3TlsContext *, void *))(*(_QWORD *)this + 480i64))(this, a3);
    case 'q':
      return CSsl3TlsContext::QueryCertificateValidationResult(this, a3);
  }
  return CSslContext::QueryContextAttributesA(this, a2, a3);
}

//----- (00000001800136A0) ----------------------------------------------------
__int64 __fastcall CreateNewEventEntry(
        __int128 *a1,
        unsigned __int8 a2,
        __int64 a3,
        unsigned __int8 a4,
        int a5,
        __int64 *a6)
{
  unsigned __int8 v6; // di
  __int64 v7; // rbp
  __int64 v9; // r8
  int v10; // r14d
  __int64 v11; // rdx
  unsigned __int8 v12; // r9
  unsigned int *v13; // r10
  __int64 v14; // rcx
  __int64 v15; // rax
  SIZE_T v16; // rsi
  HANDLE ProcessHeap; // rax
  __int64 NextOffset; // r12
  unsigned int v19; // edx
  void *v20; // rbx
  __int64 v21; // rdx
  __int64 v22; // rdi
  __int128 v23; // xmm0
  unsigned __int8 v24; // r14
  const void **v25; // rsi
  __int64 v26; // r12
  __int64 v27; // rbp
  unsigned int v28; // edx
  void *v29; // rbx
  char *v30; // rdx
  int v31; // eax
  __int64 v33[7]; // [rsp+20h] [rbp-38h] BYREF

  v6 = 0;
  v7 = a2;
  v33[0] = 0i64;
  v9 = 0i64;
  v10 = a4;
  v11 = 0i64;
  v12 = 0;
  *a6 = 0i64;
  if ( (_BYTE)v7 )
  {
    v13 = (unsigned int *)(a3 + 8);
    do
    {
      v14 = *v13;
      v13 += 4;
      if ( v12 >= 2u )
        v11 += v14;
      v15 = v14 + v9;
      if ( v12 >= 2u )
        v15 = v9;
      ++v12;
      v9 = v15;
    }
    while ( v12 < (unsigned __int8)v7 );
    if ( (unsigned __int64)(v11 + v15) > 0xFFFF )
      return 534i64;
  }
  v16 = v11 + 16 * v7 + 46;
  if ( !v16 )
    return 8i64;
  ProcessHeap = GetProcessHeap();
  v33[0] = (__int64)HeapAlloc(ProcessHeap, 8u, v16);
  if ( !v33[0] )
    return 8i64;
  v33[1] = v16;
  NextOffset = CBufferGetNextOffset(v33, 16 * v7);
  do
  {
    if ( v6 < 2u )
    {
      *(_OWORD *)(NextOffset + 16i64 * v6) = *(_OWORD *)(a3 + 16i64 * v6);
    }
    else
    {
      v20 = (void *)CBufferGetNextOffset(v33, *(unsigned int *)(a3 + 16i64 * v6 + 8));
      memcpy_0(v20, *(const void **)(a3 + 16i64 * v6), v19);
      *(_QWORD *)(NextOffset + 16i64 * v6) = v20;
      *(_DWORD *)(NextOffset + 16i64 * v6 + 12) = *(_DWORD *)(a3 + 16i64 * v6 + 12);
      *(_DWORD *)(NextOffset + 16i64 * v6 + 8) = *(_DWORD *)(a3 + 16i64 * v6 + 8);
    }
    ++v6;
  }
  while ( v6 < (unsigned int)(v10 + 2) );
  v22 = CBufferGetNextOffset(v33, 0x2Eui64);
  *(_QWORD *)(v22 + 16) = NextOffset;
  v23 = *a1;
  *(_BYTE *)(v22 + 45) = v10;
  v24 = v10 + 2;
  *(_BYTE *)(v22 + 44) = v7;
  *(_DWORD *)(v22 + 40) = a5;
  *(_OWORD *)v22 = v23;
  if ( v24 < (unsigned __int8)v7 )
  {
    v25 = (const void **)(16i64 * v24 + a3 + 8);
    v26 = v21 - 54 - a3;
    v27 = (unsigned __int8)(v7 - v24);
    do
    {
      v29 = (void *)CBufferGetNextOffset(v33, *(unsigned int *)v25);
      memcpy_0(v29, *(v25 - 1), v28);
      v30 = (char *)v25 + v26;
      *(_QWORD *)&v30[*(_QWORD *)(v22 + 16)] = v29;
      *(_DWORD *)&v30[*(_QWORD *)(v22 + 16) + 12] = *((_DWORD *)v25 + 1);
      v31 = *(_DWORD *)v25;
      v25 += 2;
      *(_DWORD *)&v30[*(_QWORD *)(v22 + 16) + 8] = v31;
      --v27;
    }
    while ( v27 );
  }
  *a6 = v22;
  return 0i64;
}
// 180013786: conditional instruction was optimized away because r14d.4<100u
// 1800137A8: variable 'v19' is possibly undefined
// 180013827: variable 'v21' is possibly undefined
// 180013844: variable 'v28' is possibly undefined

//----- (00000001800138C8) ----------------------------------------------------
__int64 __fastcall CBufferGetNextOffset(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  __int64 result; // rax

  if ( !a1 )
    return 0i64;
  if ( !a2 )
    return 0i64;
  v2 = a1[1];
  if ( v2 < a2 )
    return 0i64;
  result = *a1;
  a1[1] = v2 - a2;
  *a1 = result + a2;
  return result;
}

//----- (00000001800138FC) ----------------------------------------------------
int __fastcall CompareEventEntry(unsigned __int8 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  unsigned int v6; // edi
  int result; // eax
  unsigned int i; // ebx
  __int64 v9; // rcx

  v3 = *(_QWORD *)(a3 + 16);
  v6 = a1;
  result = memcmp_0((const void *)(a2 + 16), (const void *)(v3 + 16), 8ui64);
  if ( !result )
  {
    for ( i = *(unsigned __int8 *)(a3 + 45) + 2; i < v6; ++i )
    {
      v9 = 16i64 * i;
      result = *(_DWORD *)(v9 + a2 + 8) - *(_DWORD *)(v9 + v3 + 8);
      if ( result )
        return result;
      result = memcmp_0(*(const void **)(v9 + a2), *(const void **)(v9 + v3), *(unsigned int *)(v9 + a2 + 8));
      if ( result )
        return result;
    }
    return 0;
  }
  return result;
}

//----- (0000000180013988) ----------------------------------------------------
__int64 StringCchPrintfW(unsigned __int16 *a1, __int64 a2, const unsigned __int16 *a3, ...)
{
  unsigned __int64 v4; // rsi
  unsigned int v5; // edi
  int v6; // eax
  va_list Args; // [rsp+68h] [rbp+20h] BYREF

  va_start(Args, a3);
  if ( (unsigned __int64)(a2 - 1) <= 0x7FFFFFFE )
  {
    v4 = a2 - 1;
    v5 = 0;
    v6 = vsnwprintf(a1, a2 - 1, a3, Args);
    if ( v6 < 0 || v6 > v4 )
    {
      v5 = -2147024774;
    }
    else if ( v6 != v4 )
    {
      return v5;
    }
    a1[v4] = 0;
    return v5;
  }
  v5 = -2147024809;
  if ( a2 )
    *a1 = 0;
  return v5;
}

//----- (00000001800139F0) ----------------------------------------------------
__int64 __fastcall SpWow64MapVersion3Certificate(void *a1, int a2, struct _SecBuffer *a3, struct LSA_SCHANNEL_CRED *a4)
{
  void *v4; // rsi
  void *v5; // r13
  unsigned int *pvBuffer; // r15
  __int64 v11; // rdx
  int v12; // ebx
  unsigned int v13; // ebx
  int v14; // r13d
  unsigned int v15; // esi
  int v16; // r14d
  int v17; // eax
  HLOCAL v19; // rax
  void *v20; // r10
  unsigned int v21; // ebx
  __int64 v22; // r12
  __int64 v23; // rcx
  const BYTE *v24; // rdx
  __int64 ppvContext; // r9
  DWORD v26; // r8d
  __int64 v27; // rcx
  HCERTSTORE v28; // rax
  int v29; // eax
  unsigned int v30; // ebx
  HLOCAL v31; // rax
  unsigned int v32; // eax
  HCERTSTORE v33; // [rsp+40h] [rbp-49h]
  HLOCAL v34; // [rsp+48h] [rbp-41h]
  unsigned int pvPara; // [rsp+58h] [rbp-31h] BYREF
  unsigned int *v37; // [rsp+60h] [rbp-29h]
  __int128 v38; // [rsp+68h] [rbp-21h] BYREF
  __int128 v39; // [rsp+78h] [rbp-11h]
  unsigned int v40[4]; // [rsp+88h] [rbp-1h]
  __int64 v41; // [rsp+98h] [rbp+Fh]

  v4 = 0i64;
  v5 = 0i64;
  v34 = 0i64;
  v33 = 0i64;
  pvBuffer = 0i64;
  v38 = 0i64;
  v41 = 0i64;
  v39 = 0i64;
  *(_OWORD *)v40 = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
  if ( a2 == 3 )
  {
    v12 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int128 *, void *))(LsaTable + 80))(0i64, 48i64, &v38, a1);
    if ( v12 < 0 )
      goto LABEL_24;
    v41 = 0i64;
  }
  else
  {
    v11 = 56i64;
    if ( a2 != 4 )
      v11 = 44i64;
    v12 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int128 *, void *))(LsaTable + 80))(0i64, v11, &v38, a1);
    if ( v12 < 0 )
      goto LABEL_24;
  }
  memset_0((char *)a4 + 4, 0, 0x6Cui64);
  *(_DWORD *)a4 = a2;
  if ( a2 == 4 )
  {
    v13 = DWORD2(v38);
    v14 = HIDWORD(v38);
    v15 = DWORD1(v38);
  }
  else
  {
    v13 = HIDWORD(v38);
    v14 = v39;
    v15 = DWORD2(v38);
  }
  if ( v15 > 0x64 )
  {
    v12 = -2146893056;
  }
  else
  {
    if ( a3->pvBuffer )
    {
      pvBuffer = (unsigned int *)a3->pvBuffer;
      goto LABEL_14;
    }
    if ( (!v15 || !v13) && !v14 )
    {
LABEL_14:
      if ( v15 && v13 )
      {
        v34 = SPExternalAlloc(4 * v15);
        if ( !v34 )
        {
          v12 = -2146893056;
          v4 = 0i64;
          goto LABEL_23;
        }
        v12 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, HLOCAL, _QWORD))(LsaTable + 80))(0i64, 4 * v15, v34, v13);
        if ( v12 >= 0 )
        {
          *((_DWORD *)a4 + 1) = v15;
          v19 = SPExternalAlloc(56 * v15);
          *((_QWORD *)a4 + 1) = v19;
          if ( !v19 )
          {
LABEL_51:
            v12 = -2146893056;
            goto LABEL_22;
          }
          v33 = CertOpenStore((LPCSTR)2, 0, 0i64, 4u, 0i64);
          v20 = v33;
          if ( !v33 )
          {
            GetLastError();
            goto LABEL_51;
          }
          v21 = 0;
          v22 = 0i64;
          while ( 1 )
          {
            v23 = *pvBuffer;
            v24 = (const BYTE *)(pvBuffer + 1);
            pvBuffer = (unsigned int *)((char *)pvBuffer + v23 + 4);
            if ( !v24 )
              break;
            if ( (unsigned int)v23 < 0xC )
              break;
            ppvContext = v22 + *((_QWORD *)a4 + 1);
            *(_QWORD *)(ppvContext + 16) = *(unsigned int *)v24;
            v26 = *((_DWORD *)v24 + 1);
            if ( (int)v23 - 8 < v26 )
              break;
            if ( !CertAddSerializedElementToStore(v20, v24 + 8, v26, 4u, 0, 2u, 0i64, (const void **)ppvContext) )
            {
              GetLastError();
              goto LABEL_60;
            }
            v20 = v33;
            ++v21;
            v22 += 56i64;
            if ( v21 >= v15 )
              goto LABEL_15;
          }
LABEL_61:
          v12 = -2146893052;
        }
LABEL_22:
        v4 = v34;
LABEL_23:
        v5 = v33;
        goto LABEL_24;
      }
LABEL_15:
      if ( v14 )
      {
        v27 = *pvBuffer;
        if ( pvBuffer == (unsigned int *)-4i64 )
          goto LABEL_61;
        if ( (unsigned int)v27 < 4 )
          goto LABEL_61;
        pvPara = pvBuffer[1];
        v37 = pvBuffer + 2;
        if ( v27 - 4 < (unsigned __int64)pvPara )
          goto LABEL_61;
        v28 = CertOpenStore((LPCSTR)6, 1u, 0i64, 0, &pvPara);
        *((_QWORD *)a4 + 2) = v28;
        if ( !v28 )
        {
LABEL_60:
          v12 = -2146893043;
          goto LABEL_22;
        }
      }
      v16 = a2 - 4;
      if ( v16 )
      {
        if ( v16 != 1 )
        {
LABEL_21:
          v12 = 0;
          goto LABEL_22;
        }
        v12 = CopyTlsParameters(0i64, v40[1], v40[2], 1, (struct _TLS_PARAMETERS **)a4 + 13, (unsigned int *)a4 + 24);
        if ( v12 )
          goto LABEL_22;
        *((_DWORD *)a4 + 21) = HIDWORD(v39);
        *((_DWORD *)a4 + 22) = v40[0];
        v17 = DWORD1(v38);
      }
      else
      {
        v29 = DWORD2(v39);
        if ( DWORD2(v39) && HIDWORD(v39) )
        {
          if ( DWORD2(v39) > 0x100 )
            goto LABEL_51;
          v30 = 4 * DWORD2(v39);
          *((_DWORD *)a4 + 14) = DWORD2(v39);
          v31 = SPExternalAlloc(4 * v29);
          *((_QWORD *)a4 + 8) = v31;
          if ( !v31 )
            goto LABEL_51;
          v12 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, HLOCAL, _QWORD))(LsaTable + 80))(
                  0i64,
                  v30,
                  v31,
                  HIDWORD(v39));
          if ( v12 < 0 )
            goto LABEL_22;
        }
        v32 = v40[0];
        if ( v40[0] == -1 )
          v32 = 0;
        else
          *((_DWORD *)a4 + 18) = v40[0];
        *((_DWORD *)a4 + 18) = v32 & 0x3FFFFFFF;
        *((_DWORD *)a4 + 19) = v40[1];
        *((_DWORD *)a4 + 20) = v40[2];
        *((_DWORD *)a4 + 21) = v40[3];
        *((_DWORD *)a4 + 22) = v41;
        v17 = HIDWORD(v41);
      }
      *((_DWORD *)a4 + 23) = v17;
      goto LABEL_21;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 23i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
    v12 = 590610;
  }
  v4 = 0i64;
  v5 = 0i64;
LABEL_24:
  if ( a3 )
  {
    a3->pvBuffer = 0i64;
    *(_QWORD *)&a3->cbBuffer = 0i64;
    CleanupAppModeInfo(0i64);
  }
  if ( v4 )
    SPExternalFree(v4);
  if ( v5 )
    CertCloseStore(v5, 0);
  if ( v12 < 0 )
    FreeSchannelCred(a4, 1);
  return (unsigned int)v12;
}
// 18003CE25: conditional instruction was optimized away because esi.4 is in (1..64)
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180013BC8) ----------------------------------------------------
__int64 __fastcall CertGetEccCurveType(__int64 a1, unsigned int *a2)
{
  __int64 v2; // r8
  CCipherMill *v4; // rcx
  unsigned int EccCurveType; // eax
  unsigned int v6; // ebx
  DWORD v8; // [rsp+50h] [rbp+8h] BYREF
  HLOCAL hMem; // [rsp+58h] [rbp+10h] BYREF

  *a2 = 0;
  v2 = *(_QWORD *)(a1 + 24);
  hMem = 0i64;
  v8 = 8;
  if ( CryptDecodeObjectEx(
         1u,
         (LPCSTR)0x49,
         *(const BYTE **)(v2 + 112),
         *(_DWORD *)(v2 + 104),
         0x8000u,
         0i64,
         &hMem,
         &v8) )
  {
    EccCurveType = CCipherMill::GetEccCurveType(v4, *(char **)hMem, a2);
  }
  else
  {
    EccCurveType = GetLastError();
  }
  v6 = EccCurveType;
  if ( hMem )
    LocalFree(hMem);
  return v6;
}
// 180013C33: variable 'v4' is possibly undefined

//----- (0000000180013C60) ----------------------------------------------------
__int64 __fastcall CCipherMill::GetEccCurveType(CCipherMill *this, char *a2, unsigned int *a3)
{
  unsigned int EccCurveType; // ebx
  int v7; // r15d
  __int64 v8; // rsi
  unsigned int v9; // edi
  __int64 v10; // rbp
  __int128 i; // [rsp+20h] [rbp-38h] BYREF
  __int64 v12; // [rsp+30h] [rbp-28h]

  *a3 = 0;
  RtlAcquireResourceShared(&Resource, 1u);
  if ( a2 && qword_1800925C8 )
  {
    EccCurveType = CMasterEccCurveInfo::GetEccCurveType(qword_1800925C8, a2, a3);
    if ( EccCurveType )
    {
      v7 = 0;
      v8 = 0i64;
      v12 = 0i64;
      for ( i = 0i64; (unsigned int)v8 < qword_180092498; v8 = (unsigned int)(v8 + 1) )
      {
        if ( !(unsigned int)SslEnumEccCurves(qword_1800924A0[v8], (char *)&i + 8, &i, 0i64) )
        {
          v9 = 0;
          if ( DWORD2(i) )
          {
            while ( 1 )
            {
              v10 = i + 780i64 * v9;
              if ( !(unsigned int)o__stricmp_0(v10 + 510, a2) )
                break;
              if ( ++v9 >= DWORD2(i) )
                goto LABEL_13;
            }
            EccCurveType = 0;
            *a3 = *(_DWORD *)(v10 + 772);
            v7 = 1;
          }
        }
LABEL_13:
        if ( (_QWORD)i )
        {
          SslFreeBuffer();
          *(_QWORD *)&i = 0i64;
        }
        if ( v7 )
          break;
      }
    }
  }
  else
  {
    EccCurveType = 87;
  }
  RtlReleaseResource(&Resource);
  return EccCurveType;
}
// 180028D24: using guessed type __int64 __fastcall o__stricmp_0(_QWORD, _QWORD);
// 1800924A0: using guessed type unsigned __int64 qword_1800924A0[32];
// 180098458: using guessed type __int64 __fastcall SslEnumEccCurves(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098480: using guessed type __int64 SslFreeBuffer(void);

//----- (0000000180013D04) ----------------------------------------------------
__int64 __fastcall CMasterEccCurveInfo::GetEccCurveType(CMasterEccCurveInfo *this, char *a2, unsigned int *a3)
{
  unsigned int v3; // r9d
  unsigned int v4; // r11d
  __int64 v7; // rbp
  unsigned int v8; // ecx
  __int64 v9; // rdx
  __int64 v10; // r14
  __int64 v11; // r8
  char *v12; // rsi
  int v13; // ebx
  int v14; // eax
  __int64 result; // rax

  *a3 = 0;
  v3 = 0;
  v4 = *((_DWORD *)this + 2);
  if ( !v4 )
    return 1168i64;
  v7 = *(_QWORD *)this;
  while ( 1 )
  {
    v8 = 0;
    v9 = 32i64 * v3;
    if ( *(_DWORD *)(v9 + v7 + 8) )
      break;
LABEL_12:
    if ( ++v3 >= v4 )
      return 1168i64;
  }
  v10 = *(_QWORD *)(v9 + v7);
  while ( 1 )
  {
    v11 = 780i64 * v8 + v10 + 510;
    v12 = &a2[-v11];
    do
    {
      v13 = (unsigned __int8)v12[v11];
      v14 = *(unsigned __int8 *)v11 - v13;
      if ( v14 )
        break;
      ++v11;
    }
    while ( v13 );
    if ( !v14 )
      break;
    if ( ++v8 >= *(_DWORD *)(v9 + v7 + 8) )
      goto LABEL_12;
  }
  result = 0i64;
  *a3 = *(_DWORD *)(780i64 * v8 + v10 + 772);
  return result;
}

//----- (0000000180013DD0) ----------------------------------------------------
__int64 __fastcall CSslContext::GetProviderInfo(CSslContext *this, unsigned __int16 *const a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // rax
  unsigned int v4; // esi
  unsigned __int64 v6; // rdx
  __int64 *v7; // rax
  __int64 v8; // rdi
  unsigned int v9; // ebp
  unsigned __int16 *v10; // rdx
  __int64 v11; // rax

  v3 = (unsigned __int64 *)*((_QWORD *)this + 1);
  v4 = 0;
  if ( v3 )
    v6 = *v3;
  else
    v6 = 0i64;
  *a3 = v6;
  v7 = (__int64 *)*((_QWORD *)this + 1);
  if ( v7 )
    v8 = *v7;
  else
    v8 = 0i64;
  RtlAcquireResourceShared(&Resource, 1u);
  v9 = 0;
  if ( qword_180092498 )
  {
    while ( qword_1800924A0[v9] != v8 )
    {
      if ( ++v9 >= qword_180092498 )
        goto LABEL_13;
    }
    v10 = *(unsigned __int16 **)(qword_180092490 + 16i64 * v9);
    v11 = 256i64;
    while ( v11 != -2147483390 && *v10 )
    {
      *a2++ = *v10++;
      if ( !--v11 )
      {
        --a2;
        break;
      }
    }
    *a2 = 0;
  }
LABEL_13:
  RtlReleaseResource(&Resource);
  if ( v9 == qword_180092498 )
    return 1168;
  return v4;
}
// 180013E81: conditional instruction was optimized away because rax.8 is in (1..FFFFFFFF80000101|>=FFFFFFFF80000103u)
// 180092490: using guessed type __int64 qword_180092490;
// 1800924A0: using guessed type unsigned __int64 qword_1800924A0[32];

//----- (0000000180013ED0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetApplicationProtocols(CSsl3TlsContext *this, struct _SecBuffer *const a2)
{
  unsigned __int16 *v2; // rsi
  unsigned int *pvBuffer; // rdi
  __int64 v5; // rax
  unsigned int *v6; // rbx
  CCipherMill *v7; // r10
  unsigned __int8 *v8; // rax
  __int64 v9; // rdx
  unsigned __int8 *v10; // rdx
  __int64 v11; // rcx
  unsigned __int8 *v12; // rax
  void *v13; // rbx
  __int64 v14; // rdi
  void *v15; // rax
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // rdx
  CCipherMill *v20; // rcx

  v2 = 0i64;
  if ( a2 )
  {
    if ( a2->BufferType == 18 && a2->cbBuffer >= 0xC && (pvBuffer = (unsigned int *)a2->pvBuffer) != 0i64 )
    {
      v5 = *pvBuffer;
      if ( (unsigned int)v5 >= 8 && (unsigned int)v5 < 0xFFFFFFFC && a2->cbBuffer >= (unsigned int)(v5 + 4) )
      {
        v6 = pvBuffer + 1;
        if ( (v5 & 0xFFFFFFFFFFFFFFF8ui64) != 0 )
        {
          v7 = WPP_GLOBAL_Control;
          while ( 1 )
          {
            if ( *v6 == 2 )
            {
              if ( v2 )
              {
                if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v7 + 28) & 1) != 0 )
                {
                  v18 = *((_QWORD *)v7 + 2);
                  v19 = 79i64;
                  goto LABEL_47;
                }
                return 2148074278i64;
              }
              v8 = (unsigned __int8 *)v6 + 6;
              v2 = (unsigned __int16 *)v6;
              if ( v6 == (unsigned int *)-6i64 )
                return 87i64;
              v9 = *((unsigned __int16 *)v6 + 2);
              if ( (unsigned __int16)(v9 - 2) > 0xFFFBu )
              {
                if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v7 + 28) & 1) != 0 )
                {
                  v17 = 74i64;
                  goto LABEL_32;
                }
                return 2148074278i64;
              }
              v10 = &v8[v9];
              if ( v8 < v10 )
              {
                while ( 1 )
                {
                  v11 = *v8;
                  if ( !(_BYTE)v11 )
                    break;
                  v12 = &v8[v11];
                  if ( v12 >= v10 )
                    break;
                  v8 = v12 + 1;
                  if ( v8 >= v10 )
                    goto LABEL_18;
                }
                if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v7 + 28) & 1) != 0 )
                {
                  v17 = 76i64;
LABEL_32:
                  WPP_SF_(*((_QWORD *)v7 + 2), v17, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
                  return 2148074278i64;
                }
                return 2148074278i64;
              }
            }
            else if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v7 + 28) & 4) != 0 )
            {
              WPP_SF_d(*((_QWORD *)v7 + 2), 0x50u, (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids, *v6);
              v7 = WPP_GLOBAL_Control;
            }
LABEL_18:
            v6 += 2 * (((unsigned __int64)*((unsigned __int16 *)v6 + 2) + 13) >> 3);
            if ( ((char *)v6 - (char *)pvBuffer - 4) >> 3 >= (unsigned __int64)*pvBuffer >> 3 )
              goto LABEL_19;
          }
        }
        goto LABEL_19;
      }
      v20 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074278i64;
      v19 = 78i64;
    }
    else
    {
      v20 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074278i64;
      v19 = 77i64;
    }
    v18 = *((_QWORD *)v20 + 2);
LABEL_47:
    WPP_SF_(v18, v19, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    return 2148074278i64;
  }
LABEL_19:
  v13 = 0i64;
  if ( v2 )
  {
    v14 = v2[2];
    v15 = (void *)(*(__int64 (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 8i64))(this, v14 + 6);
    v13 = v15;
    if ( !v15 )
      return 14i64;
    memcpy_0(v15, v2, v14 + 6);
  }
  (*(void (__fastcall **)(CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 16i64))(this, *((_QWORD *)this + 98));
  *((_QWORD *)this + 98) = v13;
  if ( *((_QWORD *)this + 99) )
  {
    (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 99) = 0i64;
  }
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180014090) ----------------------------------------------------
__int64 __fastcall CSslContext::PopulateSerialContextState(CSslContext *this, struct _SSL_PACKED_CONTEXT *a2)
{
  int v4; // r14d
  __int64 v5; // rax
  int v6; // ecx
  int v7; // eax
  unsigned int v8; // esi
  unsigned int v9; // ebp
  CCipherMill *v10; // rcx
  int v11; // edx
  __int64 v12; // rax
  int v13; // ecx
  __int64 result; // rax
  unsigned int v15; // esi
  __int64 v16; // rdx
  unsigned int v17; // eax
  int *v18; // rax
  unsigned int v19; // r9d

  *(_DWORD *)a2 = *((_DWORD *)this + 17);
  v4 = 0;
  *((_QWORD *)a2 + 1) = *((_QWORD *)this + 17);
  *((_DWORD *)a2 + 4) = *((_DWORD *)this + 16);
  *((_BYTE *)a2 + 44) = (*(__int64 (__fastcall **)(CSslContext *))(*(_QWORD *)this + 360i64))(this);
  *((_QWORD *)a2 + 10) = *((_QWORD *)this + 16);
  if ( (*((_BYTE *)this + 32) & 8) != 0 && (v5 = *((_QWORD *)this + 1)) != 0 )
    v6 = *(_DWORD *)(v5 + 28);
  else
    v6 = 0;
  *((_DWORD *)a2 + 5) = v6;
  *((_DWORD *)a2 + 7) = *(_DWORD *)(*((_QWORD *)this + 11) + 8i64);
  *((_DWORD *)a2 + 6) = *((_DWORD *)this + 4);
  if ( (*((_BYTE *)this + 32) & 8) != 0 )
    v7 = *((_DWORD *)this + 11);
  else
    v7 = 0;
  *((_DWORD *)a2 + 8) = v7;
  *((_DWORD *)a2 + 38) = *((_DWORD *)this + 15);
  v8 = *((_DWORD *)this + 11);
  v9 = *((_DWORD *)this + 13);
  v10 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_D(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      11i64,
      &WPP_c955f13c15ab3d9e41a0e2d56db0bfe4_Traceguids,
      *((unsigned int *)this + 16));
    v10 = WPP_GLOBAL_Control;
  }
  if ( CSslGlobals::m_bSendAuxRecord != 2
    && (CSslGlobals::m_bSendAuxRecord == 1 || (*(_DWORD *)(*((_QWORD *)this + 10) + 156i64) & 0x400) != 0) )
  {
    v11 = *((_DWORD *)this + 16);
    if ( (unsigned int)(v11 - 3) <= 0x2FE && ((v11 - 65277) & 0xFFFFFFFD) != 0 && (*((_BYTE *)this + 56) & 1) != 0 )
    {
      v19 = *((_DWORD *)this + 12);
      if ( v9 )
        v19 += v9 - v19 % v9;
      v8 = v19 + *((_DWORD *)this + 11) + *((_DWORD *)this + 15) - 1;
    }
  }
  if ( v10 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v10 + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)v10 + 2), 12i64, &WPP_c955f13c15ab3d9e41a0e2d56db0bfe4_Traceguids, v8);
  *((_DWORD *)a2 + 9) = v8;
  v12 = (*(__int64 (__fastcall **)(CSslContext *))(*(_QWORD *)this + 248i64))(this);
  if ( v12 )
    v13 = *(_DWORD *)(v12 + 428);
  else
    v13 = 0;
  *((_DWORD *)a2 + 10) = v13;
  result = (*(__int64 (__fastcall **)(CSslContext *, char *, char *))(*(_QWORD *)this + 64i64))(
             this,
             (char *)a2 + 144,
             (char *)a2 + 148);
  v15 = result;
  if ( (int)result >= 0 )
  {
    *((_QWORD *)a2 + 6) = *((_QWORD *)this + 22);
    *((_QWORD *)a2 + 7) = *((_QWORD *)this + 23);
    *((_DWORD *)a2 + 22) = 32;
    v16 = *((_QWORD *)this + 11);
    v17 = *(unsigned __int16 *)(v16 + 238);
    if ( v17 <= 0x20 )
    {
      *((_DWORD *)a2 + 22) = v17;
      memcpy_0((char *)a2 + 92, (const void *)(v16 + 240), *(unsigned __int16 *)(v16 + 238));
    }
    *((_DWORD *)a2 + 44) = *((_DWORD *)this + 48);
    *((_QWORD *)a2 + 20) = *((_QWORD *)this + 25);
    *((_QWORD *)a2 + 21) = *((_QWORD *)this + 26);
    *((_WORD *)a2 + 90) = *((_WORD *)this + 108);
    *((_WORD *)a2 + 91) = *((_WORD *)this + 109);
    v18 = (int *)*((_QWORD *)this + 28);
    if ( v18 )
      v4 = *v18;
    *((_DWORD *)a2 + 46) = v4;
    *((_DWORD *)a2 + 47) = CSslGlobals::m_dwMaxEncryptedRecords;
    *((_BYTE *)a2 + 192) = (*(__int64 (__fastcall **)(CSslContext *))(*(_QWORD *)this + 176i64))(this);
    return v15;
  }
  return result;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927BC: using guessed type unsigned int CSslGlobals::m_bSendAuxRecord;

//----- (0000000180014300) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::UpdateHandshakeHash(CSsl3TlsContext *this, unsigned __int8 *a2, unsigned int a3)
{
  __int64 v6; // rbx
  _QWORD *v7; // rax
  __int64 v8; // rcx
  unsigned int v9; // r14d

  if ( !a2 )
    return 0i64;
  if ( !a3 )
    return 0i64;
  if ( !*a2 )
    return 0i64;
  v6 = 0i64;
  if ( !*((_DWORD *)this + 137) )
    return 0i64;
  while ( 1 )
  {
    v7 = (_QWORD *)*((_QWORD *)this + 1);
    v8 = v7 ? *v7 : 0i64;
    v9 = SslHashHandshake(v8, *((_QWORD *)this + v6 + 74), a2, a3, 0);
    if ( v9 )
      break;
    v6 = (unsigned int)(v6 + 1);
    if ( (unsigned int)v6 >= *((_DWORD *)this + 137) )
      return 0i64;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids, v9);
  return v9;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098420: using guessed type __int64 __fastcall SslHashHandshake(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);

//----- (00000001800143B0) ----------------------------------------------------
void __fastcall CSslContext::GetCertContextInfo(
        CSslContext *this,
        unsigned __int8 **a2,
        unsigned int *a3,
        unsigned __int16 **a4,
        unsigned int *a5,
        unsigned __int16 **a6,
        unsigned int *a7,
        unsigned __int8 **a8,
        unsigned int *a9,
        const unsigned __int8 **a10,
        unsigned int *a11,
        unsigned __int8 **a12,
        unsigned int *a13)
{
  __int64 v17; // rax
  unsigned int v18; // ecx
  unsigned int *v19; // rax
  __int64 v20; // rcx

  v17 = (*(__int64 (__fastcall **)(CSslContext *))(*(_QWORD *)this + 248i64))(this);
  if ( v17 )
  {
    *a4 = *(unsigned __int16 **)(v17 + 400);
    *a5 = *(_DWORD *)(v17 + 408);
    *a6 = *(unsigned __int16 **)(v17 + 416);
    v18 = *(_DWORD *)(v17 + 424);
    v19 = a7;
  }
  else
  {
    v18 = 0;
    *a6 = 0i64;
    *a4 = 0i64;
    *a7 = 0;
    v19 = a5;
  }
  *v19 = v18;
  v20 = *((_QWORD *)this + 11);
  *a3 = *(_DWORD *)(v20 + 32);
  *a2 = *(unsigned __int8 **)(v20 + 24);
  (*(void (__fastcall **)(CSslContext *, unsigned __int8 **, unsigned int *))(*(_QWORD *)this + 272i64))(this, a8, a9);
  (*(void (__fastcall **)(CSslContext *, const unsigned __int8 **, unsigned int *))(*(_QWORD *)this + 280i64))(
    this,
    a10,
    a11);
  (*(void (__fastcall **)(CSslContext *, unsigned __int8 **, unsigned int *))(*(_QWORD *)this + 288i64))(this, a12, a13);
}

//----- (0000000180014500) ----------------------------------------------------
HLOCAL __fastcall CSslContext::GetMemory(CSslContext *this, __int64 a2)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(*((_QWORD *)this + 16) + 24i64);
  if ( v2 )
    return (HLOCAL)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v2 + 48i64))(v2, a2, 0i64);
  if ( LsaTable )
    return (HLOCAL)(*(__int64 (__fastcall **)(_QWORD))(LsaTable + 40))((unsigned int)a2);
  return LocalAlloc(0x40u, (unsigned int)a2);
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180014550) ----------------------------------------------------
__int64 __fastcall CSessionCacheTable::DereferenceCacheItemInternal(
        CSessionCacheTable *this,
        struct CSessionCacheItem *a2,
        char a3,
        char a4)
{
  unsigned __int32 v8; // ebx
  CSessionCacheTable **v9; // rdx
  CSessionCacheTable *v10; // rax

  if ( a3 && !a4 )
    RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)this + 48), 1u);
  v8 = _InterlockedDecrement((volatile signed __int32 *)a2 + 58);
  if ( v8 == 1 )
  {
    LsaIModifyPerformanceCounter(5i64);
    if ( !a3 )
      return v8;
    v9 = (CSessionCacheTable **)*((_QWORD *)this + 5);
    v10 = (struct CSessionCacheItem *)((char *)a2 + 320);
    if ( *v9 != (CSessionCacheTable *)((char *)this + 32) )
      __fastfail(3u);
    *(_QWORD *)v10 = (char *)this + 32;
    *((_QWORD *)a2 + 41) = v9;
    *v9 = v10;
    *((_QWORD *)this + 5) = v10;
  }
  else if ( !a3 )
  {
    return v8;
  }
  if ( !a4 )
    RtlReleaseResource((PRTL_RESOURCE)((char *)this + 48));
  return v8;
}
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);

//----- (0000000180014630) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetTBParameters(CSsl3TlsContext *this, struct _SecBuffer *const a2)
{
  void *v3; // rdi
  __int64 v4; // rdx
  struct _SEC_TOKEN_BINDING *pvBuffer; // rsi
  unsigned int TBParametersSize; // eax
  unsigned int v8; // r8d
  __int64 v9; // rbp
  __int64 (__fastcall *v10)(CSsl3TlsContext *, __int64); // r9
  void *v11; // rax
  CCipherMill *v12; // rcx
  __int64 v13; // rdx

  if ( a2 )
  {
    if ( a2->BufferType == 21 && a2->cbBuffer >= 6 && (pvBuffer = (struct _SEC_TOKEN_BINDING *)a2->pvBuffer) != 0i64 )
    {
      TBParametersSize = CSsl3TlsContext::GetTBParametersSize((struct _SEC_TOKEN_BINDING *const)a2->pvBuffer);
      if ( v8 < TBParametersSize )
      {
        v12 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v13 = 92i64;
      }
      else
      {
        if ( pvBuffer == (struct _SEC_TOKEN_BINDING *)-4i64 )
          return 87i64;
        if ( (unsigned __int16)(pvBuffer->KeyParametersSize - 1) <= 0xFEu )
        {
          v9 = (unsigned int)CSsl3TlsContext::GetTBParametersSize(pvBuffer);
          v11 = (void *)v10(this, v9);
          v3 = v11;
          if ( !v11 )
            return 14i64;
          memcpy_0(v11, pvBuffer, (unsigned int)v9);
          goto LABEL_3;
        }
        v12 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v13 = 90i64;
      }
    }
    else
    {
      v12 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074278i64;
      v13 = 91i64;
    }
    WPP_SF_(*((_QWORD *)v12 + 2), v13, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    return 2148074278i64;
  }
  v3 = 0i64;
LABEL_3:
  if ( *((_QWORD *)this + 102) )
    (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
  v4 = *((_QWORD *)this + 103);
  *((_QWORD *)this + 102) = v3;
  if ( v4 )
  {
    if ( *(_QWORD *)(v4 + 8) )
    {
      (*(void (__fastcall **)(CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 16i64))(this, *(_QWORD *)(v4 + 8));
      v4 = *((_QWORD *)this + 103);
    }
    (*(void (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 16i64))(this, v4);
    *((_QWORD *)this + 103) = 0i64;
  }
  return 0i64;
}
// 1800146BC: variable 'v8' is possibly undefined
// 180014707: variable 'v10' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180014734) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::GetTBParametersSize(struct _SEC_TOKEN_BINDING *const a1)
{
  __int64 KeyParametersSize; // rax
  unsigned int v2; // ecx
  unsigned __int64 v3; // rax

  if ( !a1 )
    return 0i64;
  KeyParametersSize = a1->KeyParametersSize;
  v2 = 6;
  v3 = KeyParametersSize + 4;
  if ( v3 > 6 )
    return (unsigned int)v3;
  return v2;
}

//----- (0000000180014760) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::MakeRsaKeyXParameterList(
        __int64 a1,
        int a2,
        _DWORD *a3,
        __int64 a4,
        __int64 a5,
        int *a6)
{
  unsigned int v6; // eax
  __int64 v9; // rsi
  unsigned int v10; // ebp
  __int64 v11; // rdx
  unsigned int v12; // eax
  __int64 v13; // rdx
  int v14; // eax
  int v16; // r12d
  unsigned int v17; // r13d
  __int64 v18; // rax
  _QWORD *v19; // rcx
  int v20; // eax
  unsigned int v21; // r12d

  v6 = 0;
  if ( !a4 )
    return 87i64;
  v9 = *(_QWORD *)(a4 + 8);
  v10 = *(_DWORD *)(a4 + 4);
  if ( !a2 )
    goto LABEL_3;
  if ( a2 != 1 || !a3 || !v10 )
    return 87i64;
  *a3 = *(_DWORD *)(a1 + 36);
  v6 = 1;
  *(_DWORD *)(v9 + 4) = 22;
  *(_DWORD *)v9 = 4;
  *(_QWORD *)(v9 + 8) = a3;
  if ( (*(_DWORD *)(a1 + 136) & 0x8000000) == 0 )
  {
LABEL_3:
    if ( v10 >= v6 + 2 )
    {
      v11 = 2i64 * v6;
      v12 = v6 + 1;
      *(_QWORD *)(v9 + 8 * v11 + 8) = a1 + 272;
      *(_DWORD *)(v9 + 8 * v11 + 4) = 20;
      *(_DWORD *)(v9 + 8 * v11) = 32;
      v13 = 2i64 * v12;
      v14 = v12 + 1;
      *(_DWORD *)(v9 + 8 * v13 + 4) = 21;
      *(_DWORD *)(v9 + 8 * v13) = 32;
      *(_QWORD *)(v9 + 8 * v13 + 8) = a1 + 304;
LABEL_5:
      *(_DWORD *)(a4 + 4) = v14;
      return 0i64;
    }
    return 87i64;
  }
  if ( !a5 )
    return 87i64;
  if ( !a6 )
    return 87i64;
  v16 = *a6;
  if ( !*a6 )
    return 87i64;
  v17 = *(unsigned __int16 *)(a1 + 34);
  v18 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 512i64))(a1, 0i64);
  v19 = *(_QWORD **)(a1 + 8);
  if ( v19 )
    v19 = (_QWORD *)*v19;
  v20 = SslComputeSessionHash(v19, v18, v17, a5, v16, a6, 0);
  v21 = v20;
  if ( !v20 )
  {
    if ( v10 >= 2 )
    {
      *(_DWORD *)(v9 + 20) = 25;
      *(_DWORD *)(v9 + 16) = *a6;
      v14 = 2;
      *(_QWORD *)(v9 + 24) = a5;
      goto LABEL_5;
    }
    return 87i64;
  }
  CSslContext::SetErrorAndFatalAlert(a1, 604, v20, 0x33u);
  return v21;
}
// 180098530: using guessed type __int64 __fastcall SslComputeSessionHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);

//----- (0000000180014810) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetPSKParameters(
        CSsl3TlsContext *this,
        struct _SecBuffer *const a2,
        struct _SecBuffer *const a3)
{
  unsigned __int16 *pvBuffer; // rbp
  size_t v7; // rsi
  CCipherMill *v8; // rcx
  __int64 v9; // rdx
  void *v10; // rax
  unsigned int cbBuffer; // ecx
  unsigned __int16 *v12; // rsi
  size_t v13; // rbx
  void *v14; // rax

  if ( a2 )
  {
    if ( a2->BufferType != 22 || a2->cbBuffer < 4 || (pvBuffer = (unsigned __int16 *)a2->pvBuffer) == 0i64 )
    {
      v8 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074278i64;
      v9 = 93i64;
      goto LABEL_37;
    }
    v7 = (unsigned int)*pvBuffer + 2;
    if ( (unsigned int)v7 <= 4 )
    {
      v7 = 4i64;
    }
    else if ( a2->cbBuffer < (unsigned int)v7 )
    {
      v8 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074278i64;
      v9 = 94i64;
      goto LABEL_37;
    }
    if ( *((_QWORD *)this + 106) )
      (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
    v10 = (void *)(*(__int64 (__fastcall **)(CSsl3TlsContext *, size_t))(*(_QWORD *)this + 8i64))(this, v7);
    *((_QWORD *)this + 106) = v10;
    if ( !v10 )
      return 14i64;
    memcpy_0(v10, pvBuffer, v7);
  }
  if ( !a3 )
    return 0i64;
  if ( a3->BufferType != 23
    || (cbBuffer = a3->cbBuffer, a3->cbBuffer < 4)
    || (v12 = (unsigned __int16 *)a3->pvBuffer) == 0i64 )
  {
    v8 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v9 = 95i64;
    goto LABEL_37;
  }
  v13 = (unsigned int)*v12 + 2;
  if ( (unsigned int)v13 <= 4 )
  {
    v13 = 4i64;
LABEL_29:
    if ( *((_QWORD *)this + 107) )
      (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
    v14 = (void *)(*(__int64 (__fastcall **)(CSsl3TlsContext *, size_t))(*(_QWORD *)this + 8i64))(this, v13);
    *((_QWORD *)this + 107) = v14;
    if ( v14 )
    {
      memcpy_0(v14, v12, v13);
      return 0i64;
    }
    return 14i64;
  }
  if ( cbBuffer >= (unsigned int)v13 )
    goto LABEL_29;
  v8 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
    return 2148074278i64;
  v9 = 96i64;
LABEL_37:
  WPP_SF_(*((_QWORD *)v8 + 2), v9, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
  return 2148074278i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180014860) ----------------------------------------------------
void __fastcall CSslContext::CleanupLsaModeKeys(CSslContext *this)
{
  __int64 v2; // rcx
  __int64 v3; // rcx

  v2 = *((_QWORD *)this + 19);
  if ( v2 )
  {
    SslFreeObject(v2, 0i64);
    *((_QWORD *)this + 19) = 0i64;
  }
  v3 = *((_QWORD *)this + 18);
  if ( v3 )
  {
    SslFreeObject(v3, 0i64);
    *((_QWORD *)this + 18) = 0i64;
  }
  if ( *((_BYTE *)this + 233) )
  {
    if ( *((_BYTE *)this + 264) )
      *((_QWORD *)this + 31) = 0i64;
  }
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (00000001800148D0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetSrtpParameters(
        CSsl3TlsContext *this,
        struct _SecBuffer *const a2,
        struct _SecBuffer *const a3)
{
  struct _SEC_SRTP_PROTECTION_PROFILES *pvBuffer; // rsi
  _BYTE *v4; // r14
  __int64 result; // rax
  CCipherMill *v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // rax
  int ProfilesSize; // edx
  int v13; // ecx
  int v14; // eax

  pvBuffer = 0i64;
  v4 = 0i64;
  if ( !*((_BYTE *)this + 233) )
  {
    if ( !a2 && !a3 )
      return 0i64;
    v9 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v10 = 84i64;
LABEL_46:
    WPP_SF_(*((_QWORD *)v9 + 2), v10, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    return 2148074278i64;
  }
  v11 = *((_QWORD *)this + 72);
  if ( v11 && *(_QWORD *)(v11 + 56) != v11 + 56 )
    return 0i64;
  if ( !a2 )
    goto LABEL_20;
  if ( a2->BufferType != 19
    || a2->cbBuffer < 4
    || (pvBuffer = (struct _SEC_SRTP_PROTECTION_PROFILES *)a2->pvBuffer) == 0i64 )
  {
    v9 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v10 = 85i64;
    goto LABEL_46;
  }
  ProfilesSize = pvBuffer->ProfilesSize;
  if ( a2->cbBuffer < ProfilesSize + 2 )
  {
    v9 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v10 = 86i64;
    goto LABEL_46;
  }
  result = CSsl3TlsContext::ValidateProtectionProfiles(pvBuffer->ProfilesList, ProfilesSize, 1);
  if ( !(_DWORD)result )
  {
LABEL_20:
    if ( a3 )
    {
      if ( !a2 || a3->BufferType != 20 || a3->cbBuffer < 2 || (v4 = a3->pvBuffer) == 0i64 )
      {
        v9 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v10 = 87i64;
        goto LABEL_46;
      }
      if ( !*v4 || a3->cbBuffer < (unsigned int)(unsigned __int8)*v4 + 1 )
      {
        v9 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v10 = 88i64;
        goto LABEL_46;
      }
    }
    if ( pvBuffer )
      v13 = pvBuffer->ProfilesSize + 2;
    else
      v13 = 0;
    if ( v4 )
      v14 = (unsigned __int8)*v4 + 1;
    else
      v14 = 1;
    if ( (unsigned int)(v13 + v14) > 0xFFFF )
    {
      v9 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074278i64;
      v10 = 89i64;
      goto LABEL_46;
    }
    result = CSsl3TlsContext::SetSrtpProtectionProfiles(this, pvBuffer);
    if ( !(_DWORD)result )
    {
      result = (*(__int64 (__fastcall **)(CSsl3TlsContext *, _BYTE *))(*(_QWORD *)this + 440i64))(this, v4);
      if ( !(_DWORD)result )
      {
        CSsl3TlsContext::FreeSelectedSrtpParameters(this);
        return 0i64;
      }
    }
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180014940) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetPMTU(CSsl3TlsContext *this, struct _SecBuffer *const a2)
{
  unsigned __int16 *pvBuffer; // rax
  int v4; // r10d
  unsigned __int16 v5; // ax
  __int64 v6; // rcx
  __int16 v7; // r10

  if ( !*((_BYTE *)this + 233) || !a2 )
    return 0i64;
  if ( a2->BufferType == 24 && a2->cbBuffer == 2 && (pvBuffer = (unsigned __int16 *)a2->pvBuffer) != 0i64 )
  {
    v4 = *pvBuffer;
    if ( (unsigned __int16)v4 >= 0xC8u )
    {
      v5 = CSslContext::computeMaxPayload(this, v4);
      if ( v5 )
      {
        *(_WORD *)(v6 + 216) = v7;
        *(_WORD *)(v6 + 218) = v5;
        return 0i64;
      }
    }
    return 87i64;
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 97i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    return 2148074278i64;
  }
}
// 18003D982: variable 'v7' is possibly undefined
// 18003D982: variable 'v6' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180014970) ----------------------------------------------------
void __fastcall CSslContext::GetReadWriteApplicationTrafficSecrets(
        CSslContext *this,
        unsigned __int64 *a2,
        unsigned __int64 *a3)
{
  if ( a2 )
    *a2 = 0i64;
  if ( a3 )
    *a3 = 0i64;
}

//----- (0000000180014990) ----------------------------------------------------
void __fastcall CSsl3TlsContext::GetUniqueBindings(CSsl3TlsContext *this, unsigned __int8 **a2, unsigned int *a3)
{
  *a2 = (unsigned __int8 *)this + 341;
  *a3 = (*((_DWORD *)this + 16) & 0x3FC0) != 0 ? 12 : 36;
}

//----- (00000001800149C0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::ProcessRecord(__int64 a1, int a2, unsigned __int8 *a3, unsigned int a4)
{
  int v4; // r10d
  __int64 result; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rcx
  unsigned int SessionKeys; // esi

  v4 = *(_DWORD *)(a1 + 68);
  if ( v4 != 51 )
  {
LABEL_2:
    if ( a2 != 20 )
      return CSsl3TlsContext::ProcessRecord(a1, a2, a3, a4);
    if ( v4 == 46 )
    {
LABEL_6:
      if ( !(unsigned int)CSsl3TlsContext::DigestCcs((CSsl3TlsContext *)a1, a3, a4) )
      {
        if ( *(_DWORD *)(a1 + 68) == 47 || *(_DWORD *)(a1 + 68) == 52 )
          *(_DWORD *)(a1 + 68) = 48;
        else
          *(_DWORD *)(a1 + 68) = 45;
      }
      return CSsl3TlsContext::ProcessRecord(a1, a2, a3, a4);
    }
    if ( v4 != 47 )
    {
      if ( v4 == 50 )
        goto LABEL_6;
      if ( v4 != 52 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_Sd(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0xDu,
            (__int64)&WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
            *(const wchar_t **)(*(_QWORD *)(a1 + 1320) + 368i64),
            v4);
        return CSsl3TlsContext::ProcessRecord(a1, a2, a3, a4);
      }
    }
    v10 = *(_QWORD *)(a1 + 136);
    if ( (v10 & 0x1000000) != 0 )
    {
      if ( (v10 & 0x8000000) == 0 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        CSslContext::SetErrorAndFatalAlert(a1, 106, -2146893018, 0x28u);
        return CSsl3TlsContext::ProcessRecord(a1, a2, a3, a4);
      }
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_S(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xBu,
          (__int64)&WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
          *(const wchar_t **)(*(_QWORD *)(a1 + 1320) + 368i64));
      v11 = *(_QWORD *)(a1 + 120);
      if ( v11 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
      {
        *(_DWORD *)(v11 + 24) = 1;
        *(_WORD *)(v11 + 64) |= 0xAu;
      }
      v12 = *(_QWORD *)(a1 + 1320);
      *(_QWORD *)(a1 + 136) &= ~0x1000000ui64;
      RtlAcquireResourceShared((PRTL_RESOURCE)(v12 + 72), 1u);
      SessionKeys = CSslContext::MakeSessionKeys((CSslContext *)a1, *(_QWORD *)(*(_QWORD *)(a1 + 1320) + 16i64));
      RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)(a1 + 1320) + 72i64));
      if ( SessionKeys )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            12i64,
            &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
            SessionKeys);
        return CSsl3TlsContext::ProcessRecord(a1, a2, a3, a4);
      }
    }
    goto LABEL_6;
  }
  if ( (*(_DWORD *)(a1 + 136) & 0x40000000) == 0 || *(_BYTE *)(a1 + 266) )
  {
LABEL_14:
    *(_DWORD *)(a1 + 68) = 46;
    v4 = 46;
    goto LABEL_2;
  }
  result = RemotelyGetUserKeys((struct CSslContext *)a1, 2u);
  if ( !(_DWORD)result )
  {
    *(_QWORD *)(a1 + 136) &= ~0x40000000ui64;
    goto LABEL_14;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180014AB0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::ProcessRecord(__int64 a1, int a2, unsigned __int8 *a3, unsigned int a4)
{
  unsigned int v4; // ebp
  unsigned __int8 *v5; // rsi
  __int64 v8; // rax
  bool v9; // cl
  int v10; // ebx
  __int64 v11; // r14
  unsigned int v12; // ebx
  __int64 result; // rax
  __int64 v14; // r10
  unsigned int v15; // r9d
  unsigned int v16; // ecx
  CTlsMessageFragment *v17; // rcx
  unsigned int v18; // eax
  bool v19; // zf
  _QWORD *Memory; // rax
  CCipherMill *v21; // rcx
  bool v22; // zf
  CCipherMill *v23; // rcx
  bool v24; // zf
  unsigned int v25; // eax
  bool v26; // zf
  int v27; // eax
  unsigned int v28[4]; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int8 v29; // [rsp+70h] [rbp+8h] BYREF

  v4 = a4;
  v5 = a3;
  if ( *(_BYTE *)(a1 + 233) )
    return CSsl3TlsContext::DtlsProcessRecord(a1, a2, a3, a4);
  v8 = *(_QWORD *)(a1 + 464);
  v28[0] = 0;
  v9 = 1;
  if ( !v8 || !*(_DWORD *)(v8 + 36) )
  {
LABEL_3:
    v10 = a2 - 21;
    if ( !v10 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 57i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
      v27 = TlsParseAlertMessage(v5, v4, (unsigned __int8 *)(a1 + 473), &v29);
      v12 = v27;
      if ( v27 )
      {
        if ( v27 == -2146892953 || *(_DWORD *)(a1 + 36) < 0x302u || (*(_DWORD *)(a1 + 64) & 0x800A00AA) == 0 )
        {
          if ( v4 == 2 )
            LogReceiveAlertEvent(
              *(_DWORD *)(*(_QWORD *)(a1 + 80) + 212i64),
              (const unsigned __int16 *)(*(_QWORD *)(a1 + 80) + 216i64),
              *v5,
              v5[1]);
        }
        else
        {
          CSslContext::SetError(a1, 14, v27);
          return (unsigned int)-2146893018;
        }
      }
      else if ( v29 )
      {
        *(_BYTE *)(a1 + 552) = 1;
        *(_DWORD *)(a1 + 68) = 75;
      }
      return v12;
    }
    if ( v10 != 1 )
      return 0;
    while ( v4 >= 4 )
    {
      v11 = v5[3] + (v5[1] << 16) + (v5[2] << 8);
      if ( v11 + 4 > (unsigned __int64)v4 )
      {
        v17 = *(CTlsMessageFragment **)(a1 + 464);
        if ( v17 )
          goto LABEL_52;
        if ( (*(_DWORD *)(a1 + 64) & 0x40051555) != 0 )
        {
          if ( (*(_DWORD *)(a1 + 136) & 0x100i64) == 0 )
            goto LABEL_36;
          v18 = CSslGlobals::m_dwTlsMessageLimitSrvClientAuth;
          if ( CSslGlobals::m_dwTlsMessageLimitSrv > CSslGlobals::m_dwTlsMessageLimitSrvClientAuth )
            v18 = CSslGlobals::m_dwTlsMessageLimitSrv;
          if ( v18 )
          {
LABEL_36:
            v19 = CSslGlobals::m_dwTlsMessageLimitSrv == 0;
            goto LABEL_38;
          }
          goto LABEL_41;
        }
        v19 = CSslGlobals::m_dwTlsMessageLimitClient == 0;
LABEL_38:
        if ( !v19 )
        {
          Memory = CSslContext::GetMemory((CSslContext *)a1, 0x30u);
          if ( !Memory )
          {
            v21 = WPP_GLOBAL_Control;
            v22 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
LABEL_47:
            if ( !v22 && (*((_BYTE *)v21 + 28) & 1) != 0 )
              WPP_SF_(*((_QWORD *)v21 + 2), 68i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
            return 14;
          }
LABEL_51:
          *Memory = 0i64;
          *(_QWORD *)((char *)Memory + 12) = 256i64;
          Memory[3] = 0i64;
          Memory[4] = 0i64;
          *(_QWORD *)(a1 + 464) = Memory;
          CTlsMessageFragment::Initialize((CTlsMessageFragment *)Memory, (struct CSsl3TlsContext *)a1);
          v17 = *(CTlsMessageFragment **)(a1 + 464);
LABEL_52:
          v28[0] = 0;
          return (unsigned int)CTlsMessageFragment::SaveFragment(v17, v5, v4, 1, v28);
        }
LABEL_41:
        v23 = WPP_GLOBAL_Control;
        v24 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
LABEL_43:
        if ( !v24 && (*((_BYTE *)v23 + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)v23 + 2), 67i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        v12 = -2146893018;
        CSslContext::SetErrorAndFatalAlert(a1, 12, -2146893018, 0xAu);
        return v12;
      }
      v12 = CSsl3TlsContext::ProcessHandshakeCommon((CSsl3TlsContext *)a1, v5, (int)v11 + 4);
      if ( !v12 )
      {
        v5 += v11 + 4;
        v4 += -4 - v11;
        if ( v4 )
          continue;
      }
      return v12;
    }
    v17 = *(CTlsMessageFragment **)(a1 + 464);
    if ( v17 )
      goto LABEL_52;
    if ( (*(_DWORD *)(a1 + 64) & 0x40051555) != 0 )
    {
      if ( (*(_DWORD *)(a1 + 136) & 0x100i64) != 0 )
      {
        v25 = CSslGlobals::m_dwTlsMessageLimitSrvClientAuth;
        if ( CSslGlobals::m_dwTlsMessageLimitSrv > CSslGlobals::m_dwTlsMessageLimitSrvClientAuth )
          v25 = CSslGlobals::m_dwTlsMessageLimitSrv;
        if ( !v25 )
        {
LABEL_42:
          v23 = WPP_GLOBAL_Control;
          v24 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
          goto LABEL_43;
        }
      }
      v26 = CSslGlobals::m_dwTlsMessageLimitSrv == 0;
    }
    else
    {
      v26 = CSslGlobals::m_dwTlsMessageLimitClient == 0;
    }
    if ( !v26 )
    {
      Memory = CSslContext::GetMemory((CSslContext *)a1, 0x30u);
      if ( !Memory )
      {
        v21 = WPP_GLOBAL_Control;
        v22 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
        goto LABEL_47;
      }
      goto LABEL_51;
    }
    goto LABEL_42;
  }
  if ( a2 != 22 )
  {
    if ( a2 == 21 )
      *(_QWORD *)(v8 + 32) = 0i64;
LABEL_12:
    result = 0i64;
    if ( !v9 )
      return result;
    goto LABEL_3;
  }
  result = CTlsMessageFragment::SaveFragment((CTlsMessageFragment *)v8, a3, a4, 0, v28);
  if ( !(_DWORD)result )
  {
    v14 = *(_QWORD *)(a1 + 464);
    v15 = *(_DWORD *)(v14 + 32);
    v16 = *(_DWORD *)(v14 + 40) != 0 ? 12 : 4;
    if ( (v15 <= v16 || *(_DWORD *)(v14 + 36) < v15)
      && (*(_DWORD *)(v14 + 36) < v16
       || *(unsigned __int8 *)(*(_QWORD *)(v14 + 24) + 3i64)
        + (*(unsigned __int8 *)(*(_QWORD *)(v14 + 24) + 1i64) << 16)
        + (*(unsigned __int8 *)(*(_QWORD *)(v14 + 24) + 2i64) << 8)) )
    {
      return 0i64;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_d(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x45u,
        (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
        v15);
      v14 = *(_QWORD *)(a1 + 464);
    }
    result = CSsl3TlsContext::ProcessHandshakeCommon(
               (CSsl3TlsContext *)a1,
               *(unsigned __int8 **)(v14 + 24),
               *(_DWORD *)(v14 + 32));
    if ( !(_DWORD)result )
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 464) + 32i64) = 0i64;
      v5 += v28[0];
      v4 -= v28[0];
      v9 = v4 != 0;
      goto LABEL_12;
    }
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180014B9C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::ProcessHandshakeCommon(CSsl3TlsContext *this, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v6; // edi
  unsigned int v7; // eax
  int v9; // [rsp+40h] [rbp+8h] BYREF

  v9 = 0;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_DDD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x3Au,
      (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
      *((_DWORD *)this + 16),
      *a2,
      *((_DWORD *)this + 17));
  v6 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, unsigned __int8 *, _QWORD, int *))(*(_QWORD *)this + 416i64))(
         this,
         a2,
         a3,
         &v9);
  if ( (!v6 || v6 == 590624) && !v9 && !*((_DWORD *)this + 218) )
  {
    v7 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, unsigned __int8 *, _QWORD, _QWORD))(*(_QWORD *)this + 504i64))(
           this,
           a2,
           a3,
           0i64);
    if ( v7 )
      v6 = v7;
  }
  if ( *((_BYTE *)this + 923) )
  {
    v6 = 590610;
    *((_DWORD *)this + 18) = *((_DWORD *)this + 17);
    *((_DWORD *)this + 17) = 77;
  }
  else if ( v6 == 590624 )
  {
    *((_BYTE *)this + 924) = 1;
  }
  return v6;
}

//----- (0000000180014C84) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::DigestCcs(CSsl3TlsContext *this, unsigned __int8 *a2, int a3)
{
  __int64 v4; // rcx
  __int64 v5; // rax
  char v6; // al

  if ( a3 == 1 && *a2 == 1 )
  {
    *((_WORD *)this + 16) |= 0xAu;
    v4 = *((_QWORD *)this + 18);
    if ( v4 )
      SslFreeObject(v4, 0i64);
    v5 = *((_QWORD *)this + 20);
    *((_QWORD *)this + 20) = 0i64;
    *((_QWORD *)this + 18) = v5;
    v6 = *((_BYTE *)this + 233);
    if ( !v6 )
      *((_QWORD *)this + 22) = 0i64;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 60i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
      v6 = *((_BYTE *)this + 233);
    }
    if ( v6 )
    {
      ++*((_DWORD *)this + 48);
      *((_QWORD *)this + 26) = 0i64;
      *((_QWORD *)this + 25) = 0i64;
    }
    return 0i64;
  }
  else
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 904, -2146893018, 0xAu);
    return 2148074278i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180014D20) ----------------------------------------------------
unsigned __int64 __fastcall CSsl3TlsContext::GetHandshakeHash(CSsl3TlsContext *this, enum _eTlsHashAlgorithm a2)
{
  if ( a2 )
    return CSsl3TlsContext::FindTlsClientAuthHandshakeHash(this, a2);
  else
    return *((_QWORD *)this + 74);
}

//----- (0000000180014D38) ----------------------------------------------------
__int64 __fastcall I_GetHashInfoFromAlgorithmName(wchar_t *String1)
{
  unsigned int v1; // eax
  __int64 v2; // rbx
  const wchar_t **v4; // rdx
  const wchar_t *v5; // rdx

  v1 = g_dwHashInfoTotalCount;
  v2 = 0i64;
  if ( !g_dwHashInfoTotalCount )
    return 0i64;
  while ( 1 )
  {
    v4 = (const wchar_t **)g_pHashInfo[v2];
    if ( !v4 )
      goto LABEL_6;
    v5 = *v4;
    if ( !v5 )
      goto LABEL_6;
    if ( !wcsnicmp(String1, v5, 0x40ui64) )
      return g_pHashInfo[v2];
    v1 = g_dwHashInfoTotalCount;
LABEL_6:
    v2 = (unsigned int)(v2 + 1);
    if ( (unsigned int)v2 >= v1 )
      return 0i64;
  }
}
// 180092324: using guessed type int g_dwHashInfoTotalCount;
// 180092330: using guessed type _QWORD g_pHashInfo[16];

//----- (0000000180014DB8) ----------------------------------------------------
DWORD __fastcall GetPublicKeyFromCert(const struct _CERT_CONTEXT *a1, struct _PUBLICKEY **a2, unsigned int *a3)
{
  PCERT_INFO pCertInfo; // rbx
  struct _CERT_PUBLIC_KEY_INFO *p_SubjectPublicKeyInfo; // rsi
  int v7; // eax
  unsigned int v8; // edi
  DWORD result; // eax
  int v10; // eax
  int v11; // eax
  char *v12; // rax
  unsigned int *v13; // rbx
  DWORD v14; // eax
  DWORD v15; // esi
  unsigned int *v16; // rax
  PCCRYPT_OID_INFO v17; // rdx
  int v18; // edi
  char *v19; // rax
  __int64 v20; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v21; // [rsp+60h] [rbp+30h] BYREF
  int v22; // [rsp+78h] [rbp+48h] BYREF

  pCertInfo = a1->pCertInfo;
  v20 = 0i64;
  p_SubjectPublicKeyInfo = &pCertInfo->SubjectPublicKeyInfo;
  if ( pCertInfo == (PCERT_INFO)-96i64 )
    return -2146893052;
  v7 = MapOidToKeyExch(p_SubjectPublicKeyInfo->Algorithm.pszObjId);
  v22 = v7;
  v8 = v7;
  if ( !v7 )
    return -2146893043;
  v10 = v7 - 8704;
  if ( v10 )
  {
    v11 = v10 - 3;
    if ( !v11 )
    {
      result = GetAlgIdFromEccTypeCertParameters(
                 pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
                 pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData,
                 (PCCRYPT_OID_INFO *)&v20,
                 &v22);
      if ( result )
        return result;
      result = EcdsaPublicKeyFromCert((__int64)&pCertInfo->SubjectPublicKeyInfo, v20, 0i64, &v21);
      if ( result )
        return result;
      if ( v21 < 0xFFFFFFF0 )
      {
        v16 = (unsigned int *)SPExternalAlloc(v21 + 16);
        v13 = v16;
        if ( v16 )
        {
          v17 = (PCCRYPT_OID_INFO)v20;
          *(_QWORD *)v16 = v16 + 4;
          v16[2] = v21;
          v18 = EcdsaPublicKeyFromCert((__int64)p_SubjectPublicKeyInfo, (__int64)v17, v16 + 4, v16 + 2);
          if ( v18 )
          {
            SPExternalFree(v13);
            return v18;
          }
          v8 = v22;
          goto LABEL_20;
        }
        return -2146893056;
      }
      return 534;
    }
    if ( v11 == 33277 )
    {
      result = RsaPublicKeyFromCert(&pCertInfo->SubjectPublicKeyInfo, 0i64, &v21);
      if ( result )
        return result;
      if ( v21 < 0xFFFFFFF0 )
      {
        v12 = (char *)SPExternalAlloc(v21 + 16);
        v13 = (unsigned int *)v12;
        if ( v12 )
        {
          *(_QWORD *)v12 = v12 + 16;
          *((_DWORD *)v12 + 2) = v21;
          v14 = RsaPublicKeyFromCert(p_SubjectPublicKeyInfo, (struct _PUBLICKEYSTRUC *)v12 + 2, (unsigned int *)v12 + 2);
          goto LABEL_11;
        }
        return -2146893056;
      }
      return 534;
    }
    return -2146893052;
  }
  result = DssPublicKeyFromCert(&pCertInfo->SubjectPublicKeyInfo, 0i64, &v21);
  if ( result )
    return result;
  if ( v21 + 16 < v21 )
    return -2146893056;
  v19 = (char *)SPExternalAlloc(v21 + 16);
  v13 = (unsigned int *)v19;
  if ( !v19 )
    return -2146893056;
  *(_QWORD *)v19 = v19 + 16;
  *((_DWORD *)v19 + 2) = v21;
  v14 = DssPublicKeyFromCert(p_SubjectPublicKeyInfo, (struct _PUBLICKEYSTRUC *)v19 + 2, (unsigned int *)v19 + 2);
LABEL_11:
  v15 = v14;
  if ( v14 )
  {
    SPExternalFree(v13);
    return v15;
  }
LABEL_20:
  *a2 = (struct _PUBLICKEY *)v13;
  if ( a3 )
    *a3 = v8;
  return 0;
}

//----- (0000000180014F8C) ----------------------------------------------------
DWORD __fastcall RsaPublicKeyFromCert(
        struct _CERT_PUBLIC_KEY_INFO *a1,
        struct _PUBLICKEYSTRUC *pvStructInfo,
        unsigned int *pcbStructInfo)
{
  if ( CryptDecodeObject(1u, (LPCSTR)0x13, a1->PublicKey.pbData, a1->PublicKey.cbData, 0, pvStructInfo, pcbStructInfo) )
    return 0;
  else
    return GetLastError();
}

//----- (0000000180014FD4) ----------------------------------------------------
__int64 __fastcall MapOidToKeyExch(char *a1)
{
  const struct _OIDPROVMAP near *const *v2; // r8
  __int64 v3; // rax
  char *v4; // rdx
  int v5; // r10d
  int v6; // ecx

  v2 = &g_CertTypes;
  v3 = 0i64;
  do
  {
    v4 = a1;
    do
    {
      v5 = (unsigned __int8)v4[(unsigned __int64)(*v2 - (const struct _OIDPROVMAP near *const)a1)];
      v6 = (unsigned __int8)*v4 - v5;
      if ( v6 )
        break;
      ++v4;
    }
    while ( v5 );
    if ( !v6 )
      return *((unsigned int *)&g_CertTypes + 4 * v3 + 2);
    v3 = (unsigned int)(v3 + 1);
    v2 += 2;
  }
  while ( (unsigned int)v3 < 8 );
  return 0i64;
}
// 18007D750: using guessed type const struct _OIDPROVMAP near *const g_CertTypes;

//----- (0000000180015030) ----------------------------------------------------
__int64 __fastcall EcdsaPublicKeyFromCert(__int64 a1, __int64 a2, _DWORD *a3, unsigned int *a4)
{
  unsigned int v4; // r10d
  __int64 v6; // r8
  int v7; // eax
  _BYTE *v8; // rdx
  int v9; // ebx
  int v10; // edi
  int v11; // ecx
  unsigned int v12; // eax
  unsigned int v13; // ecx

  v4 = 0;
  if ( a2 )
  {
    v6 = *(_QWORD *)(a2 + 40);
    if ( v6 )
    {
      v7 = *(_DWORD *)(a2 + 32);
      if ( v7 )
      {
        if ( a1 )
        {
          v8 = *(_BYTE **)(a1 + 32);
          if ( v8 )
          {
            v9 = *(_DWORD *)(a1 + 24);
            if ( v9 )
            {
              if ( (v7 & 0xFFFFFFFC) >= 0xC )
              {
                v10 = *(_DWORD *)(v6 + 4);
                v11 = (*(_DWORD *)(v6 + 8) >> 3) + ((*(_DWORD *)(v6 + 8) & 7) != 0);
                if ( v11 )
                {
                  v12 = 2 * v11 + 16;
                  if ( a3 )
                  {
                    if ( *a4 >= v12 )
                    {
                      a3[3] = v11;
                      v13 = 2 * v11;
                      *a3 = 518;
                      a3[1] = 8707;
                      a3[2] = v10;
                      if ( v13 + 1 == v9 && ((*v8 - 4) & 0xFC) == 0 && *v8 != 5 )
                      {
                        memcpy_0(a3 + 4, v8 + 1, v13);
                        return 0i64;
                      }
                      return 2148074333i64;
                    }
                    v4 = -2146893023;
                  }
                  *a4 = v12;
                  return v4;
                }
              }
            }
          }
        }
      }
    }
  }
  return 2148074333i64;
}

//----- (0000000180015120) ----------------------------------------------------
__int64 __fastcall GetAlgIdFromEccTypeCertParameters(
        BYTE *pbEncoded,
        DWORD cbEncoded,
        PCCRYPT_OID_INFO *a3,
        _DWORD *a4)
{
  PCCRYPT_OID_INFO OIDInfo; // rax
  __int64 v7; // rdx
  int LastError; // eax
  unsigned int v9; // ebx
  DWORD v11; // [rsp+40h] [rbp-18h] BYREF
  HLOCAL hMem[2]; // [rsp+48h] [rbp-10h] BYREF

  hMem[0] = 0i64;
  v11 = 8;
  if ( !CryptDecodeObjectEx(1u, (LPCSTR)0x49, pbEncoded, cbEncoded, 0x8000u, 0i64, hMem, &v11) )
  {
    LastError = GetLastError();
LABEL_5:
    v9 = LastError;
    goto LABEL_6;
  }
  OIDInfo = CryptFindOIDInfo(1u, *(void **)hMem[0], 3u);
  *a3 = OIDInfo;
  if ( OIDInfo )
  {
    LastError = I_GetSignatureDetailsFromAlgorithmName(*(wchar_t **)&OIDInfo[1].cbSize, v7, a4);
    if ( LastError )
      LastError = -2146893043;
    goto LABEL_5;
  }
  v9 = -2146893043;
LABEL_6:
  if ( hMem[0] )
    LocalFree(hMem[0]);
  return v9;
}
// 1800151AB: variable 'v7' is possibly undefined
// 180015120: using guessed type HLOCAL hMem[2];

//----- (00000001800151F0) ----------------------------------------------------
__int64 __fastcall I_GetKeyExchangeDetailsFromAlgorithmName(wchar_t *String1, __int64 a2, _DWORD *a3)
{
  unsigned int v5; // eax
  __int64 v6; // rbx
  const wchar_t **v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // r8
  __int64 v11; // rcx

  if ( a3 )
    *a3 = 0;
  v5 = g_dwKeyExchangeInfoTotalCount;
  v6 = 0i64;
  if ( !g_dwKeyExchangeInfoTotalCount )
    return 1168i64;
  while ( 1 )
  {
    v7 = (const wchar_t **)g_pKeyExchangeInfo[v6];
    if ( !v7 || !*v7 )
      goto LABEL_8;
    if ( !wcsnicmp(String1, *v7, 0x40ui64) )
      break;
    v5 = g_dwKeyExchangeInfoTotalCount;
LABEL_8:
    v6 = (unsigned int)(v6 + 1);
    if ( (unsigned int)v6 >= v5 )
      return 1168i64;
  }
  v11 = g_pKeyExchangeInfo[v6];
  if ( !v11 )
    return 1168i64;
  return I_GetKeyExchangeDetailsFromKeyExchangeInfo(v11, v8, v9, a3, 0i64);
}
// 180015273: variable 'v8' is possibly undefined
// 180015273: variable 'v9' is possibly undefined
// 1800923B0: using guessed type int g_dwKeyExchangeInfoTotalCount;
// 1800923C0: using guessed type _QWORD g_pKeyExchangeInfo[12];

//----- (000000018001529C) ----------------------------------------------------
__int64 __fastcall I_GetKeyExchangeDetailsFromKeyExchangeInfo(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        _DWORD *a4,
        _DWORD *a5)
{
  if ( a4 )
    *a4 = *(_DWORD *)(a1 + 12);
  if ( a5 )
    *a5 = *(_DWORD *)(a1 + 16);
  return 0i64;
}

//----- (00000001800152C4) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::SetSelectedApplicationProtocol(
        CSsl3TlsClientContext *this,
        unsigned __int8 *const a2,
        unsigned __int16 a3)
{
  __int64 result; // rax
  __int64 v7; // rax
  unsigned __int8 *MatchingApplicationProtocol; // rdi
  _DWORD *v9; // rax

  result = CSsl3TlsContext::ValidateApplicationProtocolList(SecApplicationProtocolNegotiationExt_ALPN, a2, a3, 0);
  if ( !(_DWORD)result )
  {
    v7 = *((_QWORD *)this + 98);
    if ( v7 )
    {
      MatchingApplicationProtocol = CSsl3TlsContext::FindMatchingApplicationProtocol(
                                      (unsigned __int8 *const)(v7 + 6),
                                      *(_WORD *)(v7 + 4),
                                      a2,
                                      a3);
      if ( MatchingApplicationProtocol )
      {
        v9 = (_DWORD *)*((_QWORD *)this + 99);
        if ( v9
          || (v9 = (_DWORD *)(*(__int64 (__fastcall **)(CSsl3TlsClientContext *, __int64))(*(_QWORD *)this + 8i64))(
                               this,
                               264i64),
              (*((_QWORD *)this + 99) = v9) != 0i64) )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_D(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              69i64,
              &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
              *MatchingApplicationProtocol);
            v9 = (_DWORD *)*((_QWORD *)this + 99);
          }
          *v9 = 1;
          *(_DWORD *)(*((_QWORD *)this + 99) + 4i64) = 2;
          *(_BYTE *)(*((_QWORD *)this + 99) + 8i64) = *MatchingApplicationProtocol;
          memcpy_0(
            (void *)(*((_QWORD *)this + 99) + 9i64),
            MatchingApplicationProtocol + 1,
            *MatchingApplicationProtocol);
          return 0i64;
        }
        else
        {
          return 14i64;
        }
      }
      else
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 68i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        return 2148074343i64;
      }
    }
    else
    {
      return 87i64;
    }
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (00000001800153D0) ----------------------------------------------------
unsigned __int8 *__fastcall CSsl3TlsContext::FindMatchingApplicationProtocol(
        unsigned __int8 *const a1,
        unsigned __int16 a2,
        unsigned __int8 *const a3,
        unsigned __int16 a4)
{
  unsigned __int8 *v5; // rbx
  unsigned __int8 *v6; // r14
  unsigned __int8 *v7; // rbp
  unsigned __int8 *v8; // rdi
  __int64 v9; // rcx
  SIZE_T v10; // rax

  v5 = a1;
  if ( !a1 )
    return 0i64;
  if ( !a3 )
    return 0i64;
  v6 = &a1[a2];
  if ( a1 >= v6 )
    return 0i64;
  v7 = &a3[a4];
  while ( 1 )
  {
    v8 = a3;
    if ( a3 < v7 )
      break;
LABEL_11:
    v5 += *v5 + 1;
    if ( v5 >= v6 )
      return 0i64;
  }
  LOBYTE(v9) = *v5;
  while ( 1 )
  {
    if ( (_BYTE)v9 == *v8 )
    {
      v10 = RtlCompareMemory(v5 + 1, v8 + 1, (unsigned __int8)v9);
      v9 = *v5;
      if ( v10 == v9 )
        return v5;
    }
    v8 += *v8 + 1;
    if ( v8 >= v7 )
      goto LABEL_11;
  }
}

//----- (0000000180015484) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::ValidateApplicationProtocolList(
        enum _SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT a1,
        unsigned __int8 *const a2,
        unsigned __int16 a3,
        int a4)
{
  unsigned __int8 *v4; // rcx
  unsigned __int8 *v5; // rdx
  CCipherMill *v7; // rcx
  __int64 v8; // rdx

  if ( !a2 || a1 != SecApplicationProtocolNegotiationExt_ALPN )
    return 87i64;
  if ( (unsigned __int16)(a3 - 2) > 0xFFFBu )
  {
    v7 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v8 = 74i64;
  }
  else if ( a4 || (unsigned int)*a2 + 1 >= a3 )
  {
    v4 = &a2[a3];
    while ( 1 )
    {
      if ( a2 >= v4 )
        return 0i64;
      if ( !*a2 )
        break;
      v5 = &a2[*a2];
      if ( v5 >= v4 )
        break;
      a2 = v5 + 1;
    }
    v7 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v8 = 76i64;
  }
  else
  {
    v7 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v8 = 75i64;
  }
  WPP_SF_(*((_QWORD *)v7 + 2), v8, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
  return 2148074278i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180015504) ----------------------------------------------------
__int64 __fastcall I_GetSignatureDetailsFromAlgorithmName(wchar_t *String1, __int64 a2, _DWORD *a3)
{
  unsigned int v5; // eax
  __int64 v6; // rbx
  const wchar_t **v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // r8
  _DWORD *v11; // rcx

  if ( a3 )
    *a3 = 0;
  v5 = g_dwSignatureInfoTotalCount;
  v6 = 0i64;
  if ( !g_dwSignatureInfoTotalCount )
    return 1168i64;
  while ( 1 )
  {
    v7 = (const wchar_t **)g_pSignatureInfo[v6];
    if ( !v7 || !*v7 )
      goto LABEL_8;
    if ( !wcsnicmp(String1, *v7, 0x40ui64) )
      break;
    v5 = g_dwSignatureInfoTotalCount;
LABEL_8:
    v6 = (unsigned int)(v6 + 1);
    if ( (unsigned int)v6 >= v5 )
      return 1168i64;
  }
  v11 = (_DWORD *)g_pSignatureInfo[v6];
  if ( !v11 )
    return 1168i64;
  return I_GetSignatureDetailsFromSignatureInfo(v11, v8, v9, a3, 0i64, 0i64);
}
// 18001558D: variable 'v8' is possibly undefined
// 18001558D: variable 'v9' is possibly undefined
// 180092218: using guessed type int g_dwSignatureInfoTotalCount;
// 180092220: using guessed type _QWORD g_pSignatureInfo[16];

//----- (00000001800155B4) ----------------------------------------------------
__int64 __fastcall I_GetSignatureDetailsFromSignatureInfo(
        _DWORD *a1,
        __int64 a2,
        __int64 a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6)
{
  if ( a4 )
    *a4 = a1[3];
  if ( a5 )
    *a5 = a1[4];
  if ( a6 )
    *a6 = a1[5];
  return 0i64;
}

//----- (00000001800155EC) ----------------------------------------------------
__int64 TlsInitializeDefaultAlgorithms()
{
  _QWORD *v0; // rax
  __int64 v1; // rdx
  char *v2; // rcx
  _QWORD *v3; // rax
  char *v4; // rcx
  __int64 v5; // rdx
  wchar_t ***v6; // rax
  wchar_t **v7; // rcx
  __int64 v8; // rdx
  __int16 ***v9; // rax
  __int16 **v10; // rcx
  __int64 v11; // rdx

  v0 = g_pHashInfo;
  v1 = 7i64;
  v2 = (char *)&unk_18007D340;
  do
  {
    *v0 = v2;
    v2 += 24;
    ++v0;
    --v1;
  }
  while ( v1 );
  g_dwHashInfoTotalCount = 7;
  v3 = &g_pSignatureInfo;
  v4 = (char *)&unk_18007D290;
  v5 = 7i64;
  do
  {
    *v3 = v4;
    v4 += 24;
    ++v3;
    --v5;
  }
  while ( v5 );
  g_dwSignatureInfoTotalCount = 7;
  v6 = (wchar_t ***)&g_pKeyExchangeInfo;
  v7 = &off_18007D1E0;
  v8 = 7i64;
  do
  {
    *v6 = v7;
    v7 += 3;
    ++v6;
    --v8;
  }
  while ( v8 );
  g_dwKeyExchangeInfoTotalCount = 7;
  v9 = (__int16 ***)&g_pCipherInfo;
  v10 = &off_18007D100;
  v11 = 7i64;
  do
  {
    *v9 = v10;
    v10 += 4;
    ++v9;
    --v11;
  }
  while ( v11 );
  g_dwCipherInfoTotalCount = 7;
  return 0i64;
}
// 18007D100: using guessed type __int16 *off_18007D100;
// 18007D1E0: using guessed type wchar_t *off_18007D1E0;
// 180092218: using guessed type int g_dwSignatureInfoTotalCount;
// 180092320: using guessed type int g_dwCipherInfoTotalCount;
// 180092324: using guessed type int g_dwHashInfoTotalCount;
// 180092330: using guessed type _QWORD g_pHashInfo[16];
// 1800923B0: using guessed type int g_dwKeyExchangeInfoTotalCount;

//----- (00000001800156A0) ----------------------------------------------------
__int64 __fastcall CopyUnicodeString(char a1, struct _UNICODE_STRING *a2, struct _UNICODE_STRING *a3)
{
  unsigned int v5; // edi
  unsigned __int64 v6; // rax
  WCHAR *v7; // rax
  unsigned int Length; // edx
  PWSTR Buffer; // rcx
  __int128 v11; // [rsp+30h] [rbp-18h] BYREF

  v5 = 0;
  v11 = 0i64;
  if ( a2 && a3 )
  {
    if ( a1 )
    {
      v5 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int128 *, struct _UNICODE_STRING *))(LsaTable + 80))(
             0i64,
             16i64,
             &v11,
             a2);
      if ( v5 )
        goto LABEL_25;
    }
    else
    {
      v11 = (__int128)*a2;
    }
    v6 = (unsigned __int64)v11 >> 16;
    if ( WORD1(v11)
      && (_WORD)v11
      && *((_QWORD *)&v11 + 1)
      && (v11 & 1) == 0
      && (BYTE2(v11) & 1) == 0
      && (unsigned __int16)v11 <= WORD1(v11)
      && WORD1(v11) != 0xFFFF )
    {
      a3->Length = v11;
      a3->MaximumLength = v6;
      v7 = (WCHAR *)SPExternalAlloc((unsigned __int16)v6);
      a3->Buffer = v7;
      if ( !v7 )
      {
        v5 = -2146893056;
LABEL_25:
        Buffer = a3->Buffer;
        if ( Buffer )
        {
          SPExternalFree(Buffer);
          a3->Buffer = 0i64;
        }
        *(_DWORD *)&a3->Length = 0;
        return v5;
      }
      if ( a1 )
      {
        v5 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, WCHAR *, _QWORD))(LsaTable + 80))(
               0i64,
               WORD1(v11),
               v7,
               *((_QWORD *)&v11 + 1));
        if ( v5 )
          goto LABEL_25;
      }
      else
      {
        memcpy_0(v7, *((const void **)&v11 + 1), a3->MaximumLength);
      }
      Length = a3->Length;
      if ( a3->Buffer[((unsigned __int64)a3->Length >> 1) - 1] )
        return v5;
      if ( Length > 2 )
      {
        a3->Length = Length - 2;
        return v5;
      }
    }
    v5 = -2146892963;
    goto LABEL_25;
  }
  return 2148074333i64;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180015828) ----------------------------------------------------
unsigned __int8 __fastcall CTlsSignatureSuiteList::IsSupportedSignatureSuiteList(
        CTlsSignatureSuiteList *this,
        struct CTlsSignatureSuiteList *a2)
{
  int v2; // eax
  int v3; // r8d
  unsigned __int16 v4; // cx
  unsigned __int16 v5; // dx
  unsigned __int16 v6; // cx
  unsigned __int16 v7; // dx
  unsigned __int16 v8; // cx

  v2 = 0;
  if ( a2 )
  {
    if ( *(_WORD *)a2 )
    {
      v3 = *((unsigned __int16 *)a2 + 17);
      if ( (_WORD)v3 )
      {
        v4 = *((_WORD *)this + 17);
        v5 = CTlsSignatureSuiteList::RsaSha256Flags;
        if ( (CTlsSignatureSuiteList::RsaSha256Flags & v4) == 0 )
          v5 = 0;
        v6 = v5 | v4;
        v7 = CTlsSignatureSuiteList::RsaSha384Flags;
        if ( (CTlsSignatureSuiteList::RsaSha384Flags & v6) == 0 )
          v7 = 0;
        v8 = v7 | v6;
        if ( (CTlsSignatureSuiteList::RsaSha512Flags & v8) != 0 )
          v2 = CTlsSignatureSuiteList::RsaSha512Flags;
        LOBYTE(v2) = (~(v2 | v8) & v3) == 0;
      }
    }
  }
  return v2;
}
// 180092800: using guessed type unsigned __int16 CTlsSignatureSuiteList::RsaSha512Flags;
// 180092804: using guessed type unsigned __int16 CTlsSignatureSuiteList::RsaSha384Flags;
// 180092808: using guessed type unsigned __int16 CTlsSignatureSuiteList::RsaSha256Flags;

//----- (000000018001588C) ----------------------------------------------------
__int64 __fastcall IsCertKeyUsageCompliant(int a1, int a2, const struct _CERT_CONTEXT *a3)
{
  unsigned int v3; // ebx
  int v4; // edi
  struct _CERT_INFO *pCertInfo; // rdx
  int pbKeyUsage; // [rsp+50h] [rbp+18h] BYREF

  v3 = 0;
  if ( !a3 )
    return 0i64;
  if ( a2 != 9216 )
    return 1i64;
  if ( a1 == 44550 )
    goto LABEL_4;
  if ( a1 != 41984 )
  {
    if ( a1 != 43522 )
      return 1i64;
LABEL_4:
    v4 = 128;
    goto LABEL_5;
  }
  v4 = 32;
LABEL_5:
  pCertInfo = a3->pCertInfo;
  pbKeyUsage = 0;
  if ( !CertGetIntendedKeyUsage(0x10001u, pCertInfo, (BYTE *)&pbKeyUsage, 4u) )
    return 1i64;
  LOBYTE(v3) = (pbKeyUsage & v4) != 0;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x14u,
      (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
      pbKeyUsage,
      v4);
  return v3;
}

//----- (0000000180015930) ----------------------------------------------------
void __fastcall CSessionCacheClientItem::CompleteCacheAdd(
        CSessionCacheClientItem *this,
        struct CSessionCacheManager *a2,
        struct CSslContext *a3,
        char a4)
{
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rax

  v6 = *((_QWORD *)this + 48);
  *(_QWORD *)((char *)this + 188) = *(_QWORD *)(*((_QWORD *)a3 + 10) + 760i64);
  if ( v6 )
  {
    *(_BYTE *)(v6 + 236) = 0;
    CSessionCacheTable::DereferenceCacheItemInternal(
      *(CSessionCacheTable **)(*((_QWORD *)this + 48) + 224i64),
      *((struct CSessionCacheItem **)this + 48),
      1,
      a4);
    *((_QWORD *)this + 48) = 0i64;
  }
  v7 = *((_QWORD *)a3 + 1);
  *((_QWORD *)this + 22) = v7;
  *((_DWORD *)this + 46) = *((_DWORD *)a3 + 4);
  v8 = *(_QWORD *)(v7 + 848);
  if ( v8 )
    _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v8 + 16) + 12i64));
  _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v7 + 856) + 12i64));
}

//----- (00000001800159D0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::GetPeerCertValidationResults(
        CSsl3TlsClientContext *this,
        int *a2,
        unsigned int *a3)
{
  __int64 v3; // rcx

  if ( !a2 || !a3 )
    return 87i64;
  v3 = *((_QWORD *)this + 11);
  *a2 = *(_DWORD *)(v3 + 216);
  *a3 = *(_DWORD *)(v3 + 220);
  return 0i64;
}

//----- (0000000180015A10) ----------------------------------------------------
__int64 __fastcall SpInstanceInit(__int64 a1, __int64 a2)
{
  unsigned int v3; // ebx
  unsigned int *v4; // rdi
  __int64 result; // rax

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
  v3 = 0;
  v4 = (unsigned int *)&g_SchannelCallbacks;
  do
  {
    result = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(a2 + 16))(*v4, *((_QWORD *)v4 + 1));
    if ( (_DWORD)result )
      break;
    ++v3;
    v4 += 4;
  }
  while ( v3 < 0xA );
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180015A90) ----------------------------------------------------
__int64 __fastcall SpMarshallSupplementalCreds(__int64 a1, unsigned __int8 *a2, unsigned int *a3, char **a4)
{
  if ( a2 && *(_DWORD *)a2 >= 3u )
  {
    if ( *(_DWORD *)a2 <= 4u )
      return SpMarshallSupplementalCredsV4(a1, a2, a3, a4);
    if ( *(_DWORD *)a2 == 5 )
      return SpMarshallSupplementalCredsV5(a1, a2, a3, (void **)a4);
  }
  return 3221225485i64;
}

//----- (0000000180015AD0) ----------------------------------------------------
__int64 __fastcall SpMarshallSupplementalCredsV5(__int64 a1, unsigned __int8 *a2, unsigned int *a3, void **a4)
{
  void **v4; // rax
  unsigned __int8 *v5; // rsi
  unsigned int v6; // edi
  CCipherMill *v7; // rcx
  SIZE_T v8; // r14
  __int64 v9; // rbp
  __int64 v10; // r15
  unsigned int v11; // r12d
  __int64 v12; // r8
  __int64 v13; // r11
  __int64 v14; // r13
  unsigned int v15; // ebx
  __int64 v16; // rcx
  unsigned __int16 v17; // dx
  __int64 v18; // r10
  _OWORD *v19; // rax
  _QWORD *v20; // rbp
  char *v21; // rbx
  __int64 v22; // rcx
  char *v23; // r15
  unsigned int v24; // r14d
  __int64 v25; // r13
  __int64 v26; // rbx
  __int64 v27; // r12
  __int64 v28; // rcx
  unsigned int v29; // esi
  __int64 v30; // rbp
  __int64 v31; // rbx
  __int64 v32; // r14
  __int64 v34; // r9
  unsigned int v35; // r11d
  __int64 v36; // rcx
  __int64 v37; // r8
  unsigned int v38; // r9d
  __int64 v39; // rcx
  unsigned int v40; // esi
  __int64 v41; // r14
  __int64 v42; // rbx
  unsigned int v43; // r14d
  __int64 v44; // rbp
  __int64 v45; // rbx
  int v46; // [rsp+28h] [rbp-80h]
  __int64 v47; // [rsp+30h] [rbp-78h]
  __int64 v48; // [rsp+38h] [rbp-70h]
  __int64 v49; // [rsp+40h] [rbp-68h]
  __int64 v50; // [rsp+48h] [rbp-60h]
  _OWORD *v51; // [rsp+50h] [rbp-58h]
  int v52; // [rsp+B0h] [rbp+8h]
  unsigned int *v54; // [rsp+C0h] [rbp+18h]

  v54 = a3;
  v4 = a4;
  v5 = a2;
  v6 = 0;
  v7 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 30i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
    v7 = WPP_GLOBAL_Control;
    v4 = a4;
    a3 = v54;
  }
  if ( v5 && v4 && a3 )
  {
    v8 = 72i64;
    v46 = 72;
    if ( *((_DWORD *)v5 + 2) )
    {
      v8 = 8i64 * *((unsigned int *)v5 + 2) + 72;
      v46 = 8 * *((_DWORD *)v5 + 2) + 72;
    }
    if ( *((_DWORD *)v5 + 8) )
    {
      v8 += 8i64 * *((unsigned int *)v5 + 8);
      v46 = v8;
    }
    v9 = *((unsigned int *)v5 + 14);
    if ( !(_DWORD)v9 )
    {
LABEL_28:
      v19 = LocalAlloc(0x40u, v8);
      v51 = v19;
      v20 = v19;
      if ( v19 )
      {
        v21 = (char *)v19 + 72;
        *v19 = *(_OWORD *)v5;
        v19[1] = *((_OWORD *)v5 + 1);
        v19[2] = *((_OWORD *)v5 + 2);
        v19[3] = *((_OWORD *)v5 + 3);
        *((_QWORD *)v19 + 8) = *((_QWORD *)v5 + 8);
        if ( *((_DWORD *)v5 + 2) )
        {
          memcpy_0((char *)v19 + 72, *((const void **)v5 + 2), 8i64 * *((unsigned int *)v5 + 2));
          v20[2] = v21;
          *((_DWORD *)v20 + 2) = *((_DWORD *)v5 + 2);
          v21 += 8 * *((unsigned int *)v5 + 2);
        }
        if ( *((_DWORD *)v5 + 8) )
        {
          memcpy_0(v21, *((const void **)v5 + 5), 8i64 * *((unsigned int *)v5 + 8));
          v20[5] = v21;
          *((_DWORD *)v20 + 8) = *((_DWORD *)v5 + 8);
          v21 += 8 * *((unsigned int *)v5 + 8);
        }
        if ( *((_DWORD *)v5 + 14) )
        {
          memcpy_0(v21, *((const void **)v5 + 8), 40i64 * *((unsigned int *)v5 + 14));
          v20[8] = v21;
          v22 = *((unsigned int *)v5 + 14);
          v52 = 0;
          v23 = &v21[40 * v22];
          if ( (_DWORD)v22 )
          {
            v24 = 0;
            do
            {
              v25 = *((_QWORD *)v5 + 8);
              v26 = v20[8];
              v50 = v25;
              v47 = v26;
              v27 = 5i64 * v24;
              if ( *(_DWORD *)(v25 + 40i64 * v24) )
              {
                memcpy_0(v23, *(const void **)(v25 + 40i64 * v24 + 8), 16i64 * *(unsigned int *)(v25 + 40i64 * v24));
                *(_QWORD *)(v26 + 40i64 * v24 + 8) = v23;
                v23 += 16 * *(unsigned int *)(v25 + 40i64 * v24);
                if ( *(_DWORD *)(v25 + 40i64 * v24) )
                {
                  v40 = 0;
                  v41 = v26;
                  do
                  {
                    v42 = 2i64 * v40;
                    memcpy_0(
                      v23,
                      *(const void **)(*(_QWORD *)(v25 + 8 * v27 + 8) + 16i64 * v40 + 8),
                      *(unsigned __int16 *)(*(_QWORD *)(v25 + 8 * v27 + 8) + 16i64 * v40 + 2));
                    ++v40;
                    *(_QWORD *)(*(_QWORD *)(v41 + 8 * v27 + 8) + 8 * v42 + 8) = v23;
                    v23 += *(unsigned __int16 *)(*(_QWORD *)(v25 + 8 * v27 + 8) + 8 * v42 + 2);
                  }
                  while ( v40 < *(_DWORD *)(v25 + 8 * v27) );
                  v5 = a2;
                  v24 = v52;
                  v26 = v47;
                }
              }
              if ( *(_DWORD *)(v25 + 8 * v27 + 20) )
              {
                memcpy_0(v23, *(const void **)(v25 + 8 * v27 + 24), 48i64 * *(unsigned int *)(v25 + 8 * v27 + 20));
                *(_QWORD *)(v26 + 8 * v27 + 24) = v23;
                v28 = *(unsigned int *)(v25 + 8 * v27 + 20);
                v23 += 48 * v28;
                if ( (_DWORD)v28 )
                {
                  v29 = 0;
                  do
                  {
                    v30 = *(_QWORD *)(v25 + 8 * v27 + 24);
                    v48 = v30;
                    v31 = 48i64 * v29;
                    v32 = *(_QWORD *)(v47 + 8 * v27 + 24);
                    v49 = v32;
                    memcpy_0(v23, *(const void **)(v31 + v30 + 16), *(unsigned __int16 *)(v31 + v30 + 10));
                    *(_QWORD *)(v31 + v32 + 16) = v23;
                    v23 += *(unsigned __int16 *)(v31 + v30 + 10);
                    if ( *(_DWORD *)(v31 + v30 + 24) )
                    {
                      memcpy_0(v23, *(const void **)(v31 + v30 + 32), 16i64 * *(unsigned int *)(v31 + v30 + 24));
                      *(_QWORD *)(v31 + v32 + 32) = v23;
                      v43 = 0;
                      v23 += 16 * *(unsigned int *)(v31 + v30 + 24);
                      if ( *(_DWORD *)(v31 + v30 + 24) )
                      {
                        v44 = 48i64 * v29;
                        do
                        {
                          v45 = 2i64 * v43;
                          memcpy_0(
                            v23,
                            *(const void **)(*(_QWORD *)(v48 + v44 + 32) + 16i64 * v43 + 8),
                            *(unsigned __int16 *)(*(_QWORD *)(v48 + v44 + 32) + 16i64 * v43 + 2));
                          ++v43;
                          *(_QWORD *)(*(_QWORD *)(v49 + v44 + 32) + 8 * v45 + 8) = v23;
                          v23 += *(unsigned __int16 *)(*(_QWORD *)(v48 + v44 + 32) + 8 * v45 + 2);
                        }
                        while ( v43 < *(_DWORD *)(v48 + v44 + 24) );
                        v25 = v50;
                        v6 = 0;
                      }
                    }
                    ++v29;
                  }
                  while ( v29 < *(_DWORD *)(v25 + 8 * v27 + 20) );
                  v5 = a2;
                  v20 = v51;
                  v24 = v52;
                }
              }
              v52 = ++v24;
            }
            while ( v24 < *((_DWORD *)v5 + 14) );
            LODWORD(v8) = v46;
          }
        }
        *((_DWORD *)v20 + 12) = *((_DWORD *)v5 + 12);
        *((_DWORD *)v20 + 13) = *((_DWORD *)v5 + 13);
        *((_DWORD *)v20 + 1) = *((_DWORD *)v5 + 1);
        *v54 = v8;
        *a4 = v20;
      }
      else
      {
        v6 = -1073741801;
      }
      v7 = WPP_GLOBAL_Control;
      goto LABEL_47;
    }
    if ( (unsigned int)v9 > 0x10 )
      return 3221225485i64;
    v10 = *((_QWORD *)v5 + 8);
    if ( v10 )
    {
      v11 = 0;
      v8 += 40 * v9;
      v46 = v8;
      while ( 1 )
      {
        v12 = *(unsigned int *)(v10 + 40i64 * v11);
        if ( (_DWORD)v12 )
          break;
LABEL_16:
        v13 = *(unsigned int *)(v10 + 40i64 * v11 + 20);
        if ( (_DWORD)v13 )
        {
          if ( (unsigned int)v13 <= 0x10 )
          {
            v14 = *(_QWORD *)(v10 + 40i64 * v11 + 24);
            if ( v14 )
            {
              v15 = 0;
              v8 += 48 * v13;
              while ( 1 )
              {
                v16 = v14 + 48i64 * v15;
                if ( !*(_WORD *)(v16 + 10) )
                  break;
                v17 = *(_WORD *)(v16 + 10);
                if ( ((*(_WORD *)(v16 + 8) | v17) & 1) != 0
                  || *(_WORD *)(v16 + 8) > v17
                  || v17 == 0xFFFF
                  || !*(_QWORD *)(v16 + 16) && (*(_WORD *)(v16 + 8) || v17) )
                {
                  break;
                }
                v18 = *(unsigned int *)(v16 + 24);
                v8 += *(unsigned __int16 *)(v16 + 10);
                v46 = v8;
                if ( (_DWORD)v18 )
                {
                  if ( (unsigned int)v18 <= 0x10 )
                  {
                    v37 = *(_QWORD *)(v16 + 32);
                    if ( v37 )
                    {
                      v38 = 0;
                      v8 += 16 * v18;
                      while ( 1 )
                      {
                        v39 = *(unsigned __int16 *)(v37 + 16i64 * v38 + 2);
                        if ( !(_WORD)v39
                          || (((unsigned __int16)v39 | *(_WORD *)(v37 + 16i64 * v38)) & 1) != 0
                          || *(_WORD *)(v37 + 16i64 * v38) > (unsigned __int16)v39
                          || (_WORD)v39 == 0xFFFF
                          || !*(_QWORD *)(v37 + 16i64 * v38 + 8) )
                        {
                          break;
                        }
                        v8 += v39;
                        ++v38;
                        v46 = v8;
                        if ( v38 >= (unsigned int)v18 )
                          goto LABEL_26;
                      }
                    }
                  }
                  return 3221225485i64;
                }
LABEL_26:
                if ( ++v15 >= (unsigned int)v13 )
                  goto LABEL_27;
              }
            }
          }
          return 3221225485i64;
        }
LABEL_27:
        if ( ++v11 >= (unsigned int)v9 )
          goto LABEL_28;
      }
      if ( (unsigned int)v12 <= 0x10 )
      {
        v34 = *(_QWORD *)(v10 + 40i64 * v11 + 8);
        if ( v34 )
        {
          v35 = 0;
          v8 += 16 * v12;
          while ( 1 )
          {
            v36 = *(unsigned __int16 *)(v34 + 16i64 * v35 + 2);
            if ( !(_WORD)v36
              || (((unsigned __int16)v36 | *(_WORD *)(v34 + 16i64 * v35)) & 1) != 0
              || *(_WORD *)(v34 + 16i64 * v35) > (unsigned __int16)v36
              || (_WORD)v36 == 0xFFFF
              || !*(_QWORD *)(v34 + 16i64 * v35 + 8) )
            {
              break;
            }
            v8 += v36;
            ++v35;
            v46 = v8;
            if ( v35 >= (unsigned int)v12 )
              goto LABEL_16;
          }
        }
      }
      return 3221225485i64;
    }
  }
  v6 = -1073741811;
LABEL_47:
  if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v7 + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)v7 + 2), 31i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, v6);
  return v6;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180015E38) ----------------------------------------------------
__int64 __fastcall CTlsExt::BuildTBExtension(
        CTlsExt *this,
        char a2,
        char a3,
        unsigned __int8 *const a4,
        unsigned __int8 a5,
        unsigned __int8 *const a6,
        unsigned __int8 **a7)
{
  __int64 v8; // rdi
  unsigned __int16 v9; // dx
  char *v10; // rdi

  if ( !a4 )
    return 87i64;
  if ( !a5 )
    return 87i64;
  if ( !a7 )
    return 87i64;
  v8 = (__int64)*a7;
  if ( !*a7 )
    return 87i64;
  v9 = a5 + 3;
  if ( (unsigned __int64)v9 + v8 + 4 > (unsigned __int64)a6 )
    return 87i64;
  *(_WORD *)v8 = 6144;
  *(_BYTE *)(v8 + 3) = v9;
  *(_BYTE *)(v8 + 5) = a3;
  *(_BYTE *)(v8 + 2) = HIBYTE(v9);
  *(_BYTE *)(v8 + 4) = a2;
  *(_BYTE *)(v8 + 6) = a5;
  v10 = (char *)(v8 + 7);
  memcpy_0(v10, a4, a5);
  *a7 = (unsigned __int8 *)&v10[a5];
  return 0i64;
}

//----- (0000000180015EE0) ----------------------------------------------------
__int64 __fastcall SpSetContextAttributes(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4)
{
  CCipherMill *v8; // rcx
  _QWORD *v9; // rdi
  __int64 v10; // rbx
  unsigned int v11; // eax

  v8 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 25i64, &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids);
      v8 = WPP_GLOBAL_Control;
    }
    if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v8 + 28) & 4) != 0 )
      {
        WPP_SF_q(*((_QWORD *)v8 + 2), 0x1Au, (__int64)&WPP_dd5b111c8476393ce65badbe3d423765_Traceguids, a1);
        v8 = WPP_GLOBAL_Control;
      }
      if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
      {
        WPP_SF_d(*((_QWORD *)v8 + 2), 0x1Bu, (__int64)&WPP_dd5b111c8476393ce65badbe3d423765_Traceguids, a2);
        v8 = WPP_GLOBAL_Control;
      }
    }
  }
  v9 = *(_QWORD **)(a1 + 8);
  v10 = v9[10];
  if ( v10 && v8 != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)v8 + 28) & 4) != 0 )
    {
      WPP_SF_D(
        *((_QWORD *)v8 + 2),
        28i64,
        &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids,
        *(unsigned int *)(v10 + 212));
      v8 = WPP_GLOBAL_Control;
    }
    if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
      WPP_SF_S(
        *((_QWORD *)v8 + 2),
        0x1Du,
        (__int64)&WPP_dd5b111c8476393ce65badbe3d423765_Traceguids,
        (const wchar_t *)(v10 + 216));
  }
  v11 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD, __int64, _QWORD))(*v9 + 208i64))(v9, a2, a3, a4);
  return TranslateToSecurityStatus(v11);
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180015FC8) ----------------------------------------------------
char GetExternalSchannelAlgorithms()
{
  BOOL v0; // ebx
  char result; // al
  int v2; // [rsp+30h] [rbp+8h] BYREF
  HANDLE KeyHandle; // [rsp+38h] [rbp+10h] BYREF

  v0 = 0;
  KeyHandle = 0i64;
  v2 = 0;
  if ( TlsOpenRegKey(
         L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Cryptography\\Providers\\Microsoft SSL Protocol Provider",
         0i64,
         &KeyHandle) >= 0
    && GetSslDWordFromRegistry(KeyHandle, L"EnableTlsExternalAlgorithms", &v2) >= 0 )
  {
    v0 = v2 == 1;
  }
  result = TlsCloseRegKey(&KeyHandle);
  dword_1800921B0 = v0;
  if ( v0 )
  {
    GetExternalHashAlgorithms();
    GetExternalSignatureAlgorithms();
    GetExternalKeyExchangeAlgorithms();
    return GetExternalCipherAlgorithms();
  }
  return result;
}
// 180082408: using guessed type wchar_t aEnabletlsexter[28];
// 1800921B0: using guessed type int dword_1800921B0;

//----- (0000000180016034) ----------------------------------------------------
NTSTATUS __fastcall TlsCloseRegKey(void **a1)
{
  void *v2; // rcx
  NTSTATUS result; // eax

  v2 = *a1;
  if ( v2 )
  {
    result = NtClose(v2);
    *a1 = 0i64;
  }
  return result;
}

//----- (0000000180016064) ----------------------------------------------------
NTSTATUS __fastcall GetSslDWordFromRegistry(HANDLE KeyHandle, const WCHAR *a2, _DWORD *a3)
{
  NTSTATUS result; // eax
  ULONG ResultLength; // [rsp+30h] [rbp-48h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+38h] [rbp-40h] BYREF
  __int128 KeyValueInformation; // [rsp+48h] [rbp-30h] BYREF
  int v9; // [rsp+58h] [rbp-20h]

  ResultLength = 0;
  DestinationString = 0i64;
  v9 = 0;
  KeyValueInformation = 0i64;
  RtlInitUnicodeString(&DestinationString, a2);
  result = NtQueryValueKey(
             KeyHandle,
             &DestinationString,
             KeyValuePartialInformation,
             &KeyValueInformation,
             0x14u,
             &ResultLength);
  if ( result >= 0 )
  {
    if ( DWORD1(KeyValueInformation) == 4 )
      *a3 = HIDWORD(KeyValueInformation);
    else
      return -1073739509;
  }
  return result;
}

//----- (000000018001610C) ----------------------------------------------------
NTSTATUS __fastcall TlsOpenRegKey(PCWSTR Source, PCWSTR a2, PHANDLE KeyHandle)
{
  struct _UNICODE_STRING *v6; // rbx
  NTSTATUS result; // eax
  __int64 v8; // rax
  __int64 v9; // rcx
  struct _UNICODE_STRING *Heap; // rax
  struct _UNICODE_STRING *P; // [rsp+20h] [rbp-68h]
  struct _UNICODE_STRING v12; // [rsp+28h] [rbp-60h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+38h] [rbp-50h] BYREF
  unsigned int v14; // [rsp+A8h] [rbp+20h]
  NTSTATUS v15; // [rsp+A8h] [rbp+20h]

  v12 = 0i64;
  v6 = 0i64;
  P = 0i64;
  memset(&ObjectAttributes, 0, sizeof(ObjectAttributes));
  if ( !a2 )
  {
    RtlInitUnicodeString(&v12, Source);
    ObjectAttributes.Length = 48;
    ObjectAttributes.RootDirectory = 0i64;
    ObjectAttributes.Attributes = 576;
    ObjectAttributes.ObjectName = &v12;
LABEL_3:
    *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0i64;
    result = NtOpenKey(KeyHandle, 0x20019u, &ObjectAttributes);
    goto LABEL_10;
  }
  v8 = -1i64;
  v9 = -1i64;
  do
    ++v9;
  while ( Source[v9] );
  do
    ++v8;
  while ( a2[v8] );
  v14 = 2 * (v8 + v9) + 4;
  Heap = (struct _UNICODE_STRING *)RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, 0, v14 + 16i64);
  v6 = Heap;
  P = Heap;
  if ( Heap )
  {
    Heap->Length = 0;
    Heap->MaximumLength = v14;
    Heap->Buffer = &Heap[1].Length;
    RtlAppendUnicodeToString(Heap, Source);
    RtlAppendUnicodeToString(v6, L"\\");
    RtlAppendUnicodeToString(v6, a2);
    ObjectAttributes.Length = 48;
    ObjectAttributes.RootDirectory = 0i64;
    ObjectAttributes.Attributes = 576;
    ObjectAttributes.ObjectName = v6;
    goto LABEL_3;
  }
  result = -1073741801;
LABEL_10:
  v15 = result;
  if ( v6 )
  {
    RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, P);
    return v15;
  }
  return result;
}

//----- (00000001800162B0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::Initialize(CSsl3TlsClientContext *this)
{
  __int64 v2; // rax
  __int64 v3; // r8
  _QWORD *v5; // rax
  _QWORD *v6; // rdx
  _QWORD *v7; // rcx
  _QWORD *v8; // rax
  _QWORD *v9; // rax
  DTlsMsgMgr *v10; // rcx

  if ( !*((_BYTE *)this + 233) )
    goto LABEL_2;
  v5 = operator new(0x60ui64);
  v6 = v5;
  if ( v5 )
  {
    *v5 = 0i64;
    v5[4] = v5 + 3;
    v5[3] = v5 + 3;
    v5[6] = v5 + 5;
    v5[5] = v5 + 5;
    v7 = v5 + 7;
    *((_DWORD *)v5 + 2) = 10;
    v8 = v5 + 9;
    v7[1] = v7;
    *v7 = v7;
    v6[11] = this;
    v8[1] = v8;
    *v8 = v8;
  }
  else
  {
    v6 = 0i64;
  }
  *((_QWORD *)this + 72) = v6;
  if ( !v6 )
    return 14i64;
  v9 = operator new(0x30ui64);
  if ( v9 )
  {
    *v9 = *((_QWORD *)this + 72);
    v9[1] = 0i64;
    v9[2] = 0i64;
    v9[3] = 0i64;
    *((_DWORD *)v9 + 8) = 0;
    v9[5] = this;
    *((_DWORD *)v9 + 9) = *((__int16 *)this + 96);
  }
  else
  {
    v9 = 0i64;
  }
  v10 = (DTlsMsgMgr *)*((_QWORD *)this + 72);
  *((_QWORD *)this + 73) = v9;
  if ( !v9 )
  {
    if ( v10 )
      DTlsMsgMgr::`scalar deleting destructor'(v10);
    return 14i64;
  }
  *((_QWORD *)this + 28) = v10;
LABEL_2:
  v2 = *((_QWORD *)this + 15);
  v3 = *((_QWORD *)this + 166);
  if ( v2 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
  {
    *(_WORD *)(v2 + 152) = 0;
    if ( v3 )
      o_wcsncpy_s_0(v2 + 152, 256i64, v3, -1i64);
  }
  return 0i64;
}
// 180028D84: using guessed type __int64 __fastcall o_wcsncpy_s_0(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180016320) ----------------------------------------------------
bool __fastcall CSessionCacheClientItem::IsEntryAMatch(
        CSessionCacheClientItem *this,
        struct _LUID *a2,
        char *a3,
        struct CRED_THUMBPRINT *a4,
        unsigned int a5)
{
  struct _LUID *v5; // r11
  CSessionCacheClientItem *v6; // r10

  v5 = a2;
  v6 = this;
  return (*((_DWORD *)this + 42) & a5) != 0
      && *(_DWORD *)a4 == *((_DWORD *)this + 47)
      && *((_DWORD *)a4 + 1) == *((_DWORD *)this + 48)
      && (!a3 || CSessionCacheClientItem::IsSameTargetName(this, a3))
      && (!v5 || *((_DWORD *)v6 + 94) == v5->LowPart && *((_DWORD *)v6 + 95) == v5->HighPart);
}
// 180016361: variable 'v5' is possibly undefined
// 180016366: variable 'v6' is possibly undefined

//----- (0000000180016390) ----------------------------------------------------
bool __fastcall CSessionCacheClientItem::IsSameTargetName(CSessionCacheClientItem *this, char *a2)
{
  const unsigned __int16 *v2; // rax
  char *v3; // rdx
  int v4; // r8d
  int v5; // ecx

  v2 = (const unsigned __int16 *)*((_QWORD *)this + 46);
  if ( v2 == (const unsigned __int16 *)a2 )
    return 1;
  if ( !v2 || !a2 )
    return 0;
  v3 = (char *)(a2 - (char *)v2);
  do
  {
    v4 = *(unsigned __int16 *)&v3[(_QWORD)v2];
    v5 = *v2 - v4;
    if ( v5 )
      break;
    ++v2;
  }
  while ( v4 );
  return !v5;
}

//----- (00000001800163E0) ----------------------------------------------------
__int64 __fastcall DownloadCertContextCallback(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v6; // ebp
  CCipherMill *v8; // rcx
  unsigned __int16 v9; // dx
  int v10; // [rsp+20h] [rbp-28h]
  struct _CERT_CONTEXT *ppvContext; // [rsp+30h] [rbp-18h] BYREF

  if ( !(unsigned int)SchannelInit(1) )
  {
    v8 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
      return 2148074244i64;
    v9 = 50;
    goto LABEL_22;
  }
  if ( !a3 || !a4 )
  {
    v8 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
      return 2148074244i64;
    v9 = 51;
LABEL_22:
    v10 = -2146893052;
    WPP_SF_DD(*((_QWORD *)v8 + 2), v9, (__int64)&WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, -2146893052, v10);
    return 2148074244i64;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 52i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
  v6 = DeserializeCertContext((const struct _CERT_CONTEXT **)&ppvContext, *(unsigned __int8 **)(a3 + 8), *(_DWORD *)a3);
  *(_DWORD *)a4 = *(_DWORD *)a3;
  SPExternalFree(*(void **)(a3 + 8));
  *(_QWORD *)(a3 + 8) = 0i64;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  if ( v6 < 0 )
  {
    *(_DWORD *)(a4 + 4) = 0;
    *(_DWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0i64;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        53i64,
        &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids,
        (unsigned int)v6);
    return (unsigned int)v6;
  }
  else
  {
    **(_QWORD **)(a4 + 8) = ppvContext;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 54i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
    return 0i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800164B0) ----------------------------------------------------
__int64 __fastcall DeserializeCertContext(
        const struct _CERT_CONTEXT **ppvContext,
        unsigned __int8 *a2,
        unsigned int a3)
{
  unsigned __int64 v3; // rbx
  __int64 v6; // r8
  unsigned int v7; // edi
  HCERTSTORE v8; // rbp
  unsigned int v9; // ebx
  __int64 v10; // r8
  int v12; // [rsp+40h] [rbp-18h] BYREF
  unsigned __int8 *v13; // [rsp+48h] [rbp-10h]

  v3 = a3;
  if ( a3 >= 4 )
  {
    v6 = *(unsigned int *)a2;
    v12 = v6;
    v13 = a2 + 4;
    if ( (unsigned int)v6 < 0xFFFFFFFA && v3 >= v6 + 4 )
    {
      v7 = 0;
      v8 = CertOpenStore((LPCSTR)6, 1u, 0i64, 4u, &v12);
      if ( v8 )
      {
        v9 = -4 - v12 + v3;
        if ( v9 >= 4 )
        {
          v10 = *(unsigned int *)&a2[v12 + 4];
          if ( (unsigned int)v10 < 0xFFFFFFFA && v9 >= (unsigned __int64)(v10 + 4) )
          {
            if ( CertAddSerializedElementToStore(v8, &a2[v12 + 8], v10, 2u, 0, 2u, 0i64, (const void **)ppvContext) )
            {
LABEL_9:
              CertCloseStore(v8, 0);
              return v7;
            }
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 46i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
            }
          }
        }
        v7 = -2146893043;
        goto LABEL_9;
      }
    }
  }
  return 2148074253i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (00000001800165E0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::PreparseMessage(CSsl3TlsClientContext *this, struct SPBuffer *a2)
{
  HLOCAL v5; // rax

  if ( *((_DWORD *)this + 17) != 49 )
    return 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 40i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
  if ( *((_QWORD *)a2 + 1) && *(_DWORD *)a2 )
  {
    v5 = SPExternalAlloc(*(_DWORD *)a2);
    *((_QWORD *)this + 117) = v5;
    if ( v5 )
    {
      memcpy_0(v5, *((const void **)a2 + 1), *(unsigned int *)a2);
      *((_DWORD *)this + 236) = *(_DWORD *)a2;
      *((_DWORD *)this + 17) = 91;
      return 0i64;
    }
    return 14i64;
  }
  else
  {
    CSslContext::SetError((__int64)this, 500, -2146893048);
    return 2148074248i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180016610) ----------------------------------------------------
__int64 __fastcall GetAppUserKeysCallback(__int64 a1, char a2, __int64 a3, struct _SecBuffer *a4)
{
  union _LARGE_INTEGER *v8; // rcx
  struct CSslUserContext *UserContext; // rax
  unsigned int UserKeysCallback; // ebx

  if ( !(unsigned int)SchannelInit(1) || !a3 || !a4 )
    return 2148074244i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 55i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
  v8 = *(union _LARGE_INTEGER **)(a3 + 8);
  if ( v8 && *(_DWORD *)a3 == 8 )
    UserContext = SslFindUserContextEx(v8);
  else
    UserContext = SslFindUserContext(a1);
  if ( UserContext )
  {
    UserKeysCallback = GetUserKeysCallback(
                         UserContext,
                         (void *(__stdcall *)(unsigned int))PvExtVirtualAlloc,
                         (void (__stdcall *)(void *))FreeExtVirtualAlloc,
                         a2,
                         a4);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 57i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
    return UserKeysCallback;
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 56i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
    return 2148074241i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (00000001800166F0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetContextAttributesA(CSsl3TlsContext *this, int a2, void *a3, unsigned int a4)
{
  switch ( a2 )
  {
    case '"':
      return CSsl3TlsContext::SetSupportedMTU(this, a3, a4);
    case 'e':
      return CSsl3TlsContext::SetEapPrfType(this, a3, a4);
    case 'i':
      return CSsl3TlsContext::SetFalseStart(this, a3, a4);
    case 'j':
      return CSsl3TlsContext::SetKeyingMaterialInfo(this, a3, a4);
  }
  return CSslContext::SetContextAttributesA(this, a2, a3, a4);
}

//----- (0000000180016724) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetFalseStart(CSsl3TlsContext *this, void *a2, int a3)
{
  unsigned int v3; // ebx
  int v6; // [rsp+50h] [rbp+18h] BYREF

  v3 = 0;
  v6 = 0;
  if ( a3 == 4
    && ((*(void (__fastcall **)(_QWORD, __int64, int *, void *))(LsaTable + 80))(0i64, 4i64, &v6, a2), v6 == 1) )
  {
    *((_BYTE *)this + 556) = 1;
  }
  else
  {
    return 87;
  }
  return v3;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180016790) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::SetClientEphemeralKey(CSsl3TlsClientContext *this, __int64 a2)
{
  __int64 v4; // rcx

  v4 = *((_QWORD *)this + 128);
  if ( v4 )
    SslFreeObject(v4, 0i64);
  *((_QWORD *)this + 128) = a2;
  return 0i64;
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (00000001800167E0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::SetServerPublicKey(CSsl3TlsClientContext *this, __int64 a2)
{
  __int64 v4; // rcx

  v4 = *((_QWORD *)this + 127);
  if ( v4 )
    SslFreeObject(v4, 0i64);
  *((_QWORD *)this + 127) = a2;
  return 0i64;
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180016828) ----------------------------------------------------
void __fastcall CSslCredential::ReleaseEphemeralKeyData(CSslCredential *this, struct CEphemKeyData *a2)
{
  if ( a2 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)a2 + 7, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(struct CEphemKeyData *, __int64))(*(_QWORD *)a2 + 8i64))(a2, 1i64);
  }
}

//----- (000000018001686C) ----------------------------------------------------
char __fastcall IsRsaAlgorithmBlacklisted(
        unsigned __int64 a1,
        unsigned int a2,
        int a3,
        unsigned int a4,
        const UNICODE_STRING *String2,
        char a6)
{
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // r15
  char v10; // si
  unsigned int v12; // edi
  unsigned __int64 v13; // rdi
  unsigned __int64 i; // rcx
  int v15; // [rsp+20h] [rbp-28h]
  int v16; // [rsp+20h] [rbp-28h]
  int v17; // [rsp+28h] [rbp-20h]

  v8 = a1;
  if ( !a2 || !a1 )
    return 0;
  v9 = a1 + 40i64 * a2;
  if ( a1 < v9 )
  {
    v10 = 1;
    while ( 1 )
    {
      if ( *(_DWORD *)(v8 + 20) )
      {
        if ( !*(_DWORD *)v8 )
          goto LABEL_13;
        if ( String2 )
          break;
      }
LABEL_8:
      v8 += 40i64;
      if ( v8 >= v9 )
        return 0;
    }
    v12 = 0;
    while ( RtlCompareUnicodeString((PCUNICODE_STRING)(*(_QWORD *)(v8 + 8) + 16i64 * v12), String2, 1u) )
    {
      if ( ++v12 >= *(_DWORD *)v8 )
        goto LABEL_8;
    }
LABEL_13:
    if ( a6 && (*(_BYTE *)(v8 + 32) & 1) != 0 )
      goto LABEL_8;
    v13 = *(_QWORD *)(v8 + 24);
    for ( i = v13 + 48i64 * *(unsigned int *)(v8 + 20); ; i = *(_QWORD *)(v8 + 24) + 48i64 * *(unsigned int *)(v8 + 20) )
    {
      if ( v13 >= i )
        goto LABEL_8;
      if ( *(_DWORD *)v13 == a3 && *(_WORD *)(v13 + 8) == 6 && !wcsncmp(*(const wchar_t **)(v13 + 16), L"RSA", 3ui64) )
      {
        if ( !*(_DWORD *)(v13 + 24) && !*(_DWORD *)(v13 + 40) && !*(_DWORD *)(v13 + 44) )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            v16 = a3;
            WPP_SF_Sd(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xCu,
              (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
              L"RSA",
              v16);
          }
          return v10;
        }
        if ( a4 )
        {
          if ( *(_DWORD *)(v13 + 40) )
          {
            if ( *(_DWORD *)(v13 + 40) > a4 )
              goto LABEL_37;
          }
          else if ( !*(_DWORD *)(v13 + 44) )
          {
            goto LABEL_18;
          }
          if ( *(_DWORD *)(v13 + 44) && *(_DWORD *)(v13 + 44) < a4 )
          {
LABEL_37:
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              v17 = a3;
              v15 = a4;
              WPP_SF_Sdd(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0xEu,
                (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
                L"RSA",
                v15,
                v17);
            }
            return v10;
          }
        }
      }
LABEL_18:
      v13 += 48i64;
    }
  }
  return 0;
}

//----- (00000001800169E0) ----------------------------------------------------
__int64 __fastcall SpLsaQueryContextAttributes(__int64 a1, unsigned int a2, __int64 a3)
{
  CCipherMill *v6; // rcx
  _QWORD *v7; // rdi
  __int64 v8; // rbx
  unsigned int v9; // eax

  v6 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids);
      v6 = WPP_GLOBAL_Control;
    }
    if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v6 + 28) & 4) != 0 )
      {
        WPP_SF_q(*((_QWORD *)v6 + 2), 0x15u, (__int64)&WPP_dd5b111c8476393ce65badbe3d423765_Traceguids, a1);
        v6 = WPP_GLOBAL_Control;
      }
      if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 4) != 0 )
      {
        WPP_SF_d(*((_QWORD *)v6 + 2), 0x16u, (__int64)&WPP_dd5b111c8476393ce65badbe3d423765_Traceguids, a2);
        v6 = WPP_GLOBAL_Control;
      }
    }
  }
  v7 = *(_QWORD **)(a1 + 8);
  v8 = v7[10];
  if ( v8 && v6 != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)v6 + 28) & 4) != 0 )
    {
      WPP_SF_D(
        *((_QWORD *)v6 + 2),
        23i64,
        &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids,
        *(unsigned int *)(v8 + 212));
      v6 = WPP_GLOBAL_Control;
    }
    if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 4) != 0 )
      WPP_SF_S(
        *((_QWORD *)v6 + 2),
        0x18u,
        (__int64)&WPP_dd5b111c8476393ce65badbe3d423765_Traceguids,
        (const wchar_t *)(v8 + 216));
  }
  v9 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD, __int64))(*v7 + 200i64))(v7, a2, a3);
  return TranslateToSecurityStatus(v9);
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180016AB4) ----------------------------------------------------
BOOLEAN (__fastcall *SafeAllocaInitialize())(void *a1)
{
  PIMAGE_NT_HEADERS v0; // rax
  __int64 SizeOfStackCommit; // rcx
  __int64 GuaranteedStackBytes; // rax
  BOOLEAN (__fastcall *result)(void *); // rax

  v0 = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);
  if ( NtCurrentPeb()->BeingDebugged
    || !v0
    || (SizeOfStackCommit = v0->OptionalHeader.SizeOfStackCommit,
        v0->OptionalHeader.SizeOfStackReserve - SizeOfStackCommit < 0x3000) )
  {
    SizeOfStackCommit = 0i64;
  }
  g_ulMaxStackAllocSize = SizeOfStackCommit;
  if ( !v0 )
    goto LABEL_11;
  GuaranteedStackBytes = NtCurrentTeb()->GuaranteedStackBytes;
  g_ulAdditionalProbeSize = GuaranteedStackBytes;
  if ( GuaranteedStackBytes )
  {
    if ( (unsigned __int64)(GuaranteedStackBytes + 8) >= 8 )
      goto LABEL_7;
LABEL_11:
    g_ulAdditionalProbeSize = -9i64;
    goto LABEL_7;
  }
  g_ulAdditionalProbeSize = 12288i64;
LABEL_7:
  g_pfnAllocate = (__int64)SafeAllocaAllocateFromHeap;
  result = SafeAllocaFreeToHeap;
  g_pfnFree = (__int64)SafeAllocaFreeToHeap;
  return result;
}
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;

//----- (0000000180016B6C) ----------------------------------------------------
__int64 __fastcall CreateCachedSslProv(struct CACHED_SSL_PROVIDER *a1, const unsigned __int16 *a2)
{
  unsigned int v4; // ebx
  __int64 v5; // rdi
  rsize_t v6; // rdi
  wchar_t *v7; // rax
  wchar_t *v8; // rbp
  __int64 v9; // rcx
  __int64 v11; // [rsp+60h] [rbp+18h] BYREF

  v11 = 0i64;
  v4 = SslOpenProvider(&v11, a2, (unsigned int)dword_180092F58);
  if ( !v4 )
  {
    v5 = -1i64;
    do
      ++v5;
    while ( a2[v5] );
    v6 = v5 + 1;
    v7 = (wchar_t *)LocalAlloc(0x40u, 2 * v6);
    v8 = v7;
    if ( v7 )
    {
      wcscpy_s(v7, v6, a2);
      v9 = 0i64;
      *(_QWORD *)a1 = v11;
      v11 = 0i64;
      *((_QWORD *)a1 + 1) = v8;
      goto LABEL_6;
    }
    v4 = -2146893056;
  }
  v9 = v11;
LABEL_6:
  if ( v9 )
    SslFreeObject(v9, 0i64);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v4 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xFu,
      (__int64)&WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids,
      v4,
      v4);
  }
  return v4;
}
// 180092F58: using guessed type int dword_180092F58;
// 1800984F8: using guessed type __int64 __fastcall SslOpenProvider(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180016C58) ----------------------------------------------------
__int64 __fastcall SpQueryTokenBinding(struct CSslUserContext *a1, struct _SecPkgContext_TokenBinding *a2)
{
  struct _SecPkgContext_TokenBinding *v2; // rbx
  BYTE *v4; // rsi
  PBYTE KeyParameters; // rbp
  SIZE_T KeyParametersSize; // r14
  BYTE *v8; // rax

  v2 = (struct _SecPkgContext_TokenBinding *)*((_QWORD *)a1 + 51);
  v4 = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 110i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
  if ( !v2 )
  {
    *a2 = 0i64;
    return 0i64;
  }
  KeyParameters = v2->KeyParameters;
  if ( !KeyParameters )
  {
LABEL_11:
    *a2 = *v2;
    a2->KeyParameters = v4;
    return 0i64;
  }
  KeyParametersSize = v2->KeyParametersSize;
  v8 = (BYTE *)LocalAlloc(0x40u, KeyParametersSize);
  v4 = v8;
  if ( v8 )
  {
    memcpy_0(v8, KeyParameters, KeyParametersSize);
    goto LABEL_11;
  }
  return 2148074240i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180016CD0) ----------------------------------------------------
char __fastcall CSessionCacheItem::DoesAppAllowCipher(CSessionCacheItem *this, struct CCredentialGroup *a2)
{
  if ( a2 )
    return CCipherMill::IsCipherSuiteAllowed(
             (__int64)g_cCipherMill,
             *((unsigned int **)a2 + 23),
             *((_DWORD *)a2 + 44),
             *((_DWORD *)a2 + 48),
             (*((_DWORD *)a2 + 39) >> 12) & 1,
             *((_DWORD *)a2 + 39) & 0x800,
             *((_DWORD *)a2 + 42),
             *((_DWORD *)a2 + 41),
             *((_DWORD *)a2 + 38),
             *((_QWORD *)this + 22),
             0i64,
             *((_QWORD *)a2 + 25),
             *((_DWORD *)a2 + 49),
             0);
  else
    return 0;
}

//----- (0000000180016DA0) ----------------------------------------------------
__int64 __fastcall SpDeleteUserModeContext(__int64 a1)
{
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
  SslDeleteUserContext(a1);
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180016DE0) ----------------------------------------------------
void LoadSecurityDll(void)
{
  HMODULE Library; // rax
  HMODULE v1; // rax

  Library = LoadLibraryExW(L"sspicli.dll", 0i64, 0);
  g_hSspicli = Library;
  if ( Library )
    g_pFreeContextBuffer = (int (__stdcall *)(void *))GetProcAddress(Library, "FreeContextBuffer");
  v1 = LoadLibraryExW(L"mskeyprotect.dll", 0i64, 0x800u);
  g_hMskeyprotect = v1;
  if ( v1 )
  {
    g_pKeyFileProtectSessionTicket = (unsigned int (__stdcall *)(unsigned __int8 *, unsigned int, const unsigned __int16 *, unsigned __int8 **, unsigned int *))GetProcAddress(v1, "KeyFileProtectSessionTicket");
    g_pKeyFileUnprotectSessionTicket = (unsigned int (__stdcall *)(unsigned __int8 *, unsigned int, const unsigned __int16 *, unsigned __int8 **, unsigned int *))GetProcAddress(g_hMskeyprotect, "KeyFileUnprotectSessionTicket");
  }
}
// 180092180: using guessed type unsigned int (__stdcall *g_pKeyFileUnprotectSessionTicket)(unsigned __int8 *, unsigned int, const unsigned __int16 *, unsigned __int8 **, unsigned int *);
// 180092188: using guessed type unsigned int (__stdcall *g_pKeyFileProtectSessionTicket)(unsigned __int8 *, unsigned int, const unsigned __int16 *, unsigned __int8 **, unsigned int *);
// 1800921A0: using guessed type int (__stdcall *g_pFreeContextBuffer)(void *);

//----- (0000000180016E98) ----------------------------------------------------
CCipherMill *__fastcall CCipherMill::CCipherMill(CCipherMill *this)
{
  dword_180092488 = 0;
  qword_180092490 = 0i64;
  qword_180092498 = 0;
  hProvider = 0i64;
  *(_OWORD *)&xmmword_1800925B0 = 0i64;
  qword_1800925C0 = 0i64;
  qword_1800925C8 = 0i64;
  word_1800925D0 = 0;
  xmmword_1800925EA = 0i64;
  xmmword_1800925FA = 0i64;
  word_1800925E8 = 0;
  word_18009260A = 0;
  RtlInitializeResource(&Resource);
  g_cCipherMill = 1;
  return (CCipherMill *)&g_cCipherMill;
}
// 180092488: using guessed type int dword_180092488;
// 180092490: using guessed type __int64 qword_180092490;
// 1800925C0: using guessed type __int64 qword_1800925C0;
// 1800925D0: using guessed type __int16 word_1800925D0;
// 1800925EA: using guessed type __int128 xmmword_1800925EA;
// 1800925FA: using guessed type __int128 xmmword_1800925FA;
// 18009260A: using guessed type __int16 word_18009260A;

//----- (0000000180016F2C) ----------------------------------------------------
__int64 __fastcall CacheClientSideSslProv(struct CACHED_SSL_PROVIDER *a1)
{
  unsigned int v2; // ebx
  CCipherMill *v3; // rcx
  unsigned int v5; // [rsp+20h] [rbp-18h]

  v2 = 0;
  v3 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids);
    v3 = WPP_GLOBAL_Control;
  }
  if ( g_cCachedPagedSslProvs >= 0x20 )
  {
    if ( v3 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v3 + 28) & 1) != 0 )
    {
      WPP_SF_(*((_QWORD *)v3 + 2), 21i64, &WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids);
      v3 = WPP_GLOBAL_Control;
    }
    v2 = -2146893052;
  }
  else
  {
    *((_QWORD *)&g_rgCachedPagedSslProvs + 2 * g_cCachedPagedSslProvs) = *(_QWORD *)a1;
    *((_QWORD *)&g_rgCachedPagedSslProvs + 2 * g_cCachedPagedSslProvs++ + 1) = *((_QWORD *)a1 + 1);
    v3 = WPP_GLOBAL_Control;
  }
  if ( v3 != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)v3 + 28) & 1) != 0 && v2 || (*((_BYTE *)v3 + 28) & 4) != 0) )
  {
    v5 = v2;
    WPP_SF_DD(*((_QWORD *)v3 + 2), 0x16u, (__int64)&WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids, v2, v5);
  }
  return v2;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180092A90: using guessed type unsigned int g_cCachedPagedSslProvs;

//----- (0000000180016FD0) ----------------------------------------------------
__int64 InitializeClientSideSslProvCache(void)
{
  unsigned int v0; // ebx
  struct _RTL_RESOURCE *v1; // rax

  v0 = 0;
  v1 = (struct _RTL_RESOURCE *)LocalAlloc(0x40u, 0x60ui64);
  g_pSslProvCacheRWLock = v1;
  if ( v1 )
    RtlInitializeResource(v1);
  else
    v0 = -2146893056;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v0 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x13u,
      (__int64)&WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids,
      v0,
      v0);
  }
  return v0;
}
// 18003EB64: conditional instruction was optimized away because rax.8==0

//----- (0000000180017090) ----------------------------------------------------
void __fastcall CSslGlobals::PeriodicCleanupHandler(void *a1, char a2)
{
  __int64 *v3; // rbx
  __int64 v4; // rdi
  unsigned int TickCount; // edi
  __int64 *v6; // rbx
  unsigned int v7; // ecx
  unsigned __int8 v8; // al
  _QWORD *v9; // r9
  __int64 v10; // r10
  __int64 v11; // rdx
  _QWORD *v12; // r8
  __int64 v13; // rdx
  _QWORD *v14; // rax

  if ( dword_180092D78 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)tls_index)
                                   + 4i64) )
  {
    Init_thread_header(&dword_180092D78);
    if ( dword_180092D78 == -1 )
    {
      qword_1800921E8 = (__int64)CSessionCacheServerItem::m_pServerCacheLookaside;
      xmmword_1800921F0 = xmmword_180092DD0;
      qword_180092200 = (__int64)&g_SslContextManager;
      qword_180092208 = (__int64)CSessionCacheManager::m_pSessionCacheManager;
      qword_180092210 = (__int64)CSslCredManager::m_pCredManager;
      Init_thread_footer(&dword_180092D78);
    }
  }
  if ( a2 )
  {
    v3 = &qword_1800921E8;
    v4 = 6i64;
    do
    {
      if ( *v3 )
        (**(void (__fastcall ***)(__int64, _QWORD))*v3)(*v3, CSslGlobals::m_dwCleanupIntervalInSeconds);
      ++v3;
      --v4;
    }
    while ( v4 );
    if ( dword_180092704 && dword_180092778 )
    {
      TickCount = GetTickCount();
      RtlAcquireResourceExclusive(&stru_180092718, 1u);
      v6 = (__int64 *)qword_180092708;
      while ( v6 != &qword_180092708 )
      {
        v7 = *((_DWORD *)v6 - 10);
        v6 = (__int64 *)*v6;
        v8 = HasTimeElapsed(v7, TickCount, dword_1800926F8);
        if ( dword_180092704 > dword_180092700 || v8 )
        {
          v11 = *(_QWORD *)(v10 + 24);
          if ( *(_QWORD *)(v11 + 8) != v10 + 24
            || (v12 = *(_QWORD **)(v10 + 32), *v12 != v10 + 24)
            || (*v12 = v11, *(_QWORD *)(v11 + 8) = v12, v13 = *v9, *(_QWORD **)(*v9 + 8i64) != v9)
            || (v14 = (_QWORD *)v9[1], (_QWORD *)*v14 != v9) )
          {
            __fastfail(3u);
          }
          *v14 = v13;
          *(_QWORD *)(v13 + 8) = v14;
          --dword_180092704;
          SPDeleteIssuerEntry((struct ISSUER_CACHE_ENTRY *)v10);
        }
      }
      RtlReleaseResource(&stru_180092718);
    }
  }
  else
  {
    (**(void (__fastcall ***)(CSessionCacheManager *, _QWORD))CSessionCacheManager::m_pSessionCacheManager)(
      CSessionCacheManager::m_pSessionCacheManager,
      0i64);
  }
  ResetEvent(CSslGlobals::m_hCleanupEvent);
}
// 18003EC25: variable 'v10' is possibly undefined
// 18003EC42: variable 'v9' is possibly undefined
// 1800920C8: using guessed type int tls_index;
// 1800921E8: using guessed type __int64 qword_1800921E8;
// 1800921F0: using guessed type __int128 xmmword_1800921F0;
// 180092200: using guessed type __int64 qword_180092200;
// 180092208: using guessed type __int64 qword_180092208;
// 180092210: using guessed type __int64 qword_180092210;
// 180092704: using guessed type int dword_180092704;
// 180092708: using guessed type __int64 qword_180092708;
// 180092778: using guessed type int dword_180092778;
// 1800927F8: using guessed type struct IAllocate *CSessionCacheServerItem::m_pServerCacheLookaside;
// 180092D78: using guessed type int dword_180092D78;
// 180092DA0: using guessed type __int64 g_SslContextManager;
// 180092DD0: using guessed type __int128 xmmword_180092DD0;

//----- (00000001800171B8) ----------------------------------------------------
__int64 __fastcall SpQuerySessionInfo(struct CSslUserContext *a1, struct _SecPkgContext_SessionInfo *a2)
{
  DWORD dwFlags; // eax

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 94i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
  a2->dwFlags = 0;
  dwFlags = a2->dwFlags;
  if ( (*((_DWORD *)a1 + 4) & 0x8000i64) == 0 )
    dwFlags = 1;
  a2->dwFlags = dwFlags;
  a2->cbSessionId = *((_DWORD *)a1 + 80);
  memcpy_0(a2->rgbSessionId, (char *)a1 + 324, *((unsigned int *)a1 + 80));
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180017230) ----------------------------------------------------
__int64 SchannelShutdown(void)
{
  BOOL v0; // ebx
  unsigned int v1; // ebx
  CSslCredManager *v3; // rcx
  CCipherMill *v4; // rcx

  v0 = LsaTable == 0;
  RtlEnterCriticalSection(&CSslGlobals::m_InitCriticalSection);
  if ( !v0 )
  {
    v3 = CSessionCacheManager::m_pSessionCacheManager;
    if ( CSessionCacheManager::m_pSessionCacheManager )
    {
      CSessionCacheManager::ShutdownSessionCache(CSessionCacheManager::m_pSessionCacheManager);
      CSessionCacheManager::m_pSessionCacheManager = 0i64;
    }
    if ( CSslCredManager::m_pCredManager )
    {
      CSslCredManager::FreeCredentialManager(v3);
      CSslCredManager::m_pCredManager = 0i64;
    }
    if ( DTLSCookieManager::m_pCookieMgr )
    {
      DTLSCookieManager::`scalar deleting destructor'(DTLSCookieManager::m_pCookieMgr);
      DTLSCookieManager::m_pCookieMgr = 0i64;
    }
    ShutdownIssuerCache();
    SchShutdownEvents();
    UnloadSslRegOptions();
    TlsCloseBCryptHashProviders();
    if ( g_hSHAProvider )
    {
      BCryptCloseAlgorithmProvider(g_hSHAProvider, 0);
      g_hSHAProvider = 0i64;
    }
    if ( g_hMD5Provider )
    {
      BCryptCloseAlgorithmProvider(g_hMD5Provider, 0);
      g_hMD5Provider = 0i64;
    }
    if ( g_hDSAProvider )
    {
      BCryptCloseAlgorithmProvider(g_hDSAProvider, 0);
      g_hDSAProvider = 0i64;
    }
    if ( g_hRSAProvider )
    {
      BCryptCloseAlgorithmProvider(g_hRSAProvider, 0);
      g_hRSAProvider = 0i64;
    }
    if ( g_hDhSchannelProv )
    {
      CryptReleaseContext(g_hDhSchannelProv, 0);
      g_hDhSchannelProv = 0i64;
    }
    RtlAcquireResourceExclusive(&Resource, 1u);
    CCipherMill::ClearCipherMill(v4, 1);
    RtlReleaseResource(&Resource);
    CSslGlobals::CleanupPeriodicCleanupHandler();
    CSslGlobals::CleanupCryptLocatorHandles();
    CSslGlobals::CleanupCryptLocatorEvents();
    if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    {
      CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized = 0;
      TlgUnregisterAggregateProvider();
    }
  }
  if ( g_hSspicli )
  {
    FreeLibrary(g_hSspicli);
    g_hSspicli = 0i64;
    g_pFreeContextBuffer = 0i64;
  }
  if ( g_hMskeyprotect )
  {
    FreeLibrary(g_hMskeyprotect);
    g_hMskeyprotect = 0i64;
    g_pKeyFileProtectSessionTicket = 0i64;
    g_pKeyFileUnprotectSessionTicket = 0i64;
  }
  if ( g_pSslProvCacheRWLock )
  {
    RtlDeleteResource(g_pSslProvCacheRWLock);
    LocalFree(g_pSslProvCacheRWLock);
  }
  v1 = 0;
  for ( g_pSslProvCacheRWLock = 0i64; v1 < g_cCachedPagedSslProvs; ++v1 )
    DestroyCachedSslProv((struct CACHED_SSL_PROVIDER *)((char *)&g_rgCachedPagedSslProvs + 16 * v1));
  g_cCachedPagedSslProvs = 0;
  CSslGlobals::m_bSchannelInitialized = 0;
  RtlLeaveCriticalSection(&CSslGlobals::m_InitCriticalSection);
  return 1i64;
}
// 18003ECF1: variable 'v3' is possibly undefined
// 18003EDE5: variable 'v4' is possibly undefined
// 180092180: using guessed type unsigned int (__stdcall *g_pKeyFileUnprotectSessionTicket)(unsigned __int8 *, unsigned int, const unsigned __int16 *, unsigned __int8 **, unsigned int *);
// 180092188: using guessed type unsigned int (__stdcall *g_pKeyFileProtectSessionTicket)(unsigned __int8 *, unsigned int, const unsigned __int16 *, unsigned __int8 **, unsigned int *);
// 1800921A0: using guessed type int (__stdcall *g_pFreeContextBuffer)(void *);
// 1800921D8: using guessed type int CSslGlobals::m_bSchannelInitialized;
// 180092620: using guessed type __int64 LsaTable;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 180092A90: using guessed type unsigned int g_cCachedPagedSslProvs;

//----- (0000000180017348) ----------------------------------------------------
void __fastcall DestroyCachedSslProv(struct CACHED_SSL_PROVIDER *a1)
{
  __int64 v2; // rcx
  void *v3; // rcx

  v2 = *(_QWORD *)a1;
  if ( v2 )
  {
    SslFreeObject(v2, 0i64);
    *(_QWORD *)a1 = 0i64;
  }
  v3 = (void *)*((_QWORD *)a1 + 1);
  if ( v3 )
  {
    LocalFree(v3);
    *((_QWORD *)a1 + 1) = 0i64;
  }
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180017394) ----------------------------------------------------
__int64 __fastcall Wow64CopyUnicodeString(unsigned int a1, struct _UNICODE_STRING *a2)
{
  unsigned int v3; // edi
  unsigned int v4; // ecx
  unsigned int v5; // edi
  WCHAR *v6; // rax
  unsigned int Length; // edx
  PWSTR Buffer; // rcx
  __int64 v10; // [rsp+50h] [rbp+18h] BYREF

  v10 = 0i64;
  if ( a1 && a2 )
  {
    v3 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64 *, _QWORD))(LsaTable + 80))(0i64, 8i64, &v10, a1);
    if ( !v3 )
    {
      v4 = WORD1(v10);
      if ( !WORD1(v10)
        || !(_WORD)v10
        || !HIDWORD(v10)
        || (v10 & 1) != 0
        || (v10 & 0x10000) != 0
        || (unsigned __int16)v10 > WORD1(v10)
        || WORD1(v10) == 0xFFFF )
      {
LABEL_18:
        v3 = -2146892963;
        goto LABEL_19;
      }
      a2->Length = v10;
      v5 = v4;
      a2->MaximumLength = v4;
      v6 = (WCHAR *)SPExternalAlloc(v4);
      a2->Buffer = v6;
      if ( v6 )
      {
        v3 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, WCHAR *, _QWORD))(LsaTable + 80))(0i64, v5, v6, HIDWORD(v10));
        if ( !v3 )
        {
          Length = a2->Length;
          if ( a2->Buffer[((unsigned __int64)a2->Length >> 1) - 1] )
            return v3;
          if ( Length > 2 )
          {
            a2->Length = Length - 2;
            return v3;
          }
          goto LABEL_18;
        }
      }
      else
      {
        v3 = -2146893056;
      }
    }
LABEL_19:
    Buffer = a2->Buffer;
    if ( Buffer )
    {
      SPExternalFree(Buffer);
      a2->Buffer = 0i64;
    }
    *(_DWORD *)&a2->Length = 0;
    return v3;
  }
  return 3221225485i64;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (00000001800174C8) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::LogUnknownTlsExtension(CSchannelTelemetryContext *this, int a2)
{
  __int64 v2; // rax

  if ( this && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
  {
    if ( a2 > 16 )
    {
      if ( a2 < 23 || a2 > 24 && a2 != 35 && a2 != 65281 )
        goto LABEL_17;
    }
    else if ( a2 != 16 && (a2 < 0 || a2 > 6 && (a2 <= 9 || a2 > 11 && (a2 <= 12 || a2 > 14))) )
    {
LABEL_17:
      v2 = *((unsigned __int16 *)this + 892);
      if ( (unsigned int)v2 < 0x32 )
      {
        *((_DWORD *)this + v2 + 396) = a2;
        ++*((_WORD *)this + 892);
      }
    }
  }
}
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180017510) ----------------------------------------------------
__int64 __fastcall _delayLoadHelper2(__int64 a1, __int64 a2)
{
  return ResolveDelayLoadedAPI(
           &_ImageBase,
           a1,
           _pfnDefaultDliFailureHook2,
           DelayLoadFailureHook,
           a2,
           _ResolveDelayLoadedAPIFlags);
}
// 180000000: using guessed type __int16 _ImageBase;
// 1800807F8: using guessed type __int64 __fastcall ResolveDelayLoadedAPI(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180086924: using guessed type int _ResolveDelayLoadedAPIFlags;
// 180086928: using guessed type __int64 _pfnDefaultDliFailureHook2;

//----- (0000000180017560) ----------------------------------------------------
__int64 __fastcall CSslCredManager::RunBalancer(CSslCredManager *this)
{
  char v2; // bp
  void *v3; // rcx
  bool v4; // si
  DWORD LastError; // eax
  _DWORD *i; // rax
  __int64 *j; // rax

  v2 = 0;
  if ( _InterlockedIncrement((volatile signed __int32 *)this + 22) <= 1 )
  {
    v3 = (void *)*((_QWORD *)this + 10);
    if ( v3 && *((_QWORD *)this + 9) && !WaitForSingleObjectEx(v3, 0, 0) )
    {
      v2 = 1;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 24i64, &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids);
      if ( !CertControlStore(*((HCERTSTORE *)this + 9), 0, 1u, (char *)this + 80)
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        LastError = GetLastError();
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          25i64,
          &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids,
          LastError);
      }
    }
    v4 = WaitForSingleObjectEx(CSslGlobals::m_hImplicitCertChangeEvent, 0, 0) == 0;
    if ( !WaitForSingleObjectEx(CSslGlobals::m_hImplicitIssersChangeEvent, 0, 0) )
    {
      RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
      for ( i = (_DWORD *)*((_QWORD *)this + 6); i != (_DWORD *)((char *)this + 48); i = *(_DWORD **)i )
        i[37] |= 0x10u;
      RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
    }
    if ( v2 || v4 )
    {
      RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
      for ( j = (__int64 *)*((_QWORD *)this + 6); j != (__int64 *)((char *)this + 48); j = (__int64 *)*j )
      {
        if ( v4 && j[99] || v2 && !j[99] )
          *((_DWORD *)j + 37) |= 0x40u;
      }
      RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
    }
  }
  _InterlockedDecrement((volatile signed __int32 *)this + 22);
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180017638) ----------------------------------------------------
__int64 WPP_INIT_CONTROL_ARRAY()
{
  __int64 result; // rax

  result = 0i64;
  qword_180092A78 = 1i64;
  qword_180092A70 = 0i64;
  WPP_MAIN_CB = 0i64;
  return result;
}
// 180092A60: using guessed type __int64 WPP_MAIN_CB;
// 180092A70: using guessed type __int64 qword_180092A70;
// 180092A78: using guessed type __int64 qword_180092A78;

//----- (0000000180017660) ----------------------------------------------------
__int64 __fastcall SpQueryCredentialsAttributes(struct CCredentialGroup *a1, int a2, _QWORD *a3)
{
  int v6; // r14d
  unsigned int v7; // ebx
  __int64 result; // rax
  int v9; // edi
  int v10; // edi
  int v11; // edi
  int v12; // eax
  CCipherMill *v13; // rcx
  int v14; // ebx
  int v15; // eax
  int v16; // eax
  unsigned int v17; // eax
  int v18; // edi
  unsigned int v19; // r15d
  int v20; // esi
  int v21; // edi
  HLOCAL v22; // rdi
  __int64 v23; // rax
  unsigned int v24; // r15d
  int v25; // esi
  int v26; // esi
  __int64 v27; // [rsp+30h] [rbp-58h] BYREF
  __int64 v28[2]; // [rsp+38h] [rbp-50h] BYREF
  __int64 v29; // [rsp+48h] [rbp-40h] BYREF
  int v30; // [rsp+50h] [rbp-38h]
  HLOCAL hMem; // [rsp+90h] [rbp+8h] BYREF
  unsigned int *v32; // [rsp+A8h] [rbp+20h] BYREF

  v32 = 0i64;
  LODWORD(hMem) = 0;
  v27 = 0i64;
  if ( !a1 )
    return 2148074241i64;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64 *))(LsaTable + 192))(&v29) )
    return 2148074244i64;
  if ( (v30 & 0x10000) != 0 )
    return QueryCredAttributesRpc(a1, a2, a3);
  v6 = v30 & 0x40;
  switch ( a2 )
  {
    case 1:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 23i64, &WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids);
      v7 = v6 != 0 ? 4 : 8;
      break;
    case 86:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids);
      v7 = v6 != 0 ? 8 : 16;
      break;
    case 87:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 21i64, &WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids);
      v7 = 8;
      break;
    case 88:
      v7 = 4;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids);
      break;
    default:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        WPP_SF_d(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x18u,
          (__int64)&WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids,
          a2);
      return 2148074242i64;
  }
  result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64 *, _QWORD *))(LsaTable + 80))(0i64, v7, v28, a3);
  if ( (int)result < 0 )
    return result;
  v9 = a2 - 1;
  if ( v9 )
  {
    v10 = v9 - 85;
    if ( !v10 )
    {
      v17 = BuildLegacySupportedAlgsList(a1, &v32, (unsigned int *)&hMem);
      result = TranslateToSecurityStatus(v17);
      if ( (_DWORD)result )
        return result;
      v18 = (int)hMem;
      v19 = 4 * (_DWORD)hMem;
      v20 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64 *))(LsaTable + 56))(
              0i64,
              (unsigned int)(4 * (_DWORD)hMem),
              &v27);
      if ( v20 < 0 )
      {
        SPExternalFree(v32);
        return (unsigned int)v20;
      }
      LODWORD(v28[0]) = v18;
      if ( v6 )
        HIDWORD(v28[0]) = v27;
      else
        v28[1] = v27;
      v21 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, unsigned int *))(LsaTable + 72))(0i64, v19, v27, v32);
      SPExternalFree(v32);
      if ( v21 < 0 )
      {
        (*(void (__fastcall **)(_QWORD, __int64))(LsaTable + 64))(0i64, v27);
        return (unsigned int)v21;
      }
      goto LABEL_17;
    }
    v11 = v10 - 1;
    if ( v11 )
    {
      if ( v11 != 1 )
        goto LABEL_17;
      v15 = *((_DWORD *)a1 + 38);
    }
    else
    {
      v12 = *((_DWORD *)a1 + 41);
      LODWORD(v28[0]) = v12;
      v13 = (CCipherMill *)*((unsigned int *)a1 + 42);
      HIDWORD(v28[0]) = (_DWORD)v13;
      if ( (_DWORD)v13 )
      {
        if ( v12 )
          goto LABEL_17;
      }
      else if ( !v12 )
      {
        goto LABEL_17;
      }
      CCipherMill::GetBaseCipherSizes(v13, v30 & 1, (unsigned int *)&v32, (unsigned int *)&hMem);
      v16 = HIDWORD(v28[0]);
      if ( !*((_DWORD *)a1 + 42) )
        v16 = (int)hMem;
      HIDWORD(v28[0]) = v16;
      if ( *((_DWORD *)a1 + 41) )
        goto LABEL_17;
      v15 = (int)v32;
    }
    LODWORD(v28[0]) = v15;
LABEL_17:
    v14 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD *, __int64 *))(LsaTable + 72))(0i64, v7, a3, v28);
    if ( v14 >= 0 )
      return 0i64;
    if ( v27 )
      (*(void (__fastcall **)(_QWORD))(LsaTable + 64))(0i64);
    return (unsigned int)v14;
  }
  hMem = 0i64;
  result = CCredentialGroup::GetNameFromFirstCred(a1, (unsigned __int16 **)&hMem);
  if ( (_DWORD)result )
    return result;
  v22 = hMem;
  v23 = -1i64;
  do
    ++v23;
  while ( *((_WORD *)hMem + v23) );
  v24 = 2 * v23 + 2;
  v25 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64 *))(LsaTable + 56))(0i64, v24, &v27);
  if ( v25 >= 0 )
  {
    if ( v6 )
      LODWORD(v28[0]) = v27;
    else
      v28[0] = v27;
    if ( !v27
      || (v26 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, HLOCAL))(LsaTable + 72))(0i64, v24, v27, v22),
          v26 >= 0) )
    {
      if ( v22 )
        LocalFree(v22);
      goto LABEL_17;
    }
    (*(void (__fastcall **)(_QWORD, __int64))(LsaTable + 64))(0i64, v27);
    if ( v22 )
      LocalFree(v22);
    return (unsigned int)v26;
  }
  else
  {
    if ( v22 )
      LocalFree(v22);
    return (unsigned int)v25;
  }
}
// 1800178F3: conditional instruction was optimized away because ecx.4!=0
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180017BBC) ----------------------------------------------------
__int64 McGenEventRegister_EtwEventRegister()
{
  __int64 result; // rax

  result = 0i64;
  if ( !MS_Schannel_Provider_Context )
    return EtwEventRegister(
             &MS_Schannel_Provider,
             McGenControlCallbackV2,
             &MS_Schannel_Provider_Context,
             &MS_Schannel_Provider_Context);
  return result;
}
// 180080EA8: using guessed type __int64 __fastcall EtwEventRegister(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180017BFC) ----------------------------------------------------
__int64 WppCleanupUm()
{
  CCipherMill *v0; // rbx
  __int64 result; // rax

  v0 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    while ( v0 )
    {
      if ( *((_QWORD *)v0 + 1) )
      {
        result = EtwUnregisterTraceGuids();
        *((_QWORD *)v0 + 1) = 0i64;
      }
      v0 = *(CCipherMill **)v0;
    }
    WPP_GLOBAL_Control = (CCipherMill *)&WPP_GLOBAL_Control;
  }
  return result;
}
// 180080E08: using guessed type __int64 EtwUnregisterTraceGuids(void);

//----- (0000000180017C60) ----------------------------------------------------
__int64 __fastcall CSslLookaside::RunBalancer(CSslLookaside *this, unsigned int a2)
{
  int v4; // eax
  int v5; // ecx
  int v6; // r9d
  char v7; // cl
  int v8; // edx
  int v9; // edx
  int v10; // edi
  PSLIST_ENTRY v11; // rax

  if ( *((_BYTE *)this + 32) && a2 )
  {
    v4 = *((_DWORD *)this + 15);
    v5 = v4 - *((_DWORD *)this + 14);
    *((_DWORD *)this + 14) = v4;
    v6 = *((_DWORD *)this + 17) - *((_DWORD *)this + 16);
    *((_DWORD *)this + 16) = *((_DWORD *)this + 17);
    if ( 60 * v5 / a2 >= *((_DWORD *)this + 12) )
    {
      if ( v6 )
        return 0i64;
      v8 = *((_DWORD *)this + 13);
      if ( v8 <= v5 )
        return 0i64;
      v7 = *((_BYTE *)this + 33) + 1;
    }
    else
    {
      v7 = *((_BYTE *)this + 33);
      v8 = *((_DWORD *)this + 13);
    }
    v9 = v8 >> v7;
    v10 = v9 + 1;
    if ( v9 != -1 )
    {
      do
      {
        if ( *((_DWORD *)this + 13) <= *((_DWORD *)this + 10) )
          break;
        v11 = InterlockedPopEntrySList((PSLIST_HEADER)this + 1);
        SPExternalFree(v11);
        _InterlockedDecrement((volatile signed __int32 *)this + 13);
        --v10;
      }
      while ( v10 );
    }
  }
  return 0i64;
}

//----- (0000000180017C90) ----------------------------------------------------
void __fastcall CSslContextManager::~CSslContextManager(CSslContextManager *this)
{
  __int64 v2; // rcx
  __int64 v3; // rcx

  *(_QWORD *)this = &CSslContextManager::`vftable';
  v2 = *((_QWORD *)this + 6);
  if ( v2 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v2 + 8i64))(v2, 1i64);
  v3 = *((_QWORD *)this + 7);
  if ( v3 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 8i64))(v3, 1i64);
}
// 18007D3E8: using guessed type void *CSslContextManager::`vftable';

//----- (0000000180017CCC) ----------------------------------------------------
void DeleteDebugTracing()
{
  struct _DBG_TRACE_CONTROL_BLOCK *v0; // rdi
  struct _RTL_CRITICAL_SECTION *SharedMem; // rax
  struct _RTL_CRITICAL_SECTION *v2; // rbx
  __int64 v3; // rcx
  struct _DBG_TRACE_CONTROL_BLOCK **v4; // rax
  HANDLE LockSemaphore; // rcx
  int v6; // eax
  PRTL_CRITICAL_SECTION_DEBUG DebugInfo; // r8
  int SpinCount; // eax
  void (__stdcall *v9)(PVOID, BOOLEAN); // r8
  unsigned int OwningThread_high; // esi
  int v11; // ecx
  void *v12; // rdx

  v0 = SchannelGlobalTraceControlBlock;
  if ( (NtCurrentPeb()->BitField & 2) == 0 )
  {
    if ( SchannelGlobalTraceControlBlock )
    {
      SharedMem = (struct _RTL_CRITICAL_SECTION *)_DbgpOpenOrCreateSharedMem();
      v2 = SharedMem;
      if ( SharedMem )
      {
        EnterCriticalSection(SharedMem + 2);
        v3 = *(_QWORD *)v0;
        if ( *(struct _DBG_TRACE_CONTROL_BLOCK **)(*(_QWORD *)v0 + 8i64) != v0
          || (v4 = (struct _DBG_TRACE_CONTROL_BLOCK **)*((_QWORD *)v0 + 1), *v4 != v0) )
        {
          __fastfail(3u);
        }
        *v4 = (struct _DBG_TRACE_CONTROL_BLOCK *)v3;
        *(_QWORD *)(v3 + 8) = v4;
        LockSemaphore = v2[1].LockSemaphore;
        v6 = LODWORD(v2->SpinCount) - 1;
        LODWORD(v2->SpinCount) = v6;
        if ( LockSemaphore == *((HANDLE *)v0 + 18) )
        {
          DeleteTimerQueueTimer(0i64, (HANDLE)v2[1].SpinCount, (HANDLE)0xFFFFFFFFFFFFFFFFi64);
          v2[1].SpinCount = 0i64;
          v2[1].LockSemaphore = 0i64;
          DebugInfo = v2[1].DebugInfo;
          if ( DebugInfo != (PRTL_CRITICAL_SECTION_DEBUG)&v2[1] )
          {
            SpinCount = v2->SpinCount;
            HIDWORD(v2[1].OwningThread) = 10 * (SpinCount + 6);
            v9 = *(void (__stdcall **)(PVOID, BOOLEAN))&DebugInfo[3].Type;
            v2[1].LockSemaphore = v9;
            if ( !CreateTimerQueueTimer(
                    (PHANDLE)&v2[1].SpinCount,
                    0i64,
                    v9,
                    v2,
                    10000 * (SpinCount + 6),
                    10000 * (SpinCount + 6),
                    0) )
              v2[1].LockSemaphore = 0i64;
          }
        }
        else if ( LockSemaphore )
        {
          OwningThread_high = HIDWORD(v2[1].OwningThread);
          v11 = 10 * v6;
          if ( OwningThread_high > 10 * v6 + 120 )
          {
            v12 = (void *)v2[1].SpinCount;
            HIDWORD(v2[1].OwningThread) = v11 + 60;
            if ( !ChangeTimerQueueTimer(0i64, v12, 1000 * (v11 + 60), 1000 * (v11 + 60)) )
              HIDWORD(v2[1].OwningThread) = OwningThread_high;
          }
        }
        LeaveCriticalSection(v2 + 2);
        _DbgpDeleteTraceControl(v0);
        SchannelGlobalTraceControlBlock = 0i64;
      }
    }
  }
}

//----- (0000000180017D1C) ----------------------------------------------------
__int64 McGenEventUnregister_EtwEventUnregister()
{
  __int64 result; // rax

  if ( !MS_Schannel_Provider_Context )
    return 0i64;
  result = EtwEventUnregister();
  MS_Schannel_Provider_Context = 0i64;
  return result;
}
// 180080EA0: using guessed type __int64 EtwEventUnregister(void);

//----- (0000000180017D60) ----------------------------------------------------
__int64 __fastcall CSslContextManager::RunBalancer(CSslContextManager *this, int a2)
{
  unsigned __int32 v3; // eax

  if ( a2 && *((_QWORD *)this + 7) && *((_DWORD *)this + 5) >= 0x64u )
  {
    v3 = *((_DWORD *)this + 6);
    if ( v3 > *((_DWORD *)this + 7) )
      _InterlockedExchange((volatile __int32 *)this + 7, v3);
    *((_DWORD *)this + 6) = 0;
  }
  return 0i64;
}

//----- (0000000180017D80) ----------------------------------------------------
void __fastcall tlgEnableCallback(
        LPCGUID SourceId,
        __int64 IsEnabled,
        __int64 Level,
        ULONGLONG MatchAnyKeyword,
        ULONGLONG MatchAllKeyword,
        PEVENT_FILTER_DESCRIPTOR FilterData,
        _QWORD *CallbackContext)
{
  int v7; // eax
  void (__fastcall *v8)(LPCGUID, __int64, __int64, ULONGLONG, ULONGLONG, PEVENT_FILTER_DESCRIPTOR, _QWORD); // rax

  if ( CallbackContext )
  {
    if ( (_DWORD)IsEnabled )
    {
      if ( (_DWORD)IsEnabled == 1 )
      {
        if ( (_BYTE)Level )
          v7 = (unsigned __int8)Level + 1;
        else
          v7 = 256;
        *(_DWORD *)CallbackContext = v7;
        CallbackContext[2] = MatchAnyKeyword;
        CallbackContext[3] = MatchAllKeyword;
      }
    }
    else
    {
      *(_DWORD *)CallbackContext = 0;
    }
    v8 = (void (__fastcall *)(LPCGUID, __int64, __int64, ULONGLONG, ULONGLONG, PEVENT_FILTER_DESCRIPTOR, _QWORD))CallbackContext[5];
    if ( v8 )
      v8(SourceId, IsEnabled, Level, MatchAnyKeyword, MatchAllKeyword, FilterData, CallbackContext[6]);
  }
}

//----- (0000000180017E08) ----------------------------------------------------
void __fastcall CCipherMill::~CCipherMill(CCipherMill *this)
{
  if ( *(_BYTE *)this )
    RtlDeleteResource((PRTL_RESOURCE)((char *)this + 8));
}

//----- (0000000180017E30) ----------------------------------------------------
BOOLEAN RemoveExternalSchannelAlgorithms()
{
  BOOLEAN result; // al

  if ( dword_1800921B0 )
  {
    FreeExternalHashAlgorithms();
    FreeExternalSignatureAlgorithms();
    FreeExternalKeyExchangeAlgorithms();
    return FreeExternalCipherAlgorithms();
  }
  return result;
}
// 1800921B0: using guessed type int dword_1800921B0;

//----- (0000000180017E50) ----------------------------------------------------
void __fastcall TlgAggregateInternalProviderCallback(const struct _GUID *a1, int a2, __int64 a3, __int64 a4)
{
  __int64 i; // rbx

  if ( a2 == 2 && a4 == 32 && TryAcquireSRWLockExclusive(&SRWLock) )
  {
    for ( i = qword_180092EE8; i; i = *(_QWORD *)(i + 336) )
      LookUpTableFlushComplete(i);
    ReleaseSRWLockExclusive(&SRWLock);
  }
}
// 180092EE8: using guessed type __int64 qword_180092EE8;

//----- (0000000180017EA0) ----------------------------------------------------
__int64 __fastcall SpSslGetInfo(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 4) = 917505;
  *(_QWORD *)(a1 + 16) = L"Schannel";
  *(_QWORD *)(a1 + 24) = L"Schannel Security Package";
  result = 0i64;
  *(_DWORD *)a1 = 4261811;
  *(_DWORD *)(a1 + 8) = 24576;
  return result;
}

//----- (0000000180017EE0) ----------------------------------------------------
__int64 __fastcall SpUniGetInfo(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 4) = 917505;
  *(_QWORD *)(a1 + 16) = L"Microsoft Unified Security Protocol Provider";
  *(_QWORD *)(a1 + 24) = L"Schannel Security Package";
  result = 0i64;
  *(_DWORD *)a1 = 4261811;
  *(_DWORD *)(a1 + 8) = 24576;
  return result;
}

//----- (0000000180017F30) ----------------------------------------------------
__int64 SpShutdown()
{
  return 2148074242i64;
}

//----- (0000000180017F40) ----------------------------------------------------
void *__fastcall IAllocate::Allocate(IAllocate *this)
{
  return 0i64;
}

//----- (0000000180017F50) ----------------------------------------------------
__int64 __fastcall IBalance::RunBalancer(IBalance *this)
{
  return 120i64;
}

//----- (0000000180017F60) ----------------------------------------------------
void __fastcall CSslUserContext::GetCertContextInfo(
        CSslUserContext *this,
        unsigned __int8 **a2,
        unsigned int *a3,
        unsigned __int16 **a4,
        unsigned int *a5,
        unsigned __int16 **a6,
        unsigned int *a7,
        unsigned __int8 **a8,
        unsigned int *a9,
        const unsigned __int8 **a10,
        unsigned int *a11,
        unsigned __int8 **a12,
        unsigned int *a13)
{
  *a2 = (unsigned __int8 *)*((_QWORD *)this + 19);
  *a3 = *((_DWORD *)this + 40);
  *a4 = (unsigned __int16 *)*((_QWORD *)this + 21);
  *a5 = *((_DWORD *)this + 44);
  *a6 = (unsigned __int16 *)*((_QWORD *)this + 23);
  *a7 = *((_DWORD *)this + 48);
  *a8 = (unsigned __int8 *)*((_QWORD *)this + 25);
  *a9 = *((_DWORD *)this + 52);
  *a10 = (const unsigned __int8 *)*((_QWORD *)this + 27);
  *a11 = *((_DWORD *)this + 56);
  *a12 = (unsigned __int8 *)*((_QWORD *)this + 29);
  *a13 = *((_DWORD *)this + 60);
}

//----- (0000000180018010) ----------------------------------------------------
__int64 __fastcall CSslUserContext::GetClientAuthResults(CSslUserContext *this, unsigned __int64 *a2, int *a3)
{
  *a2 = *((_QWORD *)this + 33);
  *a3 = *((_DWORD *)this + 68);
  return 0i64;
}

//----- (0000000180018030) ----------------------------------------------------
unsigned __int64 __fastcall CSslUserContext::GetExporterMasterKey(CSslUserContext *this)
{
  return *((_QWORD *)this + 54);
}

//----- (0000000180018050) ----------------------------------------------------
void __fastcall CSslUserContext::GetReadWriteKeys(CSslUserContext *this, unsigned __int64 *a2, unsigned __int64 *a3)
{
  *a2 = *((_QWORD *)this + 5);
  *a3 = *((_QWORD *)this + 6);
}

//----- (0000000180018070) ----------------------------------------------------
struct _SecPkgContext_ApplicationProtocol *__fastcall CSslUserContext::GetSelectedApplicationProtocol(
        CSslUserContext *this)
{
  return (struct _SecPkgContext_ApplicationProtocol *)*((_QWORD *)this + 49);
}

//----- (0000000180018090) ----------------------------------------------------
struct _SecPkgContext_SrtpParameters *__fastcall CSslUserContext::GetSelectedSrtpParameters(CSslUserContext *this)
{
  return (struct _SecPkgContext_SrtpParameters *)*((_QWORD *)this + 50);
}

//----- (00000001800180B0) ----------------------------------------------------
struct _SecPkgContext_TokenBinding *__fastcall CSslUserContext::GetSelectedTBParameters(CSslUserContext *this)
{
  return (struct _SecPkgContext_TokenBinding *)*((_QWORD *)this + 51);
}

//----- (00000001800180D0) ----------------------------------------------------
struct _SecPkgContext_KeyingMaterial *__fastcall CSslUserContext::GetTokenBindingEKM(CSslUserContext *this)
{
  return (struct _SecPkgContext_KeyingMaterial *)((char *)this + 416);
}

//----- (00000001800180F0) ----------------------------------------------------
void __fastcall CSslUserContext::GetUniqueBindings(CSslUserContext *this, unsigned __int8 **a2, unsigned int *a3)
{
  *a2 = (unsigned __int8 *)*((_QWORD *)this + 31);
  *a3 = *((_DWORD *)this + 64);
}

//----- (0000000180018110) ----------------------------------------------------
__int64 __fastcall CSslUserContext::PopulateSerialContextState(CSslUserContext *this, struct _SSL_PACKED_CONTEXT *a2)
{
  *(_DWORD *)a2 = *((_DWORD *)this + 2);
  *((_QWORD *)a2 + 1) = *((_QWORD *)this + 2);
  *((_DWORD *)a2 + 4) = *((_DWORD *)this + 6);
  *((_DWORD *)a2 + 5) = *((_DWORD *)this + 14);
  *((_DWORD *)a2 + 6) = *((_DWORD *)this + 15);
  *((_DWORD *)a2 + 7) = *((_DWORD *)this + 7);
  *((_DWORD *)a2 + 8) = *((_DWORD *)this + 16);
  *((_DWORD *)a2 + 9) = *((_DWORD *)this + 18);
  *((_DWORD *)a2 + 38) = *((_DWORD *)this + 17);
  *((_DWORD *)a2 + 10) = *((_DWORD *)this + 49);
  *((_QWORD *)a2 + 6) = *((_QWORD *)this + 12);
  *((_QWORD *)a2 + 7) = *((_QWORD *)this + 13);
  *((_DWORD *)a2 + 44) = *((_DWORD *)this + 29);
  *((_QWORD *)a2 + 20) = *((_QWORD *)this + 15);
  *((_QWORD *)a2 + 21) = *((_QWORD *)this + 16);
  *((_WORD *)a2 + 90) = *((_WORD *)this + 68);
  *((_WORD *)a2 + 91) = *((_WORD *)this + 69);
  *((_DWORD *)a2 + 47) = *((_DWORD *)this + 115);
  *((_BYTE *)a2 + 192) = *((_BYTE *)this + 456);
  *((_BYTE *)a2 + 44) = *((_BYTE *)this + 32);
  *((_DWORD *)a2 + 36) = *((_DWORD *)this + 94);
  *((_DWORD *)a2 + 37) = *((_DWORD *)this + 95);
  *((_DWORD *)a2 + 22) = *((_DWORD *)this + 80);
  memcpy_0((char *)a2 + 92, (char *)this + 324, *((unsigned int *)this + 80));
  *((_DWORD *)a2 + 31) = *((_DWORD *)this + 89);
  memcpy_0((char *)a2 + 128, (char *)this + 360, *((unsigned int *)this + 89));
  *((_QWORD *)a2 + 10) = *((_QWORD *)this + 37);
  return 0i64;
}

//----- (0000000180018250) ----------------------------------------------------
__int64 SpCompleteAuthToken()
{
  return 3221225659i64;
}

//----- (0000000180018260) ----------------------------------------------------
__int64 SpFormatCredentials()
{
  return 3221225659i64;
}

//----- (0000000180018270) ----------------------------------------------------
__int64 SpMakeSignature()
{
  return 2148074242i64;
}

//----- (0000000180018280) ----------------------------------------------------
__int64 SpVerifySignature()
{
  return 2148074242i64;
}

//----- (00000001800182A0) ----------------------------------------------------
__int64 __fastcall CSslContext::GenerateHello(CSslContext *this, struct SPBuffer *a2)
{
  return 120i64;
}

//----- (00000001800182B0) ----------------------------------------------------
__int64 __fastcall CSslContext::GenerateTlsAlertMessage(CSslContext *this, struct SPBuffer *a2)
{
  return 0i64;
}

//----- (00000001800182C0) ----------------------------------------------------
struct CSslCredential *__fastcall CSsl3TlsClientContext::GetActiveCred(CSsl3TlsClientContext *this)
{
  return (struct CSslCredential *)*((_QWORD *)this + 116);
}

//----- (00000001800182E0) ----------------------------------------------------
struct CSslCredential *__fastcall CSsl3TlsServerContext::GetActiveCred(CSsl3TlsServerContext *this)
{
  return *(struct CSslCredential **)(*((_QWORD *)this + 124) + 336i64);
}

//----- (0000000180018300) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::GetCacheClientItem(
        CSsl3TlsClientContext *this,
        struct CSessionCacheClientItem **a2)
{
  *a2 = (struct CSessionCacheClientItem *)*((_QWORD *)this + 165);
}

//----- (0000000180018320) ----------------------------------------------------
void __fastcall CSslContext::GetCacheClientItem(CSslContext *this, struct CSessionCacheClientItem **a2)
{
  *a2 = 0i64;
}

//----- (0000000180018330) ----------------------------------------------------
void __fastcall CSsl3TlsServerContext::GetCacheServerItem(
        CSsl3TlsServerContext *this,
        struct CSessionCacheServerItem **a2)
{
  *a2 = (struct CSessionCacheServerItem *)*((_QWORD *)this + 124);
}

//----- (0000000180018350) ----------------------------------------------------
void __fastcall CSslContext::GetCacheServerItem(CSslContext *this, struct CSessionCacheServerItem **a2)
{
  *a2 = 0i64;
}

//----- (0000000180018360) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::GetCertOcspInfo(
        CSsl3TlsClientContext *this,
        unsigned __int8 **a2,
        unsigned int *a3)
{
  __int64 v3; // r9

  v3 = *((_QWORD *)this + 165);
  *a3 = *(_DWORD *)(v3 + 344);
  *a2 = *(unsigned __int8 **)(v3 + 336);
}

//----- (0000000180018390) ----------------------------------------------------
void __fastcall CSslContext::GetCertOcspInfo(CSslContext *this, unsigned __int8 **a2, unsigned int *a3)
{
  *a2 = 0i64;
  *a3 = 0;
}

//----- (00000001800183B0) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::GetCertSerialChain(
        CSsl3TlsClientContext *this,
        const unsigned __int8 **a2,
        unsigned int *a3)
{
  __int64 v3; // r9

  v3 = *((_QWORD *)this + 165);
  *a3 = *(_DWORD *)(v3 + 360);
  *a2 = *(const unsigned __int8 **)(v3 + 352);
}

//----- (00000001800183E0) ----------------------------------------------------
void __fastcall CSslContext::GetCertSerialChain(CSslContext *this, const unsigned __int8 **a2, unsigned int *a3)
{
  *a2 = 0i64;
  *a3 = 0;
}

//----- (0000000180018400) ----------------------------------------------------
unsigned __int64 __fastcall CSsl3TlsClientContext::GetClientEphemeralKey(CSsl3TlsClientContext *this)
{
  return *((_QWORD *)this + 128);
}

//----- (0000000180018420) ----------------------------------------------------
unsigned __int64 __fastcall CSslContext::GetClientEphemeralKey(CSslContext *this)
{
  return 0i64;
}

//----- (0000000180018430) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::GetEndpointBindings(
        CSsl3TlsClientContext *this,
        unsigned __int8 **a2,
        unsigned int *a3)
{
  __int64 v3; // r9

  v3 = *((_QWORD *)this + 165);
  *a2 = *(unsigned __int8 **)(v3 + 400);
  *a3 = *(_DWORD *)(v3 + 408);
}

//----- (0000000180018460) ----------------------------------------------------
void __fastcall CSslContext::GetEndpointBindings(CSslContext *this, unsigned __int8 **a2, unsigned int *a3)
{
  *a2 = 0i64;
  *a3 = 0;
}

//----- (0000000180018480) ----------------------------------------------------
unsigned __int64 __fastcall CSslContext::GetExporterMasterKey(CSslContext *this)
{
  return 0i64;
}

//----- (0000000180018490) ----------------------------------------------------
unsigned __int64 __fastcall CTls13ClientContext::GetExporterMasterKey(CTls13ClientContext *this)
{
  return *((_QWORD *)this + 183);
}

//----- (00000001800184B0) ----------------------------------------------------
unsigned __int64 __fastcall CTls13ServerContext::GetExporterMasterKey(CTls13ServerContext *this)
{
  return *((_QWORD *)this + 137);
}

//----- (00000001800184D0) ----------------------------------------------------
unsigned __int8 __fastcall CSslContext::GetIsKeyUpdateRequested(CSslContext *this)
{
  return 0;
}

//----- (00000001800184E0) ----------------------------------------------------
unsigned __int8 __fastcall CTls13ClientContext::GetIsKeyUpdateRequested(CTls13ClientContext *this)
{
  return *((_BYTE *)this + 1616);
}

//----- (00000001800184F0) ----------------------------------------------------
unsigned __int8 __fastcall CTls13ServerContext::GetIsKeyUpdateRequested(CTls13ServerContext *this)
{
  return *((_BYTE *)this + 1248);
}

//----- (0000000180018500) ----------------------------------------------------
struct _SEC_PRESHAREDKEY_IDENTITY *__fastcall CSsl3TlsContext::GetPSKExchangeValue(CSsl3TlsContext *this)
{
  return (struct _SEC_PRESHAREDKEY_IDENTITY *)*((_QWORD *)this + 108);
}

//----- (0000000180018520) ----------------------------------------------------
struct _SEC_PRESHAREDKEY_IDENTITY *__fastcall CSslContext::GetPSKExchangeValue(CSslContext *this)
{
  return 0i64;
}

//----- (0000000180018530) ----------------------------------------------------
void __fastcall CSslContext::GetReadWriteKeys(CSslContext *this, unsigned __int64 *a2, unsigned __int64 *a3)
{
  *a2 = *((_QWORD *)this + 18);
  *a3 = *((_QWORD *)this + 19);
}

//----- (0000000180018550) ----------------------------------------------------
unsigned __int8 __fastcall CSsl3TlsContext::GetRenegoInfoExtPresent(CSsl3TlsContext *this)
{
  return *((_BYTE *)this + 554);
}

//----- (0000000180018560) ----------------------------------------------------
unsigned __int8 __fastcall CSslContext::GetRenegoInfoExtPresent(CSslContext *this)
{
  return 0;
}

//----- (0000000180018570) ----------------------------------------------------
void *__fastcall CSslScratchAllocator::GetScratchBuffer(CSslScratchAllocator *this)
{
  return (void *)*((_QWORD *)this + 1);
}

//----- (0000000180018580) ----------------------------------------------------
struct _SecPkgContext_ApplicationProtocol *__fastcall CSsl3TlsContext::GetSelectedApplicationProtocol(
        CSsl3TlsContext *this)
{
  return (struct _SecPkgContext_ApplicationProtocol *)*((_QWORD *)this + 99);
}

//----- (00000001800185A0) ----------------------------------------------------
struct _SecPkgContext_ApplicationProtocol *__fastcall CSslContext::GetSelectedApplicationProtocol(CSslContext *this)
{
  return 0i64;
}

//----- (00000001800185B0) ----------------------------------------------------
struct _SecPkgContext_SrtpParameters *__fastcall CSsl3TlsContext::GetSelectedSrtpParameters(CSsl3TlsContext *this)
{
  return (struct _SecPkgContext_SrtpParameters *)*((_QWORD *)this + 101);
}

//----- (00000001800185D0) ----------------------------------------------------
struct _SecPkgContext_SrtpParameters *__fastcall CSslContext::GetSelectedSrtpParameters(CSslContext *this)
{
  return 0i64;
}

//----- (00000001800185E0) ----------------------------------------------------
struct _SecPkgContext_TokenBinding *__fastcall CSsl3TlsContext::GetSelectedTBParameters(CSsl3TlsContext *this)
{
  return (struct _SecPkgContext_TokenBinding *)*((_QWORD *)this + 103);
}

//----- (0000000180018600) ----------------------------------------------------
struct _SecPkgContext_TokenBinding *__fastcall CSslContext::GetSelectedTBParameters(CSslContext *this)
{
  return 0i64;
}

//----- (0000000180018610) ----------------------------------------------------
unsigned __int64 __fastcall CSsl3TlsClientContext::GetServerPublicKey(CSsl3TlsClientContext *this)
{
  return *((_QWORD *)this + 127);
}

//----- (0000000180018630) ----------------------------------------------------
unsigned __int64 __fastcall CSslContext::GetServerPublicKey(CSslContext *this)
{
  return 0i64;
}

//----- (0000000180018640) ----------------------------------------------------
const unsigned __int16 *__fastcall CSsl3TlsClientContext::GetTargetName(CSsl3TlsClientContext *this)
{
  return (const unsigned __int16 *)*((_QWORD *)this + 166);
}

//----- (0000000180018660) ----------------------------------------------------
const unsigned __int16 *__fastcall CSslContext::GetTargetName(CSslContext *this)
{
  return 0i64;
}

//----- (0000000180018670) ----------------------------------------------------
struct _SecPkgContext_KeyingMaterial *__fastcall CSsl3TlsContext::GetTokenBindingEKM(CSsl3TlsContext *this)
{
  return (struct _SecPkgContext_KeyingMaterial *)*((_QWORD *)this + 104);
}

//----- (0000000180018690) ----------------------------------------------------
struct _SecPkgContext_KeyingMaterial *__fastcall CSslContext::GetTokenBindingEKM(CSslContext *this)
{
  return 0i64;
}

//----- (00000001800186A0) ----------------------------------------------------
void __fastcall CSslContext::GetUniqueBindings(CSslContext *this, unsigned __int8 **a2, unsigned int *a3)
{
  *a2 = 0i64;
  *a3 = 0;
}

//----- (00000001800186C0) ----------------------------------------------------
__int64 __fastcall CSslContext::ImportApplicationTrafficSecret(
        CSslContext *this,
        __int64 a2,
        __int64 a3,
        unsigned __int8 *a4)
{
  return 0i64;
}

//----- (00000001800186D0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::Initialize(CSsl3TlsContext *this)
{
  return 0i64;
}

//----- (00000001800186E0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::ParseCcsRecord(CSsl3TlsContext *this, unsigned __int8 *const a2)
{
  return 0i64;
}

//----- (00000001800186F0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::ReturnGenericExtensions(CSsl3TlsContext *this)
{
  return 0i64;
}

//----- (0000000180018710) ----------------------------------------------------
__int64 __fastcall CSslContext::SetApplicationProtocols(CSslContext *this, struct _SecBuffer *const a2)
{
  return 0i64;
}

//----- (0000000180018720) ----------------------------------------------------
__int64 __fastcall CSslContext::SetClientEphemeralKey(CSslContext *this)
{
  return 120i64;
}

//----- (0000000180018730) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::SetClientShare(CSsl3TlsServerContext *this)
{
  return 0i64;
}

//----- (0000000180018740) ----------------------------------------------------
__int64 __fastcall CSslContext::SetGenericExtensionBuffers(
        CSslContext *this,
        struct _SecBufferDesc *const a2,
        struct _SecBuffer *const a3)
{
  return 0i64;
}

//----- (0000000180018760) ----------------------------------------------------
void __fastcall CTls13ClientContext::SetIsKeyUpdateRequested(CTls13ClientContext *this, char a2)
{
  *((_BYTE *)this + 1616) = a2;
}

//----- (0000000180018770) ----------------------------------------------------
void __fastcall CTls13ServerContext::SetIsKeyUpdateRequested(CTls13ServerContext *this, char a2)
{
  *((_BYTE *)this + 1248) = a2;
}

//----- (0000000180018780) ----------------------------------------------------
__int64 __fastcall CSslContext::SetPMTU(CSslContext *this, struct _SecBuffer *const a2)
{
  return 0i64;
}

//----- (0000000180018790) ----------------------------------------------------
__int64 __fastcall CSslContext::SetPSKParameters(
        CSslContext *this,
        struct _SecBuffer *const a2,
        struct _SecBuffer *const a3)
{
  return 0i64;
}

//----- (00000001800187A0) ----------------------------------------------------
void __fastcall CSsl3TlsContext::SetRenegoInfoExtPresent(CSsl3TlsContext *this, char a2)
{
  *((_BYTE *)this + 554) = a2;
}

//----- (00000001800187C0) ----------------------------------------------------
__int64 __fastcall CSslContext::SetServerPublicKey(CSslContext *this)
{
  return 120i64;
}

//----- (00000001800187D0) ----------------------------------------------------
__int64 __fastcall CSslContext::SetSrtpParameters(
        CSslContext *this,
        struct _SecBuffer *const a2,
        struct _SecBuffer *const a3)
{
  return 0i64;
}

//----- (00000001800187E0) ----------------------------------------------------
__int64 __fastcall CSslContext::SetTBParameters(CSslContext *this, struct _SecBuffer *const a2)
{
  return 0i64;
}

//----- (00000001800187F0) ----------------------------------------------------
__int64 __fastcall CSslContext::SetTrafficSecretsBuffers(CSslContext *this, struct _SecBufferDesc *const a2)
{
  return 0i64;
}

//----- (0000000180018800) ----------------------------------------------------
unsigned __int8 __fastcall CSslContext::UseSchannelRecordLayer(CSslContext *this)
{
  return 1;
}

//----- (0000000180018810) ----------------------------------------------------
__int64 __fastcall CSslContext::GenerateRsaCkeParameterList(
        CSslContext *this,
        struct _BCryptBufferDesc *a2,
        unsigned __int8 *a3,
        unsigned int *a4)
{
  return 120i64;
}

//----- (0000000180018820) ----------------------------------------------------
__int64 __fastcall CSslContext::GetClientAuthResults(CSslContext *this, unsigned __int64 *a2, int *a3)
{
  __int64 result; // rax

  *a2 = 0i64;
  result = 2148074242i64;
  *a3 = 0;
  return result;
}

//----- (0000000180018840) ----------------------------------------------------
__int64 CSessionCacheClientItem::GetCacheItemType()
{
  return 1i64;
}

//----- (0000000180018850) ----------------------------------------------------
__int64 CSessionCacheServerItem::GetCacheItemType()
{
  return 2i64;
}

//----- (0000000180018860) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::GetClientAuthResults(
        CSsl3TlsServerContext *this,
        unsigned __int64 *a2,
        int *a3)
{
  __int64 result; // rax

  *a2 = *(_QWORD *)(*((_QWORD *)this + 124) + 344i64);
  result = 0i64;
  *a3 = *(_DWORD *)(*((_QWORD *)this + 124) + 352i64);
  return result;
}

//----- (0000000180018890) ----------------------------------------------------
__int64 __fastcall CNulRecord::SetMaxFragment(CNulRecord *this)
{
  return 0i64;
}

//----- (00000001800188A0) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::ComputeStatusRequestExtensionSize(CTls13ClientHandshake *this)
{
  *((_WORD *)this + 76) = 5;
  return 0i64;
}

//----- (00000001800188C0) ----------------------------------------------------
unsigned __int8 __fastcall CSsl3TlsContext::IsWaitingForCCS(CSsl3TlsContext *this)
{
  return 0;
}

//----- (00000001800188D0) ----------------------------------------------------
void __fastcall PacReadFcn(_DWORD *state, char **pbuffer, unsigned int *psize)
{
  *pbuffer = *(char **)state;
  *(_QWORD *)state += *psize;
  state[2] -= *psize;
}

//----- (0000000180018910) ----------------------------------------------------
void __fastcall _DbgpTraceTimerCallback(struct _DBG_TRACE_CONTROL_BLOCK *a1)
{
  union _LARGE_INTEGER *v2; // rbx
  union _LARGE_INTEGER *v3; // rcx
  struct _RTL_CRITICAL_SECTION *v4; // rdi

  if ( !*((_DWORD *)a1 + 7) )
  {
    v2 = (union _LARGE_INTEGER *)((char *)a1 + 24);
    RegSetValueExW(*((HKEY *)a1 + 21), *((LPCWSTR *)a1 + 23), 0, 4u, (const BYTE *)a1 + 24, 4u);
    v3 = v2;
LABEL_6:
    NtQuerySystemTime(v3);
    return;
  }
  if ( *((_DWORD *)a1 + 7) == -1 )
  {
    v4 = (struct _RTL_CRITICAL_SECTION *)((char *)a1 + 192);
    EnterCriticalSection((LPCRITICAL_SECTION)((char *)a1 + 192));
    _DbgpControlTracing(a1, *((_DWORD *)a1 + 6), 0);
    LeaveCriticalSection(v4);
    v3 = (union _LARGE_INTEGER *)((char *)a1 + 24);
    goto LABEL_6;
  }
}

//----- (0000000180018960) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::ProcessHandshake(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        int *a4)
{
  int v8; // eax
  int v9; // esi
  unsigned int v10; // r13d
  int v11; // r9d
  unsigned __int8 *v12; // r12
  unsigned __int8 v13; // dl
  unsigned int v14; // eax
  unsigned int ServerMasterKey; // edi
  CCipherMill *v17; // rcx
  __int64 v18; // rcx
  int v19; // eax
  __int64 v20; // rdx
  CCipherMill *v21; // rcx
  int v22; // eax
  char v23; // [rsp+70h] [rbp+8h] BYREF
  unsigned __int8 v24; // [rsp+80h] [rbp+18h]

  v8 = 4;
  if ( *((_BYTE *)this + 233) )
    v8 = 12;
  v9 = 0;
  v10 = a3 - v8;
  v11 = *a2 << 16;
  *a4 = 0;
  v12 = &a2[v8];
  v13 = 1;
  v14 = v11 | *((unsigned __int16 *)this + 34);
  v23 = 0;
  v24 = 1;
  if ( v14 == 0x10000 )
  {
LABEL_10:
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      v13 = v24;
    }
    ServerMasterKey = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, unsigned __int8 *, _QWORD, _QWORD, char *))(*(_QWORD *)this + 536i64))(
                        this,
                        a2,
                        a3,
                        v13,
                        &v23);
    if ( !ServerMasterKey )
    {
      LOBYTE(v9) = v23 != 0;
      *((_DWORD *)this + 17) = v9 + 93;
    }
    *((_BYTE *)this + 552) = 0;
    return ServerMasterKey;
  }
  if ( v14 == 1310785 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 21i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
    ServerMasterKey = CSsl3TlsContext::DigestFinish(this, v12, v10);
    if ( !ServerMasterKey )
    {
      (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 448i64))(this);
      *a4 = 1;
    }
    return ServerMasterKey;
  }
  if ( v14 > 0x100046 )
  {
    switch ( v14 )
    {
      case 0x14003Fu:
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
        ServerMasterKey = CSsl3TlsContext::DigestFinish(this, v12, v10);
        if ( !ServerMasterKey )
          *((_DWORD *)this + 17) = 95;
        return ServerMasterKey;
      case 0x10004Bu:
        goto LABEL_19;
      case 0x170046u:
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
        return (unsigned int)CSsl3TlsServerContext::DigestSupplementalDataMsg(this, v12, v10);
    }
LABEL_40:
    if ( (*((_DWORD *)this + 16) & 0xF3FC0) != 0 )
    {
      *((_DWORD *)this + 17) = 96;
      *((_WORD *)this + 48) = 2562;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x17u,
        (__int64)&WPP_095c39149c3f336b5b94efe855075ae2_Traceguids,
        v11,
        *((unsigned __int16 *)this + 34));
    return (unsigned int)-2146893018;
  }
  if ( v14 == 1048646 )
  {
LABEL_19:
    v17 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      v17 = WPP_GLOBAL_Control;
    }
    if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) != 4 )
    {
      if ( *((_DWORD *)this + 17) != 70 || (*((_DWORD *)this + 34) & 0x100i64) == 0 )
        goto LABEL_25;
      if ( v17 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v17 + 28) & 1) == 0 )
        return (unsigned int)-2146893018;
      v20 = 14i64;
LABEL_84:
      WPP_SF_(*((_QWORD *)v17 + 2), v20, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      return (unsigned int)-2146893018;
    }
    if ( *((_QWORD *)this + 106) )
    {
LABEL_25:
      ServerMasterKey = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, unsigned __int8 *, _QWORD, _QWORD))(*(_QWORD *)this + 504i64))(
                          this,
                          a2,
                          a3,
                          0i64);
      if ( !ServerMasterKey )
      {
        *a4 = 1;
        *((_QWORD *)this + 17) |= 0x8000ui64;
        v18 = *((_QWORD *)this + 1);
        v19 = *(_DWORD *)(v18 + 48);
        switch ( v19 )
        {
          case 3:
            ServerMasterKey = CSsl3TlsServerContext::EccGenerateServerMasterKey(this, v12, v10);
            break;
          case 2:
            ServerMasterKey = CSsl3TlsServerContext::DhGenerateServerMasterKey(this, v12, v10);
            break;
          case 4:
            ServerMasterKey = MakeEccDhPskSessionKeysHelper(this, 0i64, 0i64, 1);
            break;
          default:
            v22 = *(_DWORD *)(v18 + 52);
            if ( v22 == 2 )
              ServerMasterKey = CSslContext::I_RsaGenerateServerMasterKey(this, v12, v10);
            else
              ServerMasterKey = v22 == 4
                              ? CSslContext::I_RsaGenerateEcdsaSignServerMasterKey(this, v12, v10)
                              : -2146893048;
            break;
        }
        if ( !ServerMasterKey )
          *((_DWORD *)this + 17) = 61;
      }
      return ServerMasterKey;
    }
    ServerMasterKey = CSsl3TlsContext::SetPSKExchangeValue(this, v12, v10, 0);
    if ( !ServerMasterKey )
    {
      if ( *((_BYTE *)this + 233) )
        *((_BYTE *)this + 232) = 1;
      ServerMasterKey = 590624;
      *a4 = 1;
    }
    return ServerMasterKey;
  }
  if ( v14 == 65612 )
  {
    v21 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      v21 = WPP_GLOBAL_Control;
    }
    if ( CSslGlobals::m_fDisableRenegoOnServer )
    {
      ServerMasterKey = -2146893018;
      if ( v21 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v21 + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)v21 + 2), 11i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      return ServerMasterKey;
    }
    CSchannelTelemetryContext::LogRenegoStart(*((_QWORD *)this + 15), 1, *((_QWORD *)this + 17));
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 240i64))(this);
    *((_QWORD *)this + 17) &= ~0x40000000ui64;
    v13 = 0;
    *((_QWORD *)this + 11) = 0i64;
    v24 = 0;
    goto LABEL_10;
  }
  if ( v14 != 720966 )
  {
    if ( v14 == 983101 )
    {
      v17 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 19i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
        v17 = WPP_GLOBAL_Control;
      }
      if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) == 4 )
      {
        if ( v17 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v17 + 28) & 1) == 0 )
          return (unsigned int)-2146893018;
        v20 = 20i64;
        goto LABEL_84;
      }
      ServerMasterKey = CSsl3TlsServerContext::DigestCertVerify(this, v12, v10);
      if ( !ServerMasterKey )
      {
        ServerMasterKey = DoCertificateMapping(this);
        *((_DWORD *)this + 17) = 62;
      }
      return ServerMasterKey;
    }
    if ( v14 == 1048636 )
      goto LABEL_19;
    goto LABEL_40;
  }
  v17 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 16i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
    v17 = WPP_GLOBAL_Control;
  }
  if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) == 4 )
  {
    if ( v17 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v17 + 28) & 1) == 0 )
      return (unsigned int)-2146893018;
    v20 = 17i64;
    goto LABEL_84;
  }
  if ( (*((_DWORD *)this + 34) & 0x100i64) == 0 )
  {
    if ( v17 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v17 + 28) & 1) == 0 )
      return (unsigned int)-2146893018;
    v20 = 18i64;
    goto LABEL_84;
  }
  ServerMasterKey = CSsl3TlsContext::DigestRemoteCertificate(this, v12, v10);
  if ( !ServerMasterKey )
    *((_DWORD *)this + 17) = 60;
  return ServerMasterKey;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800927C0: using guessed type int CSslGlobals::m_fDisableRenegoOnServer;

//----- (0000000180018BD0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::EccGenerateServerMasterKey(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  __int64 v3; // rax
  struct _BCRYPT_ECCKEY_BLOB *v7; // rbx
  unsigned __int64 v8; // r13
  size_t v9; // r14
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rax
  void *v12; // rsp
  size_t v13; // rdx
  unsigned __int8 *v14; // rcx
  int EccPublicKeyBlob; // esi
  __int64 *v16; // rcx
  __int64 v17; // rax
  ULONG dwMagic; // esi
  __int64 *v19; // rax
  __int64 v20; // rcx
  unsigned int EccDhPskSessionKeysHelper; // esi
  struct _BCRYPT_ECCKEY_BLOB *v23; // rax
  __int64 *v24; // rax
  __int64 v25; // rcx
  unsigned __int8 v26; // r9
  int v27; // edx
  __int64 v28; // [rsp+0h] [rbp-30h] BYREF
  unsigned __int64 v29; // [rsp+30h] [rbp+0h] BYREF
  __int64 v30[5]; // [rsp+38h] [rbp+8h] BYREF

  v3 = *((_QWORD *)this + 120);
  v29 = 0i64;
  v7 = 0i64;
  v8 = *(unsigned int *)(v3 + 24);
  if ( !(_DWORD)v8 )
    goto LABEL_31;
  v9 = (unsigned int)v8;
  if ( v8 > g_ulMaxStackAllocSize )
    goto LABEL_31;
  v10 = v8 + g_ulAdditionalProbeSize + 8;
  if ( v10 < v8 || !(unsigned int)VerifyStackAvailable(v10) )
    goto LABEL_31;
  v11 = (unsigned int)(v8 + 8) + 15i64;
  if ( v11 <= (unsigned int)(v8 + 8) )
    v11 = 0xFFFFFFFFFFFFFF0i64;
  v12 = alloca(v11 & 0xFFFFFFFFFFFFFFF0ui64);
  v7 = (struct _BCRYPT_ECCKEY_BLOB *)&v29;
  if ( &v28 == (__int64 *)-48i64 || (LODWORD(v29) = 1801679955, (v7 = (struct _BCRYPT_ECCKEY_BLOB *)v30) == 0i64) )
  {
LABEL_31:
    if ( (int)v8 + 8 >= (unsigned int)v8 )
    {
      v23 = (struct _BCRYPT_ECCKEY_BLOB *)((__int64 (__fastcall *)(_QWORD))g_pfnAllocate)((unsigned int)(v8 + 8));
      if ( !v23 )
        goto LABEL_36;
      v23->dwMagic = 1885431112;
      v7 = v23 + 1;
    }
    if ( v7 )
    {
      v9 = v8;
      goto LABEL_9;
    }
LABEL_36:
    EccDhPskSessionKeysHelper = 14;
    goto LABEL_28;
  }
LABEL_9:
  memset_0(v7, 0, v9);
  *v7 = **(struct _BCRYPT_ECCKEY_BLOB **)(*((_QWORD *)this + 120) + 16i64);
  if ( !a2 || a3 <= 2 )
  {
    EccDhPskSessionKeysHelper = -2146893048;
    goto LABEL_25;
  }
  v13 = *a2;
  v14 = a2 + 1;
  if ( (_DWORD)v13 + 1 != a3 || !*a2 )
  {
    EccDhPskSessionKeysHelper = -2146893048;
    goto LABEL_49;
  }
  if ( a2 == (unsigned __int8 *)-1i64 )
    goto LABEL_47;
  if ( (*((_BYTE *)this + 20) & 8) != 0 )
  {
    EccPublicKeyBlob = MontgomeryGetEccPublicKeyBlob(v14, v13, v7, v8);
  }
  else
  {
    EccPublicKeyBlob = 0;
    if ( *v14 == 4 && v13 + 7 <= v9 )
      memcpy_0(&v7[1], v14 + 1, (unsigned int)(v13 - 1));
    else
      EccPublicKeyBlob = -2146893048;
  }
  if ( EccPublicKeyBlob )
  {
LABEL_47:
    EccDhPskSessionKeysHelper = 1359;
LABEL_49:
    v26 = 50;
    v27 = 702;
    goto LABEL_50;
  }
  v16 = (__int64 *)*((_QWORD *)this + 1);
  v17 = v16[106];
  if ( v17 && *(_BYTE *)(v17 + 24) )
  {
    dwMagic = v7->dwMagic;
    v7->dwMagic = *((_DWORD *)this + 4);
    v19 = (__int64 *)*((_QWORD *)this + 1);
    if ( v19 )
      v20 = *v19;
    else
      v20 = 0i64;
    if ( !(unsigned int)SslImportKey(v20, &v29, L"SSLECCPUBLICBLOB", v7, v8, 0) )
      goto LABEL_24;
    v7->dwMagic = dwMagic;
    v24 = (__int64 *)*((_QWORD *)this + 1);
    if ( v24 )
    {
      v25 = *v24;
      goto LABEL_45;
    }
  }
  else if ( v16 )
  {
    v25 = *v16;
    goto LABEL_45;
  }
  v25 = 0i64;
LABEL_45:
  EccDhPskSessionKeysHelper = SslImportKey(v25, &v29, L"ECCPUBLICBLOB", v7, v8, 0);
  if ( EccDhPskSessionKeysHelper )
  {
    v26 = 51;
    v27 = 703;
LABEL_50:
    CSslContext::SetErrorAndFatalAlert((__int64)this, v27, EccDhPskSessionKeysHelper, v26);
    goto LABEL_25;
  }
LABEL_24:
  EccDhPskSessionKeysHelper = MakeEccDhPskSessionKeysHelper(this, *(_QWORD *)(*((_QWORD *)this + 120) + 8i64), v29, 1);
LABEL_25:
  if ( v7 && v7[-1].dwMagic == 1885431112 )
    ((void (__fastcall *)(struct _BCRYPT_ECCKEY_BLOB *))g_pfnFree)(&v7[-1]);
LABEL_28:
  if ( v29 )
    SslFreeObject(v29, 0i64);
  return EccDhPskSessionKeysHelper;
}
// 180082258: using guessed type wchar_t aSsleccpublicbl[17];
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);
// 1800985A0: using guessed type __int64 __fastcall SslImportKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180018E08) ----------------------------------------------------
bool __fastcall CEphemKeyData::Reference(const FILETIME *this)
{
  struct _FILETIME SystemTimeAsFileTime; // [rsp+30h] [rbp+8h] BYREF

  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  _InterlockedIncrement((volatile signed __int32 *)&this[3].dwHighDateTime);
  return CompareFileTime(&SystemTimeAsFileTime, this + 4) < 0;
}

//----- (0000000180018E50) ----------------------------------------------------
unsigned __int64 __fastcall CCipherMill::GetAProvider(CCipherMill *this)
{
  unsigned __int64 v1; // rbx
  CCipherMill *v2; // rcx
  unsigned __int64 v4; // [rsp+30h] [rbp+8h] BYREF

  v1 = 0i64;
  v4 = 0i64;
  RtlAcquireResourceShared(&Resource, 1u);
  if ( qword_1800924A0[0] )
  {
    CCipherMill::ReferenceProvider(v2, qword_1800924A0[0], &v4);
    v1 = v4;
  }
  RtlReleaseResource(&Resource);
  return v1;
}
// 180018E87: variable 'v2' is possibly undefined
// 1800924A0: using guessed type unsigned __int64 qword_1800924A0[32];

//----- (0000000180018EB4) ----------------------------------------------------
CEphemKeyData *__fastcall CEphemKeyData::CEphemKeyData(CEphemKeyData *this, unsigned int a2)
{
  __int64 v3; // rbx
  struct _FILETIME SystemTimeAsFileTime; // [rsp+30h] [rbp+8h] BYREF

  *((_DWORD *)this + 7) = 1;
  *(_QWORD *)this = &CEphemKeyData::`vftable';
  v3 = a2;
  *((_QWORD *)this + 1) = 0i64;
  *((_QWORD *)this + 2) = 0i64;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 10) = 0;
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  *((_QWORD *)this + 4) = v3 + *(_QWORD *)&SystemTimeAsFileTime;
  return this;
}
// 18007C270: using guessed type void *CEphemKeyData::`vftable';

//----- (0000000180018F20) ----------------------------------------------------
CEphemKeyData *__fastcall CEphemKeyData::`vector deleting destructor'(CEphemKeyData *this, char a2)
{
  CEphemKeyData::~CEphemKeyData(this);
  if ( (a2 & 1) != 0 )
    SPExternalFree(this);
  return this;
}

//----- (0000000180018F58) ----------------------------------------------------
void __fastcall CEphemKeyData::~CEphemKeyData(CEphemKeyData *this)
{
  __int64 v2; // rcx
  void *v3; // rdi

  *(_QWORD *)this = &CEphemKeyData::`vftable';
  v2 = *((_QWORD *)this + 1);
  if ( v2 )
    SslFreeObject(v2, 0i64);
  v3 = (void *)*((_QWORD *)this + 2);
  if ( v3 )
  {
    memset(v3, 0, *((unsigned int *)this + 6));
    SPExternalFree(*((void **)this + 2));
  }
  *(_QWORD *)this = &IAllocate::`vftable';
}
// 18007C270: using guessed type void *CEphemKeyData::`vftable';
// 18007C298: using guessed type void *IAllocate::`vftable';
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180018FC0) ----------------------------------------------------
CSessionCacheServerItem *__fastcall CSessionCacheServerItem::`vector deleting destructor'(
        CSessionCacheServerItem *this,
        char a2)
{
  void *v4; // rcx

  *(_QWORD *)this = &CSessionCacheServerItem::`vftable';
  v4 = (void *)*((_QWORD *)this + 43);
  if ( v4 )
    NtClose(v4);
  *(_QWORD *)this = &CSessionCacheItem::`vftable';
  CSessionCacheItem::ClearState(this);
  if ( !*((_DWORD *)this + 17) )
    RtlDeleteResource((PRTL_RESOURCE)((char *)this + 72));
  *(_QWORD *)this = &IAllocate::`vftable';
  if ( (a2 & 1) != 0 )
    (*(void (__fastcall **)(struct IAllocate *, CSessionCacheServerItem *))(*(_QWORD *)CSessionCacheServerItem::m_pServerCacheLookaside
                                                                          + 32i64))(
      CSessionCacheServerItem::m_pServerCacheLookaside,
      this);
  return this;
}
// 18007C298: using guessed type void *IAllocate::`vftable';
// 18007C2C0: using guessed type void *CSessionCacheItem::`vftable';
// 18007C330: using guessed type void *CSessionCacheServerItem::`vftable';
// 1800927F8: using guessed type struct IAllocate *CSessionCacheServerItem::m_pServerCacheLookaside;

//----- (0000000180019060) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::AllocateAndGenerateNstCcsAndFinish(
        CSsl3TlsServerContext *this,
        struct SPBuffer *a2)
{
  char v2; // r10
  unsigned int v5; // edi
  unsigned __int8 *v6; // rbp
  unsigned __int16 v7; // r12
  unsigned int v8; // r14d
  int v9; // r13d
  __int16 v10; // r9
  int v11; // r8d
  unsigned int v12; // ecx
  unsigned int v13; // r8d
  int v14; // ecx
  int v15; // eax
  unsigned int v16; // ecx
  unsigned int v17; // r9d
  _BYTE *v18; // r15
  unsigned int v19; // eax
  unsigned int CcsAndFinishMessage; // edi
  int v22; // edi
  unsigned int v23; // edi
  bool v24; // zf
  unsigned int v25; // edi
  unsigned int v26; // ecx
  _BYTE *Memory; // rax
  unsigned int v28; // r12d
  __int16 v29; // cx
  unsigned __int16 v30; // [rsp+70h] [rbp+8h] BYREF
  unsigned int v31; // [rsp+80h] [rbp+18h] BYREF
  unsigned __int8 *v32; // [rsp+88h] [rbp+20h] BYREF

  v2 = *((_BYTE *)this + 233);
  v5 = 0;
  v6 = 0i64;
  v7 = 0;
  v31 = 0;
  v32 = 0i64;
  v30 = 0;
  if ( v2 )
  {
    v8 = 13;
    goto LABEL_3;
  }
  v8 = 5;
  if ( (*((_BYTE *)this + 32) & 4) == 0 )
  {
LABEL_3:
    v9 = 0;
    goto LABEL_4;
  }
  v9 = *((_DWORD *)this + 11);
LABEL_4:
  if ( (*((_DWORD *)this + 34) & 0x400000) != 0 )
  {
    CcsAndFinishMessage = CSsl3TlsServerContext::SerializeAndProtectSessionState(this, (HLOCAL *)&v32, &v30);
    if ( CcsAndFinishMessage )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          53i64,
          &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids,
          CcsAndFinishMessage);
      v6 = v32;
      goto LABEL_22;
    }
    v2 = *((_BYTE *)this + 233);
    v22 = 18;
    v7 = v30;
    if ( !v2 )
      v22 = 10;
    v23 = v30 + v22;
    v24 = (*((_BYTE *)this + 32) & 4) == 0;
    v31 = v23;
    if ( !v24 )
    {
      v25 = *((_DWORD *)this + 12) + v23;
      v26 = *((_DWORD *)this + 13);
      if ( v26 )
      {
        if ( (*((_BYTE *)this + 56) & 1) != 0 )
          v26 -= v25 % v26;
        v25 += v26;
      }
      v23 = *((_DWORD *)this + 11) + v25;
    }
    v5 = *((_DWORD *)this + 15) + v23;
    v6 = v32;
  }
  v10 = *((_WORD *)this + 16);
  v11 = 1;
  if ( (v10 & 4) != 0 )
  {
    v12 = *((_DWORD *)this + 13);
    v13 = *((_DWORD *)this + 12) + 1;
    if ( v12 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v12 -= v13 % v12;
      v13 += v12;
    }
    v11 = *((_DWORD *)this + 11) + v13;
  }
  if ( (*((_BYTE *)this + 64) & 0x30) != 0 )
  {
    v14 = 48;
    v15 = 40;
  }
  else
  {
    v14 = 24;
    v15 = 16;
  }
  if ( !v2 )
    v14 = v15;
  if ( (v10 & 1) != 0 )
  {
    v16 = *((_DWORD *)this + 12) + v14;
    v17 = *((_DWORD *)this + 13);
    if ( v17 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v17 -= v16 % v17;
      v16 += v17;
    }
    v14 = *((_DWORD *)this + 11) + v16;
  }
  v18 = (_BYTE *)*((_QWORD *)a2 + 1);
  v19 = v5 + v14 + v11 + 2 * *((_DWORD *)this + 15);
  if ( v18 )
  {
    if ( *(_DWORD *)a2 < v19 )
    {
      *((_DWORD *)a2 + 1) = v19;
      CcsAndFinishMessage = -2146893023;
      goto LABEL_22;
    }
  }
  else
  {
    *(_DWORD *)a2 = v19;
    Memory = CSslContext::GetMemory(this, v19);
    *((_QWORD *)a2 + 1) = Memory;
    v18 = Memory;
    if ( !Memory )
    {
      CcsAndFinishMessage = 14;
      goto LABEL_22;
    }
  }
  *((_DWORD *)a2 + 1) = 0;
  if ( (*((_DWORD *)this + 34) & 0x400000) == 0 )
  {
LABEL_21:
    CcsAndFinishMessage = CSsl3TlsContext::GenerateCcsAndFinishMessage(this, a2);
    goto LABEL_22;
  }
  CSsl3TlsServerContext::GenerateNewSessionTicket(this, v6, v7, &v18[v8 + v9], &v31);
  v28 = v31;
  CcsAndFinishMessage = CSsl3TlsServerContext::UpdateHashAndWrapMessage(
                          this,
                          (__int64)&v18[v8 + v9],
                          v31,
                          (__int64)a2,
                          1011,
                          964);
  if ( !CcsAndFinishMessage )
  {
    if ( *((_BYTE *)this + 233) )
    {
      *((_DWORD *)a2 + 1) += v8 + v28;
      v29 = *((_WORD *)this + 17);
      v18[12] = v28;
      v18[11] = BYTE1(v28);
      v18[1] = HIBYTE(v29);
      v18[2] = v29;
      *v18 = 22;
    }
    goto LABEL_21;
  }
LABEL_22:
  if ( v6 )
    LocalFree(v6);
  return CcsAndFinishMessage;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800191DC) ----------------------------------------------------
void __fastcall CSsl3TlsServerContext::SetDowngradeProtection(CSsl3TlsServerContext *this)
{
  __int64 v1; // rax
  int v3; // r9d
  int v4; // ecx
  const unsigned __int8 near *v5; // rax
  bool v6; // cl
  bool v7; // al

  v1 = *((_QWORD *)this + 10);
  if ( v1 )
  {
    v3 = *(_DWORD *)(v1 + 152);
    v4 = *((_DWORD *)this + 16);
    if ( (v4 & 0x400) != 0 && (v3 & 0x1000) != 0 )
    {
      v5 = CSsl3TlsContext::m_rgbTls12Downgrade;
LABEL_4:
      *((_QWORD *)this + 41) = v5;
      return;
    }
    if ( *((_BYTE *)this + 233) )
    {
      v6 = (v4 & 0x40000) == 0;
      v7 = (v3 & 0x40000) != 0;
    }
    else
    {
      v6 = (v4 & 0x1400) == 0;
      v7 = (v3 & 0x1400) != 0;
    }
    if ( v6 && v7 )
    {
      v5 = CSsl3TlsContext::m_rgbTls11OrBelowDowngrade;
      goto LABEL_4;
    }
  }
}
// 180082BB8: using guessed type const unsigned __int8 near *const CSsl3TlsContext::m_rgbTls11OrBelowDowngrade;
// 180082BC0: using guessed type const unsigned __int8 near *const CSsl3TlsContext::m_rgbTls12Downgrade;

//----- (0000000180019220) ----------------------------------------------------
__int64 __fastcall CTlsExtServer::GetServerHelloExtensionsLength(
        CTlsExtServer *this,
        char a2,
        char a3,
        unsigned __int16 *a4)
{
  unsigned int v6; // ecx
  __int64 v8; // r9
  __int64 v9; // rax
  _DWORD *v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rax
  _DWORD *v13; // r8
  unsigned int v14; // ecx
  unsigned int v15; // edx

  v6 = *((_DWORD *)this + 5);
  if ( !v6 )
  {
    v8 = *((_QWORD *)this + 1);
    if ( *(_BYTE *)(v8 + 922) )
    {
      v6 = 6;
      *((_BYTE *)this + 25) = 1;
      *((_DWORD *)this + 5) = 6;
    }
    if ( a2 )
    {
      v6 += 4;
      *((_BYTE *)this + 24) = 1;
      *((_DWORD *)this + 5) = v6;
    }
    if ( (*(_DWORD *)(v8 + 136) & 0x400000) != 0 )
      *((_DWORD *)this + 5) = v6 + 4;
    v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 88i64))(v8);
    if ( v9 && *(_DWORD *)v9 == 1 && *(_DWORD *)(v9 + 4) == 2 )
      *((_DWORD *)this + 5) += *(unsigned __int8 *)(v9 + 8) + 7;
    v10 = (_DWORD *)*((_QWORD *)this + 1);
    if ( (v10[34] & 0x8000000) != 0 )
      *((_DWORD *)this + 5) += 4;
    v11 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v10 + 96i64))(v10);
    if ( v11 )
      *((_DWORD *)this + 5) += *(unsigned __int8 *)(v11 + 2) + 9;
    v12 = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 1) + 104i64))(*((_QWORD *)this + 1));
    if ( v12 )
      *((_DWORD *)this + 5) += *(unsigned __int8 *)(v12 + 2) + 7;
    v13 = (_DWORD *)*((_QWORD *)this + 1);
    v6 = *((_DWORD *)this + 5);
    if ( a3 )
    {
      v14 = v6 + 5;
      *((_BYTE *)this + 26) = 1;
      *((_DWORD *)this + 5) = v14;
      v15 = v14 + v13[104];
      *((_DWORD *)this + 5) = v15;
      v6 = v15 + v13[114];
      *((_DWORD *)this + 5) = v6;
    }
    if ( (v13[34] & 0x200000) != 0 )
    {
      v6 += 4;
      *((_DWORD *)this + 5) = v6;
    }
    if ( v6 )
    {
      v6 += 2;
      *((_DWORD *)this + 5) = v6;
    }
  }
  if ( v6 > 0xFFFF )
    return 1359i64;
  *a4 = *((_WORD *)this + 10);
  return 0i64;
}

//----- (0000000180019380) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::GenerateResponse(CSsl3TlsServerContext *this, struct SPBuffer *a2)
{
  int v2; // eax
  unsigned int Restart; // esi
  __int64 v7; // rax
  __int64 *v8; // r14
  CSessionCacheManager *v9; // r15
  __int64 v10; // rbp
  __int64 v11; // r9
  unsigned int v12; // eax
  unsigned int v13; // r8d
  __int64 v14; // rax

  v2 = *((_DWORD *)this + 17);
  Restart = 0;
  switch ( v2 )
  {
    case 94:
      Restart = CSsl3TlsServerContext::GenerateRestart(this, a2);
      if ( !Restart )
        *((_DWORD *)this + 17) = 64;
      break;
    case 93:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 25i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      Restart = CSsl3TlsServerContext::GenerateClientHelloResponse(this, a2);
      if ( !Restart )
        *((_DWORD *)this + 17) = 70;
      break;
    case 4:
      if ( CSslGlobals::m_fDisableRenegoOnServer )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 26i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
        return (unsigned int)-2146893018;
      }
      else
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 27i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
        return (unsigned int)CSsl3TlsServerContext::GenerateHelloRequest(this, a2);
      }
    case 95:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 24i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      Restart = CSsl3TlsServerContext::AllocateAndGenerateNstCcsAndFinish(this, a2);
      if ( !Restart )
      {
        (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 448i64))(this);
        v7 = *((_QWORD *)this + 17);
        if ( (v7 & 0x400000) == 0 && (v7 & 0x8000000) != 0 )
        {
          v8 = (__int64 *)*((_QWORD *)this + 11);
          v9 = CSessionCacheManager::m_pSessionCacheManager;
          if ( v8 )
          {
            v10 = *((_QWORD *)this + 10);
            if ( v10 )
            {
              RtlAcquireResourceExclusive((PRTL_RESOURCE)(v8[28] + 48), 1u);
              RtlAcquireResourceExclusive((PRTL_RESOURCE)(v8 + 9), 1u);
              v12 = *(_DWORD *)(v10 + 208);
              v13 = *((_DWORD *)v8 + 70);
              *((_BYTE *)v8 + 236) = 1;
              if ( v12 < v13 )
                v13 = v12;
              v14 = *v8;
              *((_DWORD *)v8 + 70) = v13;
              LOBYTE(v11) = 1;
              (*(void (__fastcall **)(__int64 *, CSessionCacheManager *, CSsl3TlsServerContext *, __int64))(v14 + 64))(
                v8,
                v9,
                this,
                v11);
              RtlReleaseResource((PRTL_RESOURCE)(v8 + 9));
              RtlReleaseResource((PRTL_RESOURCE)(v8[28] + 48));
            }
          }
        }
      }
      break;
  }
  return Restart;
}
// 180019518: variable 'v11' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800927C0: using guessed type int CSslGlobals::m_fDisableRenegoOnServer;

//----- (0000000180019550) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::GenerateRestart(CSsl3TlsServerContext *this, struct SPBuffer *a2)
{
  char v4; // di
  int v5; // ecx
  __int64 v6; // rax
  int v7; // edx
  __int64 v8; // rax
  __int64 v9; // rax
  unsigned int v10; // edx
  char v11; // r9
  int v12; // eax
  __int16 v13; // di
  unsigned int v14; // r10d
  int v15; // r11d
  int v16; // r8d
  int v17; // ecx
  int v18; // eax
  _BYTE *v19; // r13
  unsigned int v20; // edx
  __int64 v21; // rcx
  int v22; // eax
  __int64 v23; // rax
  int v24; // edx
  int v25; // r8d
  const unsigned __int8 near *v26; // rax
  __int64 v27; // rax
  __int64 v28; // rcx
  __int64 v29; // r15
  __int64 v30; // rcx
  __int64 v31; // rax
  __int64 v32; // rax
  int SessionKeys; // eax
  unsigned int v34; // edi
  __int64 *v35; // rax
  __int64 v36; // rcx
  __int64 v37; // rax
  __int64 v38; // r9
  unsigned int v39; // r14d
  unsigned int v41; // ecx
  unsigned int v42; // r8d
  unsigned int v43; // ecx
  unsigned int v44; // r8d
  unsigned int v45; // ecx
  unsigned int v46; // r9d
  _BYTE *Memory; // rax
  int v48; // edx
  CCipherMill *v49; // rcx
  __int64 v50; // rdx
  int v51; // edx
  __int16 v52; // cx
  unsigned int v53; // [rsp+40h] [rbp-79h]
  int v54; // [rsp+44h] [rbp-75h]
  unsigned int v55; // [rsp+48h] [rbp-71h] BYREF
  void **v56; // [rsp+50h] [rbp-69h] BYREF
  CSsl3TlsServerContext *v57; // [rsp+58h] [rbp-61h]
  __int64 v58; // [rsp+60h] [rbp-59h]
  int v59; // [rsp+68h] [rbp-51h]
  CSsl3TlsServerContext *v60; // [rsp+70h] [rbp-49h]
  __time32_t Time; // [rsp+78h] [rbp-41h] BYREF
  int v62[2]; // [rsp+80h] [rbp-39h] BYREF
  char *v63; // [rsp+88h] [rbp-31h]
  char v64; // [rsp+90h] [rbp-29h] BYREF

  if ( (*((_BYTE *)this + 32) & 4) != 0 )
    v54 = *((_DWORD *)this + 11);
  else
    v54 = 0;
  v53 = 5;
  if ( *((_BYTE *)this + 233) )
    v53 = 13;
  v4 = *((_BYTE *)this + 553);
  v56 = &CTlsExtServer::`vftable';
  v5 = 0;
  v57 = this;
  v58 = 0i64;
  v59 = 0;
  v60 = this;
  if ( *((_BYTE *)this + 922) )
  {
    v5 = 6;
    BYTE1(v59) = 1;
    HIDWORD(v58) = 6;
  }
  if ( (*((_DWORD *)this + 34) & 0x400000) != 0 )
    HIDWORD(v58) = v5 + 4;
  v6 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 88i64))(this);
  if ( v6 && *(_DWORD *)v6 == 1 && *(_DWORD *)(v6 + 4) == 2 )
  {
    v7 = HIDWORD(v58) + 7 + *(unsigned __int8 *)(v6 + 8);
    HIDWORD(v58) = v7;
  }
  else
  {
    v7 = HIDWORD(v58);
  }
  if ( (*((_DWORD *)v57 + 34) & 0x8000000) != 0 )
    HIDWORD(v58) = v7 + 4;
  v8 = (*(__int64 (**)(void))(*(_QWORD *)v57 + 96i64))();
  if ( v8 )
    HIDWORD(v58) += 9 + *(unsigned __int8 *)(v8 + 2);
  v9 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)v57 + 104i64))(v57);
  if ( v9 )
  {
    v10 = HIDWORD(v58) + 7 + *(unsigned __int8 *)(v9 + 2);
    HIDWORD(v58) = v10;
  }
  else
  {
    v10 = HIDWORD(v58);
  }
  if ( v4 )
  {
    BYTE2(v59) = 1;
    v10 += *((_DWORD *)v57 + 104) + *((_DWORD *)v57 + 114) + 5;
    HIDWORD(v58) = v10;
  }
  if ( (*((_DWORD *)v57 + 34) & 0x200000) != 0 )
  {
    v10 += 4;
    HIDWORD(v58) = v10;
  }
  if ( v10 )
  {
    v10 += 2;
    HIDWORD(v58) = v10;
  }
  if ( v10 > 0xFFFF )
  {
    v49 = WPP_GLOBAL_Control;
    v34 = 1359;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return v34;
    v50 = 43i64;
    goto LABEL_110;
  }
  v11 = *((_BYTE *)this + 233);
  v12 = 4;
  if ( v11 )
    v12 = 12;
  v13 = *((_WORD *)this + 16);
  v14 = (unsigned __int16)v10 + v12 + 70;
  v55 = v14;
  if ( (v13 & 4) != 0 )
  {
    v41 = *((_DWORD *)this + 13);
    v42 = v14 + *((_DWORD *)this + 12);
    if ( v41 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v41 -= v42 % v41;
      v42 += v41;
    }
    v43 = *((_DWORD *)this + 13);
    v14 = v42 + *((_DWORD *)this + 11);
    v15 = *((_DWORD *)this + 15);
    v44 = *((_DWORD *)this + 12) + 1;
    if ( v43 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v43 -= v44 % v43;
      v44 += v43;
    }
    v16 = *((_DWORD *)this + 11) + v44;
  }
  else
  {
    v15 = *((_DWORD *)this + 15);
    v16 = 1;
  }
  if ( (*((_BYTE *)this + 64) & 0x30) != 0 )
  {
    v17 = 48;
    v18 = 40;
  }
  else
  {
    v17 = 24;
    v18 = 16;
  }
  if ( !v11 )
    v17 = v18;
  if ( (v13 & 1) != 0 )
  {
    v45 = *((_DWORD *)this + 12) + v17;
    v46 = *((_DWORD *)this + 13);
    if ( v46 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v46 -= v45 % v46;
      v45 += v46;
    }
    v17 = *((_DWORD *)this + 11) + v45;
  }
  v19 = (_BYTE *)*((_QWORD *)a2 + 1);
  v20 = v14 + v17 + v15 + v16 + 2 * v15;
  if ( v19 )
  {
    if ( *(_DWORD *)a2 < v20 )
    {
      *((_DWORD *)a2 + 1) = v20;
      return (unsigned int)-2146893023;
    }
  }
  else
  {
    *(_DWORD *)a2 = v20;
    Memory = CSslContext::GetMemory(this, v20);
    *((_QWORD *)a2 + 1) = Memory;
    v19 = Memory;
    if ( !Memory )
      return 14;
  }
  *((_DWORD *)a2 + 1) = 0;
  time32_0(&Time);
  v21 = 304i64;
  if ( (*((_DWORD *)this + 16) & 0xA2AA0) != 0 )
    v21 = 272i64;
  *(_DWORD *)((char *)this + v21) = _byteswap_ulong(Time);
  v22 = BCryptGenRandom(0i64, (PUCHAR)this + v21 + 4, 0x1Cu, 2u);
  if ( v22 < 0 )
  {
    v34 = RtlNtStatusToDosError(v22);
    if ( v34 )
      return v34;
  }
  v23 = *((_QWORD *)this + 10);
  if ( v23 )
  {
    v24 = *(_DWORD *)(v23 + 152);
    v25 = *((_DWORD *)this + 16);
    if ( (v24 & 0x1000) != 0 && (v25 & 0x400) != 0 )
    {
      v26 = CSsl3TlsContext::m_rgbTls12Downgrade;
LABEL_44:
      *((_QWORD *)this + 41) = v26;
      goto LABEL_45;
    }
    if ( *((_BYTE *)this + 233) )
    {
      if ( (v24 & 0x40000) == 0 || (v25 & 0x40000) != 0 )
        goto LABEL_45;
    }
    else if ( (v24 & 0x1400) == 0 || (v25 & 0x1400) != 0 )
    {
      goto LABEL_45;
    }
    v26 = CSsl3TlsContext::m_rgbTls11OrBelowDowngrade;
    goto LABEL_44;
  }
LABEL_45:
  RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)this + 124) + 72i64), 1u);
  v27 = *((_QWORD *)this + 124);
  v28 = *((_QWORD *)this + 20);
  Time = 0;
  v29 = *(_QWORD *)(v27 + 16);
  if ( v28 )
  {
    SslFreeObject(v28, 0i64);
    *((_QWORD *)this + 20) = 0i64;
  }
  v30 = *((_QWORD *)this + 21);
  if ( v30 )
  {
    SslFreeObject(v30, 0i64);
    v30 = 0i64;
    *((_QWORD *)this + 21) = 0i64;
  }
  if ( (*((_BYTE *)this + 32) & 1) != 0 )
  {
    v31 = *((_QWORD *)this + 1);
    if ( v31 )
    {
      if ( *(_DWORD *)(v31 + 28) )
      {
        v62[0] = v30;
        v63 = &v64;
        v32 = *(_QWORD *)this;
        v62[1] = 4;
        SessionKeys = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, _QWORD, __time32_t *, int *, __int64, __int64))(v32 + 128))(
                        this,
                        0i64,
                        &Time,
                        v62,
                        v30,
                        v30);
        v34 = SessionKeys;
        if ( SessionKeys )
        {
          v48 = 601;
        }
        else
        {
          v35 = (__int64 *)*((_QWORD *)this + 1);
          if ( v35 )
            v36 = *v35;
          else
            v36 = 0i64;
          SessionKeys = SslGenerateSessionKeys(v36, v29, (char *)this + 160, (char *)this + 168, v62, 0);
          v34 = SessionKeys;
          if ( !SessionKeys )
            goto LABEL_56;
          v48 = 600;
        }
        CSslContext::SetErrorAndFatalAlert((__int64)this, v48, SessionKeys, 0x33u);
        RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 124) + 72i64));
        v49 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return v34;
        v50 = 44i64;
LABEL_110:
        WPP_SF_D(*((_QWORD *)v49 + 2), v50, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids, v34);
        return v34;
      }
    }
  }
LABEL_56:
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 124) + 72i64));
  v34 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, _QWORD))(*(_QWORD *)this + 496i64))(this, 0i64);
  if ( v34 )
    return v34;
  v37 = *(_QWORD *)this;
  *((_BYTE *)this + 340) = 0;
  v34 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, _QWORD, _QWORD, _QWORD))(v37 + 504))(
          this,
          *((_QWORD *)this + 110),
          *((unsigned int *)this + 218),
          0i64);
  if ( *((_QWORD *)this + 110) )
  {
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 110) = 0i64;
  }
  *((_DWORD *)this + 218) = 0;
  if ( v34 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 1007, v34, 0x50u);
    return v34;
  }
  v34 = CSsl3TlsServerContext::GenerateServerHello(this, &v19[v53 + v54], &v55, (struct CTlsExtServer *)&v56);
  if ( v34 )
  {
    v49 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return v34;
    v50 = 45i64;
    goto LABEL_110;
  }
  v39 = v55;
  LOBYTE(v38) = 1;
  v34 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, _BYTE *, _QWORD, __int64))(*(_QWORD *)this + 504i64))(
          this,
          &v19[v53 + v54],
          v55,
          v38);
  if ( v34 )
  {
    v51 = 1006;
  }
  else
  {
    if ( *((_BYTE *)this + 233) )
      goto LABEL_106;
    v34 = CSsl3TlsContext::WrapMessage((__int64)this, (__int64)a2, 22, v39);
    if ( !v34 )
    {
      if ( !*((_BYTE *)this + 233) )
        return CSsl3TlsContext::GenerateCcsAndFinishMessage(this, a2);
LABEL_106:
      *((_DWORD *)a2 + 1) += v39 + v54 + v53;
      v52 = *((_WORD *)this + 17);
      v19[12] = v39;
      v19[11] = BYTE1(v39);
      v19[1] = HIBYTE(v52);
      v19[2] = v52;
      *v19 = 22;
      return CSsl3TlsContext::GenerateCcsAndFinishMessage(this, a2);
    }
    v51 = 954;
  }
  CSslContext::SetErrorAndFatalAlert((__int64)this, v51, v34, 0x50u);
  return v34;
}
// 1800199E7: variable 'v38' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 18007C320: using guessed type void *CTlsExtServer::`vftable';
// 180082BB8: using guessed type const unsigned __int8 near *const CSsl3TlsContext::m_rgbTls11OrBelowDowngrade;
// 180082BC0: using guessed type const unsigned __int8 near *const CSsl3TlsContext::m_rgbTls12Downgrade;
// 180098428: using guessed type __int64 __fastcall SslGenerateSessionKeys(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180019B10) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::TlsParseClientHello(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned __int8 *a3,
        unsigned __int8 *const a4,
        unsigned int *a5,
        unsigned int **a6,
        unsigned int *a7)
{
  CSsl3TlsServerContext *v7; // r14
  unsigned int v8; // ecx
  __int64 v9; // rax
  bool v10; // r12
  __int64 v11; // rsi
  unsigned __int8 *v12; // rbx
  int v13; // edi
  unsigned __int8 *v14; // rbx
  unsigned int v15; // edi
  int v16; // eax
  unsigned int v17; // r15d
  unsigned __int8 *v18; // rbx
  unsigned int v19; // edi
  unsigned int v20; // ebp
  unsigned int **v21; // r11
  unsigned __int8 *v22; // r13
  unsigned int v23; // r10d
  unsigned int v24; // eax
  __int64 v25; // rsi
  unsigned int v26; // r14d
  unsigned int v27; // edi
  unsigned __int8 *v28; // rbx
  unsigned __int8 *v29; // rdx
  __int64 v30; // rcx
  _BYTE *v31; // rbx
  unsigned int v32; // edi
  unsigned int v33; // eax
  unsigned int v34; // edi
  int v35; // ebx
  unsigned int v36; // ebx
  char v37; // r12
  unsigned __int8 v38; // r15
  unsigned __int8 *v39; // rdi
  char v40; // r12
  CCipherMill *v41; // r10
  unsigned __int16 v42; // si
  unsigned int v43; // r14d
  unsigned __int8 *v44; // rdi
  unsigned int v45; // ebx
  unsigned int v46; // eax
  unsigned int v47; // esi
  __int64 result; // rax
  __int64 v49; // rcx
  unsigned int v50; // edi
  CCipherMill *v51; // rcx
  __int64 v52; // rdx
  unsigned int *Memory; // [rsp+30h] [rbp-68h]
  void **v54; // [rsp+38h] [rbp-60h] BYREF
  CSsl3TlsServerContext *v55; // [rsp+40h] [rbp-58h]
  int v56; // [rsp+48h] [rbp-50h]
  int v57; // [rsp+4Ch] [rbp-4Ch]
  __int16 v58; // [rsp+50h] [rbp-48h]
  char v59; // [rsp+52h] [rbp-46h]
  char v60; // [rsp+53h] [rbp-45h]
  CSsl3TlsServerContext *v61; // [rsp+58h] [rbp-40h]
  char v63; // [rsp+B0h] [rbp+18h]

  v63 = 0;
  *((_BYTE *)this + 554) = 0;
  v7 = this;
  if ( (unsigned int)a3 < 2 )
    goto LABEL_55;
  v8 = a2[1] + (*a2 << 8);
  if ( v8 < 0x300 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)v7, 1201, -2146893048, 0x46u);
    goto LABEL_55;
  }
  v9 = *((_QWORD *)v7 + 15);
  v10 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
  *((_DWORD *)v7 + 9) = v8;
  if ( v9 && v10 )
    *(_DWORD *)(v9 + 44) = v8;
  if ( (unsigned int)((_DWORD)a3 - 2) < 0x20 )
    goto LABEL_55;
  *((_OWORD *)v7 + 17) = *(_OWORD *)(a2 + 2);
  *((_OWORD *)v7 + 18) = *(_OWORD *)(a2 + 18);
  if ( (_DWORD)a3 == 34 )
    goto LABEL_55;
  v11 = a2[34];
  if ( (unsigned int)v11 > 0x20 )
    goto LABEL_55;
  v12 = a2 + 35;
  v13 = (_DWORD)a3 - 35;
  if ( (int)a3 - 35 < (unsigned int)v11 )
    goto LABEL_55;
  if ( a2[34] )
    memcpy_0(a4, v12, a2[34]);
  v14 = &v12[v11];
  v15 = v13 - v11;
  *a5 = v11;
  if ( *((_BYTE *)v7 + 233) )
  {
    if ( !v15 )
      goto LABEL_55;
    v49 = *v14;
    if ( (unsigned int)v49 > 0x20 )
      goto LABEL_55;
    v50 = v15 - 1;
    if ( v50 < (unsigned int)v49 )
      goto LABEL_55;
    v14 += v49 + 1;
    v15 = v50 - v49;
  }
  if ( v15 < 2 || (v16 = v14[1], v17 = v16 + (*v14 << 8), (v16 & 1) != 0) || (v18 = v14 + 2, v19 = v15 - 2, v19 < v17) )
  {
LABEL_55:
    v47 = -2146893048;
    v23 = 0;
    goto LABEL_51;
  }
  v20 = v17 >> 1;
  if ( v17 >> 1 > *a7 )
  {
    Memory = (unsigned int *)CSslContext::GetMemory(v7, 4 * v20);
    v22 = (unsigned __int8 *)Memory;
    if ( Memory )
    {
      v10 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
      v21 = a6;
      goto LABEL_18;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_d(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x36u,
        (__int64)&WPP_095c39149c3f336b5b94efe855075ae2_Traceguids,
        4 * v20);
      v23 = 0;
      v47 = -2146893048;
      goto LABEL_51;
    }
    goto LABEL_55;
  }
  v21 = a6;
  v22 = (unsigned __int8 *)*a6;
  Memory = *a6;
LABEL_18:
  v23 = 0;
  v24 = 0;
  if ( v20 )
  {
    a4 = v22;
    do
    {
      a3 = (unsigned __int8 *)(v18[2 * v24 + 1] | (v18[2 * v24] << 8));
      *(_DWORD *)a4 = (_DWORD)a3;
      if ( (_DWORD)a3 == 255 )
      {
        if ( *((_DWORD *)v7 + 104) )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 55i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
          }
          CSslContext::SetErrorAndFatalAlert((__int64)v7, 1207, -2146892986, 0x28u);
          *((_DWORD *)v7 + 17) = 96;
          v47 = -2146892986;
          *((_WORD *)v7 + 48) = 10242;
          goto LABEL_82;
        }
        *((_BYTE *)v7 + 553) = 1;
        v63 = 1;
      }
      ++v24;
      a4 += 4;
    }
    while ( v24 < v20 );
  }
  v25 = *((_QWORD *)v7 + 15);
  v26 = v17 >> 1;
  if ( v25 && v10 )
  {
    *(_DWORD *)(v25 + 1580) = v20;
    if ( v20 > 0x64 )
      v26 = 100;
    memcpy_0((void *)(v25 + 1176), v22, 4i64 * v26);
    v21 = a6;
    v23 = 0;
    *(_WORD *)(v25 + 1576) = v26;
  }
  v27 = v19 - v17;
  v28 = &v18[v17];
  v29 = v28;
  if ( !v27 )
  {
    v7 = this;
    v47 = -2146893048;
    goto LABEL_83;
  }
  v30 = *v28;
  if ( !*v28 )
  {
    v7 = this;
    v47 = -2146893048;
    goto LABEL_83;
  }
  v31 = v28 + 1;
  v32 = v27 - 1;
  if ( v32 < (unsigned int)v30 )
  {
    v7 = this;
    v47 = -2146893048;
    goto LABEL_83;
  }
  v33 = 0;
  while ( *v31 )
  {
    ++v33;
    ++v31;
    if ( v33 >= (unsigned int)v30 )
    {
      if ( v33 == (_DWORD)v30 )
      {
        v7 = this;
        v47 = -2146893048;
        goto LABEL_83;
      }
      break;
    }
  }
  v34 = v32 - v30;
  if ( v34 < 2 )
    goto LABEL_47;
  v7 = this;
  v35 = v29[v30 + 1];
  v54 = &CTlsExtServer::`vftable';
  v36 = v29[v30 + 2] | (v35 << 8);
  v55 = this;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  v61 = this;
  if ( v34 - 2 < v36 )
  {
LABEL_48:
    v47 = 0;
    goto LABEL_49;
  }
  v37 = *((_BYTE *)this + 64);
  v38 = 0;
  v56 = 1;
  v39 = &v29[v30 + 3];
  *((_BYTE *)this + 922) = 0;
  v40 = v37 & 0x30;
  v60 = 0;
  if ( !v36 )
  {
LABEL_46:
    (*(void (__fastcall **)(CSsl3TlsServerContext *, _QWORD, unsigned __int8 *, unsigned __int8 *const))(*(_QWORD *)v55 + 352i64))(
      v55,
      v38,
      a3,
      a4);
LABEL_47:
    v7 = this;
    goto LABEL_48;
  }
  v41 = WPP_GLOBAL_Control;
  while ( 1 )
  {
    if ( v36 < 4 )
      goto LABEL_89;
    v42 = _byteswap_ushort(*((_WORD *)v39 + 1));
    v43 = v39[1] | (*v39 << 8);
    if ( v41 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v41 + 28) & 4) != 0 )
    {
      WPP_SF_D(*((_QWORD *)v41 + 2), 73i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids, v43);
      v41 = WPP_GLOBAL_Control;
    }
    v44 = v39 + 4;
    v45 = v36 - 4;
    if ( v45 < v42 )
    {
      if ( v41 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v41 + 28) & 2) != 0 )
        WPP_SF_(*((_QWORD *)v41 + 2), 74i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
LABEL_89:
      v47 = -2146893018;
      goto LABEL_90;
    }
    a3 = v44;
    v39 = &v44[v42];
    v36 = v45 - v42;
    if ( !v40 || v43 == 65281 )
      break;
LABEL_45:
    if ( !v36 )
      goto LABEL_46;
  }
  v46 = ((__int64 (__fastcall *)(void ***, _QWORD, unsigned __int8 *, _QWORD))v54[1])(&v54, v43, a3, v42);
  v47 = v46;
  if ( !v46 )
  {
    v41 = WPP_GLOBAL_Control;
    if ( v43 == 65281 )
      v38 = 1;
    goto LABEL_45;
  }
  if ( v46 == -2146892986 || v46 == -2146892953 )
  {
    v7 = this;
    goto LABEL_81;
  }
LABEL_90:
  v7 = this;
  CSslContext::SetErrorAndFatalAlert((__int64)this, 1202, -2146893048, 0xAu);
LABEL_81:
  if ( !v47 )
  {
LABEL_49:
    if ( !*((_BYTE *)v7 + 554) && !v63 )
    {
      if ( !g_fAllowInsecureRenegoClients )
      {
        v51 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          goto LABEL_101;
        v52 = 56i64;
LABEL_100:
        WPP_SF_(*((_QWORD *)v51 + 2), v52, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
LABEL_101:
        CSslContext::SetErrorAndFatalAlert((__int64)v7, 1207, -2146892986, 0x28u);
        result = 2148074310i64;
        *((_DWORD *)v7 + 17) = 96;
        *((_WORD *)v7 + 48) = 10242;
        return result;
      }
      if ( *((_BYTE *)v7 + 553) )
      {
        v51 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          goto LABEL_101;
        v52 = 57i64;
        goto LABEL_100;
      }
    }
    v23 = v20;
    *a6 = Memory;
    goto LABEL_51;
  }
LABEL_82:
  v21 = a6;
  v23 = 0;
  v22 = (unsigned __int8 *)Memory;
LABEL_83:
  if ( v22 && v22 != (unsigned __int8 *)*v21 )
  {
    (*(void (__fastcall **)(CSsl3TlsServerContext *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *const))(*(_QWORD *)v7 + 16i64))(
      v7,
      v22,
      a3,
      a4);
    v23 = 0;
  }
LABEL_51:
  result = v47;
  *a7 = v23;
  return result;
}
// 180019E70: variable 'a3' is possibly undefined
// 180019E70: variable 'a4' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 18007C320: using guessed type void *CTlsExtServer::`vftable';
// 1800919AC: using guessed type int g_fAllowInsecureRenegoClients;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180019EE0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::GenerateServerHello(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned int *a3,
        struct CTlsExtServer *a4)
{
  int v8; // r15d
  unsigned int v9; // r10d
  char v10; // r8
  int v11; // edx
  int v12; // eax
  unsigned int v13; // eax
  unsigned int v14; // edi
  unsigned __int8 *v15; // rbx
  int v16; // edx
  char v17; // al
  char v18; // cl
  unsigned int v19; // edi
  unsigned int v20; // r14d
  __int64 v21; // rdx
  char *v22; // rbx
  unsigned int v23; // edi
  char *v24; // rbx
  __int64 v25; // rax
  unsigned int v26; // edi
  unsigned int v27; // eax
  __int64 result; // rax
  __int16 v29; // r8
  unsigned int v30; // ecx
  unsigned int v31; // ecx
  bool v32; // zf
  unsigned int v33; // eax
  __int64 v34; // rcx
  __int64 v35; // rdx
  __int64 v36; // rax
  _DWORD *v37; // rcx
  __int64 v38; // rax
  __int64 v39; // rax
  int v40; // [rsp+20h] [rbp-38h]
  unsigned int v41; // [rsp+24h] [rbp-34h]
  unsigned int v42; // [rsp+68h] [rbp+10h] BYREF

  if ( !a2 || !a3 )
    return 87i64;
  LOWORD(v8) = 0;
  LOWORD(v9) = 0;
  if ( a4 )
  {
    v9 = *((_DWORD *)a4 + 5);
    if ( !v9 )
    {
      v34 = *((_QWORD *)a4 + 1);
      v35 = 0i64;
      if ( *(_BYTE *)(v34 + 922) )
      {
        v35 = 6i64;
        *((_BYTE *)a4 + 25) = 1;
        *((_DWORD *)a4 + 5) = 6;
      }
      if ( (*(_DWORD *)(v34 + 136) & 0x400000) != 0 )
        *((_DWORD *)a4 + 5) = v35 + 4;
      v36 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v34 + 88i64))(v34, v35);
      if ( v36 && *(_DWORD *)v36 == 1 && *(_DWORD *)(v36 + 4) == 2 )
        *((_DWORD *)a4 + 5) += *(unsigned __int8 *)(v36 + 8) + 7;
      v37 = (_DWORD *)*((_QWORD *)a4 + 1);
      if ( (v37[34] & 0x8000000) != 0 )
        *((_DWORD *)a4 + 5) += 4;
      v38 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v37 + 96i64))(v37);
      if ( v38 )
        *((_DWORD *)a4 + 5) += *(unsigned __int8 *)(v38 + 2) + 9;
      v39 = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)a4 + 1) + 104i64))(*((_QWORD *)a4 + 1));
      if ( v39 )
        *((_DWORD *)a4 + 5) += *(unsigned __int8 *)(v39 + 2) + 7;
      v9 = *((_DWORD *)a4 + 5);
      if ( (*(_DWORD *)(*((_QWORD *)a4 + 1) + 136i64) & 0x200000) != 0 )
      {
        v9 += 4;
        *((_DWORD *)a4 + 5) = v9;
      }
      if ( v9 )
      {
        v9 += 2;
        *((_DWORD *)a4 + 5) = v9;
      }
    }
    if ( v9 > 0xFFFF )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 50i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids, 1359i64);
      return 1359i64;
    }
  }
  v10 = *((_BYTE *)this + 233);
  v11 = 4;
  v12 = 4;
  v40 = 4;
  if ( v10 )
    v12 = 12;
  v13 = (unsigned __int16)v9 + v12 + 70;
  v41 = v13;
  if ( *a3 < v13 )
  {
    *a3 = v13;
    return 234i64;
  }
  if ( v10 )
  {
    v11 = 12;
    v40 = 12;
  }
  v14 = v13 - v11;
  v15 = &a2[v11];
  v16 = *((_DWORD *)this + 16);
  if ( (v16 & 0x3FFC) != 0 && (v16 & 0xF0000) != 0 )
    goto LABEL_63;
  if ( (v16 & 0xC0000) != 0 )
  {
    v17 = -3;
    v18 = -2;
    goto LABEL_17;
  }
  if ( (v16 & 0x30000) != 0 )
  {
    v17 = -1;
    v18 = -2;
    goto LABEL_17;
  }
  if ( (v16 & 0x3000) != 0 )
  {
    v17 = 4;
LABEL_66:
    v18 = 3;
    goto LABEL_17;
  }
  if ( (v16 & 0xC00) == 0 )
  {
    if ( (v16 & 0x300) != 0 )
    {
      v17 = 2;
      goto LABEL_66;
    }
    if ( (v16 & 0xC0) != 0 )
    {
LABEL_65:
      v17 = 1;
      goto LABEL_66;
    }
    if ( (v16 & 0x30) != 0 )
    {
      v17 = 0;
      goto LABEL_66;
    }
    if ( (v16 & 0xC) != 0 )
    {
      v17 = 2;
      v18 = 0;
      goto LABEL_17;
    }
LABEL_63:
    if ( v10 )
    {
      v17 = -1;
      v18 = -2;
      goto LABEL_17;
    }
    goto LABEL_65;
  }
  v17 = 3;
  v18 = 3;
LABEL_17:
  *v15 = v18;
  v19 = v14 - 35;
  v15[1] = v17;
  v20 = v19;
  *(_OWORD *)(v15 + 2) = *((_OWORD *)this + 19);
  *(_OWORD *)(v15 + 18) = *((_OWORD *)this + 20);
  v21 = *((_QWORD *)this + 124);
  v22 = (char *)(v15 + 35);
  if ( v19 >= *(unsigned __int16 *)(v21 + 238) )
  {
    v20 = *(unsigned __int16 *)(v21 + 238);
    memcpy_0(v22, (const void *)(v21 + 240), *(unsigned __int16 *)(v21 + 238));
  }
  *(v22 - 1) = v20;
  v23 = v19 - v20;
  v24 = &v22[v20];
  if ( (*((_BYTE *)this + 32) & 1) != 0 )
  {
    v25 = *((_QWORD *)this + 1);
    if ( v25 )
      v8 = *(_DWORD *)(v25 + 28);
  }
  v26 = v23 - 3;
  *v24 = BYTE1(v8);
  v27 = v26;
  v24[1] = v8;
  v24[2] = 0;
  v42 = v26;
  if ( a4 && v26 )
  {
    result = CTlsExtServer::BuildServerHelloExtension(a4, v26, (unsigned __int8 *)v24 + 3, &v42);
    if ( (_DWORD)result )
      return result;
    v27 = v42;
  }
  v29 = *((_WORD *)this + 110);
  v30 = v27 - v26 + v41;
  *a3 = v30;
  v31 = v30 - v40;
  *((_WORD *)this + 110) = v29 + 1;
  v32 = *((_BYTE *)this + 233) == 0;
  *a2 = 2;
  if ( v32 )
  {
    v33 = HIWORD(v31);
  }
  else
  {
    a2[5] = v29;
    v33 = HIWORD(v31);
    a2[9] = BYTE2(v31);
    a2[4] = HIBYTE(v29);
    *(_WORD *)(a2 + 7) = 0;
    a2[6] = 0;
    a2[11] = v31;
    a2[10] = BYTE1(v31);
  }
  a2[1] = v33;
  result = 0i64;
  a2[3] = v31;
  a2[2] = BYTE1(v31);
  return result;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018001A100) ----------------------------------------------------
__int64 __fastcall CTlsExtServer::BuildServerHelloExtension(
        CTlsExtServer *this,
        unsigned int a2,
        unsigned __int8 *a3,
        unsigned int *a4)
{
  unsigned __int8 *v5; // rbp
  unsigned int v6; // eax
  unsigned __int8 *v7; // rdi
  unsigned __int8 *v8; // rdx
  unsigned __int8 v9; // al
  _DWORD *v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rsi
  _BOOL8 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // rax
  __int64 v16; // rax
  unsigned __int16 *v17; // rax
  __int64 v18; // rax
  __int64 v19; // rsi
  unsigned int *v20; // rax
  __int64 v21; // r9
  const void *v22; // r12
  __int64 v23; // r10
  const void *v24; // r15
  size_t v25; // rsi
  size_t v26; // r14
  __int16 v27; // ax
  unsigned __int8 v28; // r9
  char *v29; // rdi
  char *v30; // rdi
  __int64 v31; // rcx
  __int64 result; // rax
  __int16 v33; // dx
  unsigned __int16 v34; // dx
  __int64 v35; // rax
  __int64 v36; // rcx
  __int64 v37; // rcx
  __int64 v38; // rcx
  size_t v39; // r14
  int v40; // esi
  const void *v41; // r15
  unsigned __int8 *v42; // rsi
  __int64 v43; // rcx
  CTlsExt *v44; // rcx
  __int64 v45; // [rsp+20h] [rbp-48h]
  unsigned __int8 *v46; // [rsp+80h] [rbp+18h] BYREF

  v5 = &a3[a2];
  if ( !a3 || !a4 )
    return 87i64;
  v6 = *((_DWORD *)this + 5);
  *a4 = v6;
  if ( !v6 )
    return 0i64;
  if ( a2 < v6 )
    return 234i64;
  v7 = a3 + 2;
  v8 = a3 + 2;
  *a3 = (unsigned __int16)(v6 - 2) >> 8;
  v9 = *((_BYTE *)this + 20) - 2;
  v46 = a3 + 2;
  a3[1] = v9;
  if ( *((_BYTE *)this + 24) )
  {
    *(_WORD *)v7 = 1280;
    v37 = *((_QWORD *)this + 1);
    v7 = a3 + 6;
    v46 = a3 + 6;
    CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v37 + 120), 0, 5);
    v8 = v7;
  }
  if ( *((_BYTE *)this + 25) )
  {
    *v7 = 0;
    v7 = v8 + 6;
    *(_DWORD *)(v8 + 1) = 16908294;
    v8[5] = 64;
    v38 = *((_QWORD *)this + 1);
    v46 = v8 + 6;
    CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v38 + 120), 0, 6);
    v8 = v7;
  }
  v10 = (_DWORD *)*((_QWORD *)this + 1);
  if ( (v10[34] & 0x400000) != 0 )
  {
    *v7 = 0;
    v7 = v8 + 4;
    v46 = v8 + 4;
    v8[1] = 35;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 17i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
    CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 35);
    v10 = (_DWORD *)*((_QWORD *)this + 1);
  }
  v11 = (*(__int64 (__fastcall **)(_DWORD *, unsigned __int8 *))(*(_QWORD *)v10 + 88i64))(v10, v8);
  v12 = v11;
  if ( !v11 || *(_DWORD *)v11 != 1 || *(_DWORD *)(v11 + 4) != 2 )
    goto LABEL_11;
  v33 = *(unsigned __int8 *)(v11 + 8);
  *(_WORD *)v7 = 4096;
  v34 = v33 + 1;
  v7[2] = (unsigned __int16)(v34 + 2) >> 8;
  v7[3] = v34 + 2;
  v7[4] = HIBYTE(v34);
  v7[5] = v34;
  v7[6] = *(_BYTE *)(v11 + 8);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids, v34);
  memcpy_0(v7 + 7, (const void *)(v12 + 9), *(unsigned __int8 *)(v12 + 8));
  v35 = *((_QWORD *)this + 1);
  v7 += *(unsigned __int8 *)(v12 + 8) + 7;
  v46 = v7;
  v36 = *(_QWORD *)(v35 + 120);
  if ( v36 )
  {
    v13 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
    if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
      *(_DWORD *)(v36 + 68) |= 0x800u;
  }
  else
  {
LABEL_11:
    v13 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
  }
  v14 = *((_QWORD *)this + 1);
  if ( (*(_DWORD *)(v14 + 136) & 0x8000000) != 0 )
  {
    *(_WORD *)v7 = 5888;
    v7 += 4;
    v46 = v7;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 19i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
      v13 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
    }
    v14 = *((_QWORD *)this + 1);
    v15 = *(_QWORD *)(v14 + 120);
    if ( v15 && v13 )
    {
      *(_WORD *)(v15 + 66) |= 2u;
      v14 = *((_QWORD *)this + 1);
    }
    v16 = *(_QWORD *)(v14 + 120);
    if ( v16 && v13 )
    {
      *(_DWORD *)(v16 + 68) |= 0x1000u;
      v14 = *((_QWORD *)this + 1);
    }
  }
  v17 = (unsigned __int16 *)(*(__int64 (__fastcall **)(__int64, _BOOL8))(*(_QWORD *)v14 + 96i64))(v14, v13);
  if ( v17 )
  {
    v39 = *((unsigned __int8 *)v17 + 2);
    v40 = *v17;
    v41 = (const void *)*((_QWORD *)v17 + 1);
    *(_WORD *)v7 = 3584;
    v7[2] = (unsigned __int16)(v39 + 5) >> 8;
    v7[3] = v39 + 5;
    *((_WORD *)v7 + 2) = 512;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x14u,
        (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
        v40,
        v39);
    *((_WORD *)v7 + 3) = v40;
    v42 = v7 + 9;
    v7[8] = v39;
    if ( v41 )
      memcpy_0(v7 + 9, v41, v39);
    v43 = *((_QWORD *)this + 1);
    v7 = &v42[v39];
    v46 = &v42[v39];
    CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v43 + 120), 0, 14);
  }
  v18 = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 1) + 104i64))(*((_QWORD *)this + 1));
  v19 = v18;
  if ( v18 )
  {
    v44 = (CTlsExt *)*((_QWORD *)this + 4);
    if ( (*((_DWORD *)v44 + 16) & 0x1000) != 0
      || *((_BYTE *)this + 26) && (v44 = (CTlsExt *)*((_QWORD *)this + 1), (*((_DWORD *)v44 + 34) & 0x8000000) != 0) )
    {
      result = CTlsExt::BuildTBExtension(
                 v44,
                 *(_BYTE *)v18,
                 *(_BYTE *)(v18 + 1),
                 *(unsigned __int8 *const *)(v18 + 8),
                 *(_BYTE *)(v18 + 2),
                 v5,
                 &v46);
      if ( (_DWORD)result )
        return result;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          22i64,
          &WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
          *(unsigned __int16 *)(v19 + 2));
      CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 24);
      v7 = v46;
    }
    else
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 21i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
      CSsl3TlsContext::FreeSelectedTBParameters(*((CSsl3TlsContext **)this + 1));
    }
  }
  if ( !*((_BYTE *)this + 26) )
    goto LABEL_36;
  v20 = (unsigned int *)*((_QWORD *)this + 1);
  v21 = v20[104];
  v22 = (char *)v20 + 377;
  v23 = v20[114];
  v24 = v20 + 105;
  if ( (_DWORD)v21 == (_DWORD)v23 )
  {
    v25 = (unsigned int)v23;
    v26 = (unsigned int)v21;
    if ( &v7[v23 + 5 + v21] <= v5 )
    {
      *(_WORD *)v7 = 511;
      v27 = v23 + v21 + 1;
      v28 = v23 + v21;
      v7[2] = HIBYTE(v27);
      v7[3] = v28 + 1;
      v7[4] = v28;
      v29 = (char *)(v7 + 5);
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 25i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
      }
      memcpy_0(v29, v22, v26);
      v30 = &v29[v26];
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 26i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
      }
      memcpy_0(v30, v24, v25);
      v7 = (unsigned __int8 *)&v30[v25];
      v31 = *(_QWORD *)(*((_QWORD *)this + 1) + 120i64);
      if ( v31 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
        *(_DWORD *)(v31 + 68) |= 0x10000u;
LABEL_36:
      if ( (*(_DWORD *)(*((_QWORD *)this + 1) + 136i64) & 0x200000) != 0 )
      {
        *(_DWORD *)v7 = 0;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 0);
      }
      return 0i64;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 24i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
    return 234i64;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    LODWORD(v45) = v20[114];
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x17u,
      (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
      v21,
      v45);
  }
  return 1359i64;
}
// 18001A1B0: variable 'v8' is possibly undefined
// 18002EF8B: variable 'v45' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (000000018001B0B0) ----------------------------------------------------
__int64 __fastcall CCipherMill::ChooseServerCipher(
        CCipherMill *this,
        struct CSsl3TlsServerContext *a2,
        unsigned int *a3,
        unsigned int a4,
        unsigned int a5,
        unsigned __int8 a6)
{
  __int64 v6; // rdi
  __int64 v8; // r13
  unsigned __int64 v9; // rsi
  __int64 v10; // rax
  unsigned __int8 *v11; // r14
  CCipherMill *v12; // rdi
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  unsigned __int64 v16; // rdi
  unsigned __int64 v17; // rsi
  __int64 v18; // rdx
  __int64 v19; // r8
  unsigned int AcceptableCipherSuiteAndCred; // r15d
  struct CCipherSuiteInfo *v21; // r13
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // r8
  __int64 v25; // rdi
  __int64 v26; // rsi
  CSslServerKey *v27; // rcx
  struct CCipherSuiteInfo *v28; // rdi
  __int64 v29; // r12
  unsigned int v30; // r9d
  unsigned int v31; // r8d
  __int64 v32; // rax
  int v33; // eax
  unsigned int v34; // r9d
  __int16 v35; // r10
  unsigned __int8 v36; // si
  unsigned __int8 *v37; // rdx
  CCipherMill *v38; // rcx
  struct CCipherSuiteInfo *v40; // rax
  struct CSslCredential *v41; // r8
  unsigned __int8 *v42; // r9
  unsigned __int8 v43; // cl
  int v44; // r10d
  struct CSslCredential *v45; // rsi
  unsigned int v46; // edi
  unsigned int v47; // edx
  NTSTATUS v48; // eax
  __int64 v49; // r9
  __int64 v50; // rdx
  __int16 v51; // ax
  __int64 v52; // rax
  unsigned __int16 v53; // ax
  unsigned __int8 *v54; // rcx
  unsigned __int64 v55; // r15
  __int64 v56; // rax
  unsigned __int8 *v57; // rcx
  __int64 v58; // rax
  unsigned __int8 *v59; // r14
  unsigned __int8 *v60; // r12
  unsigned __int8 *v61; // r13
  __int64 v62; // rcx
  SIZE_T v63; // rax
  _DWORD *v64; // rax
  __int64 *v65; // r10
  unsigned int v66; // ecx
  __int64 v67; // r10
  __int64 v68; // rdx
  __int64 v69; // rax
  __int64 v70; // rcx
  const char *v71; // r9
  unsigned __int8 v72; // al
  const char *v73; // r9
  __int64 v74; // rax
  __int64 v75; // rdx
  __int64 v76; // rcx
  unsigned int v77; // ecx
  int v78; // eax
  CCipherMill *v79; // rcx
  __int64 v80; // rdx
  unsigned __int16 v81; // dx
  struct _UNICODE_STRING *v82; // [rsp+28h] [rbp-D8h]
  bool v83; // [rsp+60h] [rbp-A0h]
  unsigned __int8 v84; // [rsp+61h] [rbp-9Fh]
  unsigned __int8 v85[2]; // [rsp+62h] [rbp-9Eh] BYREF
  unsigned int v86; // [rsp+64h] [rbp-9Ch]
  unsigned __int8 *v87; // [rsp+68h] [rbp-98h] BYREF
  unsigned int v88; // [rsp+70h] [rbp-90h]
  unsigned int v89; // [rsp+74h] [rbp-8Ch] BYREF
  struct CCipherSuiteInfo *v90; // [rsp+78h] [rbp-88h] BYREF
  struct CCipherSuiteInfo *v91; // [rsp+80h] [rbp-80h]
  struct CSslCredential *v92; // [rsp+88h] [rbp-78h]
  struct CSslCredential *v93; // [rsp+90h] [rbp-70h] BYREF
  unsigned __int8 *v94; // [rsp+98h] [rbp-68h]
  unsigned int v95; // [rsp+A0h] [rbp-60h]
  struct _UNICODE_STRING *p_DestinationString; // [rsp+A8h] [rbp-58h]
  unsigned __int64 v97; // [rsp+B0h] [rbp-50h]
  struct _UNICODE_STRING DestinationString; // [rsp+B8h] [rbp-48h] BYREF
  __int64 v99; // [rsp+C8h] [rbp-38h]
  struct _STRING SourceString; // [rsp+D0h] [rbp-30h] BYREF
  unsigned int *v101; // [rsp+E0h] [rbp-20h]
  _BYTE Source1[20]; // [rsp+E8h] [rbp-18h] BYREF
  __int64 v103; // [rsp+100h] [rbp+0h] BYREF
  int v104; // [rsp+108h] [rbp+8h]
  wchar_t v105; // [rsp+10Ch] [rbp+Ch]
  char v106[498]; // [rsp+10Eh] [rbp+Eh] BYREF
  char v107[512]; // [rsp+300h] [rbp+200h] BYREF

  v6 = *((_QWORD *)a2 + 10);
  v101 = a3;
  v99 = v6;
  v93 = 0i64;
  v90 = 0i64;
  v89 = 0;
  v85[0] = 0;
  v94 = 0i64;
  v95 = a4;
  memset_0(v107, 0, 0x1FEui64);
  *(_DWORD *)&DestinationString.Length = 33423360;
  DestinationString.Buffer = (PWSTR)v107;
  v8 = *(unsigned int *)(v6 + 196);
  v9 = *(_QWORD *)(v6 + 200);
  p_DestinationString = 0i64;
  v97 = v9;
  v83 = (_DWORD)v8 != 0;
  v92 = 0i64;
  v91 = 0i64;
  v87 = 0i64;
  v86 = 0;
  v84 = 0;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 27i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
  RtlAcquireResourceShared(&Resource, 1u);
  v10 = *((_QWORD *)a2 + 121);
  v11 = (unsigned __int8 *)(v10 + 6);
  if ( v10 )
  {
    v88 = *(unsigned __int16 *)(v10 + 4);
  }
  else
  {
    v11 = 0i64;
    v88 = 0;
  }
  v12 = WPP_GLOBAL_Control;
  while ( 1 )
  {
    v104 = *(_DWORD *)L"E>";
    v105 = aNone[6];
    v103 = *(_QWORD *)L"<NONE>";
    memset_0(v106, 0, sizeof(v106));
    if ( v91 && v83 )
    {
      LOBYTE(v13) = 0;
      v83 = 0;
    }
    else
    {
      if ( v11 && v88 )
      {
        v94 = v11;
        *(_DWORD *)(&SourceString.MaximumLength + 1) = 0;
        p_DestinationString = &DestinationString;
        if ( !DestinationString.Buffer )
        {
          AcceptableCipherSuiteAndCred = 87;
          goto LABEL_43;
        }
        v46 = v88;
        v47 = *v11;
        if ( v47 > v88 - 1 )
        {
          AcceptableCipherSuiteAndCred = 1359;
          goto LABEL_43;
        }
        SourceString.Length = *v11;
        SourceString.MaximumLength = v47;
        SourceString.Buffer = (PCHAR)(v11 + 1);
        v48 = RtlAnsiStringToUnicodeString(&DestinationString, &SourceString, 0);
        AcceptableCipherSuiteAndCred = RtlNtStatusToDosError(v48);
        if ( AcceptableCipherSuiteAndCred )
          goto LABEL_43;
        v14 = (__int64)&v103;
        v49 = DestinationString.Length - 512i64;
        v50 = 512i64;
        v15 = (char *)DestinationString.Buffer - (char *)&v103;
        while ( v49 + v50 )
        {
          v51 = *(_WORD *)(v15 + v14);
          if ( !v51 )
            break;
          *(_WORD *)v14 = v51;
          v14 += 2i64;
          if ( !--v50 )
          {
            v14 -= 2i64;
            break;
          }
        }
        *(_WORD *)v14 = 0;
        v52 = (unsigned int)*v11 + 1;
        if ( (unsigned int)v52 > v46 )
          goto LABEL_150;
        v88 = v46 - v52;
        v11 += v52;
        v12 = WPP_GLOBAL_Control;
      }
      v13 = v83;
    }
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
    {
      v71 = "strict";
      if ( !(_BYTE)v13 )
        v71 = "all";
      WPP_SF_sS(*((_QWORD *)v12 + 2), v13, v15, v71, (const wchar_t *)&v103);
      LOBYTE(v13) = v83;
    }
    if ( !(_DWORD)v8 || !v9 || (v16 = v9, v14 = 5 * v8, v17 = v9 + 40 * v8, v97 >= v17) )
    {
LABEL_17:
      AcceptableCipherSuiteAndCred = CCipherMill::FindAcceptableCipherSuiteAndCred(
                                       (CCipherMill *)v14,
                                       a2,
                                       v101,
                                       v95,
                                       a6,
                                       p_DestinationString,
                                       v13,
                                       &v90,
                                       &v93,
                                       &v89,
                                       v85);
      if ( AcceptableCipherSuiteAndCred )
      {
        v12 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_125;
        v73 = "strict";
        if ( !v83 )
          v73 = "all";
        LODWORD(v82) = AcceptableCipherSuiteAndCred;
        WPP_SF_sSD(*((_QWORD *)WPP_GLOBAL_Control + 2), v18, v19, v73, (const wchar_t *)&v103, v82);
      }
      else
      {
        if ( a6 )
          goto LABEL_19;
        LOBYTE(v13) = v83;
        if ( !v83 )
        {
          v43 = v85[0];
          v45 = v93;
          goto LABEL_96;
        }
        v40 = v91;
        if ( v91 )
        {
          v12 = WPP_GLOBAL_Control;
LABEL_126:
          v43 = v84;
          v41 = v92;
          v42 = v87;
          v44 = v86;
LABEL_50:
          v45 = 0i64;
          v90 = 0i64;
          v93 = 0i64;
          v89 = 0;
          v85[0] = 0;
          goto LABEL_51;
        }
        v40 = v90;
        v41 = v93;
        v42 = v94;
        v43 = v85[0];
        v44 = v89;
        v91 = v90;
        v92 = v93;
        v87 = v94;
        v84 = v85[0];
        v86 = v89;
        v12 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_50;
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 29i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
      }
      v12 = WPP_GLOBAL_Control;
LABEL_125:
      v40 = v91;
      LOBYTE(v13) = v83;
      goto LABEL_126;
    }
    while ( 1 )
    {
      if ( (a5 & *(_DWORD *)(v16 + 16)) != 0 )
      {
        if ( !*(_DWORD *)v16
          || p_DestinationString
          && (v72 = DoesTlsParameterContainAlpnId((struct _TLS_PARAMETERS *)v16, p_DestinationString),
              LOBYTE(v13) = v83,
              v72) )
        {
          if ( !(_BYTE)v13 || (*(_BYTE *)(v16 + 32) & 1) == 0 )
            break;
        }
      }
      v16 += 40i64;
      if ( v16 >= v17 )
        goto LABEL_17;
    }
    v12 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_d(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xFu, (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids, a5);
      LOBYTE(v13) = v83;
      v12 = WPP_GLOBAL_Control;
    }
    v45 = v93;
    AcceptableCipherSuiteAndCred = -2146893007;
    v40 = v91;
    v43 = v84;
    v41 = v92;
    v42 = v87;
    v44 = v86;
LABEL_51:
    if ( !(_DWORD)v8 || !v88 && (!v40 || !(_BYTE)v13) )
      break;
    v9 = v97;
  }
  if ( !AcceptableCipherSuiteAndCred )
    goto LABEL_97;
  if ( !v40 )
  {
    v74 = *((_QWORD *)a2 + 121);
    if ( !v74 || !*(_WORD *)(v74 + 4) )
    {
      if ( AcceptableCipherSuiteAndCred == -2146893007 )
      {
        LogCipherMismatchEvent(*(_DWORD *)(v99 + 212), (const unsigned __int16 *)(v99 + 216), a5);
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 34i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
      }
      goto LABEL_43;
    }
    AcceptableCipherSuiteAndCred = -2146892953;
    if ( (_DWORD)v8 )
    {
      if ( v12 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v12 + 28) & 4) == 0 )
        goto LABEL_145;
      v75 = 32i64;
    }
    else
    {
      if ( v12 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v12 + 28) & 1) == 0 )
        goto LABEL_145;
      v75 = 33i64;
    }
    WPP_SF_(*((_QWORD *)v12 + 2), v75, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
LABEL_145:
    CSslContext::SetErrorAndFatalAlert((__int64)a2, 1208, -2146892953, 0x78u);
    *((_DWORD *)a2 + 17) = 96;
    *((_WORD *)a2 + 48) = 30722;
    goto LABEL_43;
  }
  v45 = v41;
  v93 = v41;
  v90 = v40;
  v94 = v42;
  v85[0] = v43;
  v89 = v44;
  if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)v12 + 2), 31i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
    v43 = v84;
  }
LABEL_96:
  if ( v43 )
  {
LABEL_19:
    v21 = v90;
    v22 = *((_QWORD *)v90 + 106);
    if ( v22 )
      _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v22 + 16) + 12i64));
    _InterlockedIncrement((volatile signed __int32 *)(*((_QWORD *)v90 + 107) + 12i64));
    AcceptableCipherSuiteAndCred = 0;
    v23 = (*(__int64 (__fastcall **)(struct CSsl3TlsServerContext *))(*(_QWORD *)a2 + 248i64))(a2);
    v25 = *((_QWORD *)a2 + 1);
    v26 = v23;
    if ( v25 )
    {
      v76 = *(_QWORD *)(v25 + 848);
      if ( v76 )
        CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v76 + 16));
      CMasterCipherInfo::Dereference(*(CMasterCipherInfo **)(v25 + 856));
    }
    v27 = (CSslServerKey *)*((_QWORD *)a2 + 3);
    if ( v27 )
    {
      CSslServerKey::Dereference(v27);
      *((_QWORD *)a2 + 3) = 0i64;
    }
    v28 = v90;
    if ( v26 )
    {
      v29 = *(_QWORD *)v90;
      RtlAcquireResourceShared((PRTL_RESOURCE)(v26 + 552), 1u);
      v30 = *(_DWORD *)(v26 + 96);
      v31 = 0;
      if ( v30 )
      {
        while ( 1 )
        {
          v32 = *(_QWORD *)(*(_QWORD *)(v26 + 88) + 8i64 * v31);
          if ( *(_QWORD *)(v32 + 16) == v29 )
            break;
          if ( ++v31 >= v30 )
            goto LABEL_28;
        }
        _InterlockedIncrement((volatile signed __int32 *)(v32 + 24));
        v28 = v90;
        *((_QWORD *)a2 + 3) = *(_QWORD *)(*(_QWORD *)(v26 + 88) + 8i64 * v31);
      }
LABEL_28:
      RtlReleaseResource((PRTL_RESOURCE)(v26 + 552));
    }
    if ( (*((_DWORD *)a2 + 16) & 0xF3F00) != 0 )
    {
      AcceptableCipherSuiteAndCred = SslLookupCipherLengths(
                                       *(_QWORD *)v28,
                                       *((unsigned __int16 *)a2 + 17),
                                       *((unsigned int *)v28 + 7),
                                       *((unsigned int *)a2 + 4),
                                       Source1,
                                       20,
                                       0);
      if ( AcceptableCipherSuiteAndCred )
      {
LABEL_33:
        *((_WORD *)a2 + 16) |= 1u;
        *((_QWORD *)a2 + 1) = v28;
        if ( AcceptableCipherSuiteAndCred )
          goto LABEL_43;
        v34 = v89;
        if ( !a6 && *((_DWORD *)v28 + 12) == 3 || (v35 = a5, (a5 & 0x1000) != 0) )
        {
          *((_DWORD *)a2 + 4) = v89;
          v65 = (__int64 *)*((_QWORD *)v21 + 106);
          if ( v65 )
          {
            v24 = *((unsigned int *)v65 + 2);
            v66 = 0;
            if ( (_DWORD)v24 )
            {
              v67 = *v65;
              while ( 1 )
              {
                v68 = 780i64 * v66;
                if ( *(_DWORD *)(v68 + v67 + 772) == v34 )
                  break;
                if ( ++v66 >= (unsigned int)v24 )
                  goto LABEL_101;
              }
              if ( v68 + v67 )
                *((_DWORD *)a2 + 5) = *(_DWORD *)(v68 + v67 + 776);
            }
          }
LABEL_101:
          v35 = a5;
        }
        v36 = v85[0];
        if ( !v85[0] && (v35 & 0x1000) != 0 )
        {
          AcceptableCipherSuiteAndCred = (*(__int64 (__fastcall **)(struct CSsl3TlsServerContext *, _QWORD, _QWORD))(*(_QWORD *)a2 + 552i64))(
                                           a2,
                                           v34,
                                           *(_QWORD *)v28);
          if ( AcceptableCipherSuiteAndCred )
            goto LABEL_43;
        }
        v37 = v94;
        if ( !v94 )
        {
LABEL_39:
          if ( v36 )
          {
            *((_DWORD *)a2 + 17) = 71;
            v38 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
            {
              goto LABEL_43;
            }
            v81 = 35;
          }
          else if ( a6 )
          {
            v38 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
            {
              goto LABEL_43;
            }
            v81 = 36;
          }
          else
          {
            v38 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
            {
              goto LABEL_43;
            }
            v81 = 37;
          }
          WPP_SF_DS(*((_QWORD *)v38 + 2), v81, v24, *((_DWORD *)v28 + 7), (const wchar_t *)v28 + 37);
          goto LABEL_43;
        }
        v53 = *v94 + 1;
        if ( v53 < 2u )
        {
          v79 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_177;
          }
          v80 = 74i64;
LABEL_176:
          WPP_SF_(*((_QWORD *)v79 + 2), v80, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
LABEL_177:
          AcceptableCipherSuiteAndCred = -2146893018;
          goto LABEL_43;
        }
        v54 = v94;
        v55 = (unsigned __int64)&v94[v53];
        if ( (unsigned __int64)v94 < v55 )
        {
          while ( 1 )
          {
            v56 = *v54;
            if ( !(_BYTE)v56 )
              break;
            v57 = &v54[v56];
            if ( (unsigned __int64)v57 >= v55 )
              break;
            v54 = v57 + 1;
            if ( (unsigned __int64)v54 >= v55 )
              goto LABEL_73;
          }
          v79 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_177;
          }
          v80 = 76i64;
          goto LABEL_176;
        }
LABEL_73:
        v58 = *((_QWORD *)a2 + 98);
        if ( !v58 )
        {
          AcceptableCipherSuiteAndCred = 87;
          goto LABEL_43;
        }
        v59 = (unsigned __int8 *)(v58 + 6);
        if ( v58 != -6 )
        {
          v60 = &v59[*(unsigned __int16 *)(v58 + 4)];
          if ( v59 < v60 )
          {
            while ( 1 )
            {
              v61 = v37;
              if ( (unsigned __int64)v37 < v55 )
                break;
LABEL_168:
              v59 += *v59 + 1;
              if ( v59 >= v60 )
                goto LABEL_169;
            }
            LOBYTE(v62) = *v59;
            while ( 1 )
            {
              if ( (_BYTE)v62 == *v61 )
              {
                v63 = RtlCompareMemory(v59 + 1, v61 + 1, (unsigned __int8)v62);
                v62 = *v59;
                if ( v63 == v62 )
                  break;
              }
              v61 += *v61 + 1;
              if ( (unsigned __int64)v61 >= v55 )
              {
                v37 = v94;
                goto LABEL_168;
              }
            }
            v64 = (_DWORD *)*((_QWORD *)a2 + 99);
            if ( !v64 )
            {
              v64 = (_DWORD *)(*(__int64 (__fastcall **)(struct CSsl3TlsServerContext *, __int64))(*(_QWORD *)a2 + 8i64))(
                                a2,
                                264i64);
              *((_QWORD *)a2 + 99) = v64;
              if ( !v64 )
              {
                AcceptableCipherSuiteAndCred = 14;
                goto LABEL_43;
              }
            }
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 61i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
              v64 = (_DWORD *)*((_QWORD *)a2 + 99);
            }
            *v64 = 1;
            *(_DWORD *)(*((_QWORD *)a2 + 99) + 4i64) = 2;
            *(_BYTE *)(*((_QWORD *)a2 + 99) + 8i64) = *v59;
            memcpy_0((void *)(*((_QWORD *)a2 + 99) + 9i64), v59 + 1, *v59);
            AcceptableCipherSuiteAndCred = 0;
            goto LABEL_39;
          }
        }
LABEL_169:
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 60i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
        AcceptableCipherSuiteAndCred = -2146892953;
        goto LABEL_145;
      }
    }
    else
    {
      v77 = *((_DWORD *)v28 + 3);
      v78 = *((_DWORD *)v28 + 4);
      *(_QWORD *)Source1 = 20i64;
      *(_QWORD *)&Source1[12] = 0i64;
      *(_DWORD *)&Source1[8] = v78;
      if ( v77 > 1 )
      {
        *(_DWORD *)&Source1[16] |= 1u;
        *(_DWORD *)&Source1[12] = v77;
      }
    }
    if ( (*((_BYTE *)a2 + 32) & 1) != 0 && RtlCompareMemory(Source1, (char *)a2 + 40, 0x14ui64) != 20 )
    {
      *((_WORD *)a2 + 16) |= 1u;
      AcceptableCipherSuiteAndCred = -2146893007;
      *((_QWORD *)a2 + 1) = v28;
      goto LABEL_43;
    }
    v33 = *(_DWORD *)&Source1[16];
    *(_OWORD *)((char *)a2 + 40) = *(_OWORD *)Source1;
    *((_DWORD *)a2 + 14) = v33;
    goto LABEL_33;
  }
LABEL_97:
  v69 = *(_QWORD *)a2;
  v87 = 0i64;
  (*(void (__fastcall **)(struct CSsl3TlsServerContext *, unsigned __int8 **))(v69 + 232))(a2, &v87);
  if ( v87 )
  {
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(v87 + 72), 1u);
    v70 = v99;
    *((_QWORD *)v87 + 42) = v45;
    *(_QWORD *)(v87 + 188) = *(_QWORD *)(v70 + 760);
    RtlReleaseResource((PRTL_RESOURCE)(v87 + 72));
    goto LABEL_19;
  }
LABEL_150:
  AcceptableCipherSuiteAndCred = -2146893052;
LABEL_43:
  RtlReleaseResource(&Resource);
  if ( *((_QWORD *)a2 + 121) )
  {
    (*(void (__fastcall **)(struct CSsl3TlsServerContext *))(*(_QWORD *)a2 + 16i64))(a2);
    *((_QWORD *)a2 + 121) = 0i64;
  }
  return AcceptableCipherSuiteAndCred;
}
// 18001B672: conditional instruction was optimized away because rdx.8!=0
// 18001B2AC: variable 'v14' is possibly undefined
// 18002FE63: variable 'v13' is possibly undefined
// 18002FE63: variable 'v15' is possibly undefined
// 18002FF76: variable 'v18' is possibly undefined
// 18002FF76: variable 'v19' is possibly undefined
// 18002FF76: variable 'v82' is possibly undefined
// 18003031D: variable 'v24' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180083D10: using guessed type wchar_t aNone[7];
// 1800984F0: using guessed type __int64 __fastcall SslLookupCipherLengths(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);
// 18001B0B0: using guessed type unsigned __int8 var_4DE[2];
// 18001B0B0: using guessed type char var_432[498];

//----- (000000018001B930) ----------------------------------------------------
__int64 __fastcall CSslCredential::IsServerCredApplicable(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        int a4,
        __int64 a5,
        struct _TLS_PARAMETERS *a6,
        unsigned int a7,
        PCUNICODE_STRING String2,
        char a9)
{
  int v9; // esi
  int v12; // ebx
  _DWORD *v13; // rax
  int v14; // r14d
  unsigned int v15; // r12d
  CCipherMill *v16; // r10
  __int64 v17; // r12
  const wchar_t *v18; // rbx
  int v19; // eax
  unsigned int v20; // r9d
  struct _TLS_PARAMETERS *v21; // r15
  const UNICODE_STRING *v22; // r13
  struct _TLS_PARAMETERS *v23; // rbx
  struct _TLS_PARAMETERS *v24; // r14
  int v25; // eax
  unsigned int v26; // r11d
  int v27; // eax
  _DWORD *v28; // rdx
  unsigned __int8 i; // r9
  int v30; // ebx
  int v31; // ecx
  int v32; // edx
  unsigned __int16 v33; // r8
  unsigned __int16 v34; // cx
  unsigned __int16 v35; // r8
  unsigned __int16 v36; // cx
  int v37; // r8d
  __int64 v38; // rdx
  int v39; // ebx
  struct _CERT_INFO *v40; // rdx
  unsigned int v42; // ebp
  unsigned __int64 v43; // rbp
  unsigned int v44; // eax
  unsigned int v45; // eax
  int v46; // r9d
  bool v47; // zf
  int v48; // eax
  int v49; // eax
  __int64 v50; // [rsp+20h] [rbp-68h]
  PCUNICODE_STRING v51; // [rsp+28h] [rbp-60h]
  unsigned int v52; // [rsp+40h] [rbp-48h]
  int v53; // [rsp+48h] [rbp-40h]
  unsigned int pbKeyUsage; // [rsp+90h] [rbp+8h] BYREF
  int v55; // [rsp+A0h] [rbp+18h]
  int v56; // [rsp+A8h] [rbp+20h]

  v56 = a4;
  v9 = 0;
  v12 = 0;
  if ( a3 )
    v12 = *(_DWORD *)(a3 + 772);
  v13 = *(_DWORD **)(a1 + 32);
  if ( !v13 )
    return 0i64;
  if ( *v13 != 1 )
    return 0i64;
  if ( !a2 )
    return 0i64;
  v14 = *(_DWORD *)(a2 + 32);
  v15 = *(_DWORD *)(a2 + 36);
  v55 = v14;
  v52 = v15;
  if ( !*(_QWORD *)(a1 + 432) && !*(_DWORD *)(a1 + 132) )
    return 0i64;
  if ( v14 == 41984 && *(_DWORD *)(a1 + 124) == 1 )
  {
    v46 = *(_DWORD *)(a1 + 128);
    if ( v46 != 1 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        WPP_SF_d(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x2Au,
          (__int64)&WPP_221bc911720835f3baa7a86739b227e3_Traceguids,
          v46);
      return 0i64;
    }
  }
  v16 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x2Bu,
      (__int64)&WPP_221bc911720835f3baa7a86739b227e3_Traceguids,
      v15,
      *(_DWORD *)(a1 + 132));
    v16 = WPP_GLOBAL_Control;
  }
  if ( v15 == 9216 )
  {
    if ( ((*(_DWORD *)(a1 + 132) - 9216) & 0xFFFF7FFF) != 0 )
      return 0i64;
    goto LABEL_13;
  }
  if ( v15 == 8704 )
  {
    v47 = *(_DWORD *)(a1 + 132) == 8704;
LABEL_113:
    if ( !v47 )
      return 0i64;
    goto LABEL_13;
  }
  if ( v15 != 8707 )
  {
    if ( v15 != 41984 )
    {
      if ( !v15 || *(_DWORD *)(a1 + 132) == v15 )
        goto LABEL_13;
      if ( v16 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v16 + 28) & 2) != 0 )
        WPP_SF_D(*((_QWORD *)v16 + 2), 45i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids, v15);
      return 0i64;
    }
    v47 = *(_DWORD *)(a1 + 132) == 41984;
    goto LABEL_113;
  }
  if ( *(_DWORD *)(a1 + 132) != 8707 )
    return 0i64;
  if ( v12 != *(_DWORD *)(a1 + 140) )
  {
    if ( v16 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v16 + 28) & 2) != 0 )
    {
      LODWORD(v50) = *(_DWORD *)(a1 + 140);
      WPP_SF_DD(*((_QWORD *)v16 + 2), 0x2Cu, (__int64)&WPP_221bc911720835f3baa7a86739b227e3_Traceguids, v12, v50);
    }
    return 0i64;
  }
LABEL_13:
  v17 = a7;
  v53 = 3;
  if ( !a7 )
    goto LABEL_33;
  v18 = (const wchar_t *)(a1 + 272);
  v19 = *(_DWORD *)(a1 + 132);
  v20 = v19 == 8707 ? *(_DWORD *)(a1 + 136) : *(_DWORD *)(a1 + 428);
  v21 = a6;
  pbKeyUsage = v20;
  if ( !a6 || !v19 || a1 == -144 || a1 == -272 )
    goto LABEL_33;
  if ( v19 == 8707 )
  {
    if ( a3
      && IsEcdsaAlgorithmBlacklisted(a6, a7, (const unsigned __int16 *)a3, *(_DWORD *)(a3 + 772), v20, String2, a9) )
    {
      return 0i64;
    }
  }
  else if ( v19 == 8704 )
  {
    if ( IsCngAlgorithmBlacklisted((unsigned __int64)a6, a7, 1, L"DSA", 0i64, v20, String2, a9) )
      return 0i64;
  }
  else
  {
    v22 = String2;
    if ( v19 == 41984 )
    {
      if ( v14 == 41984 && IsRsaAlgorithmBlacklisted((unsigned __int64)a6, a7, 0, v20, String2, a9) )
        return 0i64;
      goto LABEL_24;
    }
    if ( v19 == 9216 )
    {
LABEL_24:
      v23 = v21;
      v24 = (struct _TLS_PARAMETERS *)((char *)v21 + 40 * v17);
      if ( v21 < v24 )
      {
        while ( 1 )
        {
          if ( *((_DWORD *)v23 + 5) )
          {
            if ( !*(_DWORD *)v23 )
              goto LABEL_75;
            if ( v22 )
              break;
          }
LABEL_28:
          v23 = (struct _TLS_PARAMETERS *)((char *)v23 + 40);
          if ( v23 >= v24 )
            goto LABEL_29;
        }
        v42 = 0;
        while ( RtlCompareUnicodeString((PCUNICODE_STRING)(*((_QWORD *)v23 + 1) + 16i64 * v42), v22, 1u) )
        {
          if ( ++v42 >= *(_DWORD *)v23 )
            goto LABEL_28;
        }
LABEL_75:
        if ( a9 && (*((_BYTE *)v23 + 32) & 1) != 0 )
          goto LABEL_28;
        v43 = *((_QWORD *)v23 + 3);
        if ( v43 >= v43 + 48i64 * *((unsigned int *)v23 + 5) )
          goto LABEL_28;
        while ( 1 )
        {
          if ( *(_DWORD *)v43 != 1 || *(_WORD *)(v43 + 8) != 6 || wcsncmp(*(const wchar_t **)(v43 + 16), L"RSA", 3ui64) )
            goto LABEL_79;
          if ( !*(_DWORD *)(v43 + 24) && !*(_DWORD *)(v43 + 40) && !*(_DWORD *)(v43 + 44) )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              LODWORD(v50) = 1;
              WPP_SF_Sd(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0xCu,
                (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
                L"RSA",
                v50);
            }
            return 0i64;
          }
          if ( !pbKeyUsage )
            goto LABEL_79;
          v44 = *(_DWORD *)(v43 + 40);
          if ( v44 )
          {
            if ( v44 > pbKeyUsage )
              goto LABEL_134;
            v45 = *(_DWORD *)(v43 + 44);
            if ( !v45 )
              goto LABEL_79;
          }
          else
          {
            if ( !*(_DWORD *)(v43 + 44) )
              goto LABEL_79;
            v45 = *(_DWORD *)(v43 + 44);
          }
          if ( v45 < pbKeyUsage )
          {
LABEL_134:
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              LODWORD(v51) = 1;
              LODWORD(v50) = pbKeyUsage;
              WPP_SF_Sdd(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0xEu,
                (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
                L"RSA",
                v50,
                v51);
            }
            return 0i64;
          }
LABEL_79:
          v43 += 48i64;
          if ( v43 >= *((_QWORD *)v23 + 3) + 48 * (unsigned __int64)*((unsigned int *)v23 + 5) )
            goto LABEL_28;
        }
      }
LABEL_29:
      v14 = v55;
      v18 = (const wchar_t *)(a1 + 272);
    }
  }
  if ( IsCngAlgorithmBlacklisted((unsigned __int64)v21, v17, 4, (const wchar_t *)(a1 + 144), 0i64, 0, 0i64, 1)
    || IsCngAlgorithmBlacklisted((unsigned __int64)v21, v17, 4, v18, 0i64, 0, 0i64, 1) )
  {
    return 0i64;
  }
  v16 = WPP_GLOBAL_Control;
LABEL_33:
  if ( !a5 )
    goto LABEL_57;
  v25 = *(_DWORD *)(a1 + 132);
  v26 = *(_DWORD *)(a1 + 428);
  if ( v25 != 41984 )
  {
    v48 = v25 - 8704;
    if ( !v48 )
    {
      v27 = 2;
      goto LABEL_36;
    }
    v49 = v48 - 3;
    if ( !v49 )
    {
      v27 = 3;
      goto LABEL_37;
    }
    if ( v49 != 509 )
      return 0i64;
  }
  v27 = 1;
LABEL_36:
  v53 = v27;
LABEL_37:
  v28 = &unk_18007C3A8;
  for ( i = 0; ; ++i )
  {
    v30 = v28[1];
    if ( v30 == v27
      && (v56 & *v28) != 0
      && (!v26 || v27 != 1 || v28[9] != 8 || v26 >> 3 >= 2 * (unsigned int)*((unsigned __int8 *)v28 + 32) + 2)
      && ((v56 & 0x3000) == 0 || v30 != 3 || v28[10] == *(_DWORD *)(a1 + 140))
      && i < 0xCu )
    {
      v31 = *(unsigned __int16 *)(a5 + 34);
      if ( _bittest(&v31, i) )
        break;
    }
    v28 += 18;
    if ( v28 - 6 >= (_DWORD *)&CSsl3TlsServerContext::`vftable' )
      return 0i64;
    v27 = v53;
  }
  if ( a1 == -512 )
    return 2i64;
  if ( !*(_WORD *)(a1 + 512) )
    return 2i64;
  v32 = *(unsigned __int16 *)(a1 + 546);
  if ( !(_WORD)v32 )
    return 2i64;
  v33 = (CTlsSignatureSuiteList::RsaSha256Flags & (unsigned __int16)v31) != 0
      ? CTlsSignatureSuiteList::RsaSha256Flags
      : 0;
  v34 = v33 | v31;
  v35 = (CTlsSignatureSuiteList::RsaSha384Flags & v34) != 0 ? CTlsSignatureSuiteList::RsaSha384Flags : 0;
  v36 = v35 | v34;
  v37 = (CTlsSignatureSuiteList::RsaSha512Flags & v36) != 0 ? CTlsSignatureSuiteList::RsaSha512Flags : 0;
  if ( (~(v37 | v36) & v32) != 0 )
    return 2i64;
LABEL_57:
  v38 = *(_QWORD *)(a1 + 32);
  if ( !v38 )
    return 2i64;
  if ( v52 != 9216 )
    goto LABEL_68;
  if ( v14 != 44550 )
  {
    if ( v14 == 41984 )
    {
      v39 = 32;
      goto LABEL_61;
    }
    if ( v14 != 43522 )
      goto LABEL_68;
  }
  v39 = 128;
LABEL_61:
  v40 = *(struct _CERT_INFO **)(v38 + 24);
  pbKeyUsage = 0;
  if ( CertGetIntendedKeyUsage(0x10001u, v40, (BYTE *)&pbKeyUsage, 4u) )
  {
    if ( (pbKeyUsage & v39) != 0 )
      v9 = 1;
    v16 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
    {
      LODWORD(v50) = v39;
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x14u,
        (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
        pbKeyUsage,
        v50);
      v16 = WPP_GLOBAL_Control;
    }
    if ( v9 )
      goto LABEL_68;
    return 2i64;
  }
  v16 = WPP_GLOBAL_Control;
LABEL_68:
  if ( v16 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v16 + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)v16 + 2), 46i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids, v52);
  return 1i64;
}
// 1800306CF: variable 'v50' is possibly undefined
// 1800305E3: variable 'v51' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';
// 180092800: using guessed type unsigned __int16 CTlsSignatureSuiteList::RsaSha512Flags;
// 180092804: using guessed type unsigned __int16 CTlsSignatureSuiteList::RsaSha384Flags;
// 180092808: using guessed type unsigned __int16 CTlsSignatureSuiteList::RsaSha256Flags;

//----- (000000018001BE70) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::EccGenerateServerExchangeValue(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned int *a3)
{
  int v3; // r15d
  __int64 v4; // rax
  int v5; // r14d
  CSsl3TlsServerContext *v6; // rbp
  __int16 v7; // r12
  int v8; // ecx
  int v9; // r13d
  struct CEphemKeyData **v10; // rdi
  struct CEphemKeyData *v11; // rax
  unsigned int v12; // esi
  __int64 v13; // rax
  __int64 v14; // rbx
  __int64 v15; // r15
  __int64 *v16; // rax
  struct CEphemKeyData **v17; // rbp
  unsigned int v18; // eax
  unsigned int EphemeralKeyInfo; // ebx
  struct _BCRYPT_ECCKEY_BLOB *v20; // rax
  unsigned int cbKey; // ecx
  int v22; // edi
  int v23; // esi
  __int64 v24; // rax
  __int64 v25; // rax
  unsigned int v26; // esi
  unsigned __int8 v27; // r11
  _DWORD *v28; // rax
  unsigned __int8 v29; // r8
  __int16 v30; // r15
  unsigned __int8 v31; // bl
  __int64 v32; // r10
  int v33; // r9d
  int v34; // ecx
  unsigned __int8 v35; // cl
  void **v36; // rdx
  __int64 v37; // rdx
  __int64 v38; // r8
  DWORD v39; // r9d
  DWORD v40; // ebx
  __int64 *v41; // rcx
  __int64 v42; // rax
  int v43; // eax
  __int64 v44; // rax
  __int64 v45; // rdx
  __int64 *v46; // rax
  __int64 v47; // rcx
  unsigned int v48; // esi
  unsigned __int8 *v50; // r10
  unsigned int v51; // esi
  struct _BCRYPT_ECCKEY_BLOB *v52; // rax
  ULONG v53; // ebx
  unsigned __int8 v54; // bl
  unsigned __int8 v55; // al
  unsigned int v56; // esi
  unsigned __int8 *v57; // rdi
  ULONG v58; // r8d
  __int16 v59; // cx
  int v60; // r13d
  unsigned int v61; // eax
  char *v62; // rax
  __int64 v63; // rcx
  unsigned __int8 v64; // r9
  __int64 v65; // rax
  unsigned __int8 v66[4]; // [rsp+40h] [rbp-C8h] BYREF
  DWORD cbSignature; // [rsp+44h] [rbp-C4h] BYREF
  int v68; // [rsp+48h] [rbp-C0h]
  enum _eTlsHashAlgorithm v69; // [rsp+4Ch] [rbp-BCh]
  CSsl3TlsServerContext *v70; // [rsp+50h] [rbp-B8h]
  unsigned int v71; // [rsp+58h] [rbp-B0h]
  int v72; // [rsp+5Ch] [rbp-ACh] BYREF
  unsigned __int8 *v73; // [rsp+60h] [rbp-A8h]
  unsigned int *v74; // [rsp+68h] [rbp-A0h]
  struct _BCRYPT_ECCKEY_BLOB *v75; // [rsp+70h] [rbp-98h]
  unsigned __int16 *v76; // [rsp+78h] [rbp-90h]
  BYTE pbHashValue[64]; // [rsp+80h] [rbp-88h] BYREF

  v4 = *((_QWORD *)this + 1);
  v5 = 0;
  LOBYTE(v3) = 0;
  v70 = this;
  v6 = this;
  v74 = a3;
  v73 = a2;
  v7 = 0;
  v8 = *(_DWORD *)(v4 + 52);
  v72 = 0;
  v76 = 0i64;
  v68 = v3;
  v66[0] = 0;
  v69 = TlsHashAlgorithm_None;
  v71 = 0;
  if ( v8 == 2 )
  {
    v9 = 1;
  }
  else
  {
    if ( v8 != 4 )
      return 1359;
    v9 = 3;
  }
  v10 = (struct CEphemKeyData **)((char *)v6 + 960);
  v11 = (struct CEphemKeyData *)*((_QWORD *)v6 + 120);
  if ( !v11 )
  {
    v12 = *((_DWORD *)v6 + 4);
    v13 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)v6 + 248i64))(v6);
    v14 = v13;
    if ( !v12 )
    {
      EphemeralKeyInfo = CSslCredential::GetEphemeralKeyInfo(
                           (CSslCredential *)v13,
                           0,
                           (struct CEphemKeyData **)(v13 + 496),
                           (struct CEphemKeyData **)v6 + 120);
      if ( EphemeralKeyInfo == 87 )
      {
        v5 = 1;
        goto LABEL_96;
      }
      goto LABEL_11;
    }
    if ( v12 == *(_DWORD *)(v13 + 140) )
    {
      v17 = (struct CEphemKeyData **)(v13 + 504);
      goto LABEL_10;
    }
    *v10 = 0i64;
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(v13 + 552), 1u);
    v15 = v14 + 480;
    v16 = *(__int64 **)(v14 + 480);
    if ( v16 != (__int64 *)(v14 + 480) )
    {
      while ( *((_DWORD *)v16 + 4) != v12 )
      {
        v16 = (__int64 *)*v16;
        if ( v16 == (__int64 *)v15 )
          goto LABEL_89;
      }
      v17 = (struct CEphemKeyData **)(v16 + 3);
      if ( v16 != (__int64 *)-24i64 )
      {
LABEL_9:
        RtlReleaseResource((PRTL_RESOURCE)(v14 + 552));
        LOBYTE(v3) = v68;
LABEL_10:
        v18 = CSslCredential::GetEphemeralKeyInfo((CSslCredential *)v14, v12, v17, v10);
        v6 = v70;
        EphemeralKeyInfo = v18;
LABEL_11:
        if ( !EphemeralKeyInfo )
        {
          *(_DWORD *)(*((_QWORD *)v6 + 11) + 8i64) = *((_DWORD *)*v10 + 10);
          v11 = *v10;
          goto LABEL_13;
        }
LABEL_96:
        v64 = 40;
        if ( !v5 )
          v64 = 80;
        CSslContext::SetErrorAndFatalAlert((__int64)v6, 603, EphemeralKeyInfo, v64);
        CSslContext::SetErrorAndFatalAlert((__int64)v6, 1050, EphemeralKeyInfo, 0x50u);
        return EphemeralKeyInfo;
      }
      v6 = v70;
    }
LABEL_89:
    v62 = (char *)LocalAlloc(0x40u, 0x20ui64);
    if ( !v62 )
    {
      RtlReleaseResource((PRTL_RESOURCE)(v14 + 552));
      EphemeralKeyInfo = 14;
      goto LABEL_96;
    }
    *((_DWORD *)v62 + 4) = v12;
    *((_QWORD *)v62 + 1) = v62;
    *(_QWORD *)v62 = v62;
    v63 = *(_QWORD *)v15;
    if ( *(_QWORD *)(*(_QWORD *)v15 + 8i64) != v15 )
      __fastfail(3u);
    *(_QWORD *)v62 = v63;
    v17 = (struct CEphemKeyData **)(v62 + 24);
    *((_QWORD *)v62 + 1) = v15;
    *(_QWORD *)(v63 + 8) = v62;
    *(_QWORD *)v15 = v62;
    goto LABEL_9;
  }
LABEL_13:
  v20 = (struct _BCRYPT_ECCKEY_BLOB *)*((_QWORD *)v11 + 2);
  v75 = v20;
  if ( !v20 )
    return 87;
  cbKey = v20->cbKey;
  if ( (*((_BYTE *)v6 + 20) & 8) != 0 )
  {
    v3 = (unsigned __int8)v3;
    if ( cbKey <= 0xFF )
      v3 = (unsigned __int8)cbKey;
    EphemeralKeyInfo = 87;
    if ( cbKey <= 0xFF )
      EphemeralKeyInfo = 0;
    goto LABEL_17;
  }
  if ( cbKey <= 0x7F )
  {
    v3 = 2 * cbKey + 1;
    EphemeralKeyInfo = 0;
LABEL_17:
    v66[0] = v3;
    v68 = v3;
    goto LABEL_18;
  }
  EphemeralKeyInfo = 1359;
LABEL_18:
  if ( EphemeralKeyInfo )
    return EphemeralKeyInfo;
  v22 = *((_DWORD *)v6 + 16);
  v23 = (unsigned __int8)v3 + 6;
  if ( (v22 & 0x40400) == 0 )
  {
LABEL_38:
    memset_0(pbHashValue, 0, sizeof(pbHashValue));
    cbSignature = 0;
    v39 = 0;
    if ( (v22 & 0x43C00) != 0 )
    {
      v38 = (unsigned int)g_dwHashInfoTotalCount;
      v40 = 0;
      v37 = 0i64;
      if ( g_dwHashInfoTotalCount )
      {
        v41 = g_pHashInfo;
        while ( 1 )
        {
          v42 = *v41;
          if ( *v41 )
          {
            if ( *(_DWORD *)(v42 + 20) == v69 )
              break;
          }
          v37 = (unsigned int)(v37 + 1);
          ++v41;
          if ( (unsigned int)v37 >= g_dwHashInfoTotalCount )
            goto LABEL_112;
        }
        v40 = *(_DWORD *)(v42 + 8);
        v43 = 0;
      }
      else
      {
LABEL_112:
        v43 = 1168;
      }
      if ( v43 )
      {
LABEL_58:
        EphemeralKeyInfo = v43;
        if ( v43 >= 0 )
        {
          if ( v39 <= 0x8C )
            v39 = 140;
          v48 = v39 + v23;
          if ( !v73 )
          {
            *v74 = v48;
            return 0;
          }
          if ( *v74 < v48 )
          {
            *v74 = v48;
            return (unsigned int)-2146893023;
          }
          EphemeralKeyInfo = SslImpersonateClient(*(_QWORD *)(*((_QWORD *)v6 + 10) + 752i64), &v72);
          if ( EphemeralKeyInfo )
            goto LABEL_81;
          v50 = v73;
          v51 = v48 - 3;
          *v73 = 3;
          v50[1] = BYTE1(*((_DWORD *)v6 + 4));
          v50[2] = *((_BYTE *)v6 + 16);
          if ( (*((_BYTE *)v6 + 20) & 8) != 0 )
          {
            EphemeralKeyInfo = MontgomeryGetKeyExchangeBlob(v75, v50 + 4, v66);
            v55 = v66[0];
          }
          else
          {
            v52 = v75;
            v53 = v75->cbKey;
            if ( v53 > 0x7F )
            {
              v55 = v68;
              EphemeralKeyInfo = 1359;
              goto LABEL_72;
            }
            v54 = 2 * v53 + 1;
            if ( v50 == (unsigned __int8 *)-4i64 )
            {
              v55 = v54;
              EphemeralKeyInfo = 0;
              goto LABEL_72;
            }
            if ( (unsigned __int8)v3 < v54 )
            {
              v55 = v54;
              EphemeralKeyInfo = -2146893023;
              goto LABEL_72;
            }
            v50[4] = 4;
            memcpy_0(v50 + 5, &v52[1], v54 - 1i64);
            v55 = v54;
            EphemeralKeyInfo = 0;
          }
          v50 = v73;
LABEL_72:
          if ( EphemeralKeyInfo )
            goto LABEL_81;
          v50[3] = v55;
          v56 = -1 - v55 + v51;
          v57 = &v50[v55 + 4];
          v58 = v55 + 4;
          if ( (*((_DWORD *)v6 + 16) & 0x40400) == 0 )
          {
LABEL_76:
            v59 = v56 - 2;
            cbSignature = v56 - 2;
            v60 = v9 - 1;
            if ( v60 )
            {
              if ( v60 != 2 )
              {
LABEL_80:
                *v57 = HIBYTE(v59);
                v57[1] = cbSignature;
                *v74 = (_DWORD)v57 - (_DWORD)v50 + cbSignature + 2;
                goto LABEL_81;
              }
              v61 = SignEcdsaParams(v6, v50, v58, v69, v57 + 2, &cbSignature);
            }
            else
            {
              v61 = SignRsaParams(v6, v50, v58, v76, v69, v71, v57 + 2, &cbSignature);
            }
            EphemeralKeyInfo = v61;
            if ( v61 )
              goto LABEL_81;
            HIBYTE(v59) = BYTE1(cbSignature);
            LODWORD(v50) = (_DWORD)v73;
            goto LABEL_80;
          }
          if ( v56 >= 2 )
          {
            *(_WORD *)v57 = v7;
            v57 += 2;
            v56 -= 2;
            goto LABEL_76;
          }
          EphemeralKeyInfo = 1359;
LABEL_81:
          if ( v72 )
            RevertToSelf();
          return EphemeralKeyInfo;
        }
LABEL_117:
        CSslContext::SetErrorAndFatalAlert((__int64)v6, 1051, v43, 0x50u);
        return EphemeralKeyInfo;
      }
    }
    else
    {
      if ( v9 == 1 )
      {
        v40 = 36;
LABEL_52:
        if ( (v22 & 0x40051555) != 0 )
        {
          v44 = *((_QWORD *)v6 + 3);
          if ( v44 )
          {
            v45 = *(_QWORD *)(v44 + 8);
            v46 = (__int64 *)*((_QWORD *)v6 + 1);
            if ( v46 )
              v47 = *v46;
            else
              v47 = 0i64;
            v43 = SslSignHash(v47, v45, pbHashValue, v40, 0i64, 0, &cbSignature, 0);
            goto LABEL_57;
          }
        }
        else
        {
          v65 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, __int64, __int64, _QWORD))(*(_QWORD *)v6 + 248i64))(
                  v6,
                  v37,
                  v38,
                  0i64);
          if ( v65 )
          {
            v43 = NCryptSignHash(*(_QWORD *)(v65 + 104), 0i64, pbHashValue, v40, 0i64, cbSignature, &cbSignature, 0x40u);
LABEL_57:
            v39 = cbSignature;
            goto LABEL_58;
          }
        }
LABEL_116:
        EphemeralKeyInfo = -2146893052;
        v43 = -2146893052;
        goto LABEL_117;
      }
      v40 = 20;
    }
    if ( v40 > 0x40 )
      goto LABEL_116;
    goto LABEL_52;
  }
  v24 = *(_QWORD *)v6;
  LODWORD(v70) = (unsigned __int8)v3 + 8;
  v25 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(v24 + 248))(v6);
  if ( !v25 )
    return (unsigned int)-2146893052;
  v26 = *(_DWORD *)(v25 + 428);
  v27 = 0;
  v22 = *((_DWORD *)v6 + 16);
  v28 = &unk_18007C3A8;
  v29 = 0;
  v30 = 0;
  v31 = -1;
  v32 = 12i64;
  do
  {
    v33 = v28[1];
    if ( v33 == v9 && (v22 & *v28) != 0 && v29 < 0xCu )
    {
      v34 = *((unsigned __int16 *)v6 + 272);
      if ( _bittest(&v34, v29) )
      {
        if ( (v9 != 1 || v28[9] != 8 || v26 >> 3 >= 2 * (unsigned int)*((unsigned __int8 *)v28 + 32) + 2)
          && ((v22 & 0x3000) == 0 || v33 != 3 || !v28[10]) )
        {
          if ( (v35 = *((_BYTE *)v28 + 32), v35 < v27) && v35 > 0x14u || v27 <= 0x14u )
          {
            v31 = v29;
            v27 = *((_BYTE *)v28 + 32);
          }
        }
      }
    }
    v28 += 18;
    ++v29;
    --v32;
  }
  while ( v32 );
  v36 = (void **)&unk_18007C390;
  if ( v31 < 0xCu )
    v30 = *((_WORD *)&unk_18007C390 + 36 * v31);
  v7 = __ROR2__(v30, 8);
  if ( v7 )
  {
    while ( v30 != *(_WORD *)v36 )
    {
      v36 += 9;
      if ( v36 >= &CSsl3TlsServerContext::`vftable' )
        goto LABEL_37;
    }
    v69 = *((_DWORD *)v36 + 10);
    v76 = (unsigned __int16 *)v36[6];
    v71 = *((_DWORD *)v36 + 15);
LABEL_37:
    LOBYTE(v3) = v68;
    v23 = (int)v70;
    goto LABEL_38;
  }
  return 2148074289i64;
}
// 18003088E: conditional instruction was optimized away because r13d.4==3
// 18001BEC6: variable 'v3' is possibly undefined
// 1800308DD: variable 'v37' is possibly undefined
// 1800308DD: variable 'v38' is possibly undefined
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';
// 180092324: using guessed type int g_dwHashInfoTotalCount;
// 180092330: using guessed type _QWORD g_pHashInfo[16];
// 180098540: using guessed type __int64 __fastcall SslSignHash(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 18001BE70: using guessed type unsigned __int8 var_C8[4];

//----- (000000018001C410) ----------------------------------------------------
__int64 __fastcall CCipherMill::FindAcceptableCipherSuiteAndCred(
        CCipherMill *this,
        struct CSsl3TlsServerContext *a2,
        unsigned int *a3,
        unsigned int a4,
        unsigned __int8 a5,
        struct _UNICODE_STRING *a6,
        unsigned __int8 a7,
        struct CCipherSuiteInfo **a8,
        struct CSslCredential **a9,
        unsigned int *a10,
        unsigned __int8 *a11)
{
  __int64 v11; // rbp
  struct CCipherSuiteInfo **v14; // r13
  struct CSslCredential **v15; // rax
  unsigned __int8 *v16; // rbx
  unsigned int *v17; // rcx
  unsigned int AcceptableCipherSuite; // ebx
  unsigned __int64 v19; // rsi
  __int64 v20; // rdi
  char v21; // r12
  enum _eTlsHashAlgorithm v22; // r9d
  int v23; // r11d
  __int64 v24; // rax
  CSessionCacheItem *v25; // rcx
  __int64 v26; // rax
  int v27; // edx
  CCipherMill *v28; // r10
  __int64 v29; // r8
  unsigned int *v30; // rdx
  unsigned int *v31; // rax
  unsigned int AcceptableCredential; // eax
  struct CSslCredential **v33; // rcx
  struct CSslCredential *v34; // rax
  struct CSslCredential **v36; // rcx
  unsigned int PrfHashDetails; // eax
  struct CSslCredential **v38; // rcx
  struct _UNICODE_STRING *v39; // [rsp+20h] [rbp-A8h]
  __int64 v40; // [rsp+28h] [rbp-A0h]
  unsigned __int8 v41; // [rsp+50h] [rbp-78h]
  int v42; // [rsp+54h] [rbp-74h]
  enum _eTlsHashAlgorithm v43; // [rsp+58h] [rbp-70h] BYREF
  unsigned int v44; // [rsp+5Ch] [rbp-6Ch] BYREF
  unsigned int v45; // [rsp+60h] [rbp-68h]
  struct CSslCredential *v46; // [rsp+68h] [rbp-60h] BYREF
  struct CCipherSuiteInfo *v47; // [rsp+70h] [rbp-58h]
  struct CSslCredential *v48; // [rsp+78h] [rbp-50h]
  unsigned __int64 v49; // [rsp+80h] [rbp-48h]
  bool v50; // [rsp+D0h] [rbp+8h]
  CSessionCacheItem *v51; // [rsp+D8h] [rbp+10h] BYREF

  v11 = a4;
  if ( !a2 )
    return 2148074333i64;
  if ( !a3 )
    return 2148074333i64;
  if ( !a4 )
    return 2148074333i64;
  v14 = a8;
  if ( !a8 )
    return 2148074333i64;
  v15 = a9;
  if ( !a9 )
    return 2148074333i64;
  if ( !a10 )
    return 2148074333i64;
  v16 = a11;
  if ( !a11 )
    return 2148074333i64;
  *a10 = 0;
  v17 = (unsigned int *)xmmword_1800925B0;
  *v15 = 0i64;
  if ( (*((_DWORD *)a2 + 34) & 0x20000000) != 0 )
    v17 = (unsigned int *)*(&xmmword_1800925B0 + 1);
  *v16 = 0;
  AcceptableCipherSuite = -2146893007;
  *v14 = 0i64;
  v47 = 0i64;
  v48 = 0i64;
  v45 = 0;
  v41 = 0;
  if ( !v17 || (v19 = *(_QWORD *)v17, v20 = v17[2], !*(_QWORD *)v17) || !(_DWORD)v20 )
  {
    AcceptableCipherSuite = -2146893052;
    goto LABEL_45;
  }
  v50 = (*((_DWORD *)a2 + 16) & 0x1000) != 0;
  v21 = a5;
  v22 = TlsHashAlgorithm_None;
  v43 = TlsHashAlgorithm_None;
  v23 = 0;
  v42 = 0;
  if ( a5 )
  {
    v24 = *(_QWORD *)a2;
    v51 = 0i64;
    (*(void (__fastcall **)(struct CSsl3TlsServerContext *, CSessionCacheItem **, unsigned int *, _QWORD))(v24 + 232))(
      a2,
      &v51,
      a3,
      0i64);
    if ( !v51 )
    {
      AcceptableCipherSuite = -2146893052;
      goto LABEL_45;
    }
    RtlAcquireResourceShared((PRTL_RESOURCE)((char *)v51 + 72), 1u);
    v25 = v51;
    if ( v50 )
    {
      PrfHashDetails = CSessionCacheItem::GetPrfHashDetails(v51, 0i64, &v43);
      v25 = v51;
      if ( PrfHashDetails )
      {
        AcceptableCipherSuite = PrfHashDetails;
        RtlReleaseResource((PRTL_RESOURCE)((char *)v51 + 72));
        goto LABEL_45;
      }
    }
    else
    {
      v26 = *((_QWORD *)v51 + 22);
      if ( v26 )
        v27 = *(_DWORD *)(v26 + 28);
      else
        v27 = 0;
      v42 = v27;
    }
    RtlReleaseResource((PRTL_RESOURCE)((char *)v25 + 72));
    v22 = v43;
    v23 = v42;
  }
  v49 = v19 + 864 * v20;
  if ( v19 >= v49 )
  {
LABEL_45:
    v36 = a9;
    *v14 = 0i64;
    *v36 = 0i64;
    *a10 = 0;
    *a11 = 0;
    return AcceptableCipherSuite;
  }
  v28 = WPP_GLOBAL_Control;
  while ( 1 )
  {
    v29 = *(unsigned int *)(v19 + 28);
    v46 = 0i64;
    v44 = 0;
    LOBYTE(v51) = 0;
    if ( !(_DWORD)v29 || (v30 = &a3[v11], v31 = a3, a3 >= v30) )
    {
LABEL_26:
      if ( v28 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v28 + 28) & 4) != 0 )
      {
        WPP_SF_S(
          *((_QWORD *)v28 + 2),
          0x26u,
          (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
          (const wchar_t *)(v19 + 74));
LABEL_57:
        v28 = WPP_GLOBAL_Control;
      }
LABEL_28:
      AcceptableCipherSuite = -2146893007;
      goto LABEL_29;
    }
    while ( (_DWORD)v29 != *v31 )
    {
      if ( ++v31 >= v30 )
        goto LABEL_26;
    }
    if ( v21 && v23 != (_DWORD)v29 && !v50 )
    {
      if ( v28 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v28 + 28) & 4) != 0 )
      {
        LODWORD(v40) = v23;
        LODWORD(v39) = v29;
        WPP_SF_SDD(*((_QWORD *)v28 + 2), 0x27u, v29, (const wchar_t *)(v19 + 74), v39, v40);
        goto LABEL_57;
      }
      goto LABEL_28;
    }
    AcceptableCipherSuite = CCipherMill::FindAcceptableCipherSuite(
                              (CCipherMill *)v17,
                              a2,
                              (struct CCipherSuiteInfo *)v19,
                              v21,
                              a6,
                              a7,
                              v22,
                              &v44,
                              (unsigned __int8 *)&v51);
    if ( AcceptableCipherSuite )
      goto LABEL_55;
    if ( *(_DWORD *)(v19 + 48) == 4 )
    {
      *v14 = (struct CCipherSuiteInfo *)v19;
      return AcceptableCipherSuite;
    }
    AcceptableCredential = CCipherMill::FindAcceptableCredential(
                             (CCipherMill *)v17,
                             a2,
                             (struct CCipherSuiteInfo *)v19,
                             v21,
                             a6,
                             a7,
                             &v46);
    AcceptableCipherSuite = AcceptableCredential;
    if ( !AcceptableCredential )
    {
      v33 = a9;
      v34 = v46;
      *v14 = (struct CCipherSuiteInfo *)v19;
      *v33 = v34;
      *a10 = v44;
      *a11 = (unsigned __int8)v51;
      return AcceptableCipherSuite;
    }
    if ( AcceptableCredential == -2146893007 && v46 && !v47 )
    {
      v48 = v46;
      v45 = v44;
      v41 = (unsigned __int8)v51;
      v47 = (struct CCipherSuiteInfo *)v19;
LABEL_55:
      v28 = WPP_GLOBAL_Control;
      goto LABEL_29;
    }
    v28 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_S(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x28u,
        (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
        (const wchar_t *)(v19 + 74));
      v28 = WPP_GLOBAL_Control;
    }
LABEL_29:
    v19 += 864i64;
    if ( v19 >= v49 )
      break;
    v22 = v43;
    v23 = v42;
  }
  if ( !AcceptableCipherSuite )
    return AcceptableCipherSuite;
  if ( !v47 )
    goto LABEL_45;
  v38 = a9;
  AcceptableCipherSuite = 0;
  *v14 = v47;
  *v38 = v48;
  *a10 = v45;
  *a11 = v41;
  return AcceptableCipherSuite;
}
// 18001C6A4: variable 'v17' is possibly undefined
// 180030A87: variable 'v39' is possibly undefined
// 180030A87: variable 'v40' is possibly undefined

//----- (000000018001C7B0) ----------------------------------------------------
__int64 __fastcall CCipherMill::FindAcceptableCredential(
        CCipherMill *this,
        struct CSsl3TlsServerContext *a2,
        struct CCipherSuiteInfo *a3,
        char a4,
        struct _UNICODE_STRING *a5,
        unsigned __int8 a6,
        struct CSslCredential **a7)
{
  struct CSslCredential **v7; // r14
  int v10; // eax
  unsigned int v11; // esi
  __int64 v12; // rbp
  char v13; // r12
  int v14; // eax
  bool v15; // zf
  struct CSessionCacheServerItem *v16; // r13
  __int64 v17; // rbx
  __int64 v18; // r12
  __int64 v19; // rax
  _QWORD *v20; // r12
  void *v21; // r14
  _QWORD *v22; // rax
  int v23; // r13d
  __int64 v24; // rbp
  int IsServerCredApplicable; // eax
  char v26; // al
  char v27; // cl
  unsigned int v28; // ebp
  unsigned int *v30; // rax
  unsigned __int64 v31; // rdx
  int v32; // edx
  unsigned int v33; // r10d
  struct _TLS_PARAMETERS *v34; // r11
  const struct CTlsSignatureSuiteList *v35; // r8
  int v36; // r9d
  CCredentialGroup *v37; // rcx
  unsigned int v38; // eax
  SIZE_T v39; // rax
  unsigned int v40; // eax
  CCipherMill *v41; // rcx
  __int64 v42; // rdx
  __int64 v43; // rax
  _QWORD *v44; // [rsp+60h] [rbp-88h]
  struct CSessionCacheServerItem *v45; // [rsp+68h] [rbp-80h] BYREF
  const struct CTlsSignatureSuiteList *v46; // [rsp+70h] [rbp-78h]
  void *Source1; // [rsp+78h] [rbp-70h]
  unsigned int v48; // [rsp+80h] [rbp-68h]
  int v49; // [rsp+84h] [rbp-64h]
  __int64 v50; // [rsp+88h] [rbp-60h]
  struct _TLS_PARAMETERS *v51; // [rsp+90h] [rbp-58h]
  struct CSessionCacheServerItem *v52; // [rsp+98h] [rbp-50h]
  PRTL_RESOURCE Resource; // [rsp+A0h] [rbp-48h]
  char v54; // [rsp+F0h] [rbp+8h]
  struct CEccCurveInfo *v55; // [rsp+F0h] [rbp+8h]
  SIZE_T Length; // [rsp+F8h] [rbp+10h] BYREF

  v7 = a7;
  if ( a2 && a3 && a7 )
  {
    v10 = *((_DWORD *)a3 + 13);
    v11 = -2146893007;
    if ( v10 == 4 || *((_DWORD *)a2 + 16) == 4096 )
    {
      v12 = *((_QWORD *)a2 + 10);
      v45 = 0i64;
      v13 = 1;
      *a7 = 0i64;
      if ( v10 == 4 && !*(_BYTE *)(v12 + 900) )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 53i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
        return v11;
      }
    }
    else
    {
      v12 = *((_QWORD *)a2 + 10);
      v13 = 0;
      v45 = 0i64;
      *a7 = 0i64;
    }
    if ( a4 )
    {
      (*(void (__fastcall **)(struct CSsl3TlsServerContext *, struct CSessionCacheServerItem **))(*(_QWORD *)a2 + 232i64))(
        a2,
        &v45);
      if ( !v45 )
        return (unsigned int)-2146893052;
    }
    v14 = *((_DWORD *)a2 + 16);
    v46 = 0i64;
    v49 = v14;
    if ( (v14 & 0x41400) != 0 )
      v46 = (struct CSsl3TlsServerContext *)((char *)a2 + 510);
    if ( *(_BYTE *)(v12 + 900) && v13 )
    {
      v30 = (unsigned int *)*((_QWORD *)a3 + 106);
      Source1 = v30;
      if ( !v30 )
        return (unsigned int)-2146893052;
      v31 = *(_QWORD *)v30;
      v55 = *(struct CEccCurveInfo **)v30;
      if ( *(_QWORD *)v30 < *(_QWORD *)v30 + 780 * (unsigned __int64)v30[2] )
      {
        v18 = 0i64;
        while ( 1 )
        {
          v11 = CSsl3TlsServerContext::LookupEccCurveType(a2, *(_DWORD *)(v31 + 772));
          if ( !v11 )
          {
            v32 = *((_DWORD *)a2 + 34);
            v33 = *(_DWORD *)(v12 + 196);
            v34 = *(struct _TLS_PARAMETERS **)(v12 + 200);
            v35 = v46;
            v36 = *((_DWORD *)a2 + 16);
            if ( !*((_BYTE *)a2 + 925) )
              v35 = 0i64;
            v37 = (CCredentialGroup *)*((_QWORD *)a2 + 10);
            Length = 0i64;
            v38 = CCredentialGroup::PickServerCredential(
                    v37,
                    a3,
                    v55,
                    v36,
                    (v32 & 0x8000000) != 0i64,
                    v35,
                    v34,
                    v33,
                    a5,
                    a6,
                    v45,
                    (struct CSslCredential **)&Length);
            v11 = v38;
            if ( !v38 )
            {
              *v7 = (struct CSslCredential *)Length;
              return v11;
            }
            if ( v38 == -2146893007 && !v18 && (v39 = Length) != 0 )
            {
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
              {
                WPP_SF_D(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  56i64,
                  &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
                  *((unsigned int *)v55 + 193));
                v39 = Length;
              }
              v18 = v39;
            }
            else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                   && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_D(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                57i64,
                &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
                *((unsigned int *)v55 + 193));
            }
          }
          v31 = (unsigned __int64)v55 + 780;
          v55 = (struct CEccCurveInfo *)v31;
          if ( v31 >= *(_QWORD *)Source1 + 780 * (unsigned __int64)*((unsigned int *)Source1 + 2) )
            goto LABEL_89;
        }
      }
      return v11;
    }
    v15 = *((_BYTE *)a2 + 925) == 0;
    v16 = v45;
    v48 = *(_DWORD *)(v12 + 196);
    v51 = *(struct _TLS_PARAMETERS **)(v12 + 200);
    v52 = v45;
    if ( v15 )
      v46 = 0i64;
    v54 = (*((_DWORD *)a2 + 34) & 0x8000000) != 0i64;
    v15 = *(_DWORD *)(v12 + 28) == 0;
    v17 = 0i64;
    v50 = 0i64;
    v18 = 0i64;
    Source1 = 0i64;
    LODWORD(Length) = 0;
    if ( v15 )
      goto LABEL_85;
    if ( (*(_BYTE *)(v12 + 156) & 0x40) != 0 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 37i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids);
      v40 = CCredentialGroup::CheckForCredentialRenewal((CCredentialGroup *)v12);
      if ( v40 )
      {
        v28 = v40;
        v11 = v40;
        goto LABEL_70;
      }
    }
    Resource = (PRTL_RESOURCE)(v12 + 48);
    RtlAcquireResourceShared((PRTL_RESOURCE)(v12 + 48), 1u);
    if ( v16 )
    {
      RtlAcquireResourceShared((PRTL_RESOURCE)((char *)v16 + 72), 1u);
      v19 = *((_QWORD *)v16 + 42);
      if ( v19 )
      {
        LODWORD(Length) = 20;
        Source1 = (void *)(v19 + 40);
      }
    }
    v20 = *(_QWORD **)(v12 + 32);
    v44 = (_QWORD *)(v12 + 32);
    if ( v20 == (_QWORD *)(v12 + 32) )
    {
LABEL_30:
      v28 = v11;
      if ( v16 )
        RtlReleaseResource((PRTL_RESOURCE)((char *)v16 + 72));
      RtlReleaseResource(Resource);
      if ( v17 )
        v18 = v17;
      else
        v18 = v50;
      if ( !v11 )
        goto LABEL_35;
LABEL_70:
      if ( v28 == -2146893007 && v18 )
      {
        v41 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          v42 = 54i64;
LABEL_88:
          WPP_SF_(*((_QWORD *)v41 + 2), v42, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
          goto LABEL_89;
        }
        goto LABEL_89;
      }
LABEL_85:
      v41 = WPP_GLOBAL_Control;
      v18 = 0i64;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        v42 = 55i64;
        goto LABEL_88;
      }
LABEL_89:
      if ( v11 && v18 )
      {
        v11 = -2146893007;
LABEL_35:
        *v7 = (struct CSslCredential *)v18;
      }
      return v11;
    }
    v21 = Source1;
    v22 = (_QWORD *)(v12 + 32);
    v23 = Length;
    while ( 1 )
    {
      v24 = (__int64)(v20 - 1);
      v20 = (_QWORD *)*v20;
      if ( !v21 )
        goto LABEL_25;
      if ( v24 == -40 || v23 != 20 )
        goto LABEL_82;
      if ( RtlCompareMemory(v21, (const void *)(v24 + 40), 0x14ui64) == 20 )
      {
LABEL_25:
        IsServerCredApplicable = CSslCredential::IsServerCredApplicable(
                                   v24,
                                   (__int64)a3,
                                   0i64,
                                   v49,
                                   (__int64)v46,
                                   v51,
                                   v48,
                                   a5,
                                   a6);
        if ( IsServerCredApplicable == 1 )
        {
          if ( !v17 || (v26 = *(_BYTE *)(v24 + 80), v27 = v54, v26 != v54) )
          {
            v26 = *(_BYTE *)(v24 + 80);
            v17 = v24;
            v11 = 0;
            v27 = v54;
          }
          if ( v26 != v27 )
          {
LABEL_29:
            v7 = a7;
            v16 = v52;
            goto LABEL_30;
          }
        }
        else if ( IsServerCredApplicable == 2 )
        {
          v43 = v50;
          if ( !v50 )
            v43 = v24;
          v50 = v43;
        }
      }
      v22 = v44;
LABEL_82:
      if ( v20 == v22 )
        goto LABEL_29;
    }
  }
  return 2148074333i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082B38: using guessed type GUID WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids;

//----- (000000018001CB30) ----------------------------------------------------
__int64 __fastcall CTls13ExtServer::ParseExtension(__int64 a1, int a2, unsigned __int8 *a3, __int64 a4)
{
  unsigned __int16 v5; // si
  int v7; // r8d
  unsigned int v9; // eax
  __int64 result; // rax

  v5 = a4;
  v7 = (unsigned __int8)*(_DWORD *)(a1 + 16);
  v9 = v7 | (a2 << 8);
  if ( v9 >= 0x2901 )
  {
    switch ( v9 )
    {
      case 0x2901u:
        return CTls13ExtServer::ParsePreSharedKeyExtension((CTls13ExtServer *)a1, a3, a4, a4);
      case 0x2B01u:
        return CTls13ExtServer::ParseSupportedVersionsExtension((CTls13ExtServer *)a1, a3, a4);
      case 0x2D01u:
        return CTls13ExtServer::ParsePskKeyExchangeModesExtension((CTls13ExtServer *)a1, a3, a4, a4);
      case 0x3101u:
        if ( (_WORD)a4 )
          return 2148074248i64;
        *(_BYTE *)(*(_QWORD *)(a1 + 40) + 1506i64) = 1;
        return 0i64;
      case 0x3301u:
        return CTls13ExtServer::ParseKeyShareExtension((CTls13ExtServer *)a1, a3, a4);
    }
  }
  if ( (_WORD)a2 != 57 && (_WORD)a2 != 0xFFA5 )
    return CTlsExtServer::ParseExtension(a1, a2, a3, v5);
  result = CTls13Context::RetrieveGenericExtension(*(_QWORD *)(a1 + 40) + 1000i64, a2, v7, (__int64)a3, a4);
  if ( !(_DWORD)result )
    return CTlsExtServer::ParseExtension(a1, a2, a3, v5);
  return result;
}

//----- (000000018001CBE0) ----------------------------------------------------
__int64 __fastcall CCipherMill::FindAcceptableCipherSuite(
        CCipherMill *this,
        struct CSsl3TlsServerContext *a2,
        struct CCipherSuiteInfo *a3,
        char a4,
        struct _UNICODE_STRING *String2,
        unsigned __int8 a6,
        enum _eTlsHashAlgorithm a7,
        unsigned int *a8,
        unsigned __int8 *a9)
{
  __int64 v11; // r8
  unsigned int v12; // r11d
  unsigned __int64 v13; // r10
  unsigned int v14; // esi
  unsigned int v15; // ebp
  int v16; // r9d
  int v17; // edi
  int v18; // eax
  unsigned int *v19; // rdx
  int v20; // r10d
  int v21; // r8d
  int v22; // ebx
  int v23; // edx
  unsigned __int8 v24; // r9
  _DWORD *i; // rax
  int v26; // ecx
  int v27; // ecx
  char v28; // al
  char v29; // r8
  unsigned int AcceptableKeyXCurve; // ebx
  __int64 v32; // rax
  int v33; // ecx
  struct hsel *HashInfo; // rax
  __int64 v35; // [rsp+20h] [rbp-98h]
  __int64 v36; // [rsp+20h] [rbp-98h]
  __int64 v37; // [rsp+70h] [rbp-48h]
  int v38; // [rsp+C0h] [rbp+8h]
  const wchar_t *v39; // [rsp+C8h] [rbp+10h]

  if ( !a2 || !a3 || !a8 || !a9 )
    return 2148074333i64;
  v11 = *((_QWORD *)a2 + 10);
  v12 = *(_DWORD *)(v11 + 196);
  v13 = *(_QWORD *)(v11 + 200);
  v14 = *(_DWORD *)(v11 + 164);
  v15 = *(_DWORD *)(v11 + 168);
  v16 = *(_DWORD *)(v11 + 192);
  v17 = *((_DWORD *)a2 + 16);
  v39 = (const wchar_t *)((char *)a3 + 74);
  v18 = *(_DWORD *)(v11 + 156);
  v37 = v11;
  LODWORD(v11) = *(_DWORD *)(v11 + 176);
  v38 = 1;
  v19 = *(unsigned int **)(v37 + 184);
  *a8 = 0;
  *a9 = 0;
  if ( !CCipherMill::IsCipherSuiteAllowed(
          (__int64)g_cCipherMill,
          v19,
          v11,
          v16,
          (v18 & 0x1000) != 0,
          v18 & 0x800,
          v15,
          v14,
          v17,
          (__int64)a3,
          String2,
          v13,
          v12,
          a6) )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_S(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x29u,
        (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
        v39);
    return (unsigned int)-2146893007;
  }
  v20 = *((_DWORD *)a3 + 12);
  if ( v20 == 4 )
    return 0;
  if ( *((_DWORD *)a2 + 17) == 71 )
  {
    if ( (*((_BYTE *)a2 + 32) & 1) != 0 && (v32 = *((_QWORD *)a2 + 1)) != 0 )
      v33 = *(_DWORD *)(v32 + 28);
    else
      v33 = 0;
    if ( *((_DWORD *)a3 + 7) != v33 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_S(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x2Au,
          (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
          v39);
        return (unsigned int)-2146893007;
      }
      return (unsigned int)-2146893007;
    }
  }
  v21 = *((_DWORD *)a2 + 16);
  if ( (v21 & 0x40400) != 0 && a2 != (struct CSsl3TlsServerContext *)-510i64 )
  {
    v22 = *((_DWORD *)a3 + 9);
    switch ( v22 )
    {
      case 9216:
        goto LABEL_11;
      case 8704:
        v23 = 2;
        v38 = 2;
        goto LABEL_12;
      case 8707:
        v23 = 3;
        v38 = 3;
        goto LABEL_12;
      case 41984:
LABEL_11:
        v23 = 1;
LABEL_12:
        v24 = 0;
        for ( i = &unk_18007C3A8; i - 6 < (_DWORD *)&CSsl3TlsServerContext::`vftable'; i += 18 )
        {
          v26 = i[1];
          if ( v26 == v23 && (v21 & *i) != 0 && ((v21 & 0x3000) == 0 || v26 != 3 || !i[10]) && v24 < 0xCu )
          {
            v27 = *((unsigned __int16 *)a2 + 272);
            if ( _bittest(&v27, v24) )
              goto LABEL_20;
            v23 = v38;
          }
          ++v24;
        }
        break;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      LODWORD(v35) = *((_DWORD *)a3 + 9);
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x2Bu,
        (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
        v39,
        v35);
      return (unsigned int)-2146893007;
    }
    return (unsigned int)-2146893007;
  }
LABEL_20:
  v28 = a4;
  if ( (v21 & 0x1000) == 0 )
  {
    v29 = 0;
    goto LABEL_22;
  }
  v29 = 1;
  if ( !a4 )
    goto LABEL_22;
  HashInfo = GetHashInfo(*((_DWORD *)a3 + 11));
  if ( HashInfo )
  {
    if ( a7 != *((_DWORD *)HashInfo + 8) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        LODWORD(v35) = a7;
        WPP_SF_Sd(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x2Cu,
          (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
          v39,
          v35);
        return (unsigned int)-2146893007;
      }
      return (unsigned int)-2146893007;
    }
    v28 = a4;
LABEL_22:
    if ( v20 == 3 || v29 )
    {
      AcceptableKeyXCurve = CCipherMill::FindAcceptableKeyXCurve((CCipherMill *)a6, a2, a3, v28, a6, String2, a8, a9);
      if ( AcceptableKeyXCurve )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          LODWORD(v36) = AcceptableKeyXCurve;
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x2Du,
            (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
            (const wchar_t *)a3 + 37,
            v36);
        }
        return AcceptableKeyXCurve;
      }
    }
    else if ( v20 == 2
           && IsDheAlgorithmBlacklisted(*(struct _TLS_PARAMETERS **)(v37 + 200), *(_DWORD *)(v37 + 196), 0, String2, a6) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_S(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x2Eu,
          (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
          v39);
        return (unsigned int)-2146893007;
      }
      return (unsigned int)-2146893007;
    }
    return 0;
  }
  return 1359i64;
}
// 18001CDD3: variable 'v20' is possibly undefined
// 18003101B: variable 'v35' is possibly undefined
// 1800310ED: variable 'v29' is possibly undefined
// 1800311AF: variable 'v36' is possibly undefined
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';

//----- (000000018001CE80) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::DigestClientHello(
        CSsl3TlsServerContext *this,
        unsigned __int8 *Src,
        SIZE_T uBytes,
        char a4,
        unsigned __int8 *a5)
{
  unsigned __int8 *v5; // r13
  SIZE_T v6; // rdi
  char v9; // r15
  __int64 v10; // r8
  bool v11; // zf
  unsigned int v12; // ebx
  __int64 v13; // r12
  __int64 v14; // rax
  __int64 v15; // rcx
  HLOCAL v16; // rax
  unsigned int v17; // edi
  struct _RTL_RESOURCE *v18; // rsi
  unsigned int v19; // ecx
  __int64 v20; // rax
  unsigned __int64 v21; // r10
  unsigned int v22; // r13d
  const wchar_t **v23; // rsi
  unsigned __int8 v24; // bl
  int v25; // eax
  __int64 v26; // r8
  __int16 v27; // ax
  ULONG v28; // eax
  ULONG v29; // ebx
  __int64 v30; // rax
  unsigned int v31; // r8d
  size_t v32; // rdi
  unsigned int v33; // ecx
  unsigned int v34; // ecx
  unsigned int v35; // ebx
  __int64 v36; // r12
  int v37; // esi
  char v38; // al
  int v39; // ecx
  __int64 v40; // r13
  _QWORD **v41; // rcx
  _QWORD *v42; // r15
  __int64 v43; // rbx
  unsigned int v44; // eax
  unsigned int v45; // edx
  unsigned int v46; // ecx
  signed __int32 v47; // edi
  __int64 v48; // rdx
  _QWORD *v49; // rcx
  char v50; // al
  __int64 v51; // rax
  unsigned int v52; // ecx
  unsigned int v53; // r15d
  __int64 v54; // rdx
  int v55; // r10d
  __int64 v56; // r8
  int v57; // ebx
  __int64 v58; // rcx
  __int64 v59; // r13
  __int64 v60; // rcx
  __int64 v61; // rax
  __int64 *v62; // rsi
  __int64 v63; // rax
  __int64 v64; // rdi
  __int64 v65; // rbx
  __int64 v66; // rcx
  volatile signed __int32 *v67; // rcx
  __int64 v68; // r12
  unsigned int v69; // r9d
  unsigned int v70; // r8d
  __int64 v71; // rax
  int v72; // eax
  int v73; // r9d
  __int64 *v74; // r8
  unsigned int v75; // r10d
  unsigned int v76; // edx
  __int64 v77; // r8
  __int64 v78; // rcx
  __int64 v79; // rax
  __int64 v81; // rax
  int v82; // eax
  __int64 v83; // rcx
  CSessionCacheManager *v84; // rsi
  int v85; // r12d
  unsigned int v86; // r15d
  CSessionCacheItem *v87; // rax
  CSessionCacheItem *v88; // rdi
  unsigned int v89; // ebx
  CSessionCacheTable *v90; // rcx
  _QWORD *v91; // rsi
  __int64 *v92; // r8
  __int64 v93; // rcx
  __int64 **v94; // rax
  _QWORD *v95; // rsi
  _QWORD *v96; // rcx
  _QWORD *v97; // rax
  CSessionCacheManager *v98; // rax
  __int64 v99; // rcx
  unsigned int v100; // ecx
  unsigned int v101; // r9d
  unsigned int *v102; // r8
  int v103; // eax
  __int64 v104; // rax
  unsigned int v105; // ecx
  int v106; // eax
  size_t v107; // [rsp+20h] [rbp-E0h]
  unsigned int v109; // [rsp+44h] [rbp-BCh] BYREF
  DWORD CurrentProcessId; // [rsp+48h] [rbp-B8h]
  unsigned __int64 v111; // [rsp+50h] [rbp-B0h]
  size_t Size; // [rsp+58h] [rbp-A8h] BYREF
  unsigned __int8 *v113; // [rsp+60h] [rbp-A0h]
  unsigned int *v114; // [rsp+68h] [rbp-98h] BYREF
  CSessionCacheManager *v115; // [rsp+70h] [rbp-90h]
  PRTL_RESOURCE Resource; // [rsp+78h] [rbp-88h]
  __int64 v117; // [rsp+80h] [rbp-80h] BYREF
  unsigned __int8 v118[16]; // [rsp+88h] [rbp-78h] BYREF
  __int128 v119; // [rsp+98h] [rbp-68h]
  int v120[6]; // [rsp+A8h] [rbp-58h] BYREF
  _BYTE Source1[20]; // [rsp+C0h] [rbp-40h] BYREF
  __int16 v122; // [rsp+D8h] [rbp-28h] BYREF
  __int128 v123; // [rsp+DAh] [rbp-26h]
  __int128 v124; // [rsp+EAh] [rbp-16h]
  __int16 v125; // [rsp+FAh] [rbp-6h]
  char v126[272]; // [rsp+100h] [rbp+0h] BYREF
  UCHAR pbBuffer[16]; // [rsp+210h] [rbp+110h] BYREF
  __int128 v128; // [rsp+220h] [rbp+120h]
  __int128 Buf1[2]; // [rsp+230h] [rbp+130h] BYREF

  v5 = a5;
  v6 = (unsigned int)uBytes;
  v113 = a5;
  LODWORD(Size) = 0;
  memset(Buf1, 0, sizeof(Buf1));
  v9 = a4;
  memset_0(v126, 0, sizeof(v126));
  v11 = *((_BYTE *)this + 233) == 0;
  v12 = 4;
  v109 = 68;
  v114 = (unsigned int *)v126;
  v13 = 12i64;
  if ( !v11 )
    v12 = 12;
  v115 = CSessionCacheManager::m_pSessionCacheManager;
  *(_OWORD *)pbBuffer = 0i64;
  v128 = 0i64;
  if ( !Src || (unsigned int)v6 < v12 || !a5 )
    return 87i64;
  *a5 = 0;
  if ( *((_QWORD *)this + 110) )
  {
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 110) = 0i64;
  }
  v14 = *((_QWORD *)this + 16);
  *((_DWORD *)this + 218) = v6;
  v15 = *(_QWORD *)(v14 + 24);
  if ( v15 )
  {
    LOBYTE(v10) = 1;
    v16 = (HLOCAL)(*(__int64 (__fastcall **)(__int64, SIZE_T, __int64))(*(_QWORD *)v15 + 48i64))(v15, v6, v10);
  }
  else if ( LsaTable )
  {
    v16 = (HLOCAL)(*(__int64 (__fastcall **)(_QWORD))(LsaTable + 40))((unsigned int)v6);
  }
  else
  {
    v16 = LocalAlloc(0x40u, v6);
  }
  *((_QWORD *)this + 110) = v16;
  if ( !v16 )
  {
    v29 = 14;
    goto LABEL_123;
  }
  memcpy_0(v16, Src, *((unsigned int *)this + 218));
  v17 = v6 - v12;
  v18 = (struct _RTL_RESOURCE *)&Src[v12];
  CurrentProcessId = v17;
  v11 = (*((_DWORD *)this + 16) & 0x40400) == 0;
  Resource = v18;
  if ( !v11 )
  {
    RtlAcquireResourceShared(&::Resource, 1u);
    *((_WORD *)this + 237) = 0;
    *((_WORD *)this + 254) = 0;
    v19 = (unsigned __int16)word_1800925E8;
    if ( (unsigned __int16)word_1800925E8 <= 0x10u )
    {
      *((_WORD *)this + 237) = word_1800925E8;
      *((_WORD *)this + 254) = word_18009260A;
      memcpy_0((char *)this + 476, &xmmword_1800925EA, 2i64 * v19);
    }
    RtlReleaseResource(&::Resource);
    v20 = *((_QWORD *)this + 10);
    v21 = *(_QWORD *)(v20 + 200);
    v111 = v21;
    if ( v21 )
    {
      v22 = *(_DWORD *)(v20 + 196);
      if ( v22 )
      {
        v23 = (const wchar_t **)&off_18007C3B0;
        *((_WORD *)this + 237) = 0;
        v24 = 0;
        do
        {
          if ( v24 < 0xCu )
          {
            v25 = *((unsigned __int16 *)this + 254);
            if ( ((1 << v24) & v25) != 0 )
            {
              *((_WORD *)this + 254) = v25 & ~(1 << v24);
              if ( IsCngAlgorithmBlacklisted(v21, v22, 4, v23[2], 0i64, 0, 0i64, 1)
                || IsCngAlgorithmBlacklisted(v111, v22, 4, *v23, 0i64, 0, 0i64, 1)
                || (*((unsigned __int16 *)this + 254) & (1 << v24)) != 0 )
              {
                v21 = v111;
              }
              else
              {
                v26 = *((unsigned __int16 *)this + 237);
                v21 = v111;
                if ( (unsigned int)v26 < 0x10 )
                {
                  *((_WORD *)this + v26 + 238) = __ROR2__(*((_WORD *)&unk_18007C390 + 36 * v24), 8);
                  v27 = *((_WORD *)this + 254);
                  ++*((_WORD *)this + 237);
                  *((_WORD *)this + 254) = v27 | (1 << v24);
                }
              }
            }
          }
          v23 += 9;
          ++v24;
          --v13;
        }
        while ( v13 );
        if ( !*((_WORD *)this + 237) )
        {
          v29 = -2146893007;
          goto LABEL_123;
        }
        v17 = CurrentProcessId;
        v18 = Resource;
        v9 = a4;
      }
      v5 = v113;
    }
    *((_BYTE *)this + 925) = 0;
  }
  v28 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, struct _RTL_RESOURCE *, _QWORD, __int128 *, size_t *, unsigned int **, unsigned int *))(*(_QWORD *)this + 528i64))(
          this,
          v18,
          v17,
          Buf1,
          &Size,
          &v114,
          &v109);
  v29 = v28;
  if ( v28 )
  {
    if ( v28 != -2146892986 && v28 != -2146892953 )
    {
      v29 = -2146893048;
      CSslContext::SetErrorAndFatalAlert((__int64)this, 1200, -2146893048, 0xAu);
    }
    goto LABEL_123;
  }
  v30 = *((_QWORD *)this + 17);
  if ( (v30 & 0x8000000) == 0 )
    *((_QWORD *)this + 17) = v30 & 0xFFFFFFFFFFBFFFFFui64;
  if ( (*((_DWORD *)this + 16) & 0x40400) != 0 )
  {
    if ( !*((_BYTE *)this + 925) )
    {
      v122 = 0;
      v123 = 0i64;
      v125 = 0;
      v124 = 0i64;
      CTlsSignatureSuiteList::SetDefaultClientHello((CTlsSignatureSuiteList *)&v122);
      CTlsSignatureSuiteList::SetSignatureSuiteList(
        (CSsl3TlsServerContext *)((char *)this + 510),
        (CSsl3TlsServerContext *)((char *)this + 474));
      CTlsSignatureSuiteList::Restrict(
        (CSsl3TlsServerContext *)((char *)this + 510),
        (const struct CTlsSignatureSuiteList *)&v122,
        *((_DWORD *)this + 16));
    }
    if ( !*((_WORD *)this + 255) )
    {
      v29 = -2146893007;
      CSslContext::SetErrorAndFatalAlert((__int64)this, 1206, -2146893007, 0x28u);
      goto LABEL_123;
    }
  }
  if ( !v9 || (*((_DWORD *)this + 34) & 0x8000000) == 0 )
    goto LABEL_119;
  v31 = *((_DWORD *)this + 246);
  if ( v31 )
  {
    LODWORD(v107) = Size;
    *v5 = CSsl3TlsServerContext::UnprotectAndDeserializeSessionState(
            this,
            *((unsigned __int8 *const *)this + 122),
            v31,
            (unsigned __int8 *const)Buf1,
            v107);
    v104 = *((_QWORD *)this + 15);
    if ( v104 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    {
      *(_WORD *)(v104 + 64) |= 2u;
      *(_DWORD *)(v104 + 24) = 1;
    }
    goto LABEL_74;
  }
  v32 = (unsigned int)Size;
  if ( !(_DWORD)Size )
    goto LABEL_74;
  if ( (unsigned int)Size < 4 )
  {
    v50 = 0;
    goto LABEL_71;
  }
  if ( LODWORD(Buf1[0]) >= *((_DWORD *)v115 + 4) )
  {
    v50 = 0;
    goto LABEL_71;
  }
  v33 = *((_DWORD *)v115 + 13);
  if ( v33 == 1000 )
  {
    v34 = LODWORD(Buf1[0]) / 0x3E8;
    v35 = LODWORD(Buf1[0]) - 1000 * ((LODWORD(Buf1[0]) / 0x3E8) & 0x3FFFFFF);
  }
  else
  {
    v35 = LODWORD(Buf1[0]) % v33;
    v34 = LODWORD(Buf1[0]) / v33;
  }
  v36 = *((_QWORD *)v115 + 5) + 152i64 * v34;
  v37 = 0;
  LODWORD(v111) = GetTickCount();
  if ( LsaTable )
  {
    v38 = (*(__int64 (__fastcall **)(int *))(LsaTable + 192))(v120);
    v39 = -1;
    if ( v38 )
      v39 = v120[0];
    CurrentProcessId = v39;
  }
  else
  {
    CurrentProcessId = GetCurrentProcessId();
  }
  Resource = (PRTL_RESOURCE)(v36 + 48);
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(v36 + 48), 1u);
  v40 = 16i64 * v35;
  v41 = (_QWORD **)(v40 + *(_QWORD *)v36);
  v42 = *v41;
  if ( *v41 == v41 )
  {
LABEL_170:
    v43 = v117;
    goto LABEL_68;
  }
  while ( 1 )
  {
    v43 = (__int64)(v42 - 36);
    v42 = (_QWORD *)*v42;
    RtlAcquireResourceShared((PRTL_RESOURCE)(v43 + 72), 1u);
    if ( !*(_BYTE *)(v43 + 236) )
      goto LABEL_126;
    v44 = *(_DWORD *)(v43 + 276);
    v45 = *(_DWORD *)(v43 + 280);
    v46 = v111 - v44;
    if ( (unsigned int)v111 <= v44 )
      break;
    if ( v46 <= v45 )
      goto LABEL_53;
LABEL_126:
    RtlReleaseResource((PRTL_RESOURCE)(v43 + 72));
    if ( v42 == (_QWORD *)(v40 + *(_QWORD *)v36) )
    {
      RtlReleaseResource(Resource);
      goto LABEL_169;
    }
  }
  if ( (unsigned int)v111 < v44 && v46 - 1 >= v45 )
    goto LABEL_126;
LABEL_53:
  if ( (_DWORD)v32 != *(unsigned __int16 *)(v43 + 238) )
    goto LABEL_126;
  if ( memcmp_0(Buf1, (const void *)(v43 + 240), v32) )
    goto LABEL_126;
  if ( *(_DWORD *)(v43 + 272) != CurrentProcessId )
    goto LABEL_126;
  v117 = *(_QWORD *)(*((_QWORD *)this + 10) + 760i64);
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, _QWORD, _QWORD, __int64 *, _DWORD))(*(_QWORD *)v43 + 80i64))(
          v43,
          0i64,
          0i64,
          &v117,
          *((_DWORD *)this + 16)) )
    goto LABEL_126;
  v47 = _InterlockedIncrement((volatile signed __int32 *)(v43 + 232));
  v37 = v47;
  if ( v47 != 2 )
  {
    RtlReleaseResource((PRTL_RESOURCE)(v43 + 72));
    if ( v47 )
      goto LABEL_60;
    goto LABEL_170;
  }
  LsaIModifyPerformanceCounter(5i64);
  RtlReleaseResource((PRTL_RESOURCE)(v43 + 72));
LABEL_60:
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_54aae497645f38b3b161e68e12f6f932_Traceguids, v43);
  if ( v47 == 2 )
  {
    v48 = *(_QWORD *)(v43 + 320);
    if ( *(_QWORD *)(v48 + 8) == v43 + 320 )
    {
      v49 = *(_QWORD **)(v43 + 328);
      if ( *v49 == v43 + 320 )
      {
        *v49 = v48;
        *(_QWORD *)(v48 + 8) = v49;
        goto LABEL_67;
      }
    }
LABEL_140:
    __fastfail(3u);
  }
LABEL_67:
  LsaIModifyPerformanceCounter(9i64);
LABEL_68:
  RtlReleaseResource(Resource);
  if ( v37 <= 0 )
  {
LABEL_169:
    v50 = 0;
    *((_QWORD *)this + 124) = 0i64;
  }
  else
  {
    *((_QWORD *)this + 124) = v43;
    v50 = 1;
  }
  v5 = v113;
LABEL_71:
  *v5 = v50;
  v51 = *((_QWORD *)this + 15);
  if ( v51 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
  {
    *(_WORD *)(v51 + 64) |= 1u;
    *(_DWORD *)(v51 + 24) = 1;
  }
LABEL_74:
  if ( *v5 )
  {
    v52 = v109;
    v53 = 0;
    if ( !v109 )
      goto LABEL_118;
    v54 = *(_QWORD *)(*((_QWORD *)this + 124) + 176i64);
    while ( 1 )
    {
      v55 = v54 ? *(_DWORD *)(v54 + 28) : 0;
      v56 = v53;
      if ( v114[v56] == v55 )
        break;
      if ( ++v53 >= v109 )
        goto LABEL_118;
    }
    v57 = *((_DWORD *)this + 17);
    if ( (unsigned int)CCipherMill::ChooseServerCipher(
                         (CCipherMill *)g_cCipherMill,
                         this,
                         &v114[v56],
                         1u,
                         *((_DWORD *)this + 16),
                         *v5) )
    {
      *((_WORD *)this + 48) = 0;
      *((_DWORD *)this + 17) = v57;
    }
    else
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 48i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      v58 = *((_QWORD *)this + 124);
      *((_QWORD *)this + 11) = v58;
      RtlAcquireResourceExclusive((PRTL_RESOURCE)(v58 + 72), 1u);
      v59 = *((_QWORD *)this + 11);
      v60 = *(_QWORD *)(v59 + 176);
      v61 = *(_QWORD *)(v60 + 848);
      if ( v61 )
        _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v61 + 16) + 12i64));
      _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v60 + 856) + 12i64));
      v62 = *(__int64 **)(v59 + 176);
      v63 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 248i64))(this);
      v64 = *((_QWORD *)this + 1);
      v65 = v63;
      if ( v64 )
      {
        v66 = *(_QWORD *)(v64 + 848);
        if ( v66 )
          CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v66 + 16));
        CMasterCipherInfo::Dereference(*(CMasterCipherInfo **)(v64 + 856));
      }
      v67 = (volatile signed __int32 *)*((_QWORD *)this + 3);
      if ( v67 )
      {
        if ( _InterlockedExchangeAdd(v67 + 6, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *, __int64))(*(_QWORD *)v67 + 8i64))(v67, 1i64);
        *((_QWORD *)this + 3) = 0i64;
      }
      if ( v65 )
      {
        v68 = *v62;
        RtlAcquireResourceShared((PRTL_RESOURCE)(v65 + 552), 1u);
        v69 = *(_DWORD *)(v65 + 96);
        v70 = 0;
        if ( v69 )
        {
          while ( 1 )
          {
            v71 = *(_QWORD *)(*(_QWORD *)(v65 + 88) + 8i64 * v70);
            if ( *(_QWORD *)(v71 + 16) == v68 )
              break;
            if ( ++v70 >= v69 )
              goto LABEL_100;
          }
          _InterlockedIncrement((volatile signed __int32 *)(v71 + 24));
          *((_QWORD *)this + 3) = *(_QWORD *)(*(_QWORD *)(v65 + 88) + 8i64 * v70);
        }
LABEL_100:
        RtlReleaseResource((PRTL_RESOURCE)(v65 + 552));
      }
      if ( (*((_DWORD *)this + 16) & 0xF3F00) != 0 )
      {
        if ( !(unsigned int)SslLookupCipherLengths(
                              *v62,
                              *((unsigned __int16 *)this + 17),
                              *((unsigned int *)v62 + 7),
                              *((unsigned int *)this + 4),
                              Source1,
                              20,
                              0) )
          goto LABEL_103;
      }
      else
      {
        v105 = *((_DWORD *)v62 + 3);
        v106 = *((_DWORD *)v62 + 4);
        *(_QWORD *)Source1 = 20i64;
        *(_QWORD *)&Source1[12] = 0i64;
        *(_DWORD *)&Source1[8] = v106;
        if ( v105 > 1 )
        {
          *(_DWORD *)&Source1[16] |= 1u;
          *(_DWORD *)&Source1[12] = v105;
        }
LABEL_103:
        if ( (*((_BYTE *)this + 32) & 1) == 0 || RtlCompareMemory(Source1, (char *)this + 40, 0x14ui64) == 20 )
        {
          v72 = *(_DWORD *)&Source1[16];
          *(_OWORD *)((char *)this + 40) = *(_OWORD *)Source1;
          *((_DWORD *)this + 14) = v72;
        }
      }
      *((_WORD *)this + 16) |= 1u;
      *((_QWORD *)this + 1) = v62;
      v73 = *(_DWORD *)(v59 + 184);
      *((_DWORD *)this + 4) = v73;
      v74 = (__int64 *)v62[106];
      if ( v74 )
      {
        v75 = *((_DWORD *)v74 + 2);
        v76 = 0;
        if ( v75 )
        {
          v77 = *v74;
          while ( 1 )
          {
            v78 = 780i64 * v76;
            if ( *(_DWORD *)(v77 + v78 + 772) == v73 )
              break;
            if ( ++v76 >= v75 )
              goto LABEL_114;
          }
          if ( v77 + v78 )
            *((_DWORD *)this + 5) = *(_DWORD *)(v77 + v78 + 776);
        }
      }
LABEL_114:
      RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
      v79 = *((_QWORD *)this + 15);
      if ( v79 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
      {
        *(_WORD *)(v79 + 64) |= 4u;
        *(_DWORD *)(v79 + 24) = 1;
      }
      v5 = v113;
      v52 = v109;
LABEL_118:
      if ( v53 != v52 )
      {
LABEL_119:
        if ( *v5 )
          goto LABEL_120;
        goto LABEL_129;
      }
    }
    *(_BYTE *)(*((_QWORD *)this + 124) + 236i64) = 0;
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 240i64))(this);
    *v5 = 0;
  }
LABEL_129:
  v81 = *((_QWORD *)this + 17);
  if ( (v81 & 0x800) != 0 && *((_DWORD *)this + 246) )
    *((_QWORD *)this + 17) = v81 | 0x400000;
  v82 = BCryptGenRandom(0i64, pbBuffer, 0x20u, 2u);
  if ( v82 >= 0 || (v29 = RtlNtStatusToDosError(v82)) == 0 )
  {
    if ( CSessionCacheManager::m_pSessionCacheManager )
    {
      v83 = *((_QWORD *)CSessionCacheManager::m_pSessionCacheManager + 5)
          + 152i64
          * ((unsigned int)(*(_DWORD *)pbBuffer % *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 4))
           / *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 13));
      if ( v83 )
        RtlAcquireResourceExclusive((PRTL_RESOURCE)(v83 + 48), 1u);
    }
    v84 = v115;
    v85 = *((_DWORD *)this + 16);
    v86 = *(_DWORD *)pbBuffer % *((_DWORD *)v115 + 4);
    *(_OWORD *)v118 = *(_OWORD *)pbBuffer;
    *(_DWORD *)v118 = v86;
    v119 = v128;
    if ( g_SslMachineID != -1 )
      *(_DWORD *)&v118[4] = g_SslMachineID;
    v87 = (CSessionCacheItem *)(*(__int64 (__fastcall **)(struct IAllocate *, __int64))(*(_QWORD *)CSessionCacheServerItem::m_pServerCacheLookaside
                                                                                      + 24i64))(
                                 CSessionCacheServerItem::m_pServerCacheLookaside,
                                 360i64);
    v88 = v87;
    if ( v87 )
    {
      CSessionCacheItem::CSessionCacheItem(v87, *((_DWORD *)v84 + 6), v118);
      *((_DWORD *)v88 + 54) = -2146893019;
      *(_QWORD *)v88 = &CSessionCacheServerItem::`vftable';
      *((_QWORD *)v88 + 42) = 0i64;
      *((_QWORD *)v88 + 43) = 0i64;
      *((_DWORD *)v88 + 88) = 0;
      v29 = *((_DWORD *)v88 + 17);
      if ( v29 )
      {
        CSessionCacheServerItem::`vector deleting destructor'(v88, 1);
      }
      else
      {
        v89 = *((_DWORD *)v84 + 13);
        v90 = (CSessionCacheTable *)(v86 / v89);
        v91 = (_QWORD *)(*((_QWORD *)v115 + 5) + 152i64 * (_QWORD)v90);
        CSessionCacheTable::ReferenceCacheItemInternal(v90, v88);
        *((_QWORD *)v88 + 28) = v91;
        v92 = (__int64 *)((char *)v88 + 288);
        v93 = *v91 + 16i64 * (v86 % v89);
        v94 = *(__int64 ***)(v93 + 8);
        if ( *v94 != (__int64 *)v93 )
          goto LABEL_140;
        *v92 = v93;
        v95 = v91 + 2;
        *((_QWORD *)v88 + 37) = v94;
        *v94 = v92;
        *(_QWORD *)(v93 + 8) = v92;
        v96 = (_QWORD *)((char *)v88 + 304);
        v97 = (_QWORD *)v95[1];
        if ( (_QWORD *)*v97 != v95 )
          goto LABEL_140;
        *((_QWORD *)v88 + 39) = v97;
        *v96 = v95;
        *v97 = v96;
        v98 = v115;
        v95[1] = v96;
        _InterlockedIncrement((volatile signed __int32 *)v98 + 8);
        LsaIModifyPerformanceCounter(4i64);
        *((_QWORD *)this + 124) = v88;
        v29 = 0;
        *((_DWORD *)v88 + 42) = v85;
      }
    }
    else
    {
      v29 = 14;
    }
    if ( CSessionCacheManager::m_pSessionCacheManager )
    {
      v99 = *((_QWORD *)CSessionCacheManager::m_pSessionCacheManager + 5)
          + 152i64
          * ((unsigned int)(*(_DWORD *)pbBuffer % *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 4))
           / *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 13));
      if ( v99 )
        RtlReleaseResource((PRTL_RESOURCE)(v99 + 48));
    }
    if ( !v29 )
    {
      v100 = *((_DWORD *)this + 16);
      v101 = v109;
      v102 = v114;
      *((_QWORD *)this + 11) = *((_QWORD *)this + 124);
      v103 = CCipherMill::ChooseServerCipher((CCipherMill *)g_cCipherMill, this, v102, v101, v100, *v5);
      v29 = v103;
      if ( v103 )
      {
        CSslContext::SetErrorAndFatalAlert((__int64)this, 1205, v103, 0x28u);
      }
      else
      {
LABEL_120:
        v11 = *((_BYTE *)this + 233) == 0;
        *((_BYTE *)this + 555) = 0;
        if ( !v11 )
          CSsl3TlsContext::FreeSavedWriteCipherState(this);
        v29 = 0;
      }
    }
  }
LABEL_123:
  *((_QWORD *)this + 122) = 0i64;
  *((_DWORD *)this + 246) = 0;
  if ( v114 != (unsigned int *)v126 )
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 16i64))(this);
  return v29;
}
// 1800311E3: variable 'v10' is possibly undefined
// 1800312EA: variable 'v107' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18007C330: using guessed type void *CSessionCacheServerItem::`vftable';
// 18007C3B0: using guessed type wchar_t *off_18007C3B0;
// 1800919F4: using guessed type unsigned int g_SslMachineID;
// 1800925E8: using guessed type __int16 word_1800925E8;
// 1800925EA: using guessed type __int128 xmmword_1800925EA;
// 18009260A: using guessed type __int16 word_18009260A;
// 180092620: using guessed type __int64 LsaTable;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 1800927F8: using guessed type struct IAllocate *CSessionCacheServerItem::m_pServerCacheLookaside;
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);
// 1800984F0: using guessed type __int64 __fastcall SslLookupCipherLengths(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);
// 18001CE80: using guessed type int var_1E8[6];

//----- (000000018001DB80) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::DigestClientHello(
        CTls13ServerContext *this,
        unsigned __int8 *Src,
        SIZE_T uBytes)
{
  unsigned int v3; // ebx
  SIZE_T v4; // rdi
  __int64 v7; // r14
  __int64 v8; // r8
  __int64 v9; // rdx
  __int64 v10; // rax
  __int64 v11; // rcx
  HLOCAL v12; // rax
  unsigned __int8 *v13; // rbp
  unsigned int v14; // edi
  unsigned int v15; // ecx
  __int64 v16; // rax
  unsigned __int64 v17; // r13
  unsigned int v18; // r12d
  const wchar_t **v19; // rsi
  unsigned __int8 v20; // bl
  int v21; // eax
  __int64 v22; // r8
  __int16 v23; // ax
  __int64 v24; // rax
  unsigned int v25; // eax
  unsigned int RandomBits; // ebx
  __int64 v27; // rax
  int v28; // ecx
  __int64 v29; // rax
  __int64 v30; // rbx
  __int64 v31; // rdi
  __int64 v32; // rbp
  __int64 v33; // rsi
  __int64 v34; // rbx
  _WORD *v36; // rax
  int v37; // r14d
  CSessionCacheManager *v38; // rbp
  __int64 *v39; // rdi
  unsigned __int8 v40; // si
  __int64 v41; // rax
  __int64 v42; // rcx
  __int64 v43; // rcx
  unsigned int v44; // r9d
  unsigned int *v45; // r8
  int v46; // r14d
  unsigned int v47; // eax
  __int64 v48; // rax
  __int64 v49; // rax
  unsigned int v50; // [rsp+40h] [rbp-198h] BYREF
  unsigned int v51; // [rsp+44h] [rbp-194h] BYREF
  unsigned int v52; // [rsp+48h] [rbp-190h]
  unsigned int *v53; // [rsp+50h] [rbp-188h] BYREF
  unsigned __int8 *v54; // [rsp+58h] [rbp-180h]
  char v55[272]; // [rsp+60h] [rbp-178h] BYREF
  UCHAR pbBuffer[16]; // [rsp+170h] [rbp-68h] BYREF
  __int128 v57; // [rsp+180h] [rbp-58h]

  v3 = 4;
  v4 = (unsigned int)uBytes;
  v7 = 12i64;
  if ( *((_BYTE *)this + 233) )
    v3 = 12;
  if ( !Src || (unsigned int)uBytes < v3 || !*((_QWORD *)this + 10) )
    return 87i64;
  v50 = 0;
  memset_0(v55, 0, sizeof(v55));
  v9 = *((_QWORD *)this + 110);
  v53 = (unsigned int *)v55;
  v51 = 68;
  if ( v9 )
  {
    (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 110) = 0i64;
  }
  v10 = *((_QWORD *)this + 16);
  *((_DWORD *)this + 218) = v4;
  v11 = *(_QWORD *)(v10 + 24);
  if ( v11 )
  {
    LOBYTE(v8) = 1;
    v12 = (HLOCAL)(*(__int64 (__fastcall **)(__int64, SIZE_T, __int64))(*(_QWORD *)v11 + 48i64))(v11, v4, v8);
  }
  else if ( LsaTable )
  {
    v12 = (HLOCAL)(*(__int64 (__fastcall **)(_QWORD))(LsaTable + 40))((unsigned int)v4);
  }
  else
  {
    v12 = LocalAlloc(0x40u, v4);
  }
  *((_QWORD *)this + 110) = v12;
  if ( !v12 )
    return 14i64;
  memcpy_0(v12, Src, *((unsigned int *)this + 218));
  v13 = &Src[v3];
  v14 = v4 - v3;
  v54 = v13;
  v52 = v14;
  RtlAcquireResourceShared(&Resource, 1u);
  *((_WORD *)this + 237) = 0;
  *((_WORD *)this + 254) = 0;
  v15 = (unsigned __int16)word_1800925E8;
  if ( (unsigned __int16)word_1800925E8 <= 0x10u )
  {
    *((_WORD *)this + 237) = word_1800925E8;
    *((_WORD *)this + 254) = word_18009260A;
    memcpy_0((char *)this + 476, &xmmword_1800925EA, 2i64 * v15);
  }
  RtlReleaseResource(&Resource);
  v16 = *((_QWORD *)this + 10);
  v17 = *(_QWORD *)(v16 + 200);
  if ( v17 )
  {
    v18 = *(_DWORD *)(v16 + 196);
    if ( v18 )
    {
      v19 = (const wchar_t **)&off_18007C3B0;
      *((_WORD *)this + 237) = 0;
      v20 = 0;
      do
      {
        if ( v20 < 0xCu )
        {
          v21 = *((unsigned __int16 *)this + 254);
          if ( ((1 << v20) & v21) != 0 )
          {
            *((_WORD *)this + 254) = v21 & ~(1 << v20);
            if ( !IsCngAlgorithmBlacklisted(v17, v18, 4, v19[2], 0i64, 0, 0i64, 1)
              && !IsCngAlgorithmBlacklisted(v17, v18, 4, *v19, 0i64, 0, 0i64, 1)
              && (*((unsigned __int16 *)this + 254) & (1 << v20)) == 0 )
            {
              v22 = *((unsigned __int16 *)this + 237);
              if ( (unsigned int)v22 < 0x10 )
              {
                *((_WORD *)this + v22 + 238) = __ROR2__(*((_WORD *)&unk_18007C390 + 36 * v20), 8);
                v23 = *((_WORD *)this + 254);
                ++*((_WORD *)this + 237);
                *((_WORD *)this + 254) = v23 | (1 << v20);
              }
            }
          }
        }
        v19 += 9;
        ++v20;
        --v7;
      }
      while ( v7 );
      if ( !*((_WORD *)this + 237) )
        return 2148074289i64;
      v14 = v52;
      v13 = v54;
    }
  }
  v24 = *(_QWORD *)this;
  *((_BYTE *)this + 925) = 0;
  v25 = (*(__int64 (__fastcall **)(CTls13ServerContext *, unsigned __int8 *, _QWORD, char *, unsigned int *, unsigned int **, unsigned int *))(v24 + 528))(
          this,
          v13,
          v14,
          (char *)this + 1249,
          &v50,
          &v53,
          &v51);
  RandomBits = v25;
  if ( v25 )
  {
    if ( v25 != -2146892986 && v25 != -2146892953 )
    {
      RandomBits = -2146893048;
      CSslContext::SetErrorAndFatalAlert((__int64)this, 1200, -2146893048, 0xAu);
    }
    goto LABEL_36;
  }
  v27 = *((_QWORD *)this + 10);
  if ( !v27 )
  {
LABEL_46:
    RandomBits = 1359;
    goto LABEL_36;
  }
  v28 = *((_DWORD *)this + 16);
  if ( (v28 & *(_DWORD *)(v27 + 152) & 0x51550) == 0 )
    goto LABEL_47;
  if ( (v28 & 0x1000) != 0 )
  {
    if ( v50 <= 0x20 )
    {
      v38 = CSessionCacheManager::m_pSessionCacheManager;
      *((_BYTE *)this + 1281) = v50;
      if ( v38 )
      {
        while ( 1 )
        {
          if ( (*((_DWORD *)this + 34) & 0x8000i64) != 0 )
          {
            v40 = 0;
            *(_OWORD *)pbBuffer = 0i64;
            v57 = 0i64;
            RandomBits = GenerateRandomBits(pbBuffer, 0x20u);
            if ( RandomBits )
              goto LABEL_36;
            CSessionCacheManager::AcquireCacheTableLock(v42, 0i64, pbBuffer);
            v39 = (__int64 *)((char *)this + 992);
            RandomBits = CSessionCacheManager::CacheRetrieveNewServerItem(
                           v38,
                           *((_DWORD *)this + 16),
                           pbBuffer,
                           (struct CSessionCacheServerItem **)this + 124);
            CSessionCacheManager::ReleaseCacheTableLock(v43, 0i64, pbBuffer);
            if ( RandomBits )
              goto LABEL_36;
            v41 = *((_QWORD *)this + 124);
          }
          else
          {
            v39 = (__int64 *)((char *)this + 992);
            v40 = 1;
            v41 = *((_QWORD *)this + 124);
            if ( !v41 )
              goto LABEL_46;
          }
          v44 = v51;
          v45 = v53;
          v46 = *((_DWORD *)this + 17);
          *((_QWORD *)this + 11) = v41;
          v47 = CCipherMill::ChooseServerCipher(
                  (CCipherMill *)g_cCipherMill,
                  this,
                  v45,
                  v44,
                  *((_DWORD *)this + 16),
                  v40);
          RandomBits = v47;
          if ( !v40 )
            goto LABEL_36;
          if ( !v47 )
            break;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 65i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
          }
          v48 = *v39;
          *((_WORD *)this + 48) = 0;
          *((_DWORD *)this + 17) = v46;
          *(_BYTE *)(v48 + 236) = 0;
          *((_QWORD *)this + 17) |= 0x8000ui64;
          (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 240i64))(this);
          *((_QWORD *)this + 11) = 0i64;
        }
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 64i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
        v49 = *((_QWORD *)this + 15);
        if ( v49 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
        {
          *(_WORD *)(v49 + 64) |= 4u;
          *(_DWORD *)(v49 + 24) = 1;
        }
      }
      else
      {
        RandomBits = 1359;
      }
    }
    else
    {
      RandomBits = 1359;
    }
    goto LABEL_36;
  }
  if ( *((_DWORD *)this + 17) == 71 )
  {
LABEL_47:
    RandomBits = -2146893007;
    CSslContext::SetErrorAndFatalAlert((__int64)this, 11, -2146893007, 0x46u);
    goto LABEL_36;
  }
  *((_QWORD *)this + 17) &= ~0x8000ui64;
  v29 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)xmmword_180092DD0 + 16i64))(xmmword_180092DD0);
  v30 = v29;
  if ( !v29 )
  {
    RandomBits = 14;
    goto LABEL_36;
  }
  *(_QWORD *)(v29 + 8) = 0i64;
  v31 = v29;
  v32 = v29;
  CSsl3TlsContext::CSsl3TlsContext((CSsl3TlsContext *)(v29 + 40), (__int64)this);
  *(_QWORD *)(v30 + 40) = &CSsl3TlsServerContext::`vftable';
  v33 = v30 + 40;
  *(_QWORD *)(v30 + 968) = *((_QWORD *)this + 116);
  *(_QWORD *)(v30 + 976) = *((_QWORD *)this + 117);
  *(_QWORD *)(v30 + 984) = *((_QWORD *)this + 118);
  *(_WORD *)(v30 + 992) = *((_WORD *)this + 476);
  *(_QWORD *)(v30 + 1000) = *((_QWORD *)this + 120);
  *(_QWORD *)(v30 + 1008) = *((_QWORD *)this + 121);
  *(_QWORD *)(v30 + 1016) = *((_QWORD *)this + 122);
  *(_DWORD *)(v30 + 1024) = *((_DWORD *)this + 246);
  *(_BYTE *)(v30 + 1028) = *((_BYTE *)this + 988);
  *(_QWORD *)(v30 + 1032) = *((_QWORD *)this + 124);
  v34 = v30 + 1040;
  *((_QWORD *)this + 116) = 0i64;
  *((_QWORD *)this + 117) = 0i64;
  *((_QWORD *)this + 118) = 0i64;
  *((_WORD *)this + 476) = 0;
  *((_QWORD *)this + 120) = 0i64;
  *((_QWORD *)this + 121) = 0i64;
  *((_QWORD *)this + 122) = 0i64;
  *((_DWORD *)this + 246) = 0;
  *((_BYTE *)this + 988) = 0;
  *((_QWORD *)this + 124) = 0i64;
  if ( *((_QWORD *)&xmmword_180092DD0 + 1) )
  {
    v36 = (_WORD *)(*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)&xmmword_180092DD0 + 1) + 16i64))(*((_QWORD *)&xmmword_180092DD0 + 1));
    v37 = qword_180092DC0;
LABEL_51:
    if ( v36 && v37 )
    {
      *(_QWORD *)(v34 + 8) = 0i64;
      *(_QWORD *)v34 = &CSslScratchAllocator::`vftable';
      *(_WORD *)(v34 + 16) = v37;
      *(_DWORD *)(v34 + 18) = 0;
      if ( (unsigned __int16)v37 > 4u )
      {
        *(_QWORD *)(v34 + 8) = v36;
        *v36 = 0;
        *(_WORD *)(*(_QWORD *)(v34 + 8) + 2i64) = v37 - 4;
      }
      *(_QWORD *)(v31 + 24) = v34;
    }
    goto LABEL_35;
  }
  if ( byte_180092DE4 )
  {
    v37 = 2048;
    v36 = SPExternalAlloc(0x800u);
    *(_BYTE *)(v31 + 32) = 1;
    goto LABEL_51;
  }
LABEL_35:
  *(_QWORD *)(v31 + 8) = v33;
  RandomBits = 1359;
  *(_QWORD *)(v33 + 128) = v31;
  *(_QWORD *)(*((_QWORD *)this + 16) + 16i64) = *(_QWORD *)(v32 + 8);
  *((_QWORD *)this + 17) |= 0x40000ui64;
LABEL_36:
  if ( v53 != (unsigned int *)v55 )
    (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 16i64))(this);
  return RandomBits;
}
// 18003154B: variable 'v8' is possibly undefined
// 180031708: variable 'v42' is possibly undefined
// 180031737: variable 'v43' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18007C3B0: using guessed type wchar_t *off_18007C3B0;
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';
// 18007D508: using guessed type void *CSslScratchAllocator::`vftable';
// 1800925E8: using guessed type __int16 word_1800925E8;
// 1800925EA: using guessed type __int128 xmmword_1800925EA;
// 18009260A: using guessed type __int16 word_18009260A;
// 180092620: using guessed type __int64 LsaTable;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 180092DC0: using guessed type __int64 qword_180092DC0;
// 180092DD0: using guessed type __int128 xmmword_180092DD0;
// 180092DE4: using guessed type char byte_180092DE4;

//----- (000000018001E0C0) ----------------------------------------------------
__int64 __fastcall CTlsExtServer::ParseExtension(__int64 a1, int a2, unsigned __int8 *a3, unsigned __int16 a4)
{
  unsigned __int8 *v4; // r15
  __int64 v6; // r14
  __int16 *v7; // r8
  __int64 v8; // rcx
  __int64 result; // rax
  __int64 v10; // r11
  int v11; // esi
  int v12; // eax
  int v13; // r9d
  int v14; // ebx
  _WORD *v15; // rdi
  unsigned int v16; // ebx
  unsigned int v17; // ecx
  __int64 v18; // r10
  unsigned __int8 v19; // cl
  void **v20; // rax
  __int16 v21; // dx
  int v22; // eax
  __int64 v23; // rax
  __int16 v24; // bx
  unsigned int v25; // esi
  __int16 v26; // ax
  unsigned __int16 *v27; // rdi
  _QWORD *v28; // rcx
  unsigned __int16 v29; // bx
  __int64 v30; // rcx
  HLOCAL v31; // rax
  __int64 v32; // rax
  __int64 v33; // rbp
  __int64 v34; // rcx
  __int64 v35; // rcx
  __int64 v36; // rcx
  __int64 v37; // rax
  __int64 v38; // rcx
  __int64 v39; // rax
  __int64 v40; // rcx
  size_t v41; // rbx
  const void *v42; // r15
  int v43; // r8d
  int v44; // ebp
  CCipherMill *v45; // rcx
  __int64 v46; // r8
  unsigned __int16 v47; // dx
  __int64 v48; // rbx
  unsigned __int8 *v49; // rbp
  unsigned __int16 v50; // r12
  unsigned __int8 *v51; // rcx
  unsigned __int64 v52; // r13
  __int64 v53; // rax
  unsigned __int8 *v54; // rcx
  __int64 v55; // rax
  unsigned __int8 *v56; // rcx
  unsigned int v57; // esi
  unsigned __int64 v58; // rax
  unsigned __int8 *v59; // rdi
  SIZE_T v60; // rsi
  unsigned __int8 *v61; // r15
  __int64 v62; // r12
  unsigned int v63; // eax
  _WORD *v64; // rax
  __int64 v65; // rax
  __int16 v66; // ax
  unsigned int v67; // ecx
  _BYTE *v68; // rdi
  unsigned int v69; // edi
  CCipherMill *v70; // rcx
  __int64 v71; // rdx
  CCipherMill *v72; // rcx
  __int64 v73; // rdx
  __int64 v74; // rcx
  __int64 v75; // r10
  unsigned __int16 v76; // r8
  unsigned __int16 v77; // r9
  unsigned __int16 v78; // cx
  CSsl3TlsServerContext *v79; // rcx
  __int64 v80; // rbx
  __int64 v81; // rcx
  __int64 v82; // rcx
  unsigned __int16 v83; // dx
  int v84; // r9d
  __int64 v85; // rax
  CCipherMill *v86; // rbp
  unsigned __int16 v87; // [rsp+30h] [rbp-98h]
  unsigned int v88; // [rsp+34h] [rbp-94h]
  char *v89; // [rsp+38h] [rbp-90h]
  __int64 v90; // [rsp+40h] [rbp-88h]
  unsigned __int64 v91; // [rsp+48h] [rbp-80h]
  unsigned __int8 *v93; // [rsp+58h] [rbp-70h]
  __int16 v94; // [rsp+60h] [rbp-68h] BYREF
  __int128 v95[2]; // [rsp+62h] [rbp-66h] BYREF
  unsigned __int16 v96; // [rsp+82h] [rbp-46h]

  v4 = 0i64;
  v89 = 0i64;
  v6 = a1;
  if ( a2 != 65281 )
  {
    if ( a2 > 65281 )
    {
LABEL_220:
      CSchannelTelemetryContext::LogUnknownTlsExtension(
        *(CSchannelTelemetryContext **)(*(_QWORD *)(a1 + 8) + 120i64),
        a2);
    }
    else
    {
      v7 = &_ImageBase;
      switch ( a2 )
      {
        case 0:
          v80 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 80i64);
          if ( !(unsigned int)CTlsExtServer::ParseServerNameExtension((CSsl3TlsServerContext **)a1, a3, a4)
            && (*(_DWORD *)(v80 + 156) & 0x100) != 0 )
          {
            *(_QWORD *)(*(_QWORD *)(v6 + 8) + 136i64) |= 0x200000ui64;
          }
          CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 120i64), 1, 0);
          return 0i64;
        case 5:
          if ( a4 && *a3 == 1 )
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 8) + 136i64) |= 0x20000ui64;
            CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 120i64), 1, 5);
          }
          else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                 && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 56i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
          }
          return 0i64;
        case 6:
          v67 = *a3;
          v68 = a3 + 1;
          if ( v67 != a4 - 1 )
            return 2148074278i64;
          if ( !v67 )
            goto LABEL_115;
          while ( *v68 != 64 )
          {
            LODWORD(v4) = (_DWORD)v4 + 1;
            ++v68;
            if ( (unsigned int)v4 >= v67 )
              goto LABEL_115;
          }
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 54i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
          }
          *(_BYTE *)(*(_QWORD *)(v6 + 8) + 922i64) = 1;
LABEL_115:
          CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 120i64), 1, 6);
          return 0i64;
        case 10:
          if ( a4 < 2u )
            return (unsigned int)-2146893018;
          v24 = *a3;
          v25 = a4 - 2;
          v26 = a3[1];
          v27 = (unsigned __int16 *)(a3 + 2);
          v28 = *(_QWORD **)(a1 + 8);
          v29 = v26 | (v24 << 8);
          if ( v28[114] )
          {
            (*(void (__fastcall **)(_QWORD *))(*v28 + 16i64))(v28);
            v28 = *(_QWORD **)(v6 + 8);
          }
          v30 = *(_QWORD *)(v28[16] + 24i64);
          if ( v30 )
          {
            LOBYTE(v7) = 1;
            v31 = (HLOCAL)(*(__int64 (__fastcall **)(__int64, _QWORD, __int16 *))(*(_QWORD *)v30 + 48i64))(v30, v29, v7);
          }
          else if ( LsaTable )
          {
            v31 = (HLOCAL)(*(__int64 (__fastcall **)(_QWORD))(LsaTable + 40))(v29);
          }
          else
          {
            v31 = LocalAlloc(0x40u, v29);
          }
          *(_QWORD *)(*(_QWORD *)(v6 + 8) + 912i64) = v31;
          v32 = *(_QWORD *)(v6 + 8);
          if ( !*(_QWORD *)(v32 + 912) )
            return 14;
          if ( v29 < 2u || v25 != v29 || (v29 & 1) != 0 )
            return (unsigned int)-2146893018;
          if ( v25 > 1 )
          {
            v33 = ((v25 - 2) >> 1) + 1;
            do
            {
              *(_WORD *)(2i64 * (unsigned int)v4 + *(_QWORD *)(*(_QWORD *)(v6 + 8) + 912i64)) = _byteswap_ushort(*v27);
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
              {
                WPP_SF_D(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  27i64,
                  &WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
                  *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 912i64) + 2i64 * (unsigned int)v4));
              }
              LODWORD(v4) = (_DWORD)v4 + 1;
              ++v27;
              --v33;
            }
            while ( v33 );
            v32 = *(_QWORD *)(v6 + 8);
          }
          *(_WORD *)(v32 + 920) = v29 >> 1;
          v34 = *(_QWORD *)(*(_QWORD *)(v6 + 8) + 120i64);
          if ( v34 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
            *(_DWORD *)(v34 + 72) |= 0x80u;
          return 0i64;
        case 11:
          v35 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 120i64);
          if ( v35 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
            *(_DWORD *)(v35 + 72) |= 0x100u;
          return 0i64;
        case 13:
          v10 = *(_QWORD *)(a1 + 8);
          if ( (*(_DWORD *)(v10 + 64) & 0x41400) == 0 )
            goto LABEL_32;
          v94 = 0;
          memset(v95, 0, sizeof(v95));
          if ( *(_BYTE *)(v10 + 925) )
            return (unsigned int)-2146893018;
          v11 = a4;
          if ( !a3 )
            return (unsigned int)-2146893018;
          if ( a4 < 2u )
            return (unsigned int)-2146893018;
          v12 = a3[1];
          LOWORD(v13) = 0;
          v14 = *a3;
          v15 = a3 + 2;
          v16 = v12 | (v14 << 8);
          v94 = 0;
          v96 = 0;
          v17 = v16 >> 1;
          if ( v16 > v11 - 2 || (v16 & 1) != 0 || v17 - 1 > 0x4F )
            return (unsigned int)-2146893018;
          if ( !v17 )
            return (unsigned int)-2146893007;
          v18 = v17;
          do
          {
            v19 = 0;
            v20 = (void **)&unk_18007C390;
            v21 = __ROR2__(*v15, 8);
            while ( v21 != *(_WORD *)v20 )
            {
              v20 += 9;
              ++v19;
              if ( v20 >= &CSsl3TlsServerContext::`vftable' )
                goto LABEL_28;
            }
            if ( v19 < 0xCu )
            {
              v22 = (unsigned __int16)v13;
              if ( !_bittest(&v22, v19) && (unsigned __int16)v4 < 0x10u )
              {
                *((_WORD *)v95 + (unsigned __int16)v4) = __ROR2__(*((_WORD *)&unk_18007C390 + 36 * v19), 8);
                LOWORD(v4) = v94 + 1;
                v13 = v96 | (1 << v19);
                ++v94;
                v96 |= 1 << v19;
              }
            }
LABEL_28:
            ++v15;
            --v18;
          }
          while ( v18 );
          if ( !(_WORD)v4 )
            return (unsigned int)-2146893007;
          if ( v11 != v16 + 2 )
            return (unsigned int)-2146893018;
          CTlsSignatureSuiteList::SetSignatureSuiteList(
            (CTlsSignatureSuiteList *)(v10 + 510),
            (const struct CTlsSignatureSuiteList *)(v10 + 474));
          CTlsSignatureSuiteList::Restrict(
            (CTlsSignatureSuiteList *)(*(_QWORD *)(v6 + 8) + 510i64),
            (const struct CTlsSignatureSuiteList *)&v94,
            *(_DWORD *)(*(_QWORD *)(v6 + 8) + 64i64));
          *(_BYTE *)(*(_QWORD *)(v6 + 8) + 925i64) = 1;
          v10 = *(_QWORD *)(v6 + 8);
LABEL_32:
          v23 = *(_QWORD *)(v10 + 120);
          if ( v23 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
            *(_DWORD *)(v23 + 72) |= 0x200u;
          return 0i64;
        case 14:
          v75 = *(_QWORD *)(a1 + 32);
          if ( !*(_BYTE *)(v75 + 233) || !*(_QWORD *)(v75 + 800) )
            return 0i64;
          if ( a4 < 5u )
          {
            v70 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v71 = 59i64;
              goto LABEL_194;
            }
            return 2148074278i64;
          }
          v76 = _byteswap_ushort(*(_WORD *)a3);
          v77 = a4 - 2;
          if ( v77 < (unsigned __int64)v76 + 1 )
          {
            v70 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v71 = 60i64;
              goto LABEL_194;
            }
            return 2148074278i64;
          }
          v78 = a3[v76 + 2];
          if ( !(_BYTE)v78 )
            goto LABEL_169;
          if ( (unsigned __int16)(v77 - v76 - 1) < v78 )
          {
            v70 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v71 = 61i64;
              goto LABEL_194;
            }
            return 2148074278i64;
          }
          v4 = &a3[v76 + 3];
LABEL_169:
          result = CSsl3TlsServerContext::SelectSrtpParameters(
                     (CSsl3TlsServerContext *)v75,
                     (unsigned __int16 *const)a3 + 1,
                     v76,
                     v4,
                     v78);
          if ( (_DWORD)result )
            return result;
          CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 120i64), 1, 14);
          return 0i64;
        case 16:
          v46 = *(_QWORD *)(a1 + 8);
          if ( !*(_QWORD *)(v46 + 784) )
            return 0i64;
          if ( a4 < 4u )
          {
            v70 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v71 = 57i64;
              goto LABEL_194;
            }
            return 2148074278i64;
          }
          v47 = _byteswap_ushort(*(_WORD *)a3);
          if ( v47 != a4 - 2 )
          {
            v70 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v71 = 58i64;
              goto LABEL_194;
            }
            return 2148074278i64;
          }
          v48 = *(_QWORD *)(a1 + 32);
          v49 = a3 + 2;
          v90 = v48;
          if ( !*(_QWORD *)(v48 + 968) )
          {
            v87 = 0;
            v50 = 0;
            if ( a3 != (unsigned __int8 *)-2i64 )
            {
              if ( (unsigned __int16)(v47 - 2) > 0xFFFBu )
              {
                v72 = WPP_GLOBAL_Control;
                if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
                  || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
                {
                  return (unsigned int)-2146893018;
                }
                v73 = 74i64;
LABEL_147:
                WPP_SF_(*((_QWORD *)v72 + 2), v73, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
                return (unsigned int)-2146893018;
              }
              v51 = a3 + 2;
              v52 = (unsigned __int64)&v49[v47];
              if ( (unsigned __int64)v49 < v52 )
              {
                while ( 1 )
                {
                  v53 = *v51;
                  if ( !(_BYTE)v53 )
                    break;
                  v54 = &v51[v53];
                  if ( (unsigned __int64)v54 >= v52 )
                    break;
                  v51 = v54 + 1;
                  if ( (unsigned __int64)v51 >= v52 )
                    goto LABEL_81;
                }
                v72 = WPP_GLOBAL_Control;
                if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
                  || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
                {
                  return (unsigned int)-2146893018;
                }
                v73 = 76i64;
                goto LABEL_147;
              }
LABEL_81:
              v55 = *(_QWORD *)(v48 + 784);
              if ( v55 )
              {
                v56 = (unsigned __int8 *)(v55 + 6);
                v88 = 0;
                v57 = 0;
                v58 = v55 + 6 + *(unsigned __int16 *)(v55 + 4);
                v93 = v56;
                v91 = v58;
                while ( 1 )
                {
                  v59 = v56;
                  if ( (unsigned __int64)v56 < v58 )
                  {
                    do
                    {
                      v60 = *v59;
                      v61 = v49;
                      if ( (unsigned __int64)v49 < v52 )
                      {
                        while ( 1 )
                        {
                          v62 = *v61;
                          if ( (_BYTE)v60 == (_BYTE)v62 && RtlCompareMemory(v59 + 1, v61 + 1, v60) == v60 )
                            break;
                          v61 += v62 + 1;
                          if ( (unsigned __int64)v61 >= v52 )
                            goto LABEL_87;
                        }
                        v66 = v60 + 1;
                        if ( *(_QWORD *)(v90 + 968) )
                        {
                          memcpy_0(v89, v59, (unsigned __int16)(v60 + 1));
                          v89 += (unsigned __int16)(v60 + 1);
LABEL_87:
                          v50 = v87;
                          goto LABEL_88;
                        }
                        v50 = v66 + v87;
                        v87 += v66;
                      }
LABEL_88:
                      v59 += v60 + 1;
                    }
                    while ( (unsigned __int64)v59 < v91 );
                    v6 = a1;
                    v48 = v90;
                    v57 = v88;
                  }
                  if ( !v50 )
                    break;
                  if ( !*(_QWORD *)(v48 + 968) )
                  {
                    v63 = v50 + 6;
                    if ( LsaTable )
                      v64 = (_WORD *)(*(__int64 (__fastcall **)(_QWORD))(LsaTable + 40))(v63);
                    else
                      v64 = LocalAlloc(0x40u, v63);
                    *(_QWORD *)(v48 + 968) = v64;
                    if ( !v64 )
                      return 14;
                    v64[2] = v50;
                    v89 = (char *)(*(_QWORD *)(v48 + 968) + 6i64);
                  }
                  v88 = ++v57;
                  if ( v57 >= 2 )
                  {
                    v46 = *(_QWORD *)(v6 + 8);
                    goto LABEL_98;
                  }
                  v58 = v91;
                  v56 = v93;
                }
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                {
                  WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 65i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
                }
                v69 = -2146892953;
                CSslContext::SetErrorAndFatalAlert(v48, 1208, -2146892953, 0x78u);
                *(_DWORD *)(v48 + 68) = 96;
                *(_WORD *)(v48 + 96) = 30722;
                return v69;
              }
            }
            return 87;
          }
LABEL_98:
          v65 = *(_QWORD *)(v46 + 120);
          if ( v65 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
            *(_DWORD *)(v65 + 72) |= 0x800u;
          break;
        case 23:
          if ( CSslGlobals::m_fDisableServerExtendedMS || (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 64i64) & 0x51540) == 0 )
          {
            v74 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 120i64);
            if ( v74 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
              *(_WORD *)(v74 + 66) |= 0x10u;
          }
          else
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 8) + 136i64) |= 0x8000000ui64;
            v8 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 120i64);
            if ( v8 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
              *(_DWORD *)(v8 + 72) |= 0x1000u;
          }
          return 0i64;
        case 24:
          v79 = *(CSsl3TlsServerContext **)(a1 + 32);
          if ( !*((_QWORD *)v79 + 102) )
            return 0i64;
          if ( a4 < 4u )
          {
            v70 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v71 = 62i64;
              goto LABEL_194;
            }
            return 2148074278i64;
          }
          if ( (unsigned __int16)(a4 - 3) < a3[2] )
          {
            v70 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v71 = 63i64;
              goto LABEL_194;
            }
            return 2148074278i64;
          }
          result = CSsl3TlsServerContext::SelectTBParameters(v79, *a3, a3[1], a3 + 3, a3[2]);
          if ( (_DWORD)result )
            return result;
          CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 120i64), 1, 24);
          return 0i64;
        case 35:
          v36 = *(_QWORD *)(a1 + 8);
          v37 = *(_QWORD *)(v36 + 136);
          if ( (v37 & 0x800) != 0 )
          {
            if ( a4 )
            {
              *(_DWORD *)(v36 + 984) = a4;
              *(_QWORD *)(v36 + 976) = a3;
            }
            else
            {
              *(_QWORD *)(v36 + 136) = v37 | 0x400000;
            }
          }
          v38 = *(_QWORD *)(*(_QWORD *)(v6 + 8) + 120i64);
          if ( v38 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
            *(_DWORD *)(v38 + 72) |= 0x2000u;
          return 0i64;
        default:
          goto LABEL_220;
      }
    }
    return 0i64;
  }
  v39 = *(_QWORD *)(a1 + 8);
  if ( !*(_DWORD *)(v39 + 416) || *(_BYTE *)(v39 + 553) )
  {
    *(_BYTE *)(v39 + 553) = 1;
    v40 = *(_QWORD *)(a1 + 8);
    v41 = *(unsigned int *)(v40 + 416);
    v42 = (const void *)(v40 + 377);
    if ( a4 )
    {
      v43 = *a3;
      v44 = a4;
      if ( v43 + 1 == a4 )
      {
        if ( a4 == 1 )
        {
          v45 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 67i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
            v45 = WPP_GLOBAL_Control;
          }
          if ( (_DWORD)v41 )
          {
            if ( v45 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v45 + 28) & 1) == 0 )
              goto LABEL_203;
            v82 = *((_QWORD *)v45 + 2);
            v83 = 68;
            v84 = v44;
LABEL_202:
            WPP_SF_DD(v82, v83, (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids, v84, v41);
LABEL_203:
            v40 = *(_QWORD *)(v6 + 8);
LABEL_204:
            CSslContext::SetErrorAndFatalAlert(v40, 1207, -2146892986, 0x28u);
            v85 = *(_QWORD *)(v6 + 8);
            *(_DWORD *)(v85 + 68) = 96;
            *(_WORD *)(v85 + 96) = 10242;
            return 2148074310i64;
          }
        }
        else
        {
          if ( v43 != (_DWORD)v41 )
          {
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
            {
              goto LABEL_204;
            }
            v82 = *((_QWORD *)WPP_GLOBAL_Control + 2);
            v83 = 69;
            v84 = v43;
            goto LABEL_202;
          }
          v86 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
          {
            if ( (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 70i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
              v86 = WPP_GLOBAL_Control;
            }
            if ( v86 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)v86 + 7) & 0x800) != 0 )
            {
              WPP_SF_(*((_QWORD *)v86 + 2), 71i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
              v86 = WPP_GLOBAL_Control;
            }
          }
          if ( memcmp_0(a3 + 1, v42, v41) )
          {
            if ( v86 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v86 + 28) & 1) != 0 )
              WPP_SF_(*((_QWORD *)v86 + 2), 72i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
            goto LABEL_203;
          }
          CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 120i64), 1, 65281);
        }
        return 0i64;
      }
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
      {
        WPP_SF_DD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x42u,
          (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
          v43,
          a4);
      }
    }
    else
    {
      v70 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        v71 = 65i64;
LABEL_194:
        WPP_SF_(*((_QWORD *)v70 + 2), v71, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
      }
    }
    return 2148074278i64;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 64i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
    v39 = *(_QWORD *)(v6 + 8);
  }
  CSslContext::SetErrorAndFatalAlert(v39, 1207, -2146892986, 0x28u);
  v81 = *(_QWORD *)(v6 + 8);
  result = 2148074310i64;
  *(_DWORD *)(v81 + 68) = 96;
  *(_WORD *)(v81 + 96) = 10242;
  return result;
}
// 180031905: variable 'v7' is possibly undefined
// 180000000: using guessed type __int16 _ImageBase;
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';
// 180092620: using guessed type __int64 LsaTable;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 1800927B4: using guessed type int CSslGlobals::m_fDisableServerExtendedMS;

//----- (000000018001E850) ----------------------------------------------------
__int64 __fastcall CCipherMill::FindAcceptableKeyXCurve(
        CCipherMill *this,
        struct CSsl3TlsServerContext *a2,
        struct CCipherSuiteInfo *a3,
        char a4,
        char a5,
        PCUNICODE_STRING String2,
        unsigned int *a7,
        unsigned __int8 *a8)
{
  struct CSsl3TlsServerContext *v9; // r14
  unsigned int v10; // edi
  bool v11; // zf
  unsigned int v12; // esi
  unsigned int v13; // r13d
  char v14; // al
  __int64 v15; // rdx
  unsigned __int64 v16; // rbp
  __int64 v17; // rax
  __int64 v18; // r15
  unsigned __int64 v19; // r14
  unsigned int v20; // r12d
  unsigned __int64 v21; // rsi
  unsigned __int64 v22; // rbx
  const UNICODE_STRING *v23; // rax
  const wchar_t *v24; // r9
  unsigned int v25; // ebx
  unsigned int v26; // edx
  __int64 v27; // r8
  char v28; // r12
  unsigned int v29; // ecx
  bool v30; // cc
  CCipherMill *v31; // r10
  int v32; // eax
  unsigned int v33; // edi
  unsigned __int64 v34; // rdi
  unsigned int v35; // eax
  unsigned int v36; // eax
  unsigned int v37; // ecx
  __int64 v39; // rax
  unsigned __int16 v40; // dx
  __int64 v41; // [rsp+20h] [rbp-88h]
  __int64 v42; // [rsp+28h] [rbp-80h]
  char v43; // [rsp+40h] [rbp-68h]
  unsigned int v44; // [rsp+44h] [rbp-64h]
  unsigned int v45; // [rsp+48h] [rbp-60h]
  __int64 v46; // [rsp+50h] [rbp-58h] BYREF
  unsigned int v47; // [rsp+58h] [rbp-50h]
  __int64 v48; // [rsp+60h] [rbp-48h]
  char v49; // [rsp+B0h] [rbp+8h]

  v9 = a2;
  if ( !a2 || !a3 || !a7 || !a8 )
    return 2148074244i64;
  v10 = *((_DWORD *)a3 + 5);
  v11 = (*((_DWORD *)a2 + 16) & 0x1000) == 0;
  v12 = 0;
  v13 = 0;
  *a8 = 0;
  *a7 = 0;
  v44 = 0;
  LODWORD(v46) = 0;
  v45 = 0;
  v47 = v10;
  v14 = !v11;
  v43 = v14;
  if ( !a4 || v14 )
  {
    v49 = 0;
  }
  else
  {
    v39 = *(_QWORD *)a2;
    v49 = 1;
    v46 = 0i64;
    (*(void (__fastcall **)(struct CSsl3TlsServerContext *, __int64 *))(v39 + 232))(a2, &v46);
    if ( !v46 )
      return (unsigned int)-2146893052;
    LODWORD(v46) = *(_DWORD *)(v46 + 184);
  }
  v15 = *((_QWORD *)a3 + 106);
  v48 = v15;
  if ( !v15 )
    return (unsigned int)-2146893052;
  v16 = *(_QWORD *)v15;
  if ( *(_QWORD *)v15 >= *(_QWORD *)v15 + 780 * (unsigned __int64)*(unsigned int *)(v15 + 8) )
  {
    v31 = WPP_GLOBAL_Control;
    goto LABEL_132;
  }
  while ( 2 )
  {
    v17 = *((_QWORD *)v9 + 10);
    v18 = *(unsigned int *)(v17 + 196);
    v19 = *(_QWORD *)(v17 + 200);
    if ( !(_DWORD)v18 || !v19 || !v16 )
    {
LABEL_27:
      v9 = a2;
      v25 = *(_DWORD *)(v16 + 772);
      v26 = (*(__int64 (__fastcall **)(struct CSsl3TlsServerContext *, _QWORD))(*(_QWORD *)a2 + 544i64))(a2, v25);
      if ( v26 && v26 != 1168 && v26 != 50 )
        return v26;
      v28 = v49;
      if ( v49 )
      {
        v32 = v46;
        if ( !v26 && v25 == (_DWORD)v46 )
        {
          v31 = WPP_GLOBAL_Control;
          goto LABEL_69;
        }
        v31 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_39;
        LODWORD(v42) = v46;
        LODWORD(v41) = v25;
        WPP_SF_SDD(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x30u, v27, (const wchar_t *)v16, v41, v42);
        goto LABEL_38;
      }
      if ( v26 == 50 )
      {
        v31 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_39;
        v40 = 49;
      }
      else
      {
        v29 = (*(_DWORD *)(v16 + 768) + (*(_DWORD *)(v16 + 768) & 1u)) >> 1;
        if ( v26 != 1168 )
        {
          if ( !v12 )
          {
            v44 = v25;
            v12 = v25;
            v45 = 0;
            v13 = (*(_DWORD *)(v16 + 768) + (*(_DWORD *)(v16 + 768) & 1u)) >> 1;
            if ( v29 == v10 )
            {
LABEL_67:
              v31 = WPP_GLOBAL_Control;
              break;
            }
            goto LABEL_34;
          }
LABEL_32:
          if ( v13 == v10 )
            goto LABEL_38;
          if ( v29 == v10 )
            goto LABEL_75;
LABEL_34:
          v30 = v13 <= v10;
          if ( v13 < v10 )
          {
            if ( v13 < v29 )
            {
LABEL_75:
              v13 = (*(_DWORD *)(v16 + 768) + (*(_DWORD *)(v16 + 768) & 1u)) >> 1;
              if ( v12 )
              {
                v25 = *(_DWORD *)(v16 + 772);
                v44 = v25;
                if ( v29 != v10 )
                {
                  v31 = WPP_GLOBAL_Control;
                  goto LABEL_40;
                }
                goto LABEL_67;
              }
              if ( v45 )
                v45 = *(_DWORD *)(v16 + 772);
LABEL_38:
              v31 = WPP_GLOBAL_Control;
              goto LABEL_39;
            }
            v30 = v13 <= v10;
          }
          if ( v30 || v13 <= v29 || v29 <= v10 )
            goto LABEL_38;
          goto LABEL_75;
        }
        if ( !v12 )
        {
          if ( v45 )
            goto LABEL_32;
          if ( !*((_DWORD *)a2 + 17) && v43 )
          {
            v45 = v25;
            v13 = (*(_DWORD *)(v16 + 768) + (*(_DWORD *)(v16 + 768) & 1u)) >> 1;
            goto LABEL_32;
          }
        }
        v31 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_39;
        v40 = 50;
      }
      WPP_SF_S(
        *((_QWORD *)v31 + 2),
        v40,
        (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
        (const wchar_t *)v16);
      v31 = WPP_GLOBAL_Control;
      goto LABEL_39;
    }
    v20 = *(_DWORD *)(v16 + 768);
    v21 = v19 + 40 * v18;
    v22 = *(_QWORD *)(v17 + 200);
    if ( v19 >= v21 )
    {
LABEL_20:
      if ( !IsCngAlgorithmBlacklisted(v19, v18, 0, (const wchar_t *)v16, 0i64, 0, String2, a5) )
      {
        switch ( *(_DWORD *)(v16 + 772) )
        {
          case 0x17:
            v24 = L"ECDH_P256";
            break;
          case 0x18:
            v24 = L"ECDH_P384";
            break;
          case 0x19:
            v24 = L"ECDH_P521";
            break;
          default:
            goto LABEL_26;
        }
        if ( !IsCngAlgorithmBlacklisted(v19, v18, 0, v24, 0i64, 0, String2, a5) )
        {
LABEL_26:
          v12 = v44;
          goto LABEL_27;
        }
      }
LABEL_99:
      v31 = WPP_GLOBAL_Control;
      goto LABEL_100;
    }
    while ( 1 )
    {
      if ( *(_DWORD *)(v22 + 20) )
      {
        if ( !*(_DWORD *)v22 )
          goto LABEL_51;
        v23 = String2;
        if ( String2 )
          break;
      }
LABEL_18:
      v22 += 40i64;
      if ( v22 >= v21 )
      {
        v10 = v47;
        goto LABEL_20;
      }
    }
    v33 = 0;
    while ( RtlCompareUnicodeString((PCUNICODE_STRING)(*(_QWORD *)(v22 + 8) + 16i64 * v33), v23, 1u) )
    {
      v23 = String2;
      if ( ++v33 >= *(_DWORD *)v22 )
        goto LABEL_18;
    }
LABEL_51:
    if ( a5 && (*(_BYTE *)(v22 + 32) & 1) != 0 )
      goto LABEL_18;
    v34 = *(_QWORD *)(v22 + 24);
    if ( v34 >= v34 + 48i64 * *(unsigned int *)(v22 + 20) )
      goto LABEL_18;
    while ( 1 )
    {
      if ( *(_DWORD *)v34 || *(_WORD *)(v34 + 8) != 8 || wcsncmp(*(const wchar_t **)(v34 + 16), L"ECDH", 4ui64) )
        goto LABEL_55;
      if ( !*(_DWORD *)(v34 + 24) && !*(_DWORD *)(v34 + 40) && !*(_DWORD *)(v34 + 44) )
        break;
      if ( !v20 )
        goto LABEL_55;
      v35 = *(_DWORD *)(v34 + 40);
      if ( !v35 )
      {
        if ( !*(_DWORD *)(v34 + 44) )
          goto LABEL_55;
        v36 = *(_DWORD *)(v34 + 44);
LABEL_94:
        if ( v36 < v20 )
        {
LABEL_95:
          v31 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control )
            goto LABEL_103;
          if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            LODWORD(v42) = 0;
            LODWORD(v41) = v20;
            WPP_SF_Sdd(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xEu,
              (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
              L"ECDH",
              v41,
              v42);
            goto LABEL_99;
          }
          goto LABEL_100;
        }
        goto LABEL_55;
      }
      if ( v35 > v20 )
        goto LABEL_95;
      v36 = *(_DWORD *)(v34 + 44);
      if ( v36 )
        goto LABEL_94;
LABEL_55:
      v34 += 48i64;
      if ( v34 >= *(_QWORD *)(v22 + 24) + 48 * (unsigned __int64)*(unsigned int *)(v22 + 20) )
        goto LABEL_18;
    }
    v31 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control )
      goto LABEL_103;
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      LODWORD(v41) = 0;
      WPP_SF_Sd(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xCu,
        (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
        L"ECDH",
        v41);
      goto LABEL_99;
    }
LABEL_100:
    if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v31 + 28) & 4) != 0 )
    {
      WPP_SF_S(
        *((_QWORD *)v31 + 2),
        0x2Fu,
        (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
        (const wchar_t *)v16);
      v31 = WPP_GLOBAL_Control;
    }
LABEL_103:
    v9 = a2;
    v28 = v49;
LABEL_39:
    v25 = v44;
LABEL_40:
    v16 += 780i64;
    if ( v16 < *(_QWORD *)v48 + 780 * (unsigned __int64)*(unsigned int *)(v48 + 8) )
    {
      v10 = v47;
      v12 = v44;
      continue;
    }
    break;
  }
  v32 = v46;
LABEL_69:
  v37 = v45;
  if ( !v25 && !v45 )
  {
LABEL_132:
    if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v31 + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)v31 + 2), 51i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
    return (unsigned int)-2146893007;
  }
  if ( v28 && v25 != v32 )
  {
    if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v31 + 28) & 4) != 0 )
    {
      LODWORD(v41) = v32;
      WPP_SF_DD(*((_QWORD *)v31 + 2), 0x34u, (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids, v25, v41);
    }
    return (unsigned int)-2146893007;
  }
  if ( v25 || !v45 )
  {
    v37 = v25;
    *a8 = 0;
  }
  else
  {
    *a8 = 1;
  }
  v26 = 0;
  *a7 = v37;
  return v26;
}
// 18003211B: variable 'v27' is possibly undefined
// 18003211B: variable 'v41' is possibly undefined
// 18003211B: variable 'v42' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018001ED90) ----------------------------------------------------
__int64 __fastcall SpAcceptLsaModeContext(
        struct CCredentialGroup *a1,
        __int64 a2,
        struct _SecBufferDesc *a3,
        unsigned int a4,
        int a5,
        __int64 *a6,
        __int64 a7,
        _DWORD *a8,
        union _LARGE_INTEGER *a9,
        unsigned __int8 *a10,
        struct _SecBuffer *a11)
{
  unsigned int *v11; // r11
  __int64 v12; // rdi
  __int64 v13; // r12
  __int64 v15; // rax
  unsigned __int64 v16; // r14
  int v18; // r10d
  struct _SecBuffer *v19; // r15
  __int64 v20; // rsi
  unsigned int v21; // ecx
  unsigned int v22; // ebx
  unsigned int v23; // r8d
  __int64 v24; // r9
  _DWORD *v25; // rdx
  int v26; // eax
  _DWORD *v27; // r9
  _DWORD *v28; // rdx
  unsigned __int64 v29; // rcx
  void *pvBuffer; // rax
  __int64 v31; // r8
  __int64 v32; // rsi
  struct CCredentialGroup *v33; // rax
  __int64 v34; // rcx
  struct CCredentialGroup *v35; // rdx
  unsigned int v36; // eax
  __int64 (__fastcall *v37)(__int64, __int64, _QWORD, _QWORD); // rdi
  unsigned __int8 v38; // al
  int v39; // ebx
  __int64 v40; // rax
  __int64 v42; // rbx
  bool v43; // zf
  bool v44; // al
  int v45; // eax
  int v46; // eax
  struct CSslParentContext *v47; // r14
  __int64 v48; // rcx
  int v49; // edi
  int v50; // r13d
  int v51; // ebx
  __int64 v52; // r12
  char v53; // bl
  int v54; // eax
  __int64 v55; // rax
  int v56; // eax
  int v57; // eax
  int v58; // eax
  __int64 v59; // rax
  __int64 *v60; // r9
  __int64 v61; // r9
  unsigned __int64 *v62; // rax
  __int64 v63; // rcx
  unsigned int v64; // ecx
  unsigned int v65; // eax
  void *v66; // rax
  __int64 v67; // rax
  void *v68; // rax
  __int64 v69; // rcx
  __int64 v70; // rax
  __int64 v71; // rdi
  void (__fastcall *v72)(__int64, __int64); // rbx
  __int64 v73; // rax
  void *v74; // rax
  int v75; // eax
  __int64 v76; // rdx
  __int64 v77; // rcx
  struct CSslParentContext *v78; // [rsp+70h] [rbp-90h] BYREF
  __int64 v79; // [rsp+78h] [rbp-88h]
  __int64 v80; // [rsp+80h] [rbp-80h] BYREF
  __int128 v81; // [rsp+90h] [rbp-70h] BYREF
  __int64 v82; // [rsp+A0h] [rbp-60h]
  __int64 v83; // [rsp+A8h] [rbp-58h]
  unsigned __int64 v84; // [rsp+B0h] [rbp-50h]
  struct _SecBuffer *v85; // [rsp+B8h] [rbp-48h] BYREF
  __int64 v86[2]; // [rsp+C0h] [rbp-40h] BYREF
  __int128 v87; // [rsp+D0h] [rbp-30h] BYREF
  struct _SecBuffer *v88; // [rsp+E0h] [rbp-20h] BYREF
  struct _SecBuffer *v89; // [rsp+E8h] [rbp-18h] BYREF
  struct _SecBuffer *v90; // [rsp+F0h] [rbp-10h] BYREF
  struct _SecBuffer *v91; // [rsp+F8h] [rbp-8h] BYREF
  struct _SecBuffer *v92; // [rsp+100h] [rbp+0h] BYREF
  struct _SecBuffer *v93; // [rsp+108h] [rbp+8h] BYREF
  struct _SecBuffer *v94; // [rsp+110h] [rbp+10h] BYREF
  struct _SecBuffer *v95; // [rsp+118h] [rbp+18h] BYREF
  struct _SecBuffer *v96; // [rsp+120h] [rbp+20h] BYREF
  struct _SecBuffer *v97; // [rsp+128h] [rbp+28h] BYREF
  unsigned __int64 *v98; // [rsp+130h] [rbp+30h]
  unsigned int *v99; // [rsp+190h] [rbp+90h]
  __int64 v100; // [rsp+198h] [rbp+98h]
  int v102; // [rsp+1A8h] [rbp+A8h]

  v100 = a2;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 28i64;
  v15 = a2;
  v16 = a4;
  LODWORD(a2) = 0;
  v102 = 0;
  v78 = 0i64;
  v85 = 0i64;
  v97 = 0i64;
  v89 = 0i64;
  v90 = 0i64;
  v92 = 0i64;
  v91 = 0i64;
  v93 = 0i64;
  v95 = 0i64;
  v94 = 0i64;
  v96 = 0i64;
  v88 = 0i64;
  v87 = 0i64;
  v79 = 0i64;
  v81 = 0i64;
  v98 = 0i64;
  v84 = a4;
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
  {
    McTemplateU0pp_EtwEventWriteTransfer((__int64)a1, 0i64, a1, v15);
    v15 = v100;
    v11 = 0i64;
    LODWORD(a2) = 0;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 40i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
      v15 = v100;
      v11 = 0i64;
      LODWORD(a2) = 0;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 41i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
        v15 = v100;
        v11 = 0i64;
        LODWORD(a2) = 0;
      }
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_q(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x2Au,
            (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
            a1);
          v15 = v100;
          v11 = 0i64;
          LODWORD(a2) = 0;
        }
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_q(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x2Bu,
              (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
              v15);
            v11 = 0i64;
            LODWORD(a2) = 0;
          }
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 44i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids, a4);
            v11 = 0i64;
            LODWORD(a2) = 0;
          }
        }
      }
    }
  }
  if ( !a1 )
  {
    v22 = -2146893055;
    goto LABEL_157;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        45i64,
        &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
        *((unsigned int *)a1 + 53));
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_S(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x2Eu,
        (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
        (const wchar_t *)a1 + 108);
  }
  v18 = 0;
  v19 = 0i64;
  v99 = 0i64;
  v11 = 0i64;
  v80 = 0i64;
  v82 = 0i64;
  v20 = 0i64;
  v21 = 0;
  v22 = 14;
  v23 = *(_DWORD *)(a7 + 4);
  if ( !v23 )
  {
LABEL_34:
    v29 = v16 & 0x100;
    goto LABEL_35;
  }
  v24 = *(_QWORD *)(a7 + 8);
  v25 = (_DWORD *)(v24 + 4);
  do
  {
    v26 = *v25 & 0xFFFFFFF;
    if ( v26 )
    {
      if ( v26 == 2 )
        goto LABEL_111;
      v56 = v26 - 17;
      if ( v56 )
      {
        v57 = v56 - 6;
        if ( v57 )
        {
          v58 = v57 - 3;
          if ( v58 )
          {
            if ( v58 == 1 )
              v20 = v24 + 16i64 * v21;
          }
          else
          {
            v82 = v24 + 16i64 * v21;
          }
        }
        else
        {
          v80 = v24 + 16i64 * v21;
        }
      }
      else
      {
        v11 = (unsigned int *)(v24 + 16i64 * v21);
      }
    }
    else if ( !v19 && (v16 & 0x100) != 0 )
    {
LABEL_111:
      v19 = (struct _SecBuffer *)(v24 + 16i64 * v21);
    }
    ++v21;
    v25 += 4;
  }
  while ( v21 < v23 );
  v27 = (_DWORD *)v80;
  v99 = v11;
  if ( v80 )
  {
    if ( (v16 & 0x100) != 0 )
    {
      *(_QWORD *)(v80 + 8) = 0i64;
      *v27 = 0;
    }
    else if ( !*(_QWORD *)(v80 + 8) )
    {
      v18 = 14;
    }
  }
  v28 = (_DWORD *)v82;
  if ( v82 )
  {
    if ( (v16 & 0x100) != 0 )
    {
      *(_QWORD *)(v82 + 8) = 0i64;
      *v28 = 0;
    }
    else if ( !*(_QWORD *)(v82 + 8) )
    {
      v18 = 14;
    }
  }
  if ( v20 )
  {
    if ( (v16 & 0x100) != 0 )
    {
      *(_QWORD *)(v20 + 8) = 0i64;
      *(_DWORD *)v20 = 0;
    }
    else if ( *(_QWORD *)(v20 + 8) )
    {
      if ( *(_DWORD *)v20 < 8u )
      {
        *(_DWORD *)v20 = 8;
        v18 = -2146893023;
      }
    }
    else
    {
      v18 = 14;
    }
  }
  if ( !v11 )
    goto LABEL_34;
  v29 = v16 & 0x100;
  if ( (v16 & 0x100) != 0 )
  {
    *((_QWORD *)v11 + 1) = 0i64;
    *v11 = 0;
    goto LABEL_189;
  }
  v59 = *((_QWORD *)v11 + 1);
  if ( !v59 )
  {
    v18 = 14;
LABEL_189:
    v59 = 0i64;
  }
  *((_QWORD *)&v87 + 1) = v59;
  *(_QWORD *)&v87 = *v11;
LABEL_35:
  if ( !v19 )
  {
    v22 = -2146893048;
    goto LABEL_192;
  }
  v19->BufferType = 2;
  if ( !v29 )
  {
    pvBuffer = v19->pvBuffer;
    if ( pvBuffer )
      goto LABEL_38;
LABEL_192:
    LODWORD(a2) = 0;
LABEL_157:
    v13 &= ~0x8000ui64;
    goto LABEL_90;
  }
  v19->pvBuffer = 0i64;
  pvBuffer = 0i64;
  v19->cbBuffer = 0;
LABEL_38:
  *((_QWORD *)&v81 + 1) = pvBuffer;
  v22 = v18;
  *(_QWORD *)&v81 = v19->cbBuffer;
  if ( v18 )
  {
    LODWORD(a2) = 0;
  }
  else
  {
    if ( (v16 & 2) != 0 )
    {
      v12 = 256i64;
      v79 = 256i64;
    }
    if ( CSslGlobals::m_dwEnableSessionTicket == 1 || CSslGlobals::m_dwEnableSessionTicket != 2 && (v16 & 0x40) != 0 )
    {
      v12 |= 0x800ui64;
      v79 = v12;
    }
    if ( (v16 & 0x1000000) != 0 )
    {
      v12 |= 0x10000ui64;
      v13 = 16777244i64;
      v79 = v12;
    }
    if ( v29 )
      v13 |= 0x100ui64;
    if ( (v16 & 0x8000) != 0 )
    {
      v13 |= 0x8000ui64;
      v12 |= 0x200ui64;
      v79 = v12;
    }
    if ( (v16 & 0x800) != 0 )
    {
      v13 |= 0x800ui64;
      v12 |= 0x1000ui64;
      v83 = v13;
      v79 = v12;
      if ( (v16 & 0x400) != 0
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 47i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
      }
    }
    else
    {
      v13 |= 0x10000ui64;
      v83 = v13;
    }
    if ( (*((_BYTE *)a1 + 156) & 1) != 0 )
    {
      v12 |= 0x10000ui64;
      v79 = v12;
    }
    v22 = ParseInputBufferDesc(
            a3,
            &v85,
            (struct SPBuffer *)v86,
            &v97,
            &v89,
            &v90,
            &v92,
            &v91,
            &v93,
            &v95,
            &v94,
            &v96,
            &v88);
    if ( v22 )
      goto LABEL_84;
    if ( !v88 )
      goto LABEL_56;
    v60 = (__int64 *)v88->pvBuffer;
    if ( v60 && v88->cbBuffer >= 8 )
    {
      v61 = *v60;
      if ( (v61 & 0xFFFFFFFEFFFFFFFFui64) != 0 )
      {
        v22 = -2146892963;
        goto LABEL_84;
      }
      if ( (v61 & 0x100000000i64) != 0 )
      {
        v13 |= 0x100000000ui64;
        v79 = v12 | 0x100000000i64;
        v83 = v13;
      }
      v16 |= v61;
      v84 = v16;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_i(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x30u, (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
      if ( v20 )
      {
        v62 = *(unsigned __int64 **)(v20 + 8);
        if ( !v62 )
        {
          v62 = (unsigned __int64 *)SPExternalAlloc(8u);
          *(_QWORD *)(v20 + 8) = v62;
          if ( !v62 )
          {
            v11 = v99;
            v22 = -2146893056;
            LODWORD(a2) = 0;
            goto LABEL_85;
          }
          *(_DWORD *)v20 = 8;
        }
        v98 = v62;
      }
LABEL_56:
      v31 = 0i64;
      if ( v85 && (v85->BufferType & 0xFFFFFFF) != 2 )
      {
        v86[1] = 0i64;
        v86[0] = 0i64;
      }
      if ( !v100 )
      {
        v22 = CSslContextManager::InstantiateServerContext(
                (CSslContextManager *)&g_SslContextManager,
                (struct SPBuffer *)v86,
                (struct SPBuffer *)&v81,
                v19,
                v89,
                a1,
                v16,
                &v78);
        if ( v22 )
          goto LABEL_84;
        v32 = *((_QWORD *)v78 + 1);
        v42 = *(_QWORD *)(v32 + 120);
        if ( v42 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
        {
          *(_DWORD *)(v42 + 12) = 1;
          QueryPerformanceCounter((LARGE_INTEGER *)(v42 + 80));
          v43 = *(_DWORD *)(v42 + 12) == 1;
          *(_DWORD *)(v42 + 24) = 0;
          v44 = v43;
          v43 = !CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
          *(_BYTE *)(v42 + 28) = v44;
          *(_QWORD *)(v42 + 144) = v78;
          *(_QWORD *)(v42 + 120) = v16;
          *(_QWORD *)(v42 + 136) = a1;
          if ( !v43 )
            o_wcsncpy_s_0(v42 + 664, 256i64, (char *)a1 + 216, -1i64);
        }
        goto LABEL_64;
      }
      v32 = *(_QWORD *)(v100 + 8);
      a2 = 1i64;
      v102 = 1;
      v78 = (struct CSslParentContext *)v100;
      if ( _InterlockedIncrement((volatile signed __int32 *)v100) == 1 )
      {
        v33 = *(struct CCredentialGroup **)(v32 + 80);
        if ( v33 && v33 != a1 )
        {
          v22 = -2146893055;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            v11 = v99;
          }
          else
          {
            WPP_SF_D(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              50i64,
              &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
              2148074241i64);
            v11 = v99;
            LODWORD(a2) = 1;
          }
          goto LABEL_85;
        }
        *(_WORD *)(v100 + 34) = 0;
        *(_DWORD *)(v100 + 36) = 0;
LABEL_64:
        v34 = *((_QWORD *)v78 + 3);
        if ( v34 )
          (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v34 + 56i64))(v34, a2, v31);
        v35 = *(struct CCredentialGroup **)(v32 + 80);
        if ( v35 != a1 )
        {
          if ( v35 )
          {
            CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, v35);
            (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v32 + 256i64))(v32, 0i64);
          }
          _InterlockedIncrement((volatile signed __int32 *)a1 + 6);
          *(_QWORD *)(v32 + 80) = a1;
          v45 = *((_DWORD *)a1 + 39);
          if ( (v45 & 4) != 0 )
          {
            v63 = *(_QWORD *)(v32 + 136);
            if ( (v63 & 0x100) == 0 )
            {
              *(_QWORD *)(v32 + 136) = v63 | 0x4000;
              v45 = *((_DWORD *)a1 + 39);
            }
          }
          if ( (v45 & 0x4000) != 0 )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_c955f13c15ab3d9e41a0e2d56db0bfe4_Traceguids);
            }
            *(_QWORD *)(v32 + 136) |= 0x200000000ui64;
          }
          v46 = *(_DWORD *)(v32 + 68);
          if ( v46 == 91 || v46 == 101 )
          {
            if ( *(_BYTE *)(v32 + 266) )
            {
              *(_BYTE *)(v32 + 923) = 1;
              CSsl3TlsClientContext::SetDefCredSearched(v32, 0);
            }
            else
            {
              CSsl3TlsClientContext::CheckForClientCred((CSsl3TlsClientContext *)v32);
            }
          }
        }
        *(_QWORD *)(v32 + 136) |= v79;
        if ( (*(_DWORD *)(v32 + 68) & 0xFFFFFFFB) == 0 )
        {
          v22 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *, __int64))(*(_QWORD *)v32 + 296i64))(
                  v32,
                  v90,
                  v31);
          if ( v22 )
            goto LABEL_84;
          v22 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *, struct _SecBuffer *))(*(_QWORD *)v32 + 304i64))(
                  v32,
                  v92,
                  v91);
          if ( v22 )
            goto LABEL_84;
          v22 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v32 + 312i64))(v32, v93);
          if ( v22 )
            goto LABEL_84;
        }
        v22 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *, struct _SecBuffer *))(*(_QWORD *)v32 + 328i64))(
                v32,
                v95,
                v94);
        if ( v22 )
          goto LABEL_84;
        v22 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v32 + 344i64))(v32, v96);
        if ( v22 )
          goto LABEL_84;
        v36 = (*(__int64 (__fastcall **)(__int64, struct _SecBufferDesc *, __int64))(*(_QWORD *)v32 + 368i64))(
                v32,
                a3,
                v82);
        v22 = v36;
        if ( v36 )
        {
          if ( *(_DWORD *)(v32 + 68) == 4 && v36 == 590614 )
          {
            v39 = 0;
            goto LABEL_75;
          }
LABEL_84:
          v11 = v99;
          LODWORD(a2) = v102;
          goto LABEL_85;
        }
        v37 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v32 + 376i64);
        if ( (v16 & 0x100) != 0 )
          LOBYTE(v22) = 1;
        v38 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v32 + 384i64))(v32);
        v22 = v37(v32, a7, v38, (unsigned __int8)v22);
        if ( v22 )
          goto LABEL_84;
        v39 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int128 *))(*(_QWORD *)v32 + 192i64))(v32, v86, &v81);
        if ( v39 != 1359 || (*(_DWORD *)(v32 + 136) & 0x40000) == 0 )
          goto LABEL_75;
        v47 = v78;
        if ( !v100 )
        {
          v32 = *((_QWORD *)v78 + 2);
          if ( v32 )
          {
            v78 = *(struct CSslParentContext **)(v32 + 128);
            if ( v78 )
            {
              v48 = *((_QWORD *)v47 + 1);
              *((_QWORD *)v47 + 2) = 0i64;
              v49 = *(_DWORD *)(v48 + 64);
              v50 = *(_DWORD *)(v48 + 68);
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
              {
                WPP_SF_q(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  0x12u,
                  (__int64)&WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids,
                  v47);
                v48 = *((_QWORD *)v47 + 1);
              }
              if ( v48 )
              {
                v51 = *(_DWORD *)(v48 + 64);
                (**(void (__fastcall ***)(__int64, _QWORD))v48)(v48, 0i64);
                if ( (v51 & 0x800A2AAA) != 0 )
                  SPExternalFree(*((void **)v47 + 1));
                *((_QWORD *)v47 + 1) = 0i64;
              }
              if ( (v49 & 0x51550) != 0 )
              {
                v52 = *((_QWORD *)v47 + 3);
                v53 = *((_BYTE *)v47 + 32);
                if ( !v52 )
                  goto LABEL_145;
                if ( v50 == 4 )
                {
                  v64 = (*(unsigned __int16 (__fastcall **)(_QWORD))(*(_QWORD *)v52 + 64i64))(*((_QWORD *)v47 + 3));
                  v65 = qword_180092DB8;
                  if ( (unsigned int)qword_180092DB8 <= v64 )
                    v65 = v64;
                  LODWORD(qword_180092DB8) = v65;
                  if ( _InterlockedIncrement((_DWORD *)&qword_180092DB0 + 1) == 100 )
                  {
                    if ( *((_QWORD *)&xmmword_180092DD0 + 1) )
                    {
                      LODWORD(qword_180092DC0) = qword_180092DB8;
                      if ( dword_180092DE0 )
                      {
                        v66 = operator new(0x80ui64);
                        if ( v66 )
                        {
                          v67 = CSslLookasidePreallocate::CSslLookasidePreallocate(
                                  (__int64)v66,
                                  qword_180092DC0,
                                  dword_180092DE0);
                          goto LABEL_244;
                        }
                      }
                      else
                      {
                        v68 = operator new(0x50ui64);
                        if ( v68 )
                        {
                          v67 = CSslLookaside::CSslLookaside((__int64)v68, qword_180092DC0, 1);
LABEL_244:
                          v69 = v67;
                          v70 = *((_QWORD *)&xmmword_180092DD0 + 1);
                          if ( v69 )
                            v70 = v69;
                          *((_QWORD *)&xmmword_180092DD0 + 1) = v70;
                        }
                      }
                    }
                  }
                }
                if ( v53 )
                {
                  v74 = (void *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v52 + 40i64))(v52);
                  SPExternalFree(v74);
                }
                else
                {
                  v71 = *((_QWORD *)&xmmword_180092DD0 + 1);
                  v72 = *(void (__fastcall **)(__int64, __int64))(**((_QWORD **)&xmmword_180092DD0 + 1) + 32i64);
                  v73 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v52 + 40i64))(v52);
                  v72(v71, v73);
                }
LABEL_145:
                *((_QWORD *)v47 + 3) = 0i64;
                (*(void (__fastcall **)(_QWORD, struct CSslParentContext *))(*(_QWORD *)xmmword_180092DD0 + 32i64))(
                  xmmword_180092DD0,
                  v47);
                v13 = v83;
              }
              else
              {
                SPExternalFree(v47);
              }
              v54 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int128 *))(*(_QWORD *)v32 + 192i64))(
                      v32,
                      v86,
                      &v81);
              v16 = v84;
              v39 = v54;
LABEL_75:
              v40 = *(_QWORD *)(v32 + 136);
              if ( (v40 & 0x10000000) != 0 )
              {
                v13 |= 0x8000ui64;
                *(_QWORD *)(v32 + 136) = v40 & 0xFFFFFFFFEFFFFFFFui64;
              }
              if ( v39 && !*((_DWORD *)v78 + 9) )
                *((_DWORD *)v78 + 9) = v39;
              if ( v99 )
                GenerateFatalAlertMessage(v39, v32, v16, (__int64)&v87);
              if ( v39 == 590624 && v80 )
                GeneratePSKExchangeMessage(v32, v80);
              if ( v100
                || !v39
                || v39 == 590614
                || v39 == -2146892950
                || HIBYTE(*(_WORD *)(v32 + 34)) == 0xFE && v39 == 590692 )
              {
                *a6 = (__int64)v78;
              }
              else
              {
                if ( (v16 & 0x100) != 0 && *((_QWORD *)&v81 + 1) )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v32 + 16i64))(v32);
                  *((_QWORD *)&v81 + 1) = 0i64;
                }
                CSslContextManager::DeleteFullSslContext((CSslContextManager *)&g_SslContextManager, v78);
                v32 = 0i64;
              }
              v22 = AscIscPostProcessing(
                      v39,
                      (struct CSslContext *)v32,
                      v78,
                      a11,
                      v97,
                      v85,
                      (struct SPBuffer *)v86,
                      v19,
                      (struct SPBuffer *)&v81,
                      v16,
                      a10,
                      a9);
              if ( !v22 && v32 && *(_DWORD *)(v32 + 68) == 4 )
              {
                v55 = *(_QWORD *)v32;
                v80 = 0i64;
                (*(void (__fastcall **)(__int64, __int64 *))(v55 + 232))(v32, &v80);
                if ( *(_QWORD *)(v80 + 344) )
                  v13 |= 2ui64;
                v11 = v99;
                LODWORD(a2) = v102;
                if ( (*(_DWORD *)(v32 + 136) & 0x400000) != 0 )
                  v13 |= 0x40ui64;
                goto LABEL_85;
              }
              goto LABEL_84;
            }
          }
        }
        LOWORD(v16) = v84;
        v22 = 1359;
        v11 = v99;
        LODWORD(a2) = v102;
      }
      else
      {
        v11 = v99;
        v22 = 120;
      }
    }
    else
    {
      v11 = v99;
      v22 = 87;
      LODWORD(a2) = 0;
    }
  }
LABEL_85:
  if ( !v19->cbBuffer || DWORD1(v81) > (unsigned int)v81 || v22 == -2146892949 )
    goto LABEL_157;
  if ( (v16 & 0x8000) != 0 )
    v13 |= 0x8000ui64;
LABEL_90:
  if ( v11 )
  {
    *((_QWORD *)v11 + 1) = *((_QWORD *)&v87 + 1);
    *v11 = DWORD1(v87);
  }
  if ( a8 )
    *a8 = v13;
  if ( v98 )
    *v98 = v13 & 0xFFFFFFFF00000000ui64;
  if ( (_DWORD)a2 && v78 )
    _InterlockedDecrement((volatile signed __int32 *)v78);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 51i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids, v22);
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
  {
    v75 = TranslateToSecurityStatus(v22);
    McTemplateU0pd_EtwEventWriteTransfer(v77, v76, *a6, v75);
  }
  if ( (v22 & 0x1FFF0000) == 589824 )
  {
    if ( v22 + 2146893823 > 0x2E )
    {
      if ( v22 + 2146889727 > 0x100E && v22 + 2146885612 > 0xFEC && v22 != -2146885615 )
        return v22;
LABEL_263:
      if ( v22 > 0x80092004 )
      {
        switch ( v22 )
        {
          case 0x800B0101:
          case 0x800B0102:
            return (unsigned int)-2146893016;
          case 0x800B0109:
            return (unsigned int)-2146893019;
          case 0x800B010C:
            return (unsigned int)-2146885616;
          case 0x800B010F:
            return (unsigned int)-2146893022;
        }
      }
      else
      {
        switch ( v22 )
        {
          case 0x80092004:
            return (unsigned int)-2146893043;
          case 0xEu:
            return (unsigned int)-2146893056;
          case 0x57u:
            return (unsigned int)-2146892963;
          case 0x78u:
            return (unsigned int)-2146893054;
          case 0x7Au:
            return (unsigned int)-2146893023;
        }
      }
    }
    return (unsigned int)-2146893052;
  }
  if ( v22 )
    goto LABEL_263;
  return 0i64;
}
// 180032A0E: conditional instruction was optimized away because ecx.4 is in (FE00..FEFF)
// 18003270F: variable 'a2' is possibly undefined
// 18003270F: variable 'v31' is possibly undefined
// 180032AD5: variable 'v77' is possibly undefined
// 180032AD5: variable 'v76' is possibly undefined
// 180028D84: using guessed type __int64 __fastcall o_wcsncpy_s_0(_QWORD, _QWORD, _QWORD, _QWORD);
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 1800927B0: using guessed type unsigned int CSslGlobals::m_dwEnableSessionTicket;
// 180092DA0: using guessed type __int64 g_SslContextManager;
// 180092DB0: using guessed type __int64 qword_180092DB0;
// 180092DB8: using guessed type __int64 qword_180092DB8;
// 180092DC0: using guessed type __int64 qword_180092DC0;
// 180092DD0: using guessed type __int128 xmmword_180092DD0;
// 180092DE0: using guessed type int dword_180092DE0;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;

//----- (000000018001F810) ----------------------------------------------------
__int64 __fastcall CSslContextManager::InstantiateServerContext(
        CSslContextManager *this,
        struct SPBuffer *a2,
        struct SPBuffer *a3,
        struct _SecBuffer *a4,
        struct _SecBuffer *a5,
        struct CCredentialGroup *a6,
        unsigned __int64 a7,
        struct CSslParentContext **a8)
{
  char v8; // r12
  unsigned __int64 v11; // rsi
  CCipherMill *v12; // r11
  unsigned int v13; // ebx
  __int64 v14; // rdx
  int v15; // edi
  unsigned int v16; // ecx
  int v17; // r8d
  unsigned int v18; // ebp
  int v19; // eax
  unsigned int v20; // r9d
  unsigned int v21; // eax
  unsigned int v22; // ebp
  int v23; // r15d
  __int64 v24; // rax
  __int64 v25; // rdi
  __int64 v26; // rbx
  void ***v27; // r14
  __int64 v28; // r12
  void **v29; // rax
  __int64 v30; // rax
  char v31; // al
  unsigned __int16 v32; // ax
  unsigned int v33; // ecx
  int v34; // eax
  _DWORD *v35; // rsi
  __int16 v36; // ax
  __int16 v37; // cx
  __int64 v38; // rsi
  _QWORD *v39; // rax
  __int64 v40; // rcx
  __int64 v41; // rsi
  _DWORD *v42; // rbx
  __int64 result; // rax
  int v44; // r9d
  int v45; // eax
  ULONG v46; // edx
  __int64 v47; // rax
  char v48; // al
  unsigned __int16 v49; // ax
  unsigned int v50; // ecx
  int v51; // eax
  _DWORD *v52; // rsi
  __int16 v53; // ax
  __int16 v54; // cx
  _WORD *v55; // rax
  int v56; // r14d
  char v57[8]; // [rsp+30h] [rbp-58h] BYREF
  int v58; // [rsp+38h] [rbp-50h]
  int v59; // [rsp+98h] [rbp+10h]

  v8 = 0;
  v59 = 0;
  v11 = a7 & 0x100000000i64;
  v12 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids);
    v12 = WPP_GLOBAL_Control;
  }
  v13 = *((_DWORD *)a2 + 1);
  if ( v13 < 5 && (a7 & 0x100000000i64) == 0 )
  {
    *((_DWORD *)a2 + 1) = 5;
    return 2148074264i64;
  }
  v14 = *((_QWORD *)a2 + 1);
  v15 = *((_DWORD *)a6 + 38);
  if ( (a7 & 0x100000000i64) != 0 )
  {
    if ( (v15 & 0xFFFFEFFF) != 0 )
      return 2148074333i64;
    v22 = 771;
    v23 = 1024;
    v8 = 1;
LABEL_18:
    v24 = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 6) + 16i64))(*((_QWORD *)this + 6));
    v25 = v24;
    if ( v24 )
    {
      v26 = v24 + 40;
      *(_QWORD *)(v24 + 8) = 0i64;
      if ( !v8 )
      {
        *(_QWORD *)(v24 + 48) = 0i64;
        *(_QWORD *)v26 = &CSslContext::`vftable';
        *(_QWORD *)(v24 + 56) = 0i64;
        *(_QWORD *)(v24 + 64) = 0i64;
        *(_WORD *)(v24 + 72) = 0;
        *(_DWORD *)(v24 + 76) = 0;
        *(_OWORD *)(v24 + 80) = 0i64;
        *(_DWORD *)(v24 + 96) = 0;
        *(_WORD *)(v24 + 136) = 0;
        *(_BYTE *)(v24 + 272) = 0;
        *(_WORD *)(v24 + 304) = 0;
        *(_BYTE *)(v24 + 306) = 0;
        v47 = LsaTable;
        *(_DWORD *)(v26 + 64) = v23;
        *(_QWORD *)(v26 + 68) = 0i64;
        *(_QWORD *)(v26 + 80) = 0i64;
        *(_QWORD *)(v26 + 88) = 0i64;
        *(_QWORD *)(v26 + 104) = 0i64;
        *(_QWORD *)(v26 + 112) = 0i64;
        *(_QWORD *)(v26 + 120) = 0i64;
        *(_QWORD *)(v26 + 128) = 0i64;
        *(_QWORD *)(v26 + 136) = 0i64;
        *(_QWORD *)(v26 + 144) = 0i64;
        *(_QWORD *)(v26 + 152) = 0i64;
        *(_QWORD *)(v26 + 160) = 0i64;
        *(_QWORD *)(v26 + 168) = 0i64;
        *(_QWORD *)(v26 + 176) = 0i64;
        *(_QWORD *)(v26 + 184) = 0i64;
        *(_DWORD *)(v26 + 192) = 0;
        *(_QWORD *)(v26 + 200) = 0i64;
        *(_QWORD *)(v26 + 208) = 0i64;
        *(_DWORD *)(v26 + 216) = 0;
        *(_WORD *)(v26 + 220) = 0;
        *(_QWORD *)(v26 + 224) = 0i64;
        *(_WORD *)(v26 + 234) = 0;
        *(_QWORD *)(v26 + 240) = 0i64;
        *(_QWORD *)(v26 + 248) = 0i64;
        *(_QWORD *)(v26 + 256) = 0i64;
        if ( (*(unsigned __int8 (__fastcall **)(char *))(v47 + 192))(v57) )
        {
          v48 = v58;
          if ( (v58 & 1) != 0 )
            *(_QWORD *)(v26 + 136) |= 0x20000000ui64;
          *(_BYTE *)(v26 + 266) = (v48 & 0x11) == 0;
        }
        v49 = ConvertSchannelProtocolToSsl(*(_DWORD *)(v26 + 64));
        v50 = v49;
        *(_WORD *)(v26 + 34) = v49;
        if ( HIBYTE(v49) != 0xFE || (v51 = 13, v50 > 0xFEFF) )
          v51 = 5;
        *(_DWORD *)(v26 + 60) = v51;
        *(_BYTE *)(v26 + 233) = (v23 & 0xF0000) != 0;
        if ( dword_180091480
          && (qword_180091490 & 0x400000000000i64) != 0
          && (qword_180091498 & 0x400000000000i64) == qword_180091498
          && (v52 = SPExternalAlloc(0x700u)) != 0i64 )
        {
          v52[2] = 0;
          *(_QWORD *)v52 = &CSchannelTelemetryContext::`vftable';
          *((_BYTE *)v52 + 16) = 0;
          v52[5] = 1;
          memset_0(v52 + 6, 0, 0x6E8ui64);
        }
        else
        {
          v52 = 0i64;
        }
        *(_QWORD *)(v26 + 120) = v52;
        memset_0((void *)(v26 + 272), 0, 0x40ui64);
        *(_DWORD *)(v26 + 336) = 0;
        *(_BYTE *)(v26 + 340) = 0;
        memset_0((void *)(v26 + 341), 0, 0x48ui64);
        *(_DWORD *)(v26 + 416) = 0;
        *(_OWORD *)(v26 + 420) = 0i64;
        *(_OWORD *)(v26 + 436) = 0i64;
        *(_QWORD *)(v26 + 452) = 0i64;
        *(_QWORD *)(v26 + 464) = 0i64;
        *(_DWORD *)(v26 + 472) = 0;
        *(_OWORD *)(v26 + 476) = 0i64;
        *(_OWORD *)(v26 + 492) = 0i64;
        *(_DWORD *)(v26 + 508) = 0;
        *(_OWORD *)(v26 + 512) = 0i64;
        *(_OWORD *)(v26 + 528) = 0i64;
        *(_WORD *)(v26 + 544) = 0;
        *(_QWORD *)(v26 + 548) = 0i64;
        *(_BYTE *)(v26 + 556) = 0;
        *(_OWORD *)(v26 + 560) = 0i64;
        *(_QWORD *)(v26 + 576) = 0i64;
        *(_QWORD *)(v26 + 584) = 0i64;
        memset_0((void *)(v26 + 592), 0, 0x80ui64);
        *(_DWORD *)(v26 + 720) = 0;
        *(_OWORD *)(v26 + 724) = 0i64;
        *(_OWORD *)(v26 + 740) = 0i64;
        *(_OWORD *)(v26 + 756) = 0i64;
        *(_QWORD *)(v26 + 772) = 0i64;
        *(_DWORD *)(v26 + 780) = 0;
        *(_QWORD *)(v26 + 784) = 0i64;
        *(_QWORD *)(v26 + 792) = 0i64;
        *(_QWORD *)(v26 + 800) = 0i64;
        *(_QWORD *)(v26 + 808) = 0i64;
        *(_QWORD *)(v26 + 816) = 0i64;
        *(_QWORD *)(v26 + 824) = 0i64;
        *(_QWORD *)(v26 + 832) = 0i64;
        *(_QWORD *)(v26 + 840) = 0i64;
        *(_QWORD *)(v26 + 848) = 0i64;
        *(_QWORD *)(v26 + 856) = 0i64;
        *(_QWORD *)(v26 + 864) = 0i64;
        *(_DWORD *)(v26 + 872) = 0;
        *(_QWORD *)(v26 + 880) = 0i64;
        *(_DWORD *)(v26 + 888) = 0;
        *(_QWORD *)(v26 + 896) = 0i64;
        *(_QWORD *)(v26 + 904) = 0i64;
        *(_QWORD *)(v26 + 912) = 0i64;
        *(_DWORD *)(v26 + 920) = 0;
        *(_WORD *)(v26 + 924) = 0;
        if ( *(_BYTE *)(v26 + 233) )
        {
          v53 = 1083;
          v54 = 1096;
        }
        else
        {
          *(_DWORD *)(v26 + 192) = -1;
          v53 = 0;
          *(_QWORD *)(v26 + 200) = 0i64;
          v54 = 0;
          *(_QWORD *)(v26 + 208) = 0i64;
        }
        *(_WORD *)(v26 + 216) = v54;
        v28 = 1000i64;
        *(_WORD *)(v26 + 218) = v53;
        *(_QWORD *)v26 = &CSsl3TlsServerContext::`vftable';
        *(_QWORD *)(v26 + 928) = 0i64;
        *(_QWORD *)(v26 + 936) = 0i64;
        *(_QWORD *)(v26 + 944) = 0i64;
        *(_WORD *)(v26 + 952) = 0;
        *(_QWORD *)(v26 + 960) = 0i64;
        *(_QWORD *)(v26 + 968) = 0i64;
        *(_QWORD *)(v26 + 976) = 0i64;
        *(_DWORD *)(v26 + 984) = 0;
        *(_BYTE *)(v26 + 988) = 0;
        *(_QWORD *)(v26 + 992) = 0i64;
LABEL_41:
        v40 = *((_QWORD *)this + 7);
        v41 = v28 + v26;
        if ( v40 )
        {
          v55 = (_WORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v40 + 16i64))(v40);
          v56 = *((_DWORD *)this + 8);
        }
        else
        {
          if ( !*((_BYTE *)this + 68) )
          {
LABEL_43:
            *(_QWORD *)(v25 + 8) = v26;
            *(_QWORD *)(v26 + 128) = v25;
            v42 = *(_DWORD **)(v25 + 8);
            if ( !v42 )
              return 1359i64;
            result = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)v42 + 184i64))(*(_QWORD *)(v25 + 8));
            if ( !(_DWORD)result )
            {
              v42[17] = v59;
              v42[9] = v22;
              *a8 = (struct CSslParentContext *)v25;
              return 0i64;
            }
            return result;
          }
          v56 = 2048;
          v55 = SPExternalAlloc(0x800u);
          *(_BYTE *)(v25 + 32) = 1;
        }
        if ( v55 && v56 )
        {
          *(_QWORD *)(v41 + 8) = 0i64;
          *(_QWORD *)v41 = &CSslScratchAllocator::`vftable';
          *(_WORD *)(v41 + 16) = v56;
          *(_DWORD *)(v41 + 18) = 0;
          if ( (unsigned __int16)v56 > 4u )
          {
            *(_QWORD *)(v41 + 8) = v55;
            *v55 = 0;
            *(_WORD *)(*(_QWORD *)(v41 + 8) + 2i64) = v56 - 4;
          }
          *(_QWORD *)(v25 + 24) = v41;
        }
        goto LABEL_43;
      }
      v27 = (void ***)(v24 + 1560);
      v28 = 1600i64;
      if ( !v11 )
        v28 = 1616i64;
      if ( v24 != -1560 && v24 != -40 )
      {
        if ( v11 )
        {
          v29 = &CNulRecord::`vftable';
        }
        else
        {
          *(_DWORD *)(v24 + 1644) = 20;
          *(_WORD *)(v24 + 1640) = 0x4000;
          *(_WORD *)(v24 + 1650) = 0x4000;
          v29 = &CTls13Record::`vftable';
          *(_BYTE *)(v26 + 1608) = 0;
        }
        *(_QWORD *)(v26 + 1528) = v26;
        *(_WORD *)(v26 + 1536) = 0;
        *(_QWORD *)(v26 + 1544) = 0i64;
        *(_QWORD *)(v26 + 1552) = 0i64;
        *(_DWORD *)(v26 + 1560) = 0;
        *(_QWORD *)(v26 + 1568) = 0i64;
        *(_QWORD *)(v26 + 1576) = 0i64;
        *(_QWORD *)(v26 + 1584) = 0i64;
        *(_DWORD *)(v26 + 1592) = 0;
        *v27 = v29;
        *(_QWORD *)v26 = &CSslContext::`vftable';
        *(_QWORD *)(v26 + 8) = 0i64;
        *(_QWORD *)(v26 + 16) = 0i64;
        *(_QWORD *)(v26 + 24) = 0i64;
        *(_WORD *)(v26 + 32) = 0;
        *(_DWORD *)(v26 + 36) = 0;
        *(_OWORD *)(v26 + 40) = 0i64;
        *(_DWORD *)(v26 + 56) = 0;
        *(_WORD *)(v26 + 96) = 0;
        *(_BYTE *)(v26 + 232) = 0;
        *(_WORD *)(v26 + 264) = 0;
        *(_BYTE *)(v26 + 266) = 0;
        v30 = LsaTable;
        *(_DWORD *)(v26 + 64) = v23;
        *(_QWORD *)(v26 + 68) = 0i64;
        *(_QWORD *)(v26 + 80) = 0i64;
        *(_QWORD *)(v26 + 88) = 0i64;
        *(_QWORD *)(v26 + 104) = 0i64;
        *(_QWORD *)(v26 + 112) = 0i64;
        *(_QWORD *)(v26 + 120) = 0i64;
        *(_QWORD *)(v26 + 128) = 0i64;
        *(_QWORD *)(v26 + 136) = 0i64;
        *(_QWORD *)(v26 + 144) = 0i64;
        *(_QWORD *)(v26 + 152) = 0i64;
        *(_QWORD *)(v26 + 160) = 0i64;
        *(_QWORD *)(v26 + 168) = 0i64;
        *(_QWORD *)(v26 + 176) = 0i64;
        *(_QWORD *)(v26 + 184) = 0i64;
        *(_DWORD *)(v26 + 192) = 0;
        *(_QWORD *)(v26 + 200) = 0i64;
        *(_QWORD *)(v26 + 208) = 0i64;
        *(_DWORD *)(v26 + 216) = 0;
        *(_WORD *)(v26 + 220) = 0;
        *(_QWORD *)(v26 + 224) = 0i64;
        *(_WORD *)(v26 + 234) = 0;
        *(_QWORD *)(v26 + 240) = 0i64;
        *(_QWORD *)(v26 + 248) = 0i64;
        *(_QWORD *)(v26 + 256) = 0i64;
        if ( (*(unsigned __int8 (__fastcall **)(char *))(v30 + 192))(v57) )
        {
          v31 = v58;
          if ( (v58 & 1) != 0 )
            *(_QWORD *)(v26 + 136) |= 0x20000000ui64;
          *(_BYTE *)(v26 + 266) = (v31 & 0x11) == 0;
        }
        v32 = ConvertSchannelProtocolToSsl(*(_DWORD *)(v26 + 64));
        v33 = v32;
        *(_WORD *)(v26 + 34) = v32;
        if ( HIBYTE(v32) != 0xFE || (v34 = 13, v33 > 0xFEFF) )
          v34 = 5;
        *(_DWORD *)(v26 + 60) = v34;
        *(_BYTE *)(v26 + 233) = (v23 & 0xF0000) != 0;
        if ( dword_180091480
          && (qword_180091490 & 0x400000000000i64) != 0
          && (qword_180091498 & 0x400000000000i64) == qword_180091498
          && (v35 = SPExternalAlloc(0x700u)) != 0i64 )
        {
          v35[2] = 0;
          *(_QWORD *)v35 = &CSchannelTelemetryContext::`vftable';
          *((_BYTE *)v35 + 16) = 0;
          v35[5] = 1;
          memset_0(v35 + 6, 0, 0x6E8ui64);
        }
        else
        {
          v35 = 0i64;
        }
        *(_QWORD *)(v26 + 120) = v35;
        memset_0((void *)(v26 + 272), 0, 0x40ui64);
        *(_DWORD *)(v26 + 336) = 0;
        *(_BYTE *)(v26 + 340) = 0;
        memset_0((void *)(v26 + 341), 0, 0x48ui64);
        *(_DWORD *)(v26 + 416) = 0;
        *(_OWORD *)(v26 + 420) = 0i64;
        *(_OWORD *)(v26 + 436) = 0i64;
        *(_QWORD *)(v26 + 452) = 0i64;
        *(_QWORD *)(v26 + 464) = 0i64;
        *(_DWORD *)(v26 + 472) = 0;
        *(_OWORD *)(v26 + 476) = 0i64;
        *(_OWORD *)(v26 + 492) = 0i64;
        *(_DWORD *)(v26 + 508) = 0;
        *(_OWORD *)(v26 + 512) = 0i64;
        *(_OWORD *)(v26 + 528) = 0i64;
        *(_WORD *)(v26 + 544) = 0;
        *(_QWORD *)(v26 + 548) = 0i64;
        *(_BYTE *)(v26 + 556) = 0;
        *(_OWORD *)(v26 + 560) = 0i64;
        *(_QWORD *)(v26 + 576) = 0i64;
        *(_QWORD *)(v26 + 584) = 0i64;
        memset_0((void *)(v26 + 592), 0, 0x80ui64);
        *(_DWORD *)(v26 + 720) = 0;
        *(_OWORD *)(v26 + 724) = 0i64;
        *(_OWORD *)(v26 + 740) = 0i64;
        *(_OWORD *)(v26 + 756) = 0i64;
        *(_QWORD *)(v26 + 772) = 0i64;
        *(_DWORD *)(v26 + 780) = 0;
        *(_QWORD *)(v26 + 784) = 0i64;
        *(_QWORD *)(v26 + 792) = 0i64;
        *(_QWORD *)(v26 + 800) = 0i64;
        *(_QWORD *)(v26 + 808) = 0i64;
        *(_QWORD *)(v26 + 816) = 0i64;
        *(_QWORD *)(v26 + 824) = 0i64;
        *(_QWORD *)(v26 + 832) = 0i64;
        *(_QWORD *)(v26 + 840) = 0i64;
        *(_QWORD *)(v26 + 848) = 0i64;
        *(_QWORD *)(v26 + 856) = 0i64;
        *(_QWORD *)(v26 + 864) = 0i64;
        *(_DWORD *)(v26 + 872) = 0;
        *(_QWORD *)(v26 + 880) = 0i64;
        *(_DWORD *)(v26 + 888) = 0;
        *(_QWORD *)(v26 + 896) = 0i64;
        *(_QWORD *)(v26 + 904) = 0i64;
        *(_QWORD *)(v26 + 912) = 0i64;
        *(_DWORD *)(v26 + 920) = 0;
        *(_WORD *)(v26 + 924) = 0;
        if ( *(_BYTE *)(v26 + 233) )
        {
          v36 = 1083;
          v37 = 1096;
        }
        else
        {
          *(_DWORD *)(v26 + 192) = -1;
          v36 = 0;
          *(_QWORD *)(v26 + 200) = 0i64;
          v37 = 0;
          *(_QWORD *)(v26 + 208) = 0i64;
        }
        *(_WORD *)(v26 + 216) = v37;
        *(_WORD *)(v26 + 218) = v36;
        *(_QWORD *)(v26 + 928) = 0i64;
        *(_QWORD *)(v26 + 936) = 0i64;
        *(_QWORD *)(v26 + 944) = 0i64;
        *(_WORD *)(v26 + 952) = 0;
        *(_QWORD *)(v26 + 960) = 0i64;
        *(_QWORD *)(v26 + 968) = 0i64;
        *(_QWORD *)(v26 + 976) = 0i64;
        *(_DWORD *)(v26 + 984) = 0;
        *(_BYTE *)(v26 + 988) = 0;
        *(_QWORD *)(v26 + 992) = 0i64;
        *(_QWORD *)(v26 + 1016) = &CTls13ChangeCipherSpec::`vftable';
        *(_QWORD *)(v26 + 1024) = v27;
        *(_BYTE *)(v26 + 1008) = 0;
        *(_BYTE *)(v26 + 1032) = 0;
        *(_QWORD *)(v26 + 1040) = 0i64;
        *(_QWORD *)(v26 + 1048) = 0i64;
        *(_QWORD *)(v26 + 1056) = 0i64;
        *(_QWORD *)(v26 + 1064) = 0i64;
        *(_QWORD *)(v26 + 1072) = 0i64;
        *(_QWORD *)(v26 + 1080) = 0i64;
        *(_QWORD *)(v26 + 1088) = 0i64;
        *(_QWORD *)(v26 + 1096) = 0i64;
        *(_QWORD *)(v26 + 1104) = 0i64;
        *(_QWORD *)(v26 + 1112) = 0i64;
        *(_BYTE *)(v26 + 1120) = 0;
        *(_BYTE *)(v26 + 1136) = 0;
        *(_QWORD *)(v26 + 1128) = 0i64;
        *(_QWORD *)(v26 + 1144) = 0i64;
        *(_OWORD *)(v26 + 1152) = 0i64;
        *(_OWORD *)(v26 + 1168) = 0i64;
        *(_OWORD *)(v26 + 1184) = 0i64;
        *(_BYTE *)(v26 + 1216) = 0;
        *(_WORD *)(v26 + 1232) = 0;
        *(_BYTE *)(v26 + 1248) = 0;
        *(_WORD *)(v26 + 1200) = 256;
        *(_QWORD *)(v26 + 1208) = v27;
        *(_QWORD *)(v26 + 1224) = 0i64;
        *(_QWORD *)(v26 + 1240) = 0i64;
        *(_OWORD *)(v26 + 1249) = 0i64;
        *(_OWORD *)(v26 + 1265) = 0i64;
        *(_WORD *)(v26 + 1281) = 0;
        v38 = *(_QWORD *)(v26 + 1208);
        *(_QWORD *)v26 = &CTls13ServerContext::`vftable'{for `CSsl3TlsServerContext'};
        *(_QWORD *)(v26 + 1000) = &CTls13ServerContext::`vftable'{for `CTls13Context'};
        *(_QWORD *)(v26 + 1288) = &CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::`vftable';
        *(_QWORD *)(v26 + 1296) = v26;
        v39 = operator new(0x30ui64);
        if ( v39 )
        {
          v39[1] = v26;
          *v39 = &CTls13ExtServer::`vftable';
          v39[2] = 0i64;
          *((_DWORD *)v39 + 6) = 0;
          v39[4] = v26;
          v39[5] = v26;
        }
        else
        {
          v39 = 0i64;
        }
        *(_QWORD *)(v26 + 1304) = v39;
        *(_QWORD *)(v26 + 1288) = &CTls13ServerHandshake::`vftable';
        *(_QWORD *)(v26 + 1312) = 0i64;
        *(_QWORD *)(v26 + 1320) = v38;
        *(_DWORD *)(v26 + 1328) = 0;
        *(_WORD *)(v26 + 1332) = 0;
        *(_BYTE *)(v26 + 1334) = 0;
        *(_DWORD *)(v26 + 1336) = 0;
        *(_WORD *)(v26 + 1340) = 0;
        *(_BYTE *)(v26 + 1342) = 0;
        *(_QWORD *)(v26 + 1344) = 0i64;
        *(_WORD *)(v26 + 1352) = 0;
        *(_QWORD *)(v26 + 1360) = 0i64;
        *(_DWORD *)(v26 + 1368) = 0;
        *(_QWORD *)(v26 + 1376) = 0i64;
        *(_QWORD *)(v26 + 1384) = 0i64;
        *(_DWORD *)(v26 + 1392) = 0;
        *(_QWORD *)(v26 + 1400) = 0i64;
        *(_QWORD *)(v26 + 1408) = 0i64;
        *(_QWORD *)(v26 + 1416) = 0i64;
        *(_QWORD *)(v26 + 1424) = 0i64;
        *(_QWORD *)(v26 + 1432) = 0i64;
        *(_DWORD *)(v26 + 1440) = 0;
        *(_WORD *)(v26 + 1444) = 0;
        *(_QWORD *)(v26 + 1448) = 0i64;
        *(_DWORD *)(v26 + 1456) = 0;
        *(_WORD *)(v26 + 1460) = 0;
        *(_QWORD *)(v26 + 1464) = 0i64;
        *(_DWORD *)(v26 + 1472) = 0;
        *(_WORD *)(v26 + 1476) = 0;
        *(_QWORD *)(v26 + 1480) = 0i64;
        *(_WORD *)(v26 + 1488) = 0;
        *(_QWORD *)(v26 + 1496) = 0i64;
        *(_WORD *)(v26 + 1504) = 0;
        *(_BYTE *)(v26 + 1506) = 0;
        *(_QWORD *)(v26 + 1512) = 0i64;
        goto LABEL_41;
      }
      (*(void (__fastcall **)(_QWORD, __int64))(**((_QWORD **)this + 6) + 32i64))(*((_QWORD *)this + 6), v26);
    }
    return 14i64;
  }
  if ( *(_BYTE *)v14 != 22 )
  {
    v22 = *(unsigned __int8 *)(v14 + 4) | (*(unsigned __int8 *)(v14 + 3) << 8);
    if ( v22 < 0x300 )
      goto LABEL_70;
    if ( v13 < 0xE )
    {
      *((_DWORD *)a2 + 1) = 14;
      return 2148074264i64;
    }
    if ( !(*(unsigned __int8 *)(v14 + 6) | (*(unsigned __int8 *)(v14 + 5) << 8)) )
      return 2148074289i64;
    if ( BYTE1(v22) == 0xFE && v22 <= 0xFEFF )
    {
      if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)v12 + 2), 13i64, &WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids);
      return 2148074278i64;
    }
    if ( v22 < 0x302 )
    {
      if ( v22 < 0x301 )
        goto LABEL_102;
    }
    else
    {
      v23 = 256;
      if ( (v15 & 0x100) != 0 )
      {
        v59 = 20;
        goto LABEL_18;
      }
    }
    if ( (v15 & 0x40) != 0 )
    {
      v59 = 20;
      v23 = 64;
      goto LABEL_18;
    }
LABEL_102:
    if ( (v15 & 0x10) != 0 )
    {
      v59 = 20;
      goto LABEL_104;
    }
LABEL_70:
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)v12 + 2), 14i64, &WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids);
    return 2148074289i64;
  }
  v16 = *(unsigned __int8 *)(v14 + 2) | (*(unsigned __int8 *)(v14 + 1) << 8);
  if ( _byteswap_ushort(*(_WORD *)(v14 + 1)) >> 8 == 0xFE && v16 <= 0xFEFF )
  {
    v17 = *(unsigned __int8 *)(v14 + 11);
    v18 = 13;
    v19 = *(unsigned __int8 *)(v14 + 12);
    v20 = 12;
  }
  else
  {
    v17 = *(unsigned __int8 *)(v14 + 3);
    v18 = 5;
    v19 = *(unsigned __int8 *)(v14 + 4);
    v20 = 4;
  }
  if ( (v19 | (unsigned int)(v17 << 8)) < v20 + 2 )
  {
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 1) != 0 )
    {
      if ( BYTE1(v16) == 0xFE && v16 <= 0xFEFF )
      {
        v44 = *(unsigned __int8 *)(v14 + 11);
        v45 = *(unsigned __int8 *)(v14 + 12);
      }
      else
      {
        v44 = *(unsigned __int8 *)(v14 + 3);
        v45 = *(unsigned __int8 *)(v14 + 4);
      }
      WPP_SF_d(*((_QWORD *)v12 + 2), 0xCu, (__int64)&WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids, v45 | (v44 << 8));
    }
    return 2148074278i64;
  }
  v21 = v20 + v18 + 2;
  if ( v13 < v21 )
  {
    *((_DWORD *)a2 + 1) = v21;
    return 2148074264i64;
  }
  v22 = *(unsigned __int8 *)(v18 + v14 + v20 + 1) | (*(unsigned __int8 *)(v18 + v14 + v20) << 8);
  if ( BYTE1(v22) != 0xFE || v22 > 0xFEFF )
  {
    if ( v22 < 0x303 )
    {
      if ( v22 < 0x302 )
      {
        if ( v22 < 0x301 )
          goto LABEL_83;
        goto LABEL_86;
      }
    }
    else if ( (v15 & 0x1400) != 0 )
    {
      if ( (v15 & 0x1000) != 0 )
        v8 = 1;
      v23 = 1024;
      goto LABEL_18;
    }
    v23 = 256;
    if ( (v15 & 0x100) != 0 )
      goto LABEL_18;
LABEL_86:
    if ( (v15 & 0x40) != 0 )
    {
      v23 = 64;
      goto LABEL_18;
    }
LABEL_83:
    if ( (v15 & 0x10) == 0 )
      return 2148074289i64;
LABEL_104:
    v23 = 16;
    goto LABEL_18;
  }
  if ( v22 > 0xFEFD || (v23 = 0x40000, (v15 & 0x40000) == 0) )
  {
    v23 = 0x10000;
    if ( (v15 & 0x10000) == 0 )
      goto LABEL_70;
  }
  v46 = CheckInitialDTLSHelloCookie(*((_DWORD *)a6 + 53), (const unsigned __int16 *)a6 + 108, a5, a2, a3);
  if ( !v46 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids);
    goto LABEL_18;
  }
  if ( v46 == 590610 )
  {
    a4->pvBuffer = (void *)*((_QWORD *)a3 + 1);
    a4->cbBuffer = *((_DWORD *)a3 + 1);
  }
  return v46;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';
// 18007C920: using guessed type void *CTls13ServerContext::`vftable'{for `CTls13Context'};
// 18007C928: using guessed type void *CTls13ServerContext::`vftable'{for `CSsl3TlsServerContext'};
// 18007CB58: using guessed type void *CTls13ChangeCipherSpec::`vftable';
// 18007CB68: using guessed type void *CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::`vftable';
// 18007CB80: using guessed type void *CTls13ServerHandshake::`vftable';
// 18007CB98: using guessed type void *CTls13ExtServer::`vftable';
// 18007CDB8: using guessed type void *CSslContext::`vftable';
// 18007CF58: using guessed type void *CSchannelTelemetryContext::`vftable';
// 18007CF80: using guessed type void *CTls13Record::`vftable';
// 18007D508: using guessed type void *CSslScratchAllocator::`vftable';
// 18007D590: using guessed type void *CNulRecord::`vftable';
// 180091490: using guessed type __int64 qword_180091490;
// 180091498: using guessed type __int64 qword_180091498;
// 180092620: using guessed type __int64 LsaTable;
// 18001F810: using guessed type char var_58[8];

//----- (0000000180020110) ----------------------------------------------------
CTls13ServerContext *__fastcall CTls13ServerContext::`scalar deleting destructor'(CTls13ServerContext *this)
{
  void *v2; // rcx
  void *v3; // rcx
  void *v4; // rcx
  void *v5; // rdx
  void *v6; // rdx
  void *v7; // rdi
  void *v8; // rdi
  void *v9; // rdx
  void *v10; // rdx
  void *v11; // rdx
  void *v12; // rdx
  __int64 v13; // rdx
  void **v14; // rcx
  void *v15; // rdx
  void *v16; // rdx
  void *v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // rcx
  __int64 v21; // rcx
  __int64 v22; // rcx
  __int64 v23; // rdi
  __int64 v24; // rcx
  CSslServerKey *v25; // rcx
  int v26; // ecx
  struct CCredentialGroup *v27; // rdx
  __int64 v28; // rcx
  volatile signed __int32 *v29; // rcx
  _QWORD *v31; // rdi
  void *v32; // rdx
  __int64 v33; // rax

  *(_QWORD *)this = &CTls13ServerContext::`vftable'{for `CSsl3TlsServerContext'};
  *((_QWORD *)this + 125) = &CTls13ServerContext::`vftable'{for `CTls13Context'};
  v2 = (void *)*((_QWORD *)this + 187);
  if ( v2 )
    SPExternalFree(v2);
  CTls13ServerContext::CleanupConnectedState(this);
  CTls13ServerHandshake::~CTls13ServerHandshake((CTls13ServerContext *)((char *)this + 1288));
  CTls13Context::~CTls13Context((CTls13ServerContext *)((char *)this + 1000));
  *(_QWORD *)this = &CSsl3TlsServerContext::`vftable';
  CSsl3TlsServerContext::CleanupConnectedState(this);
  v3 = (void *)*((_QWORD *)this + 116);
  if ( v3 )
    SPExternalFree(v3);
  v4 = (void *)*((_QWORD *)this + 117);
  if ( v4 )
    SPExternalFree(v4);
  v5 = (void *)*((_QWORD *)this + 118);
  if ( v5 )
    CSslContext::FreeMemory(this, v5);
  *(_QWORD *)this = &CSsl3TlsContext::`vftable';
  if ( *((_BYTE *)this + 233) )
  {
    v6 = (void *)*((_QWORD *)this + 71);
    if ( v6 )
      CSslContext::FreeMemory(this, v6);
    v7 = (void *)*((_QWORD *)this + 73);
    if ( v7 )
    {
      DTlsHandshakeQueue::~DTlsHandshakeQueue(*((DTlsHandshakeQueue **)this + 73));
      operator delete(v7);
      *((_QWORD *)this + 73) = 0i64;
    }
    v8 = (void *)*((_QWORD *)this + 72);
    if ( v8 )
    {
      DTlsMsgMgr::~DTlsMsgMgr(*((DTlsMsgMgr **)this + 72));
      operator delete(v8);
      *((_QWORD *)this + 72) = 0i64;
    }
    CSsl3TlsContext::FreeSavedWriteCipherState(this);
  }
  else
  {
    v31 = (_QWORD *)*((_QWORD *)this + 58);
    if ( v31 )
    {
      v32 = (void *)*((_QWORD *)this + 58);
      if ( *v31 && v31[3] )
      {
        (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*v31 + 16i64))(*v31, v31[3]);
        v31[3] = 0i64;
        *((_DWORD *)v31 + 4) = 0;
        v32 = (void *)*((_QWORD *)this + 58);
      }
      CSslContext::FreeMemory(this, v32);
    }
  }
  v9 = (void *)*((_QWORD *)this + 98);
  if ( v9 )
    CSslContext::FreeMemory(this, v9);
  v10 = (void *)*((_QWORD *)this + 99);
  if ( v10 )
    CSslContext::FreeMemory(this, v10);
  v11 = (void *)*((_QWORD *)this + 100);
  if ( v11 )
    CSslContext::FreeMemory(this, v11);
  CSsl3TlsContext::FreeSelectedSrtpParameters(this);
  v12 = (void *)*((_QWORD *)this + 102);
  if ( v12 )
    CSslContext::FreeMemory(this, v12);
  CSsl3TlsContext::FreeSelectedTBParameters(this);
  v13 = *((_QWORD *)this + 104);
  if ( v13 )
  {
    if ( *(_QWORD *)(v13 + 8) )
      (*(void (__fastcall **)(CTls13ServerContext *, _QWORD))(*(_QWORD *)this + 16i64))(this, *(_QWORD *)(v13 + 8));
    (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 104) = 0i64;
  }
  v14 = (void **)*((_QWORD *)this + 105);
  if ( v14 )
  {
    if ( v14[1] )
    {
      SPExternalFree(v14[1]);
      v14 = (void **)*((_QWORD *)this + 105);
    }
    if ( v14[3] )
    {
      SPExternalFree(v14[3]);
      v14 = (void **)*((_QWORD *)this + 105);
    }
    SPExternalFree(v14);
    *((_QWORD *)this + 105) = 0i64;
  }
  v15 = (void *)*((_QWORD *)this + 106);
  if ( v15 )
    CSslContext::FreeMemory(this, v15);
  v16 = (void *)*((_QWORD *)this + 107);
  if ( v16 )
    CSslContext::FreeMemory(this, v16);
  v17 = (void *)*((_QWORD *)this + 108);
  if ( v17 )
    CSslContext::FreeMemory(this, v17);
  CSsl3TlsContext::FreeHandshakeHash(this);
  v18 = *((_QWORD *)this + 18);
  *(_QWORD *)this = &CSslContext::`vftable';
  if ( v18 )
    SslFreeObject(v18, 0i64);
  v19 = *((_QWORD *)this + 19);
  if ( v19 )
    SslFreeObject(v19, 0i64);
  v20 = *((_QWORD *)this + 20);
  if ( v20 )
    SslFreeObject(v20, 0i64);
  v21 = *((_QWORD *)this + 21);
  if ( v21 )
    SslFreeObject(v21, 0i64);
  v22 = *((_QWORD *)this + 14);
  if ( v22 )
    SslFreeObject(v22, 0i64);
  v23 = *((_QWORD *)this + 1);
  if ( v23 )
  {
    v24 = *(_QWORD *)(v23 + 848);
    if ( v24 )
      CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v24 + 16));
    CMasterCipherInfo::Dereference(*(CMasterCipherInfo **)(v23 + 856));
  }
  v25 = (CSslServerKey *)*((_QWORD *)this + 3);
  if ( v25 )
    CSslServerKey::Dereference(v25);
  v26 = *((_DWORD *)this + 17);
  if ( (unsigned int)(v26 - 3) > 1 && v26 != 79 && (*((_DWORD *)this + 34) & 0x40000) == 0 )
  {
    v33 = *((_QWORD *)this + 11);
    if ( v33 )
      *(_BYTE *)(v33 + 236) = 0;
  }
  v27 = (struct CCredentialGroup *)*((_QWORD *)this + 10);
  if ( v27 )
    CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, v27);
  v28 = *((_QWORD *)this + 11);
  if ( v28 )
    CSessionCacheTable::DereferenceCacheItemInternal(
      *(CSessionCacheTable **)(v28 + 224),
      *((struct CSessionCacheItem **)this + 11),
      1,
      0);
  v29 = (volatile signed __int32 *)*((_QWORD *)this + 15);
  if ( v29 && _InterlockedExchangeAdd(v29 + 5, 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(volatile signed __int32 *, __int64))(*(_QWORD *)v29 + 8i64))(v29, 1i64);
  *(_QWORD *)this = &ISslSerialize::`vftable';
  return this;
}
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';
// 18007C920: using guessed type void *CTls13ServerContext::`vftable'{for `CTls13Context'};
// 18007C928: using guessed type void *CTls13ServerContext::`vftable'{for `CSsl3TlsServerContext'};
// 18007CBA8: using guessed type void *CSsl3TlsContext::`vftable';
// 18007CDB8: using guessed type void *CSslContext::`vftable';
// 18007CFB8: using guessed type void *ISslSerialize::`vftable';
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180020590) ----------------------------------------------------
struct CSessionCacheItem **__fastcall CSsl3TlsServerContext::`vector deleting destructor'(
        struct CSessionCacheItem **this)
{
  struct CSessionCacheItem *v2; // rcx
  struct CSessionCacheItem *v3; // rcx
  struct CSessionCacheItem *v4; // rdx
  struct CSessionCacheItem *v5; // rdx
  struct CSessionCacheItem *v6; // rdi
  struct CSessionCacheItem *v7; // rdi
  struct CSessionCacheItem *v8; // rdx
  struct CSessionCacheItem *v9; // rdx
  struct CSessionCacheItem *v10; // rdx
  struct CSessionCacheItem *v11; // rdx
  struct CSessionCacheItem *v12; // rdx
  void **v13; // rcx
  struct CSessionCacheItem *v14; // rdx
  struct CSessionCacheItem *v15; // rdx
  struct CSessionCacheItem *v16; // rdx
  struct CSessionCacheItem *v17; // rcx
  struct CSessionCacheItem *v18; // rcx
  struct CSessionCacheItem *v19; // rcx
  struct CSessionCacheItem *v20; // rcx
  struct CSessionCacheItem *v21; // rcx
  struct CSessionCacheItem *v22; // rdi
  __int64 v23; // rcx
  CSslServerKey *v24; // rcx
  int v25; // ecx
  struct CCredentialGroup *v26; // rdx
  struct CSessionCacheItem *v27; // rcx
  volatile signed __int32 *v28; // rcx
  struct CSessionCacheItem *v30; // rdi
  struct CSessionCacheItem *v31; // rdx
  struct CSessionCacheItem *v32; // rax

  *this = (struct CSessionCacheItem *)&CSsl3TlsServerContext::`vftable';
  CSsl3TlsServerContext::CleanupConnectedState((CSsl3TlsServerContext *)this);
  v2 = this[116];
  if ( v2 )
    SPExternalFree(v2);
  v3 = this[117];
  if ( v3 )
    SPExternalFree(v3);
  v4 = this[118];
  if ( v4 )
    CSslContext::FreeMemory((CSslContext *)this, v4);
  *this = (struct CSessionCacheItem *)&CSsl3TlsContext::`vftable';
  if ( *((_BYTE *)this + 233) )
  {
    v5 = this[71];
    if ( v5 )
      CSslContext::FreeMemory((CSslContext *)this, v5);
    v6 = this[73];
    if ( v6 )
    {
      DTlsHandshakeQueue::~DTlsHandshakeQueue(this[73]);
      operator delete(v6);
      this[73] = 0i64;
    }
    v7 = this[72];
    if ( v7 )
    {
      DTlsMsgMgr::~DTlsMsgMgr(this[72]);
      operator delete(v7);
      this[72] = 0i64;
    }
    CSsl3TlsContext::FreeSavedWriteCipherState((CSsl3TlsContext *)this);
  }
  else
  {
    v30 = this[58];
    if ( v30 )
    {
      v31 = this[58];
      if ( *(_QWORD *)v30 && *((_QWORD *)v30 + 3) )
      {
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)v30 + 16i64))(*(_QWORD *)v30, *((_QWORD *)v30 + 3));
        *((_QWORD *)v30 + 3) = 0i64;
        *((_DWORD *)v30 + 4) = 0;
        v31 = this[58];
      }
      CSslContext::FreeMemory((CSslContext *)this, v31);
    }
  }
  v8 = this[98];
  if ( v8 )
    CSslContext::FreeMemory((CSslContext *)this, v8);
  v9 = this[99];
  if ( v9 )
    CSslContext::FreeMemory((CSslContext *)this, v9);
  v10 = this[100];
  if ( v10 )
    CSslContext::FreeMemory((CSslContext *)this, v10);
  CSsl3TlsContext::FreeSelectedSrtpParameters((CSsl3TlsContext *)this);
  v11 = this[102];
  if ( v11 )
    CSslContext::FreeMemory((CSslContext *)this, v11);
  CSsl3TlsContext::FreeSelectedTBParameters((CSsl3TlsContext *)this);
  v12 = this[104];
  if ( v12 )
  {
    if ( *((_QWORD *)v12 + 1) )
      (*((void (__fastcall **)(struct CSessionCacheItem **, _QWORD))*this + 2))(this, *((_QWORD *)v12 + 1));
    (*((void (__fastcall **)(struct CSessionCacheItem **))*this + 2))(this);
    this[104] = 0i64;
  }
  v13 = (void **)this[105];
  if ( v13 )
  {
    if ( v13[1] )
    {
      SPExternalFree(v13[1]);
      v13 = (void **)this[105];
    }
    if ( v13[3] )
    {
      SPExternalFree(v13[3]);
      v13 = (void **)this[105];
    }
    SPExternalFree(v13);
    this[105] = 0i64;
  }
  v14 = this[106];
  if ( v14 )
    CSslContext::FreeMemory((CSslContext *)this, v14);
  v15 = this[107];
  if ( v15 )
    CSslContext::FreeMemory((CSslContext *)this, v15);
  v16 = this[108];
  if ( v16 )
    CSslContext::FreeMemory((CSslContext *)this, v16);
  CSsl3TlsContext::FreeHandshakeHash((CSsl3TlsContext *)this);
  v17 = this[18];
  *this = (struct CSessionCacheItem *)&CSslContext::`vftable';
  if ( v17 )
    SslFreeObject(v17, 0i64);
  v18 = this[19];
  if ( v18 )
    SslFreeObject(v18, 0i64);
  v19 = this[20];
  if ( v19 )
    SslFreeObject(v19, 0i64);
  v20 = this[21];
  if ( v20 )
    SslFreeObject(v20, 0i64);
  v21 = this[14];
  if ( v21 )
    SslFreeObject(v21, 0i64);
  v22 = this[1];
  if ( v22 )
  {
    v23 = *((_QWORD *)v22 + 106);
    if ( v23 )
      CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v23 + 16));
    CMasterCipherInfo::Dereference(*((CMasterCipherInfo **)v22 + 107));
  }
  v24 = this[3];
  if ( v24 )
    CSslServerKey::Dereference(v24);
  v25 = *((_DWORD *)this + 17);
  if ( (unsigned int)(v25 - 3) > 1 && v25 != 79 && ((_DWORD)this[17] & 0x40000) == 0 )
  {
    v32 = this[11];
    if ( v32 )
      *((_BYTE *)v32 + 236) = 0;
  }
  v26 = this[10];
  if ( v26 )
    CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, v26);
  v27 = this[11];
  if ( v27 )
    CSessionCacheTable::DereferenceCacheItemInternal(*((CSessionCacheTable **)v27 + 28), this[11], 1, 0);
  v28 = (volatile signed __int32 *)this[15];
  if ( v28 && _InterlockedExchangeAdd(v28 + 5, 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(volatile signed __int32 *, __int64))(*(_QWORD *)v28 + 8i64))(v28, 1i64);
  *this = (struct CSessionCacheItem *)&ISslSerialize::`vftable';
  return this;
}
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';
// 18007CBA8: using guessed type void *CSsl3TlsContext::`vftable';
// 18007CDB8: using guessed type void *CSslContext::`vftable';
// 18007CFB8: using guessed type void *ISslSerialize::`vftable';
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (00000001800209BC) ----------------------------------------------------
void __fastcall CSslServerKey::Dereference(CSslServerKey *this)
{
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)this + 6, 0xFFFFFFFF) == 1 )
  {
    if ( this )
      (*(void (__fastcall **)(CSslServerKey *, __int64))(*(_QWORD *)this + 8i64))(this, 1i64);
  }
}

//----- (00000001800209E0) ----------------------------------------------------
void __fastcall CSsl3TlsServerContext::CleanupConnectedState(CSsl3TlsServerContext *this)
{
  volatile signed __int32 *v2; // rcx
  void *v3; // rcx
  __int64 v4; // rdx
  _QWORD *v5; // rbx

  if ( *((_QWORD *)this + 120) )
  {
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 248i64))(this);
    v2 = (volatile signed __int32 *)*((_QWORD *)this + 120);
    if ( v2 && _InterlockedExchangeAdd(v2 + 7, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *, __int64))(*(_QWORD *)v2 + 8i64))(v2, 1i64);
    *((_QWORD *)this + 120) = 0i64;
  }
  if ( *((_QWORD *)this + 121) )
  {
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 121) = 0i64;
  }
  v3 = (void *)*((_QWORD *)this + 112);
  if ( v3 )
  {
    SPExternalFree(v3);
    *((_QWORD *)this + 112) = 0i64;
    *((_DWORD *)this + 222) = 0;
  }
  if ( *((_QWORD *)this + 110) )
  {
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 110) = 0i64;
  }
  v4 = *((_QWORD *)this + 114);
  *((_DWORD *)this + 218) = 0;
  if ( v4 )
  {
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 114) = 0i64;
    *((_WORD *)this + 460) = 0;
  }
  *(_WORD *)((char *)this + 923) = 0;
  *((_BYTE *)this + 472) = 0;
  v5 = (_QWORD *)*((_QWORD *)this + 58);
  if ( v5 && *v5 )
  {
    if ( v5[3] )
    {
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v5 + 16i64))(*v5);
      v5[3] = 0i64;
      *((_DWORD *)v5 + 4) = 0;
    }
  }
}

//----- (0000000180020B60) ----------------------------------------------------
void __fastcall CTls13Context::~CTls13Context(CTls13Context *this)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  void *v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  void (__fastcall ***v7)(_QWORD, _QWORD); // rcx

  *(_QWORD *)this = &CTls13Context::`vftable';
  v2 = *((_QWORD *)this + 9);
  if ( v2 )
    SslFreeObject(v2, 0i64);
  v3 = *((_QWORD *)this + 12);
  if ( v3 )
    SslFreeObject(v3, 0i64);
  v4 = (void *)*((_QWORD *)this + 20);
  if ( v4 )
    SPExternalFree(v4);
  v5 = *((_QWORD *)this + 10);
  if ( v5 )
  {
    SslFreeObject(v5, 0i64);
    *((_QWORD *)this + 10) = 0i64;
  }
  v6 = *((_QWORD *)this + 11);
  if ( v6 )
  {
    SslFreeObject(v6, 0i64);
    *((_QWORD *)this + 11) = 0i64;
  }
  *((_QWORD *)this + 18) = 0i64;
  *((_QWORD *)this + 16) = 0i64;
  memset((char *)this + 112, 0, 8ui64);
  *((_BYTE *)this + 120) = 0;
  memset((char *)this + 168, 0, 0x20ui64);
  v7 = (void (__fastcall ***)(_QWORD, _QWORD))*((_QWORD *)this + 26);
  *((_BYTE *)this + 200) = 0;
  (**v7)(v7, 0i64);
  *((_QWORD *)this + 2) = &CTls13ChangeCipherSpec::`vftable';
}
// 18007CB58: using guessed type void *CTls13ChangeCipherSpec::`vftable';
// 18007CB60: using guessed type void *CTls13Context::`vftable';
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180020C30) ----------------------------------------------------
void __fastcall CTls13ServerHandshake::~CTls13ServerHandshake(CTls13ServerHandshake *this)
{
  void *v2; // rcx
  void *v3; // rcx
  void (__fastcall ***v4)(_QWORD, __int64); // rcx
  void *v5; // rcx
  void *v6; // rcx

  *(_QWORD *)this = &CTls13ServerHandshake::`vftable';
  v2 = (void *)*((_QWORD *)this + 22);
  if ( v2 )
    SPExternalFree(v2);
  v3 = (void *)*((_QWORD *)this + 24);
  if ( v3 )
    LocalFree(v3);
  v4 = (void (__fastcall ***)(_QWORD, __int64))*((_QWORD *)this + 2);
  *(_QWORD *)this = &CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::`vftable';
  if ( v4 )
    (**v4)(v4, 1i64);
  v5 = (void *)*((_QWORD *)this + 7);
  if ( v5 )
    SPExternalFree(v5);
  v6 = (void *)*((_QWORD *)this + 18);
  if ( v6 )
    SPExternalFree(v6);
}
// 18007CB68: using guessed type void *CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::`vftable';
// 18007CB80: using guessed type void *CTls13ServerHandshake::`vftable';
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180020CD0) ----------------------------------------------------
void __fastcall CTls13ServerContext::CleanupConnectedState(CTls13ServerContext *this)
{
  const CERT_SERVER_OCSP_RESPONSE_CONTEXT *v2; // rcx
  __int64 v3; // rcx
  void *v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rcx
  void *v10; // rcx
  __int64 v11; // rdx
  _QWORD *v12; // rbx
  CSslCredential *v13; // rcx

  v2 = (const CERT_SERVER_OCSP_RESPONSE_CONTEXT *)*((_QWORD *)this + 189);
  if ( v2 )
  {
    CertFreeServerOcspResponseContext(v2);
    *((_QWORD *)this + 189) = 0i64;
  }
  v3 = *((_QWORD *)this + 138);
  if ( v3 )
  {
    SslFreeObject(v3, 0i64);
    *((_QWORD *)this + 138) = 0i64;
  }
  v4 = (void *)*((_QWORD *)this + 153);
  if ( v4 )
  {
    SPExternalFree(v4);
    *((_QWORD *)this + 153) = 0i64;
  }
  v5 = *((_QWORD *)this + 130);
  *((_BYTE *)this + 1232) = 0;
  if ( v5 )
  {
    SslFreeObject(v5, 0i64);
    *((_QWORD *)this + 130) = 0i64;
  }
  v6 = *((_QWORD *)this + 131);
  if ( v6 )
  {
    SslFreeObject(v6, 0i64);
    *((_QWORD *)this + 131) = 0i64;
  }
  v7 = *((_QWORD *)this + 132);
  if ( v7 )
  {
    SslFreeObject(v7, 0i64);
    *((_QWORD *)this + 132) = 0i64;
  }
  v8 = *((_QWORD *)this + 133);
  if ( v8 )
  {
    SslFreeObject(v8, 0i64);
    *((_QWORD *)this + 133) = 0i64;
  }
  v9 = *((_QWORD *)this + 155);
  if ( v9 )
  {
    SslFreeObject(v9, 0i64);
    *((_QWORD *)this + 155) = 0i64;
  }
  if ( *((_QWORD *)this + 120) )
  {
    (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 248i64))(this);
    CSslCredential::ReleaseEphemeralKeyData(v13, *((struct CEphemKeyData **)this + 120));
    *((_QWORD *)this + 120) = 0i64;
  }
  if ( *((_QWORD *)this + 121) )
  {
    (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 121) = 0i64;
  }
  v10 = (void *)*((_QWORD *)this + 112);
  if ( v10 )
  {
    SPExternalFree(v10);
    *((_QWORD *)this + 112) = 0i64;
    *((_DWORD *)this + 222) = 0;
  }
  if ( *((_QWORD *)this + 110) )
  {
    (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 110) = 0i64;
  }
  v11 = *((_QWORD *)this + 114);
  *((_DWORD *)this + 218) = 0;
  if ( v11 )
  {
    (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 114) = 0i64;
    *((_WORD *)this + 460) = 0;
  }
  *(_WORD *)((char *)this + 923) = 0;
  *((_BYTE *)this + 472) = 0;
  v12 = (_QWORD *)*((_QWORD *)this + 58);
  if ( v12 && *v12 )
  {
    if ( v12[3] )
    {
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v12 + 16i64))(*v12);
      v12[3] = 0i64;
      *((_DWORD *)v12 + 4) = 0;
    }
  }
}
// 180033533: variable 'v13' is possibly undefined
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180020DF0) ----------------------------------------------------
CSsl3TlsContext *__fastcall CSsl3TlsContext::CSsl3TlsContext(CSsl3TlsContext *this, __int64 a2)
{
  __int64 v4; // rdx
  void *v5; // rsi
  void *v6; // rdx
  CSsl3TlsContext *result; // rax

  CSslContext::CSslContext((__int64)this, a2);
  *(_QWORD *)this = &CSsl3TlsContext::`vftable';
  *((_DWORD *)this + 84) = *(_DWORD *)(v4 + 336);
  *((_BYTE *)this + 340) = *(_BYTE *)(v4 + 340);
  *((_DWORD *)this + 104) = *(_DWORD *)(v4 + 416);
  *((_DWORD *)this + 114) = *(_DWORD *)(v4 + 456);
  *((_QWORD *)this + 58) = *(_QWORD *)(v4 + 464);
  *((_BYTE *)this + 472) = *(_BYTE *)(v4 + 472);
  *((_BYTE *)this + 473) = *(_BYTE *)(v4 + 473);
  *(_OWORD *)((char *)this + 474) = *(_OWORD *)(v4 + 474);
  *(_OWORD *)((char *)this + 490) = *(_OWORD *)(v4 + 490);
  *(_DWORD *)((char *)this + 506) = *(_DWORD *)(v4 + 506);
  *(_OWORD *)((char *)this + 510) = *(_OWORD *)(v4 + 510);
  *(_OWORD *)((char *)this + 526) = *(_OWORD *)(v4 + 526);
  *(_DWORD *)((char *)this + 542) = *(_DWORD *)(v4 + 542);
  *((_DWORD *)this + 137) = *(_DWORD *)(v4 + 548);
  *((_BYTE *)this + 552) = *(_BYTE *)(v4 + 552);
  *((_BYTE *)this + 553) = *(_BYTE *)(v4 + 553);
  *((_BYTE *)this + 554) = *(_BYTE *)(v4 + 554);
  *((_BYTE *)this + 555) = *(_BYTE *)(v4 + 555);
  *((_BYTE *)this + 556) = *(_BYTE *)(v4 + 556);
  *((_DWORD *)this + 140) = *(_DWORD *)(v4 + 560);
  *((_DWORD *)this + 141) = *(_DWORD *)(v4 + 564);
  *((_QWORD *)this + 71) = *(_QWORD *)(v4 + 568);
  *((_QWORD *)this + 72) = *(_QWORD *)(v4 + 576);
  *((_QWORD *)this + 73) = *(_QWORD *)(v4 + 584);
  *((_QWORD *)this + 98) = *(_QWORD *)(v4 + 784);
  *((_QWORD *)this + 100) = *(_QWORD *)(v4 + 800);
  *((_QWORD *)this + 101) = *(_QWORD *)(v4 + 808);
  *((_QWORD *)this + 102) = *(_QWORD *)(v4 + 816);
  *((_QWORD *)this + 103) = *(_QWORD *)(v4 + 824);
  *((_QWORD *)this + 104) = *(_QWORD *)(v4 + 832);
  *((_QWORD *)this + 105) = *(_QWORD *)(v4 + 840);
  *((_QWORD *)this + 106) = *(_QWORD *)(v4 + 848);
  *((_QWORD *)this + 107) = *(_QWORD *)(v4 + 856);
  *((_QWORD *)this + 108) = *(_QWORD *)(v4 + 864);
  *((_DWORD *)this + 218) = *(_DWORD *)(v4 + 872);
  *((_QWORD *)this + 110) = *(_QWORD *)(v4 + 880);
  *((_DWORD *)this + 222) = *(_DWORD *)(v4 + 888);
  *((_QWORD *)this + 112) = *(_QWORD *)(v4 + 896);
  v5 = (void *)(v4 + 592);
  *((_QWORD *)this + 113) = *(_QWORD *)(v4 + 904);
  *((_QWORD *)this + 114) = *(_QWORD *)(v4 + 912);
  *((_WORD *)this + 460) = *(_WORD *)(v4 + 920);
  *((_BYTE *)this + 922) = *(_BYTE *)(v4 + 922);
  *((_BYTE *)this + 923) = *(_BYTE *)(v4 + 923);
  *((_BYTE *)this + 924) = *(_BYTE *)(v4 + 924);
  *((_BYTE *)this + 925) = *(_BYTE *)(v4 + 925);
  *((_OWORD *)this + 45) = *(_OWORD *)(v4 + 720);
  *((_OWORD *)this + 46) = *(_OWORD *)(v4 + 736);
  *((_OWORD *)this + 47) = *(_OWORD *)(v4 + 752);
  *((_OWORD *)this + 48) = *(_OWORD *)(v4 + 768);
  *((_OWORD *)this + 37) = *(_OWORD *)(v4 + 592);
  *((_OWORD *)this + 38) = *(_OWORD *)(v4 + 608);
  *((_OWORD *)this + 39) = *(_OWORD *)(v4 + 624);
  *((_OWORD *)this + 40) = *(_OWORD *)(v4 + 640);
  *((_OWORD *)this + 41) = *(_OWORD *)(v4 + 656);
  *((_OWORD *)this + 42) = *(_OWORD *)(v4 + 672);
  *((_OWORD *)this + 43) = *(_OWORD *)(v4 + 688);
  *((_OWORD *)this + 44) = *(_OWORD *)(v4 + 704);
  *(_OWORD *)((char *)this + 420) = *(_OWORD *)(v4 + 420);
  *(_OWORD *)((char *)this + 436) = *(_OWORD *)(v4 + 436);
  *((_DWORD *)this + 113) = *(_DWORD *)(v4 + 452);
  *(_OWORD *)((char *)this + 377) = *(_OWORD *)(v4 + 377);
  *(_OWORD *)((char *)this + 393) = *(_OWORD *)(v4 + 393);
  *(_DWORD *)((char *)this + 409) = *(_DWORD *)(v4 + 409);
  *(_OWORD *)((char *)this + 341) = *(_OWORD *)(v4 + 341);
  *(_OWORD *)((char *)this + 357) = *(_OWORD *)(v4 + 357);
  *(_DWORD *)((char *)this + 373) = *(_DWORD *)(v4 + 373);
  *((_OWORD *)this + 17) = *(_OWORD *)(v4 + 272);
  *((_OWORD *)this + 18) = *(_OWORD *)(v4 + 288);
  *((_OWORD *)this + 19) = *(_OWORD *)(v4 + 304);
  *((_OWORD *)this + 20) = *(_OWORD *)(v4 + 320);
  *(_QWORD *)(v4 + 896) = 0i64;
  *(_DWORD *)(v4 + 888) = 0;
  *(_QWORD *)(v4 + 880) = 0i64;
  *(_DWORD *)(v4 + 872) = 0;
  *(_QWORD *)(v4 + 912) = 0i64;
  *(_WORD *)(v4 + 920) = 0;
  *(_QWORD *)(v4 + 464) = 0i64;
  *(_QWORD *)(v4 + 560) = 0i64;
  *(_QWORD *)(v4 + 568) = 0i64;
  *(_QWORD *)(v4 + 584) = 0i64;
  *(_QWORD *)(v4 + 576) = 0i64;
  *(_QWORD *)(v4 + 784) = 0i64;
  *(_QWORD *)(v4 + 800) = 0i64;
  *(_QWORD *)(v4 + 808) = 0i64;
  v6 = *(void **)(v4 + 792);
  if ( v6 )
  {
    CSslContext::FreeMemory(this, v6);
    *(_QWORD *)(a2 + 792) = 0i64;
  }
  *(_QWORD *)(a2 + 816) = 0i64;
  *(_QWORD *)(a2 + 824) = 0i64;
  *(_QWORD *)(a2 + 832) = 0i64;
  *(_QWORD *)(a2 + 840) = 0i64;
  *(_QWORD *)(a2 + 848) = 0i64;
  *(_QWORD *)(a2 + 856) = 0i64;
  *(_QWORD *)(a2 + 864) = 0i64;
  memset_0(v5, 0, 0x80ui64);
  memset_0((void *)(a2 + 720), 0, 0x40ui64);
  result = this;
  *(_DWORD *)(a2 + 548) = 0;
  *(_WORD *)(a2 + 474) = 0;
  *(_DWORD *)(a2 + 508) = 0;
  *(_WORD *)(a2 + 544) = 0;
  *(_BYTE *)(a2 + 473) = 0;
  return result;
}
// 180020E1F: variable 'v4' is possibly undefined
// 18007CBA8: using guessed type void *CSsl3TlsContext::`vftable';

//----- (00000001800212D0) ----------------------------------------------------
__int64 __fastcall CSslContext::CSslContext(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &CSslContext::`vftable';
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_WORD *)(a1 + 32) = *(_WORD *)(a2 + 32);
  *(_WORD *)(a1 + 34) = *(_WORD *)(a2 + 34);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_BYTE *)(a1 + 96) = *(_BYTE *)(a2 + 96);
  *(_BYTE *)(a1 + 97) = *(_BYTE *)(a2 + 97);
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
  *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
  *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
  *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
  *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
  *(_DWORD *)(a1 + 192) = *(_DWORD *)(a2 + 192);
  *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
  *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
  *(_WORD *)(a1 + 216) = *(_WORD *)(a2 + 216);
  *(_WORD *)(a1 + 218) = *(_WORD *)(a2 + 218);
  *(_WORD *)(a1 + 220) = *(_WORD *)(a2 + 220);
  *(_QWORD *)(a1 + 224) = *(_QWORD *)(a2 + 224);
  *(_BYTE *)(a1 + 232) = *(_BYTE *)(a2 + 232);
  *(_BYTE *)(a1 + 233) = *(_BYTE *)(a2 + 233);
  *(_WORD *)(a1 + 234) = *(_WORD *)(a2 + 234);
  *(_QWORD *)(a1 + 240) = *(_QWORD *)(a2 + 240);
  *(_QWORD *)(a1 + 248) = *(_QWORD *)(a2 + 248);
  *(_QWORD *)(a1 + 256) = *(_QWORD *)(a2 + 256);
  *(_BYTE *)(a1 + 264) = *(_BYTE *)(a2 + 264);
  *(_BYTE *)(a1 + 265) = *(_BYTE *)(a2 + 265);
  *(_BYTE *)(a1 + 266) = *(_BYTE *)(a2 + 266);
  *(_QWORD *)(a2 + 144) = 0i64;
  *(_QWORD *)(a2 + 152) = 0i64;
  *(_QWORD *)(a2 + 160) = 0i64;
  *(_QWORD *)(a2 + 168) = 0i64;
  *(_QWORD *)(a2 + 112) = 0i64;
  *(_QWORD *)(a2 + 8) = 0i64;
  *(_QWORD *)(a2 + 24) = 0i64;
  *(_QWORD *)(a2 + 88) = 0i64;
  *(_QWORD *)(a2 + 80) = 0i64;
  *(_QWORD *)(a2 + 120) = 0i64;
  return a1;
}
// 18007CDB8: using guessed type void *CSslContext::`vftable';

//----- (0000000180021510) ----------------------------------------------------
CTlsExtServer *__fastcall CTlsExtServer::`vector deleting destructor'(CTlsExtServer *this, char a2)
{
  *(_QWORD *)this = &CTlsExt::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 18007D038: using guessed type void *CTlsExt::`vftable';

//----- (0000000180021540) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::WriteServerEvent(CSchannelTelemetryContext *this)
{
  unsigned int v1; // r10d
  char v2; // al
  int v3; // r10d
  __int16 v4; // r8
  int v5; // r11d
  int v6; // edi
  const WCHAR *v7; // r9
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // rax
  int v26; // ecx
  unsigned __int8 v27; // bl
  char *v28; // rax
  char v29; // cl
  char v32; // cl
  char v33; // r8
  char v34; // dl
  __int64 v35; // rcx
  signed __int64 v36; // r13
  __int64 v37; // rdi
  unsigned int v38; // eax
  unsigned int v39; // eax
  unsigned int v40; // eax
  unsigned __int8 v41; // cl
  unsigned int v42; // edx
  struct _EVENT_DATA_DESCRIPTOR *v43; // r10
  __int64 v44; // r11
  unsigned __int64 i; // rcx
  int v46; // eax
  RTL_SRWLOCK *v47; // r12
  int v48; // r15d
  volatile signed __int64 *j; // rsi
  volatile signed __int64 v50; // rsi
  int v51; // ecx
  __int64 v52; // r14
  int v53; // eax
  unsigned int v54; // edi
  unsigned __int8 v55; // dl
  signed __int64 v56; // r8
  __int64 v57; // rax
  int v58; // r10d
  volatile signed __int64 *v59; // r9
  int v60; // eax
  unsigned int v61; // eax
  signed __int64 v62; // rax
  volatile signed __int64 v63; // rtt
  char v64; // [rsp+38h] [rbp-D0h] BYREF
  char v65; // [rsp+39h] [rbp-CFh] BYREF
  __int64 v66; // [rsp+40h] [rbp-C8h] BYREF
  __int16 v67; // [rsp+48h] [rbp-C0h] BYREF
  __int16 v68; // [rsp+4Ah] [rbp-BEh] BYREF
  int v69; // [rsp+4Ch] [rbp-BCh] BYREF
  int v70; // [rsp+50h] [rbp-B8h] BYREF
  int v71; // [rsp+54h] [rbp-B4h] BYREF
  int v72; // [rsp+58h] [rbp-B0h] BYREF
  int v73; // [rsp+5Ch] [rbp-ACh] BYREF
  int v74; // [rsp+60h] [rbp-A8h] BYREF
  int v75; // [rsp+64h] [rbp-A4h] BYREF
  int v76; // [rsp+68h] [rbp-A0h] BYREF
  int v77; // [rsp+6Ch] [rbp-9Ch] BYREF
  int v78; // [rsp+70h] [rbp-98h] BYREF
  int v79; // [rsp+74h] [rbp-94h] BYREF
  int v80; // [rsp+78h] [rbp-90h] BYREF
  int v81; // [rsp+7Ch] [rbp-8Ch] BYREF
  int v82; // [rsp+80h] [rbp-88h] BYREF
  __int64 v83; // [rsp+88h] [rbp-80h]
  EVENT_DESCRIPTOR EventDescriptor; // [rsp+90h] [rbp-78h] BYREF
  __int64 v85; // [rsp+A0h] [rbp-68h] BYREF
  __int64 v86; // [rsp+A8h] [rbp-60h] BYREF
  __int64 v87; // [rsp+B0h] [rbp-58h] BYREF
  __int64 v88; // [rsp+B8h] [rbp-50h] BYREF
  __int64 v89; // [rsp+C0h] [rbp-48h] BYREF
  __int64 v90; // [rsp+C8h] [rbp-40h] BYREF
  __int64 v91; // [rsp+D0h] [rbp-38h] BYREF
  __int64 v92; // [rsp+D8h] [rbp-30h] BYREF
  __int64 v93; // [rsp+E0h] [rbp-28h] BYREF
  __int64 v94; // [rsp+E8h] [rbp-20h] BYREF
  __int64 v95; // [rsp+F0h] [rbp-18h] BYREF
  __int64 v96; // [rsp+F8h] [rbp-10h] BYREF
  __int64 v97; // [rsp+100h] [rbp-8h] BYREF
  __int64 v98; // [rsp+108h] [rbp+0h] BYREF
  __int64 v99; // [rsp+110h] [rbp+8h] BYREF
  __int64 v100; // [rsp+118h] [rbp+10h] BYREF
  __int64 v101; // [rsp+120h] [rbp+18h] BYREF
  __int64 v102; // [rsp+128h] [rbp+20h] BYREF
  __int64 v103; // [rsp+130h] [rbp+28h] BYREF
  __int64 v104; // [rsp+138h] [rbp+30h] BYREF
  __int64 v105; // [rsp+140h] [rbp+38h] BYREF
  __int64 v106; // [rsp+148h] [rbp+40h] BYREF
  __int64 v107; // [rsp+150h] [rbp+48h] BYREF
  __int64 v108; // [rsp+158h] [rbp+50h] BYREF
  __int64 v109; // [rsp+160h] [rbp+58h] BYREF
  __int64 v110; // [rsp+168h] [rbp+60h] BYREF
  __int64 v111; // [rsp+170h] [rbp+68h] BYREF
  __int64 v112; // [rsp+178h] [rbp+70h] BYREF
  __int64 v113; // [rsp+180h] [rbp+78h] BYREF
  __int64 v114; // [rsp+188h] [rbp+80h] BYREF
  __int64 v115; // [rsp+190h] [rbp+88h] BYREF
  __int64 v116; // [rsp+198h] [rbp+90h] BYREF
  __int64 v117; // [rsp+1A0h] [rbp+98h] BYREF
  __int64 v118; // [rsp+1A8h] [rbp+A0h] BYREF
  __int64 v119[2]; // [rsp+1B0h] [rbp+A8h] BYREF
  __int16 v120; // [rsp+1C0h] [rbp+B8h] BYREF
  __int64 v121; // [rsp+1C8h] [rbp+C0h]
  __int16 v122; // [rsp+1D0h] [rbp+C8h] BYREF
  __int64 v123; // [rsp+1D8h] [rbp+D0h]
  struct _EVENT_DATA_DESCRIPTOR UserData; // [rsp+1E8h] [rbp+E0h] BYREF
  void *Buf1; // [rsp+1F8h] [rbp+F0h] BYREF
  int v126; // [rsp+200h] [rbp+F8h]
  int v127; // [rsp+204h] [rbp+FCh]
  __int64 *v128; // [rsp+208h] [rbp+100h]
  __int64 v129[68]; // [rsp+210h] [rbp+108h]
  int v130; // [rsp+430h] [rbp+328h]
  int v131; // [rsp+434h] [rbp+32Ch]
  char *v132; // [rsp+438h] [rbp+330h]
  __int64 v133; // [rsp+440h] [rbp+338h]
  __int64 *v134; // [rsp+448h] [rbp+340h]
  __int64 v135; // [rsp+450h] [rbp+348h]
  __int64 *v136; // [rsp+458h] [rbp+350h]
  __int64 v137; // [rsp+460h] [rbp+358h]
  int *v138; // [rsp+468h] [rbp+360h]
  __int64 v139; // [rsp+470h] [rbp+368h]
  __int16 *v140; // [rsp+478h] [rbp+370h]
  __int64 v141; // [rsp+480h] [rbp+378h]
  int *v142; // [rsp+488h] [rbp+380h]
  __int64 v143; // [rsp+490h] [rbp+388h]
  int *v144; // [rsp+498h] [rbp+390h]
  __int64 v145; // [rsp+4A0h] [rbp+398h]
  __int16 *v146; // [rsp+4A8h] [rbp+3A0h]
  __int64 v147; // [rsp+4B0h] [rbp+3A8h]
  __int64 v148; // [rsp+4B8h] [rbp+3B0h]
  int v149; // [rsp+4C0h] [rbp+3B8h]
  int v150; // [rsp+4C4h] [rbp+3BCh]
  __int16 *v151; // [rsp+4C8h] [rbp+3C0h]
  __int64 v152; // [rsp+4D0h] [rbp+3C8h]
  int *v153; // [rsp+4D8h] [rbp+3D0h]
  __int64 v154; // [rsp+4E0h] [rbp+3D8h]
  int *v155; // [rsp+4E8h] [rbp+3E0h]
  __int64 v156; // [rsp+4F0h] [rbp+3E8h]
  int *v157; // [rsp+4F8h] [rbp+3F0h]
  __int64 v158; // [rsp+500h] [rbp+3F8h]
  int *v159; // [rsp+508h] [rbp+400h]
  __int64 v160; // [rsp+510h] [rbp+408h]
  int *v161; // [rsp+518h] [rbp+410h]
  __int64 v162; // [rsp+520h] [rbp+418h]
  int *v163; // [rsp+528h] [rbp+420h]
  __int64 v164; // [rsp+530h] [rbp+428h]
  int *v165; // [rsp+538h] [rbp+430h]
  __int64 v166; // [rsp+540h] [rbp+438h]
  char *v167; // [rsp+548h] [rbp+440h]
  __int64 v168; // [rsp+550h] [rbp+448h]
  int *v169; // [rsp+558h] [rbp+450h]
  __int64 v170; // [rsp+560h] [rbp+458h]
  int *v171; // [rsp+568h] [rbp+460h]
  __int64 v172; // [rsp+570h] [rbp+468h]
  __int16 *v173; // [rsp+578h] [rbp+470h]
  __int64 v174; // [rsp+580h] [rbp+478h]
  __int64 v175; // [rsp+588h] [rbp+480h]
  int v176; // [rsp+590h] [rbp+488h]
  int v177; // [rsp+594h] [rbp+48Ch]
  int *v178; // [rsp+598h] [rbp+490h]
  __int64 v179; // [rsp+5A0h] [rbp+498h]

  v1 = *((_DWORD *)this + 8);
  v2 = v1 & 0xF;
  v3 = v1 >> 4;
  v4 = 1 << v2;
  if ( (unsigned int)dword_180091480 <= 5
    || (qword_180091490 & 0x400000000000i64) == 0
    || (qword_180091498 & 0x400000000000i64) != qword_180091498 )
  {
    return;
  }
  v5 = *((unsigned __int16 *)this + 892);
  v6 = *((unsigned __int16 *)this + 788);
  v7 = (const WCHAR *)((char *)this + 664);
  v70 = *((_DWORD *)this + 395);
  v71 = *((_DWORD *)this + 11);
  v72 = *((_DWORD *)this + 28);
  v64 = *((_BYTE *)this + 108);
  v73 = *((_DWORD *)this + 26);
  v74 = *((_DWORD *)this + 15);
  v75 = *((_DWORD *)this + 14);
  v76 = *((_DWORD *)this + 13);
  v77 = *((_DWORD *)this + 12);
  v78 = *((_DWORD *)this + 10);
  v79 = *((_DWORD *)this + 9);
  v80 = *((_DWORD *)this + 18);
  v81 = *((_DWORD *)this + 17);
  v68 = *((_WORD *)this + 33);
  LOWORD(v69) = *((_WORD *)this + 32);
  v119[0] = *((_QWORD *)this + 16);
  v85 = *((_QWORD *)this + 15);
  v65 = *((_BYTE *)this + 24);
  v119[1] = (__int64)this + 1176;
  v120 = v6;
  v67 = v5;
  v121 = (__int64)this + 1584;
  v122 = v5;
  v123 = (__int64)this + 664;
  v82 = v3;
  v8 = v4 < 0 ? *((_QWORD *)this + 12) : 0i64;
  v86 = v8;
  v9 = (v4 & 0x4000) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v87 = v9;
  v10 = (v4 & 0x2000) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v88 = v10;
  v11 = (v4 & 0x1000) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v89 = v11;
  v12 = (v4 & 0x800) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v90 = v12;
  v13 = (v4 & 0x400) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v91 = v13;
  v14 = (v4 & 0x200) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v92 = v14;
  v15 = (v4 & 0x100) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v93 = v15;
  v16 = (v4 & 0x80u) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v94 = v16;
  v17 = (v4 & 0x40) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v95 = v17;
  v18 = (v4 & 0x20) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v96 = v18;
  v19 = (v4 & 0x10) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v97 = v19;
  v20 = (v4 & 8) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v98 = v20;
  v21 = (v4 & 4) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v99 = v21;
  v22 = (v4 & 2) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v100 = v22;
  v23 = (v4 & 1) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v101 = v23;
  v118 = 1i64;
  v179 = 4i64;
  v102 = (unsigned __int16)v4 & 0x8000;
  v174 = 2i64;
  v103 = v4 & 0x4000;
  v175 = (__int64)this + 1176;
  v104 = v4 & 0x2000;
  v177 = 0;
  v105 = v4 & 0x1000;
  v172 = 4i64;
  v106 = v4 & 0x800;
  v170 = 4i64;
  v107 = v4 & 0x400;
  v168 = 1i64;
  v108 = v4 & 0x200;
  v166 = 4i64;
  v109 = v4 & 0x100;
  v164 = 4i64;
  v110 = (unsigned __int8)v4 & 0x80;
  v162 = 4i64;
  v111 = v4 & 0x40;
  v112 = v4 & 0x20;
  v113 = v4 & 0x10;
  v114 = v4 & 8;
  v115 = v4 & 4;
  v116 = v4 & 2;
  v178 = &v70;
  v173 = &v120;
  v176 = 4 * v6;
  v171 = &v71;
  v169 = &v72;
  v167 = &v64;
  v165 = &v73;
  v163 = &v74;
  v161 = &v75;
  v159 = &v76;
  v117 = v4 & 1;
  v160 = 4i64;
  v157 = &v77;
  v155 = &v78;
  v153 = &v79;
  v151 = &v67;
  v146 = &v122;
  v149 = 4 * v5;
  v144 = &v80;
  v142 = &v81;
  v140 = &v68;
  v138 = &v69;
  v136 = v119;
  v134 = &v85;
  v132 = &v65;
  v158 = 4i64;
  v156 = 4i64;
  v154 = 4i64;
  v152 = 2i64;
  v147 = 2i64;
  v148 = (__int64)this + 1584;
  v150 = 0;
  v145 = 4i64;
  v143 = 4i64;
  v141 = 2i64;
  v139 = 2i64;
  v137 = 8i64;
  v135 = 8i64;
  v133 = 1i64;
  if ( this == (CSchannelTelemetryContext *)-664i64 )
  {
    v7 = &Class;
    v26 = 2;
  }
  else
  {
    v24 = -1i64;
    while ( v7[++v24] != 0 )
      ;
    v26 = 2 * v24 + 2;
  }
  v129[67] = (__int64)v7;
  v129[65] = (__int64)&v82;
  v129[63] = (__int64)&v86;
  v129[61] = (__int64)&v87;
  v129[59] = (__int64)&v88;
  v129[57] = (__int64)&v89;
  v129[55] = (__int64)&v90;
  v129[53] = (__int64)&v91;
  v129[51] = (__int64)&v92;
  v129[49] = (__int64)&v93;
  v129[47] = (__int64)&v94;
  v129[45] = (__int64)&v95;
  v129[43] = (__int64)&v96;
  v129[41] = (__int64)&v97;
  v129[39] = (__int64)&v98;
  v129[37] = (__int64)&v99;
  v129[35] = (__int64)&v100;
  v129[33] = (__int64)&v101;
  v129[31] = (__int64)&v102;
  v129[29] = (__int64)&v103;
  v129[27] = (__int64)&v104;
  v129[25] = (__int64)&v105;
  v129[23] = (__int64)&v106;
  v129[21] = (__int64)&v107;
  v129[19] = (__int64)&v108;
  v129[17] = (__int64)&v109;
  v129[15] = (__int64)&v110;
  v130 = v26;
  v131 = 0;
  v129[66] = 4i64;
  v129[64] = 8i64;
  v129[62] = 8i64;
  v129[60] = 8i64;
  v129[58] = 8i64;
  v129[56] = 8i64;
  v129[54] = 8i64;
  v129[52] = 8i64;
  v129[50] = 8i64;
  v129[48] = 8i64;
  v129[46] = 8i64;
  v129[44] = 8i64;
  v129[42] = 8i64;
  v129[40] = 8i64;
  v129[38] = 8i64;
  v129[36] = 8i64;
  v129[34] = 8i64;
  v129[32] = 8i64;
  v129[30] = 8i64;
  v129[28] = 8i64;
  v129[26] = 8i64;
  v129[24] = 8i64;
  v129[22] = 8i64;
  v129[20] = 8i64;
  v129[18] = 8i64;
  v129[16] = 8i64;
  v129[14] = 8i64;
  v129[13] = (__int64)&v111;
  v129[12] = 8i64;
  v129[11] = (__int64)&v112;
  v129[9] = (__int64)&v113;
  v129[7] = (__int64)&v114;
  v129[5] = (__int64)&v115;
  v129[3] = (__int64)&v116;
  v129[1] = (__int64)&v117;
  v128 = &v118;
  *(_DWORD *)&EventDescriptor.Level = 5;
  UserData.Ptr = (ULONGLONG)off_180091488;
  v129[10] = 8i64;
  v129[8] = 8i64;
  v129[6] = 8i64;
  v129[4] = 8i64;
  v129[2] = 8i64;
  v129[0] = 8i64;
  *(_DWORD *)&EventDescriptor.Id = 184549376;
  EventDescriptor.Keyword = 0x400000000000i64;
  UserData.Size = *(unsigned __int16 *)off_180091488;
  Buf1 = &unk_180083F6C;
  UserData.Reserved = 2;
  v126 = 1137;
  v127 = 1;
  LODWORD(v66) = (unsigned int)&TraceLoggingMetadataEnd - (unsigned int)&TraceLoggingMetadata;
  if ( (void (__fastcall *)(const struct _GUID *, unsigned int, __int64, __int64, unsigned __int64, struct _EVENT_FILTER_DESCRIPTOR *, _QWORD *))qword_1800914A8 != TlgAggregateInternalRegisteredProviderEtwCallback )
    return;
  v27 = 0;
  v28 = (char *)&unk_180083F6E;
  do
    v29 = *v28++;
  while ( v29 < 0 );
  while ( *v28++ )
    ;
  if ( v28 >= (char *)&unk_1800843DD )
    goto LABEL_117;
  while ( 1 )
  {
    while ( *v28++ )
      ;
    if ( *v28 >= 0 )
      break;
    v32 = v28[1];
    v33 = *v28 & 0x7F;
    v28 += 2;
    if ( v32 >= 0 )
      break;
    v34 = *v28;
    if ( *v28 < 0 )
    {
      while ( v34 == (char)0x80 )
      {
        v34 = *++v28;
        if ( v34 >= 0 )
          goto LABEL_51;
      }
      break;
    }
LABEL_51:
    if ( v33 == 9 && (unsigned __int8)(v34 - 113) <= 2u )
    {
      v35 = v27++;
      BYTE5(v129[2 * v35]) = v34;
      if ( v28 < (char *)&unk_1800843DD )
        continue;
    }
    break;
  }
  if ( !v27 )
  {
LABEL_117:
    EventWriteTransfer_0(RegHandle, &EventDescriptor, 0i64, 0i64, 0x3Cu, &UserData);
    return;
  }
  v36 = 0i64;
  v37 = qword_1800914B0;
  v66 = 0i64;
  v83 = qword_1800914B0;
  v38 = 1025
      * (BYTE4(Buf1)
       + ((1025
         * (BYTE3(Buf1)
          + ((1025
            * (BYTE2(Buf1)
             + ((1025
               * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) ^ ((1025 * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) >> 6)))) ^ ((1025 * (BYTE2(Buf1) + ((1025 * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) ^ ((1025 * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) >> 6)))) >> 6)))) ^ ((1025 * (BYTE3(Buf1) + ((1025 * (BYTE2(Buf1) + ((1025 * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) ^ ((1025 * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) >> 6)))) ^ ((1025 * (BYTE2(Buf1) + ((1025 * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) ^ ((1025 * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) >> 6)))) >> 6)))) >> 6)));
  v39 = 1025 * (BYTE5(Buf1) + (v38 ^ (v38 >> 6)));
  v40 = 1025 * (BYTE6(Buf1) + (v39 ^ (v39 >> 6)));
  v41 = v27 + 2;
  v42 = ((1025 * (HIBYTE(Buf1) + (v40 ^ (v40 >> 6)))) >> 6) ^ (1025 * (HIBYTE(Buf1) + (v40 ^ (v40 >> 6))));
  if ( (unsigned __int8)(v27 + 2) < 0x3Cu )
  {
    v43 = &UserData + v41;
    v44 = (unsigned __int8)(60 - v41);
    do
    {
      for ( i = 0i64; i < v43->Size; v42 = ((1025 * (v42 + v46)) >> 6) ^ (1025 * (v42 + v46)) )
      {
        v46 = *(unsigned __int8 *)(i + v43->Ptr);
        ++i;
      }
      ++v43;
      --v44;
    }
    while ( v44 );
  }
  v47 = (RTL_SRWLOCK *)(qword_1800914B0 + 264);
  v48 = 32769 * ((9 * v42) ^ ((9 * v42) >> 11));
  AcquireSRWLockShared((PSRWLOCK)(qword_1800914B0 + 264));
  for ( j = (volatile signed __int64 *)(v37 + 8i64 * (v48 & 0x1F));
        ;
        j = (volatile signed __int64 *)((((__int64)v53 >> 63) & 0xFFFFFFFFFFFFFFF8ui64) + v50 + 32) )
  {
    if ( !*j )
    {
      if ( *(_DWORD *)(v37 + 256) >= 0x400u )
      {
        ++*(_DWORD *)(v37 + 300);
        goto LABEL_74;
      }
      if ( !v36 )
      {
        v60 = CreateNewEventEntry((__int128 *)&EventDescriptor, 0x3Cu, (__int64)&UserData, v27, v48, &v66);
        v36 = v66;
        if ( !v66 )
        {
          if ( v60 == 8 )
            ++*(_DWORD *)(v37 + 304);
          else
            ++*(_DWORD *)(v37 + 308);
          goto LABEL_74;
        }
      }
      if ( !_InterlockedCompareExchange64(j, v36, 0i64) )
      {
        v66 = 0i64;
        if ( _InterlockedIncrement((volatile signed __int32 *)(v37 + 256)) == 1 )
          EnableFlushTimer(*(struct _TP_TIMER **)(v37 + 344), *(_DWORD *)(v37 + 352));
        v61 = *(_DWORD *)(v37 + 256);
        v36 = v66;
        if ( *(_DWORD *)(v37 + 288) < v61 )
          *(_DWORD *)(v37 + 288) = v61;
        goto LABEL_74;
      }
      v36 = v66;
    }
    v50 = *j;
    v51 = *(_DWORD *)(v50 + 40);
    if ( v48 != v51 )
    {
      v53 = v48 - v51;
      continue;
    }
    v52 = *(_QWORD *)(v50 + 16);
    v53 = memcmp_0(&Buf1, (const void *)(v52 + 16), 8ui64);
    if ( v53 )
      continue;
    v54 = *(unsigned __int8 *)(v50 + 45) + 2;
    if ( v54 >= 0x3C )
      break;
    while ( 1 )
    {
      v53 = *(&UserData.Size + 4 * v54) - *(_DWORD *)(v52 + 16i64 * v54 + 8);
      if ( v53 )
        break;
      v53 = memcmp_0(
              *((const void **)&UserData.Ptr + 2 * v54),
              *(const void **)(v52 + 16i64 * v54),
              *(&UserData.Size + 4 * v54));
      if ( v53 )
        break;
      if ( ++v54 >= 0x3C )
        goto LABEL_68;
    }
    v37 = v83;
  }
LABEL_68:
  if ( v50 )
  {
    v55 = 2;
    do
    {
      v56 = **((_QWORD **)&UserData.Ptr + 2 * v55);
      v57 = *(_QWORD *)(v50 + 16);
      v58 = *(unsigned __int8 *)(v57 + 16i64 * v55 + 13);
      v59 = *(volatile signed __int64 **)(v57 + 16i64 * v55);
      if ( v58 == 113 )
      {
        _InterlockedExchangeAdd64(v59, v56);
      }
      else if ( (unsigned int)(v58 - 114) <= 1 )
      {
        do
        {
          v62 = *v59;
          if ( (_BYTE)v58 == 114 )
          {
            if ( v56 >= v62 )
              break;
          }
          else if ( v56 <= v62 )
          {
            break;
          }
          v63 = *v59;
        }
        while ( v63 != _InterlockedCompareExchange64(v59, v56, v62) );
      }
      ++v55;
    }
    while ( v55 < (unsigned int)v27 + 2 );
    v36 = v66;
  }
LABEL_74:
  ReleaseSRWLockShared(v47);
  if ( v36 )
    DestroyEventEntry(v36);
}
// 1800220DF: conditional instruction was optimized away because bl.1!=0
// 180091488: using guessed type void *off_180091488;
// 180091490: using guessed type __int64 qword_180091490;
// 180091498: using guessed type __int64 qword_180091498;
// 1800914A8: using guessed type __int64 qword_1800914A8;
// 1800914B0: using guessed type __int64 qword_1800914B0;

//----- (0000000180022240) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::TlsParseClientHello(
        CTls13ServerContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int8 *const a4,
        unsigned int *a5,
        unsigned int **a6,
        unsigned int *a7)
{
  return CTls13ServerHandshake::ParseClientHello((CTls13ServerContext *)((char *)this + 1288), a2, a3, a4, a5, a6, a7);
}

//----- (0000000180022260) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::ParseClientHello(
        CTls13ServerHandshake *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int8 *const a4,
        unsigned int *a5,
        unsigned int **a6,
        unsigned int *a7)
{
  CTls13ServerHandshake *v7; // r11
  unsigned int v10; // r13d
  __int64 v12; // rcx
  bool v13; // r14
  const void **v14; // r10
  unsigned int *v15; // r8
  unsigned int v16; // edi
  unsigned int v17; // edi
  SIZE_T v18; // rsi
  unsigned __int8 *v19; // rbx
  unsigned int v20; // edi
  size_t v21; // r14
  unsigned __int16 *v22; // rbx
  unsigned int v23; // edi
  unsigned __int16 *v24; // r15
  unsigned __int16 v25; // bp
  unsigned __int8 *v26; // rbx
  unsigned int v27; // edi
  unsigned __int16 v28; // si
  unsigned int v29; // r12d
  _DWORD *v30; // r9
  _DWORD *v31; // rdx
  int v32; // eax
  int v33; // ecx
  unsigned int v34; // ebx
  __int64 v35; // rsi
  unsigned int v36; // edi
  char *v37; // rcx
  __int64 v38; // rdx
  unsigned int v39; // edi
  char *v40; // r9
  unsigned int v41; // edi
  unsigned int v42; // ebx
  __int64 v43; // r12
  char *v44; // rdi
  unsigned __int8 v45; // r14
  __int64 v46; // rax
  char v47; // r15
  CCipherMill *v48; // r10
  unsigned __int16 v49; // si
  unsigned int v50; // ebp
  unsigned int *v51; // rdi
  unsigned int v52; // ebx
  unsigned int v53; // eax
  unsigned __int8 v55; // r9
  int v56; // edx
  __int64 v57; // rax
  unsigned int v58; // edi
  unsigned int *Memory; // [rsp+30h] [rbp-48h]
  unsigned int v61; // [rsp+88h] [rbp+10h]

  v7 = this;
  v10 = 0;
  v12 = *((_QWORD *)this + 1);
  v13 = *(_DWORD *)(v12 + 68) == 71;
  if ( !a2 )
    return 87i64;
  if ( !a3 )
    return 87i64;
  if ( !a5 )
    return 87i64;
  v14 = (const void **)a6;
  if ( !a6 )
    return 87i64;
  v15 = a7;
  if ( !a7 )
    return 87i64;
  if ( a3 < 2 )
  {
    v10 = -2146893048;
    goto LABEL_66;
  }
  if ( (a2[1] | (*a2 << 8)) < 0x300u )
  {
    v55 = 70;
    v56 = 1201;
LABEL_64:
    CSslContext::SetErrorAndFatalAlert(v12, v56, -2146893048, v55);
    v10 = -2146893048;
    goto LABEL_65;
  }
  v16 = a3 - 2;
  if ( v16 < 0x20 )
    goto LABEL_62;
  if ( *(_DWORD *)(v12 + 68) == 71 )
  {
    if ( RtlCompareMemory(a2 + 2, (const void *)(v12 + 272), 0x20ui64) != 32 )
      goto LABEL_72;
    v7 = this;
    v15 = a7;
    v14 = (const void **)a6;
  }
  else
  {
    *(_OWORD *)(v12 + 272) = *(_OWORD *)(a2 + 2);
    *(_OWORD *)(v12 + 288) = *(_OWORD *)(a2 + 18);
  }
  v17 = v16 - 32;
  if ( !v17 || (v18 = a2[34], (unsigned __int8)v18 > 0x20u) || (v19 = a2 + 35, v20 = v17 - 1, v20 < (unsigned int)v18) )
  {
    v12 = *((_QWORD *)v7 + 1);
    goto LABEL_62;
  }
  if ( v13 )
  {
    v12 = *((_QWORD *)v7 + 1);
    if ( *(_BYTE *)(v12 + 1281) != (_BYTE)v18 )
    {
      v55 = 47;
      goto LABEL_63;
    }
  }
  if ( (_BYTE)v18 )
  {
    if ( !v13 )
    {
      v21 = v18;
LABEL_18:
      memcpy_0(a4, v19, v21);
      v7 = this;
      v15 = a7;
      v14 = (const void **)a6;
      goto LABEL_19;
    }
    if ( *((_QWORD *)v7 + 1) == -1249i64 )
    {
      v10 = -2146893052;
      goto LABEL_66;
    }
    v21 = v18;
    if ( RtlCompareMemory(v19, (const void *)(*((_QWORD *)v7 + 1) + 1249i64), v18) == v18 )
      goto LABEL_18;
LABEL_72:
    v55 = 47;
    v12 = *((_QWORD *)this + 1);
    goto LABEL_63;
  }
LABEL_19:
  *a5 = v18;
  v22 = (unsigned __int16 *)&v19[v18];
  v12 = *((_QWORD *)v7 + 1);
  v23 = v20 - v18;
  if ( *(_BYTE *)(v12 + 233) )
  {
    if ( !v23 )
      goto LABEL_62;
    v57 = *(unsigned __int8 *)v22;
    if ( (unsigned __int8)v57 > 0x20u )
      goto LABEL_62;
    v58 = v23 - 1;
    if ( v58 < (unsigned int)v57 )
      goto LABEL_62;
    v22 = (unsigned __int16 *)((char *)v22 + v57 + 1);
    v23 = v58 - v57;
  }
  v24 = v22;
  if ( v23 < 2
    || (v25 = _byteswap_ushort(*v22), v25 < 2u)
    || (v25 & 1) != 0
    || (v26 = (unsigned __int8 *)(v22 + 1), v27 = v23 - 2, v27 < v25) )
  {
LABEL_62:
    v55 = 50;
LABEL_63:
    v56 = 1200;
    goto LABEL_64;
  }
  v28 = v25 >> 1;
  v29 = v25 >> 1;
  v61 = v29;
  if ( v29 > *v15 )
  {
    Memory = (unsigned int *)CSslContext::GetMemory((CSslContext *)v12, 4 * (unsigned int)v28);
    v30 = Memory;
    if ( !Memory )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_d(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x1Fu,
          (__int64)WPP_922678f99ae534148d3bb024010f1556_Traceguids,
          4 * v29);
      v10 = 14;
      goto LABEL_65;
    }
    v7 = this;
    v14 = (const void **)a6;
  }
  else
  {
    v30 = *v14;
    Memory = (unsigned int *)*v14;
  }
  if ( v28 )
  {
    v31 = v30;
    v15 = (unsigned int *)(v25 >> 1);
    do
    {
      v32 = *v26;
      ++v31;
      v33 = v26[1];
      v26 += 2;
      *(v31 - 1) = (v32 << 8) | v33;
      v15 = (unsigned int *)((char *)v15 - 1);
    }
    while ( v15 );
  }
  v34 = v25 >> 1;
  v35 = *(_QWORD *)(*((_QWORD *)v7 + 1) + 120i64);
  if ( v35 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
  {
    *(_DWORD *)(v35 + 1580) = v29;
    if ( v29 > 0x64 )
      v34 = 100;
    memcpy_0((void *)(v35 + 1176), v30, 4i64 * v34);
    v7 = this;
    v14 = (const void **)a6;
    *(_WORD *)(v35 + 1576) = v34;
  }
  v36 = v27 - v25;
  v37 = (char *)v24 + v25;
  if ( !v36 )
    goto LABEL_83;
  v38 = (unsigned __int8)v37[2];
  if ( !(_BYTE)v38 )
  {
    v10 = -2146893048;
    goto LABEL_100;
  }
  v39 = v36 - 1;
  if ( v39 < (unsigned int)v38 )
    goto LABEL_83;
  v40 = v37 + 3;
  if ( v37[3] )
  {
    while ( v40 != &v37[v38 + 2] )
    {
      if ( !*++v40 )
        goto LABEL_38;
    }
LABEL_83:
    CSslContext::SetErrorAndFatalAlert(*((_QWORD *)v7 + 1), 1200, -2146893048, 0x32u);
    v10 = -2146893048;
    goto LABEL_99;
  }
LABEL_38:
  v41 = v39 - v38;
  if ( v41 < 2 )
    goto LABEL_54;
  v42 = (unsigned __int8)v37[v38 + 4] | ((unsigned __int8)v37[v38 + 3] << 8);
  if ( v41 < v42 )
    goto LABEL_54;
  v43 = *((_QWORD *)v7 + 2);
  v44 = &v37[v38 + 5];
  v45 = 0;
  v46 = *(_QWORD *)(v43 + 8);
  v47 = *(_BYTE *)(v46 + 64) & 0x30;
  *(_DWORD *)(v43 + 16) = 1;
  *(_BYTE *)(v46 + 922) = 0;
  *(_BYTE *)(v43 + 27) = 0;
  if ( !v42 )
  {
LABEL_52:
    (*(void (__fastcall **)(_QWORD, _QWORD, unsigned int *, char *))(**(_QWORD **)(v43 + 8) + 352i64))(
      *(_QWORD *)(v43 + 8),
      v45,
      v15,
      v40);
    v10 = 0;
LABEL_53:
    v29 = v61;
LABEL_54:
    v15 = a7;
    *a6 = Memory;
    goto LABEL_55;
  }
  v48 = WPP_GLOBAL_Control;
  while ( 1 )
  {
    if ( v42 < 4 )
      goto LABEL_96;
    v49 = _byteswap_ushort(*((_WORD *)v44 + 1));
    v50 = (unsigned __int8)v44[1] | ((unsigned __int8)*v44 << 8);
    if ( v48 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v48 + 28) & 4) != 0 )
    {
      WPP_SF_D(*((_QWORD *)v48 + 2), 73i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids, v50);
      v48 = WPP_GLOBAL_Control;
    }
    v51 = (unsigned int *)(v44 + 4);
    v52 = v42 - 4;
    if ( v52 < v49 )
    {
      if ( v48 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v48 + 28) & 2) != 0 )
        WPP_SF_(*((_QWORD *)v48 + 2), 74i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
LABEL_96:
      v10 = -2146893018;
LABEL_97:
      CSslContext::SetErrorAndFatalAlert(*((_QWORD *)this + 1), 1200, -2146893048, 0x32u);
      goto LABEL_98;
    }
    v15 = v51;
    v44 = (char *)v51 + v49;
    v42 = v52 - v49;
    if ( v47 && v50 != 65281 )
      goto LABEL_51;
    v53 = (*(__int64 (__fastcall **)(__int64, _QWORD, unsigned int *, _QWORD))(*(_QWORD *)v43 + 8i64))(
            v43,
            v50,
            v15,
            v49);
    v10 = v53;
    if ( v53 )
      break;
    v48 = WPP_GLOBAL_Control;
    if ( v50 == 65281 )
      v45 = 1;
LABEL_51:
    if ( !v42 )
      goto LABEL_52;
  }
  if ( v53 != -2146892986 && v53 != -2146892953 )
    goto LABEL_97;
LABEL_98:
  if ( !v10 )
    goto LABEL_53;
LABEL_99:
  v14 = (const void **)a6;
  v7 = this;
LABEL_100:
  if ( Memory && Memory != *v14 )
    (*(void (__fastcall **)(_QWORD))(**((_QWORD **)v7 + 1) + 16i64))(*((_QWORD *)v7 + 1));
LABEL_65:
  v15 = a7;
LABEL_66:
  v29 = 0;
LABEL_55:
  *v15 = v29;
  return v10;
}
// 18002260E: variable 'v15' is possibly undefined
// 18002260E: variable 'v40' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180022670) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::ProcessRecord(__int64 a1, int a2, unsigned __int8 *a3, unsigned int a4)
{
  char v4; // al
  unsigned int v5; // ebp
  unsigned __int8 *v6; // r14
  __int64 v8; // rbx
  unsigned int v9; // esi
  __int64 v10; // rax
  bool v11; // cl
  int v12; // edi
  __int64 v13; // rdi
  unsigned int v14; // eax
  unsigned int v15; // eax
  int v17; // eax
  __int64 v18; // rcx
  char v19; // al
  int v20; // eax
  __int64 v21; // r10
  unsigned int v22; // eax
  unsigned int v23; // r9d
  CTlsMessageFragment *v24; // rcx
  unsigned int v25; // eax
  _QWORD *Memory; // rax
  CCipherMill *v27; // rcx
  bool v28; // zf
  CCipherMill *v29; // rcx
  bool v30; // zf
  int v31; // edx
  unsigned int v32; // eax
  int v33; // eax
  unsigned int *v34; // [rsp+20h] [rbp-48h]
  __int64 v35; // [rsp+28h] [rbp-40h]
  unsigned int v36; // [rsp+70h] [rbp+8h] BYREF
  unsigned __int8 v37; // [rsp+78h] [rbp+10h] BYREF

  v4 = *(_BYTE *)(a1 + 233);
  v5 = a4;
  v6 = a3;
  v8 = a1;
  v9 = -2146893018;
  if ( v4 )
    v9 = 590610;
  if ( a2 == 20 )
  {
    v17 = *(_DWORD *)(a1 + 68);
    if ( v17 == 61 )
    {
      if ( (*(_DWORD *)(a1 + 136) & 0x100i64) != 0 && !*(_BYTE *)(a1 + 552) )
        return (unsigned int)-2146893018;
    }
    else if ( ((v17 - 62) & 0xFFFFFFFD) != 0 )
    {
      return v9;
    }
    if ( a4 == 1 && *a3 == 1 )
    {
      *(_WORD *)(a1 + 32) |= 0xAu;
      v18 = *(_QWORD *)(a1 + 144);
      if ( v18 )
        SslFreeObject(v18, 0i64);
      *(_QWORD *)(v8 + 144) = *(_QWORD *)(v8 + 160);
      v19 = *(_BYTE *)(v8 + 233);
      *(_QWORD *)(v8 + 160) = 0i64;
      if ( !v19 )
        *(_QWORD *)(v8 + 176) = 0i64;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 60i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        v19 = *(_BYTE *)(v8 + 233);
      }
      if ( v19 )
      {
        ++*(_DWORD *)(v8 + 192);
        *(_QWORD *)(v8 + 208) = 0i64;
        *(_QWORD *)(v8 + 200) = 0i64;
      }
      v20 = 63;
      v9 = 0;
      if ( *(_DWORD *)(v8 + 68) == 64 )
        v20 = 65;
      *(_DWORD *)(v8 + 68) = v20;
      return v9;
    }
    v31 = 904;
    goto LABEL_112;
  }
  if ( v4 )
    return (unsigned int)CSsl3TlsContext::DtlsProcessRecord(a1, a2, a3, a4);
  v10 = *(_QWORD *)(a1 + 464);
  v11 = 1;
  v36 = 0;
  if ( v10 && *(_DWORD *)(v10 + 36) )
  {
    if ( a2 == 22 )
    {
      v9 = CTlsMessageFragment::SaveFragment((CTlsMessageFragment *)v10, a3, a4, 0, &v36);
      if ( v9 )
        return v9;
      v21 = *(_QWORD *)(v8 + 464);
      v22 = 12;
      v23 = *(_DWORD *)(v21 + 32);
      if ( !*(_DWORD *)(v21 + 40) )
        v22 = 4;
      if ( (v23 <= v22 || *(_DWORD *)(v21 + 36) < v23)
        && (*(_DWORD *)(v21 + 36) < v22
         || *(unsigned __int8 *)(*(_QWORD *)(v21 + 24) + 3i64)
          + (*(unsigned __int8 *)(*(_QWORD *)(v21 + 24) + 1i64) << 16)
          + (*(unsigned __int8 *)(*(_QWORD *)(v21 + 24) + 2i64) << 8)) )
      {
        return 0;
      }
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_d(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x45u,
          (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
          v23);
        v21 = *(_QWORD *)(v8 + 464);
      }
      v9 = CSsl3TlsContext::ProcessHandshakeCommon(
             (CSsl3TlsContext *)v8,
             *(unsigned __int8 **)(v21 + 24),
             *(_DWORD *)(v21 + 32));
      if ( v9 )
        return v9;
      *(_QWORD *)(*(_QWORD *)(v8 + 464) + 32i64) = 0i64;
      v6 += v36;
      v5 -= v36;
      v11 = v5 != 0;
    }
    else if ( a2 == 21 )
    {
      *(_QWORD *)(v10 + 32) = 0i64;
    }
    v9 = 0;
    if ( !v11 )
      return v9;
  }
  v12 = a2 - 21;
  if ( !v12 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 57i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    v33 = TlsParseAlertMessage(v6, v5, (unsigned __int8 *)(v8 + 473), &v37);
    v9 = v33;
    if ( !v33 )
    {
      if ( v37 )
      {
        *(_BYTE *)(v8 + 552) = 1;
        *(_DWORD *)(v8 + 68) = 75;
      }
      return v9;
    }
    if ( v33 == -2146892953 || *(_DWORD *)(v8 + 36) < 0x302u || (*(_DWORD *)(v8 + 64) & 0x800A00AA) == 0 )
    {
      if ( v5 == 2 )
        LogReceiveAlertEvent(
          *(_DWORD *)(*(_QWORD *)(v8 + 80) + 212i64),
          (const unsigned __int16 *)(*(_QWORD *)(v8 + 80) + 216i64),
          *v6,
          v6[1]);
      return v9;
    }
    CSslContext::SetError(v8, 14, v33);
    return (unsigned int)-2146893018;
  }
  if ( v12 != 1 )
    return 0;
  while ( 1 )
  {
    if ( v5 < 4 )
    {
      v24 = *(CTlsMessageFragment **)(v8 + 464);
      if ( v24 )
        goto LABEL_96;
      if ( (*(_DWORD *)(v8 + 64) & 0x40051555) != 0 )
      {
        if ( (*(_DWORD *)(v8 + 136) & 0x100i64) != 0 )
        {
          v32 = CSslGlobals::m_dwTlsMessageLimitSrvClientAuth;
          if ( CSslGlobals::m_dwTlsMessageLimitSrv > CSslGlobals::m_dwTlsMessageLimitSrvClientAuth )
            v32 = CSslGlobals::m_dwTlsMessageLimitSrv;
          if ( !v32 )
            goto LABEL_75;
        }
        if ( !CSslGlobals::m_dwTlsMessageLimitSrv )
          goto LABEL_75;
      }
      else if ( !CSslGlobals::m_dwTlsMessageLimitClient )
      {
LABEL_75:
        v29 = WPP_GLOBAL_Control;
        v30 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
LABEL_76:
        if ( !v30 && (*((_BYTE *)v29 + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)v29 + 2), 67i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        v31 = 12;
        a1 = v8;
LABEL_112:
        CSslContext::SetErrorAndFatalAlert(a1, v31, -2146893018, 0xAu);
        return (unsigned int)-2146893018;
      }
      Memory = CSslContext::GetMemory((CSslContext *)v8, 0x30u);
      if ( !Memory )
      {
        v27 = WPP_GLOBAL_Control;
        v28 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
        goto LABEL_81;
      }
      goto LABEL_95;
    }
    v13 = v6[3] + (v6[1] << 16) + (v6[2] << 8);
    if ( v13 + 4 > (unsigned __int64)v5 )
      break;
    v36 = 0;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      LODWORD(v35) = *(_DWORD *)(v8 + 68);
      LODWORD(v34) = *v6;
      WPP_SF_DDD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x3Au,
        (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
        *(_DWORD *)(v8 + 64),
        v34,
        v35);
    }
    v14 = (*(__int64 (__fastcall **)(__int64, unsigned __int8 *, _QWORD, unsigned int *))(*(_QWORD *)v8 + 416i64))(
            v8,
            v6,
            (unsigned int)(v13 + 4),
            &v36);
    v9 = v14;
    if ( (!v14 || v14 == 590624) && !*(_DWORD *)(v8 + 872) && !v36 )
    {
      v15 = (*(__int64 (__fastcall **)(__int64, unsigned __int8 *, _QWORD, _QWORD))(*(_QWORD *)v8 + 504i64))(
              v8,
              v6,
              (unsigned int)(v13 + 4),
              0i64);
      if ( v15 )
        v9 = v15;
    }
    if ( *(_BYTE *)(v8 + 923) )
    {
      v9 = 590610;
      *(_DWORD *)(v8 + 72) = *(_DWORD *)(v8 + 68);
      *(_DWORD *)(v8 + 68) = 77;
      return v9;
    }
    if ( v9 == 590624 )
    {
      *(_BYTE *)(v8 + 924) = 1;
      return v9;
    }
    if ( !v9 )
    {
      v6 += v13 + 4;
      v5 += -4 - v13;
      if ( v5 )
        continue;
    }
    return v9;
  }
  v24 = *(CTlsMessageFragment **)(v8 + 464);
  if ( v24 )
  {
LABEL_96:
    v36 = 0;
    return (unsigned int)CTlsMessageFragment::SaveFragment(v24, v6, v5, 1, &v36);
  }
  if ( (*(_DWORD *)(v8 + 64) & 0x40051555) == 0 )
  {
    if ( CSslGlobals::m_dwTlsMessageLimitClient )
      goto LABEL_71;
    goto LABEL_74;
  }
  if ( (*(_DWORD *)(v8 + 136) & 0x100i64) != 0 )
  {
    v25 = CSslGlobals::m_dwTlsMessageLimitSrvClientAuth;
    if ( CSslGlobals::m_dwTlsMessageLimitSrv > CSslGlobals::m_dwTlsMessageLimitSrvClientAuth )
      v25 = CSslGlobals::m_dwTlsMessageLimitSrv;
    if ( !v25 )
      goto LABEL_74;
  }
  if ( !CSslGlobals::m_dwTlsMessageLimitSrv )
  {
LABEL_74:
    v29 = WPP_GLOBAL_Control;
    v30 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
    goto LABEL_76;
  }
LABEL_71:
  Memory = CSslContext::GetMemory((CSslContext *)v8, 0x30u);
  if ( Memory )
  {
LABEL_95:
    *Memory = 0i64;
    *(_QWORD *)((char *)Memory + 12) = 256i64;
    Memory[3] = 0i64;
    Memory[4] = 0i64;
    *(_QWORD *)(v8 + 464) = Memory;
    CTlsMessageFragment::Initialize((CTlsMessageFragment *)Memory, (struct CSsl3TlsContext *)v8);
    v24 = *(CTlsMessageFragment **)(v8 + 464);
    goto LABEL_96;
  }
  v27 = WPP_GLOBAL_Control;
  v28 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
LABEL_81:
  if ( !v28 && (*((_BYTE *)v27 + 28) & 1) != 0 )
    WPP_SF_(*((_QWORD *)v27 + 2), 68i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
  return 14;
}
// 18003F865: variable 'v34' is possibly undefined
// 18003F865: variable 'v35' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (00000001800228D0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::LookupEccCurveType(CSsl3TlsServerContext *this, int a2)
{
  unsigned __int16 *v2; // rax
  __int64 v3; // r9
  unsigned __int16 *v4; // r8

  v2 = (unsigned __int16 *)*((_QWORD *)this + 114);
  v3 = *((unsigned __int16 *)this + 460);
  v4 = &v2[v3];
  if ( v2 < v4 )
  {
    while ( *v2 != a2 )
    {
      if ( ++v2 >= v4 )
        goto LABEL_6;
    }
    return 0i64;
  }
LABEL_6:
  if ( !(_WORD)v3 )
    return 0i64;
  return 50i64;
}

//----- (0000000180022910) ----------------------------------------------------
void __fastcall CSsl3TlsServerContext::SetStateConnected(CSsl3TlsServerContext *this)
{
  __int64 v1; // rax
  __int64 v3; // rcx
  DWORD v4; // edi
  DWORD v5; // ebp
  LARGE_INTEGER v6; // r14
  bool v7; // r9
  __int64 v8; // rax
  __int64 v9; // r11
  int v10; // r10d
  LARGE_INTEGER *v11; // rbx
  LARGE_INTEGER *v12; // r11
  __int64 v13; // r8
  __int64 v14; // rdx
  bool v15; // zf
  unsigned __int16 v16; // ax
  DTlsHandshakeQueue *v17; // rcx
  struct kexch *KeyExchangeInfo; // rax
  int v19; // r10d
  _DWORD *v20; // r11
  char v21[8]; // [rsp+A0h] [rbp-708h] BYREF
  DWORD v22; // [rsp+A8h] [rbp-700h]
  LONG v23; // [rsp+ACh] [rbp-6FCh]

  v1 = *(_QWORD *)this;
  *((_DWORD *)this + 17) = 4;
  (*(void (**)(void))(v1 + 456))();
  if ( *((_BYTE *)this + 233) )
  {
    v16 = CSslContext::computeMaxPayload(this, *((unsigned __int16 *)this + 108));
    v17 = (DTlsHandshakeQueue *)*((_QWORD *)this + 73);
    *((_WORD *)this + 109) = v16;
    DTlsHandshakeQueue::DtlsHandshakeDone(v17);
    **((_DWORD **)this + 72) = 0;
    *((_WORD *)this + 110) = 0;
  }
  memset_0(v21, 0, 0x6E8ui64);
  v3 = *((_QWORD *)this + 1);
  if ( v3 )
  {
    v4 = *(_DWORD *)(v3 + 28);
    v22 = v4;
  }
  else
  {
    v4 = 0;
    v22 = 0;
  }
  v5 = *((unsigned __int16 *)this + 17);
  v6 = *(LARGE_INTEGER *)((char *)this + 136);
  v7 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
  v23 = *((_DWORD *)this + 4);
  if ( v3 )
  {
    v8 = *((_QWORD *)this + 11);
    if ( v8 )
    {
      v9 = *((_QWORD *)this + 15);
      v10 = *(_DWORD *)(v3 + 32);
      if ( v9 )
      {
        if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
        {
          *(_DWORD *)(v9 + 48) = *(_DWORD *)(v8 + 8);
          if ( v10 == 43522 || v10 == 41984 )
          {
            KeyExchangeInfo = GetKeyExchangeInfo(v10);
            if ( KeyExchangeInfo )
            {
              v20[13] = *((_DWORD *)KeyExchangeInfo + 8);
              v20[14] = *((_DWORD *)KeyExchangeInfo + 10);
              if ( v19 == 43522 )
                v20[15] = *((_DWORD *)KeyExchangeInfo + 12);
            }
          }
        }
      }
    }
  }
  v11 = (LARGE_INTEGER *)*((_QWORD *)this + 15);
  v12 = v11;
  if ( v11 )
  {
    if ( !v7 )
      return;
    v11[4].HighPart = v23;
    v11[4].LowPart = v4;
    v11[5].LowPart = v5;
    v11[16] = v6;
    QueryPerformanceCounter(v11 + 11);
    v13 = 1000 * (v11[11].QuadPart - v11[10].QuadPart);
    v11[12].QuadPart = v13;
    if ( CSchannelTelemetryContext::m_liPerfCtrFreq.QuadPart == 10000000 )
      v14 = v13 / 10000000;
    else
      v14 = v13 / CSchannelTelemetryContext::m_liPerfCtrFreq.QuadPart;
    v15 = v11[13].LowPart == -2146893032;
    v11[12].QuadPart = v14;
    if ( v15 )
    {
      v11[13].LowPart = 0;
      v11[14].LowPart = 0;
    }
    CSchannelTelemetryContext::WriteEvent((CSchannelTelemetryContext *)v11, 0, v13);
    v12 = (LARGE_INTEGER *)*((_QWORD *)this + 15);
    v7 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
  }
  if ( v12
    && v7
    && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_SSSdiiDDDDDddiDDd(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      HIWORD(v12[8].u.LowPart),
      LOWORD(v12[8].LowPart),
      L"Server",
      (const wchar_t *)&v12[19],
      (const wchar_t *)&v12[83],
      v12[3].LowPart,
      v12[15].QuadPart,
      v12[16].QuadPart,
      v12[4].LowPart,
      v12[4].HighPart,
      v12[5].LowPart,
      v12[5].HighPart,
      v12[6].LowPart,
      v12[8].LowPart,
      HIWORD(v12[8].u.LowPart),
      v12[12].QuadPart,
      v12[13].LowPart,
      BYTE4(v12[13].QuadPart),
      v12[14].LowPart);
  }
}
// 1800229FF: variable 'v7' is possibly undefined
// 18003FBD5: variable 'v20' is possibly undefined
// 18003FBE7: variable 'v19' is possibly undefined
// 180082BC8: using guessed type wchar_t aServer_0[7];
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 180022910: using guessed type char var_708[8];

//----- (0000000180022B10) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::SetGenericExtensionBuffers(
        CTls13ServerContext *this,
        struct _SecBufferDesc *const a2,
        struct _SecBuffer *const a3)
{
  return CTls13Context::SetGenericExtensionBuffers((CTls13ServerContext *)((char *)this + 1000), a2, a3);
}

//----- (0000000180022B30) ----------------------------------------------------
__int64 __fastcall CTls13Context::SetGenericExtensionBuffers(
        CTls13Context *this,
        struct _SecBufferDesc *const a2,
        struct _SecBuffer *const a3)
{
  void *v6; // rax
  PSecBuffer pBuffers; // rdx
  int v8; // eax
  unsigned int v9; // edx
  unsigned int v11; // ecx
  _DWORD *pvBuffer; // rdi
  int v13; // r8d
  __int64 v14; // r9
  unsigned __int64 cbBuffer; // rcx
  _DWORD *v16; // r8
  __int64 v17; // rdi
  unsigned __int64 v18; // r9
  __int16 *v19; // rdi
  unsigned __int64 v20; // r9

  *((_QWORD *)this + 18) = 0i64;
  *((_QWORD *)this + 16) = 0i64;
  memset((char *)this + 112, 0, 8ui64);
  *((_BYTE *)this + 120) = 0;
  v6 = (void *)*((_QWORD *)this + 20);
  if ( v6 )
  {
    v11 = *((_DWORD *)this + 38);
    if ( v11 )
    {
      if ( *((_BYTE *)this + 8) )
      {
        if ( a3 )
        {
          if ( a3->cbBuffer )
          {
            if ( a3->cbBuffer < v11 )
            {
              a3->cbBuffer = v11;
              v9 = -2146892950;
              goto LABEL_39;
            }
            memcpy_0(a3->pvBuffer, *((const void **)this + 20), *((unsigned int *)this + 38));
            SPExternalFree(*((void **)this + 20));
          }
          else
          {
            a3->pvBuffer = v6;
          }
          v9 = 590614;
          a3->cbBuffer = *((_DWORD *)this + 38);
          *((_QWORD *)this + 20) = 0i64;
          *((_DWORD *)this + 38) = 0;
          *((_BYTE *)this + 136) = 0;
LABEL_39:
          *((_QWORD *)this + 18) = 0i64;
          *((_QWORD *)this + 16) = 0i64;
          memset((char *)this + 112, 0, 8ui64);
          *((_BYTE *)this + 120) = 0;
          return v9;
        }
        SPExternalFree(*((void **)this + 20));
        *((_QWORD *)this + 20) = 0i64;
        *((_DWORD *)this + 38) = 0;
        *((_BYTE *)this + 136) = 0;
      }
    }
  }
  if ( a2 )
  {
    pBuffers = a2->pBuffers;
    if ( pBuffers < &pBuffers[a2->cBuffers] )
    {
      do
      {
        v8 = pBuffers->BufferType & 0xFFFFFFF;
        if ( v8 == 25 )
        {
          if ( *((_BYTE *)this + 120) )
            goto LABEL_38;
          if ( pBuffers->cbBuffer < 0xC )
            goto LABEL_38;
          pvBuffer = pBuffers->pvBuffer;
          v13 = *((unsigned __int16 *)pvBuffer + 4);
          if ( v13 + 10 > pBuffers->cbBuffer
            || (unsigned int)(v13 + 4) > 0xFFFF
            || pvBuffer[1]
            || !CTls13Context::IsValidGenericExtensionType(*(_WORD *)pvBuffer) )
          {
            goto LABEL_38;
          }
          *((_QWORD *)this + v14 + 14) = pvBuffer;
          ++*((_BYTE *)this + 120);
        }
        else if ( v8 == 26 )
        {
          cbBuffer = pBuffers->cbBuffer;
          if ( (unsigned int)cbBuffer < 0xC )
            goto LABEL_38;
          if ( *((_QWORD *)this + 16) )
            goto LABEL_38;
          v16 = pBuffers->pvBuffer;
          v17 = (unsigned int)v16[1];
          if ( (unsigned int)(v17 - 1) > 1 )
            goto LABEL_38;
          if ( *v16 )
            goto LABEL_38;
          v18 = 4 * v17 + 8;
          if ( v18 > cbBuffer )
            goto LABEL_38;
          v19 = (__int16 *)(v16 + 2);
          if ( v16 + 2 < (_DWORD *)((char *)v16 + v18) )
          {
            while ( CTls13Context::IsValidGenericExtensionType(*v19) )
            {
              v19 += 2;
              if ( (unsigned __int64)v19 >= v20 )
                goto LABEL_36;
            }
LABEL_38:
            v9 = -2146892963;
            goto LABEL_39;
          }
LABEL_36:
          *((_QWORD *)this + 16) = v16;
        }
        ++pBuffers;
      }
      while ( pBuffers < &a2->pBuffers[(unsigned __int64)a2->cBuffers] );
    }
    if ( *((_QWORD *)this + 16) && !a3 )
      goto LABEL_38;
    *((_QWORD *)this + 18) = a3;
    return 0;
  }
  return 0i64;
}
// 180022BB7: variable 'pBuffers' is possibly undefined
// 18003FDA2: variable 'v14' is possibly undefined
// 18003FE00: variable 'v20' is possibly undefined
// 18003FE02: variable 'v16' is possibly undefined

//----- (0000000180022C10) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::ProcessHandshake(
        CTls13ServerContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        int *a4)
{
  __int64 v4; // rsi
  unsigned int updated; // ebp
  __int64 v10; // r15
  unsigned __int8 *v11; // r10
  int v12; // ecx
  unsigned int v13; // r8d
  int v14; // r9d
  unsigned int v15; // edx
  bool v16; // r15
  __int64 v17; // rax
  __int64 v18; // r9
  unsigned int v20; // edx
  unsigned int v21; // edx
  CCipherMill *v22; // rcx
  __int64 v23; // rdx
  CCipherMill *v24; // rcx
  __int64 v25; // rdx
  unsigned int v26; // edx
  unsigned int v27; // edx
  __int64 *v28; // rax
  __int64 v29; // rcx
  int v30; // eax
  __int64 v31; // rdx
  __int64 v32; // rcx
  __int64 v33; // rax
  __int64 v34; // rcx
  __int64 v35; // rax
  __int64 *v36; // rax
  __int64 v37; // rdx
  int v38; // eax
  unsigned int v39; // edi
  __int64 *v40; // rax
  __int64 v41; // rdx
  int v42; // eax
  __int64 *v43; // rax
  __int64 v44; // rax
  int v45; // eax
  __int64 v46; // [rsp+80h] [rbp+8h] BYREF
  char v47; // [rsp+90h] [rbp+18h] BYREF
  unsigned __int8 *v48; // [rsp+98h] [rbp+20h]

  v4 = 0i64;
  *a4 = 0;
  *((_BYTE *)this + 1282) = 0;
  v47 = 0;
  if ( !a3 || !a2 )
    return 87i64;
  updated = 0;
  v10 = *((_QWORD *)this + 10);
  if ( !v10 )
    return 1359i64;
  v11 = a2 + 4;
  v12 = *((_DWORD *)this + 17);
  v13 = a3 - 4;
  v14 = *a2 << 8;
  v15 = v14 | (unsigned __int8)v12;
  v48 = v11;
  LODWORD(v46) = v13;
  if ( v15 == 256 )
    goto LABEL_5;
  if ( v15 > 0x143C )
  {
    if ( v15 > 0x144F )
    {
      if ( v15 == 6148 || v15 > 0x184D && v15 <= 0x184F )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 56i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
          v11 = v48;
          v13 = v46;
        }
        updated = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ParseKeyUpdate((__int64)this + 1288, v11, v13);
        if ( !updated )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 57i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
          }
          v43 = (__int64 *)*((_QWORD *)this + 1);
          if ( v43 )
            v4 = *v43;
          updated = UpdateTrafficSecretAndDeriveNewKey(
                      v4,
                      (unsigned __int64 *)this + 135,
                      (unsigned __int64 *)this + 18,
                      (unsigned __int64 *)this + 22);
          if ( !updated && *((_DWORD *)this + 17) != 79 )
            *((_DWORD *)this + 17) = 4;
        }
        return updated;
      }
      goto LABEL_113;
    }
    if ( v15 == 5199 )
    {
      v24 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control )
        return updated;
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 53i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
        v24 = WPP_GLOBAL_Control;
      }
      if ( v24 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v24 + 28) & 4) == 0 )
        return updated;
      v25 = 54i64;
      goto LABEL_41;
    }
    v27 = v15 - 5182;
    if ( v27 && v27 != 8 )
      goto LABEL_113;
  }
  else if ( v15 != 5180 )
  {
    if ( v15 > 0xB4F )
    {
      v26 = v15 - 3900;
      if ( !v26 )
      {
        v22 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 51i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
          v22 = WPP_GLOBAL_Control;
          v11 = v48;
          v13 = v46;
        }
        if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) != 4 )
        {
          updated = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ParseCertificateVerify(
                      (__int64)this + 1288,
                      (__int64)v11,
                      v13);
          if ( !updated )
          {
            updated = DoCertificateMapping(this);
            if ( !updated )
              *((_DWORD *)this + 17) = 62;
          }
          return updated;
        }
        if ( v22 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v22 + 28) & 1) == 0 )
          return (unsigned int)-2146893018;
        v23 = 52i64;
        goto LABEL_25;
      }
      if ( v26 != 19 )
      {
LABEL_113:
        *((_DWORD *)this + 17) = 96;
        *((_WORD *)this + 48) = 2562;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_DD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x3Au,
            (__int64)&WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids,
            v14,
            96);
        return (unsigned int)-2146893018;
      }
      v24 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control )
        return updated;
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 49i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
        v24 = WPP_GLOBAL_Control;
      }
      if ( v24 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v24 + 28) & 4) == 0 )
        return updated;
      v25 = 50i64;
    }
    else
    {
      if ( v15 != 2895 )
      {
        v20 = v15 - 327;
        if ( !v20 )
        {
LABEL_5:
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 43i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
            v12 = *((_DWORD *)this + 17);
          }
          v16 = v12 == 71;
          *((_QWORD *)this + 17) |= 0x8000ui64;
          (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 240i64))(this);
          v17 = *(_QWORD *)this;
          *((_QWORD *)this + 11) = 0i64;
          LOBYTE(v18) = 1;
          updated = (*(__int64 (__fastcall **)(CTls13ServerContext *, unsigned __int8 *, _QWORD, __int64, char *))(v17 + 536))(
                      this,
                      a2,
                      a3,
                      v18,
                      &v47);
          if ( !updated )
          {
            v44 = *((_QWORD *)this + 17);
            if ( (v44 & 0x40000) == 0 )
            {
              *((_BYTE *)this + 552) = 0;
              *((_QWORD *)this + 17) = v44 & 0xFFFFFFFFFFBFFFFFui64;
              if ( v16 )
              {
                *((_DWORD *)this + 17) = 99;
              }
              else
              {
                v45 = 93;
                if ( *((_DWORD *)this + 17) == 71 )
                  v45 = 98;
                *((_DWORD *)this + 17) = v45;
              }
            }
          }
          return updated;
        }
        v21 = v20 - 2559;
        if ( !v21 || v21 == 8 )
        {
          v22 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 46i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
            v22 = WPP_GLOBAL_Control;
            v11 = v48;
            v13 = v46;
          }
          if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) == 4 )
          {
            if ( v22 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v22 + 28) & 1) == 0 )
              return (unsigned int)-2146893018;
            v23 = 47i64;
          }
          else
          {
            if ( (*((_DWORD *)this + 34) & 0x100i64) != 0 && (*((_DWORD *)this + 17) != 78 || *((_BYTE *)this + 1232)) )
            {
              updated = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ParseCertificateMsg(
                          (__int64)this + 1288,
                          v11,
                          v13);
              if ( !updated )
                *((_DWORD *)this + 17) = 60;
              return updated;
            }
            if ( v22 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v22 + 28) & 1) == 0 )
              return (unsigned int)-2146893018;
            v23 = 48i64;
          }
LABEL_25:
          WPP_SF_(*((_QWORD *)v22 + 2), v23, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
          return (unsigned int)-2146893018;
        }
        goto LABEL_113;
      }
      v24 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control )
        return updated;
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 44i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
        v24 = WPP_GLOBAL_Control;
      }
      if ( v24 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v24 + 28) & 4) == 0 )
        return updated;
      v25 = 45i64;
    }
LABEL_41:
    WPP_SF_(*((_QWORD *)v24 + 2), v25, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
    return updated;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 55i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
    v12 = *((_DWORD *)this + 17);
    v11 = a2 + 4;
    v13 = a3 - 4;
  }
  if ( v12 == 60 && (*((_DWORD *)this + 34) & 0x100i64) != 0 && !*((_BYTE *)this + 552) )
    return (unsigned int)-2146893018;
  updated = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ParseFinished((__int64)this + 1288, v11, v13);
  if ( updated )
    return updated;
  updated = (*(__int64 (__fastcall **)(CTls13ServerContext *, unsigned __int8 *, _QWORD, _QWORD))(*(_QWORD *)this
                                                                                                + 504i64))(
              this,
              a2,
              a3,
              0i64);
  if ( updated )
    return updated;
  *a4 = 1;
  if ( (*((_DWORD *)this + 34) & 0x2008000) != 33587200i64 || (*(_BYTE *)(v10 + 156) & 0x20) != 0 )
  {
    v33 = *(_QWORD *)this;
    *((_BYTE *)this + 1216) = 3;
    (*(void (__fastcall **)(CTls13ServerContext *))(v33 + 448))(this);
  }
  else
  {
    if ( !*((_QWORD *)this + 11) )
      return 1359;
    v28 = (__int64 *)*((_QWORD *)this + 1);
    v46 = 0i64;
    if ( v28 )
      v29 = *v28;
    else
      v29 = 0i64;
    v30 = SslExpandResumptionMasterKey(v29, *((_QWORD *)this + 134), *((_QWORD *)this + 74), &v46, 0i64, 0);
    updated = v30;
    if ( v30 )
    {
      CSslContext::SetError((__int64)this, 613, v30);
      return updated;
    }
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
    v31 = *((_QWORD *)this + 11);
    v32 = *(_QWORD *)(v31 + 16);
    if ( v32 )
    {
      SslFreeObject(v32, 0i64);
      v31 = *((_QWORD *)this + 11);
    }
    *(_QWORD *)(v31 + 16) = v46;
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
    *((_DWORD *)this + 17) = 102;
  }
  if ( !*((_BYTE *)this + 1233) )
  {
    *((_WORD *)this + 16) |= 0xAu;
    v34 = *((_QWORD *)this + 18);
    if ( v34 )
      SslFreeObject(v34, 0i64);
    *((_QWORD *)this + 18) = *((_QWORD *)this + 20);
    *((_QWORD *)this + 20) = 0i64;
    if ( !*((_BYTE *)this + 233) )
      *((_QWORD *)this + 22) = 0i64;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 60i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
  }
  v35 = *(_QWORD *)this;
  updated = 0;
  *((_BYTE *)this + 1233) = 1;
  if ( (*(unsigned __int8 (__fastcall **)(CTls13ServerContext *))(v35 + 384))(this) )
    return updated;
  v36 = (__int64 *)*((_QWORD *)this + 1);
  if ( v36 )
    v37 = *v36;
  else
    v37 = 0i64;
  v38 = CTls13Context::PopulateSecTrafficSecret((__int64)this + 1000, v37, 1, 3u, (__int64)v36, 0, 0);
  v39 = v38;
  if ( !v38 )
  {
    v40 = (__int64 *)*((_QWORD *)this + 1);
    if ( v40 )
      v41 = *v40;
    else
      v41 = 0i64;
    v42 = CTls13Context::PopulateSecTrafficSecret((__int64)this + 1000, v41, 0, 3u, (__int64)v40, 0, 0);
    updated = v42;
    if ( v42 )
      CSslContext::SetError((__int64)this, 611, v42);
    return updated;
  }
  CSslContext::SetError((__int64)this, 612, v38);
  return v39;
}
// 180022D1E: variable 'v18' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180098450: using guessed type __int64 __fastcall SslExpandResumptionMasterKey(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180022D60) ----------------------------------------------------
struct _SLIST_ENTRY *__fastcall CSslLookaside::Allocate(CSslLookaside *this)
{
  SIZE_T v2; // rcx
  struct _SLIST_ENTRY *result; // rax
  PSLIST_ENTRY v4; // rax
  unsigned int v5; // ecx
  PSLIST_ENTRY v6; // rdi

  if ( *((_BYTE *)this + 32) )
  {
    v4 = InterlockedPopEntrySList((PSLIST_HEADER)this + 1);
    v5 = *((_DWORD *)this + 9);
    v6 = v4;
    if ( v4 )
    {
      memset_0(&v4[1], 0, v5);
      _InterlockedDecrement((volatile signed __int32 *)this + 13);
    }
    else
    {
      result = (struct _SLIST_ENTRY *)SPExternalAlloc(v5 + 16);
      v6 = result;
      if ( !result )
        return result;
      _InterlockedIncrement((volatile signed __int32 *)this + 17);
    }
    _InterlockedIncrement((volatile signed __int32 *)this + 15);
    return v6 + 1;
  }
  else
  {
    v2 = *((unsigned int *)this + 9);
    if ( LsaTable )
      return (struct _SLIST_ENTRY *)(*(__int64 (__fastcall **)(SIZE_T))(LsaTable + 40))(v2);
    else
      return (struct _SLIST_ENTRY *)LocalAlloc(0x40u, v2);
  }
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180022DB0) ----------------------------------------------------
void __fastcall CSsl3TlsServerContext::GetEndpointBindings(
        CSsl3TlsServerContext *this,
        unsigned __int8 **a2,
        unsigned int *a3)
{
  __int64 v6; // rax

  *a2 = 0i64;
  *a3 = 0;
  if ( (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 248i64))(this) )
  {
    v6 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 248i64))(this);
    *a2 = *(unsigned __int8 **)(v6 + 464);
    *a3 = *(_DWORD *)(v6 + 472);
  }
}

//----- (0000000180022E40) ----------------------------------------------------
void __fastcall CSslLookaside::Deallocate(CSslLookaside *this, struct _SLIST_ENTRY *a2)
{
  if ( *((_BYTE *)this + 32) )
  {
    InterlockedPushEntrySList((PSLIST_HEADER)this + 1, a2 - 1);
    _InterlockedIncrement((volatile signed __int32 *)this + 13);
  }
  else if ( LsaTable )
  {
    (*(void (__fastcall **)(struct _SLIST_ENTRY *))(LsaTable + 48))(a2);
  }
  else
  {
    LocalFree(a2);
  }
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180022E90) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::PreparseMessage(CSsl3TlsServerContext *this, struct SPBuffer *a2)
{
  int v2; // eax
  unsigned int v3; // ebx
  __int64 v7; // r8
  bool v8; // al
  int v9; // ecx

  v2 = *((_DWORD *)this + 17);
  v3 = 0;
  if ( v2 == 4 )
  {
    if ( *((_DWORD *)a2 + 1) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 28i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      *((_DWORD *)this + 17) = 76;
    }
    return v3;
  }
  if ( v2 != 20 )
    return v3;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 29i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
  v7 = *((unsigned int *)a2 + 1);
  if ( (unsigned int)v7 >= 3 )
  {
    v3 = CSsl3TlsServerContext::DigestUnifiedHello(this, *((unsigned __int8 **)a2 + 1), v7);
    v8 = IsFatalError(v3);
    v9 = 93;
    if ( v8 )
      v9 = 96;
    *((_DWORD *)this + 17) = v9;
    return v3;
  }
  *((_DWORD *)a2 + 1) = 3;
  return 2148074264i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180022EE0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::GetPeerCertValidationResults(
        CSsl3TlsServerContext *this,
        int *a2,
        unsigned int *a3)
{
  __int64 v3; // rcx
  __int64 result; // rax

  if ( !a2 || !a3 )
    return 87i64;
  if ( *(_QWORD *)(*((_QWORD *)this + 10) + 848i64) )
  {
    v3 = *((_QWORD *)this + 124);
    *a2 = *(_DWORD *)(v3 + 216);
    *a3 = *(_DWORD *)(v3 + 220);
    return 0i64;
  }
  else
  {
    result = 0i64;
    *a2 = 0;
    *a3 = 0;
  }
  return result;
}

//----- (0000000180022F30) ----------------------------------------------------
bool __fastcall CSessionCacheServerItem::IsEntryAMatch(
        CSessionCacheServerItem *this,
        struct _LUID *a2,
        const unsigned __int16 *a3,
        struct CRED_THUMBPRINT *a4,
        unsigned int a5)
{
  return (*((_DWORD *)this + 42) & a5) != 0
      && *(_DWORD *)a4 == *((_DWORD *)this + 47)
      && *((_DWORD *)a4 + 1) == *((_DWORD *)this + 48);
}

//----- (0000000180022F70) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::PreparseMessage(CTls13ServerContext *this, struct SPBuffer *a2)
{
  unsigned int v2; // ebx

  v2 = 0;
  if ( a2 && this )
  {
    if ( *((_DWORD *)this + 17) == 4 && *((_DWORD *)a2 + 1) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_s(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x12u,
          (__int64)&WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids,
          "server");
      *((_DWORD *)this + 17) = 78;
    }
  }
  else
  {
    return (unsigned int)-2146892963;
  }
  return v2;
}

//----- (0000000180022FB0) ----------------------------------------------------
CTls13Record *__fastcall CTls13Record::`vector deleting destructor'(CTls13Record *this, char a2)
{
  *(_QWORD *)this = &CTlsRecord::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 18007D3F0: using guessed type void *CTlsRecord::`vftable';

//----- (0000000180022FF0) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::SetTrafficSecretsBuffers(
        CTls13ServerContext *this,
        struct _SecBufferDesc *const a2,
        char a3,
        char a4)
{
  unsigned int v4; // r10d
  char *v8; // r8
  unsigned int v9; // edx
  unsigned __int8 v10; // di
  PSecBuffer pBuffers; // rcx
  __int64 v12; // rax

  v4 = 0;
  if ( a3 )
    return v4;
  if ( !a2 )
    return (unsigned int)-2146892963;
  v8 = (char *)this + 1168;
  v9 = 0;
  memset((char *)this + 1168, 0, 0x20ui64);
  *((_BYTE *)this + 1200) = 0;
  v10 = 0;
  pBuffers = a2->pBuffers;
  if ( pBuffers < &pBuffers[a2->cBuffers] )
  {
    while ( 1 )
    {
      if ( v10 >= 4u )
      {
LABEL_20:
        *((_BYTE *)this + 1201) = 0;
        return v9;
      }
      if ( (pBuffers->BufferType & 0xFFFFFFF) == 28 )
      {
        if ( a4 )
        {
          pBuffers->pvBuffer = 0i64;
          pBuffers->cbBuffer = 0;
        }
        else
        {
          if ( !pBuffers->pvBuffer )
          {
            v9 = 14;
            goto LABEL_14;
          }
          if ( pBuffers->cbBuffer < 0x1C0 )
          {
            pBuffers->cbBuffer = 448;
            goto LABEL_11;
          }
        }
        v12 = v10++;
        *((_QWORD *)this + v12 + 146) = pBuffers;
      }
LABEL_11:
      if ( ++pBuffers >= &a2->pBuffers[(unsigned __int64)a2->cBuffers] )
      {
        if ( v10 < 4u )
          break;
        goto LABEL_20;
      }
    }
  }
  v9 = -2146892949;
LABEL_14:
  memset(v8, 0, 0x20ui64);
  *((_BYTE *)this + 1200) = 0;
  return v9;
}

//----- (0000000180023030) ----------------------------------------------------
bool __fastcall CTls13ServerContext::UseSchannelRecordLayer(CTls13ServerContext *this)
{
  return (*((_QWORD *)this + 17) & 0x100000000i64) == 0;
}

//----- (0000000180023050) ----------------------------------------------------
void __fastcall CSessionCacheServerItem::CompleteCacheAdd(
        CSessionCacheServerItem *this,
        struct CSessionCacheManager *a2,
        struct CSslContext *a3)
{
  __int64 v3; // rax
  __int64 v4; // rdx
  __int64 v5; // rax

  v3 = *((_QWORD *)a3 + 10);
  if ( v3 && (*(_BYTE *)(v3 + 156) & 0x20) != 0 )
    *((_WORD *)this + 118) = 256;
  v4 = *((_QWORD *)a3 + 1);
  *((_QWORD *)this + 22) = v4;
  *((_DWORD *)this + 46) = *((_DWORD *)a3 + 4);
  v5 = *(_QWORD *)(v4 + 848);
  if ( v5 )
    _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v5 + 16) + 12i64));
  _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v4 + 856) + 12i64));
}

//----- (00000001800230B0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::Initialize(CSsl3TlsServerContext *this)
{
  int v2; // edi
  char *v4; // rax
  char *v5; // rdx
  _QWORD *v6; // rcx
  _QWORD *v7; // rax
  _DWORD *v8; // rax
  __int64 v9; // rcx
  DTlsMsgMgr *v10; // rcx

  v2 = g_fEnableHelloVerifyRequest;
  if ( !*((_BYTE *)this + 233) )
    return 0i64;
  *((_QWORD *)this + 23) = g_fEnableHelloVerifyRequest != 0;
  v4 = (char *)operator new(0x60ui64);
  v5 = v4;
  if ( v4 )
  {
    *((_DWORD *)v4 + 2) = 10;
    *((_QWORD *)v4 + 11) = this;
    *((_DWORD *)v4 + 1) = 0;
    *(_DWORD *)v4 = v2 != 0;
    *((_QWORD *)v4 + 4) = v4 + 24;
    *((_QWORD *)v4 + 3) = v4 + 24;
    v6 = v4 + 40;
    v7 = v4 + 56;
    v6[1] = v6;
    *v6 = v6;
    v7[1] = v7;
    *v7 = v7;
    *((_QWORD *)v5 + 10) = v5 + 72;
    *((_QWORD *)v5 + 9) = v5 + 72;
  }
  else
  {
    v5 = 0i64;
  }
  *((_QWORD *)this + 72) = v5;
  if ( v5 )
  {
    v8 = operator new(0x30ui64);
    if ( v8 )
    {
      v9 = *((_QWORD *)this + 72);
      v8[2] = 0;
      v8[3] = 0;
      *((_QWORD *)v8 + 2) = 0i64;
      *((_QWORD *)v8 + 3) = 0i64;
      v8[8] = 0;
      *(_QWORD *)v8 = v9;
      *((_QWORD *)v8 + 5) = this;
      v8[9] = *((__int16 *)this + 96);
    }
    v10 = (DTlsMsgMgr *)*((_QWORD *)this + 72);
    *((_QWORD *)this + 73) = v8;
    if ( v8 )
    {
      *((_QWORD *)this + 28) = v10;
      if ( v2 )
        ++*((_WORD *)this + 110);
      return 0i64;
    }
    if ( v10 )
      DTlsMsgMgr::`scalar deleting destructor'(v10);
  }
  return 14i64;
}
// 1800919A4: using guessed type int g_fEnableHelloVerifyRequest;

//----- (00000001800230F0) ----------------------------------------------------
void __fastcall CSsl3TlsServerContext::ClearCacheItem(CSsl3TlsServerContext *this)
{
  CSessionCacheTable **v2; // rcx

  v2 = (CSessionCacheTable **)*((_QWORD *)this + 124);
  if ( v2 )
  {
    CSessionCacheTable::DereferenceCacheItemInternal(v2[28], (struct CSessionCacheItem *)v2, 1, 0);
    *((_QWORD *)this + 124) = 0i64;
  }
}

//----- (0000000180023120) ----------------------------------------------------
__int64 __fastcall CSslLookaside::Allocate(CSslLookaside *this, __int64 a2)
{
  if ( a2 == *((_DWORD *)this + 9) )
    return (*(__int64 (__fastcall **)(CSslLookaside *))(*(_QWORD *)this + 16i64))(this);
  else
    return 0i64;
}

//----- (0000000180023150) ----------------------------------------------------
void __fastcall FlushTimerCallbackUserMode(PTP_CALLBACK_INSTANCE Instance, __int64 Context, PTP_TIMER Timer)
{
  if ( *(_BYTE *)(Context + 356) )
  {
    *(_BYTE *)(Context + 356) = 0;
    LookUpTableFlushComplete(Context);
  }
  else
  {
    LookUpTableFlushPartial(Context);
  }
  if ( *(_DWORD *)(Context + 256) )
    EnableFlushTimer(*(struct _TP_TIMER **)(Context + 344), *(_DWORD *)(Context + 352));
}

//----- (0000000180023188) ----------------------------------------------------
void __fastcall LookUpTableFlushPartial(__int64 a1)
{
  unsigned int v1; // esi
  unsigned int v3; // ebp
  unsigned int v4; // ebx

  v1 = 0;
  if ( *(_DWORD *)(a1 + 256) )
  {
    v3 = *(_DWORD *)(a1 + 260);
    v4 = v3;
    do
    {
      if ( *(_QWORD *)(a1 + 8i64 * v4) )
        v1 += FlushLookUpTableBucket(a1, v4);
      v4 = ((_BYTE)v4 + 1) & 0x1F;
    }
    while ( v4 != v3 && v1 < 0x10 );
    *(_DWORD *)(a1 + 260) = v4;
    UpdateInternalStatsOnFlush(a1, v1);
  }
}

//----- (0000000180023204) ----------------------------------------------------
__int64 __fastcall FlushLookUpTableBucket(__int64 a1, unsigned int a2)
{
  __int64 v2; // rbx
  RTL_SRWLOCK *v4; // rdi
  const EVENT_DESCRIPTOR *v5; // rsi
  unsigned int v6; // eax
  unsigned int v7; // ebx

  v2 = a2;
  if ( !*(_QWORD *)(a1 + 8i64 * a2) )
    return 0i64;
  v4 = (RTL_SRWLOCK *)(a1 + 264);
  AcquireSRWLockExclusive((PSRWLOCK)(a1 + 264));
  v5 = *(const EVENT_DESCRIPTOR **)(a1 + 8 * v2);
  *(_QWORD *)(a1 + 8 * v2) = 0i64;
  v6 = FlattenEventEntryTree((__int64)v5);
  *(_DWORD *)(a1 + 256) -= v6;
  v7 = v6;
  ReleaseSRWLockExclusive(v4);
  FlushEventEntryList(*(_QWORD *)(*(_QWORD *)(a1 + 328) + 32i64), v5);
  return v7;
}

//----- (000000018002329C) ----------------------------------------------------
void __fastcall FlushEventEntryList(REGHANDLE RegHandle, PCEVENT_DESCRIPTOR EventDescriptor)
{
  PCEVENT_DESCRIPTOR v2; // rdi
  int v4; // edx
  __int64 v5; // rcx
  const EVENT_DESCRIPTOR *Keyword; // rbx

  if ( EventDescriptor )
  {
    v2 = EventDescriptor;
    do
    {
      v4 = 2;
      if ( (unsigned int)BYTE5(v2[2].Keyword) + 2 > 2 )
      {
        v5 = 32i64;
        do
        {
          v5 += 16i64;
          ++v4;
          *(_BYTE *)(v5 + *(_QWORD *)&v2[1].Id - 3) = 0;
        }
        while ( v4 < BYTE5(v2[2].Keyword) + 2 );
      }
      EventWriteTransfer_0(RegHandle, v2, 0i64, 0i64, BYTE4(v2[2].Keyword), *(PEVENT_DATA_DESCRIPTOR *)&v2[1].Id);
      Keyword = (const EVENT_DESCRIPTOR *)v2[1].Keyword;
      DestroyEventEntry((__int64)v2);
      v2 = Keyword;
    }
    while ( Keyword );
  }
}

//----- (0000000180023334) ----------------------------------------------------
void __fastcall DestroyEventEntry(__int64 a1)
{
  void *v1; // rbx
  HANDLE ProcessHeap; // rax

  if ( a1 )
  {
    v1 = *(void **)(a1 + 16);
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v1);
  }
}

//----- (0000000180023370) ----------------------------------------------------
__int64 __fastcall FlattenEventEntryTree(__int64 a1)
{
  __int64 *v1; // rdx
  __int64 result; // rax
  __int64 v3; // r9
  __int64 *v4; // r8
  __int64 i; // rcx
  __int64 v6; // [rsp+8h] [rbp+8h] BYREF

  v6 = a1;
  v1 = &v6;
  result = 0i64;
  while ( a1 )
  {
    v3 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = 0i64;
    v1 = (__int64 *)(*v1 + 24);
    v4 = v1;
    for ( i = *v1; i; i = *(_QWORD *)(i + 32) )
      v4 = (__int64 *)(i + 32);
    *v4 = v3;
    result = (unsigned int)(result + 1);
    a1 = *v1;
  }
  return result;
}

//----- (00000001800233B8) ----------------------------------------------------
void __fastcall UpdateInternalStatsOnFlush(__int64 a1, unsigned int a2)
{
  __int64 *v2; // r8
  __int64 v3; // rax

  if ( a2 )
  {
    v2 = (__int64 *)(a1 + 280);
    if ( *(_DWORD *)(a1 + 296) > a2 || (v3 = *v2) == 0 )
    {
      v3 = *v2;
      *(_DWORD *)(a1 + 296) = a2;
    }
    if ( *(_DWORD *)(a1 + 292) < a2 )
      *(_DWORD *)(a1 + 292) = a2;
    *v2 = v3 + 1;
    *(_QWORD *)(a1 + 272) += a2;
  }
}

//----- (0000000180023408) ----------------------------------------------------
void __fastcall CCipherMill::ReferenceProvider(CCipherMill *this, unsigned __int64 a2, unsigned __int64 *a3)
{
  CCipherMill *v5; // rcx

  RtlAcquireResourceShared(&Resource, 1u);
  if ( a2 )
  {
    if ( *a3 != a2 )
    {
      CCipherMill::DeferenceProvider(v5, a3);
      if ( (int)SslIncrementProviderReferenceCount(a2) >= 0 )
      {
        _InterlockedIncrement(&dword_1800925A0);
        *a3 = a2;
      }
    }
  }
  RtlReleaseResource(&Resource);
}
// 18002343A: variable 'v5' is possibly undefined
// 1800925A0: using guessed type int dword_1800925A0;
// 1800984E8: using guessed type __int64 __fastcall SslIncrementProviderReferenceCount(_QWORD);

//----- (0000000180023480) ----------------------------------------------------
void __fastcall CCipherMill::DeferenceProvider(CCipherMill *this, unsigned __int64 *a2)
{
  if ( a2 )
  {
    if ( *a2 )
    {
      SslDecrementProviderReferenceCount();
      _InterlockedDecrement(&dword_1800925A0);
      *a2 = 0i64;
    }
  }
}
// 1800925A0: using guessed type int dword_1800925A0;
// 180098518: using guessed type __int64 SslDecrementProviderReferenceCount(void);

//----- (00000001800234BC) ----------------------------------------------------
void __fastcall EnableFlushTimer(struct _TP_TIMER *a1, unsigned int a2)
{
  struct _FILETIME v2; // rdx
  struct _FILETIME pftDueTime; // [rsp+40h] [rbp+8h] BYREF

  if ( a1 )
  {
    v2 = (struct _FILETIME)(-10000i64 * a2);
    if ( !dword_180092DE8 )
    {
      pftDueTime = v2;
      SetThreadpoolTimer(a1, &pftDueTime, 0, 0x1388u);
    }
  }
}
// 180092DE8: using guessed type int dword_180092DE8;

//----- (0000000180023520) ----------------------------------------------------
__int64 LoadSslRegistryOptions(void)
{
  NTSTATUS v0; // eax
  CCipherMill *v1; // rcx

  qword_180092680 = (__int64)CreateEventW(0i64, 0, 0, 0i64);
  qword_180092698 = (__int64)SslWatchParamKey;
  qword_180092690 = (__int64)L"System\\CurrentControlSet\\Control\\SecurityProviders\\Schannel";
  qword_1800926A8 = (__int64)CreateEventW(0i64, 0, 0, 0i64);
  qword_1800926C0 = (__int64)FipsWatchParamKey;
  qword_1800926B8 = (__int64)L"System\\CurrentControlSet\\Control\\Lsa";
  qword_1800926D0 = (__int64)CreateEventW(0i64, 0, 0, 0i64);
  qword_1800926E8 = (__int64)UserMappingsWatchParamKey;
  qword_1800926E0 = (__int64)L"Software\\Policies\\Microsoft\\Cryptography\\Configuration\\SSL\\00010002";
  qword_180092658 = (__int64)CreateEventW(0i64, 0, 0, 0i64);
  qword_180092670 = (__int64)DefaultEccCurveWatchParamKey;
  qword_180092668 = (__int64)L"System\\CurrentControlSet\\Control\\Cryptography\\Configuration\\Local\\SSL\\00010002";
  SslWatchParamKey(g_BaseSslRegOptions);
  FipsWatchParamKey(g_FipsRegOptions, 1);
  UserMappingsWatchParamKey(&g_UserMappingRegOptions);
  DefaultEccCurveWatchParamKey(&g_DefaultEccCurveRegOptions, 1);
  v0 = BCryptRegisterConfigChangeNotify(&g_hBcryptEvent);
  if ( v0 < 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        10i64,
        &WPP_652d1bd98c7033c24f7b4105215d66be_Traceguids,
        (unsigned int)v0);
    return 0i64;
  }
  else
  {
    RtlRegisterWait(&g_hBcryptWait, g_hBcryptEvent, (WAITORTIMERCALLBACKFUNC)WatchBcryptEvent, 0i64, 0xFFFFFFFF, 0);
    CCipherMill::BuildCipherMill(v1);
    return 1i64;
  }
}
// 180023689: variable 'v1' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800817E0: using guessed type wchar_t aSystemCurrentc_1[37];
// 180092658: using guessed type __int64 qword_180092658;
// 180092668: using guessed type __int64 qword_180092668;
// 180092670: using guessed type __int64 qword_180092670;
// 180092680: using guessed type __int64 qword_180092680;
// 180092690: using guessed type __int64 qword_180092690;
// 180092698: using guessed type __int64 qword_180092698;
// 1800926A8: using guessed type __int64 qword_1800926A8;
// 1800926B8: using guessed type __int64 qword_1800926B8;
// 1800926C0: using guessed type __int64 qword_1800926C0;
// 1800926C8: using guessed type HKEY g_UserMappingRegOptions;
// 1800926D0: using guessed type __int64 qword_1800926D0;
// 1800926E0: using guessed type __int64 qword_1800926E0;
// 1800926E8: using guessed type __int64 qword_1800926E8;

//----- (00000001800236B0) ----------------------------------------------------
void __fastcall DefaultEccCurveWatchParamKey(void *a1, char a2)
{
  BYTE *lpData; // rbx
  CCipherMill *v5; // rcx
  HLOCAL v6; // rdi
  DWORD cbData; // [rsp+40h] [rbp+8h] BYREF
  DWORD Type; // [rsp+50h] [rbp+18h] BYREF

  cbData = 0;
  if ( WatchParamKeyHelper((char *)a1) )
    goto LABEL_10;
  if ( RegQueryValueExW(*((HKEY *)a1 + 2), L"EccCurves", 0i64, &Type, 0i64, &cbData) )
    goto LABEL_10;
  if ( !cbData )
    goto LABEL_10;
  if ( Type != 7 )
    goto LABEL_10;
  lpData = (BYTE *)LocalAlloc(0x40u, cbData);
  if ( !lpData )
    goto LABEL_10;
  if ( RegQueryValueExW(*((HKEY *)a1 + 2), L"EccCurves", 0i64, &Type, lpData, &cbData) )
    goto LABEL_15;
  v6 = g_pbDefaultEccCurveList;
  if ( g_pbDefaultEccCurveList && g_cbDefaultEccCurveList )
  {
    if ( g_cbDefaultEccCurveList != cbData || memcmp_0(g_pbDefaultEccCurveList, lpData, cbData) )
    {
      LocalFree(v6);
      goto LABEL_8;
    }
LABEL_15:
    LocalFree(lpData);
    goto LABEL_10;
  }
LABEL_8:
  g_cbDefaultEccCurveList = cbData;
  g_pbDefaultEccCurveList = lpData;
  if ( !a2 )
    CCipherMill::BuildCipherMill(v5);
LABEL_10:
  NotifyWNFConfigChangeEvent(WNF_SCH_ECC_RELOAD);
}
// 1800237B1: variable 'v5' is possibly undefined
// 180092790: using guessed type unsigned int g_cbDefaultEccCurveList;

//----- (00000001800237C0) ----------------------------------------------------
__int64 __fastcall CCipherMill::BuildCipherMill(CCipherMill *this)
{
  CCipherMill *v1; // rcx
  CCipherMill *v2; // rcx
  unsigned int ProviderList; // ebx
  CCipherMill *v5; // [rsp+40h] [rbp+8h] BYREF

  v5 = this;
  if ( !g_cCipherMill[0] )
    return 14i64;
  if ( CSessionCacheManager::m_pSessionCacheManager )
    CSessionCacheManager::PurgeCacheEntries(CSessionCacheManager::m_pSessionCacheManager, 0x30000u, 0i64, 0, 0i64);
  RtlAcquireResourceExclusive(&Resource, 1u);
  CCipherMill::ClearCipherMill(v1, 0);
  ProviderList = CCipherMill::LoadProviderList(v2, (unsigned __int8 *)&v5);
  if ( ProviderList
    || !hProvider
    && (ProviderList = NCryptOpenStorageProvider(&hProvider, L"Microsoft Software Key Storage Provider", 0)) != 0
    || (ProviderList = CCipherMill::LoadCipherTables((CCipherMill *)g_cCipherMill)) != 0 )
  {
    RtlReleaseResource(&Resource);
  }
  else
  {
    RtlReleaseResource(&Resource);
    if ( CSessionCacheManager::m_pSessionCacheManager )
      CSessionCacheManager::PurgeCacheEntries(CSessionCacheManager::m_pSessionCacheManager, 0x30000u, 0i64, 0, 0i64);
    if ( (_BYTE)v5 )
    {
      if ( CSslCredManager::m_pCredManager )
        CSslCredManager::NotifyProviderChange(CSslCredManager::m_pCredManager);
    }
  }
  return ProviderList;
}
// 1800237FE: variable 'v1' is possibly undefined
// 180023808: variable 'v2' is possibly undefined

//----- (00000001800238AC) ----------------------------------------------------
__int64 __fastcall CCipherMill::LoadCipherTables(CCipherMill *this)
{
  __int64 v1; // r14
  unsigned int v2; // ebx
  struct CCipherSuiteInfo *v3; // r13
  wchar_t *v4; // r15
  unsigned int v5; // r12d
  struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *v6; // rax
  unsigned int v7; // ebx
  unsigned int v8; // esi
  __int64 v9; // r15
  char *v10; // rdi
  char *v11; // rax
  __int64 v12; // rdx
  _OWORD *v13; // rcx
  _OWORD *v14; // rax
  __int128 v15; // xmm1
  __int64 v16; // rcx
  unsigned __int16 *v17; // rdi
  unsigned __int8 v18; // r10
  char v19; // r10
  int v20; // eax
  ULONG v21; // eax
  unsigned __int16 *v22; // rdi
  unsigned int v23; // r15d
  unsigned __int16 *v24; // rsi
  int *v25; // rax
  __int64 v26; // rcx
  wchar_t *v27; // rax
  __int64 v28; // rbx
  unsigned int v29; // r12d
  int *v30; // rdi
  unsigned int v31; // esi
  __int64 v32; // r15
  int v33; // ecx
  __int64 v34; // rcx
  unsigned int v35; // ebx
  void **v36; // r8
  unsigned int v37; // ebx
  wchar_t *v38; // rdi
  __int64 v39; // rsi
  unsigned int i; // r11d
  __int64 v41; // rcx
  __int64 v42; // rdx
  __int64 v43; // r9
  char *v44; // r10
  __int64 v45; // rax
  __int128 v46; // xmm0
  __int128 v47; // xmm1
  __int128 v48; // xmm0
  __int128 v49; // xmm1
  __int128 v50; // xmm0
  __int128 v51; // xmm1
  __int128 v52; // xmm0
  __int128 v53; // xmm1
  int v54; // eax
  __int64 v55; // r9
  __int64 v56; // rax
  __int128 v57; // xmm1
  char *v58; // rdx
  __int64 v59; // rax
  __int128 v60; // xmm1
  __int128 v61; // xmm0
  __int128 v62; // xmm1
  __int128 v63; // xmm0
  __int128 v64; // xmm1
  __int128 v65; // xmm0
  __int128 v66; // xmm1
  unsigned int j; // edi
  void *v68; // rcx
  int v69; // ecx
  int *v70; // rax
  __int64 v71; // rdx
  char *v72; // rax
  unsigned int v73; // eax
  PCRYPT_CONTEXT_FUNCTIONS v74; // rdx
  int v75; // r12d
  __int64 v76; // rbx
  const wchar_t **v77; // rsi
  unsigned int v78; // edi
  int v79; // eax
  CCipherMill *v80; // rcx
  __int16 v81; // cx
  __int64 v82; // rdx
  __int64 v83; // r8
  __int64 v84; // rax
  wchar_t *v85; // rdi
  __int64 v86; // rsi
  unsigned int v87; // ebx
  struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *v88; // r15
  unsigned int v89; // edi
  CCipherMill *v90; // rcx
  unsigned int v91; // esi
  unsigned __int8 *v92; // rbx
  int SupportedProvider; // eax
  struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *v94; // rdi
  __int64 v95; // rsi
  void *v96; // rcx
  unsigned int k; // edi
  void *v98; // rcx
  BOOLEAN pfEnabled[4]; // [rsp+48h] [rbp-C0h] BYREF
  unsigned int v101; // [rsp+4Ch] [rbp-BCh]
  unsigned int v102; // [rsp+50h] [rbp-B8h] BYREF
  unsigned int v103; // [rsp+54h] [rbp-B4h] BYREF
  ULONG v104; // [rsp+58h] [rbp-B0h] BYREF
  unsigned int v105; // [rsp+5Ch] [rbp-ACh]
  unsigned int v106[2]; // [rsp+60h] [rbp-A8h]
  PVOID pvBuffer; // [rsp+68h] [rbp-A0h] BYREF
  PCRYPT_CONTEXT_FUNCTIONS v108; // [rsp+70h] [rbp-98h] BYREF
  wchar_t *v109; // [rsp+78h] [rbp-90h] BYREF
  wchar_t *String1; // [rsp+80h] [rbp-88h] BYREF
  unsigned __int16 *v111; // [rsp+88h] [rbp-80h] BYREF
  wchar_t *v112; // [rsp+90h] [rbp-78h]
  struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *v113; // [rsp+98h] [rbp-70h]
  _OWORD *v114; // [rsp+A0h] [rbp-68h] BYREF
  struct CCipherSuiteInfo *v115; // [rsp+A8h] [rbp-60h] BYREF
  struct CCipherSuiteInfo *v116; // [rsp+B0h] [rbp-58h] BYREF
  ULONG pcbBuffer; // [rsp+B8h] [rbp-50h] BYREF
  ULONG v118; // [rsp+BCh] [rbp-4Ch] BYREF
  CMasterCipherInfo *v119; // [rsp+C0h] [rbp-48h] BYREF
  CMasterCipherInfo *v120; // [rsp+C8h] [rbp-40h] BYREF
  PCRYPT_CONTEXT_FUNCTIONS ppBuffer; // [rsp+D0h] [rbp-38h] BYREF
  char v122[784]; // [rsp+D8h] [rbp-30h] BYREF
  void *v123; // [rsp+3E8h] [rbp+2E0h] BYREF
  int v124[187]; // [rsp+3F0h] [rbp+2E8h] BYREF
  wchar_t v125[5]; // [rsp+6DEh] [rbp+5D6h] BYREF
  wchar_t Destination[64]; // [rsp+6E8h] [rbp+5E0h] BYREF
  wchar_t v127[64]; // [rsp+768h] [rbp+660h] BYREF

  LODWORD(v1) = 0;
  v2 = 0;
  v118 = 0;
  v101 = 0;
  v108 = 0i64;
  v104 = 0;
  v3 = 0i64;
  pvBuffer = 0i64;
  v4 = 0i64;
  v115 = 0i64;
  v5 = 0;
  v116 = 0i64;
  v105 = 0;
  v106[0] = 0;
  v120 = 0i64;
  v119 = 0i64;
  pcbBuffer = 0;
  ppBuffer = 0i64;
  v111 = 0i64;
  v103 = 0;
  pfEnabled[0] = 0;
  v112 = 0i64;
  String1 = 0i64;
  v102 = 0;
  memset_0(&v123, 0, 0x300ui64);
  memset_0(Destination, 0, sizeof(Destination));
  memset_0(v127, 0, sizeof(v127));
  ++dword_180092488;
  v114 = 0i64;
  dword_1800925D4 = 13;
  v6 = (struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *)SPExternalAlloc(0xC800u);
  v113 = v6;
  if ( !v6 )
  {
    v7 = 14;
    goto LABEL_167;
  }
  v8 = 0;
  if ( !qword_180092498 )
    goto LABEL_30;
  while ( 2 )
  {
    v109 = 0i64;
    v9 = v2;
    if ( v2 >= 0xC80 )
      goto LABEL_20;
    v10 = (char *)v6 + 16 * v2;
    do
    {
      if ( !(_BYTE)v1 )
      {
        v7 = SslEnumCipherSuitesEx(*(_QWORD *)&g_cCipherMill[8 * v8 + 128], 0i64, v10, &v109, 0);
        if ( v7 != -2146893783 )
        {
          LOBYTE(v1) = 0;
          goto LABEL_10;
        }
        LOBYTE(v1) = 1;
      }
      v7 = SslEnumCipherSuites(*(_QWORD *)&g_cCipherMill[8 * v8 + 128], 0i64, &v114, &v109, 0);
LABEL_10:
      *((_DWORD *)v10 + 2) = v8;
      v10[12] = v1;
      if ( v7 == -2146893782 )
        break;
      if ( v7 )
      {
        v16 = (__int64)v109;
        *(_QWORD *)v10 = 0i64;
        *((_DWORD *)v10 + 2) = 0;
        SslFreeBuffer(v16);
        goto LABEL_28;
      }
      if ( (_BYTE)v1 )
      {
        v11 = (char *)SPExternalAlloc(0x328u);
        *(_QWORD *)v10 = v11;
        if ( !v11 )
        {
          v7 = -2146893056;
          goto LABEL_159;
        }
        v12 = 5i64;
        v13 = v11 + 4;
        v14 = v114;
        do
        {
          *v13 = *v14;
          v13[1] = v14[1];
          v13[2] = v14[2];
          v13[3] = v14[3];
          v13[4] = v14[4];
          v13[5] = v14[5];
          v13[6] = v14[6];
          v13 += 8;
          v15 = v14[7];
          v14 += 8;
          *(v13 - 1) = v15;
          --v12;
        }
        while ( v12 );
        *v13 = *v14;
        v13[1] = v14[1];
        *((_DWORD *)v13 + 8) = *((_DWORD *)v14 + 8);
        SslFreeBuffer(v114);
        v114 = 0i64;
      }
      v10 += 16;
      ++v101;
    }
    while ( v101 < 0xC80 );
    if ( v109 )
      SslFreeBuffer(v109);
LABEL_20:
    if ( (unsigned int)SslEnumEccCurves(*(_QWORD *)&g_cCipherMill[8 * v8 + 128], &v124[6 * v8], &v124[6 * v8 - 2], 0i64) )
    {
      LOBYTE(v124[6 * v8 + 2]) = 0;
      v2 = v101;
      CCipherMill::EnumEccCurvesFromCipherToProvTable(
        0i64,
        (struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *)((char *)v113 + 16 * v9),
        v101 - v9,
        (unsigned int *)&v124[6 * v8],
        (struct _NCRYPT_SSL_ECC_CURVE **)&v124[6 * v8 - 2]);
    }
    else
    {
      LOBYTE(v124[6 * v8 + 2]) = 1;
      v2 = v101;
    }
    ++v8;
    LODWORD(v1) = 0;
    if ( v8 < qword_180092498 )
    {
      v6 = v113;
      continue;
    }
    break;
  }
  v4 = v112;
LABEL_30:
  word_1800925E8 = 0;
  word_18009260A = 0;
  if ( BCryptEnumContextFunctions(1u, L"SSL", 0x10003u, &pcbBuffer, &ppBuffer) < 0
    || !CTlsSignatureSuiteList::AddBCryptSignatureSuites(
          (CTlsSignatureSuiteList *)&word_1800925E8,
          (const unsigned __int16 **const)ppBuffer->rgpszFunctions,
          ppBuffer->cFunctions,
          1) )
  {
    word_1800925E8 = 0;
    v18 = 0;
    word_18009260A = 0;
    do
    {
      CTlsSignatureSuiteList::AddSignatureSuite((CTlsSignatureSuiteList *)&word_1800925E8, v18);
      v18 = v19 + 1;
    }
    while ( v18 < 0xCu );
    CTlsSignatureSuiteList::SetRsaSignatureFlags();
  }
  v20 = BCryptEnumContextFunctions(1u, L"SSL", 0x10002u, &v118, &v108);
  if ( v20 < 0 )
  {
    v21 = RtlNtStatusToDosError(v20);
    goto LABEL_150;
  }
  if ( !(unsigned int)IsCipherSuiteGroupPolicyEnabled()
    || (unsigned int)IsEccCurveGroupPolicyEnabled()
    || (GetSslEccCurveTypeOrderFromCipherSuiteList((__int64)v108, &String1, &v102),
        v5 = v102,
        v4 = String1,
        v112 = String1,
        !v102) )
  {
    v111 = 0i64;
    GetSslEccCurveOrder((BYTE **)&v111, (unsigned __int16 *)&v103);
    v22 = v111;
    if ( v111 )
    {
      v23 = qword_180092498;
      v103 = qword_180092498;
      v24 = v111;
      String1 = v111;
      if ( qword_180092498 )
      {
        v25 = v124;
        v26 = qword_180092498;
        do
        {
          LODWORD(v3) = *v25 + (_DWORD)v3;
          v25 += 6;
          --v26;
        }
        while ( v26 );
      }
      v27 = (wchar_t *)SPExternalAlloc(4 * (int)v3);
      v109 = v27;
      if ( v27 )
      {
        v28 = -1i64;
        do
          ++v28;
        while ( v22[v28] );
        if ( v28 )
        {
          while ( 1 )
          {
            v29 = 0;
            if ( v23 )
              break;
LABEL_63:
            if ( (_DWORD)v1 != (_DWORD)v3 )
            {
              v24 += v28 + 1;
              String1 = v24;
              v28 = -1i64;
              do
                ++v28;
              while ( v24[v28] );
              if ( v28 )
                continue;
            }
            goto LABEL_67;
          }
          v30 = v124;
          while ( 1 )
          {
            if ( *((_QWORD *)v30 - 1) )
            {
              v31 = 0;
              if ( *v30 )
              {
                while ( 1 )
                {
                  v32 = *((_QWORD *)v30 - 1) + 780i64 * v31;
                  if ( !wcsicmp(String1, (const wchar_t *)v32) )
                    break;
                  if ( ++v31 >= *v30 )
                    goto LABEL_59;
                }
                v33 = 0;
                if ( (_DWORD)v1 )
                {
                  while ( *(_DWORD *)&v109[2 * v33] != *(_DWORD *)(v32 + 772) )
                  {
                    if ( ++v33 >= (unsigned int)v1 )
                      goto LABEL_58;
                  }
                }
                else
                {
LABEL_58:
                  v34 = (unsigned int)v1;
                  LODWORD(v1) = v1 + 1;
                  *(_DWORD *)&v109[2 * v34] = *(_DWORD *)(v32 + 772);
                }
LABEL_59:
                v23 = v103;
              }
              if ( (_DWORD)v1 == (_DWORD)v3 )
                break;
            }
            ++v29;
            v30 += 6;
            if ( v29 >= v23 )
            {
              v24 = String1;
              goto LABEL_63;
            }
          }
LABEL_67:
          v27 = v109;
          v22 = v111;
        }
        v4 = v27;
        v112 = v27;
        v5 = v1;
        v102 = v1;
      }
      else
      {
        v4 = v112;
      }
      SPExternalFree(v22);
      LODWORD(v1) = 0;
    }
  }
  if ( !v4 || !v5 )
    goto LABEL_97;
  if ( BCryptGetFipsAlgorithmMode(pfEnabled) >= 0 && pfEnabled[0] )
  {
    FilterFipsEccCurves((__int64)v4, &v102);
    v5 = v102;
  }
  if ( v5 )
  {
    v35 = qword_180092498;
    if ( qword_180092498 )
    {
      v36 = &v123;
      v1 = qword_180092498;
      do
      {
        if ( *v36 )
        {
          v37 = 0;
          v38 = v4;
          v39 = v5;
          do
          {
            for ( i = 0; i < *((_DWORD *)v36 + 2); ++i )
            {
              v41 = (__int64)*v36 + 780 * i;
              if ( *(_DWORD *)v38 == *(_DWORD *)(v41 + 772) )
              {
                v42 = (__int64)*v36 + 780 * v37;
                if ( v37 != i )
                {
                  v43 = (__int64)*v36 + 780 * v37;
                  v44 = v122;
                  v45 = 6i64;
                  do
                  {
                    v46 = *(_OWORD *)v43;
                    v47 = *(_OWORD *)(v43 + 16);
                    v43 += 128i64;
                    *(_OWORD *)v44 = v46;
                    v48 = *(_OWORD *)(v43 - 96);
                    *((_OWORD *)v44 + 1) = v47;
                    v49 = *(_OWORD *)(v43 - 80);
                    *((_OWORD *)v44 + 2) = v48;
                    v50 = *(_OWORD *)(v43 - 64);
                    *((_OWORD *)v44 + 3) = v49;
                    v51 = *(_OWORD *)(v43 - 48);
                    *((_OWORD *)v44 + 4) = v50;
                    v52 = *(_OWORD *)(v43 - 32);
                    *((_OWORD *)v44 + 5) = v51;
                    v53 = *(_OWORD *)(v43 - 16);
                    *((_OWORD *)v44 + 6) = v52;
                    v44 += 128;
                    *((_OWORD *)v44 - 1) = v53;
                    --v45;
                  }
                  while ( v45 );
                  *(_QWORD *)v44 = *(_QWORD *)v43;
                  v54 = *(_DWORD *)(v43 + 8);
                  v55 = v41;
                  *((_DWORD *)v44 + 2) = v54;
                  v56 = 6i64;
                  do
                  {
                    *(_OWORD *)v42 = *(_OWORD *)v55;
                    *(_OWORD *)(v42 + 16) = *(_OWORD *)(v55 + 16);
                    *(_OWORD *)(v42 + 32) = *(_OWORD *)(v55 + 32);
                    *(_OWORD *)(v42 + 48) = *(_OWORD *)(v55 + 48);
                    *(_OWORD *)(v42 + 64) = *(_OWORD *)(v55 + 64);
                    *(_OWORD *)(v42 + 80) = *(_OWORD *)(v55 + 80);
                    *(_OWORD *)(v42 + 96) = *(_OWORD *)(v55 + 96);
                    v42 += 128i64;
                    v57 = *(_OWORD *)(v55 + 112);
                    v55 += 128i64;
                    *(_OWORD *)(v42 - 16) = v57;
                    --v56;
                  }
                  while ( v56 );
                  *(_QWORD *)v42 = *(_QWORD *)v55;
                  *(_DWORD *)(v42 + 8) = *(_DWORD *)(v55 + 8);
                  v58 = v122;
                  v59 = 6i64;
                  do
                  {
                    v60 = *((_OWORD *)v58 + 1);
                    *(_OWORD *)v41 = *(_OWORD *)v58;
                    v61 = *((_OWORD *)v58 + 2);
                    *(_OWORD *)(v41 + 16) = v60;
                    v62 = *((_OWORD *)v58 + 3);
                    *(_OWORD *)(v41 + 32) = v61;
                    v63 = *((_OWORD *)v58 + 4);
                    *(_OWORD *)(v41 + 48) = v62;
                    v64 = *((_OWORD *)v58 + 5);
                    *(_OWORD *)(v41 + 64) = v63;
                    v65 = *((_OWORD *)v58 + 6);
                    *(_OWORD *)(v41 + 80) = v64;
                    v66 = *((_OWORD *)v58 + 7);
                    v58 += 128;
                    *(_OWORD *)(v41 + 96) = v65;
                    v41 += 128i64;
                    *(_OWORD *)(v41 - 16) = v66;
                    --v59;
                  }
                  while ( v59 );
                  *(_QWORD *)v41 = *(_QWORD *)v58;
                  *(_DWORD *)(v41 + 8) = *((_DWORD *)v58 + 2);
                }
                ++v37;
              }
            }
            v38 += 2;
            --v39;
          }
          while ( v39 );
          *((_DWORD *)v36 + 2) = v37;
        }
        v36 += 3;
        --v1;
      }
      while ( v1 );
      v35 = qword_180092498;
    }
  }
  else
  {
LABEL_97:
    v35 = qword_180092498;
    for ( j = 0; j < v35; ++j )
    {
      v68 = *(void **)&v124[6 * j - 2];
      v124[6 * j] = 0;
      if ( v68 )
      {
        if ( LOBYTE(v124[6 * j + 2]) )
          SslFreeBuffer(v68);
        else
          SPExternalFree(v68);
        v35 = qword_180092498;
        *(_QWORD *)&v124[6 * j - 2] = 0i64;
      }
    }
  }
  v69 = 0;
  if ( v35 )
  {
    v70 = v124;
    v71 = v35;
    do
    {
      v69 += *v70;
      v70 += 6;
      --v71;
    }
    while ( v71 );
  }
  v72 = (char *)SPExternalAlloc(32 * v35 + 16 + 780 * v69);
  v17 = (unsigned __int16 *)v72;
  if ( !v72 )
  {
    v7 = 14;
    goto LABEL_157;
  }
  qword_1800925C8 = CMasterEccCurveInfo::CMasterEccCurveInfo(
                      (CMasterEccCurveInfo *)v72,
                      (struct ProviderEccCurves *)(v72 + 16),
                      (struct CEccCurveInfo *)&v72[32 * v35 + 16],
                      (struct PROVIDER_TO_ECC_CURVES *)&v123,
                      qword_180092498);
  v17 = 0i64;
  v111 = 0i64;
  v7 = AllocateCipherSuiteData(v108->cFunctions, (unsigned __int8 **)&v119, &v115);
  if ( v7 )
  {
    v3 = v115;
    goto LABEL_153;
  }
  v73 = AllocateCipherSuiteData(v108->cFunctions, (unsigned __int8 **)&v120, &v116);
  v3 = v115;
  v7 = v73;
  if ( v73 )
  {
LABEL_153:
    if ( v119 )
      FreeCipherSuiteData(v105, (NCRYPT_HANDLE *)v3, v119);
    if ( !v120 )
      goto LABEL_159;
    FreeCipherSuiteData(v106[0], (NCRYPT_HANDLE *)v116, v120);
LABEL_157:
    if ( v17 )
      SPExternalFree(v17);
    goto LABEL_159;
  }
  v74 = v108;
  v75 = 0;
  qword_1800925C0 = 0i64;
  if ( !v108->cFunctions )
  {
LABEL_132:
    xmmword_1800925B0 = CMasterCipherInfo::CMasterCipherInfo(v119, v3, v105);
    *(&xmmword_1800925B0 + 1) = CMasterCipherInfo::CMasterCipherInfo(v120, v116, v106[0]);
    v81 = 0;
    word_1800925D0 = 0;
    if ( qword_180092498 )
    {
      v82 = 0i64;
      v83 = qword_180092498;
      do
      {
        v82 += 32i64;
        v81 += *(_WORD *)(*(_QWORD *)qword_1800925C8 + v82 - 24);
        word_1800925D0 = v81;
        --v83;
      }
      while ( v83 );
    }
    v7 = 0;
    goto LABEL_159;
  }
  while ( 2 )
  {
    if ( pvBuffer )
    {
      BCryptFreeBuffer(pvBuffer);
      v74 = v108;
      pvBuffer = 0i64;
    }
    wcscpy_s(Destination, 0x40ui64, v74->rgpszFunctions[v75]);
    v76 = -1i64;
    do
      ++v76;
    while ( Destination[v76] );
    if ( (unsigned int)v76 > 5 )
    {
      v77 = (const wchar_t **)&off_18007F170;
      v78 = 0;
      while ( wcsicmp(&v125[(unsigned int)v76], *v77) )
      {
        ++v78;
        v77 += 99;
        if ( v78 >= 3 )
          goto LABEL_122;
      }
      LODWORD(v1) = 1;
    }
LABEL_122:
    v79 = BCryptEnumContextFunctionProviders(
            1u,
            0i64,
            0x10002u,
            Destination,
            &v104,
            (PCRYPT_CONTEXT_FUNCTION_PROVIDERS *)&pvBuffer);
    if ( v79 == -1073741275 )
    {
      v79 = BCryptEnumContextFunctionProviders(
              1u,
              L"SSL",
              0x10002u,
              Destination,
              &v104,
              (PCRYPT_CONTEXT_FUNCTION_PROVIDERS *)&pvBuffer);
      if ( v79 == -1073741275 )
      {
        if ( (_DWORD)v1 )
        {
          v80 = (CCipherMill *)(2i64 * (unsigned int)(v76 - 5));
          if ( (unsigned __int64)v80 >= 0x80 )
            goto LABEL_184;
          Destination[(unsigned int)(v76 - 5)] = 0;
          LODWORD(v1) = 0;
          v79 = BCryptEnumContextFunctionProviders(
                  1u,
                  0i64,
                  0x10002u,
                  Destination,
                  &v104,
                  (PCRYPT_CONTEXT_FUNCTION_PROVIDERS *)&pvBuffer);
          if ( v79 == -1073741275 )
            v79 = BCryptEnumContextFunctionProviders(
                    1u,
                    L"SSL",
                    0x10002u,
                    Destination,
                    &v104,
                    (PCRYPT_CONTEXT_FUNCTION_PROVIDERS *)&pvBuffer);
          goto LABEL_128;
        }
LABEL_130:
        LODWORD(v1) = 0;
        goto LABEL_131;
      }
    }
LABEL_128:
    if ( v79 >= 0 )
    {
      if ( (_DWORD)v1 )
      {
        wcscpy_s(v127, 0x40ui64, Destination);
        v84 = -1i64;
        do
          ++v84;
        while ( v127[v84] );
        v80 = (CCipherMill *)(2i64 * (unsigned int)(v84 - 5));
        if ( (unsigned __int64)v80 >= 0x80 )
LABEL_184:
          _report_rangecheckfailure(v80);
        v127[(unsigned int)(v84 - 5)] = 0;
        v85 = v127;
      }
      else
      {
        v85 = Destination;
      }
      v86 = v105;
      v87 = 0;
      if ( v105 )
      {
        while ( wcsicmp(v85, (const wchar_t *)v3 + 432 * v87 + 37) )
        {
          if ( ++v87 >= (unsigned int)v86 )
            goto LABEL_145;
        }
        goto LABEL_130;
      }
LABEL_145:
      v88 = v113;
      v89 = v101;
      if ( !(unsigned int)CCipherMill::FindSupportedProvider(
                            v80,
                            (struct _CRYPT_CONTEXT_FUNCTION_PROVIDERS *)pvBuffer,
                            1u,
                            v113,
                            v101,
                            (unsigned __int8 *)v3 + 864 * v86,
                            Destination,
                            v1) )
      {
        LODWORD(qword_1800925C0) = *((_DWORD *)v3 + 216 * v86 + 2) | qword_1800925C0;
        v105 = v86 + 1;
      }
      v91 = v106[0];
      v92 = (unsigned __int8 *)v116 + 864 * v106[0];
      SupportedProvider = CCipherMill::FindSupportedProvider(
                            v90,
                            (struct _CRYPT_CONTEXT_FUNCTION_PROVIDERS *)pvBuffer,
                            2u,
                            v88,
                            v89,
                            v92,
                            Destination,
                            v1);
      LODWORD(v1) = 0;
      if ( !SupportedProvider )
      {
        HIDWORD(qword_1800925C0) |= *((_DWORD *)v92 + 2);
        v106[0] = v91 + 1;
      }
LABEL_131:
      v74 = v108;
      if ( ++v75 >= v108->cFunctions )
        goto LABEL_132;
      continue;
    }
    break;
  }
  if ( v79 == -1073741275 )
    goto LABEL_130;
  v21 = RtlNtStatusToDosError(v79);
LABEL_150:
  v7 = v21;
  if ( v21 )
  {
LABEL_28:
    v17 = v111;
    goto LABEL_153;
  }
LABEL_159:
  if ( v101 )
  {
    v94 = v113;
    v95 = v101;
    do
    {
      v96 = *(void **)v94;
      if ( *(_QWORD *)v94 )
      {
        if ( *((_BYTE *)v94 + 12) )
          SPExternalFree(v96);
        else
          SslFreeBuffer(v96);
      }
      v94 = (struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *)((char *)v94 + 16);
      --v95;
    }
    while ( v95 );
  }
  SPExternalFree(v113);
  v4 = v112;
LABEL_167:
  for ( k = 0; k < qword_180092498; ++k )
  {
    v98 = *(void **)&v124[6 * k - 2];
    if ( v98 )
    {
      if ( LOBYTE(v124[6 * k + 2]) )
        SslFreeBuffer(v98);
      else
        SPExternalFree(v98);
    }
  }
  if ( v4 )
    SPExternalFree(v4);
  if ( pvBuffer )
    BCryptFreeBuffer(pvBuffer);
  if ( v108 )
    BCryptFreeBuffer(v108);
  if ( ppBuffer )
    BCryptFreeBuffer(ppBuffer);
  if ( v114 )
    SslFreeBuffer(v114);
  return v7;
}
// 180023F0A: conditional instruction was optimized away because r12d.4!=0
// 180023C92: variable 'v19' is possibly undefined
// 180024504: variable 'v80' is possibly undefined
// 180024553: variable 'v90' is possibly undefined
// 1800281B8: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD);
// 18007F170: using guessed type wchar_t *off_18007F170;
// 180092488: using guessed type int dword_180092488;
// 1800925C0: using guessed type __int64 qword_1800925C0;
// 1800925D0: using guessed type __int16 word_1800925D0;
// 1800925D4: using guessed type int dword_1800925D4;
// 1800925E8: using guessed type __int16 word_1800925E8;
// 18009260A: using guessed type __int16 word_18009260A;
// 180098458: using guessed type __int64 __fastcall SslEnumEccCurves(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098468: using guessed type __int64 __fastcall SslEnumCipherSuitesEx(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098480: using guessed type __int64 __fastcall SslFreeBuffer(_QWORD);
// 180098590: using guessed type __int64 __fastcall SslEnumCipherSuites(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 1800238AC: using guessed type wchar_t Destination[64];
// 1800238AC: using guessed type wchar_t var_B0[64];
// 1800238AC: using guessed type wchar_t var_13A[5];

//----- (0000000180024700) ----------------------------------------------------
__int64 __fastcall CCipherMill::FindSupportedProvider(
        CCipherMill *this,
        struct _CRYPT_CONTEXT_FUNCTION_PROVIDERS *a2,
        ULONG a3,
        struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *a4,
        unsigned int a5,
        unsigned __int8 *a6,
        unsigned __int16 *a7,
        int a8)
{
  unsigned int v11; // esi
  unsigned int v12; // ebx
  PWSTR *rgpszProviders; // rcx
  wchar_t *v14; // r14
  unsigned int v15; // edi
  struct ProviderEccCurves *v16; // rbx
  __int64 v18; // rax
  ULONG pcbBuffer; // [rsp+80h] [rbp+8h] BYREF
  int v20; // [rsp+84h] [rbp+Ch]
  PCRYPT_PROVIDER_REG ppBuffer; // [rsp+88h] [rbp+10h] BYREF

  v20 = HIDWORD(this);
  pcbBuffer = 0;
  v11 = -1;
  v12 = 0;
  if ( !a2->cProviders )
    return 1168i64;
  while ( v11 == -1 )
  {
    rgpszProviders = a2->rgpszProviders;
    ppBuffer = 0i64;
    if ( BCryptQueryProviderRegistration(rgpszProviders[v12], a3, 0x10002u, &pcbBuffer, &ppBuffer) >= 0
      && (a3 == 1 && ppBuffer->pUM || a3 == 2 && ppBuffer->pKM) )
    {
      v11 = v12;
    }
    if ( ppBuffer )
      BCryptFreeBuffer(ppBuffer);
    if ( ++v12 >= a2->cProviders )
    {
      if ( v11 == -1 )
        return 1168i64;
      break;
    }
  }
  v14 = a7;
  if ( a8 && !wcsnicmp(a2->rgpszProviders[v11], L"Microsoft SSL Protocol Provider", 0x40ui64) )
  {
    v18 = -1i64;
    do
      ++v18;
    while ( v14[v18] );
    v14[(unsigned int)(v18 - 5)] = 0;
  }
  v15 = 0;
  if ( !qword_180092498 )
    goto LABEL_20;
  while ( wcsnicmp(*(const wchar_t **)(qword_180092490 + 16i64 * v15), a2->rgpszProviders[v11], 0x40ui64) )
  {
    if ( ++v15 >= qword_180092498 )
      goto LABEL_20;
  }
  if ( v15 == -1 )
LABEL_20:
    v16 = 0i64;
  else
    v16 = (struct ProviderEccCurves *)(*(_QWORD *)qword_1800925C8 + 32i64 * v15);
  return CCipherMill::InitializeCipherSuite(
           (CCipherMill *)v11,
           a4,
           a5,
           (CCipherSuiteInfo *)a6,
           (char *)a2->rgpszProviders[v11],
           v14,
           v16);
}
// 180092490: using guessed type __int64 qword_180092490;

//----- (0000000180024898) ----------------------------------------------------
CMasterCipherInfo *__fastcall CMasterCipherInfo::CMasterCipherInfo(
        CMasterCipherInfo *this,
        struct CCipherSuiteInfo *a2,
        int a3)
{
  unsigned int i; // edx
  __int64 v4; // rax

  *(_QWORD *)this = a2;
  *((_DWORD *)this + 2) = a3;
  *((_DWORD *)this + 3) = 1;
  _InterlockedIncrement(&CMasterCipherInfo::m_lMasterCiphersCount);
  for ( i = 0; i < *((_DWORD *)this + 2); *(_QWORD *)(864 * v4 + *(_QWORD *)this + 856) = this )
    v4 = i++;
  return this;
}
// 180092D90: using guessed type int CMasterCipherInfo::m_lMasterCiphersCount;

//----- (00000001800248E0) ----------------------------------------------------
__int64 __fastcall AllocateCipherSuiteData(unsigned int a1, unsigned __int8 **a2, struct CCipherSuiteInfo **a3)
{
  unsigned __int8 *v5; // rax

  if ( a1 > 864 * a1 )
    return 14i64;
  v5 = (unsigned __int8 *)SPExternalAlloc(864 * a1 + 16);
  *a2 = v5;
  if ( !v5 )
    return 14i64;
  *a3 = (struct CCipherSuiteInfo *)(v5 + 16);
  return 0i64;
}

//----- (000000018002492C) ----------------------------------------------------
CMasterEccCurveInfo *__fastcall CMasterEccCurveInfo::CMasterEccCurveInfo(
        CMasterEccCurveInfo *this,
        struct ProviderEccCurves *a2,
        struct CEccCurveInfo *a3,
        struct PROVIDER_TO_ECC_CURVES *a4,
        unsigned int a5)
{
  __int64 v6; // rbx
  unsigned int *v7; // r11
  __int64 v8; // rsi
  unsigned int v9; // ebp
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // r8
  __int64 v13; // r9

  *((_DWORD *)this + 3) = 1;
  *((_DWORD *)this + 2) = a5;
  *(_QWORD *)this = a2;
  if ( a5 )
  {
    v6 = 0i64;
    v7 = (unsigned int *)((char *)a4 + 8);
    v8 = a5;
    do
    {
      *(_DWORD *)(v6 + *(_QWORD *)this + 8) = *v7;
      *(_BYTE *)(v6 + *(_QWORD *)this + 24) = *((_BYTE *)v7 + 8);
      *(_QWORD *)(v6 + *(_QWORD *)this + 16) = this;
      if ( *v7 )
      {
        v9 = 0;
        *(_QWORD *)(v6 + *(_QWORD *)this) = a3;
        v10 = *v7;
        if ( (_DWORD)v10 )
        {
          do
          {
            v11 = 780i64 * v9;
            v12 = v11 + *((_QWORD *)v7 - 1);
            v13 = v11 + *(_QWORD *)(v6 + *(_QWORD *)this);
            *(_OWORD *)v13 = *(_OWORD *)v12;
            *(_OWORD *)(v13 + 16) = *(_OWORD *)(v12 + 16);
            *(_OWORD *)(v13 + 32) = *(_OWORD *)(v12 + 32);
            *(_OWORD *)(v13 + 48) = *(_OWORD *)(v12 + 48);
            *(_OWORD *)(v13 + 64) = *(_OWORD *)(v12 + 64);
            *(_OWORD *)(v13 + 80) = *(_OWORD *)(v12 + 80);
            *(_OWORD *)(v13 + 96) = *(_OWORD *)(v12 + 96);
            *(_OWORD *)(v13 + 112) = *(_OWORD *)(v12 + 112);
            *(_OWORD *)(v13 + 128) = *(_OWORD *)(v12 + 128);
            *(_OWORD *)(v13 + 144) = *(_OWORD *)(v12 + 144);
            *(_OWORD *)(v13 + 160) = *(_OWORD *)(v12 + 160);
            *(_OWORD *)(v13 + 176) = *(_OWORD *)(v12 + 176);
            *(_OWORD *)(v13 + 192) = *(_OWORD *)(v12 + 192);
            *(_OWORD *)(v13 + 208) = *(_OWORD *)(v12 + 208);
            *(_OWORD *)(v13 + 224) = *(_OWORD *)(v12 + 224);
            *(_QWORD *)(v13 + 240) = *(_QWORD *)(v12 + 240);
            *(_DWORD *)(v13 + 248) = *(_DWORD *)(v12 + 248);
            *(_WORD *)(v13 + 252) = *(_WORD *)(v12 + 252);
            *(_BYTE *)(v13 + 254) = *(_BYTE *)(v12 + 254);
            *(_OWORD *)(v13 + 510) = *(_OWORD *)(v12 + 510);
            *(_OWORD *)(v13 + 526) = *(_OWORD *)(v12 + 526);
            *(_OWORD *)(v13 + 542) = *(_OWORD *)(v12 + 542);
            *(_OWORD *)(v13 + 558) = *(_OWORD *)(v12 + 558);
            *(_OWORD *)(v13 + 574) = *(_OWORD *)(v12 + 574);
            *(_OWORD *)(v13 + 590) = *(_OWORD *)(v12 + 590);
            *(_OWORD *)(v13 + 606) = *(_OWORD *)(v12 + 606);
            *(_OWORD *)(v13 + 622) = *(_OWORD *)(v12 + 622);
            *(_OWORD *)(v13 + 638) = *(_OWORD *)(v12 + 638);
            *(_OWORD *)(v13 + 654) = *(_OWORD *)(v12 + 654);
            *(_OWORD *)(v13 + 670) = *(_OWORD *)(v12 + 670);
            *(_OWORD *)(v13 + 686) = *(_OWORD *)(v12 + 686);
            *(_OWORD *)(v13 + 702) = *(_OWORD *)(v12 + 702);
            *(_OWORD *)(v13 + 718) = *(_OWORD *)(v12 + 718);
            *(_OWORD *)(v13 + 734) = *(_OWORD *)(v12 + 734);
            ++v9;
            *(_QWORD *)(v13 + 750) = *(_QWORD *)(v12 + 750);
            *(_DWORD *)(v13 + 758) = *(_DWORD *)(v12 + 758);
            *(_WORD *)(v13 + 762) = *(_WORD *)(v12 + 762);
            *(_BYTE *)(v13 + 764) = *(_BYTE *)(v12 + 764);
            *(_DWORD *)(v13 + 772) = *(_DWORD *)(v12 + 772);
            *(_DWORD *)(v13 + 768) = *(_DWORD *)(v12 + 768);
            *(_DWORD *)(v13 + 776) = *(_DWORD *)(v12 + 776);
            v10 = *v7;
          }
          while ( v9 < (unsigned int)v10 );
        }
        a3 = (struct CEccCurveInfo *)((char *)a3 + 780 * v10);
      }
      v7 += 6;
      v6 += 32i64;
      --v8;
    }
    while ( v8 );
  }
  return this;
}

//----- (0000000180024B84) ----------------------------------------------------
__int64 __fastcall GetSslEccCurveOrder(BYTE **a1, unsigned __int16 *a2)
{
  __int64 result; // rax
  const unsigned __int16 *v5; // rdx

  if ( a2 )
    *(_DWORD *)a2 = 0;
  if ( !a1 )
    return 3221225485i64;
  result = ReadMultiSzFromRegistry(L"Software\\Policies\\Microsoft\\Cryptography\\Configuration\\SSL\\00010002", a2, a1);
  if ( (_DWORD)result )
  {
    result = ReadMultiSzFromRegistry(
               L"System\\CurrentControlSet\\Control\\Cryptography\\Configuration\\Local\\SSL\\00010002",
               v5,
               a1);
    if ( !(_DWORD)result )
      *(_DWORD *)a2 = 0;
  }
  else
  {
    *(_DWORD *)a2 = 1;
  }
  return result;
}
// 180024BBE: variable 'v5' is possibly undefined

//----- (0000000180024BEC) ----------------------------------------------------
__int64 __fastcall ReadMultiSzFromRegistry(LPCWSTR lpSubKey, const unsigned __int16 *a2, BYTE **a3)
{
  BYTE *v4; // rbx
  unsigned int v5; // edi
  DWORD cbData; // [rsp+68h] [rbp+38h] BYREF
  int v8; // [rsp+6Ch] [rbp+3Ch]
  DWORD Type; // [rsp+70h] [rbp+40h] BYREF
  HKEY hKey; // [rsp+78h] [rbp+48h] BYREF

  v8 = HIDWORD(a2);
  hKey = 0i64;
  v4 = 0i64;
  cbData = 0;
  if ( !a3 )
    return (unsigned int)-1073741811;
  *a3 = 0i64;
  v5 = RegOpenKeyExW(HKEY_LOCAL_MACHINE, lpSubKey, 0, 0x20119u, &hKey);
  if ( v5 )
    goto LABEL_9;
  v5 = RegQueryValueExW(hKey, L"EccCurves", 0i64, &Type, 0i64, &cbData);
  if ( !v5 && Type == 7 )
  {
    v4 = (BYTE *)SPExternalAlloc(cbData + 4);
    if ( v4 )
    {
      v5 = RegQueryValueExW(hKey, L"EccCurves", 0i64, &Type, v4, &cbData);
      if ( !v5 && Type == 7 )
      {
        *(_WORD *)&v4[2 * ((unsigned __int64)cbData >> 1)] = 0;
        *(_WORD *)&v4[2 * ((unsigned __int64)cbData >> 1) + 2] = 0;
LABEL_9:
        *a3 = v4;
        goto LABEL_10;
      }
      SPExternalFree(v4);
    }
  }
LABEL_10:
  if ( hKey )
    RegCloseKey(hKey);
  return v5;
}

//----- (0000000180024D20) ----------------------------------------------------
__int64 IsCipherSuiteGroupPolicyEnabled()
{
  unsigned int v0; // ebx
  DWORD Type; // [rsp+40h] [rbp+8h] BYREF
  DWORD cbData; // [rsp+48h] [rbp+10h] BYREF
  HKEY hKey; // [rsp+50h] [rbp+18h] BYREF

  hKey = 0i64;
  v0 = 0;
  if ( RegOpenKeyExW(
         HKEY_LOCAL_MACHINE,
         L"Software\\Policies\\Microsoft\\Cryptography\\Configuration\\SSL\\00010002",
         0,
         0x20119u,
         &hKey)
    || !RegQueryValueExW(hKey, L"Functions", 0i64, &Type, 0i64, &cbData) && Type == 1 )
  {
    v0 = 1;
  }
  if ( hKey )
    RegCloseKey(hKey);
  return v0;
}

//----- (0000000180024DC4) ----------------------------------------------------
__int64 __fastcall CCipherMill::LoadProviderList(CCipherMill *this, unsigned __int8 *a2)
{
  char j; // si
  CCipherMill *v4; // rcx
  unsigned int v5; // ebx
  unsigned int i; // r8d
  unsigned int v7; // r11d
  unsigned __int16 *v8; // r9
  __int64 v9; // r14
  int v10; // eax
  int v11; // ebp
  __int64 v13; // rdx
  __int64 v14; // rdi
  __int64 v15; // rdx
  unsigned int v16; // [rsp+50h] [rbp+8h] BYREF
  int v17; // [rsp+54h] [rbp+Ch]
  CCipherMill *v18; // [rsp+58h] [rbp+10h] BYREF

  v17 = HIDWORD(this);
  v16 = 0;
  v18 = 0i64;
  *a2 = 0;
  j = 1;
  v5 = SslEnumProtocolProviders(&v16, &v18, 0i64);
  if ( !v5 )
  {
    if ( v16 - 1 <= 0x1F )
    {
      if ( v16 != qword_180092498 )
        goto LABEL_21;
      v4 = v18;
      for ( i = 0; i < v16; ++i )
      {
        if ( !j )
          break;
        v7 = 0;
        for ( j = 0; v7 < qword_180092498; ++v7 )
        {
          if ( j )
            break;
          v8 = (unsigned __int16 *)*((_QWORD *)v18 + 2 * i);
          v9 = *(_QWORD *)(qword_180092490 + 16i64 * v7) - (_QWORD)v8;
          do
          {
            v10 = *(unsigned __int16 *)((char *)v8 + v9);
            v11 = *v8 - v10;
            if ( v11 )
              break;
            ++v8;
          }
          while ( v10 );
          if ( !v11 )
            j = 1;
        }
      }
      if ( i == v16 )
      {
        if ( !*a2 )
        {
LABEL_17:
          v5 = 0;
          goto LABEL_18;
        }
      }
      else
      {
LABEL_21:
        *a2 = 1;
      }
      CCipherMill::DeleteProviderList(v4);
      v13 = (__int64)v18;
      v4 = 0i64;
      v14 = 0i64;
      qword_180092490 = (__int64)v18;
      qword_180092498 = v16;
      v18 = 0i64;
      if ( !v16 )
        goto LABEL_17;
      while ( 1 )
      {
        v15 = *(_QWORD *)(v13 + 16i64 * (unsigned int)v14);
        if ( !v15 )
          break;
        v5 = SslOpenProvider(&qword_1800924A0[v14], v15, 0i64);
        if ( v5 )
          goto LABEL_29;
        v14 = (unsigned int)(v14 + 1);
        if ( (unsigned int)v14 >= qword_180092498 )
        {
          v4 = v18;
          goto LABEL_17;
        }
        v13 = qword_180092490;
      }
    }
    v5 = 1359;
  }
LABEL_29:
  CCipherMill::DeleteProviderList(v4);
  v4 = v18;
LABEL_18:
  if ( v4 )
    SslFreeBuffer(v4);
  return v5;
}
// 180024EE0: variable 'v4' is possibly undefined
// 180092490: using guessed type __int64 qword_180092490;
// 1800924A0: using guessed type unsigned __int64 qword_1800924A0[32];
// 180098478: using guessed type __int64 __fastcall SslEnumProtocolProviders(_QWORD, _QWORD, _QWORD);
// 180098480: using guessed type __int64 __fastcall SslFreeBuffer(_QWORD);
// 1800984F8: using guessed type __int64 __fastcall SslOpenProvider(_QWORD, _QWORD, _QWORD);

//----- (0000000180024F64) ----------------------------------------------------
void __fastcall CCipherMill::ClearCipherMill(CCipherMill *this, char a2)
{
  if ( a2 )
  {
    CCipherMill::DeleteProviderList(this);
    if ( hProvider )
    {
      NCryptFreeObject(hProvider);
      hProvider = 0i64;
    }
  }
  if ( xmmword_1800925B0 )
  {
    CMasterCipherInfo::Dereference(xmmword_1800925B0);
    xmmword_1800925B0 = 0i64;
  }
  if ( *(&xmmword_1800925B0 + 1) )
  {
    CMasterCipherInfo::Dereference(*(&xmmword_1800925B0 + 1));
    *(&xmmword_1800925B0 + 1) = 0i64;
  }
  if ( qword_1800925C8 )
  {
    CMasterEccCurveInfo::Dereference(qword_1800925C8);
    qword_1800925C8 = 0i64;
  }
  word_1800925D0 = 0;
}
// 1800925D0: using guessed type __int16 word_1800925D0;

//----- (0000000180024FD0) ----------------------------------------------------
void __fastcall CCipherMill::DeleteProviderList(CCipherMill *this)
{
  __int64 i; // rdi

  for ( i = 0i64; (unsigned int)i < qword_180092498; i = (unsigned int)(i + 1) )
  {
    SslFreeObject(qword_1800924A0[i], 0i64);
    qword_1800924A0[i] = 0i64;
  }
  if ( qword_180092490 )
  {
    SslFreeBuffer();
    qword_180092490 = 0i64;
  }
  qword_180092498 = 0;
}
// 180092490: using guessed type __int64 qword_180092490;
// 1800924A0: using guessed type unsigned __int64 qword_1800924A0[32];
// 180098480: using guessed type __int64 SslFreeBuffer(void);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018002501C) ----------------------------------------------------
void __fastcall InitDebugTracingEx(
        const unsigned __int16 *a1,
        const unsigned __int16 *a2,
        struct _GUID *a3,
        const unsigned __int16 *a4)
{
  struct _RTL_CRITICAL_SECTION *SharedMem; // rax
  struct _RTL_CRITICAL_SECTION *v5; // rbx
  struct _DBG_TRACE_CONTROL_BLOCK **v6; // rcx
  struct _DBG_TRACE_CONTROL_BLOCK *v7; // rdi
  int SpinCount; // ecx
  unsigned int OwningThread_high; // esi
  struct _DBG_TRACE_CONTROL_BLOCK *v10; // rcx
  const unsigned __int16 *DueTime; // [rsp+20h] [rbp-28h]
  int Period; // [rsp+28h] [rbp-20h]
  struct _DBG_TRACE_CONTROL_BLOCK *v13; // [rsp+68h] [rbp+20h] BYREF

  v13 = 0i64;
  if ( (NtCurrentPeb()->BitField & 2) != 0 )
  {
    SchannelGlobalTraceControlBlock = 0i64;
    return;
  }
  if ( (((unsigned __int64)SchannelGlobalTraceControlBlock + 1) & 0xFFFFFFFFFFFFFFFEui64) == 0 )
  {
    if ( !(unsigned int)_DbgpCreateTraceControl(a1, a2, a3, a4, DueTime, Period, &v13)
      || (SharedMem = (struct _RTL_CRITICAL_SECTION *)_DbgpOpenOrCreateSharedMem(), (v5 = SharedMem) == 0i64) )
    {
      v10 = v13;
LABEL_9:
      if ( v10 )
        _DbgpDeleteTraceControl(v10);
      return;
    }
    EnterCriticalSection(SharedMem + 2);
    v6 = *(struct _DBG_TRACE_CONTROL_BLOCK ***)&v5[1].LockCount;
    if ( *v6 != (struct _DBG_TRACE_CONTROL_BLOCK *)&v5[1] )
      __fastfail(3u);
    v7 = v13;
    *(_QWORD *)v13 = v5 + 1;
    *((_QWORD *)v7 + 1) = v6;
    *v6 = v7;
    *(_QWORD *)&v5[1].LockCount = v7;
    ++LODWORD(v5->SpinCount);
    if ( v5[1].LockSemaphore )
      goto LABEL_7;
    if ( LOBYTE(v5[1].OwningThread) || IsDebuggerPresent() )
    {
      HIDWORD(v5[1].OwningThread) = 60;
      if ( CreateTimerQueueTimer(
             (PHANDLE)&v5[1].SpinCount,
             0i64,
             (WAITORTIMERCALLBACK)_DbgpTraceControllerTimerCallback,
             v5,
             0x2BF20u,
             0xEA60u,
             0) )
      {
        v5[1].LockSemaphore = _DbgpTraceControllerTimerCallback;
      }
      goto LABEL_8;
    }
    if ( v5[1].LockSemaphore )
    {
LABEL_7:
      SpinCount = v5->SpinCount;
      OwningThread_high = HIDWORD(v5[1].OwningThread);
      if ( OwningThread_high < 10 * SpinCount )
      {
        HIDWORD(v5[1].OwningThread) = 10 * (SpinCount + 6);
        if ( !ChangeTimerQueueTimer(0i64, (HANDLE)v5[1].SpinCount, 10000 * (SpinCount + 6), 10000 * (SpinCount + 6)) )
          HIDWORD(v5[1].OwningThread) = OwningThread_high;
      }
    }
LABEL_8:
    LeaveCriticalSection(v5 + 2);
    _DbgpRegistryChangeNotifycationCallback(*((void **)v7 + 29), 1u);
    v10 = 0i64;
    SchannelGlobalTraceControlBlock = v7;
    goto LABEL_9;
  }
}
// 18002506A: variable 'DueTime' is possibly undefined
// 18002506A: variable 'Period' is possibly undefined

//----- (0000000180025130) ----------------------------------------------------
void __fastcall SslWatchParamKey(char *a1)
{
  __int64 v1; // rbx
  LSTATUS v2; // eax
  int v3; // ecx

  v1 = *((_QWORD *)a1 + 2);
  v2 = WatchParamKeyHelper(a1);
  v3 = 0;
  if ( !v2 )
  {
    LOBYTE(v3) = v1 == 0;
    SslReadRegOptions(v3);
    NotifyWNFConfigChangeEvent(WNF_SCH_REGISTRY_RELOAD);
  }
}

//----- (000000018002516C) ----------------------------------------------------
__int64 __fastcall NotifyWNFConfigChangeEvent(struct _WNF_STATE_NAME a1)
{
  if ( g_fEnableConfigChangeNtf )
    ((void (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))RtlPublishWnfStateData)(a1, 0i64, 0i64, 0i64, 0i64);
  return 0i64;
}
// 180080E30: using guessed type __int64 __fastcall RtlPublishWnfStateData(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18009278C: using guessed type int g_fEnableConfigChangeNtf;

//----- (000000018002518C) ----------------------------------------------------
__int64 __fastcall SslReadRegOptions(int a1)
{
  LSTATUS v2; // eax
  HKEY v3; // rdx
  BOOL v4; // ebx
  __int64 v5; // r15
  __int64 v6; // r12
  unsigned int v7; // eax
  int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // ecx
  unsigned int v11; // ecx
  unsigned int v12; // eax
  unsigned int v13; // esi
  unsigned int v14; // edi
  LPCWSTR *v15; // r14
  LSTATUS v16; // eax
  HKEY v17; // rcx
  char *v18; // rdi
  int v19; // esi
  int v20; // eax
  const CHAR *v21; // rdx
  LSTATUS v22; // eax
  HKEY v23; // rcx
  char *v24; // rdi
  __int64 v25; // rsi
  int v26; // r14d
  int v27; // eax
  const CHAR *v28; // rdx
  LSTATUS v29; // eax
  HKEY v30; // rcx
  char *v31; // rdi
  int *v32; // rsi
  int v33; // r13d
  int v34; // edx
  char v36; // al
  CCipherMill *v37; // rcx
  int v38; // eax
  int v39; // eax
  int v40; // eax
  DWORD Type; // [rsp+30h] [rbp-28h] BYREF
  HKEY phkResult; // [rsp+38h] [rbp-20h] BYREF
  HKEY v43; // [rsp+40h] [rbp-18h] BYREF
  HKEY hKey; // [rsp+48h] [rbp-10h] BYREF
  unsigned int v46; // [rsp+A8h] [rbp+50h] BYREF
  int Data; // [rsp+B0h] [rbp+58h] BYREF
  DWORD cbData; // [rsp+B8h] [rbp+60h] BYREF

  phkResult = 0i64;
  v46 = 0;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_652d1bd98c7033c24f7b4105215d66be_Traceguids);
  v2 = RegOpenKeyExW(
         HKEY_LOCAL_MACHINE,
         L"System\\CurrentControlSet\\Control\\SecurityProviders\\Schannel",
         0,
         0x2001Bu,
         &hKey);
  v3 = hKey;
  if ( v2 )
    v3 = 0i64;
  hKey = v3;
  v4 = ReadRegistrySetting(::hKey, v3, L"EventLogging", (BYTE *)&g_dwEventLogging, 1u) != 0;
  if ( (unsigned int)ReadRegistrySetting(::hKey, 0i64, L"LogLevel", (BYTE *)&SchannelInfoLevel, 0) )
    v4 = 1;
  ReadRegistrySetting(::hKey, 0i64, L"ManualCredValidation", (BYTE *)&v46, 0);
  if ( (v46 != 0) != g_fManualCredValidation )
  {
    v4 = 1;
    g_fManualCredValidation = v46 != 0;
  }
  if ( (unsigned int)ReadRegistrySetting(
                       ::hKey,
                       0i64,
                       L"ClientCacheTime",
                       (BYTE *)&CSslGlobals::m_dwClientLifespan,
                       0x2255100u) )
    v4 = 1;
  if ( (unsigned int)ReadRegistrySetting(
                       ::hKey,
                       0i64,
                       L"ServerCacheTime",
                       (BYTE *)&CSslGlobals::m_dwServerLifespan,
                       0x2255100u) )
    v4 = 1;
  if ( (unsigned int)ReadRegistrySetting(
                       ::hKey,
                       0i64,
                       L"SessionTicketTime",
                       (BYTE *)&CSslGlobals::m_dwSessionTicketLifespan,
                       0x2255100u) )
    v4 = 1;
  if ( (unsigned int)ReadRegistrySetting(
                       ::hKey,
                       0i64,
                       L"SessionTicketTimeSkew",
                       (BYTE *)&CSslGlobals::m_dwSessionTicketTimeSkew,
                       0x493E0u) )
    v4 = 1;
  ReadRegistrySetting(::hKey, 0i64, L"DisableRenegoOnClient", (BYTE *)&v46, 0);
  CSslGlobals::m_fDisableRenegoOnClient = v46 != 0;
  ReadRegistrySetting(::hKey, 0i64, L"DisableRenegoOnServer", (BYTE *)&v46, 0);
  CSslGlobals::m_fDisableRenegoOnServer = v46 != 0;
  ReadRegistrySetting(::hKey, 0i64, L"MaximumCacheSize", (BYTE *)&CSslGlobals::m_dwMaximumEntries, 0x4E20u);
  ReadRegistrySetting(::hKey, 0i64, L"IgnoreExponentOfOne", (BYTE *)&v46, 0);
  if ( (v46 != 0) != g_fIgnoreExponentOfOne )
  {
    v4 = 1;
    g_fIgnoreExponentOfOne = v46 != 0;
  }
  ReadRegistrySetting(::hKey, 0i64, L"SendTrustedIssuerList", (BYTE *)&v46, 0);
  if ( (v46 != 0) != g_fSendIssuerList )
  {
    v4 = 1;
    g_fSendIssuerList = v46 != 0;
  }
  v5 = 14i64;
  v6 = 8i64;
  if ( (unsigned int)ReadRegistrySetting(
                       ::hKey,
                       0i64,
                       L"CertificateMappingMethods",
                       (BYTE *)&g_dwCertMappingMethods,
                       0x1Fu) )
  {
    v36 = g_dwCertMappingMethods;
    v4 = 1;
    if ( (g_dwCertMappingMethods & 1) == 0 )
    {
      v37 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
        goto LABEL_90;
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_652d1bd98c7033c24f7b4105215d66be_Traceguids);
      v36 = g_dwCertMappingMethods;
    }
    v37 = WPP_GLOBAL_Control;
LABEL_90:
    if ( (v36 & 2) == 0 && v37 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v37 + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)v37 + 2), 14i64, &WPP_652d1bd98c7033c24f7b4105215d66be_Traceguids);
      v37 = WPP_GLOBAL_Control;
      v36 = g_dwCertMappingMethods;
    }
    if ( (v36 & 4) == 0 && v37 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v37 + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)v37 + 2), 15i64, &WPP_652d1bd98c7033c24f7b4105215d66be_Traceguids);
      v37 = WPP_GLOBAL_Control;
      v36 = g_dwCertMappingMethods;
    }
    if ( (v36 & 8) == 0 && v37 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v37 + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)v37 + 2), 16i64, &WPP_652d1bd98c7033c24f7b4105215d66be_Traceguids);
      v37 = WPP_GLOBAL_Control;
      v36 = g_dwCertMappingMethods;
    }
    if ( (v36 & 0x10) == 0 && v37 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v37 + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)v37 + 2), 17i64, &WPP_652d1bd98c7033c24f7b4105215d66be_Traceguids);
  }
  if ( hKey )
  {
    RegCloseKey(hKey);
    hKey = 0i64;
  }
  ReadRegistrySetting(::hKey, 0i64, L"IssuerCacheTime", (BYTE *)&dword_1800926F8, 0x927C0u);
  ReadRegistrySetting(::hKey, 0i64, L"IssuerCacheSize", (BYTE *)&dword_180092700, 0x64u);
  v7 = dword_1800926FC;
  if ( a1 )
    v7 = dword_180092700;
  dword_1800926FC = v7;
  ReadRegistrySetting(
    ::hKey,
    0i64,
    L"MaxEncryptedRecordsBeforeKeyUpdate",
    (BYTE *)&CSslGlobals::m_dwMaxEncryptedRecords,
    0x16A09E6u);
  v8 = CSslGlobals::m_dwMaxEncryptedRecords;
  if ( CSslGlobals::m_dwMaxEncryptedRecords > 0x16A09E6 )
    v8 = 23726566;
  CSslGlobals::m_dwMaxEncryptedRecords = v8;
  ReadRegistrySetting(::hKey, 0i64, L"AllowInsecureRenegoClients", (BYTE *)&v46, 1u);
  g_fAllowInsecureRenegoClients = v46 != 0;
  ReadRegistrySetting(::hKey, 0i64, L"AllowInsecureRenegoServers", (BYTE *)&v46, 1u);
  g_fAllowInsecureRenegoServers = v46 != 0;
  ReadRegistrySetting(::hKey, 0i64, L"EnableOcspStaplingForSni", (BYTE *)&v46, 0);
  g_fEnableOcspForSni = v46 != 0;
  ReadRegistrySetting(::hKey, 0i64, L"DisableOcspStapling", (BYTE *)&v46, 0);
  g_fDisableOcsp = v46 != 0;
  if ( a1 )
    ReadOcspReadDirectoryRegistrySetting(::hKey);
  ReadRegistrySetting(::hKey, 0i64, L"ClientAuthTrustMode", (BYTE *)&v46, 0);
  v9 = g_eClientAuthMode;
  if ( v46 < 3 )
    v9 = v46;
  g_eClientAuthMode = v9;
  if ( (unsigned int)ReadRegistrySetting(
                       ::hKey,
                       0i64,
                       L"CleanupPeriod",
                       (BYTE *)&CSslGlobals::m_dwCleanupIntervalInSeconds,
                       0x12Cu) )
  {
    CSslGlobals::CleanupPeriodicCleanupHandler();
    CSslGlobals::InitializePeriodicCleanupHandler();
  }
  ReadRegistrySetting(::hKey, 0i64, L"SendExtraRecord", (BYTE *)&v46, 0);
  v10 = v46;
  if ( v46 - 1 > 1 )
    v10 = 0;
  CSslGlobals::m_bSendAuxRecord = v10;
  ReadRegistrySetting(::hKey, 0i64, L"EnableConfigChangeNotification", (BYTE *)&v46, 0);
  g_fEnableConfigChangeNtf = v46 != 0;
  ReadRegistrySetting(::hKey, 0i64, L"HelloVerifyRequestEnabled", (BYTE *)&v46, 1u);
  g_fEnableHelloVerifyRequest = v46 != 0;
  ReadRegistrySetting(::hKey, 0i64, L"HelloRetryRequestEnabled", (BYTE *)&v46, 0);
  g_fEnableHelloRetryRequest = v46 != 0;
  ReadRegistrySetting(::hKey, 0i64, L"EnableSessionTicket", (BYTE *)&v46, 0);
  v11 = v46;
  if ( v46 - 1 > 1 )
    v11 = 0;
  CSslGlobals::m_dwEnableSessionTicket = v11;
  WinSqmSetDWORD(0i64, 12709i64);
  ReadRegistrySetting(::hKey, 0i64, L"DisableClientExtendedMasterSecret", (BYTE *)&v46, 0);
  CSslGlobals::m_fDisableClientExtendedMS = v46 != 0;
  ReadRegistrySetting(::hKey, 0i64, L"DisableServerExtendedMasterSecret", (BYTE *)&v46, 0);
  CSslGlobals::m_fDisableServerExtendedMS = v46 != 0;
  ReadRegistrySetting(::hKey, 0i64, L"MachineID", (BYTE *)&v46, 0xFFFFFFFF);
  v12 = _byteswap_ulong(v46);
  v46 = v12;
  if ( v12 != g_SslMachineID )
  {
    g_SslMachineID = v12;
    v4 = 1;
  }
  v13 = 1074741184;
  v14 = 48;
  if ( RegOpenKeyExW(::hKey, L"Protocols", 0, 0x20019u, &phkResult) )
  {
    CSslGlobals::m_ProtEnabled = 1074741184;
  }
  else
  {
    v15 = (LPCWSTR *)&unk_18007F098;
    do
    {
      if ( !RegOpenKeyExW(phkResult, *(v15 - 1), 0, 0x20019u, &v43) )
      {
        cbData = 4;
        if ( !RegQueryValueExW(v43, L"Enabled", 0i64, &Type, (LPBYTE)&Data, &cbData) )
        {
          v38 = *(_DWORD *)v15;
          if ( Data )
            v13 |= v38;
          else
            v13 &= ~v38;
        }
        cbData = 4;
        if ( !RegQueryValueExW(v43, L"DisabledByDefault", 0i64, &Type, (LPBYTE)&Data, &cbData) )
        {
          v39 = *(_DWORD *)v15;
          if ( Data )
            v14 |= v39;
          else
            v14 &= ~v39;
        }
        RegCloseKey(v43);
      }
      v15 += 2;
      --v5;
    }
    while ( v5 );
    RegCloseKey(phkResult);
    if ( CSslGlobals::m_ProtEnabled != v13 )
    {
      CSslGlobals::m_ProtEnabled = v13;
      v4 = 1;
    }
    if ( CSslGlobals::m_ProtDisabledByDefault == v14 )
      goto LABEL_48;
    v4 = 1;
  }
  CSslGlobals::m_ProtDisabledByDefault = v14;
LABEL_48:
  v16 = RegOpenKeyExW(::hKey, L"Ciphers", 0, 0x20019u, &phkResult);
  v17 = phkResult;
  v18 = (char *)&unk_1800910E4;
  if ( v16 )
    v17 = 0i64;
  phkResult = v17;
  do
  {
    v19 = *((_DWORD *)v18 - 1);
    v20 = *(_DWORD *)v18;
    *((_DWORD *)v18 - 1) = *(_DWORD *)v18;
    if ( v17 )
    {
      v21 = *(const CHAR **)(v18 + 12);
      Data = v20;
      if ( !RegOpenKeyExA(v17, v21, 0, 0x20019u, &v43) )
      {
        cbData = 4;
        if ( RegQueryValueExW(v43, L"Enabled", 0i64, &Type, (LPBYTE)&Data, &cbData) )
          Data = *(_DWORD *)v18;
        RegCloseKey(v43);
      }
      v20 = Data & *((_DWORD *)v18 + 1);
      v17 = phkResult;
      *((_DWORD *)v18 - 1) = v20;
    }
    if ( v20 != v19 )
      v4 = 1;
    v18 += 56;
    --v6;
  }
  while ( v6 );
  if ( v17 )
    RegCloseKey(v17);
  v22 = RegOpenKeyExW(::hKey, L"Hashes", 0, 0x20019u, &phkResult);
  v23 = phkResult;
  v24 = (char *)&g_AvailableHashes;
  v25 = 5i64;
  if ( v22 )
    v23 = 0i64;
  phkResult = v23;
  do
  {
    v26 = *(_DWORD *)v24;
    v27 = *((_DWORD *)v24 + 1);
    *(_DWORD *)v24 = v27;
    if ( v23 )
    {
      v28 = (const CHAR *)*((_QWORD *)v24 + 1);
      Data = v27;
      if ( !RegOpenKeyExA(v23, v28, 0, 0x20019u, &v43) )
      {
        cbData = 4;
        if ( RegQueryValueExW(v43, L"Enabled", 0i64, &Type, (LPBYTE)&Data, &cbData) )
          Data = *((_DWORD *)v24 + 1);
        RegCloseKey(v43);
      }
      v27 = Data & *(_DWORD *)v24;
      v23 = phkResult;
      *(_DWORD *)v24 = v27;
    }
    if ( v26 != v27 )
      v4 = 1;
    v24 += 40;
    --v25;
  }
  while ( v25 );
  if ( v23 )
    RegCloseKey(v23);
  v29 = RegOpenKeyExW(::hKey, L"KeyExchangeAlgorithms", 0, 0x20019u, &phkResult);
  v30 = phkResult;
  v31 = (char *)&unk_1800914C8;
  if ( v29 )
    v30 = 0i64;
  phkResult = v30;
  do
  {
    v32 = (int *)(v31 + 40);
    v33 = *((_DWORD *)v31 - 1);
    v34 = *(_DWORD *)v31;
    *((_DWORD *)v31 + 6) = *((_DWORD *)v31 + 7);
    *((_DWORD *)v31 + 8) = *((_DWORD *)v31 + 9);
    *((_DWORD *)v31 + 10) = *((_DWORD *)v31 + 11);
    *((_DWORD *)v31 + 12) = *((_DWORD *)v31 + 13);
    *((_DWORD *)v31 - 1) = v34;
    if ( !v30 )
      goto LABEL_76;
    Data = v34;
    if ( !RegOpenKeyExA(v30, *((LPCSTR *)v31 + 1), 0, 0x20019u, &v43) )
    {
      ReadRegistrySetting(v43, 0i64, L"Enabled", (BYTE *)&Data, *(_DWORD *)v31);
      ReadRegistrySetting(v43, 0i64, L"ClientMinKeyBitLength", (BYTE *)v31 + 24, *((_DWORD *)v31 + 7));
      ReadRegistrySetting(v43, 0i64, L"ClientMaxKeyBitLength", (BYTE *)v31 + 32, *((_DWORD *)v31 + 9));
      ReadRegistrySetting(v43, 0i64, L"ServerMinKeyBitLength", (BYTE *)v31 + 40, *((_DWORD *)v31 + 11));
      if ( *((_DWORD *)v31 - 2) == 43522 )
      {
        v40 = 1024;
        if ( (unsigned int)*v32 > 0x400 )
        {
          v40 = 2048;
          if ( (unsigned int)*v32 > 0x800 )
          {
            v40 = 4096;
            if ( (unsigned int)*v32 <= 0xC00 )
              v40 = 3072;
          }
        }
        *v32 = v40;
      }
      else if ( *((_DWORD *)v31 - 2) != 44550 )
      {
LABEL_132:
        RegCloseKey(v43);
        goto LABEL_75;
      }
      ReadRegistrySetting(v43, 0i64, L"EphemKeyReuseTime", (BYTE *)v31 + 48, *((_DWORD *)v31 + 13));
      goto LABEL_132;
    }
LABEL_75:
    *((_DWORD *)v31 - 1) &= Data;
    v34 = *((_DWORD *)v31 - 1);
    v30 = phkResult;
LABEL_76:
    if ( v33 != v34 )
      v4 = 1;
    v31 += 64;
  }
  while ( v31 - 8 < SpTable );
  if ( v30 )
    RegCloseKey(v30);
  if ( !RegOpenKeyExW(::hKey, L"Messaging", 0, 0x20019u, &phkResult) )
  {
    ReadRegistrySetting(
      phkResult,
      0i64,
      L"MessageLimitClient",
      (BYTE *)&CSslGlobals::m_dwTlsMessageLimitClient,
      0x8000u);
    ReadRegistrySetting(phkResult, 0i64, L"MessageLimitServer", (BYTE *)&CSslGlobals::m_dwTlsMessageLimitSrv, 0x4000u);
    ReadRegistrySetting(
      phkResult,
      0i64,
      L"MessageLimitServerClientAuth",
      (BYTE *)&CSslGlobals::m_dwTlsMessageLimitSrvClientAuth,
      0x8000u);
    RegCloseKey(phkResult);
  }
  if ( !a1 && v4 && CSessionCacheManager::m_pSessionCacheManager )
    CSessionCacheManager::PurgeCacheEntries(CSessionCacheManager::m_pSessionCacheManager, 0x30000u, 0i64, 0, 0i64);
  return 1i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080E38: using guessed type __int64 __fastcall WinSqmSetDWORD(_QWORD, _QWORD);
// 1800919A4: using guessed type int g_fEnableHelloVerifyRequest;
// 1800919A8: using guessed type int g_fAllowInsecureRenegoServers;
// 1800919AC: using guessed type int g_fAllowInsecureRenegoClients;
// 1800919F4: using guessed type unsigned int g_SslMachineID;
// 1800919F8: using guessed type unsigned int CSslGlobals::m_ProtEnabled;
// 1800919FC: using guessed type unsigned int CSslGlobals::m_ProtDisabledByDefault;
// 1800926FC: using guessed type int dword_1800926FC;
// 18009278C: using guessed type int g_fEnableConfigChangeNtf;
// 1800927A0: using guessed type int g_fEnableHelloRetryRequest;
// 1800927A4: using guessed type int g_fDisableOcsp;
// 1800927A8: using guessed type int g_fEnableOcspForSni;
// 1800927B0: using guessed type unsigned int CSslGlobals::m_dwEnableSessionTicket;
// 1800927B4: using guessed type int CSslGlobals::m_fDisableServerExtendedMS;
// 1800927B8: using guessed type int CSslGlobals::m_fDisableClientExtendedMS;
// 1800927BC: using guessed type unsigned int CSslGlobals::m_bSendAuxRecord;
// 1800927C0: using guessed type int CSslGlobals::m_fDisableRenegoOnServer;
// 1800927C4: using guessed type int CSslGlobals::m_fDisableRenegoOnClient;
// 180092F04: using guessed type int g_fManualCredValidation;
// 180092F08: using guessed type int g_fSendIssuerList;
// 180092F1C: using guessed type int g_fIgnoreExponentOfOne;

//----- (0000000180025AD4) ----------------------------------------------------
__int64 __fastcall ReadRegistrySetting(HKEY a1, HKEY a2, const unsigned __int16 *a3, BYTE *lpData, unsigned int a5)
{
  int v5; // ebp
  unsigned int v9; // ebx
  DWORD v11[10]; // [rsp+30h] [rbp-28h] BYREF
  DWORD v12; // [rsp+78h] [rbp+20h] BYREF

  v5 = *(_DWORD *)lpData;
  v12 = 4;
  v9 = 0;
  if ( RegQueryValueExW(a1, a3, 0i64, v11, lpData, &v12) )
  {
    *(_DWORD *)lpData = a5;
    if ( a2 )
      RegSetValueExW(a2, a3, 0, 4u, lpData, 4u);
  }
  LOBYTE(v9) = v5 != *(_DWORD *)lpData;
  return v9;
}
// 180025AD4: using guessed type DWORD anonymous_0[10];

//----- (0000000180025B58) ----------------------------------------------------
__int64 __fastcall _DbgpCreateTraceControl(
        const unsigned __int16 *a1,
        const unsigned __int16 *a2,
        struct _GUID *a3,
        const unsigned __int16 *a4,
        const unsigned __int16 *a5,
        int a6,
        struct _DBG_TRACE_CONTROL_BLOCK **a7)
{
  char *Heap; // rax
  unsigned int v8; // esi
  char *v9; // rdi
  int v10; // eax
  HMODULE ModuleHandleW; // rax
  LSTATUS v12; // ebx
  struct _RTL_CRITICAL_SECTION *SharedMem; // rax
  struct _RTL_CRITICAL_SECTION *v14; // rbp
  PRTL_CRITICAL_SECTION_DEBUG DebugInfo; // rdx
  HANDLE EventW; // rax
  __int64 v17; // rax
  DWORD LastError; // eax
  struct _UNICODE_STRING DestinationString; // [rsp+30h] [rbp-238h] BYREF
  WCHAR Filename[264]; // [rsp+40h] [rbp-228h] BYREF

  Heap = (char *)RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, 0, 0xF0ui64);
  v8 = 0;
  v9 = Heap;
  if ( !Heap )
  {
    v12 = 14;
    goto LABEL_14;
  }
  memset_0(Heap, 0, 0xF0ui64);
  InitializeCriticalSection((LPCRITICAL_SECTION)(v9 + 192));
  *((_DWORD *)v9 + 4) = 1937339236;
  *((_DWORD *)v9 + 5) = 1819440227;
  RtlInitUnicodeString(&DestinationString, L"schannel");
  if ( (DestinationString.Length & 0xFFFEu) >= 0x104 )
  {
    v12 = 87;
    goto LABEL_21;
  }
  v10 = RtlDuplicateUnicodeString(3u, &DestinationString, (PUNICODE_STRING)(v9 + 56));
  if ( v10 < 0 )
    goto LABEL_17;
  Filename[260] = 0;
  ModuleHandleW = GetModuleHandleW(L"schannel.dll");
  if ( !ModuleHandleW || !GetModuleFileNameW(ModuleHandleW, Filename, 0x104u) )
  {
LABEL_19:
    LastError = GetLastError();
    goto LABEL_20;
  }
  RtlInitUnicodeString(&DestinationString, Filename);
  v10 = RtlDuplicateUnicodeString(3u, &DestinationString, (PUNICODE_STRING)(v9 + 40));
  if ( v10 < 0 )
  {
LABEL_17:
    LastError = RtlNtStatusToDosError(v10);
LABEL_20:
    v12 = LastError;
    goto LABEL_21;
  }
  v12 = RegOpenKeyExW(
          HKEY_LOCAL_MACHINE,
          L"System\\CurrentControlSet\\Control\\SecurityProviders\\Schannel",
          0,
          0x2000000u,
          (PHKEY)v9 + 21);
  if ( v12 )
  {
LABEL_21:
    _DbgpDeleteTraceControl((struct _DBG_TRACE_CONTROL_BLOCK *)v9);
    goto LABEL_14;
  }
  RtlInitUnicodeString((PUNICODE_STRING)v9 + 11, L"LogLevel");
  *((_QWORD *)v9 + 18) = _DbgpTraceControllerTimerCallback;
  *((_OWORD *)v9 + 7) = SchannelTracingGuid;
  SharedMem = (struct _RTL_CRITICAL_SECTION *)_DbgpOpenOrCreateSharedMem();
  v14 = SharedMem;
  if ( !SharedMem )
  {
    v12 = 1168;
    goto LABEL_21;
  }
  EnterCriticalSection(SharedMem + 2);
  DebugInfo = v14[3].DebugInfo;
  v14[3].DebugInfo = (PRTL_CRITICAL_SECTION_DEBUG)((char *)&DebugInfo->Type + 1);
  *((_QWORD *)v9 + 29) = DebugInfo;
  LeaveCriticalSection(v14 + 2);
  if ( LOBYTE(v14[1].OwningThread) )
    *((_DWORD *)v9 + 8) = 3;
  *((_QWORD *)v9 + 17) = _DbgpTraceTimerCallback;
  EventW = CreateEventW(0i64, 0, 0, 0i64);
  *((_QWORD *)v9 + 19) = EventW;
  if ( !EventW )
    goto LABEL_19;
  v17 = RegisterWaitForSingleObjectEx(
          EventW,
          _DbgpRegistryChangeNotifycationCallback,
          *((_QWORD *)v9 + 29),
          0xFFFFFFFFi64,
          128);
  *((_QWORD *)v9 + 20) = v17;
  if ( !v17 )
    goto LABEL_19;
  NtQuerySystemTime((PLARGE_INTEGER)v9 + 3);
  *a7 = (struct _DBG_TRACE_CONTROL_BLOCK *)v9;
  v12 = 0;
LABEL_14:
  LOBYTE(v8) = v12 == 0;
  return v8;
}
// 180080BC0: using guessed type __int64 __fastcall RegisterWaitForSingleObjectEx(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180081F98: using guessed type __int128 SchannelTracingGuid;

//----- (0000000180025E40) ----------------------------------------------------
__int64 __fastcall SpGetExtendedInformation(int a1, __int64 *a2)
{
  __int64 v3; // rax
  __int64 v4; // rbx
  const WCHAR *v5; // rdi
  UINT SystemWow64DirectoryW; // eax
  unsigned int v7; // edi
  __int64 result; // rax
  __int64 v9; // rax

  if ( a1 != 2 )
  {
    if ( a1 != 4 )
    {
      v7 = -2146893054;
      v4 = 0i64;
      goto LABEL_8;
    }
    v3 = (*(__int64 (__fastcall **)(__int64))(LsaTable + 40))(576i64);
    v4 = v3;
    if ( !v3 )
    {
      v7 = -1073741670;
      goto LABEL_8;
    }
    v5 = (const WCHAR *)(v3 + 56);
    SystemWow64DirectoryW = GetSystemWow64DirectoryW((LPWSTR)(v3 + 56), 0x104u);
    if ( SystemWow64DirectoryW )
    {
      if ( (unsigned __int64)(SystemWow64DirectoryW + 1) + 12 < 0x104 )
      {
        _o_wcscat_s(v5, 260i64, L"\\");
        _o_wcscat_s(v5, 260i64, L"schannel.dll");
        *(_DWORD *)v4 = 4;
        RtlInitUnicodeString((PUNICODE_STRING)(v4 + 8), v5);
        goto LABEL_7;
      }
      v7 = -1073741670;
    }
    else
    {
      v7 = -2146893054;
    }
    (*(void (__fastcall **)(__int64))(LsaTable + 48))(v4);
    goto LABEL_8;
  }
  v9 = (*(__int64 (__fastcall **)(__int64))(LsaTable + 40))(104i64);
  v4 = v9;
  if ( !v9 )
  {
    v7 = -2146893056;
    goto LABEL_8;
  }
  *(_DWORD *)v9 = 2;
  *(_DWORD *)(v9 + 8) = 12;
  *(_OWORD *)(v9 + 12) = xmmword_180083D20;
  *(_OWORD *)(v9 + 28) = xmmword_180083D30;
  *(_OWORD *)(v9 + 44) = xmmword_180083D40;
LABEL_7:
  v7 = 0;
LABEL_8:
  result = v7;
  *a2 = v4;
  return result;
}
// 180080C68: using guessed type __int64 __fastcall _o_wcscat_s(_QWORD, _QWORD, _QWORD);
// 180083D20: using guessed type __int128 xmmword_180083D20;
// 180083D30: using guessed type __int128 xmmword_180083D30;
// 180083D40: using guessed type __int128 xmmword_180083D40;
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180025F94) ----------------------------------------------------
NTSTATUS __fastcall _DbgpWaitForControllerEvent(int *a1, void **a2)
{
  wchar_t *TraceMappingName; // rax
  NTSTATUS result; // eax
  void *v6; // rcx
  union _LARGE_INTEGER Timeout; // [rsp+30h] [rbp-D0h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+38h] [rbp-C8h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+48h] [rbp-B8h] BYREF
  wchar_t Buffer[264]; // [rsp+80h] [rbp-80h] BYREF

  DestinationString = 0i64;
  *a1 = 0;
  Buffer[259] = 0;
  TraceMappingName = _DbgpGetTraceMappingName();
  snwprintf_s(Buffer, 0x104ui64, 0x103ui64, L"\\DSYSDBG.%s", TraceMappingName);
  RtlInitUnicodeString(&DestinationString, Buffer);
  ObjectAttributes.Length = 48;
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 0;
  *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0i64;
  result = NtCreateEvent(a2, 0x100002u, &ObjectAttributes, NotificationEvent, 0);
  if ( result == -1073741771 || result == 0x40000000 )
  {
    result = NtOpenEvent(a2, 0x100000u, &ObjectAttributes);
    if ( result >= 0 )
    {
      v6 = *a2;
      Timeout.QuadPart = -600000000i64;
      result = NtWaitForSingleObject(v6, 0, &Timeout);
      if ( result )
      {
        if ( result >= 0 )
          return -1073741823;
      }
      else
      {
        *a1 = 1;
      }
    }
  }
  return result;
}

//----- (00000001800260E0) ----------------------------------------------------
void __fastcall _DbgpRegistryChangeNotifycationCallback(void *a1, unsigned __int8 a2)
{
  int v2; // r14d
  struct _RTL_CRITICAL_SECTION *SharedMem; // rax
  struct _RTL_CRITICAL_SECTION *v5; // rbx
  struct _RTL_CRITICAL_SECTION *v6; // rsi
  struct _RTL_CRITICAL_SECTION *v7; // rbx
  PRTL_CRITICAL_SECTION_DEBUG i; // rdi

  v2 = a2;
  SharedMem = (struct _RTL_CRITICAL_SECTION *)_DbgpOpenOrCreateSharedMem();
  v5 = SharedMem;
  if ( SharedMem )
  {
    v6 = SharedMem + 2;
    EnterCriticalSection(SharedMem + 2);
    v7 = v5 + 1;
    for ( i = v7->DebugInfo; i != (PRTL_CRITICAL_SECTION_DEBUG)v7; i = *(PRTL_CRITICAL_SECTION_DEBUG *)&i->Type )
    {
      if ( *(void **)&i[4].Flags == a1 )
      {
        EnterCriticalSection((LPCRITICAL_SECTION)&i[4]);
        _DbgpControlTracingThroughRegistry((struct _DBG_TRACE_CONTROL_BLOCK *)i, v2);
        RegNotifyChangeKeyValue((HKEY)i[3].ProcessLocksList.Blink, 0, 4u, i[3].CriticalSection, 1);
        LeaveCriticalSection((LPCRITICAL_SECTION)&i[4]);
        break;
      }
    }
    LeaveCriticalSection(v6);
  }
}

//----- (00000001800261CC) ----------------------------------------------------
__int64 __fastcall _DbgpControlTracingThroughRegistry(struct _DBG_TRACE_CONTROL_BLOCK *a1, int a2)
{
  LSTATUS v4; // eax
  unsigned int v5; // edi
  DWORD v7; // [rsp+50h] [rbp+8h] BYREF
  DWORD v8; // [rsp+60h] [rbp+18h] BYREF
  unsigned int v9; // [rsp+68h] [rbp+20h] BYREF

  v7 = 4;
  v4 = RegQueryValueExW(*((HKEY *)a1 + 21), *((LPCWSTR *)a1 + 23), 0i64, &v8, (LPBYTE)&v9, &v7);
  v5 = v4;
  if ( v4 == 2 )
  {
    return 0;
  }
  else if ( !v4 )
  {
    if ( v7 >= 4 && v8 == 4 )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)((char *)a1 + 192));
      v5 = _DbgpControlTracing(a1, v9, a2);
      LeaveCriticalSection((LPCRITICAL_SECTION)((char *)a1 + 192));
    }
    else
    {
      return 1169;
    }
  }
  return v5;
}

//----- (000000018002623C) ----------------------------------------------------
struct _DBG_TCB_HEADER *_DbgpOpenOrCreateSharedMem(void)
{
  HANDLE FileMappingW; // rdi
  struct _DBG_TCB_HEADER **v1; // rbx
  wchar_t *TraceMappingName; // rax
  const WCHAR *v3; // rsi
  HANDLE v5; // rax
  struct _DBG_TCB_HEADER **v6; // rax
  struct _DBG_TCB_HEADER *v7; // rcx
  wchar_t *lpName; // rax
  struct _DBG_TCB_HEADER **v9; // rax
  struct _RTL_CRITICAL_SECTION *v10; // rax
  struct _RTL_CRITICAL_SECTION *v11; // rsi
  struct _SYSTEM_INFO SystemInfo; // [rsp+30h] [rbp-30h] BYREF
  int v13; // [rsp+80h] [rbp+20h] BYREF
  LONG PreviousState; // [rsp+88h] [rbp+28h] BYREF
  HANDLE Handle; // [rsp+90h] [rbp+30h] BYREF

  FileMappingW = 0i64;
  v1 = 0i64;
  Handle = 0i64;
  TraceMappingName = _DbgpGetTraceMappingName();
  v13 = 0;
  v3 = TraceMappingName;
  if ( !DbgpGlobalControllerHeader )
  {
    if ( _DbgpWaitForControllerEvent(&v13, &Handle) >= 0 )
    {
      GetSystemInfo(&SystemInfo);
      if ( v13 )
      {
        v5 = OpenFileMappingW(0xF001Fu, 0, v3);
        FileMappingW = v5;
        if ( v5 )
        {
          v6 = (struct _DBG_TCB_HEADER **)MapViewOfFileEx(v5, 6u, 0, 0, SystemInfo.dwAllocationGranularity, 0i64);
          v1 = v6;
          if ( v6 )
          {
            v7 = (struct _DBG_TCB_HEADER *)v6;
            if ( v6 != (struct _DBG_TCB_HEADER **)v6[1] )
              v7 = v6[1];
            DbgpGlobalControllerHeader = v7;
          }
        }
      }
      else
      {
        lpName = _DbgpGetTraceMappingName();
        FileMappingW = CreateFileMappingW(
                         (HANDLE)0xFFFFFFFFFFFFFFFFi64,
                         0i64,
                         0x4000004u,
                         0,
                         SystemInfo.dwAllocationGranularity,
                         lpName);
        if ( FileMappingW )
        {
          v9 = (struct _DBG_TCB_HEADER **)MapViewOfFileEx(
                                            FileMappingW,
                                            6u,
                                            0,
                                            0,
                                            SystemInfo.dwAllocationGranularity,
                                            0i64);
          v1 = v9;
          if ( v9 )
          {
            v10 = (struct _RTL_CRITICAL_SECTION *)VirtualAlloc(v9, SystemInfo.dwPageSize, 0x1000u, 4u);
            v11 = v10;
            if ( v10 )
            {
              memset_0(v10, 0, 0x80ui64);
              LODWORD(v11->DebugInfo) = 1819440227;
              *(_QWORD *)&v11[1].LockCount = v11 + 1;
              v11[1].DebugInfo = (PRTL_CRITICAL_SECTION_DEBUG)&v11[1];
              *(_QWORD *)&v11->LockCount = v11;
              NtQuerySystemInformation(SystemKernelDebuggerInformation, &v11[1].OwningThread, 2u, 0i64);
              InitializeCriticalSection(v11 + 2);
              if ( NtSetEvent(Handle, &PreviousState) >= 0 )
              {
                v1 = 0i64;
                v11->LockSemaphore = Handle;
                Handle = 0i64;
                v11->OwningThread = FileMappingW;
                FileMappingW = 0i64;
                v11[1].SpinCount = 0i64;
                DbgpGlobalControllerHeader = (struct _DBG_TCB_HEADER *)v11;
              }
            }
          }
        }
      }
    }
    if ( Handle )
      NtClose(Handle);
    if ( v1 )
      UnmapViewOfFile(v1);
    if ( FileMappingW )
      CloseHandle(FileMappingW);
  }
  return DbgpGlobalControllerHeader;
}
// 180092810: using guessed type struct _DBG_TCB_HEADER *DbgpGlobalControllerHeader;

//----- (0000000180026354) ----------------------------------------------------
wchar_t *_DbgpGetTraceMappingName(void)
{
  DWORD CurrentProcessId; // [rsp+20h] [rbp-18h]

  if ( !Buffer )
  {
    word_180092A26 = 0;
    CurrentProcessId = GetCurrentProcessId();
    snwprintf_s(&Buffer, 0x104ui64, 0x103ui64, L"Debug.Trace.Memory.%x", CurrentProcessId);
  }
  return &Buffer;
}
// 180092A26: using guessed type __int16 word_180092A26;

//----- (00000001800263AC) ----------------------------------------------------
void __fastcall ReadOcspReadDirectoryRegistrySetting(HKEY hKey)
{
  HLOCAL lpData; // rbx
  SIZE_T uBytes; // [rsp+48h] [rbp+10h] BYREF
  DWORD Type; // [rsp+50h] [rbp+18h] BYREF

  LODWORD(uBytes) = 0;
  Type = 0;
  if ( !RegQueryValueExW(hKey, L"OcspReadDirectory", 0i64, &Type, 0i64, (LPDWORD)&uBytes) )
  {
    if ( (_DWORD)uBytes )
    {
      if ( Type == 1 )
      {
        lpData = LocalAlloc(0x40u, (unsigned int)uBytes);
        if ( lpData )
        {
          if ( RegQueryValueExW(hKey, L"OcspReadDirectory", 0i64, &Type, (LPBYTE)lpData, (LPDWORD)&uBytes) )
            LocalFree(lpData);
          else
            g_pszOcspReadDirectory = lpData;
        }
      }
    }
  }
}

//----- (0000000180026410) ----------------------------------------------------
void __fastcall UserMappingsWatchParamKey(HKEY *a1)
{
  BYTE *lpData; // rax
  BYTE *v3; // rax
  DWORD cbData; // [rsp+40h] [rbp+8h] BYREF
  DWORD Type; // [rsp+50h] [rbp+18h] BYREF

  cbData = 0;
  if ( !WatchParamKeyHelper((char *)a1) )
  {
    lpData = g_pszDomainList;
    if ( g_pszDomainList )
    {
      LocalFree(g_pszDomainList);
      lpData = 0i64;
      g_pszDomainList = 0i64;
    }
    if ( !RegQueryValueExW(a1[2], L"UserMappingSafeDomains", 0i64, &Type, lpData, &cbData) )
    {
      if ( cbData )
      {
        if ( Type == 1 )
        {
          v3 = (BYTE *)LocalAlloc(0x40u, cbData);
          g_pszDomainList = v3;
          if ( v3 )
          {
            if ( RegQueryValueExW(a1[2], L"UserMappingSafeDomains", 0i64, &Type, v3, &cbData) )
            {
              LocalFree(g_pszDomainList);
              g_pszDomainList = 0i64;
            }
          }
        }
      }
    }
  }
}

//----- (000000018002647C) ----------------------------------------------------
LSTATUS __fastcall WatchParamKeyHelper(char *pvContext)
{
  HKEY *v2; // rdi
  LSTATUS result; // eax
  LSTATUS v4; // edi
  NTSTATUS v5; // eax
  DWORD v6; // [rsp+60h] [rbp+8h] BYREF

  if ( !pvContext )
    return 0;
  v2 = (HKEY *)(pvContext + 16);
  if ( *((_QWORD *)pvContext + 2)
    || (result = RegCreateKeyExW(
                   HKEY_LOCAL_MACHINE,
                   *((LPCWSTR *)pvContext + 3),
                   0,
                   (LPWSTR)&Class,
                   0,
                   0x20019u,
                   0i64,
                   v2,
                   &v6)) == 0 )
  {
    v4 = RegNotifyChangeKeyValue(*v2, 1, 0x10000005u, *((HANDLE *)pvContext + 1), 1);
    if ( !*(_QWORD *)pvContext || (v5 = RtlDeregisterWait(*(HANDLE *)pvContext), *(_QWORD *)pvContext = 0i64, v5 >= 0) )
    {
      if ( !v4 )
        RtlRegisterWait(
          (PHANDLE)pvContext,
          *((HANDLE *)pvContext + 1),
          *((WAITORTIMERCALLBACKFUNC *)pvContext + 4),
          pvContext,
          0xFFFFFFFF,
          0x48u);
    }
    return 0;
  }
  return result;
}

//----- (0000000180026560) ----------------------------------------------------
void __fastcall FipsWatchParamKey(char *a1, char a2)
{
  CCipherMill *v3; // rcx
  BOOLEAN pfEnabled; // [rsp+40h] [rbp+18h] BYREF

  pfEnabled = 0;
  if ( !WatchParamKeyHelper(a1) )
  {
    if ( BCryptGetFipsAlgorithmMode(&pfEnabled) < 0 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_652d1bd98c7033c24f7b4105215d66be_Traceguids);
    }
    else if ( pfEnabled != CSslGlobals::m_bFipsMode )
    {
      CSslGlobals::m_bFipsMode = pfEnabled;
      if ( !a2 )
        CCipherMill::BuildCipherMill(v3);
    }
  }
}
// 18002B67A: variable 'v3' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180092F18: using guessed type int CSslGlobals::m_bFipsMode;

//----- (00000001800265B0) ----------------------------------------------------
__int64 __fastcall CCipherMill::InitializeCipherSuite(
        CCipherMill *this,
        struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *a2,
        unsigned int a3,
        CCipherSuiteInfo *a4,
        char *a5,
        wchar_t *String1,
        struct ProviderEccCurves *a7)
{
  __int64 v7; // rdi
  CCipherSuiteInfo *v10; // rbx
  unsigned int v11; // r10d
  char *v12; // rcx
  char *v13; // r8
  int v14; // edx
  int v15; // eax
  unsigned __int64 v16; // r12
  __int64 v17; // r14
  __int64 v18; // rsi
  int v20; // r9d
  int v21; // r8d
  int v22; // edx
  int v23; // ecx
  int v24; // ecx

  v7 = a3;
  v10 = 0i64;
  v11 = 0;
  if ( !qword_180092498 )
    return 1168i64;
  while ( 1 )
  {
    v12 = *(char **)(qword_180092490 + 16i64 * v11);
    v13 = (char *)(a5 - v12);
    do
    {
      v14 = *(unsigned __int16 *)&v13[(_QWORD)v12];
      v15 = *(unsigned __int16 *)v12 - v14;
      if ( v15 )
        break;
      v12 += 2;
    }
    while ( v14 );
    if ( !v15 )
      break;
    if ( ++v11 >= qword_180092498 )
      return 1168i64;
  }
  v16 = qword_1800924A0[v11];
  if ( (_DWORD)v7 )
  {
    v17 = v7;
    do
    {
      v18 = *(_QWORD *)a2;
      if ( !wcsicmp(String1, (const wchar_t *)(*(_QWORD *)a2 + 16i64)) )
      {
        if ( !v10 )
          v10 = CCipherSuiteInfo::CCipherSuiteInfo(a4, v16, (struct _NCRYPT_SSL_CIPHER_SUITE_EX *)v18);
        *((_DWORD *)v10 + 2) |= ConvertSslVersionToSchannelProtocol(*(_DWORD *)(v18 + 4));
        if ( a7
          && *((_DWORD *)a7 + 2) != v20
          && (!wcscmp_0((const wchar_t *)(v18 + 412), L"ECDH")
           || !wcscmp_0((const wchar_t *)(v18 + 412), L"ECDH_P256")
           || !wcscmp_0((const wchar_t *)(v18 + 412), L"ECDH_P384")
           || !wcscmp_0((const wchar_t *)(v18 + 412), L"ECDH_P521")
           || !*(_WORD *)(v18 + 412)) )
        {
          *((_QWORD *)v10 + 106) = a7;
        }
        v21 = *(_DWORD *)(v18 + 276);
        v22 = *(_DWORD *)(v18 + 408) >> 3;
        v23 = v22 + 3;
        if ( dword_1800925D4 > (unsigned int)(v22 + 3) )
          v23 = dword_1800925D4;
        dword_1800925D4 = v23;
        v24 = v22 + v21;
        if ( dword_1800925D8 > (unsigned int)(v22 + v21) )
          v24 = dword_1800925D8;
        dword_1800925D8 = v24;
      }
      a2 = (struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *)((char *)a2 + 16);
      --v17;
    }
    while ( v17 );
  }
  return v10 == 0i64 ? 0x490 : 0;
}
// 1800266A7: variable 'v20' is possibly undefined
// 180092490: using guessed type __int64 qword_180092490;
// 1800924A0: using guessed type unsigned __int64 qword_1800924A0[32];
// 1800925D4: using guessed type int dword_1800925D4;
// 1800925D8: using guessed type int dword_1800925D8;

//----- (0000000180026774) ----------------------------------------------------
__int64 __fastcall CSessionCacheManager::InitializeSessionCache(CSessionCacheManager *this)
{
  unsigned int v1; // esi
  HLOCAL v3; // rax
  CSessionCacheTable *v4; // rax
  CSessionCacheTable *v5; // rbx
  unsigned int v6; // eax
  unsigned int v7; // ebp
  struct _LIST_ENTRY *v8; // r14
  unsigned int v9; // ecx
  unsigned int v10; // edx
  int v11; // eax
  ULONG v12; // ebx

  v1 = *((_DWORD *)this + 4);
  *((_DWORD *)this + 12) = (*((_DWORD *)this + 13) + v1 - 1) / *((_DWORD *)this + 13);
  v3 = SPExternalAlloc(16 * v1);
  *((_QWORD *)this + 1) = v3;
  if ( !v3
    || (v4 = (CSessionCacheTable *)SPExternalAlloc(152 * *((_DWORD *)this + 12)),
        *((_QWORD *)this + 5) = v4,
        (v5 = v4) == 0i64) )
  {
LABEL_15:
    v12 = 14;
LABEL_16:
    CSessionCacheManager::ShutdownSessionCache(this);
    CSessionCacheManager::m_pSessionCacheManager = 0i64;
    return v12;
  }
  v6 = *((_DWORD *)this + 12);
  v7 = 0;
  v8 = (struct _LIST_ENTRY *)*((_QWORD *)this + 1);
  if ( v6 )
  {
    v9 = *((_DWORD *)this + 13);
    do
    {
      if ( v1 <= v9 )
        v9 = v1;
      CSessionCacheTable::CSessionCacheTable(v5, v8, v9);
      v9 = *((_DWORD *)this + 13);
      ++v7;
      v5 = (CSessionCacheTable *)((char *)v5 + 152);
      v1 -= v9;
      v8 += v9;
      v6 = *((_DWORD *)this + 12);
    }
    while ( v7 < v6 );
  }
  v10 = 0;
  if ( v6 )
  {
    while ( *(_BYTE *)(152i64 * v10 + *((_QWORD *)this + 5) + 144) )
    {
      if ( ++v10 >= *((_DWORD *)this + 12) )
        goto LABEL_11;
    }
    goto LABEL_15;
  }
LABEL_11:
  v11 = RtlInitializeCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 56));
  v12 = v11;
  if ( v11 < 0 )
    v12 = RtlNtStatusToDosError(v11);
  else
    *((_BYTE *)this + 96) = 1;
  if ( v12 )
    goto LABEL_16;
  return v12;
}

//----- (0000000180026888) ----------------------------------------------------
CSessionCacheTable *__fastcall CSessionCacheTable::CSessionCacheTable(
        CSessionCacheTable *this,
        struct _LIST_ENTRY *a2,
        __int64 a3)
{
  __int64 v4; // rdx
  _QWORD *v5; // rcx

  *(_QWORD *)this = a2;
  *((_DWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = (char *)this + 16;
  *((_QWORD *)this + 2) = (char *)this + 16;
  *((_QWORD *)this + 5) = (char *)this + 32;
  *((_QWORD *)this + 4) = (char *)this + 32;
  v4 = 0i64;
  if ( (_DWORD)a3 )
  {
    a3 = (unsigned int)a3;
    do
    {
      v5 = (_QWORD *)(v4 + *(_QWORD *)this);
      v5[1] = v5;
      *v5 = v5;
      v4 += 16i64;
      --a3;
    }
    while ( a3 );
  }
  RtlInitializeResource((PRTL_RESOURCE)((char *)this + 48));
  *((_BYTE *)this + 144) = 1;
  return this;
}

//----- (0000000180026908) ----------------------------------------------------
CCipherSuiteInfo *__fastcall CCipherSuiteInfo::CCipherSuiteInfo(
        CCipherSuiteInfo *this,
        unsigned __int64 a2,
        struct _NCRYPT_SSL_CIPHER_SUITE_EX *a3)
{
  _DWORD *v3; // rdi
  _DWORD *v4; // r14
  __int64 v7; // rdx
  __int64 v8; // rdx
  int v9; // r9d
  __int64 v10; // r8
  __int64 v11; // rdx
  __int64 *v12; // rax
  __int64 v13; // rcx
  unsigned int v14; // eax
  bool v15; // al
  __int64 v16; // rax
  unsigned __int64 v17; // rcx
  const wchar_t *v18; // r14
  int v19; // edi
  const wchar_t **i; // rsi

  v3 = (_DWORD *)((char *)this + 48);
  *((_DWORD *)this + 2) = 0;
  v4 = (_DWORD *)((char *)this + 52);
  *((_DWORD *)this + 3) = *((_DWORD *)a3 + 69);
  *((_DWORD *)this + 4) = *((_DWORD *)a3 + 102) >> 3;
  *((_DWORD *)this + 5) = *((_DWORD *)a3 + 68);
  *((_DWORD *)this + 6) = *((_DWORD *)a3 + 135);
  *((_DWORD *)this + 7) = *((_DWORD *)a3 + 2);
  *((_DWORD *)this + 12) = 0;
  *((_DWORD *)this + 13) = 0;
  *((_BYTE *)this + 56) = 0;
  *((_QWORD *)this + 8) = 0i64;
  *((_QWORD *)this + 106) = 0i64;
  *((_QWORD *)this + 107) = 0i64;
  CCipherMill::ReferenceProvider(this, a2, (unsigned __int64 *)this);
  *((_DWORD *)this + 8) = LookupExchangeAlg((wchar_t *)a3, v7);
  *((_DWORD *)this + 9) = LookupCertificateAlg((wchar_t *)a3, v8);
  *((_DWORD *)this + 10) = LookupSymmetricCipherAlg(a3);
  *((_DWORD *)this + 11) = LookupChecksumAlg((wchar_t *)a3);
  wcscpy_s((wchar_t *)this + 101, 0x40ui64, (const wchar_t *)a3 + 72);
  wcscpy_s((wchar_t *)this + 165, 0x40ui64, (const wchar_t *)a3 + 206);
  wcscpy_s((wchar_t *)this + 229, 0x40ui64, (const wchar_t *)a3 + 274);
  wcscpy_s((wchar_t *)this + 293, 0x40ui64, (const wchar_t *)a3 + 140);
  wcscpy_s((wchar_t *)this + 357, 0x40ui64, (const wchar_t *)a3 + 340);
  if ( *((_DWORD *)a3 + 1) != 772 )
  {
    v9 = *((_DWORD *)this + 8);
    if ( v3 )
      *v3 = 0;
    v10 = (unsigned int)g_dwKeyExchangeInfoTotalCount;
    v11 = 0i64;
    if ( g_dwKeyExchangeInfoTotalCount )
    {
      v12 = g_pKeyExchangeInfo;
      while ( 1 )
      {
        v13 = *v12;
        if ( *v12 )
        {
          if ( *(_DWORD *)(v13 + 12) == v9 )
            break;
        }
        v11 = (unsigned int)(v11 + 1);
        ++v12;
        if ( (unsigned int)v11 >= g_dwKeyExchangeInfoTotalCount )
          goto LABEL_11;
      }
      I_GetKeyExchangeDetailsFromKeyExchangeInfo(v13, v11, (unsigned int)g_dwKeyExchangeInfoTotalCount, 0i64, v3);
    }
LABEL_11:
    I_GetSignatureDetailsFromAlgId(*((_DWORD *)this + 9), v11, v10, 0i64, v4);
  }
  GetKeyStorageProviderHandle((LPCWSTR)a3 + 274, (unsigned __int8 *)this + 56, (unsigned __int64 *)this + 8);
  v14 = *((_DWORD *)a3 + 2);
  v15 = v14 == 3 || v14 > 0x61 && (v14 <= 0x64 || v14 == 131200);
  *((_BYTE *)this + 72) = v15;
  wcscpy_s((wchar_t *)this + 37, 0x40ui64, (const wchar_t *)a3 + 8);
  v16 = -1i64;
  v17 = -1i64;
  do
    ++v17;
  while ( *((_WORD *)this + v17 + 37) );
  if ( v17 > 5 )
  {
    do
      ++v16;
    while ( *((_WORD *)this + v16 + 37) );
    v18 = (const wchar_t *)((char *)this + 2 * v16);
    v19 = 0;
    for ( i = (const wchar_t **)&off_18007F170; wcsicmp(v18 + 32, *i); i += 99 )
    {
      if ( (unsigned int)++v19 >= 3 )
        return this;
    }
    *((_WORD *)v18 + 32) = 0;
  }
  return this;
}
// 180026992: variable 'v7' is possibly undefined
// 18002699D: variable 'v8' is possibly undefined
// 180026A91: variable 'v11' is possibly undefined
// 180026A91: variable 'v10' is possibly undefined
// 18007F170: using guessed type wchar_t *off_18007F170;
// 1800923B0: using guessed type int g_dwKeyExchangeInfoTotalCount;
// 1800923C0: using guessed type _QWORD g_pKeyExchangeInfo[12];

//----- (0000000180026B60) ----------------------------------------------------
__int64 __fastcall GetKeyStorageProviderHandle(LPCWSTR pszFunction, unsigned __int8 *a2, unsigned __int64 *a3)
{
  NTSTATUS v5; // eax
  _QWORD *v6; // rcx
  unsigned int v7; // edi
  __int64 v8; // rbx
  SECURITY_STATUS v10; // eax
  PVOID pvBuffer; // [rsp+30h] [rbp-18h] BYREF
  ULONG v12; // [rsp+68h] [rbp+20h] BYREF

  v12 = 0;
  pvBuffer = 0i64;
  v5 = BCryptEnumContextFunctionProviders(
         1u,
         0i64,
         3u,
         pszFunction,
         &v12,
         (PCRYPT_CONTEXT_FUNCTION_PROVIDERS *)&pvBuffer);
  v6 = pvBuffer;
  v7 = v5;
  if ( v5 >= 0 )
  {
    v8 = 0i64;
    if ( *(_DWORD *)pvBuffer )
    {
      while ( 1 )
      {
        if ( !wcsicmp(*(const wchar_t **)(v6[1] + 8 * v8), L"Microsoft Primitive Provider") )
        {
          v7 = 0;
          v6 = pvBuffer;
          *a3 = hProvider;
          *a2 = 0;
          goto LABEL_5;
        }
        v10 = NCryptOpenStorageProvider(a3, *(LPCWSTR *)(*((_QWORD *)pvBuffer + 1) + 8 * v8), 0);
        v6 = pvBuffer;
        v7 = v10;
        if ( v10 >= 0 )
          break;
        v8 = (unsigned int)(v8 + 1);
        if ( (unsigned int)v8 >= *(_DWORD *)pvBuffer )
          goto LABEL_5;
      }
      *a2 = 1;
    }
  }
LABEL_5:
  if ( v6 )
    BCryptFreeBuffer(v6);
  return v7;
}

//----- (0000000180026C20) ----------------------------------------------------
__int64 __fastcall LookupCertificateAlg(wchar_t *a1, __int64 a2)
{
  const wchar_t *v2; // rbx
  unsigned int v4; // [rsp+40h] [rbp+8h] BYREF

  v4 = 0;
  v2 = a1 + 274;
  if ( (unsigned int)I_GetSignatureDetailsFromAlgorithmName(a1 + 274, a2, &v4)
    && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xBu, (__int64)&WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids, v2);
  }
  return v4;
}

//----- (0000000180026C74) ----------------------------------------------------
__int64 __fastcall I_GetSignatureDetailsFromAlgId(int a1, __int64 a2, __int64 a3, _DWORD *a4, _DWORD *a5)
{
  __int64 v6; // rdx
  _QWORD *i; // r8
  _DWORD *v8; // rcx

  if ( a4 )
    *a4 = 0;
  if ( a5 )
    *a5 = 0;
  v6 = 0i64;
  if ( !g_dwSignatureInfoTotalCount )
    return 1168i64;
  for ( i = g_pSignatureInfo; ; ++i )
  {
    v8 = (_DWORD *)*i;
    if ( *i )
    {
      if ( v8[3] == a1 )
        break;
    }
    v6 = (unsigned int)(v6 + 1);
    if ( (unsigned int)v6 >= g_dwSignatureInfoTotalCount )
      return 1168i64;
  }
  return I_GetSignatureDetailsFromSignatureInfo(v8, v6, (__int64)i, 0i64, a4, a5);
}
// 180092218: using guessed type int g_dwSignatureInfoTotalCount;
// 180092220: using guessed type _QWORD g_pSignatureInfo[16];

//----- (0000000180026CE8) ----------------------------------------------------
void __fastcall FreeCipherSuiteData(unsigned int a1, NCRYPT_HANDLE *a2, struct CMasterCipherInfo *a3)
{
  __int64 v5; // rdi

  if ( a1 )
  {
    v5 = a1;
    do
    {
      CCipherSuiteInfo::~CCipherSuiteInfo(a2);
      a2 += 108;
      --v5;
    }
    while ( v5 );
  }
  SPExternalFree(a3);
}

//----- (0000000180026D38) ----------------------------------------------------
void __fastcall CCipherSuiteInfo::~CCipherSuiteInfo(NCRYPT_HANDLE *this)
{
  NCRYPT_HANDLE v2; // rcx

  CCipherMill::DeferenceProvider((CCipherMill *)this, this);
  if ( *((_BYTE *)this + 56) )
  {
    v2 = this[8];
    if ( v2 )
    {
      NCryptFreeObject(v2);
      this[8] = 0i64;
    }
  }
}

//----- (0000000180026D60) ----------------------------------------------------
__int64 InitializeIssuerCache(void)
{
  unsigned int i; // ecx
  _QWORD *v1; // rax
  unsigned int v2; // ebx

  memset_0(&IssuerCache, 0, 0x90ui64);
  dword_1800926F8 = 600000;
  dword_1800926FC = 100;
  dword_180092700 = 100;
  qword_180092710 = (__int64)&qword_180092708;
  qword_180092708 = (__int64)&qword_180092708;
  RtlInitializeResource(&stru_180092718);
  dword_180092778 = 1;
  IssuerCache = SPExternalAlloc(16 * dword_1800926FC);
  if ( IssuerCache )
  {
    for ( i = 0; i < dword_1800926FC; ++i )
    {
      v1 = (char *)IssuerCache + 16 * i;
      v1[1] = v1;
      *v1 = v1;
    }
    return 0;
  }
  else
  {
    v2 = 14;
    ShutdownIssuerCache();
  }
  return v2;
}
// 1800926FC: using guessed type int dword_1800926FC;
// 180092708: using guessed type __int64 qword_180092708;
// 180092710: using guessed type __int64 qword_180092710;
// 180092778: using guessed type int dword_180092778;

//----- (0000000180026E34) ----------------------------------------------------
__int64 TlgRegisterAggregateProviderEx()
{
  RTL_SRWLOCK *TlgAggregateSession; // rax
  RTL_SRWLOCK *v1; // rbx
  int v2; // esi
  __int64 v3; // rax
  __int64 *v4; // rcx

  TlgAggregateSession = CreateTlgAggregateSession(1);
  v1 = TlgAggregateSession;
  if ( !TlgAggregateSession )
    return TraceLoggingRegisterEx_EventRegister_EventSetInformation((ULONGLONG *)&dword_180091480, 0i64, 0i64);
  TlgAggregateSession[39].Ptr = 0i64;
  TlgAggregateSession[40].Ptr = 0i64;
  TlgAggregateSession[41].Ptr = &dword_180091480;
  LODWORD(TlgAggregateSession[44].Ptr) = ComputeFlushPeriod((unsigned __int64)TlgAggregateSession);
  v2 = TraceLoggingRegisterEx_EventRegister_EventSetInformation(
         (ULONGLONG *)&dword_180091480,
         (ULONGLONG)TlgAggregateInternalRegisteredProviderEtwCallback,
         (ULONGLONG)v1);
  if ( v2 < 0 )
  {
    qword_1800914A8 = 0i64;
    DestroyAggregateSession(v1);
    return (unsigned int)v2;
  }
  else
  {
    AcquireSRWLockExclusive(&SRWLock);
    v3 = qword_180092EE8;
    if ( !qword_180092EE8 )
    {
      TraceLoggingRegisterEx_EventRegister_EventSetInformation(
        (ULONGLONG *)&dword_180091870,
        (ULONGLONG)TlgAggregateInternalProviderCallback,
        0i64);
      v3 = qword_180092EE8;
    }
    v4 = &qword_180092EE8;
    while ( v3 )
    {
      if ( *(int **)(v3 + 328) == &dword_180091480 )
        goto LABEL_8;
      v4 = (__int64 *)(v3 + 336);
      v3 = *(_QWORD *)(v3 + 336);
    }
    *v4 = (__int64)v1;
LABEL_8:
    ReleaseSRWLockExclusive(&SRWLock);
    return 0i64;
  }
}
// 1800914A8: using guessed type __int64 qword_1800914A8;
// 180092EE8: using guessed type __int64 qword_180092EE8;

//----- (0000000180026F1C) ----------------------------------------------------
__int64 __fastcall TraceLoggingRegisterEx_EventRegister_EventSetInformation(
        ULONGLONG *CallbackContext,
        ULONGLONG a2,
        ULONGLONG a3)
{
  ULONGLONG *v3; // rsi
  bool v4; // zf
  signed int v6; // eax
  unsigned int v7; // ebx
  GUID ProviderId; // [rsp+20h] [rbp-28h] BYREF

  v3 = CallbackContext + 4;
  v4 = CallbackContext[4] == 0;
  ProviderId = *(GUID *)(CallbackContext[1] - 16);
  if ( !v4 )
    __fastfail(5u);
  CallbackContext[5] = a2;
  CallbackContext[6] = a3;
  v6 = EventRegister(&ProviderId, (PENABLECALLBACK)tlgEnableCallback, CallbackContext, v3);
  v7 = v6;
  if ( v6 )
  {
    if ( v6 > 0 )
      return (unsigned __int16)v6 | 0x80070000;
  }
  else
  {
    EventSetInformation(
      *v3,
      2i64,
      CallbackContext[1],
      *(unsigned __int16 *)CallbackContext[1],
      *(_QWORD *)&ProviderId.Data1,
      *(_QWORD *)ProviderId.Data4);
  }
  return v7;
}
// 180080D68: using guessed type __int64 __fastcall EventSetInformation(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180026FCC) ----------------------------------------------------
__int64 __fastcall ComputeFlushPeriod(unsigned __int64 a1)
{
  __int64 v1; // rax
  int v3; // [rsp+20h] [rbp-38h] BYREF
  unsigned __int64 v4; // [rsp+28h] [rbp-30h] BYREF
  __int128 v5; // [rsp+30h] [rbp-28h] BYREF

  v1 = *(_QWORD *)(a1 + 328);
  v3 = 0;
  v4 = a1 >> 4;
  v5 = *(_OWORD *)(*(_QWORD *)(v1 + 8) - 16i64);
  RunningHash(&v3, (__int64)&v5, 0x10ui64);
  RunningHash(&v3, (__int64)&v4, 8ui64);
  return 32769 * ((9 * v3) ^ ((unsigned int)(9 * v3) >> 11)) % 0x927C0 + 600000;
}

//----- (0000000180027078) ----------------------------------------------------
RTL_SRWLOCK *__fastcall CreateTlgAggregateSession(char a1)
{
  char v2; // di
  HANDLE ProcessHeap; // rax
  RTL_SRWLOCK *v4; // rax
  RTL_SRWLOCK *v5; // rbx

  v2 = 0;
  ProcessHeap = GetProcessHeap();
  v4 = (RTL_SRWLOCK *)HeapAlloc(ProcessHeap, 8u, 0x168ui64);
  v5 = v4;
  if ( v4 )
  {
    InitializeSRWLock(v4 + 33);
    if ( !a1
      || !dword_180092DE8
      && (v5[43].Ptr = CreateThreadpoolTimer((PTP_TIMER_CALLBACK)FlushTimerCallbackUserMode, v5, 0i64)) != 0i64 )
    {
      v2 = 1;
    }
  }
  if ( !v2 )
  {
    DestroyAggregateSession(v5);
    return 0i64;
  }
  return v5;
}
// 180092DE8: using guessed type int dword_180092DE8;

//----- (0000000180027150) ----------------------------------------------------
void CTlsSignatureSuiteList::SetRsaSignatureFlags(void)
{
  int v0; // r11d
  char v1; // cl
  int v2; // r10d
  int v3; // r9d
  _DWORD *v4; // r8
  __int64 v5; // rbx

  LOWORD(v0) = CTlsSignatureSuiteList::RsaSha256Flags;
  v1 = 0;
  LOWORD(v2) = CTlsSignatureSuiteList::RsaSha384Flags;
  LOWORD(v3) = CTlsSignatureSuiteList::RsaSha512Flags;
  if ( !CTlsSignatureSuiteList::RsaSha256Flags
    || !CTlsSignatureSuiteList::RsaSha384Flags
    || !CTlsSignatureSuiteList::RsaSha512Flags )
  {
    v4 = &unk_18007C3B8;
    v5 = 12i64;
    do
    {
      if ( *(v4 - 3) == 1 )
      {
        switch ( *v4 )
        {
          case 4:
            v0 = (unsigned __int16)v0 | (1 << v1);
            CTlsSignatureSuiteList::RsaSha256Flags = v0;
            break;
          case 5:
            v2 = (unsigned __int16)v2 | (1 << v1);
            CTlsSignatureSuiteList::RsaSha384Flags = v2;
            break;
          case 6:
            v3 = (unsigned __int16)v3 | (1 << v1);
            CTlsSignatureSuiteList::RsaSha512Flags = v3;
            break;
        }
      }
      v4 += 18;
      ++v1;
      --v5;
    }
    while ( v5 );
  }
}
// 180092800: using guessed type unsigned __int16 CTlsSignatureSuiteList::RsaSha512Flags;
// 180092804: using guessed type unsigned __int16 CTlsSignatureSuiteList::RsaSha384Flags;
// 180092808: using guessed type unsigned __int16 CTlsSignatureSuiteList::RsaSha256Flags;

//----- (0000000180027204) ----------------------------------------------------
__int64 InitializeSslMemoryOptions(void)
{
  char v0; // bl
  char v1; // di
  int v2; // esi
  void *v3; // rax
  __int64 v4; // rax
  void *v6; // rax

  v0 = CSslGlobals::m_dwMemoryOptFlags;
  v1 = CSslGlobals::m_dwMemoryOptFlags & 1;
  v2 = CSslGlobals::m_dwContextPreallocateLength;
  if ( (_QWORD)xmmword_180092DD0 )
    (*(void (__fastcall **)(_QWORD, __int64))(*(_QWORD *)xmmword_180092DD0 + 8i64))(xmmword_180092DD0, 1i64);
  if ( !v1 || !v2 )
  {
    v3 = operator new(0x50ui64);
    if ( v3 )
    {
      v4 = CSslLookaside::CSslLookaside((__int64)v3, 1656, v1);
      goto LABEL_6;
    }
    goto LABEL_8;
  }
  dword_180092DE0 = v2;
  v6 = operator new(0x80ui64);
  if ( !v6 )
  {
LABEL_8:
    v4 = 0i64;
    goto LABEL_6;
  }
  v4 = CSslLookasidePreallocate::CSslLookasidePreallocate((__int64)v6, 1656, v2);
LABEL_6:
  *(_QWORD *)&xmmword_180092DD0 = v4;
  if ( v4 )
    return CSessionCacheServerItem::InitializeServerCacheLookAside((v0 & 4) != 0);
  else
    return 14i64;
}
// 180092DD0: using guessed type __int128 xmmword_180092DD0;
// 180092DE0: using guessed type int dword_180092DE0;
// 180092F70: using guessed type unsigned int CSslGlobals::m_dwContextPreallocateLength;
// 180092F74: using guessed type unsigned int CSslGlobals::m_dwMemoryOptFlags;

//----- (0000000180027298) ----------------------------------------------------
__int64 __fastcall CSessionCacheServerItem::InitializeServerCacheLookAside(char a1)
{
  struct IAllocate *v2; // rbx
  void *v3; // rax

  v2 = 0i64;
  if ( CSessionCacheServerItem::m_pServerCacheLookaside )
    (*(void (__fastcall **)(struct IAllocate *, __int64))(*(_QWORD *)CSessionCacheServerItem::m_pServerCacheLookaside
                                                        + 8i64))(
      CSessionCacheServerItem::m_pServerCacheLookaside,
      1i64);
  v3 = operator new(0x50ui64);
  if ( v3 )
    v2 = (struct IAllocate *)CSslLookaside::CSslLookaside((__int64)v3, 360, a1);
  CSessionCacheServerItem::m_pServerCacheLookaside = v2;
  return v2 == 0i64 ? 0xE : 0;
}
// 1800927F8: using guessed type struct IAllocate *CSessionCacheServerItem::m_pServerCacheLookaside;

//----- (00000001800272FC) ----------------------------------------------------
__int64 __fastcall CSslLookaside::CSslLookaside(__int64 a1, int a2, char a3)
{
  __int64 result; // rax

  *(_BYTE *)(a1 + 32) = a3;
  *(_QWORD *)a1 = &CSslLookaside::`vftable';
  *(_DWORD *)(a1 + 36) = a2;
  *(_DWORD *)(a1 + 40) = 20;
  *(_QWORD *)(a1 + 48) = 20i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 44) = 0x100000;
  InitializeSListHead((PSLIST_HEADER)(a1 + 16));
  result = a1;
  *(_BYTE *)(a1 + 33) = 5;
  return result;
}
// 18007D428: using guessed type void *CSslLookaside::`vftable';

//----- (0000000180027360) ----------------------------------------------------
__int64 __fastcall SpInitialize(unsigned __int64 *a1, __int64 a2, __int64 a3)
{
  int v5; // eax
  const unsigned __int16 *v6; // rdx
  const unsigned __int16 *v7; // rcx
  struct _GUID *v8; // r8
  const unsigned __int16 *v9; // r9

  if ( SpInitialized )
  {
    qword_180092630 = (__int64)a1;
  }
  else
  {
    LsaTable = a3;
    *(_QWORD *)SslTokenSource.SourceName = 0x6C656E6E61686353i64;
    AllocateLocallyUniqueId(&SslTokenSource.SourceIdentifier);
    SslDuplicateString(&SslDomainName, (struct _UNICODE_STRING *)(a2 + 24));
    SslDuplicateString(&SslGlobalDnsDomainName, (struct _UNICODE_STRING *)(a2 + 40));
    RtlInitUnicodeString(&SslPackageName, L"Schannel");
    RtlInitUnicodeString(&SslLegacyPackageName, L"Microsoft Unified Security Protocol Provider");
    bDomainJoined = (*(_DWORD *)(a2 + 4) & 0x10) == 0;
    RtlInitString(&SslPackageNameA, "Schannel");
    RtlInitializeResource(&SslGlobalLock);
    v5 = LsaIRegisterPolicyChangeNotificationCallback(SslDomainChangeCallback, 4i64);
    if ( v5 < 0 )
    {
      v6 = (const unsigned __int16 *)&WPP_GLOBAL_Control;
      v7 = (const unsigned __int16 *)WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          92i64,
          &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
          (unsigned int)v5);
    }
    InitDebugTracingEx(v7, v6, v8, v9);
    SpInitialized = 1;
    g_dwPackageId = a1;
  }
  return 0i64;
}
// 180027464: variable 'v7' is possibly undefined
// 180027464: variable 'v6' is possibly undefined
// 180027464: variable 'v8' is possibly undefined
// 180027464: variable 'v9' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;
// 180092628: using guessed type unsigned __int64 near *g_dwPackageId;
// 180092630: using guessed type __int64 qword_180092630;
// 180092648: using guessed type int bDomainJoined;
// 180092780: using guessed type int SpInitialized;
// 180098218: using guessed type __int64 __fastcall LsaIRegisterPolicyChangeNotificationCallback(_QWORD, _QWORD);

//----- (0000000180027498) ----------------------------------------------------
__int64 __fastcall SslDuplicateString(struct _UNICODE_STRING *a1, struct _UNICODE_STRING *a2)
{
  WCHAR *v4; // rax

  v4 = (WCHAR *)SPExternalAlloc((unsigned int)a2->Length + 2);
  a1->Buffer = v4;
  if ( !v4 )
    return 3221225495i64;
  a1->Length = a2->Length;
  a1->MaximumLength = a2->Length + 2;
  memcpy_0(v4, a2->Buffer, a2->Length);
  a1->Buffer[(unsigned __int64)a1->Length >> 1] = 0;
  return 0i64;
}

//----- (0000000180027520) ----------------------------------------------------
__int64 SchInitializeEvents(void)
{
  unsigned int v0; // ecx
  HMODULE Library; // rax
  HMODULE v2; // rbx
  unsigned __int64 v3; // rax
  DWORD Data; // [rsp+60h] [rbp+8h] BYREF
  HKEY hKey; // [rsp+68h] [rbp+10h] BYREF

  v0 = RegCreateKeyExW(
         HKEY_LOCAL_MACHINE,
         L"System\\CurrentControlSet\\Services\\EventLog\\System\\Schannel",
         0,
         (LPWSTR)&Class,
         0,
         0x20006u,
         0i64,
         &hKey,
         &Data);
  if ( !v0 )
  {
    if ( Data == 1 )
    {
      RegSetValueExW(hKey, L"EventMessageFile", 0, 2u, L"%SystemRoot%\\system32\\lsasrv.dll", 0x42u);
      Data = 7;
      RegSetValueExW(hKey, L"TypesSupported", 0, 4u, (const BYTE *)&Data, 4u);
      RegFlushKey(hKey);
    }
    RegCloseKey(hKey);
    Library = LoadLibraryExW(L"lsasrv.dll", 0i64, 0);
    v2 = Library;
    if ( Library )
    {
      SchGetMessageString(Library, 0x80009080, (WCHAR *)&pszClientString);
      SchGetMessageString(v2, 0x80009081, (WCHAR *)&pszServerString);
      FreeLibrary(v2);
      v0 = EtwEventRegister(&S_Microsoft_Windows_Schannel, 0i64, 0i64, &g_RegistrationHandle);
      v3 = g_RegistrationHandle;
      if ( v0 )
        v3 = 0i64;
      g_RegistrationHandle = v3;
    }
    else
    {
      return GetLastError();
    }
  }
  return v0;
}
// 180080EA8: using guessed type __int64 __fastcall EtwEventRegister(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092D80: using guessed type unsigned __int64 g_RegistrationHandle;

//----- (000000018002763C) ----------------------------------------------------
__int64 __fastcall SchGetMessageString(LPCVOID lpSource, DWORD dwMessageId, WCHAR *a3)
{
  DWORD v4; // eax

  *(_QWORD *)a3 = 0i64;
  v4 = FormatMessageW(0x900u, lpSource, dwMessageId, 0, a3, 0, 0i64);
  if ( !v4 || !*(_QWORD *)a3 )
    return 1812i64;
  *(_WORD *)(*(_QWORD *)a3 + 2i64 * (v4 - 2)) = 0;
  return 0i64;
}

//----- (00000001800276A4) ----------------------------------------------------
ULONG SslInitSystemMapper(void)
{
  int v0; // ebx
  int v1; // eax
  ULONG v2; // edi
  struct _TOKEN_GROUPS *v3; // rax
  enum _NT_PRODUCT_TYPE ProductType; // [rsp+20h] [rbp-29h] BYREF
  ULONG SecurityMode; // [rsp+24h] [rbp-25h] BYREF
  struct _STRING DestinationString; // [rsp+28h] [rbp-21h] BYREF
  struct _SID_IDENTIFIER_AUTHORITY IdentifierAuthority; // [rsp+38h] [rbp-11h] BYREF
  char Sid[80]; // [rsp+40h] [rbp-9h] BYREF

  v0 = 0;
  if ( !SslLogonHandle )
  {
    v1 = LsaRegisterLogonProcess((PLSA_STRING)&SslPackageNameA, &SslLogonHandle, &SecurityMode);
    if ( v1 < 0 )
      return RtlNtStatusToDosError(v1);
  }
  RtlInitString(&DestinationString, "Kerberos");
  v1 = LsaLookupAuthenticationPackage(SslLogonHandle, (PLSA_STRING)&DestinationString, &SslKerberosPackageId);
  if ( v1 < 0 )
    return RtlNtStatusToDosError(v1);
  RtlInitString(&DestinationString, "MICROSOFT_AUTHENTICATION_PACKAGE_V1_0");
  v1 = LsaLookupAuthenticationPackage(SslLogonHandle, (PLSA_STRING)&DestinationString, &SslMsvPackageId);
  if ( v1 < 0 )
    return RtlNtStatusToDosError(v1);
  if ( !SslPackageSid )
  {
    *(_DWORD *)IdentifierAuthority.Value = 0;
    *(_WORD *)&IdentifierAuthority.Value[4] = 1280;
    RtlInitializeSid(Sid, &IdentifierAuthority, 2u);
    *RtlSubAuthoritySid(Sid, 0) = 64;
    *RtlSubAuthoritySid(Sid, 1u) = 14;
    v2 = RtlLengthSid(Sid);
    v3 = (struct _TOKEN_GROUPS *)LocalAlloc(0x40u, v2 + 24i64);
    SslPackageSid = v3;
    if ( !v3 )
      return 14;
    v3->GroupCount = 1;
    v3->Groups[0].Sid = &v3[1];
    v3->Groups[0].Attributes = 7;
    RtlCopySid(v2, &v3[1], Sid);
  }
  g_SslS4U2SelfInitialized = 1;
  if ( RtlGetNtProductType(&ProductType) )
    LOBYTE(v0) = ProductType == NtProductLanManNt;
  else
    v0 = 1;
  fUseLocalMapping = v0;
  return 0;
}
// 1800919A0: using guessed type int fUseLocalMapping;
// 180092784: using guessed type int g_SslS4U2SelfInitialized;

//----- (0000000180027890) ----------------------------------------------------
unsigned __int8 __fastcall CSslCredManager::InitCredentialManager(CSslCredManager *this)
{
  HANDLE EventA; // rax
  HCERTSTORE v3; // rax
  HANDLE v4; // rax

  if ( RtlInitializeCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8)) < 0 )
    return 0;
  *((_QWORD *)this + 7) = (char *)this + 48;
  *((_QWORD *)this + 6) = (char *)this + 48;
  EventA = CreateEventA(0i64, 0, 0, 0i64);
  *((_QWORD *)this + 8) = EventA;
  if ( EventA )
    RegisterGPNotification(EventA, 1);
  v3 = CertOpenStore((LPCSTR)0xA, 1u, 0i64, 0x20020000u, L"MY");
  *((_QWORD *)this + 9) = v3;
  if ( v3 )
  {
    v4 = CreateEventA(0i64, 0, 0, 0i64);
    *((_QWORD *)this + 10) = v4;
    if ( v4 )
      CertControlStore(*((HCERTSTORE *)this + 9), 0, 2u, (char *)this + 80);
  }
  return 1;
}
// 18008275C: using guessed type wchar_t aMy[3];

//----- (000000018002796C) ----------------------------------------------------
struct CSessionCacheManager *CSessionCacheManager::CreateCacheManager(void)
{
  CSessionCacheManager *v0; // rcx
  CSessionCacheManager *v1; // rax
  unsigned int v2; // eax

  v0 = CSessionCacheManager::m_pSessionCacheManager;
  if ( !CSessionCacheManager::m_pSessionCacheManager )
  {
    v1 = (CSessionCacheManager *)SPExternalAlloc(0x68u);
    v0 = v1;
    if ( v1 )
    {
      *((_QWORD *)v1 + 1) = 0i64;
      *(_QWORD *)v1 = &CSessionCacheManager::`vftable';
      *((_DWORD *)v1 + 4) = 20000;
      *((_DWORD *)v1 + 5) = CSslGlobals::m_dwClientLifespan;
      *((_DWORD *)v1 + 6) = CSslGlobals::m_dwServerLifespan;
      v2 = CSslGlobals::m_dwMaximumEntries;
      *((_QWORD *)v0 + 5) = 0i64;
      *((_DWORD *)v0 + 7) = v2;
      *((_DWORD *)v0 + 13) = 1000;
    }
    else
    {
      v0 = 0i64;
    }
    CSessionCacheManager::m_pSessionCacheManager = v0;
  }
  return v0;
}
// 18007D450: using guessed type void *CSessionCacheManager::`vftable';

//----- (00000001800279E8) ----------------------------------------------------
__int64 CSslGlobals::InitializePeriodicCleanupHandler(void)
{
  DWORD v0; // ebx
  DWORD LastError; // edi
  HANDLE EventA; // rax

  v0 = 0;
  LastError = 0;
  if ( (unsigned int)_InterlockedIncrement((volatile signed __int32 *)&CSslGlobals::m_lReentryCount) <= 1 )
  {
    EventA = CreateEventA(0i64, 0, 0, 0i64);
    CSslGlobals::m_hCleanupEvent = EventA;
    if ( !EventA
      || (CSslGlobals::m_hCleanupWaitObject = (HANDLE)RegisterWaitForSingleObjectEx(
                                                        EventA,
                                                        CSslGlobals::PeriodicCleanupHandler,
                                                        0i64,
                                                        1000 * CSslGlobals::m_dwCleanupIntervalInSeconds,
                                                        0)) == 0i64 )
    {
      LastError = GetLastError();
      if ( LastError )
        CSslGlobals::CleanupPeriodicCleanupHandler();
    }
    v0 = LastError;
  }
  _InterlockedDecrement((volatile signed __int32 *)&CSslGlobals::m_lReentryCount);
  return v0;
}
// 180080BC0: using guessed type __int64 __fastcall RegisterWaitForSingleObjectEx(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180092EE0: using guessed type unsigned int CSslGlobals::m_lReentryCount;

//----- (0000000180027A84) ----------------------------------------------------
__int64 CSslGlobals::InitializeCryptLocatorEvents(void)
{
  DWORD LastError; // ebx
  CCipherMill *v2; // rcx
  __int64 v3; // rdx

  LastError = 0;
  CSslGlobals::m_hImplicitCertChangeEvent = CreateEventA(0i64, 0, 0, 0i64);
  if ( CSslGlobals::m_hImplicitCertChangeEvent )
  {
    CSslGlobals::m_hImplicitIssersChangeEvent = CreateEventA(0i64, 0, 0, 0i64);
    if ( CSslGlobals::m_hImplicitIssersChangeEvent )
      return LastError;
    LastError = GetLastError();
    v2 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      v3 = 12i64;
      goto LABEL_10;
    }
  }
  else
  {
    LastError = GetLastError();
    v2 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      v3 = 11i64;
LABEL_10:
      WPP_SF_D(*((_QWORD *)v2 + 2), v3, &WPP_092b895ef39c3c047a28e4103b904d61_Traceguids, LastError);
    }
  }
  if ( LastError )
    CSslGlobals::CleanupCryptLocatorEvents();
  return LastError;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180027AF0) ----------------------------------------------------
void __fastcall TlgAggregateInternalRegisteredProviderEtwCallback(
        const struct _GUID *a1,
        unsigned int a2,
        __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        struct _EVENT_FILTER_DESCRIPTOR *a6,
        _QWORD *a7)
{
  void (__fastcall *v8)(const struct _GUID *, _QWORD, __int64, __int64, unsigned __int64, struct _EVENT_FILTER_DESCRIPTOR *, _QWORD); // rax

  v8 = (void (__fastcall *)(const struct _GUID *, _QWORD, __int64, __int64, unsigned __int64, struct _EVENT_FILTER_DESCRIPTOR *, _QWORD))a7[39];
  if ( v8 )
    v8(a1, a2, a3, a4, a5, a6, a7[40]);
  if ( a2 == 1 )
  {
    LookUpTableFlushComplete((__int64)a7);
  }
  else if ( a2 == 2 )
  {
    LookUpTableFlushPartial((__int64)a7);
  }
}

//----- (0000000180027B44) ----------------------------------------------------
__int64 __fastcall LookUpTableFlushComplete(__int64 a1)
{
  unsigned int v1; // edx
  unsigned int v2; // edi
  __int64 v4; // rcx
  __int64 v5; // r9
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int128 v8; // xmm0
  __int64 result; // rax
  int v10; // [rsp+70h] [rbp-29h] BYREF
  int v11; // [rsp+74h] [rbp-25h] BYREF
  int v12; // [rsp+78h] [rbp-21h] BYREF
  int v13; // [rsp+7Ch] [rbp-1Dh] BYREF
  int v14; // [rsp+80h] [rbp-19h] BYREF
  __int64 v15; // [rsp+88h] [rbp-11h] BYREF
  __int64 v16; // [rsp+90h] [rbp-9h] BYREF
  __int64 v17; // [rsp+98h] [rbp-1h] BYREF
  __int128 *v18; // [rsp+A0h] [rbp+7h] BYREF
  __int64 v19; // [rsp+C8h] [rbp+2Fh]
  __int128 v20; // [rsp+D0h] [rbp+37h] BYREF

  v1 = *(_DWORD *)(a1 + 256);
  v2 = 0;
  if ( v1 )
  {
    UpdateInternalStatsOnFlush(a1, v1);
    v6 = *(_QWORD *)(v4 + 272);
    if ( v6 )
    {
      if ( (unsigned int)dword_180091870 > 5
        && (qword_180091880 & 0x200000000000i64) != 0
        && (qword_180091888 & 0x200000000000i64) == qword_180091888 )
      {
        v7 = *(_QWORD *)(*(_QWORD *)(v4 + 328) + 8i64);
        v8 = *(_OWORD *)(v7 - 16);
        v10 = *(_DWORD *)(a1 + 308);
        v11 = *(_DWORD *)(a1 + 304);
        v12 = *(_DWORD *)(a1 + 300);
        v13 = *(_DWORD *)(a1 + 296);
        v14 = *(_DWORD *)(a1 + 292);
        v16 = *(unsigned int *)(a1 + 288);
        v17 = *(_QWORD *)(a1 + 280);
        v18 = &v20;
        v15 = v6;
        v20 = v8;
        _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByRef<16>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>>(
          v7,
          byte_1800849D8,
          0x200000000000i64,
          v5,
          (__int64 *)&v18,
          (__int64)&v17,
          (__int64)&v16,
          (__int64)&v15,
          (__int64)&v14,
          (__int64)&v13,
          (__int64)&v12,
          (__int64)&v11,
          (__int64)&v10);
      }
      *(_OWORD *)(a1 + 272) = 0i64;
      v19 = 0i64;
      *(_OWORD *)(a1 + 288) = 0i64;
      *(_QWORD *)(a1 + 304) = v19;
    }
    do
      result = FlushLookUpTableBucket(a1, v2++);
    while ( v2 < 0x20 );
  }
  return result;
}
// 180040D57: variable 'v4' is possibly undefined
// 180040E5C: variable 'v5' is possibly undefined
// 1800849D8: using guessed type unsigned __int8 byte_1800849D8[219];
// 180091880: using guessed type __int64 qword_180091880;
// 180091888: using guessed type __int64 qword_180091888;

//----- (0000000180027BB0) ----------------------------------------------------
__int64 __fastcall SpLsaModeInitialize(
        __int64 a1,
        unsigned int *a2,
        struct _SECPKG_FUNCTION_TABLE **a3,
        unsigned int *a4)
{
  __int64 result; // rax

  *a2 = 0x40000;
  *a3 = (struct _SECPKG_FUNCTION_TABLE *)&SpTable;
  result = 0i64;
  *a4 = 2;
  return result;
}

//----- (0000000180027BD4) ----------------------------------------------------
CSslContextManager *__fastcall CSslContextManager::CSslContextManager(CSslContextManager *this)
{
  CSslContextManager *result; // rax

  g_SslContextManager = &CSslContextManager::`vftable';
  qword_180092DA8 = 0i64;
  qword_180092DB0 = 0i64;
  qword_180092DB8 = 0i64;
  qword_180092DC0 = 0i64;
  dword_180092DC8 = 0;
  dword_180092DE0 = 0;
  byte_180092DE4 = 0;
  result = (CSslContextManager *)&g_SslContextManager;
  xmmword_180092DD0 = 0i64;
  return result;
}
// 18007D3E8: using guessed type void *CSslContextManager::`vftable';
// 180092DA8: using guessed type __int64 qword_180092DA8;
// 180092DB0: using guessed type __int64 qword_180092DB0;
// 180092DB8: using guessed type __int64 qword_180092DB8;
// 180092DC0: using guessed type __int64 qword_180092DC0;
// 180092DC8: using guessed type int dword_180092DC8;
// 180092DD0: using guessed type __int128 xmmword_180092DD0;
// 180092DE0: using guessed type int dword_180092DE0;
// 180092DE4: using guessed type char byte_180092DE4;

//----- (0000000180027C30) ----------------------------------------------------
__int64 initialize_legacy_wide_specifiers()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 *v1; // rax

  v0 = _local_stdio_printf_options();
  *v0 |= 4ui64;
  v1 = _local_stdio_scanf_options();
  *v1 |= 2ui64;
  return 0i64;
}

//----- (0000000180027C54) ----------------------------------------------------
unsigned __int64 *__cdecl _local_stdio_printf_options()
{
  return (unsigned __int64 *)&`__local_stdio_printf_options'::`2'::_OptionsStorage;
}

//----- (0000000180027C64) ----------------------------------------------------
unsigned __int64 *__cdecl _local_stdio_scanf_options()
{
  return (unsigned __int64 *)&`__local_stdio_scanf_options'::`2'::_OptionsStorage;
}

//----- (0000000180027C80) ----------------------------------------------------
__int64 initialize_msvcrt_compatibility()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 *v1; // rax

  v0 = _local_stdio_printf_options();
  *v0 |= 0x18ui64;
  v1 = _local_stdio_scanf_options();
  *v1 |= 4ui64;
  return 0i64;
}

//----- (0000000180027CB0) ----------------------------------------------------
__int64 __fastcall dllmain_crt_dispatch(__int64 a1, int a2, __int64 a3)
{
  int v3; // edx
  int v4; // edx
  __int64 result; // rax

  if ( !a2 )
    return dllmain_crt_process_detach(a3 != 0);
  v3 = a2 - 1;
  if ( !v3 )
    return dllmain_crt_process_attach(a1, a3);
  v4 = v3 - 1;
  if ( v4 )
  {
    if ( v4 != 1 )
      return 1i64;
    LOBYTE(result) = _scrt_dllmain_crt_thread_detach();
  }
  else
  {
    LOBYTE(result) = _scrt_dllmain_crt_thread_attach();
  }
  return (unsigned __int8)result;
}

//----- (0000000180027D08) ----------------------------------------------------
__int64 __fastcall dllmain_crt_process_attach(__int64 a1, __int64 a2)
{
  char v4; // bl
  char v5; // di
  _QWORD *dyn_tls_init_callback; // rax

  if ( !_scrt_initialize_crt(0) )
    return 0i64;
  v4 = _scrt_acquire_startup_lock();
  v5 = 1;
  if ( _scrt_current_native_startup_state )
  {
    _scrt_fastfail(7u);
    __debugbreak();
    JUMPOUT(0x180027E28i64);
  }
  _scrt_current_native_startup_state = 1;
  if ( _scrt_dllmain_before_initialize_c() )
  {
    RTC_Initialize();
    __scrt_initialize_type_info();
    _scrt_initialize_default_local_stdio_options();
    if ( !initterm_e_0((_PIFV *)&_xi_a, (_PIFV *)&_xi_z) )
    {
      if ( _scrt_dllmain_after_initialize_c() )
      {
        initterm_0((_PVFV *)&_xc_a, (_PVFV *)&_xc_z);
        _scrt_current_native_startup_state = 2;
        v5 = 0;
      }
    }
  }
  _scrt_release_startup_lock(v4);
  if ( v5 )
    return 0i64;
  dyn_tls_init_callback = _scrt_get_dyn_tls_init_callback();
  if ( *dyn_tls_init_callback )
  {
    if ( _scrt_is_nonwritable_in_current_image((__int64)dyn_tls_init_callback) )
      _guard_xfg_dispatch_icall_fptr(a1, 2i64, a2);
  }
  ++dword_180091A30;
  return 1i64;
}
// 180027E27: control flows out of bounds to 180027E28
// 18002A7C0: using guessed type __int64 __fastcall guard_xfg_dispatch_icall_nop();
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180091A30: using guessed type int dword_180091A30;
// 180091FC0: using guessed type int _scrt_current_native_startup_state;

//----- (0000000180027E30) ----------------------------------------------------
_BOOL8 __fastcall dllmain_crt_process_detach(char a1)
{
  char v3; // bl
  __int64 v4; // rcx
  BOOL v5; // ebx

  if ( dword_180091A30 <= 0 )
    return 0i64;
  --dword_180091A30;
  v3 = _scrt_acquire_startup_lock();
  if ( _scrt_current_native_startup_state != 2 )
  {
    _scrt_fastfail(7u);
    __debugbreak();
    JUMPOUT(0x180027EB4i64);
  }
  _scrt_dllmain_uninitialize_c();
  __scrt_uninitialize_type_info();
  RTC_Terminate();
  _scrt_current_native_startup_state = 0;
  _scrt_release_startup_lock(v3);
  LOBYTE(v4) = a1;
  v5 = _scrt_uninitialize_crt(v4, 0) != 0;
  _scrt_dllmain_uninitialize_critical();
  return v5;
}
// 180027EB3: control flows out of bounds to 180027EB4
// 180027E92: variable 'v4' is possibly undefined
// 180091A30: using guessed type int dword_180091A30;
// 180091FC0: using guessed type int _scrt_current_native_startup_state;

//----- (0000000180027EBC) ----------------------------------------------------
__int64 __fastcall dllmain_dispatch(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  unsigned int v7; // ebx
  BOOL v8; // eax

  if ( !fdwReason && dword_180091A30 <= 0 )
    return 0i64;
  if ( fdwReason - 1 > 1
    || (!pRawDllMain || (v7 = ((__int64 (*)(void))pRawDllMain)()) != 0)
    && (v7 = dllmain_crt_dispatch((__int64)hinstDLL, fdwReason, (__int64)lpvReserved)) != 0 )
  {
    v8 = DllMain(hinstDLL, fdwReason, lpvReserved);
    v7 = v8;
    if ( fdwReason == 1 && !v8 )
    {
      DllMain(hinstDLL, 0, lpvReserved);
      dllmain_crt_dispatch((__int64)hinstDLL, 0, (__int64)lpvReserved);
      if ( pRawDllMain )
        pRawDllMain(hinstDLL, 0i64, lpvReserved);
    }
    if ( !fdwReason || fdwReason == 3 )
    {
      v7 = dllmain_crt_dispatch((__int64)hinstDLL, fdwReason, (__int64)lpvReserved);
      if ( v7 )
      {
        if ( pRawDllMain )
          return (unsigned int)pRawDllMain(hinstDLL, fdwReason, lpvReserved);
        else
          return 1;
      }
    }
  }
  return v7;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180082768: using guessed type __int64 (__fastcall *pRawDllMain)(_QWORD, _QWORD, _QWORD);
// 180091A30: using guessed type int dword_180091A30;

//----- (0000000180028370) ----------------------------------------------------
void __cdecl _security_init_cookie()
{
  uintptr_t v0; // rax
  unsigned __int64 v1; // [rsp+30h] [rbp+10h] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [rsp+38h] [rbp+18h] BYREF
  LARGE_INTEGER PerformanceCount; // [rsp+40h] [rbp+20h] BYREF

  v0 = _security_cookie;
  if ( _security_cookie == 0x2B992DDFA232i64 )
  {
    SystemTimeAsFileTime = 0i64;
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v1 = (unsigned __int64)SystemTimeAsFileTime;
    v1 ^= GetCurrentThreadId();
    v1 ^= GetCurrentProcessId();
    QueryPerformanceCounter(&PerformanceCount);
    v0 = ((unsigned __int64)&v1 ^ v1 ^ PerformanceCount.QuadPart ^ ((unsigned __int64)PerformanceCount.LowPart << 32)) & 0xFFFFFFFFFFFFi64;
    if ( v0 == 0x2B992DDFA232i64 )
      v0 = 0x2B992DDFA233i64;
    _security_cookie = v0;
  }
  _security_cookie_complement = ~v0;
}
// 180091978: using guessed type __int64 _security_cookie_complement;

//----- (0000000180028424) ----------------------------------------------------
void __scrt_initialize_type_info(void)
{
  InitializeSListHead(&__type_info_root_node);
}
// 180091FB0: using guessed type union _SLIST_HEADER __type_info_root_node;

//----- (0000000180028438) ----------------------------------------------------
void __scrt_uninitialize_type_info(void)
{
  _std_type_info_destroy_list(&__type_info_root_node);
}
// 180028C7A: using guessed type __int64 __fastcall _std_type_info_destroy_list(_QWORD);
// 180091FB0: using guessed type union _SLIST_HEADER __type_info_root_node;

//----- (000000018002844C) ----------------------------------------------------
unsigned __int64 *_scrt_initialize_default_local_stdio_options()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 *result; // rax

  v0 = _local_stdio_printf_options();
  *v0 |= 0x24ui64;
  result = _local_stdio_scanf_options();
  *result |= 2ui64;
  return result;
}

//----- (0000000180028470) ----------------------------------------------------
char _scrt_acquire_startup_lock()
{
  PVOID StackBase; // rcx
  signed __int64 v1; // rax

  if ( _scrt_is_ucrt_dll_in_use() )
  {
    StackBase = NtCurrentTeb()->NtTib.StackBase;
    while ( 1 )
    {
      v1 = _InterlockedCompareExchange64(&_scrt_native_startup_lock, (signed __int64)StackBase, 0i64);
      if ( !v1 )
        break;
      if ( StackBase == (PVOID)v1 )
        return 1;
    }
  }
  return 0;
}
// 180091FC8: using guessed type __int64 _scrt_native_startup_lock;

//----- (00000001800284B0) ----------------------------------------------------
char _scrt_dllmain_after_initialize_c()
{
  _crt_argv_mode startup_argv_mode; // eax

  if ( _scrt_is_ucrt_dll_in_use() )
  {
    _isa_available_init();
  }
  else
  {
    startup_argv_mode = get_startup_argv_mode();
    if ( o__configure_narrow_argv_0(startup_argv_mode) )
      return 0;
    initialize_narrow_environment();
  }
  return 1;
}

//----- (00000001800284EC) ----------------------------------------------------
bool _scrt_dllmain_before_initialize_c()
{
  return _scrt_initialize_onexit_tables(0) != 0;
}

//----- (0000000180028508) ----------------------------------------------------
char _scrt_dllmain_crt_thread_attach()
{
  if ( !_scrt_stub_for_acrt_thread_attach() )
    return 0;
  if ( !_scrt_stub_for_acrt_thread_attach() )
  {
    _scrt_stub_for_acrt_thread_attach();
    return 0;
  }
  return 1;
}

//----- (0000000180028538) ----------------------------------------------------
char _scrt_dllmain_crt_thread_detach()
{
  _scrt_stub_for_acrt_thread_attach();
  _scrt_stub_for_acrt_thread_attach();
  return 1;
}

//----- (0000000180028554) ----------------------------------------------------
int __fastcall _scrt_dllmain_exception_filter(
        __int64 a1,
        int a2,
        __int64 a3,
        void (__fastcall *a4)(__int64, _QWORD, __int64),
        unsigned int ExceptionNum,
        struct _EXCEPTION_POINTERS *ExceptionPtr)
{
  if ( !_scrt_is_ucrt_dll_in_use() && a2 == 1 )
    a4(a1, 0i64, a3);
  return o__seh_filter_dll_0(ExceptionNum, ExceptionPtr);
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (00000001800285C4) ----------------------------------------------------
int _scrt_dllmain_uninitialize_c()
{
  int result; // eax

  if ( _scrt_is_ucrt_dll_in_use() )
    return execute_onexit_table(&Table);
  result = _scrt_stub_for_is_c_termination_complete();
  if ( !result )
    return o__cexit_0();
  return result;
}
// 180028CAA: using guessed type __int64 o__cexit_0(void);

//----- (00000001800285FC) ----------------------------------------------------
char _scrt_dllmain_uninitialize_critical()
{
  _scrt_stub_for_acrt_uninitialize_critical();
  return _scrt_stub_for_acrt_uninitialize_critical();
}

//----- (0000000180028618) ----------------------------------------------------
char __fastcall _scrt_initialize_crt(int a1)
{
  char v1; // al

  v1 = byte_180092001;
  if ( !a1 )
    v1 = 1;
  byte_180092001 = v1;
  _isa_available_init();
  if ( !_scrt_stub_for_acrt_thread_attach() )
    return 0;
  if ( !_scrt_stub_for_acrt_thread_attach() )
  {
    _scrt_stub_for_acrt_uninitialize_critical();
    return 0;
  }
  return 1;
}
// 180092001: using guessed type char byte_180092001;

//----- (0000000180028668) ----------------------------------------------------
char __fastcall _scrt_initialize_onexit_tables(unsigned int a1)
{
  if ( !byte_180092000 )
  {
    if ( a1 > 1 )
    {
      _scrt_fastfail(5u);
      JUMPOUT(0x1800286F2i64);
    }
    if ( !_scrt_is_ucrt_dll_in_use() || a1 )
    {
      *(__m128i *)&Table._first = _mm_load_si128((const __m128i *)&_xmm_ffffffffffffffffffffffffffffffff);
      Table._end = (_PVFV *)-1i64;
      *(_OWORD *)&stru_180091FE8._first = *(_OWORD *)&Table._first;
      stru_180091FE8._end = (_PVFV *)-1i64;
    }
    else if ( initialize_onexit_table(&Table) || initialize_onexit_table(&stru_180091FE8) )
    {
      return 0;
    }
    byte_180092000 = 1;
  }
  return 1;
}
// 1800286ED: control flows out of bounds to 1800286F2
// 180082770: using guessed type __int128 _xmm_ffffffffffffffffffffffffffffffff;
// 180092000: using guessed type char byte_180092000;

//----- (00000001800286FC) ----------------------------------------------------
bool __fastcall _scrt_is_nonwritable_in_current_image(__int64 a1)
{
  unsigned __int64 v1; // r8
  _DWORD *v2; // rdx
  _DWORD *v3; // r9
  unsigned __int64 v4; // rcx

  if ( _ImageBase != 23117
    || *(_DWORD *)((char *)&_ImageBase + (int)off_18000003C) != 17744
    || *(__int16 *)((char *)&word_180000018 + (int)off_18000003C) != 523 )
  {
    return 0;
  }
  v1 = a1 - (_QWORD)&_ImageBase;
  v2 = (_DWORD *)((char *)&word_180000018
                + (int)off_18000003C
                + *(unsigned __int16 *)((char *)&word_180000014 + (int)off_18000003C));
  v3 = &v2[10 * *(unsigned __int16 *)((char *)&word_180000006 + (int)off_18000003C)];
  while ( v2 != v3 )
  {
    v4 = (unsigned int)v2[3];
    if ( v1 >= v4 && v1 < (unsigned int)(v4 + v2[2]) )
      return v2 && v2[9] >= 0;
    v2 += 10;
  }
  v2 = 0i64;
  return v2 && v2[9] >= 0;
}
// 180000000: using guessed type __int16 _ImageBase;
// 180000006: using guessed type __int16;
// 180000014: using guessed type __int16;
// 180000018: using guessed type __int16;
// 18000003C: using guessed type void *__ptr32 off_18000003C;

//----- (000000018002879C) ----------------------------------------------------
_BOOL8 __fastcall _scrt_release_startup_lock(char a1)
{
  _BOOL8 result; // rax

  result = _scrt_is_ucrt_dll_in_use();
  if ( result && !a1 )
    _InterlockedExchange64(&_scrt_native_startup_lock, 0i64);
  return result;
}
// 180091FC8: using guessed type __int64 _scrt_native_startup_lock;

//----- (00000001800287C8) ----------------------------------------------------
char __fastcall _scrt_uninitialize_crt(__int64 a1, char a2)
{
  if ( !byte_180092001 || !a2 )
  {
    _scrt_stub_for_acrt_uninitialize_critical();
    _scrt_stub_for_acrt_uninitialize_critical();
  }
  return 1;
}
// 180092001: using guessed type char byte_180092001;

//----- (00000001800287F8) ----------------------------------------------------
_onexit_t __cdecl onexit(_onexit_t Func)
{
  int v2; // eax
  int (__cdecl *v3)(); // rdx

  if ( Table._first == (_PVFV *)-1i64 )
    v2 = crt_atexit((_PVFV)Func);
  else
    v2 = o__register_onexit_function_0(&Table, Func);
  v3 = 0i64;
  if ( !v2 )
    return Func;
  return v3;
}

//----- (0000000180028858) ----------------------------------------------------
void *_scrt_get_dyn_tls_init_callback()
{
  return &_dyn_tls_init_callback;
}

//----- (0000000180028868) ----------------------------------------------------
void _crt_debugger_hook()
{
  _scrt_debugger_hook_flag = 0;
}
// 180092004: using guessed type int _scrt_debugger_hook_flag;

//----- (0000000180028878) ----------------------------------------------------
void __fastcall _scrt_fastfail(unsigned int a1)
{
  DWORD64 Rip; // rbx
  struct _RUNTIME_FUNCTION *v3; // rax
  bool v4; // bl
  struct _EXCEPTION_POINTERS ExceptionInfo; // [rsp+40h] [rbp-C0h] BYREF
  int v6[4]; // [rsp+50h] [rbp-B0h] BYREF
  DWORD64 v7; // [rsp+60h] [rbp-A0h]
  CONTEXT ContextRecord; // [rsp+F0h] [rbp-10h] BYREF
  DWORD64 retaddr; // [rsp+5C8h] [rbp+4C8h]
  __int64 v10; // [rsp+5D0h] [rbp+4D0h] BYREF
  unsigned __int64 ImageBase; // [rsp+5D8h] [rbp+4D8h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+5E0h] [rbp+4E0h] BYREF
  PVOID HandlerData; // [rsp+5E8h] [rbp+4E8h] BYREF

  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(a1);
  _crt_debugger_hook();
  memset_0(&ContextRecord, 0, sizeof(ContextRecord));
  RtlCaptureContext(&ContextRecord);
  Rip = ContextRecord.Rip;
  v3 = RtlLookupFunctionEntry(ContextRecord.Rip, &ImageBase, 0i64);
  if ( v3 )
    RtlVirtualUnwind(0, ImageBase, Rip, v3, &ContextRecord, &HandlerData, &EstablisherFrame, 0i64);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&v10;
  memset_0(v6, 0, 0x98ui64);
  v7 = retaddr;
  v6[0] = 1073741845;
  v6[1] = 1;
  ExceptionInfo.ExceptionRecord = (PEXCEPTION_RECORD)v6;
  v4 = IsDebuggerPresent();
  ExceptionInfo.ContextRecord = &ContextRecord;
  SetUnhandledExceptionFilter(0i64);
  if ( !UnhandledExceptionFilter(&ExceptionInfo) && !v4 )
    _crt_debugger_hook();
}

//----- (00000001800289CC) ----------------------------------------------------
void __cdecl RTC_Initialize()
{
  void (**i)(void); // rbx

  for ( i = &_rtc_izz; i < &_rtc_izz; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 1800871A0: using guessed type void (*_rtc_izz)(void);

//----- (0000000180028A18) ----------------------------------------------------
void __cdecl RTC_Terminate()
{
  void (**i)(void); // rbx

  for ( i = &_rtc_tzz; i < &_rtc_tzz; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 1800871B0: using guessed type void (*_rtc_tzz)(void);

//----- (0000000180028A88) ----------------------------------------------------
int __cdecl _isa_available_init()
{
  int v5; // r11d
  int v6; // r10d
  int v7; // esi
  int v9; // r9d
  int v14; // edi
  int v15; // eax
  unsigned __int64 v16; // rax
  __int64 v17; // rcx
  int v18; // r8d
  int v23; // eax
  char v25; // [rsp+20h] [rbp+8h]

  _RAX = 0i64;
  __asm { cpuid }
  v5 = 0;
  v6 = _RDX;
  v7 = _RAX;
  _RAX = 1i64;
  v9 = _RCX ^ 0x6C65746E | _RBX ^ 0x756E6547;
  __asm { cpuid }
  v14 = _RCX;
  if ( !(v6 ^ 0x49656E69 | v9)
    && ((_memcpy_nt_iters = -1i64, v15 = _RAX & 0xFFF3FF0, v15 == 67264)
     || v15 == 132704
     || v15 == 132720
     || (v16 = (unsigned int)(v15 - 198224), (unsigned int)v16 <= 0x20) && (v17 = 0x100010001i64, _bittest64(&v17, v16))) )
  {
    v18 = _favor | 1;
    _favor |= 1u;
  }
  else
  {
    v18 = _favor;
  }
  _RAX = 7i64;
  if ( v7 >= 7 )
  {
    __asm { cpuid }
    v5 = _RBX;
    if ( (_RBX & 0x200) != 0 )
      _favor = v18 | 2;
  }
  _isa_available = 1;
  _isa_enabled = 2;
  if ( (v14 & 0x100000) != 0 )
  {
    _isa_available = 2;
    _isa_enabled = 6;
    if ( (v14 & 0x8000000) != 0 && (v14 & 0x10000000) != 0 )
    {
      __asm { xgetbv }
      v25 = _RAX;
      if ( (_RAX & 6) == 6 )
      {
        v23 = _isa_enabled | 8;
        _isa_available = 3;
        _isa_enabled |= 8u;
        if ( (v5 & 0x20) != 0 )
        {
          _isa_available = 5;
          _isa_enabled = v23 | 0x20;
          if ( (v5 & 0xD0030000) == -805109760 && (v25 & 0xE0) == 0xE0 )
          {
            _isa_enabled |= 0x40u;
            _isa_available = 6;
          }
        }
      }
    }
  }
  return 0;
}
// 180091980: using guessed type int _isa_available;
// 180091984: using guessed type int _isa_enabled;
// 180091988: using guessed type __int64 _memcpy_nt_iters;
// 180092008: using guessed type int _favor;

//----- (0000000180028C30) ----------------------------------------------------
_crt_argv_mode __cdecl get_startup_argv_mode()
{
  return 1;
}

//----- (0000000180028C3C) ----------------------------------------------------
_BOOL8 _scrt_is_ucrt_dll_in_use()
{
  return _scrt_ucrt_dll_is_in_use != 0;
}
// 180091994: using guessed type int _scrt_ucrt_dll_is_in_use;

//----- (0000000180028D9C) ----------------------------------------------------
__int64 __fastcall load_SslImportKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180028DA8) ----------------------------------------------------
__int64 __fastcall _tailMerge_ncrypt_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_ncrypt_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180028DE2: variable 'v4' is possibly undefined
// 18008BE50: using guessed type int _DELAY_IMPORT_DESCRIPTOR_ncrypt_dll;

//----- (0000000180028E27) ----------------------------------------------------
__int64 __fastcall load_CertSerializeCertificateStoreElement(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180028E33) ----------------------------------------------------
__int64 __fastcall _tailMerge_crypt32_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_crypt32_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180028E6D: variable 'v4' is possibly undefined
// 18008BE70: using guessed type int _DELAY_IMPORT_DESCRIPTOR_crypt32_dll;

//----- (0000000180028EB2) ----------------------------------------------------
__int64 __fastcall load_CertSaveStore(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180028EC4) ----------------------------------------------------
__int64 __fastcall load_CertOpenStore(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180028ED6) ----------------------------------------------------
__int64 __fastcall load_CertCloseStore(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180028EE8) ----------------------------------------------------
__int64 __fastcall load_CertAddSerializedElementToStore(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180028EFA) ----------------------------------------------------
__int64 __fastcall load_CertFreeCertificateContext(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180028F0C) ----------------------------------------------------
__int64 __fastcall load_CertEnumCertificatesInStore(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180028F1E) ----------------------------------------------------
__int64 __fastcall load_CertAddCertificateContextToStore(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180028F30) ----------------------------------------------------
__int64 __fastcall load_CertFindCertificateInStore(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180028F42) ----------------------------------------------------
__int64 __fastcall load_CredIsMarshaledCredentialW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_credentials_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180028F4E) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_security_credentials_l1_1_0_dll(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_credentials_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180028F88: variable 'v4' is possibly undefined
// 18008BE90: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_credentials_l1_1_0_dll;

//----- (0000000180028FCD) ----------------------------------------------------
__int64 __fastcall load_CredUnmarshalCredentialW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_credentials_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180028FDF) ----------------------------------------------------
__int64 __fastcall load_CredFree(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_credentials_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180028FF1) ----------------------------------------------------
__int64 __fastcall load_CertFindCTLInStore(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029003) ----------------------------------------------------
__int64 __fastcall load_CertFreeCTLContext(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029015) ----------------------------------------------------
__int64 __fastcall load_SslFreeObject(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029027) ----------------------------------------------------
__int64 __fastcall load_CertNameToStrW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029039) ----------------------------------------------------
__int64 __fastcall load_CertCreateCertificateContext(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (000000018002904B) ----------------------------------------------------
__int64 __fastcall load_CertNameToStrA(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (000000018002905D) ----------------------------------------------------
__int64 __fastcall load_CertGetPublicKeyLength(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (000000018002906F) ----------------------------------------------------
__int64 __fastcall load_CertDuplicateCertificateContext(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029081) ----------------------------------------------------
__int64 __fastcall load_CertSetCertificateContextProperty(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029093) ----------------------------------------------------
__int64 __fastcall load_SslComputeEapKeyBlock(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800290A5) ----------------------------------------------------
__int64 __fastcall load_SslExportKeyingMaterial(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800290B7) ----------------------------------------------------
__int64 __fastcall load_LsaRegisterLogonProcess(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_sspicli_dll(a1, a2, a3, a4);
}

//----- (00000001800290C3) ----------------------------------------------------
__int64 __fastcall _tailMerge_sspicli_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_sspicli_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 1800290FD: variable 'v4' is possibly undefined
// 18008BEB0: using guessed type int _DELAY_IMPORT_DESCRIPTOR_sspicli_dll;

//----- (0000000180029142) ----------------------------------------------------
__int64 __fastcall load_LsaLookupAuthenticationPackage(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_sspicli_dll(a1, a2, a3, a4);
}

//----- (0000000180029154) ----------------------------------------------------
__int64 __fastcall load_CryptDecodeObjectEx(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029166) ----------------------------------------------------
__int64 __fastcall load_CertGetNameStringW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029178) ----------------------------------------------------
__int64 __fastcall load_LsaLogonUser(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_sspicli_dll(a1, a2, a3, a4);
}

//----- (000000018002918A) ----------------------------------------------------
__int64 __fastcall load_LsaFreeReturnBuffer(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_sspicli_dll(a1, a2, a3, a4);
}

//----- (000000018002919C) ----------------------------------------------------
__int64 __fastcall load_CertGetCertificateChain(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (00000001800291AE) ----------------------------------------------------
__int64 __fastcall load_CertFreeCertificateChain(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (00000001800291C0) ----------------------------------------------------
__int64 __fastcall load_CertCompareCertificateName(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (00000001800291D2) ----------------------------------------------------
__int64 __fastcall load_LsaCallAuthenticationPackage(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_sspicli_dll(a1, a2, a3, a4);
}

//----- (00000001800291E4) ----------------------------------------------------
__int64 __fastcall load_LsaConnectUntrusted(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_sspicli_dll(a1, a2, a3, a4);
}

//----- (00000001800291F6) ----------------------------------------------------
__int64 __fastcall load_LsaDeregisterLogonProcess(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_sspicli_dll(a1, a2, a3, a4);
}

//----- (0000000180029208) ----------------------------------------------------
__int64 __fastcall load_CertFreeCertificateChainEngine(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (000000018002921A) ----------------------------------------------------
__int64 __fastcall load_BCryptRegisterConfigChangeNotify(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029226) ----------------------------------------------------
__int64 __fastcall _tailMerge_bcrypt_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_bcrypt_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180029260: variable 'v4' is possibly undefined
// 18008BED0: using guessed type int _DELAY_IMPORT_DESCRIPTOR_bcrypt_dll;

//----- (00000001800292A5) ----------------------------------------------------
__int64 __fastcall load_BCryptUnregisterConfigChangeNotify(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800292B7) ----------------------------------------------------
__int64 __fastcall load_BCryptGetFipsAlgorithmMode(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800292C9) ----------------------------------------------------
__int64 __fastcall load_BCryptOpenAlgorithmProvider(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800292DB) ----------------------------------------------------
__int64 __fastcall load_BCryptCloseAlgorithmProvider(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800292ED) ----------------------------------------------------
__int64 __fastcall load_SslExportKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800292FF) ----------------------------------------------------
__int64 __fastcall load_SslExpandWriteKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029311) ----------------------------------------------------
__int64 __fastcall load_SslDecrementProviderReferenceCount(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029323) ----------------------------------------------------
__int64 __fastcall load_SslLookupCipherSuiteInfo(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029335) ----------------------------------------------------
__int64 __fastcall load_SslEncryptPacket(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029347) ----------------------------------------------------
__int64 __fastcall load_SslExpandNextGenTrafficKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029359) ----------------------------------------------------
__int64 __fastcall load_SslOpenProvider(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (000000018002936B) ----------------------------------------------------
__int64 __fastcall load_SslLookupCipherLengths(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (000000018002937D) ----------------------------------------------------
__int64 __fastcall load_SslIncrementProviderReferenceCount(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (000000018002938F) ----------------------------------------------------
__int64 __fastcall load_SslDecryptPacket(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800293A1) ----------------------------------------------------
__int64 __fastcall load_NCryptSignHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800293B3) ----------------------------------------------------
__int64 __fastcall load_NCryptFreeObject(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800293C5) ----------------------------------------------------
__int64 __fastcall load_CertGetCertificateContextProperty(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (00000001800293D7) ----------------------------------------------------
__int64 __fastcall load_NCryptSetProperty(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800293E9) ----------------------------------------------------
__int64 __fastcall load_BCryptGenRandom(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029407) ----------------------------------------------------
__int64 __fastcall load_CertAddEncodedCertificateToStore(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029419) ----------------------------------------------------
__int64 __fastcall load_CryptDecodeObject(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (000000018002942B) ----------------------------------------------------
__int64 __fastcall load_CryptFindOIDInfo(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (000000018002943D) ----------------------------------------------------
__int64 __fastcall load_CertVerifyCertificateChainPolicy(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (000000018002944F) ----------------------------------------------------
__int64 __fastcall load_CryptMemFree(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029461) ----------------------------------------------------
__int64 __fastcall load_CertGetEnhancedKeyUsage(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029473) ----------------------------------------------------
__int64 __fastcall load_CryptHashCertificate2(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029485) ----------------------------------------------------
__int64 __fastcall load_GetUserNameExW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_sspicli_dll(a1, a2, a3, a4);
}

//----- (0000000180029497) ----------------------------------------------------
__int64 __fastcall load_CertControlStore(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (00000001800294A9) ----------------------------------------------------
__int64 __fastcall load_CertDuplicateStore(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (00000001800294BB) ----------------------------------------------------
__int64 __fastcall load_ConvertSidToStringSidW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_sddl_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (00000001800294C7) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_security_sddl_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_sddl_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180029501: variable 'v4' is possibly undefined
// 18008BEF0: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_sddl_l1_1_0_dll;

//----- (0000000180029546) ----------------------------------------------------
__int64 __fastcall load_CertFindChainInStore(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029558) ----------------------------------------------------
__int64 __fastcall load_CertFindExtension(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (000000018002956A) ----------------------------------------------------
__int64 __fastcall load_RegisterGPNotification(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_userenv_dll(a1, a2, a3, a4);
}

//----- (0000000180029576) ----------------------------------------------------
__int64 __fastcall _tailMerge_userenv_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_userenv_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 1800295B0: variable 'v4' is possibly undefined
// 18008BF10: using guessed type int _DELAY_IMPORT_DESCRIPTOR_userenv_dll;

//----- (00000001800295F5) ----------------------------------------------------
__int64 __fastcall load_UnregisterGPNotification(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_userenv_dll(a1, a2, a3, a4);
}

//----- (0000000180029607) ----------------------------------------------------
__int64 __fastcall load_BCryptEnumContextFunctionProviders(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029619) ----------------------------------------------------
__int64 __fastcall load_NCryptOpenStorageProvider(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (000000018002962B) ----------------------------------------------------
__int64 __fastcall load_BCryptFreeBuffer(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (000000018002963D) ----------------------------------------------------
__int64 __fastcall load_SslFreeBuffer(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (000000018002964F) ----------------------------------------------------
__int64 __fastcall load_SslEnumProtocolProviders(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029661) ----------------------------------------------------
__int64 __fastcall load_BCryptQueryProviderRegistration(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029673) ----------------------------------------------------
__int64 __fastcall load_SslEnumCipherSuitesEx(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029685) ----------------------------------------------------
__int64 __fastcall load_SslEnumCipherSuites(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029697) ----------------------------------------------------
__int64 __fastcall load_SslEnumEccCurves(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800296A9) ----------------------------------------------------
__int64 __fastcall load_BCryptEnumContextFunctions(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800296BB) ----------------------------------------------------
__int64 __fastcall load_SslOpenPrivateKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800296CD) ----------------------------------------------------
__int64 __fastcall load_NCryptImportKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800296DF) ----------------------------------------------------
__int64 __fastcall load_SslCreateHandshakeHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800296F1) ----------------------------------------------------
__int64 __fastcall load_SslGetCipherSuitePRFHashAlgorithm(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029703) ----------------------------------------------------
__int64 __fastcall load_SslCreateClientAuthHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029715) ----------------------------------------------------
__int64 __fastcall load_SslHashHandshake(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029727) ----------------------------------------------------
__int64 __fastcall load_BCryptGetProperty(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029739) ----------------------------------------------------
__int64 __fastcall load_BCryptCreateHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (000000018002974B) ----------------------------------------------------
__int64 __fastcall load_BCryptHashData(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (000000018002975D) ----------------------------------------------------
__int64 __fastcall load_BCryptFinishHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (000000018002976F) ----------------------------------------------------
__int64 __fastcall load_BCryptDestroyHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029781) ----------------------------------------------------
__int64 __fastcall load_CryptImportPublicKeyInfoEx(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029793) ----------------------------------------------------
__int64 __fastcall load_NCryptExportKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800297A5) ----------------------------------------------------
__int64 __fastcall load_BCryptImportKeyPair(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800297B7) ----------------------------------------------------
__int64 __fastcall load_CryptImportPublicKeyInfoEx2(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (00000001800297C9) ----------------------------------------------------
__int64 __fastcall load_SslComputeClientAuthHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800297DB) ----------------------------------------------------
__int64 __fastcall load_BCryptVerifySignature(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800297ED) ----------------------------------------------------
__int64 __fastcall load_BCryptDestroyKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800297FF) ----------------------------------------------------
__int64 __fastcall load_NCryptOpenKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029811) ----------------------------------------------------
__int64 __fastcall load_CertGetIntendedKeyUsage(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029823) ----------------------------------------------------
__int64 __fastcall load_BCryptHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029835) ----------------------------------------------------
__int64 __fastcall load_CertOpenServerOcspResponse(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029847) ----------------------------------------------------
__int64 __fastcall load_CertCloseServerOcspResponse(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029859) ----------------------------------------------------
__int64 __fastcall load_CryptEncodeObject(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (000000018002986B) ----------------------------------------------------
__int64 __fastcall load_CertGetServerOcspResponseContext(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (000000018002987D) ----------------------------------------------------
__int64 __fastcall load_CertFreeServerOcspResponseContext(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (000000018002988F) ----------------------------------------------------
__int64 __fastcall load_SslDuplicateTranscriptHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800298A1) ----------------------------------------------------
__int64 __fastcall load_SslCreateEphemeralKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800298B3) ----------------------------------------------------
__int64 __fastcall load_SslSignHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800298C5) ----------------------------------------------------
__int64 __fastcall load_SslComputeFinishedHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800298D7) ----------------------------------------------------
__int64 __fastcall load_SslComputeSessionHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800298E9) ----------------------------------------------------
__int64 __fastcall load_SslExpandTrafficKeys(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800298FB) ----------------------------------------------------
__int64 __fastcall load_SslExtractEarlyKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (000000018002990D) ----------------------------------------------------
__int64 __fastcall load_SslExtractHandshakeKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (000000018002991F) ----------------------------------------------------
__int64 __fastcall load_SslExtractMasterKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029931) ----------------------------------------------------
__int64 __fastcall load_SslExpandExporterMasterKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029943) ----------------------------------------------------
__int64 __fastcall load_SslExpandPreSharedKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029955) ----------------------------------------------------
__int64 __fastcall load_SslExpandBinderKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029967) ----------------------------------------------------
__int64 __fastcall load_SslExpandResumptionMasterKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180029979) ----------------------------------------------------
__int64 __fastcall load_SslGetKeyProperty(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (000000018002998B) ----------------------------------------------------
__int64 __fastcall load_SslGeneratePreMasterKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (000000018002999D) ----------------------------------------------------
__int64 __fastcall load_SslGenerateMasterKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800299AF) ----------------------------------------------------
__int64 __fastcall load_SslImportMasterKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800299C1) ----------------------------------------------------
__int64 __fastcall load_NCryptVerifySignature(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800299D3) ----------------------------------------------------
__int64 __fastcall load_CertCreateCertificateChainEngine(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (00000001800299E5) ----------------------------------------------------
__int64 __fastcall load_SslGenerateSessionKeys(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ncrypt_dll(a1, a2, a3, a4);
}

//----- (00000001800299F7) ----------------------------------------------------
__int64 __fastcall load_SampUsingDsData(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_samsrv_dll(a1, a2, a3, a4);
}

//----- (0000000180029A03) ----------------------------------------------------
__int64 __fastcall _tailMerge_samsrv_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_samsrv_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180029A3D: variable 'v4' is possibly undefined
// 18008BF30: using guessed type int _DELAY_IMPORT_DESCRIPTOR_samsrv_dll;

//----- (0000000180029A82) ----------------------------------------------------
__int64 __fastcall load_CryptAcquireContextW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_cryptsp_dll(a1, a2, a3, a4);
}

//----- (0000000180029A8E) ----------------------------------------------------
__int64 __fastcall _tailMerge_cryptsp_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_cryptsp_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180029AC8: variable 'v4' is possibly undefined
// 18008BF50: using guessed type int _DELAY_IMPORT_DESCRIPTOR_cryptsp_dll;

//----- (0000000180029B0D) ----------------------------------------------------
__int64 __fastcall load_CryptReleaseContext(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_cryptsp_dll(a1, a2, a3, a4);
}

//----- (0000000180029B1F) ----------------------------------------------------
__int64 __fastcall load_CryptSignHashW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_cryptsp_dll(a1, a2, a3, a4);
}

//----- (0000000180029B31) ----------------------------------------------------
__int64 __fastcall load_CryptDestroyHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_cryptsp_dll(a1, a2, a3, a4);
}

//----- (0000000180029B43) ----------------------------------------------------
__int64 __fastcall load_CryptSetHashParam(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_cryptsp_dll(a1, a2, a3, a4);
}

//----- (0000000180029B55) ----------------------------------------------------
__int64 __fastcall load_CryptHashData(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_cryptsp_dll(a1, a2, a3, a4);
}

//----- (0000000180029B67) ----------------------------------------------------
__int64 __fastcall load_CryptCreateHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_cryptsp_dll(a1, a2, a3, a4);
}

//----- (0000000180029B79) ----------------------------------------------------
__int64 __fastcall load_CryptSetProvParam(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_cryptsp_dll(a1, a2, a3, a4);
}

//----- (0000000180029B8B) ----------------------------------------------------
__int64 __fastcall load_CryptGetProvParam(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_cryptsp_dll(a1, a2, a3, a4);
}

//----- (0000000180029B9D) ----------------------------------------------------
__int64 __fastcall load_CryptExportKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_cryptsp_dll(a1, a2, a3, a4);
}

//----- (0000000180029BAF) ----------------------------------------------------
__int64 __fastcall load_CryptDestroyKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_cryptsp_dll(a1, a2, a3, a4);
}

//----- (0000000180029BC4) ----------------------------------------------------
char IsCrackSingleNamePresent()
{
  char result; // al
  char v1; // [rsp+30h] [rbp+8h] BYREF

  if ( dword_180092058 == 1 )
    return 1;
  if ( dword_180092058 == 2 )
    return 0;
  v1 = 0;
  if ( (int)ApiSetQueryApiSetPresence_0(L"Z\\", &v1) < 0 )
    return 0;
  result = v1;
  dword_180092058 = 2 - (v1 != 0);
  return result;
}
// 18002A3E0: using guessed type __int64 __fastcall ApiSetQueryApiSetPresence_0(_QWORD, _QWORD);
// 18007D4B0: using guessed type wchar_t aZ[3];
// 180092058: using guessed type int dword_180092058;

//----- (0000000180029C18) ----------------------------------------------------
__int64 __fastcall load_CrackSingleName(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ext_ms_win_ntdsa_activedirectoryserver_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180029C24) ----------------------------------------------------
__int64 __fastcall _tailMerge_ext_ms_win_ntdsa_activedirectoryserver_l1_1_0_dll(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_ext_ms_win_ntdsa_activedirectoryserver_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180029C5E: variable 'v4' is possibly undefined
// 18008BF70: using guessed type int _DELAY_IMPORT_DESCRIPTOR_ext_ms_win_ntdsa_activedirectoryserver_l1_1_0_dll;

//----- (0000000180029CA3) ----------------------------------------------------
__int64 __fastcall load__CryptObjectLocatorFree__YAXPEAX_Z(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029CB5) ----------------------------------------------------
__int64 __fastcall load__CryptObjectLocatorGet__YAPEAXPEAXKPEAU_CRYPTOAPI_BLOB___Z(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029CC7) ----------------------------------------------------
__int64 __fastcall load__CryptObjectLocatorGetContent__YAPEAXPEAX_Z(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029CD9) ----------------------------------------------------
__int64 __fastcall load_I_CertWnfEnableFlushCache(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029CEB) ----------------------------------------------------
__int64 __fastcall load_I_CertProcessSslHandshake(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029CFD) ----------------------------------------------------
__int64 __fastcall load_I_CertFinishSslHandshake(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029D0F) ----------------------------------------------------
__int64 __fastcall load__CryptObjectLocatorInitialize__YAPEAXPEBDKKPEAX1_Z(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029D21) ----------------------------------------------------
__int64 __fastcall load__CryptObjectLocatorRelease__YAXKPEAX_Z(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029D33) ----------------------------------------------------
__int64 __fastcall load__CryptObjectLocatorIsChanged__YAHPEAX_Z(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029D45) ----------------------------------------------------
__int64 __fastcall load__CryptObjectLocatorGetUpdated__YAPEAXPEAX_Z(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_crypt32_dll(a1, a2, a3, a4);
}

//----- (0000000180029D57) ----------------------------------------------------
__int64 __fastcall load_LsaISetTokenDacl(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_lsasrv_dll(a1, a2, a3, a4);
}

//----- (0000000180029D63) ----------------------------------------------------
__int64 __fastcall _tailMerge_lsasrv_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_lsasrv_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180029D9D: variable 'v4' is possibly undefined
// 18008BF90: using guessed type int _DELAY_IMPORT_DESCRIPTOR_lsasrv_dll;

//----- (0000000180029DE2) ----------------------------------------------------
__int64 __fastcall load_LsaIIsDomainWithinForest(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_lsasrv_dll(a1, a2, a3, a4);
}

//----- (0000000180029DF4) ----------------------------------------------------
__int64 __fastcall load_LsaIQueryInformationPolicyTrusted(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_lsasrv_dll(a1, a2, a3, a4);
}

//----- (0000000180029E06) ----------------------------------------------------
__int64 __fastcall load_LsaIFree_LSAPR_POLICY_INFORMATION(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_lsasrv_dll(a1, a2, a3, a4);
}

//----- (0000000180029E18) ----------------------------------------------------
__int64 __fastcall load_LsaIRegisterPolicyChangeNotificationCallback(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_lsasrv_dll(a1, a2, a3, a4);
}

//----- (0000000180029E2A) ----------------------------------------------------
__int64 __fastcall load_LsaIFilterSids(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_lsasrv_dll(a1, a2, a3, a4);
}

//----- (0000000180029E3C) ----------------------------------------------------
__int64 __fastcall load_LsaIModifyPerformanceCounter(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_lsasrv_dll(a1, a2, a3, a4);
}

//----- (0000000180029E4E) ----------------------------------------------------
__int64 __fastcall load_I_RpcMapWin32Status(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_rpcrt4_dll(a1, a2, a3, a4);
}

//----- (0000000180029E5A) ----------------------------------------------------
__int64 __fastcall _tailMerge_rpcrt4_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_rpcrt4_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180029E94: variable 'v4' is possibly undefined
// 18008BFB0: using guessed type int _DELAY_IMPORT_DESCRIPTOR_rpcrt4_dll;

//----- (0000000180029ED9) ----------------------------------------------------
__int64 __fastcall load_MesHandleFree(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_rpcrt4_dll(a1, a2, a3, a4);
}

//----- (0000000180029EEB) ----------------------------------------------------
__int64 __fastcall load_MesEncodeIncrementalHandleCreate(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_rpcrt4_dll(a1, a2, a3, a4);
}

//----- (0000000180029EFD) ----------------------------------------------------
__int64 __fastcall load_MesDecodeIncrementalHandleCreate(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_rpcrt4_dll(a1, a2, a3, a4);
}

//----- (0000000180029F0F) ----------------------------------------------------
__int64 __fastcall load_MesIncrementalHandleReset(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_rpcrt4_dll(a1, a2, a3, a4);
}

//----- (0000000180029F21) ----------------------------------------------------
__int64 __fastcall load_NdrMesTypeDecode3(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_rpcrt4_dll(a1, a2, a3, a4);
}

//----- (0000000180029F33) ----------------------------------------------------
__int64 __fastcall load_NdrMesTypeEncode3(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_rpcrt4_dll(a1, a2, a3, a4);
}

//----- (0000000180029F45) ----------------------------------------------------
__int64 __fastcall load_NdrMesTypeAlignSize3(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_rpcrt4_dll(a1, a2, a3, a4);
}

//----- (0000000180029F58) ----------------------------------------------------
void *__fastcall operator new(size_t Size)
{
  size_t i; // rdi
  void *v2; // rbx

  for ( i = Size; ; Size = i )
  {
    v2 = o_malloc_0(Size);
    if ( v2 || !(unsigned int)o__callnewh_0(i) )
      break;
  }
  return v2;
}
// 180028C9E: using guessed type __int64 __fastcall o__callnewh_0(_QWORD);

//----- (0000000180029FA0) ----------------------------------------------------
__int64 _scrt_initialize_thread_safe_statics()
{
  HMODULE ModuleHandleW; // rbx
  FARPROC ProcAddress; // rdi
  FARPROC v2; // rax

  InitializeCriticalSectionAndSpinCount(&CriticalSection, 0xFA0u);
  ModuleHandleW = GetModuleHandleW(L"api-ms-win-core-synch-l1-2-0.dll");
  if ( !ModuleHandleW )
  {
    ModuleHandleW = GetModuleHandleW(L"kernel32.dll");
    if ( !ModuleHandleW )
      goto LABEL_9;
  }
  ProcAddress = GetProcAddress(ModuleHandleW, "SleepConditionVariableCS");
  v2 = GetProcAddress(ModuleHandleW, "WakeAllConditionVariable");
  if ( ProcAddress && v2 )
  {
    qword_1800920B8 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))ProcAddress;
    qword_1800920C0 = (__int64 (__fastcall *)(_QWORD))v2;
    goto LABEL_7;
  }
  hHandle = CreateEventW(0i64, 1, 0, 0i64);
  if ( !hHandle )
  {
LABEL_9:
    _scrt_fastfail(7u);
    JUMPOUT(0x18002A06Fi64);
  }
LABEL_7:
  if ( !_scrt_initialize_onexit_tables(0) )
    goto LABEL_9;
  atexit(_scrt_uninitialize_thread_safe_statics);
  return 0i64;
}
// 18002A06A: control flows out of bounds to 18002A06F
// 1800920B8: using guessed type __int64 (__fastcall *qword_1800920B8)(_QWORD, _QWORD, _QWORD);
// 1800920C0: using guessed type __int64 (__fastcall *qword_1800920C0)(_QWORD);

//----- (000000018002A080) ----------------------------------------------------
void __fastcall _scrt_uninitialize_thread_safe_statics()
{
  DeleteCriticalSection(&CriticalSection);
  if ( hHandle )
    CloseHandle(hHandle);
}

//----- (000000018002A0B0) ----------------------------------------------------
int __fastcall Init_thread_footer(_DWORD *a1)
{
  __int64 v2; // rdx

  EnterCriticalSection(&CriticalSection);
  v2 = (unsigned int)tls_index;
  *a1 = ++Init_global_epoch;
  *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + v2) + 4i64) = Init_global_epoch;
  LeaveCriticalSection(&CriticalSection);
  return Init_thread_notify();
}
// 180091990: using guessed type int Init_global_epoch;
// 1800920C8: using guessed type int tls_index;

//----- (000000018002A118) ----------------------------------------------------
void __fastcall Init_thread_header(_DWORD *a1)
{
  EnterCriticalSection(&CriticalSection);
  while ( 1 )
  {
    if ( !*a1 )
    {
      *a1 = -1;
      goto LABEL_7;
    }
    if ( *a1 != -1 )
      break;
    Init_thread_wait(0x64u);
  }
  *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)tls_index) + 4i64) = Init_global_epoch;
LABEL_7:
  LeaveCriticalSection(&CriticalSection);
}
// 180091990: using guessed type int Init_global_epoch;
// 1800920C8: using guessed type int tls_index;

//----- (000000018002A188) ----------------------------------------------------
int Init_thread_notify()
{
  if ( qword_1800920C0 )
    return qword_1800920C0(&unk_180092080);
  SetEvent(hHandle);
  return ResetEvent(hHandle);
}
// 1800920C0: using guessed type __int64 (__fastcall *qword_1800920C0)(_QWORD);

//----- (000000018002A1DC) ----------------------------------------------------
void __fastcall Init_thread_wait(DWORD dwMilliseconds)
{
  if ( qword_1800920B8 )
  {
    qword_1800920B8(&unk_180092080, &CriticalSection, dwMilliseconds);
  }
  else
  {
    LeaveCriticalSection(&CriticalSection);
    WaitForSingleObjectEx(hHandle, dwMilliseconds, 0);
    EnterCriticalSection(&CriticalSection);
  }
}
// 1800920B8: using guessed type __int64 (__fastcall *qword_1800920B8)(_QWORD, _QWORD, _QWORD);

//----- (000000018002A25C) ----------------------------------------------------
int __cdecl vsnwprintf(wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, va_list Args)
{
  unsigned __int64 *v8; // rax
  int result; // eax

  v8 = _local_stdio_printf_options();
  result = o___stdio_common_vswprintf_0(*v8 | 1, Buffer, BufferCount, Format, 0i64, Args);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (000000018002A2C4) ----------------------------------------------------
int snwprintf_s(
        wchar_t *const Buffer,
        const size_t BufferCount,
        const size_t MaxCount,
        const wchar_t *const Format,
        ...)
{
  unsigned __int64 *v8; // rax
  int result; // eax
  va_list va; // [rsp+90h] [rbp+28h] BYREF

  va_start(va, Format);
  v8 = _local_stdio_printf_options();
  result = _stdio_common_vsnwprintf_s(*v8, Buffer, BufferCount, MaxCount, Format, 0i64, va);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (000000018002A324) ----------------------------------------------------
__int64 __fastcall load_EnableTraceEx2(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_eventing_controller_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018002A330) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_eventing_controller_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_eventing_controller_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 18002A36A: variable 'v4' is possibly undefined
// 18008BFD0: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_eventing_controller_l1_1_0_dll;

//----- (000000018002A3AF) ----------------------------------------------------
__int64 __fastcall load_ControlTraceW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_eventing_controller_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018002A3C1) ----------------------------------------------------
__int64 __fastcall load_StartTraceW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_eventing_controller_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018002A3EC) ----------------------------------------------------
char _scrt_stub_for_acrt_thread_attach()
{
  return 1;
}

//----- (000000018002A3F8) ----------------------------------------------------
char _scrt_stub_for_acrt_uninitialize_critical()
{
  return 1;
}

//----- (000000018002A404) ----------------------------------------------------
__int64 _scrt_stub_for_is_c_termination_complete()
{
  return 0i64;
}

//----- (000000018002A410) ----------------------------------------------------
CSslBasicAllocator *__fastcall CSslBasicAllocator::CSslBasicAllocator(CSslBasicAllocator *this)
{
  *(_QWORD *)this = &CSslBasicAllocator::`vftable';
  return this;
}
// 18007D4E0: using guessed type void *CSslBasicAllocator::`vftable';

//----- (000000018002A428) ----------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  int v4; // ebx

  if ( fdwReason == 1 )
  {
    CSslGlobals::m_hInstance = hinstDLL;
    DisableThreadLibraryCalls(hinstDLL);
    if ( RtlInitializeCriticalSection(&CSslGlobals::m_InitCriticalSection) >= 0 )
    {
      g_bInitCritSecInitialized = 1;
      if ( RtlInitializeCriticalSection(&CSslGlobals::m_DTLSInitCriticalSection) >= 0 )
      {
        g_bDTLSInitCritSecInitialized = 1;
        if ( (int)TlsInitializeDefaultAlgorithms() >= 0 )
        {
          GetExternalSchannelAlgorithms();
          McGenEventRegister_EtwEventRegister();
          WPP_INIT_CONTROL_ARRAY();
          WPP_GLOBAL_Control = (CCipherMill *)&WPP_MAIN_CB;
          WPP_REGISTRATION_GUIDS = (__int64)&WPP_ThisDir_CTLGUID_SchannelWppGuid;
          WppInitUm();
          return 1;
        }
      }
    }
    return 0;
  }
  else
  {
    if ( fdwReason )
      return 1;
    v4 = SchannelShutdown();
    if ( g_bInitCritSecInitialized )
      RtlDeleteCriticalSection(&CSslGlobals::m_InitCriticalSection);
    if ( g_bDTLSInitCritSecInitialized )
      RtlDeleteCriticalSection(&CSslGlobals::m_DTLSInitCriticalSection);
    RemoveExternalSchannelAlgorithms();
    McGenEventUnregister_EtwEventUnregister();
    DeleteDebugTracing();
    WppCleanupUm();
    return v4;
  }
}
// 180092198: using guessed type unsigned __int8 g_bDTLSInitCritSecInitialized;
// 180092199: using guessed type unsigned __int8 g_bInitCritSecInitialized;
// 180092A60: using guessed type __int64 WPP_MAIN_CB;
// 180092A88: using guessed type __int64 WPP_REGISTRATION_GUIDS;

//----- (000000018002A530) ----------------------------------------------------
__int64 __fastcall CCipherMill::GetProtocolsWithCipherSuitesEnabled(CCipherMill *this, char a2)
{
  __int64 result; // rax

  result = (unsigned int)qword_1800925C0;
  if ( a2 )
    return HIDWORD(qword_1800925C0);
  return result;
}
// 1800925C0: using guessed type __int64 qword_1800925C0;

//----- (000000018002A548) ----------------------------------------------------
bool __fastcall CTlsSignatureSuiteList::Restrict(
        CTlsSignatureSuiteList *this,
        const struct CTlsSignatureSuiteList *a2,
        __int16 a3)
{
  unsigned __int16 *v4; // r11
  unsigned __int16 v5; // ax
  bool v6; // zf
  unsigned __int8 i; // r10
  int v8; // eax

  v4 = (unsigned __int16 *)this;
  if ( !a2 )
    return 0;
  v5 = *((_WORD *)a2 + 17);
  v6 = (v5 & *((_WORD *)this + 17)) == 0;
  *((_WORD *)this + 17) &= v5;
  *(_WORD *)this = 0;
  if ( v6 )
    return 0;
  for ( i = 0; i < 0xCu; ++i )
  {
    v8 = v4[17];
    if ( _bittest(&v8, i) )
    {
      v4[17] = v8 & ~(1 << i);
      if ( (a3 & 0x3000) == 0 || *((_DWORD *)&unk_18007C3AC + 18 * i) != 2 )
        CTlsSignatureSuiteList::AddSignatureSuite((CTlsSignatureSuiteList *)v4, i);
    }
  }
  return *v4 != 0;
}
// 18002A56F: variable 'v4' is possibly undefined
// 18002A5AD: variable 'i' is possibly undefined

//----- (000000018002A7E0) ----------------------------------------------------
CTls13ClientContext *__fastcall CTls13ClientContext::`vector deleting destructor'(__int64 a1)
{
  return CTls13ClientContext::`vector deleting destructor'((CTls13ClientContext *)(a1 - 1368));
}

//----- (000000018002A800) ----------------------------------------------------
CTls13ServerContext *__fastcall CTls13ServerContext::`vector deleting destructor'(__int64 a1)
{
  return CTls13ServerContext::`scalar deleting destructor'((CTls13ServerContext *)(a1 - 1000));
}

//----- (000000018002A960) ----------------------------------------------------
void dynamic_atexit_destructor_for__g_cCipherMill__()
{
  CCipherMill::~CCipherMill((CCipherMill *)&g_cCipherMill);
}
// 180092420: using guessed type char g_cCipherMill;

//----- (000000018002A980) ----------------------------------------------------
void dynamic_atexit_destructor_for__g_SslContextManager__()
{
  CSslContextManager::~CSslContextManager((CSslContextManager *)&g_SslContextManager);
}
// 180092DA0: using guessed type __int64 g_SslContextManager;

//----- (0000000180040EA4) ----------------------------------------------------
__int64 __fastcall RemotelyCloseClientKeyHandle(__int64 a1, __int64 a2, int a3)
{
  int v6; // r14d
  CCipherMill *v7; // rcx
  unsigned __int64 v8; // rax
  unsigned int v9; // ebx
  _DWORD *v10; // rdx
  __int64 v11; // r8
  _DWORD *v12; // r9
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  CCipherMill *v15; // rcx
  __int64 v16; // rax
  unsigned int v17; // ebx
  int v18; // eax
  __int64 v19; // [rsp+20h] [rbp-50h]
  __int64 v20; // [rsp+30h] [rbp-40h] BYREF
  __int128 v21; // [rsp+38h] [rbp-38h] BYREF
  int v22[2]; // [rsp+48h] [rbp-28h] BYREF
  _DWORD *v23; // [rsp+50h] [rbp-20h]
  char v24[24]; // [rsp+58h] [rbp-18h] BYREF
  int v25; // [rsp+B0h] [rbp+40h] BYREF
  int v26; // [rsp+B8h] [rbp+48h] BYREF

  v25 = a3;
  v26 = 0;
  v20 = 0i64;
  LOBYTE(v25) = 0;
  v21 = 0i64;
  if ( !LsaTable )
    return 87i64;
  if ( !(*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v24) )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x14u,
        (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids,
        -1073741595,
        -1073741595);
    return 3221225701i64;
  }
  v6 = v24[8] & 0x40;
  v7 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 21i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
      v7 = WPP_GLOBAL_Control;
    }
    if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v7 + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)v7 + 2), 22i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
        v7 = WPP_GLOBAL_Control;
      }
      if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)v7 + 28) & 4) != 0 )
        {
          WPP_SF_q(*((_QWORD *)v7 + 2), 0x17u, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids, a1);
          v7 = WPP_GLOBAL_Control;
        }
        if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v7 + 28) & 4) != 0 )
          WPP_SF_q(*((_QWORD *)v7 + 2), 0x18u, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids, a2);
      }
    }
  }
  if ( (*(int (__fastcall **)(int *, __int64 *, _QWORD, __int128 *, int *))(LsaTable + 488))(
         &v26,
         &v20,
         0i64,
         &v21,
         &v25) < 0 )
    return 1359i64;
  v22[1] = 1;
  v8 = (unsigned int)v21;
  v9 = v6 != 0 ? 8 : 16;
  if ( (_DWORD)v21 )
  {
    v10 = (_DWORD *)*((_QWORD *)&v21 + 1);
  }
  else
  {
    LODWORD(v21) = v6 != 0 ? 8 : 16;
    *((_QWORD *)&v21 + 1) = (*(__int64 (__fastcall **)(_QWORD))(LsaTable + 384))(v9);
    v10 = (_DWORD *)*((_QWORD *)&v21 + 1);
    if ( !*((_QWORD *)&v21 + 1) )
      return 14i64;
    v8 = (unsigned int)v21;
  }
  v11 = v20;
  v12 = v10;
  v23 = v10;
  v22[0] = v8;
  if ( v20 )
  {
    if ( v8 >= (unsigned __int64)v9 * (v20 + 1) )
    {
      v10 = (_DWORD *)((char *)v10 + v20 * v9);
      goto LABEL_29;
    }
    return 1359i64;
  }
LABEL_29:
  if ( v6 )
    *v10 = a1;
  else
    *(_QWORD *)v10 = a1;
  v13 = -(__int64)(v6 != 0) & 0xFFFFFFFFFFFFFFFCui64;
  if ( v6 )
    *(_DWORD *)((char *)v10 + v13 + 8) = a2;
  else
    *(_QWORD *)((char *)v10 + v13 + 8) = a2;
  v14 = ++v20;
  v15 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 25i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
    v14 = v20;
    v15 = WPP_GLOBAL_Control;
  }
  v16 = LsaTable;
  if ( !LsaTable )
  {
    v17 = -2146893052;
LABEL_45:
    if ( v15 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v15 + 28) & 1) != 0 )
    {
      WPP_SF_D(*((_QWORD *)v15 + 2), 26i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v17);
      v16 = LsaTable;
    }
    (*(void (__fastcall **)(_DWORD *, __int64, __int64, _DWORD *))(v16 + 392))(v23, v14, v11, v12);
    goto LABEL_49;
  }
  LOBYTE(v19) = 0;
  v18 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, int *, _DWORD))(LsaTable + 496))(5i64, v14, 0i64, v22, v19);
  v17 = v18;
  if ( v18 < 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        10i64,
        &WPP_66cada2652f531372f2ad4492a08a619_Traceguids,
        (unsigned int)v18);
    CleanupAppModeInfo(0i64);
    v16 = LsaTable;
    v15 = WPP_GLOBAL_Control;
    goto LABEL_45;
  }
LABEL_49:
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v17 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    LODWORD(v19) = v17;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x1Bu,
      (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids,
      v17,
      v19);
  }
  return v17;
}
// 18004115D: variable 'v19' is possibly undefined
// 1800411DF: variable 'v14' is possibly undefined
// 1800411DF: variable 'v11' is possibly undefined
// 1800411DF: variable 'v12' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180041244) ----------------------------------------------------
__int64 __fastcall RemotelyGetAppDataStatus(struct CSsl3TlsContext *a1)
{
  int v1; // edi
  void *v4; // rax
  void **v5; // rcx
  int v6; // ebx
  struct _SecBuffer Size; // [rsp+40h] [rbp-40h] BYREF
  void *v8[2]; // [rsp+50h] [rbp-30h] BYREF
  char v9[32]; // [rsp+60h] [rbp-20h] BYREF

  v1 = *((unsigned __int8 *)a1 + 266);
  *(_OWORD *)v8 = 0i64;
  if ( !LsaTable )
    return 87i64;
  Size.pvBuffer = 0i64;
  *(_QWORD *)&Size.cbBuffer = 0x100000000i64;
  if ( !(*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v9) )
    return 1359i64;
  if ( (v9[8] & 0x40) != 0 )
  {
    Size.cbBuffer = 8;
    if ( (_BYTE)v1 )
    {
      v4 = (void *)(*(__int64 (__fastcall **)(__int64))(LsaTable + 384))(8i64);
      Size.pvBuffer = v4;
      if ( !v4 )
        return 14i64;
      memcpy_0(v4, (char *)a1 + 128, Size.cbBuffer);
    }
    else
    {
      Size.pvBuffer = (char *)a1 + 128;
    }
  }
  v5 = v8;
  if ( (_BYTE)v1 )
    v5 = 0i64;
  v6 = PerformApplicationCallback(
         9i64,
         *((_QWORD *)a1 + 16),
         -(__int64)((_BYTE)v1 != 0) & 8,
         &Size,
         (struct _SecBuffer *)v5,
         (_BYTE)v1 == 0,
         v1,
         1);
  if ( v6 >= 0 )
  {
    if ( (_BYTE)v1 )
    {
      v6 = 590610;
    }
    else if ( LODWORD(v8[0]) )
    {
      v6 = 0;
      *((_BYTE *)a1 + 472) = *(_BYTE *)v8[1];
    }
    else
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 45i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
      v6 = 87;
    }
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        44i64,
        &WPP_66cada2652f531372f2ad4492a08a619_Traceguids,
        (unsigned int)v6);
    if ( (_BYTE)v1 && Size.pvBuffer )
      (*(void (**)(void))(LsaTable + 392))();
  }
  if ( v8[1] )
    SPExternalFree(v8[1]);
  return (unsigned int)v6;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180041460) ----------------------------------------------------
__int64 __fastcall RemotelyOpenClientKeyHandle(
        const unsigned __int16 *Src,
        const unsigned __int16 *a2,
        unsigned __int8 *a3,
        int a4,
        unsigned int a5,
        unsigned int a6)
{
  unsigned int v8; // r14d
  unsigned int v9; // r15d
  char *v11; // rbx
  unsigned int v12; // esi
  size_t v13; // rdx
  char *v14; // rax
  char *v15; // rdi
  char *v16; // rdi
  CCipherMill *v17; // r10
  __int64 v18; // rax
  __int64 v19; // rdx
  size_t v20; // r8
  unsigned int v21; // ebx
  int v22; // eax
  int v23; // [rsp+20h] [rbp-40h]
  int v24; // [rsp+30h] [rbp-30h] BYREF
  size_t Size; // [rsp+38h] [rbp-28h] BYREF
  __int64 v26; // [rsp+40h] [rbp-20h] BYREF
  void *Srca[2]; // [rsp+48h] [rbp-18h] BYREF

  v24 = 0;
  Size = 0i64;
  v26 = 0i64;
  v8 = 0;
  v9 = 0;
  *(_OWORD *)Srca = 0i64;
  if ( !LsaTable )
    return 87i64;
  if ( (*(int (__fastcall **)(int *, __int64 *, size_t *, void **, _QWORD))(LsaTable + 488))(
         &v24,
         &v26,
         &Size,
         Srca,
         0i64) < 0 )
    return 1359i64;
  if ( Src )
    v8 = 2 * lstrlenW(Src) + 2;
  if ( a2 )
    v9 = 2 * lstrlenW(a2) + 2;
  v11 = (char *)Srca[1];
  v12 = v9 + v8 + 44;
  if ( Srca[1] )
  {
    v13 = Size;
    if ( LODWORD(Srca[0]) >= Size + v12 )
      goto LABEL_16;
    v14 = (char *)(*(__int64 (__fastcall **)(_QWORD))(LsaTable + 384))(4 * v12 + LODWORD(Srca[0]));
    v11 = v14;
    if ( v14 )
    {
      memcpy_0(v14, Srca[1], Size);
      (*(void (__fastcall **)(void *))(LsaTable + 392))(Srca[1]);
      LODWORD(Srca[0]) += 4 * v12;
      v13 = Size;
      Srca[1] = v11;
      goto LABEL_16;
    }
    return 14i64;
  }
  LODWORD(Srca[0]) = 4 * v12 + 8;
  Srca[1] = (void *)(*(__int64 (**)(void))(LsaTable + 384))();
  v11 = (char *)Srca[1];
  if ( !Srca[1] )
    return 14i64;
  v13 = Size + 8;
  Size += 8i64;
LABEL_16:
  v15 = &v11[v13];
  *(_DWORD *)v15 = v12 - 4;
  *(_OWORD *)(v15 + 4) = *(_OWORD *)a3;
  *((_DWORD *)v15 + 5) = *((_DWORD *)a3 + 4);
  *((_DWORD *)v15 + 6) = a5;
  *((_DWORD *)v15 + 7) = a6;
  *((_DWORD *)v15 + 8) = a4;
  *((_DWORD *)v15 + 9) = v8;
  *((_DWORD *)v15 + 10) = v9;
  v16 = &v11[v13 + 44];
  memcpy_0(v16, Src, v8);
  memcpy_0(&v16[v8], a2, v9);
  v17 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
    v17 = WPP_GLOBAL_Control;
  }
  v18 = LsaTable;
  v19 = v26 + 1;
  v20 = Size + v12;
  Size = v20;
  ++v26;
  if ( !LsaTable )
  {
    v21 = -2146893052;
LABEL_26:
    if ( Srca[1] )
    {
      (*(void (**)(void))(v18 + 392))();
      v17 = WPP_GLOBAL_Control;
    }
    if ( v17 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v17 + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)v17 + 2), 19i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v21);
    return v21;
  }
  LOBYTE(v23) = 1;
  v22 = (*(__int64 (__fastcall **)(__int64, __int64, size_t, void **, int))(LsaTable + 496))(4i64, v19, v20, Srca, v23);
  v21 = v22;
  if ( v22 < 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        10i64,
        &WPP_66cada2652f531372f2ad4492a08a619_Traceguids,
        (unsigned int)v22);
    CleanupAppModeInfo(0i64);
    v18 = LsaTable;
    v17 = WPP_GLOBAL_Control;
    goto LABEL_26;
  }
  return v21;
}
// 1800416DF: variable 'v23' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180041794) ----------------------------------------------------
__int64 __fastcall RemotelySetMtu(struct CSslContext *a1)
{
  int v1; // edi
  unsigned int cbBuffer; // ecx
  _QWORD *v5; // rax
  _WORD *v6; // rcx
  struct _SecBuffer *v7; // r9
  __int64 v8; // rdx
  int v9; // ebx
  struct _SecBuffer v10; // [rsp+40h] [rbp-40h] BYREF
  int v11[2]; // [rsp+50h] [rbp-30h] BYREF
  __int64 v12; // [rsp+58h] [rbp-28h]
  char v13[8]; // [rsp+60h] [rbp-20h] BYREF
  char v14; // [rsp+68h] [rbp-18h]

  v1 = *((unsigned __int8 *)a1 + 266);
  if ( !LsaTable )
    return 87i64;
  v10.cbBuffer = 4;
  if ( !(*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v13) )
    return 1359i64;
  if ( (v14 & 0x40) != 0 )
  {
    cbBuffer = v10.cbBuffer + 8;
    v10.cbBuffer += 8;
  }
  else
  {
    cbBuffer = v10.cbBuffer;
  }
  v10.BufferType = 1;
  if ( (_BYTE)v1 )
    v5 = (_QWORD *)(*(__int64 (**)(void))(LsaTable + 384))();
  else
    v5 = SPExternalAlloc(cbBuffer);
  v10.pvBuffer = v5;
  v6 = v5;
  if ( !v5 )
    return 14i64;
  if ( (v14 & 0x40) != 0 )
  {
    *v5 = *((_QWORD *)a1 + 16);
    v6 = v5 + 1;
  }
  v7 = (struct _SecBuffer *)v11;
  *v6 = *((_WORD *)a1 + 108);
  v6[1] = *((_WORD *)a1 + 109);
  if ( (_BYTE)v1 )
    v7 = 0i64;
  v8 = *((_QWORD *)a1 + 16);
  v11[1] = 1;
  v11[0] = 0;
  v12 = 0i64;
  v9 = PerformApplicationCallback(8i64, v8, (_BYTE)v1 != 0 ? 8 : 0, &v10, v7, 0, v1, 0);
  if ( v9 < 0
    && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    WPP_SF_D(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      43i64,
      &WPP_66cada2652f531372f2ad4492a08a619_Traceguids,
      (unsigned int)v9);
  }
  if ( v10.pvBuffer )
  {
    if ( (_BYTE)v1 )
    {
      if ( v9 < 0 )
        (*(void (**)(void))(LsaTable + 392))();
    }
    else
    {
      SPExternalFree(v10.pvBuffer);
    }
  }
  return (unsigned int)v9;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;
// 180041794: using guessed type char var_20[8];

//----- (0000000180041960) ----------------------------------------------------
__int64 __fastcall RemotelySignHash(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int a4,
        unsigned int a5,
        unsigned int a6,
        LPCWSTR lpString,
        LPCWSTR a8,
        unsigned __int8 *Src,
        size_t Size)
{
  size_t v10; // rbx
  unsigned int v11; // r14d
  CCipherMill *v15; // rcx
  char *v16; // rdi
  char *v17; // rdi
  __int64 v18; // rax
  unsigned int v19; // ebx
  _BOOL8 v20; // r8
  int v21; // eax
  int v22[2]; // [rsp+30h] [rbp-38h] BYREF
  char *v23; // [rsp+38h] [rbp-30h]

  v10 = 0i64;
  v11 = 0;
  if ( !LsaTable )
    return 87i64;
  if ( lpString )
    v10 = (unsigned int)(2 * lstrlenW(lpString) + 2);
  if ( a8 )
    v11 = 2 * lstrlenW(a8) + 2;
  v22[1] = 1;
  v22[0] = v11 + v10 + Size + 36;
  v23 = (char *)(*(__int64 (**)(void))(LsaTable + 384))();
  if ( !v23 )
    return 14i64;
  v15 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xCu, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids, a1);
      v15 = WPP_GLOBAL_Control;
    }
    if ( v15 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v15 + 28) & 4) != 0 )
      {
        WPP_SF_q(*((_QWORD *)v15 + 2), 0xDu, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids, a3);
        v15 = WPP_GLOBAL_Control;
      }
      if ( v15 != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)v15 + 28) & 4) != 0 )
        {
          WPP_SF_D(*((_QWORD *)v15 + 2), 14i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids, a4);
          v15 = WPP_GLOBAL_Control;
        }
        if ( v15 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v15 + 28) & 4) != 0 )
        {
          WPP_SF_S(*((_QWORD *)v15 + 2), 0xFu, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids, lpString);
          v15 = WPP_GLOBAL_Control;
        }
      }
    }
  }
  if ( a8 && v15 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v15 + 28) & 4) != 0 )
    WPP_SF_S(*((_QWORD *)v15 + 2), 0x10u, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids, a8);
  v16 = v23;
  *((_DWORD *)v23 + 5) = 0;
  *(_DWORD *)v16 = a5;
  *((_DWORD *)v16 + 1) = a6;
  *(_QWORD *)(v16 + 12) = a2;
  *((_DWORD *)v16 + 2) = a4;
  *((_DWORD *)v16 + 6) = v10;
  *((_DWORD *)v16 + 7) = v11;
  *((_DWORD *)v16 + 8) = Size;
  v16 += 36;
  memcpy_0(v16, lpString, v10);
  v17 = &v16[v10];
  if ( v11 )
  {
    memcpy_0(v17, a8, v11);
    v17 += v11;
  }
  memcpy_0(v17, Src, (unsigned int)Size);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 17i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
  v18 = LsaTable;
  if ( LsaTable )
  {
    v20 = a3 != 0;
    if ( !a3 )
      a3 = a1;
    v21 = (*(__int64 (__fastcall **)(__int64, __int64, _BOOL8, int *, char))(LsaTable + 496))(1i64, a3, v20, v22, 1);
    v19 = v21;
    if ( v21 < 0 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          10i64,
          &WPP_66cada2652f531372f2ad4492a08a619_Traceguids,
          (unsigned int)v21);
      CleanupAppModeInfo(0i64);
    }
    if ( !v19 )
      return 590610i64;
    v18 = LsaTable;
  }
  else
  {
    v19 = -2146893052;
  }
  if ( v23 )
    (*(void (**)(void))(v18 + 392))();
  return v19;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180041CB0) ----------------------------------------------------
#error "180041CC3: call analysis failed (funcsize=8)"

//----- (0000000180041CDC) ----------------------------------------------------
#error "180041D05: call analysis failed (funcsize=13)"

//----- (0000000180041D20) ----------------------------------------------------
__int64 WPP_SF_DD(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, ...)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+80h] [rbp+28h] BYREF

  va_start(va, a4);
  v5 = a4;
  return EtwTraceMessage(a1, 43i64, a3, a2, &v5, 4i64, (__int64 *)va, 4i64, 0i64);
}

//----- (0000000180041D70) ----------------------------------------------------
__int64 __fastcall WPP_SF_S(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v7; // [rsp+38h] [rbp-10h]
  __int64 v8; // [rsp+40h] [rbp-8h]

  if ( a4 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( a4[v4] );
    v5 = 2 * v4 + 2;
  }
  else
  {
    v5 = 10i64;
  }
  if ( !a4 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43i64, a3, a2, a4, v5, 0i64, v7, v8);
}
// 180041DBF: variable 'v7' is possibly undefined
// 180041DBF: variable 'v8' is possibly undefined
// 180083C60: using guessed type wchar_t aNull_0[5];

//----- (0000000180041DD8) ----------------------------------------------------
__int64 WPP_SF_SD(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, ...)
{
  __int64 v4; // rax
  __int64 v5; // rax
  va_list va; // [rsp+80h] [rbp+28h] BYREF

  va_start(va, a4);
  if ( a4 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( a4[v4] );
    v5 = 2 * v4 + 2;
  }
  else
  {
    v5 = 10i64;
  }
  if ( !a4 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43i64, a3, a2, a4, v5, va, 4i64, 0i64);
}
// 180083C60: using guessed type wchar_t aNull_0[5];

//----- (0000000180041E58) ----------------------------------------------------
__int64 WPP_SF_i(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  __int64 v4; // [rsp+38h] [rbp-10h]
  __int64 v5; // [rsp+40h] [rbp-8h]
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  return EtwTraceMessage(a1, 43i64, a3, a2, (__int64 *)va, 8i64, 0i64, v4, v5);
}
// 180041E81: variable 'v4' is possibly undefined
// 180041E81: variable 'v5' is possibly undefined

//----- (0000000180041E9C) ----------------------------------------------------
__int64 WPP_SF_q(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  __int64 v4; // [rsp+38h] [rbp-10h]
  __int64 v5; // [rsp+40h] [rbp-8h]
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  return EtwTraceMessage(a1, 43i64, a3, a2, (__int64 *)va, 8i64, 0i64, v4, v5);
}
// 180041EC5: variable 'v4' is possibly undefined
// 180041EC5: variable 'v5' is possibly undefined

//----- (0000000180041EE0) ----------------------------------------------------
__int64 __fastcall CopyClientString(unsigned __int16 *a1, int a2, char a3, struct _UNICODE_STRING *a4)
{
  int v7; // ebx
  WCHAR *v8; // rax
  int v9; // ebx
  unsigned int v10; // esi
  struct _STRING SourceString; // [rsp+30h] [rbp-38h] BYREF

  *(_DWORD *)&a4->Length = 0;
  a4->Buffer = 0i64;
  SourceString.Buffer = 0i64;
  v7 = 0;
  if ( !a1 )
    return (unsigned int)v7;
  if ( a2 )
  {
    v9 = (a3 != 0) + 1;
    v10 = v9 * (a2 + 1);
    if ( v10 > 0xFFFF || v10 - v9 > 0xFFFF )
    {
      v7 = -1073741811;
      goto LABEL_16;
    }
    SourceString.Buffer = (PCHAR)LocalAlloc(0x40u, v10);
    if ( !SourceString.Buffer )
      return (unsigned int)-1073741801;
    SourceString.MaximumLength = v10;
    SourceString.Length = v10 - ((a3 != 0) + 1);
    v7 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, PCHAR, unsigned __int16 *))(LsaTable + 80))(
           0i64,
           v10 - v9,
           SourceString.Buffer,
           a1);
    if ( v7 < 0 )
      goto LABEL_16;
    if ( a3 )
    {
      a4->Buffer = (PWSTR)SourceString.Buffer;
      a4->Length = v10 - ((a3 != 0) + 1);
      a4->MaximumLength = v10;
      goto LABEL_16;
    }
    if ( RtlAnsiStringToUnicodeString(a4, &SourceString, 1u) >= 0 )
      goto LABEL_16;
  }
  else
  {
    v8 = (WCHAR *)LocalAlloc(0x40u, 2ui64);
    a4->Buffer = v8;
    if ( v8 )
    {
      a4->MaximumLength = 2;
      *v8 = 0;
      goto LABEL_16;
    }
  }
  v7 = -1073741801;
LABEL_16:
  if ( SourceString.Buffer && (!a3 || v7 < 0) )
    LocalFree(SourceString.Buffer);
  return (unsigned int)v7;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004206C) ----------------------------------------------------
__int64 __fastcall LoadCredentialsFromLocalStore(
        unsigned int a1,
        const struct _CERT_CONTEXT **a2,
        int a3,
        void *a4,
        struct LSA_SCHANNEL_CRED *a5)
{
  unsigned int v5; // ebx
  HLOCAL v9; // rax
  struct LSA_SCHANNEL_CRED *v10; // rcx
  unsigned int v11; // r13d
  char *v12; // r14
  __int64 v13; // rsi
  char *v14; // r15
  __int64 v15; // r12
  unsigned __int16 *v16; // rax
  unsigned __int8 *v17; // r10
  int v18; // edx
  int v19; // edi
  __int64 v20; // rcx
  int v21; // edi
  const struct _CERT_CONTEXT *CertificateByHash; // rax
  unsigned __int16 *v23; // [rsp+30h] [rbp-48h]
  __int64 v24; // [rsp+38h] [rbp-40h]

  v5 = 0;
  if ( a1 > 0x4924924 )
    return 2148074333i64;
  v9 = SPExternalAlloc(56 * a1);
  v10 = a5;
  *((_QWORD *)a5 + 1) = v9;
  if ( !v9 )
  {
    v5 = 14;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x2Du,
        (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
        14,
        14);
    return v5;
  }
  v11 = 0;
  if ( !a1 )
    return v5;
  v12 = (char *)a2 + 4;
  v13 = 0i64;
  v14 = v12;
  while ( 1 )
  {
    v15 = *((_QWORD *)v10 + 1);
    v16 = 0i64;
    v17 = 0i64;
    v23 = 0i64;
    v18 = 0;
    v24 = 0i64;
    v19 = 0;
    if ( a3 == 2 )
    {
      v20 = *(_QWORD *)(v14 + 4);
      v17 = (unsigned __int8 *)(v14 + 12);
      v21 = *(_DWORD *)v14;
      v16 = (unsigned __int16 *)(v14 + 32);
    }
    else
    {
      if ( a3 != 1 )
        goto LABEL_14;
      v20 = *(_QWORD *)(v12 + 4);
      v17 = (unsigned __int8 *)(v12 + 12);
      v21 = *(_DWORD *)v12;
      v16 = L"MY";
    }
    v19 = v21 & 1;
    v24 = v20;
    v23 = v16;
    v18 = 20;
LABEL_14:
    CertificateByHash = SslGetCertificateByHash(v17, v18, v19, v16, a4);
    *(_QWORD *)(v13 + v15) = CertificateByHash;
    if ( !CertificateByHash )
      break;
    if ( v19 && !(unsigned int)_o__wcsicmp(v23, L"MY") )
      *(_DWORD *)(v13 + v15 + 48) |= 1u;
    ++v11;
    v10 = a5;
    v14 += 296;
    *(_QWORD *)(v13 + v15 + 16) = v24;
    v12 += 40;
    v13 += 56i64;
    if ( v11 >= a1 )
      return v5;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 46i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
  return (unsigned int)-2146893042;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080C40: using guessed type __int64 __fastcall _o__wcsicmp(_QWORD, _QWORD);
// 18008275C: using guessed type wchar_t aMy[3];

//----- (0000000180042244) ----------------------------------------------------
__int64 __fastcall LoadImplicitCredentials(struct _UNICODE_STRING *a1, __int64 a2, struct LSA_SCHANNEL_CRED *a3)
{
  void *v5; // r12
  void *v6; // r13
  unsigned int v8; // eax
  unsigned int v9; // edi
  unsigned int CertificatesFromLocator; // eax
  __int64 v11; // rcx
  __int64 v12; // r8
  CCipherMill *v13; // rcx
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // r8
  void *v19; // rcx
  void *v20; // rax
  __int64 v21; // r8
  __int64 v22; // rcx
  DWORD LastError; // eax
  void *Content; // rax
  __int64 v25; // rcx
  __int64 v26; // r8
  struct LSA_SCHANNEL_CRED *v27; // r15
  __int64 v28; // [rsp+20h] [rbp-78h]
  int v29; // [rsp+30h] [rbp-68h] BYREF
  struct _CRYPTOAPI_BLOB v30; // [rsp+38h] [rbp-60h] BYREF
  struct LSA_SCHANNEL_CRED *v31; // [rsp+48h] [rbp-50h]
  char v32[16]; // [rsp+50h] [rbp-48h] BYREF

  v31 = a3;
  v5 = 0i64;
  v6 = 0i64;
  v29 = 0;
  v30 = 0i64;
  if ( a1->Length )
  {
    if ( !CSslGlobals::m_hCertLocator )
    {
      v8 = CSslGlobals::InitializeCryptLocatorHandles();
      v9 = v8;
      if ( v8 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 38i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, v8);
        return v9;
      }
    }
    CertificatesFromLocator = SslImpersonateClient(a2, &v29);
    v9 = CertificatesFromLocator;
    if ( CertificatesFromLocator )
    {
      v13 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        goto LABEL_47;
      v14 = 39i64;
    }
    else
    {
      v30.cbData = a1->Length;
      v30.pbData = (BYTE *)a1->Buffer;
      if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
        McGenEventWrite_EtwEventWriteTransfer(v11, (__int64)&LocatorGetStart, v12, 1, (__int64)v32);
      v5 = CryptObjectLocatorGet(CSslGlobals::m_hCertLocator, 1u, &v30);
      if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
        McGenEventWrite_EtwEventWriteTransfer(v15, (__int64)&LocatorGetStop, v16, 1, (__int64)v32);
      if ( v5 )
      {
        CertificatesFromLocator = LoadCertificatesFromLocator(v5, v31, v16, v17);
        v9 = CertificatesFromLocator;
        if ( CertificatesFromLocator )
        {
          v13 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_47;
          }
          v14 = 41i64;
        }
        else
        {
          v19 = CSslGlobals::m_hIssuersLocator;
          v5 = 0i64;
          if ( !CSslGlobals::m_hIssuersLocator )
            goto LABEL_46;
          v30.cbData = a1->Length;
          v30.pbData = (BYTE *)a1->Buffer;
          if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
          {
            McGenEventWrite_EtwEventWriteTransfer(
              (__int64)CSslGlobals::m_hIssuersLocator,
              (__int64)&LocatorGetStart,
              v18,
              1,
              (__int64)v32);
            v19 = CSslGlobals::m_hIssuersLocator;
          }
          v20 = CryptObjectLocatorGet(v19, 1u, &v30);
          v22 = (unsigned int)Microsoft_Windows_Schannel_EventsEnableBits;
          v6 = v20;
          if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
          {
            McGenEventWrite_EtwEventWriteTransfer(
              (unsigned int)Microsoft_Windows_Schannel_EventsEnableBits,
              (__int64)&LocatorGetStop,
              v21,
              1,
              (__int64)v32);
            v22 = (unsigned int)Microsoft_Windows_Schannel_EventsEnableBits;
          }
          if ( !v6 )
          {
            LastError = GetLastError();
            v13 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_D(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                42i64,
                &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                LastError);
              v13 = WPP_GLOBAL_Control;
            }
            v9 = 0;
            goto LABEL_47;
          }
          if ( (v22 & 1) != 0 )
            McGenEventWrite_EtwEventWriteTransfer(v22, (__int64)&LocatorGetContentStart, v21, 1, (__int64)v32);
          Content = CryptObjectLocatorGetContent(v6);
          v27 = v31;
          *((_QWORD *)v31 + 6) = Content;
          if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
            McGenEventWrite_EtwEventWriteTransfer(v25, (__int64)&LocatorGetContentStop, v26, 1, (__int64)v32);
          if ( *((_QWORD *)v27 + 6) )
            goto LABEL_46;
          CertificatesFromLocator = GetLastError();
          v9 = CertificatesFromLocator;
          v13 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_47;
          }
          v14 = 43i64;
        }
      }
      else
      {
        CertificatesFromLocator = GetLastError();
        v9 = CertificatesFromLocator;
        v13 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          goto LABEL_47;
        v14 = 40i64;
      }
    }
    WPP_SF_D(*((_QWORD *)v13 + 2), v14, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, CertificatesFromLocator);
LABEL_46:
    v13 = WPP_GLOBAL_Control;
LABEL_47:
    if ( v29 )
    {
      RevertToSelf();
      v13 = WPP_GLOBAL_Control;
    }
    if ( v5 )
    {
      CryptObjectLocatorFree(v5);
      v13 = WPP_GLOBAL_Control;
    }
    if ( v6 )
    {
      CryptObjectLocatorFree(v6);
      v13 = WPP_GLOBAL_Control;
    }
    if ( v13 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v13 + 28) & 0x20) != 0 )
    {
      LODWORD(v28) = v9;
      WPP_SF_DD(*((_QWORD *)v13 + 2), 0x2Cu, (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, v9, v28);
    }
    return v9;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 37i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
  return 2148074253i64;
}
// 180042387: variable 'v11' is possibly undefined
// 180042387: variable 'v12' is possibly undefined
// 1800423C5: variable 'v15' is possibly undefined
// 1800423C5: variable 'v16' is possibly undefined
// 180042408: variable 'v17' is possibly undefined
// 180042476: variable 'v18' is possibly undefined
// 1800424B6: variable 'v21' is possibly undefined
// 18004255A: variable 'v25' is possibly undefined
// 18004255A: variable 'v26' is possibly undefined
// 180042615: variable 'v28' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180084C20: using guessed type EVENT_DESCRIPTOR LocatorGetContentStop;
// 180084C30: using guessed type EVENT_DESCRIPTOR LocatorGetContentStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 180092F60: using guessed type void *CSslGlobals::m_hIssuersLocator;
// 180092F68: using guessed type void *CSslGlobals::m_hCertLocator;
// 180098018: using guessed type void __stdcall CryptObjectLocatorFree(void *);
// 1800980D8: using guessed type void *__stdcall CryptObjectLocatorGet(void *, unsigned int, struct _CRYPTOAPI_BLOB *);
// 180098168: using guessed type void *__stdcall CryptObjectLocatorGetContent(void *);

//----- (0000000180042648) ----------------------------------------------------
__int64 __fastcall MapKernelAuthDataV4(
        struct _SCHANNEL_CRED *a1,
        struct _UNICODE_STRING *a2,
        void *a3,
        struct LSA_SCHANNEL_CRED *a4)
{
  unsigned int ImplicitCredentials; // ebx
  unsigned int cCreds; // ecx
  DWORD cSupportedAlgs; // eax
  unsigned __int64 v11; // rbx
  HLOCAL v12; // rax
  DWORD grbitEnabledProtocols; // eax
  DWORD dwCredFormat; // eax
  struct LSA_SCHANNEL_CRED *v16; // [rsp+20h] [rbp-18h]

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 47i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
  memset_0(a4, 0, 0x70ui64);
  if ( !a1 || a1->dwVersion != 4 )
    return 2148074253i64;
  *(_DWORD *)a4 = 4;
  if ( a2 && a2->Buffer )
  {
    ImplicitCredentials = LoadImplicitCredentials(a2, (__int64)a3, a4);
    if ( !ImplicitCredentials )
    {
LABEL_13:
      cSupportedAlgs = a1->cSupportedAlgs;
      if ( cSupportedAlgs )
      {
        *((_DWORD *)a4 + 14) = cSupportedAlgs;
        v11 = 4i64 * cSupportedAlgs;
        if ( v11 > 0xFFFFFFFF )
        {
          ImplicitCredentials = 534;
          goto LABEL_28;
        }
        v12 = SPExternalAlloc(v11);
        *((_QWORD *)a4 + 8) = v12;
        if ( !v12 )
        {
          ImplicitCredentials = 14;
          goto LABEL_28;
        }
        memcpy_0(v12, a1->palgSupportedAlgs, (unsigned int)v11);
      }
      grbitEnabledProtocols = 0;
      if ( a1->grbitEnabledProtocols != -1 )
        grbitEnabledProtocols = a1->grbitEnabledProtocols;
      *((_DWORD *)a4 + 18) = grbitEnabledProtocols;
      *((_DWORD *)a4 + 19) = a1->dwMinimumCipherStrength;
      *((_DWORD *)a4 + 20) = a1->dwMaximumCipherStrength;
      *((_DWORD *)a4 + 21) = a1->dwSessionLifespan;
      *((_DWORD *)a4 + 22) = a1->dwFlags;
      dwCredFormat = a1->dwCredFormat;
      *((_DWORD *)a4 + 18) &= 0x3FFFFFFFu;
      ImplicitCredentials = 0;
      *((_DWORD *)a4 + 23) = dwCredFormat;
      goto LABEL_21;
    }
  }
  else
  {
    cCreds = a1->cCreds;
    if ( !cCreds )
      goto LABEL_13;
    ImplicitCredentials = LoadCredentialsFromLocalStore(cCreds, a1->paCred, a1->dwCredFormat, a3, a4);
    if ( !ImplicitCredentials )
    {
      *((_DWORD *)a4 + 1) = a1->cCreds;
      goto LABEL_13;
    }
  }
LABEL_28:
  FreeSchannelCred(a4, 1);
LABEL_21:
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && ImplicitCredentials
     || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    LODWORD(v16) = ImplicitCredentials;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x30u,
      (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
      ImplicitCredentials,
      v16);
  }
  return ImplicitCredentials;
}
// 1800427BE: variable 'v16' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180042800) ----------------------------------------------------
__int64 __fastcall MapKernelAuthDataV5(
        struct _SCHANNEL_CRED *a1,
        struct _UNICODE_STRING *a2,
        void *a3,
        struct LSA_SCHANNEL_CRED *a4)
{
  unsigned int ImplicitCredentials; // ebx
  unsigned int paCred; // ecx
  int v8; // eax
  struct _TLS_PARAMETERS **v10; // [rsp+20h] [rbp-18h]

  *(_DWORD *)a4 = 5;
  if ( a2 && a2->Buffer )
  {
    ImplicitCredentials = LoadImplicitCredentials(a2, (__int64)a3, a4);
    if ( ImplicitCredentials )
      goto LABEL_11;
  }
  else
  {
    paCred = (unsigned int)a1->paCred;
    if ( paCred )
    {
      ImplicitCredentials = LoadCredentialsFromLocalStore(
                              paCred,
                              (const struct _CERT_CONTEXT **)a1->hRootStore,
                              a1->cCreds,
                              a3,
                              a4);
      if ( ImplicitCredentials )
        goto LABEL_11;
      *((_DWORD *)a4 + 1) = a1->paCred;
    }
  }
  v8 = CopyTlsParameters(
         *(struct _TLS_PARAMETERS **)&a1->dwMaximumCipherStrength,
         a1->grbitEnabledProtocols,
         0,
         0,
         (struct _TLS_PARAMETERS **)a4 + 13,
         (unsigned int *)a4 + 24);
  if ( !v8 )
  {
    ImplicitCredentials = 0;
    *((_DWORD *)a4 + 21) = a1->palgSupportedAlgs;
    *((_DWORD *)a4 + 22) = HIDWORD(a1->palgSupportedAlgs);
    *((_DWORD *)a4 + 23) = a1->cCreds;
    goto LABEL_13;
  }
  ImplicitCredentials = 14;
  if ( v8 == -2146892963 )
    ImplicitCredentials = 87;
LABEL_11:
  FreeSchannelCred(a4, 1);
LABEL_13:
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && ImplicitCredentials
     || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    LODWORD(v10) = ImplicitCredentials;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x31u,
      (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
      ImplicitCredentials,
      v10);
  }
  return ImplicitCredentials;
}
// 1800428FA: variable 'v10' is possibly undefined

//----- (0000000180042918) ----------------------------------------------------
__int64 __fastcall SpMapAuthIdentity(void *a1, struct LSA_SCHANNEL_CRED *a2, __int64 a3)
{
  HCERTSTORE v6; // r14
  int v8; // ebx
  int v9; // esi
  HLOCAL v10; // rdi
  unsigned int LastError; // ebx
  unsigned __int16 *v12; // rcx
  bool v13; // si
  CCipherMill *v14; // rcx
  unsigned __int16 v15; // dx
  unsigned __int16 *v16; // rcx
  PCCERT_CONTEXT CertificateInStore; // rbx
  _QWORD *v18; // rax
  int v19; // [rsp+30h] [rbp-69h] BYREF
  enum _CRED_MARSHAL_TYPE CredType; // [rsp+34h] [rbp-65h] BYREF
  PVOID Credential; // [rsp+38h] [rbp-61h] BYREF
  struct _UNICODE_STRING v22; // [rsp+40h] [rbp-59h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+50h] [rbp-49h] BYREF
  int pvFindPara; // [rsp+60h] [rbp-39h] BYREF
  __int64 v25; // [rsp+68h] [rbp-31h]
  char v26[24]; // [rsp+70h] [rbp-29h] BYREF
  __int128 v27; // [rsp+88h] [rbp-11h] BYREF
  __int128 v28; // [rsp+98h] [rbp-1h]
  __int64 v29; // [rsp+A8h] [rbp+Fh]
  int v30; // [rsp+B0h] [rbp+17h]

  Credential = 0i64;
  v19 = 0;
  v29 = 0i64;
  v30 = 0;
  v6 = 0i64;
  v27 = 0i64;
  v28 = 0i64;
  if ( !(*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v26) )
    return 1359i64;
  v8 = v26[8] & 0x40;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 34i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
  RtlInitUnicodeString(&DestinationString, 0i64);
  RtlInitUnicodeString(&v22, 0i64);
  v9 = 72;
  v10 = SPExternalAlloc(0x48u);
  if ( v10 )
  {
    if ( v8 )
    {
      LastError = (*(__int64 (__fastcall **)(_QWORD, __int64, __int128 *, void *))(LsaTable + 80))(
                    0i64,
                    44i64,
                    &v27,
                    a1);
      if ( LastError )
        goto LABEL_36;
      *(_DWORD *)v10 = v27;
      if ( DWORD1(v27) >= 0x48 )
        v9 = DWORD1(v27);
      *((_DWORD *)v10 + 1) = v9;
      *((_DWORD *)v10 + 4) = HIDWORD(v27);
      *((_QWORD *)v10 + 1) = DWORD2(v27);
      *((_DWORD *)v10 + 8) = DWORD1(v28);
      *((_QWORD *)v10 + 3) = (unsigned int)v28;
      *((_DWORD *)v10 + 12) = HIDWORD(v28);
      *((_QWORD *)v10 + 5) = DWORD2(v28);
      *((_DWORD *)v10 + 13) = v29;
      *((_DWORD *)v10 + 16) = v30;
      *((_QWORD *)v10 + 7) = HIDWORD(v29);
    }
    else
    {
      LastError = (*(__int64 (__fastcall **)(_QWORD, __int64, HLOCAL, void *))(LsaTable + 80))(0i64, 72i64, v10, a1);
      if ( LastError )
        goto LABEL_36;
    }
    v12 = (unsigned __int16 *)*((_QWORD *)v10 + 1);
    v13 = (*((_BYTE *)v10 + 52) & 1) == 0;
    if ( v12 )
    {
      LastError = CopyClientString(v12, *((_DWORD *)v10 + 4), (*((_BYTE *)v10 + 52) & 1) == 0, &DestinationString);
      if ( LastError )
      {
        v14 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          goto LABEL_36;
        v15 = 35;
        goto LABEL_19;
      }
    }
    v16 = (unsigned __int16 *)*((_QWORD *)v10 + 5);
    if ( !v16 || (LastError = CopyClientString(v16, *((_DWORD *)v10 + 12), v13, &v22)) == 0 )
    {
      if ( CredIsMarshaledCredentialW(DestinationString.Buffer)
        && CredUnmarshalCredentialW(DestinationString.Buffer, &CredType, &Credential)
        && CredType == CertCredential )
      {
        LastError = SslImpersonateClient(a3, &v19);
        if ( !LastError )
        {
          v6 = CertOpenStore((LPCSTR)0xA, 1u, 0i64, 0x10004u, L"MY");
          if ( v6
            && (v25 = (__int64)Credential + 4,
                pvFindPara = 20,
                (CertificateInStore = CertFindCertificateInStore(v6, 1u, 0, 0x10000u, &pvFindPara, 0i64)) != 0i64) )
          {
            v18 = SPExternalAlloc(0x38u);
            *((_QWORD *)a2 + 1) = v18;
            if ( v18 )
            {
              *v18 = CertificateInStore;
              *(_QWORD *)(*((_QWORD *)a2 + 1) + 8i64) = v22.Buffer;
              v22.Buffer = 0i64;
              LastError = 0;
              *((_DWORD *)a2 + 1) = 1;
            }
            else
            {
              LastError = 14;
            }
          }
          else
          {
            LastError = GetLastError();
          }
        }
      }
      else
      {
        LastError = -2146893043;
      }
      goto LABEL_36;
    }
    v14 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      v15 = 36;
LABEL_19:
      WPP_SF_L(*((_QWORD *)v14 + 2), v15, (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, LastError);
    }
LABEL_36:
    SPExternalFree(v10);
    goto LABEL_37;
  }
  LastError = 14;
LABEL_37:
  if ( DestinationString.Buffer )
    LocalFree(DestinationString.Buffer);
  if ( v22.Buffer )
  {
    memset(v22.Buffer, 0, v22.Length);
    LocalFree(v22.Buffer);
  }
  if ( Credential )
    CredFree(Credential);
  if ( v6 )
    CertCloseStore(v6, 0);
  if ( v19 )
    RevertToSelf();
  return LastError;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18008275C: using guessed type wchar_t aMy[3];
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180042D24) ----------------------------------------------------
const struct _CERT_CONTEXT *__fastcall SslGetCertificateByHash(
        unsigned __int8 *a1,
        int a2,
        int a3,
        unsigned __int16 *a4,
        void *a5)
{
  struct _CERT_CONTEXT *v5; // rbx
  CCipherMill *v10; // rcx
  __int64 v11; // rcx
  const char *v12; // r9
  DWORD v13; // edi
  ULONG v14; // eax
  HCERTSTORE v15; // rdi
  DWORD v16; // eax
  const CERT_CONTEXT *CertificateInStore; // rax
  DWORD LastError; // eax
  struct _CERT_CONTEXT *v20; // [rsp+30h] [rbp-48h] BYREF
  int pvFindPara; // [rsp+38h] [rbp-40h] BYREF
  unsigned __int8 *v22; // [rsp+40h] [rbp-38h]
  int v23; // [rsp+90h] [rbp+18h] BYREF

  v23 = 0;
  v5 = 0i64;
  v20 = 0i64;
  v10 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 24i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
      v10 = WPP_GLOBAL_Control;
    }
    if ( v10 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v10 + 28) & 4) != 0 )
      {
        WPP_SF_qd(*((_QWORD *)v10 + 2), 0x19u, (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, a1, a2);
        v10 = WPP_GLOBAL_Control;
      }
      if ( v10 != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)v10 + 28) & 4) != 0 )
        {
          v11 = *((_QWORD *)v10 + 2);
          v12 = "LOCAL_MACHINE";
          if ( !a3 )
            v12 = "CURRENT_USER";
          WPP_SF_s(v11, 0x1Au, (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, v12);
          v10 = WPP_GLOBAL_Control;
        }
        if ( v10 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v10 + 28) & 4) != 0 )
        {
          WPP_SF_S(*((_QWORD *)v10 + 2), 0x1Bu, (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, a4);
          v10 = WPP_GLOBAL_Control;
        }
      }
    }
  }
  if ( a3 )
  {
    v13 = 537002496;
  }
  else
  {
    v13 = 536936960;
    if ( v10 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v10 + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)v10 + 2), 28i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
    v14 = SslImpersonateClient((__int64)a5, &v23);
    v10 = WPP_GLOBAL_Control;
    if ( v14 )
      goto LABEL_39;
  }
  if ( v10 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v10 + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)v10 + 2), 29i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
  v15 = CertOpenStore((LPCSTR)0xA, 1u, 0i64, v13, a4);
  if ( v15 )
  {
    pvFindPara = a2;
    v22 = a1;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 31i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
    CertificateInStore = CertFindCertificateInStore(v15, 1u, 0, 0x10000u, &pvFindPara, 0i64);
    v5 = (struct _CERT_CONTEXT *)CertificateInStore;
    if ( CertificateInStore )
    {
      if ( (unsigned int)CheckForLocalStoreCertificateRenewal(
                           v15,
                           CertificateInStore,
                           0,
                           (const struct _CERT_CONTEXT **)&v20) )
      {
        CertFreeCertificateContext(v5);
        v5 = v20;
      }
    }
    else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      LastError = GetLastError();
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 32i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, LastError);
    }
    CertCloseStore(v15, 0);
    goto LABEL_38;
  }
  v10 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    v16 = GetLastError();
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 30i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, v16);
LABEL_38:
    v10 = WPP_GLOBAL_Control;
  }
LABEL_39:
  if ( v23 )
  {
    RevertToSelf();
    v10 = WPP_GLOBAL_Control;
  }
  if ( v10 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v10 + 28) & 4) != 0 )
    WPP_SF_q(*((_QWORD *)v10 + 2), 0x21u, (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, v5);
  return v5;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180043028) ----------------------------------------------------
__int64 __fastcall UpdatePrivateKeysForCreds(struct CCredentialGroup *this, struct _SecBuffer *a2, char a3)
{
  int v3; // r15d
  unsigned int v4; // ebx
  unsigned int cbBuffer; // esi
  unsigned int *pvBuffer; // rdi
  struct CSslCredential *v10; // rdx
  unsigned int v11; // esi
  __int64 v12; // rax
  __int64 v13; // rcx
  struct CSslCredential *v15; // [rsp+58h] [rbp+10h] BYREF

  v15 = 0i64;
  v3 = 0;
  v4 = 0;
  if ( !a2 || !this )
    return 2148074244i64;
  cbBuffer = a2->cbBuffer;
  pvBuffer = (unsigned int *)a2->pvBuffer;
  while ( 1 )
  {
    if ( !cbBuffer )
    {
      *((_DWORD *)this + 184) = v3;
      goto LABEL_17;
    }
    if ( cbBuffer < 0x14 )
      break;
    if ( (unsigned int)CCredentialGroup::FindCredential(this, (unsigned __int8 *)pvBuffer, 20, &v15) )
      break;
    v10 = v15;
    v11 = cbBuffer - 20;
    if ( !v15 )
      break;
    if ( a3 )
    {
      if ( v11 < 8 )
        break;
      v12 = pvBuffer[5];
      v13 = pvBuffer[6];
      pvBuffer += 7;
      cbBuffer = v11 - 8;
    }
    else
    {
      if ( v11 < 0x10 )
        break;
      v12 = *(_QWORD *)(pvBuffer + 5);
      v13 = *(_QWORD *)(pvBuffer + 7);
      pvBuffer += 9;
      cbBuffer = v11 - 16;
    }
    if ( !v12 && !v13 )
      break;
    *((_QWORD *)v15 + 13) = v12;
    ++v3;
    *((_QWORD *)v10 + 14) = v13;
  }
  v4 = -2146893052;
LABEL_17:
  a2->pvBuffer = 0i64;
  a2->cbBuffer = 0;
  a2->BufferType = 0;
  CleanupAppModeInfo(0i64);
  return v4;
}

//----- (000000018004312C) ----------------------------------------------------
__int64 __fastcall McGenEventWrite_EtwEventWriteTransfer(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5)
{
  unsigned __int16 *v5; // r8
  int v6; // eax
  int v7; // r8d

  v5 = (unsigned __int16 *)qword_180091388;
  v6 = 0;
  if ( qword_180091388 )
  {
    *(_QWORD *)a5 = qword_180091388;
    v6 = 2;
    v7 = *v5;
  }
  else
  {
    *(_QWORD *)a5 = 0i64;
    v7 = 0;
  }
  *(_DWORD *)(a5 + 8) = v7;
  *(_DWORD *)(a5 + 12) = v6;
  return EtwEventWriteTransfer(MS_Schannel_Provider_Context, a2, 0i64, 0i64, a4, a5);
}
// 180080F00: using guessed type __int64 __fastcall EtwEventWriteTransfer(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD);
// 180091388: using guessed type __int64 qword_180091388;

//----- (0000000180043190) ----------------------------------------------------
__int64 __fastcall McTemplateU0d_EtwEventWriteTransfer(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD v4[3]; // [rsp+30h] [rbp-38h] BYREF
  int v5; // [rsp+48h] [rbp-20h]
  int v6; // [rsp+4Ch] [rbp-1Ch]
  int v7; // [rsp+80h] [rbp+18h] BYREF

  v7 = a3;
  v4[2] = &v7;
  v6 = 0;
  v5 = 4;
  return McGenEventWrite_EtwEventWriteTransfer(a1, (__int64)&AchStop, a3, 2, (__int64)v4);
}

//----- (00000001800431F4) ----------------------------------------------------
__int64 __fastcall McTemplateU0p_EtwEventWriteTransfer(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD v4[3]; // [rsp+30h] [rbp-38h] BYREF
  int v5; // [rsp+48h] [rbp-20h]
  int v6; // [rsp+4Ch] [rbp-1Ch]
  __int64 v7; // [rsp+80h] [rbp+18h] BYREF

  v7 = a3;
  v4[2] = &v7;
  v6 = 0;
  v5 = 8;
  return McGenEventWrite_EtwEventWriteTransfer(a1, (__int64)&FchStart, a3, 2, (__int64)v4);
}

//----- (0000000180043258) ----------------------------------------------------
__int64 WPP_SF_Dd(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, ...)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+80h] [rbp+28h] BYREF

  va_start(va, a4);
  v5 = a4;
  return EtwTraceMessage(a1, 43i64, a3, a2, &v5, 4i64, (__int64 *)va, 4i64, 0i64);
}

//----- (00000001800432A8) ----------------------------------------------------
__int64 __fastcall WPP_SF_L(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  __int64 v5; // [rsp+38h] [rbp-10h]
  __int64 v6; // [rsp+40h] [rbp-8h]
  int v7; // [rsp+68h] [rbp+20h] BYREF

  v7 = a4;
  return EtwTraceMessage(a1, 43i64, a3, a2, &v7, 4i64, 0i64, v5, v6);
}
// 1800432D1: variable 'v5' is possibly undefined
// 1800432D1: variable 'v6' is possibly undefined

//----- (00000001800432EC) ----------------------------------------------------
__int64 __fastcall WPP_SF_d(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  __int64 v5; // [rsp+38h] [rbp-10h]
  __int64 v6; // [rsp+40h] [rbp-8h]
  int v7; // [rsp+68h] [rbp+20h] BYREF

  v7 = a4;
  return EtwTraceMessage(a1, 43i64, a3, a2, &v7, 4i64, 0i64, v5, v6);
}
// 180043315: variable 'v5' is possibly undefined
// 180043315: variable 'v6' is possibly undefined

//----- (0000000180043330) ----------------------------------------------------
__int64 WPP_SF_qd(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  __int64 v4; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+78h] [rbp+20h]
  va_list va1; // [rsp+80h] [rbp+28h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  return EtwTraceMessage(a1, 43i64, a3, a2, (__int64 *)va, 8i64, va1, 4i64, 0i64);
}

//----- (0000000180043384) ----------------------------------------------------
__int64 __fastcall WPP_SF_s(__int64 a1, unsigned __int16 a2, __int64 a3, const char *a4)
{
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v7; // [rsp+38h] [rbp-10h]
  __int64 v8; // [rsp+40h] [rbp-8h]

  if ( a4 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( a4[v4] );
    v5 = v4 + 1;
  }
  else
  {
    v5 = 5i64;
  }
  if ( !a4 )
    a4 = "NULL";
  return EtwTraceMessage(a1, 43i64, a3, a2, a4, v5, 0i64, v7, v8);
}
// 1800433CC: variable 'v7' is possibly undefined
// 1800433CC: variable 'v8' is possibly undefined

//----- (00000001800433E4) ----------------------------------------------------
PCCTL_CONTEXT __fastcall FindCtlInStore(const unsigned __int16 *a1, const unsigned __int16 *a2)
{
  HCERTSTORE v4; // rdi
  __int64 v6; // rax
  PCCTL_CONTEXT CTLInStore; // rsi
  void *pvFindPara; // [rsp+20h] [rbp-48h]
  void *pvFindParaa; // [rsp+20h] [rbp-48h]
  __int128 v10; // [rsp+30h] [rbp-38h] BYREF
  __int128 v11; // [rsp+40h] [rbp-28h]
  __int128 v12; // [rsp+50h] [rbp-18h]

  v10 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v4 = CertOpenStore((LPCSTR)0xA, 0, 0i64, 0x20000u, a1);
  if ( v4 )
  {
    LODWORD(v10) = 48;
    v6 = -1i64;
    do
      ++v6;
    while ( a2[v6] );
    DWORD2(v11) = 2 * v6 + 2;
    *(_QWORD *)&v12 = a2;
    CTLInStore = CertFindCTLInStore(v4, 0x10001u, 0, 3u, &v10, 0i64);
    if ( !CTLInStore
      && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
    {
      LODWORD(pvFindParaa) = GetLastError();
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xBu,
        (__int64)&WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids,
        a2,
        pvFindParaa);
    }
    CertCloseStore(v4, 0);
    return CTLInStore;
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      LODWORD(pvFindPara) = GetLastError();
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xAu,
        (__int64)&WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids,
        a1,
        pvFindPara);
    }
    return 0i64;
  }
}
// 180043476: variable 'pvFindPara' is possibly undefined
// 18004351C: variable 'pvFindParaa' is possibly undefined

//----- (0000000180043554) ----------------------------------------------------
__int64 __fastcall InitializeClientCertPolicy(struct _SecPkgCred_ClientCertPolicy *a1, struct CLIENT_CERT_POLICY *a2)
{
  BOOL fOmitUsageCheck; // eax
  const unsigned __int16 *pwszSslCtlIdentifier; // rdx
  LPWSTR pwszSslCtlStoreName; // rax
  PCCTL_CONTEXT CtlInStore; // rax
  HCERTSTORE v9; // rax
  void *pvPara; // [rsp+20h] [rbp-18h]

  *((_DWORD *)a2 + 4) = a1->dwCertFlags;
  *((_DWORD *)a2 + 5) = a1->dwUrlRetrievalTimeout;
  *((_DWORD *)a2 + 6) = a1->fCheckRevocationFreshnessTime;
  *((_DWORD *)a2 + 7) = a1->dwRevocationFreshnessTime;
  *(GUID *)a2 = a1->guidPolicyId;
  fOmitUsageCheck = a1->fOmitUsageCheck;
  *((_QWORD *)a2 + 5) = 0i64;
  *((_DWORD *)a2 + 8) = fOmitUsageCheck;
  pwszSslCtlIdentifier = a1->pwszSslCtlIdentifier;
  pwszSslCtlStoreName = a1->pwszSslCtlStoreName;
  if ( pwszSslCtlIdentifier )
  {
    if ( pwszSslCtlStoreName )
    {
      CtlInStore = FindCtlInStore(a1->pwszSslCtlStoreName, pwszSslCtlIdentifier);
      *((_QWORD *)a2 + 5) = CtlInStore;
      if ( CtlInStore )
        return 0i64;
    }
  }
  else
  {
    if ( !pwszSslCtlStoreName )
      return 0i64;
    v9 = CertOpenStore((LPCSTR)0xA, 0, 0i64, 0x24000u, a1->pwszSslCtlStoreName);
    *((_QWORD *)a2 + 6) = v9;
    if ( v9 )
      return 0i64;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      LODWORD(pvPara) = GetLastError();
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xCu,
        (__int64)&WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids,
        a1->pwszSslCtlStoreName,
        pvPara);
    }
  }
  return 2148074253i64;
}
// 180043639: variable 'pvPara' is possibly undefined

//----- (0000000180043650) ----------------------------------------------------
__int64 __fastcall QueryCredAttributesRpc(struct CCredentialGroup *a1, int a2, _QWORD *a3)
{
  __int64 result; // rax
  int v7; // eax
  CCipherMill *v8; // rcx
  unsigned int v9; // eax
  int v10; // ebx
  size_t v11; // rsi
  void *v12; // rax
  HLOCAL v13; // rbx
  __int64 v14; // rax
  size_t v15; // rsi
  void *v16; // rax
  char v17[56]; // [rsp+20h] [rbp-38h] BYREF
  HLOCAL hMem; // [rsp+60h] [rbp+8h] BYREF
  void *Src; // [rsp+78h] [rbp+20h] BYREF

  Src = 0i64;
  LODWORD(hMem) = 0;
  if ( !a1 )
    return 2148074241i64;
  if ( !(*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v17) )
    return 2148074244i64;
  if ( !a3 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids);
    return 2148074333i64;
  }
  switch ( a2 )
  {
    case 1:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, &WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids);
      hMem = 0i64;
      result = CCredentialGroup::GetNameFromFirstCred(a1, (unsigned __int16 **)&hMem);
      if ( !(_DWORD)result )
      {
        v13 = hMem;
        v14 = -1i64;
        do
          ++v14;
        while ( *((_WORD *)hMem + v14) );
        v15 = (unsigned int)(2 * v14 + 2);
        v16 = (void *)(*(__int64 (**)(void))(LsaTable + 384))();
        *a3 = v16;
        if ( v16 )
        {
          memcpy_0(v16, v13, v15);
          if ( v13 )
            LocalFree(v13);
          return 0i64;
        }
        if ( v13 )
          LocalFree(v13);
        return 2148074240i64;
      }
      break;
    case 86:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids);
      v9 = BuildLegacySupportedAlgsList(a1, (unsigned int **)&Src, (unsigned int *)&hMem);
      result = TranslateToSecurityStatus(v9);
      if ( !(_DWORD)result )
      {
        v10 = (int)hMem;
        v11 = (unsigned int)(4 * (_DWORD)hMem);
        v12 = (void *)(*(__int64 (**)(void))(LsaTable + 384))();
        a3[1] = v12;
        if ( !v12 )
        {
          SPExternalFree(Src);
          return 2148074240i64;
        }
        memcpy_0(v12, Src, v11);
        *(_DWORD *)a3 = v10;
        SPExternalFree(Src);
        return 0i64;
      }
      break;
    case 87:
      v8 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 16i64, &WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids);
      *(_DWORD *)a3 = *((_DWORD *)a1 + 41);
      *((_DWORD *)a3 + 1) = *((_DWORD *)a1 + 42);
      if ( *((_DWORD *)a1 + 42) )
      {
        if ( !*((_DWORD *)a1 + 41) )
          goto LABEL_29;
      }
      else if ( *((_DWORD *)a1 + 41) )
      {
LABEL_29:
        CCipherMill::GetBaseCipherSizes(v8, v17[8] & 1, (unsigned int *)&Src, (unsigned int *)&hMem);
        if ( !*((_DWORD *)a1 + 42) )
          *((_DWORD *)a3 + 1) = (_DWORD)hMem;
        if ( *((_DWORD *)a1 + 41) )
          return 0i64;
        v7 = (int)Src;
        goto LABEL_33;
      }
      return 0i64;
    case 88:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 17i64, &WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids);
      v7 = *((_DWORD *)a1 + 38);
LABEL_33:
      *(_DWORD *)a3 = v7;
      return 0i64;
    default:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        WPP_SF_d(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x13u,
          (__int64)&WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids,
          a2);
      return 2148074242i64;
  }
  return result;
}
// 1800437D7: conditional instruction was optimized away because eax.4!=0
// 1800437F7: variable 'v8' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (00000001800439C4) ----------------------------------------------------
__int64 __fastcall SetClientCertPolicy(
        struct CCredentialGroup *a1,
        struct _SecPkgCred_ClientCertPolicy *a2,
        unsigned int a3)
{
  struct CLIENT_CERT_POLICY *v3; // rbx
  __int64 result; // rax
  struct CLIENT_CERT_POLICY *v7; // rax
  struct CLIENT_CERT_POLICY *v8; // rdi
  CCredentialGroup *v9; // rcx
  unsigned int v10; // ebp
  void *v11; // rdx

  v3 = 0i64;
  if ( !a3 || (result = VerifyClientCertPolicyBuffer((char *)a2, a3), !(_DWORD)result) )
  {
    v7 = (struct CLIENT_CERT_POLICY *)SPExternalAlloc(0x38u);
    v8 = v7;
    if ( v7 )
    {
      v10 = InitializeClientCertPolicy(a2, v7);
      if ( v10 )
      {
        SPExternalFree(v8);
      }
      else
      {
        v11 = (void *)*((_QWORD *)a1 + 102);
        if ( v11 )
        {
          if ( *((_QWORD *)a1 + 103) )
            CCredentialGroup::UnsubscribeCertStoreChangeNotification(v9, v11, (void **)a1 + 103);
        }
        *((_QWORD *)a1 + 102) = *((_QWORD *)v8 + 6);
        *((_QWORD *)v8 + 6) = 0i64;
        v3 = v8;
      }
      *((_QWORD *)a1 + 106) = v3;
      return v10;
    }
    else
    {
      return 2148074240i64;
    }
  }
  return result;
}
// 180043A40: variable 'v9' is possibly undefined

//----- (0000000180043A7C) ----------------------------------------------------
__int64 __fastcall VerifyClientCertPolicyBuffer(char *a1, unsigned int a2)
{
  int v2; // r8d
  char *v3; // r9
  const unsigned __int16 *v4; // rcx
  const unsigned __int16 *v5; // r10
  __int64 result; // rax

  v2 = a2;
  v3 = a1;
  if ( a2 < 0x38 )
    return 2148074333i64;
  if ( &a1[a2] < a1 )
    return 2148074333i64;
  v4 = (const unsigned __int16 *)*((_QWORD *)a1 + 5);
  if ( ((unsigned __int8)v4 & 1) != 0 )
    return 2148074333i64;
  v5 = (const unsigned __int16 *)*((_QWORD *)v3 + 6);
  if ( ((unsigned __int8)v5 & 1) != 0 )
    return 2148074333i64;
  if ( !v4 || (result = VerifyUnicodeStringIsInBuffer(v4, v3, a2), !(_DWORD)result) )
  {
    if ( !v5 )
      return 0i64;
    result = VerifyUnicodeStringIsInBuffer(v5, v3, v2);
    if ( !(_DWORD)result )
      return 0i64;
  }
  return result;
}
// 180043ABB: variable 'v5' is possibly undefined
// 180043AC3: variable 'v3' is possibly undefined
// 180043AC3: variable 'v2' is possibly undefined

//----- (0000000180043AE4) ----------------------------------------------------
__int64 __fastcall VerifyUnicodeStringIsInBuffer(const unsigned __int16 *a1, char *a2, int a3)
{
  char *v3; // rdx

  if ( a1 >= (const unsigned __int16 *)a2 )
  {
    v3 = &a2[a3 - 2];
    while ( a1 <= (const unsigned __int16 *)v3 )
    {
      if ( !*a1 )
        return 0i64;
      ++a1;
    }
  }
  return 2148074333i64;
}

//----- (0000000180043B20) ----------------------------------------------------
__int64 __fastcall SpSetCredentialsAttributes(
        struct CCredentialGroup *a1,
        int a2,
        struct _SecPkgCred_ClientCertPolicy *a3,
        unsigned int a4)
{
  __int64 v9; // [rsp+20h] [rbp-28h] BYREF
  int v10; // [rsp+28h] [rbp-20h]

  if ( !(*(unsigned __int8 (__fastcall **)(__int64 *))(LsaTable + 192))(&v9) )
    return 2148074244i64;
  if ( (v10 & 1) == 0 )
    return 2148074242i64;
  if ( !a3 || !a1 )
    return 2148074333i64;
  if ( (v10 & 0x10000) == 0 )
  {
    if ( a4 )
      goto LABEL_10;
    return 2148074333i64;
  }
  a4 = 0;
LABEL_10:
  if ( a2 != 96 )
    return 2148074242i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids);
  return SetClientCertPolicy(a1, a3, a4);
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180043BF8) ----------------------------------------------------
ULONG __fastcall CheckInitialDTLSHelloCookie(
        unsigned int a1,
        const unsigned __int16 *a2,
        struct _SecBuffer *a3,
        struct SPBuffer *a4,
        struct SPBuffer *a5)
{
  int DTLSHelloVerify; // edi
  unsigned __int64 v8; // r9
  _BYTE *v9; // r8
  __int64 v10; // rdx
  __int64 v11; // rbx
  unsigned __int8 *v12; // r15
  unsigned int v13; // ebx
  unsigned int v14; // ebx
  __int64 v15; // rdx
  unsigned int v16; // ebx
  int v17; // ebx
  unsigned __int8 *v18; // r8
  ULONG v19; // ebp
  __int64 v20; // rsi
  unsigned int v21; // ebx
  unsigned int v22; // ebx
  unsigned __int8 *v23; // r12
  NTSTATUS DTlsCookieManager; // eax
  unsigned int cbBuffer; // esi
  unsigned __int8 *pvBuffer; // r14
  ULONGLONG TickCount64; // rax
  DTLSCookieManager *v29; // rdi
  NTSTATUS v30; // eax
  DTLSCookieManager *v32; // [rsp+48h] [rbp-80h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+50h] [rbp-78h] BYREF
  __int128 v34; // [rsp+60h] [rbp-68h]

  DTLSHelloVerify = 0;
  v32 = 0i64;
  *(_QWORD *)&DestinationString.Length = a2;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 57i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
  if ( !a3 || !a4 || !a5 )
    return -2146892963;
  v8 = *((unsigned int *)a4 + 1);
  if ( (unsigned int)v8 < 0xD )
    return -2146893032;
  v9 = (_BYTE *)*((_QWORD *)a4 + 1);
  if ( !v9 )
    return -2146892963;
  if ( *v9 != 22 || v9[1] != 0xFE || ((unsigned __int8)v9[2] | ((unsigned __int8)v9[1] << 8)) > 0xFEFFu )
    return -2146893048;
  v10 = (unsigned __int8)v9[12] | ((unsigned __int8)v9[11] << 8);
  if ( v8 < v10 + 13 )
    return -2146893032;
  if ( (unsigned int)v10 < 0xC
    || v9[13] != 1
    || (unsigned __int8)v9[21] + (((unsigned __int8)v9[20] + ((unsigned __int8)v9[19] << 8)) << 8) )
  {
    return -2146893048;
  }
  v11 = (unsigned __int8)v9[24] + (((unsigned __int8)v9[23] + ((unsigned __int8)v9[22] << 8)) << 8);
  if ( (unsigned int)(v8 - 13) < (unsigned __int64)(v11 + 12) )
    return -2146893032;
  v12 = v9 + 25;
  if ( (unsigned int)v11 < 2 )
    return -2146893048;
  if ( *v12 != 0xFE )
    return -2146893048;
  if ( ((unsigned __int8)v9[26] | ((unsigned __int8)v9[25] << 8)) > 0xFEFFu )
    return -2146893048;
  v13 = v11 - 2;
  if ( v13 < 0x20 )
    return -2146893048;
  v14 = v13 - 32;
  if ( !v14 )
    return -2146893048;
  v15 = (unsigned __int8)v9[59];
  if ( (unsigned int)v15 > 0x20 )
    return -2146893048;
  v16 = v14 - 1;
  if ( v16 < (unsigned int)v15 )
    return -2146893048;
  v17 = v16 - v15;
  v18 = &v9[v15 + 60];
  v19 = v15 + 35;
  if ( !v17 )
    return -2146893048;
  v20 = *v18;
  if ( (v20 & 0xFFFFFFDF) != 0 )
    return -2146893048;
  v21 = v17 - 1;
  if ( v21 < (unsigned int)v20 )
    return -2146893048;
  v22 = v21 - v20;
  v23 = &v18[v20];
  DTlsCookieManager = DTLSCookieManager::getDTlsCookieManager(&v32);
  if ( DTlsCookieManager < 0 )
    return RtlNtStatusToDosError(DTlsCookieManager);
  if ( (_DWORD)v20 )
  {
    if ( !(unsigned int)DTLSCookieManager::ValidateCookie(
                          v32,
                          v12,
                          v19,
                          v23 + 1,
                          v22,
                          (unsigned __int8 *const)a3->pvBuffer,
                          a3->cbBuffer) )
    {
      DTLSHelloVerify = -2146893024;
      if ( (g_dwEventLogging & 2) != 0 )
      {
        RtlInitUnicodeString(&DestinationString, *(PCWSTR *)&DestinationString.Length);
        SchEventWrite(&SSLEVENT_DTLS_COOKIE_VERIFY_FAILED, L"du", a1, &DestinationString);
      }
    }
  }
  else
  {
    DestinationString = 0i64;
    v34 = 0i64;
    if ( g_fEnableHelloVerifyRequest )
    {
      cbBuffer = a3->cbBuffer;
      pvBuffer = (unsigned __int8 *)a3->pvBuffer;
      TickCount64 = GetTickCount64();
      v29 = v32;
      if ( *((_QWORD *)v32 + 6) + *((_QWORD *)v32 + 7) < TickCount64 )
        DTLSCookieManager::ResetSecret((PUCHAR *)v32);
      v30 = DTLSCookieManager::ComputeCookie(
              v29,
              v12,
              v19,
              v23 + 1,
              v22,
              pvBuffer,
              cbBuffer,
              (unsigned __int8 *)&DestinationString);
      if ( v30 >= 0 )
      {
        DTLSHelloVerify = GenerateDTLSHelloVerify(a5, (unsigned __int8 *)&DestinationString);
        if ( !DTLSHelloVerify )
          return 590610;
      }
      else
      {
        return SspNtStatusToSecStatus(v30);
      }
    }
    else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 58i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
    }
  }
  return DTLSHelloVerify;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800919A4: using guessed type int g_fEnableHelloVerifyRequest;

//----- (0000000180043FA0) ----------------------------------------------------
__int64 __fastcall GenerateDTLSHelloVerify(struct SPBuffer *a1, unsigned __int8 *a2)
{
  char *v2; // rax
  unsigned int v3; // ebx
  __int128 v6; // xmm1
  __int64 v7; // rcx

  v2 = (char *)*((_QWORD *)a1 + 1);
  v3 = 0;
  if ( !v2 )
  {
    *(_DWORD *)a1 = 60;
    v2 = (char *)SPExternalAlloc(0x3Cu);
    *((_QWORD *)a1 + 1) = v2;
    if ( !v2 )
      return 14;
LABEL_6:
    *((_DWORD *)a1 + 1) = 0;
    *(_OWORD *)(v2 + 28) = *(_OWORD *)a2;
    v6 = *((_OWORD *)a2 + 1);
    *(_DWORD *)(v2 + 13) = 587202563;
    *(_OWORD *)(v2 + 44) = v6;
    *((_DWORD *)v2 + 6) = 553647651;
    *((_DWORD *)v2 + 5) = 0;
    v2[19] = 0;
    v7 = *((_QWORD *)a1 + 1);
    *(_DWORD *)v7 = 16776726;
    *(_WORD *)(v7 + 4) = 0;
    *(_DWORD *)(v7 + 7) = 0;
    *(_BYTE *)(v7 + 6) = 0;
    *(_WORD *)(v7 + 11) = 12032;
    *((_DWORD *)a1 + 1) = 60;
    return v3;
  }
  if ( *(_DWORD *)a1 >= 0x3Cu )
    goto LABEL_6;
  *((_DWORD *)a1 + 1) = 60;
  return (unsigned int)-2146893023;
}

//----- (0000000180044054) ----------------------------------------------------
void __fastcall GenerateFatalAlertMessage(int a1, __int64 a2, __int16 a3, __int64 a4)
{
  __int64 v7; // rdx
  __int64 v8; // r8
  __int64 v9; // r9

  if ( *(_BYTE *)(a2 + 96) == 2 && IsFatalError(a1) && (*(_DWORD *)(v7 + 64) & 0x3FF0) != 0 )
  {
    LOBYTE(v9) = *(_BYTE *)(v7 + 97);
    if ( (*(unsigned int (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v7 + 392i64))(a2, a4, v8, v9) )
    {
      if ( (a3 & 0x100) != 0 )
      {
        if ( *(_QWORD *)(a4 + 8) )
        {
          (*(void (__fastcall **)(__int64))(*(_QWORD *)a2 + 16i64))(a2);
          *(_QWORD *)(a4 + 8) = 0i64;
        }
      }
      *(_DWORD *)a4 = 0;
      *(_DWORD *)(a4 + 4) = 0;
    }
    else
    {
      *(_WORD *)(a2 + 96) = 0;
      if ( *(_DWORD *)(a2 + 68) == 96 )
        *(_DWORD *)(a2 + 68) = 3;
    }
  }
}
// 180044082: variable 'v7' is possibly undefined
// 1800440A9: variable 'v8' is possibly undefined
// 1800440A9: variable 'v9' is possibly undefined

//----- (0000000180044114) ----------------------------------------------------
__int64 __fastcall GeneratePSKExchangeMessage(__int64 a1, __int64 a2)
{
  unsigned __int16 *v4; // rax
  unsigned __int16 *v5; // rbx
  void *v6; // rcx
  __int64 v7; // rax
  unsigned int v9; // eax

  v4 = (unsigned __int16 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
  v5 = v4;
  if ( !v4 )
    return 0i64;
  v6 = *(void **)(a2 + 8);
  if ( v6 )
  {
    v9 = *(_DWORD *)a2;
  }
  else
  {
    v7 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 8i64))(a1, *v4);
    *(_QWORD *)(a2 + 8) = v7;
    v6 = (void *)v7;
    if ( !v7 )
      return 14i64;
    v9 = *v5;
    *(_DWORD *)a2 = v9;
  }
  if ( *v5 <= v9 )
  {
    memcpy_0(v6, v5 + 1, *v5);
    *(_DWORD *)a2 = *v5;
    return 0i64;
  }
  return 2148074273i64;
}

//----- (00000001800441C4) ----------------------------------------------------
__int64 __fastcall SspNtStatusToSecStatus(NTSTATUS a1)
{
  unsigned int v1; // edx
  bool v2; // zf
  signed int v4; // eax

  v1 = a1;
  if ( (a1 & 0x1FFF0000) == 589824 )
    return v1;
  if ( a1 > -1073741428 )
  {
    if ( a1 <= -1073740965 )
    {
      if ( a1 == -1073740965 )
        return (unsigned int)-2146892986;
      if ( a1 > -1073741261 )
      {
        switch ( a1 )
        {
          case -1073741260:
            return (unsigned int)-2146893044;
          case -1073741252:
            return (unsigned int)-2146893039;
          case -1073741063:
            return (unsigned int)-2146893044;
          case -1073741058:
            return (unsigned int)-2146892993;
        }
        v2 = a1 == -1073741024;
      }
      else
      {
        if ( a1 == -1073741261 || a1 == -1073741427 || a1 == -1073741424 || a1 == -1073741422 )
          return (unsigned int)-2146893039;
        if ( a1 == -1073741421 )
          return (unsigned int)-2146893044;
        if ( a1 <= -1073741417 )
          goto LABEL_83;
        if ( a1 <= -1073741413 )
          return v1;
        v2 = a1 == -1073741276;
      }
LABEL_56:
      if ( !v2 )
        goto LABEL_83;
      return (unsigned int)-2146893044;
    }
    if ( a1 > -1073740789 )
    {
      if ( a1 == -1073740781 )
        return v1;
      if ( a1 != -1073740776 )
      {
        switch ( a1 )
        {
          case -1073740755:
            return (unsigned int)-2146892959;
          case -1073740753:
            return (unsigned int)-2146892958;
          case 0:
            return 0;
        }
        goto LABEL_83;
      }
    }
    else
    {
      if ( a1 == -1073740789 )
        return (unsigned int)-2146892969;
      if ( a1 < -1073740928 )
        goto LABEL_83;
      if ( a1 > -1073740927 )
      {
        if ( a1 <= -1073740926 )
          goto LABEL_83;
        if ( a1 > -1073740921 )
        {
          if ( a1 == -1073740920 )
            return (unsigned int)-2146892976;
          if ( a1 != -1073740916 && a1 != -1073740913 )
          {
            v2 = a1 == -1073740792;
            goto LABEL_56;
          }
        }
      }
    }
    return (unsigned int)-2146893044;
  }
  if ( a1 == -1073741428 )
    return v1;
  if ( a1 > -1073741724 )
  {
    if ( a1 > -1073741601 )
    {
      if ( a1 == -1073741595 )
        return (unsigned int)-2146893052;
      if ( a1 != -1073741562 )
      {
        if ( a1 == -1073741517 )
          return (unsigned int)-2146893020;
        if ( a1 == -1073741477 )
          return (unsigned int)-2146893044;
        if ( a1 != -1073741429 )
          goto LABEL_83;
        return (unsigned int)-2146893053;
      }
    }
    else
    {
      if ( a1 == -1073741601 )
        return (unsigned int)-2146893039;
      if ( a1 == -1073741718 )
        return (unsigned int)-2146893044;
      if ( a1 != -1073741717 )
      {
        if ( a1 <= -1073741717 )
          goto LABEL_83;
        if ( a1 <= -1073741710 )
          return (unsigned int)-2146893044;
        if ( a1 != -1073741670 )
        {
          if ( a1 == -1073741637 )
            return (unsigned int)-2146893054;
          if ( a1 != -1073741634 )
            goto LABEL_83;
          return (unsigned int)-2146893039;
        }
        return (unsigned int)-2146893056;
      }
    }
    return (unsigned int)-2146893048;
  }
  if ( a1 == -1073741724 )
    return (unsigned int)-2146893044;
  if ( a1 > -1073741811 )
  {
    if ( a1 != -1073741801 )
    {
      if ( a1 == -1073741789 )
        return (unsigned int)-2146893023;
      if ( a1 != -1073741772 )
      {
        if ( a1 != -1073741730 )
        {
          if ( a1 == -1073741729 )
            return (unsigned int)-2146893043;
          if ( a1 == -1073741727 )
            return (unsigned int)-2146893050;
          goto LABEL_83;
        }
        return (unsigned int)-2146893039;
      }
      return (unsigned int)-2146893053;
    }
    return (unsigned int)-2146893056;
  }
  if ( a1 == -1073741811 || a1 == -2147483635 )
    return (unsigned int)-2146893048;
  if ( a1 == -2146885616 )
    return (unsigned int)-2146893044;
  if ( a1 <= -2146885615 )
    goto LABEL_83;
  if ( a1 <= -2146885613 || a1 == -2146869247 || a1 == -2146762480 )
    return (unsigned int)-2146893044;
  if ( a1 == -1073741816 )
    return (unsigned int)-2146893055;
LABEL_83:
  v4 = RtlNtStatusToDosErrorNoTeb(a1);
  v1 = v4;
  if ( v4 >= 0 || (v4 & 0x1FFF0000) != 589824 )
    return (unsigned int)-2146893052;
  return v1;
}

//----- (0000000180044528) ----------------------------------------------------
__int64 __fastcall McTemplateU0pd_EtwEventWriteTransfer(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  _QWORD v5[3]; // [rsp+30h] [rbp-48h] BYREF
  int v6; // [rsp+48h] [rbp-30h]
  int v7; // [rsp+4Ch] [rbp-2Ch]
  int *v8; // [rsp+50h] [rbp-28h]
  int v9; // [rsp+58h] [rbp-20h]
  int v10; // [rsp+5Ch] [rbp-1Ch]
  __int64 v11; // [rsp+90h] [rbp+18h] BYREF
  int v12; // [rsp+98h] [rbp+20h] BYREF

  v12 = a4;
  v11 = a3;
  v5[2] = &v11;
  v7 = 0;
  v6 = 8;
  v8 = &v12;
  v10 = 0;
  v9 = 4;
  return McGenEventWrite_EtwEventWriteTransfer(a1, (__int64)&AscStop, a3, 3, (__int64)v5);
}

//----- (00000001800445A4) ----------------------------------------------------
__int64 McTemplateU0pp_EtwEventWriteTransfer(__int64 a1, __int64 a2, ...)
{
  _QWORD v3[3]; // [rsp+30h] [rbp-48h] BYREF
  int v4; // [rsp+48h] [rbp-30h]
  int v5; // [rsp+4Ch] [rbp-2Ch]
  va_list v6; // [rsp+50h] [rbp-28h]
  int v7; // [rsp+58h] [rbp-20h]
  int v8; // [rsp+5Ch] [rbp-1Ch]
  va_list va; // [rsp+90h] [rbp+18h]
  __int64 v10; // [rsp+90h] [rbp+18h] BYREF
  va_list va1; // [rsp+98h] [rbp+20h] BYREF

  va_start(va1, a2);
  va_start(va, a2);
  v10 = va_arg(va1, _QWORD);
  va_copy((va_list)&v3[2], va);
  v5 = 0;
  v4 = 8;
  va_copy(v6, va1);
  v8 = 0;
  v7 = 8;
  return McGenEventWrite_EtwEventWriteTransfer(8i64, (__int64)&AscStart, v10, 3, (__int64)v3);
}

//----- (000000018004461C) ----------------------------------------------------
__int64 __fastcall McTemplateU0pz_EtwEventWriteTransfer(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v4; // rax
  __int64 v5; // rcx
  char v7[16]; // [rsp+30h] [rbp-48h] BYREF
  __int64 *v8; // [rsp+40h] [rbp-38h]
  __int64 v9; // [rsp+48h] [rbp-30h]
  const wchar_t *v10; // [rsp+50h] [rbp-28h]
  int v11; // [rsp+58h] [rbp-20h]
  int v12; // [rsp+5Ch] [rbp-1Ch]
  __int64 v13; // [rsp+90h] [rbp+18h] BYREF

  v13 = a3;
  v9 = 8i64;
  v8 = &v13;
  if ( a4 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( a4[v4] );
    v5 = (unsigned int)(2 * v4 + 2);
  }
  else
  {
    v5 = 10i64;
  }
  v12 = 0;
  v11 = v5;
  if ( !a4 )
    a4 = L"NULL";
  v10 = a4;
  return McGenEventWrite_EtwEventWriteTransfer(v5, (__int64)&DscStart, a3, 3, (__int64)v7);
}
// 180083C60: using guessed type wchar_t aNull_0[5];
// 18004461C: using guessed type char var_48[16];

//----- (00000001800446C0) ----------------------------------------------------
__int64 __fastcall SpApplyControlToken(__int64 a1, __int64 a2)
{
  CCipherMill *v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rdi
  int v7; // esi
  unsigned int v8; // edx
  __int64 v9; // r10
  __int64 result; // rax
  _DWORD *v11; // r9
  int v12; // ecx
  __int64 v13; // rcx
  __int64 v14; // rdx
  char v15; // cl

  v4 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_qq(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x35u,
      (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
      a1,
      a2);
    v4 = WPP_GLOBAL_Control;
  }
  v5 = *(_QWORD *)(a1 + 8);
  if ( *(_DWORD *)(a2 + 4) != 1 )
    return 2148074248i64;
  v6 = *(_QWORD *)(a2 + 8);
  if ( !v6 )
    return 2148074248i64;
  v7 = 2;
  if ( (*(_DWORD *)(v6 + 4) & 0xFFFFFFF) != 2 )
    return 2148074248i64;
  v8 = *(_DWORD *)v6;
  if ( *(_DWORD *)v6 < 4u )
    return 2148074242i64;
  v9 = *(_QWORD *)(v5 + 88);
  if ( !v9 )
    return 2148074241i64;
  v11 = *(_DWORD **)(v6 + 8);
  if ( *v11 == 1 )
  {
    if ( v4 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v4 + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)v4 + 2), 54i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
    if ( *(_DWORD *)(v5 + 68) != 4 )
      v7 = 5;
    *(_DWORD *)(v5 + 68) = v7;
    return 0i64;
  }
  if ( *v11 == 2 )
  {
    if ( v4 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v4 + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)v4 + 2), 55i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
      v8 = *(_DWORD *)v6;
    }
    if ( v8 < 0xC )
      return 2148074248i64;
    v14 = *(_QWORD *)(v6 + 8);
    if ( (*(_DWORD *)(v5 + 64) & 0x3FF0) != 0 )
    {
      if ( (unsigned int)(*(_DWORD *)(v14 + 4) - 1) <= 1 && *(_DWORD *)(v14 + 8) < 0x100u )
      {
        v15 = *(_BYTE *)(v14 + 8);
        *(_BYTE *)(v5 + 96) = *(_BYTE *)(v14 + 4);
        *(_BYTE *)(v5 + 97) = v15;
        *(_DWORD *)(v5 + 68) = 96;
        return 0i64;
      }
      return 2148074248i64;
    }
    return 2148074242i64;
  }
  result = 2148074242i64;
  if ( *v11 != 3 )
    return result;
  if ( v8 < 8 )
    return 2148074248i64;
  v12 = v11[1];
  if ( (v12 & 2) != 0 )
  {
    *(_BYTE *)(v9 + 236) = 0;
    result = 0i64;
    v12 = v11[1];
  }
  if ( (v12 & 1) != 0 )
  {
    v13 = *(_QWORD *)(v5 + 88);
    if ( *(_BYTE *)(v13 + 237) )
    {
      *(_WORD *)(v13 + 236) = 1;
      return 0i64;
    }
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180044890) ----------------------------------------------------
char __fastcall SslFreeCustomBuffer(__int64 a1, unsigned __int64 *a2, __int64 a3, char a4)
{
  char v4; // di
  __int64 v8; // rcx

  v4 = 0;
  if ( a2 != g_dwPackageId && a2 != (unsigned __int64 *)qword_180092630 || !a1 )
    return 0;
  v8 = *(_QWORD *)(a1 + 24);
  if ( v8 )
  {
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 32i64))(v8, a3);
    v4 = 1;
    if ( a4 )
    {
      CSslContextManager::DeleteContextScratch(
        (__int64)&g_SslContextManager,
        *(_QWORD *)(a1 + 24),
        *(_BYTE *)(a1 + 32),
        *(_DWORD *)(*(_QWORD *)(a1 + 8) + 68i64));
      *(_QWORD *)(a1 + 24) = 0i64;
    }
  }
  return v4;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180092628: using guessed type unsigned __int64 near *g_dwPackageId;
// 180092630: using guessed type __int64 qword_180092630;
// 180092DA0: using guessed type __int64 g_SslContextManager;

//----- (000000018004492C) ----------------------------------------------------
__int64 WPP_SF_dd(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, ...)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+80h] [rbp+28h] BYREF

  va_start(va, a4);
  v5 = a4;
  return EtwTraceMessage(a1, 43i64, a3, a2, &v5, 4i64, (__int64 *)va, 4i64, 0i64);
}

//----- (000000018004497C) ----------------------------------------------------
__int64 WPP_SF_qq(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  __int64 v4; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+78h] [rbp+20h]
  va_list va1; // [rsp+80h] [rbp+28h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  return EtwTraceMessage(a1, 43i64, a3, a2, (__int64 *)va, 8i64, va1, 8i64, 0i64);
}

//----- (00000001800449CC) ----------------------------------------------------
void __fastcall LogBogusClientCertEvent(
        unsigned int a1,
        const unsigned __int16 *a2,
        const struct _CERT_CONTEXT *a3,
        int a4)
{
  int v7; // [rsp+20h] [rbp-38h]
  DWORD cbCertEncoded; // [rsp+28h] [rbp-30h]
  struct _UNICODE_STRING DestinationString; // [rsp+40h] [rbp-18h] BYREF

  if ( (g_dwEventLogging & 2) != 0 )
  {
    RtlInitUnicodeString(&DestinationString, a2);
    cbCertEncoded = a3->cbCertEncoded;
    v7 = a4;
    SchEventWrite(&SSLEVENT_BOGUS_CLIENT_CERT, L"dudb", a1, &DestinationString, v7, cbCertEncoded, a3->pbCertEncoded);
  }
}

//----- (0000000180044A44) ----------------------------------------------------
void __fastcall LogBogusServerCertEvent(
        unsigned int a1,
        const unsigned __int16 *a2,
        const struct _CERT_CONTEXT *a3,
        unsigned __int16 *a4,
        unsigned int a5)
{
  const struct _EVENT_DESCRIPTOR *v8; // rcx
  BYTE *pbCertEncoded; // [rsp+28h] [rbp-40h]
  struct _UNICODE_STRING DestinationString; // [rsp+40h] [rbp-28h] BYREF
  struct _UNICODE_STRING v11; // [rsp+50h] [rbp-18h] BYREF

  RtlInitUnicodeString(&DestinationString, a2);
  if ( (g_dwEventLogging & 1) != 0 )
  {
    if ( a5 == -2146893022 )
    {
      RtlInitUnicodeString(&v11, a4);
      SchEventWrite(
        &SSLEVENT_NAME_MISMATCHED_SERVER_CERT,
        L"duub",
        a1,
        &DestinationString,
        &v11,
        a3->cbCertEncoded,
        a3->pbCertEncoded);
    }
    else
    {
      switch ( a5 )
      {
        case 0x80090325:
          pbCertEncoded = a3->pbCertEncoded;
          v8 = (const struct _EVENT_DESCRIPTOR *)&SSLEVENT_UNTRUSTED_SERVER_CERT;
          break;
        case 0x80090328:
          pbCertEncoded = a3->pbCertEncoded;
          v8 = &SSLEVENT_EXPIRED_SERVER_CERT;
          break;
        case 0x80092010:
          pbCertEncoded = a3->pbCertEncoded;
          v8 = (const struct _EVENT_DESCRIPTOR *)&SSLEVENT_REVOKED_SERVER_CERT;
          break;
        default:
          SchEventWrite(
            &SSLEVENT_BOGUS_SERVER_CERT,
            L"dudb",
            a1,
            &DestinationString,
            a5,
            a3->cbCertEncoded,
            a3->pbCertEncoded);
          return;
      }
      SchEventWrite(v8, L"dub", a1, &DestinationString, a3->cbCertEncoded, pbCertEncoded);
    }
  }
}
// 180084FE0: using guessed type struct _EVENT_DESCRIPTOR SSLEVENT_BOGUS_SERVER_CERT;

//----- (0000000180044B64) ----------------------------------------------------
void __fastcall LogCertMappingFailureEvent(unsigned int a1, const unsigned __int16 *a2, int a3)
{
  int v5; // [rsp+20h] [rbp-38h]
  struct _UNICODE_STRING DestinationString; // [rsp+40h] [rbp-18h] BYREF

  if ( (g_dwEventLogging & 2) != 0 )
  {
    RtlInitUnicodeString(&DestinationString, a2);
    v5 = a3;
    SchEventWrite(&SSLEVENT_CERT_MAPPING_FAILURE, L"dudb", a1, &DestinationString, v5, 0i64, 0i64);
  }
}

//----- (0000000180044BCC) ----------------------------------------------------
void __fastcall LogCipherMismatchEvent(unsigned int a1, const unsigned __int16 *a2, unsigned int a3)
{
  struct _UNICODE_STRING v5; // [rsp+30h] [rbp-28h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+40h] [rbp-18h] BYREF

  if ( (g_dwEventLogging & 1) != 0 )
  {
    RtlInitUnicodeString(&DestinationString, a2);
    MapProtocolToString(a3, &v5);
    SchEventWrite(&SSLEVENT_CIPHER_MISMATCH, L"duu", a1, &DestinationString, &v5);
  }
}

//----- (0000000180044C38) ----------------------------------------------------
__int64 __fastcall LogCreateCredFailedEvent(unsigned int a1, const WCHAR *a2, char a3, int a4)
{
  const WCHAR *v7; // rdx
  __int64 result; // rax
  int v9; // [rsp+28h] [rbp-30h]
  struct _UNICODE_STRING v10; // [rsp+30h] [rbp-28h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+40h] [rbp-18h] BYREF

  if ( (g_dwEventLogging & 1) != 0 )
  {
    RtlInitUnicodeString(&DestinationString, a2);
    v7 = (const WCHAR *)pszClientString;
    if ( a3 )
      v7 = pszServerString;
    RtlInitUnicodeString(&v10, v7);
    v9 = a4;
    return SchEventWrite(&SSLEVENT_CREATE_CRED_FAILED, L"duud", a1, &DestinationString, &v10, v9);
  }
  return result;
}

//----- (0000000180044CCC) ----------------------------------------------------
__int64 __fastcall LogCredAcquireContextFailedEvent(unsigned int a1, const WCHAR *a2, char a3, int a4, int a5)
{
  const WCHAR *v8; // rdx
  __int64 result; // rax
  int v10; // [rsp+28h] [rbp-40h]
  struct _UNICODE_STRING v12; // [rsp+40h] [rbp-28h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+50h] [rbp-18h] BYREF

  if ( (g_dwEventLogging & 1) != 0 )
  {
    RtlInitUnicodeString(&DestinationString, a2);
    v8 = (const WCHAR *)pszClientString;
    if ( a3 )
      v8 = pszServerString;
    RtlInitUnicodeString(&v12, v8);
    v10 = a4;
    return SchEventWrite(&SSLEVENT_CRED_ACQUIRE_CONTEXT_FAILED, L"duudd", a1, &DestinationString, &v12, v10, a5);
  }
  return result;
}

//----- (0000000180044D6C) ----------------------------------------------------
void __fastcall LogCredPropertiesEvent(char a1, struct _CRYPT_KEY_PROV_INFO *a2, const struct _CERT_CONTEXT *a3)
{
  const WCHAR *v5; // rbx
  const WCHAR *v6; // rdx
  struct _UNICODE_STRING v7; // [rsp+50h] [rbp-48h] BYREF
  struct _UNICODE_STRING v8; // [rsp+60h] [rbp-38h] BYREF
  struct _UNICODE_STRING v9; // [rsp+70h] [rbp-28h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+80h] [rbp-18h] BYREF

  if ( (g_dwEventLogging & 4) != 0 )
  {
    if ( a2->dwKeySpec == 1 )
    {
      v5 = L"key exchange";
    }
    else if ( a2->dwKeySpec == 2 )
    {
      v5 = L"signature";
    }
    else
    {
      v5 = L"N/A";
      if ( a2->dwProvType )
        v5 = L"unknown";
    }
    v6 = (const WCHAR *)pszClientString;
    if ( a1 )
      v6 = pszServerString;
    RtlInitUnicodeString(&DestinationString, v6);
    RtlInitUnicodeString(&v9, a2->pwszProvName);
    RtlInitUnicodeString(&v8, a2->pwszContainerName);
    RtlInitUnicodeString(&v7, v5);
    SchEventWrite(
      &SSLEVENT_CRED_PROPERTIES,
      L"uuduudb",
      (__int64)&DestinationString,
      &v9,
      a2->dwProvType,
      &v8,
      &v7,
      a2->dwFlags,
      a3->cbCertEncoded,
      a3->pbCertEncoded);
  }
}
// 180084E40: using guessed type wchar_t aKeyExchange[13];
// 180084E60: using guessed type wchar_t aSignature[10];
// 180084E78: using guessed type wchar_t aNA[4];

//----- (0000000180044E9C) ----------------------------------------------------
void __fastcall LogDtlsRecordOutOfRecvWindow(unsigned int a1, const unsigned __int16 *a2)
{
  struct _UNICODE_STRING DestinationString; // [rsp+20h] [rbp-18h] BYREF

  if ( (g_dwEventLogging & 2) != 0 )
  {
    RtlInitUnicodeString(&DestinationString, a2);
    SchEventWrite(&SSLEVENT_DTLS_RECORD_OUTSIDE_OF_RECV_WINDOW, L"du", a1, &DestinationString);
  }
}

//----- (0000000180044EE8) ----------------------------------------------------
void __fastcall LogDtlsRetransmitRequested(unsigned int a1, const unsigned __int16 *a2)
{
  struct _UNICODE_STRING DestinationString; // [rsp+20h] [rbp-18h] BYREF

  if ( (g_dwEventLogging & 4) != 0 )
  {
    RtlInitUnicodeString(&DestinationString, a2);
    SchEventWrite(&SSLEVENT_DTLS_RETRANSMIT_REQUESTED, L"du", a1, &DestinationString);
  }
}

//----- (0000000180044F34) ----------------------------------------------------
void __fastcall LogFastMappingFailureEvent(
        unsigned int a1,
        const unsigned __int16 *a2,
        const struct _CERT_CONTEXT *a3,
        int a4)
{
  int v7; // [rsp+20h] [rbp-38h]
  DWORD cbCertEncoded; // [rsp+28h] [rbp-30h]
  struct _UNICODE_STRING DestinationString; // [rsp+40h] [rbp-18h] BYREF

  if ( (g_dwEventLogging & 2) != 0 )
  {
    RtlInitUnicodeString(&DestinationString, a2);
    cbCertEncoded = a3->cbCertEncoded;
    v7 = a4;
    SchEventWrite(&SSLEVENT_FAST_MAPPING_FAILURE, L"dudb", a1, &DestinationString, v7, cbCertEncoded, a3->pbCertEncoded);
  }
}

//----- (0000000180044FAC) ----------------------------------------------------
void __fastcall LogGetCertificateChainFailureEvent(
        unsigned int a1,
        const unsigned __int16 *a2,
        char a3,
        const struct _CERT_CONTEXT *a4,
        unsigned int a5,
        unsigned int a6)
{
  const WCHAR *v9; // rdx
  DWORD cbCertEncoded; // [rsp+38h] [rbp-40h]
  struct _UNICODE_STRING v13; // [rsp+50h] [rbp-28h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+60h] [rbp-18h] BYREF

  if ( (g_dwEventLogging & 1) != 0 )
  {
    RtlInitUnicodeString(&DestinationString, a2);
    v9 = (const WCHAR *)pszClientString;
    if ( a3 )
      v9 = pszServerString;
    RtlInitUnicodeString(&v13, v9);
    cbCertEncoded = a4->cbCertEncoded;
    SchEventWrite(
      &SSLEVENT_GET_CERT_CHAIN_FAILURE,
      L"duuddb",
      a1,
      &DestinationString,
      &v13,
      a5,
      a6,
      cbCertEncoded,
      a4->pbCertEncoded);
  }
}

//----- (0000000180045064) ----------------------------------------------------
void __fastcall LogGlobalAcquireContextFailedEvent(unsigned __int16 *a1, unsigned int a2)
{
  struct _UNICODE_STRING DestinationString; // [rsp+20h] [rbp-18h] BYREF

  if ( (g_dwEventLogging & 1) != 0 )
  {
    RtlInitUnicodeString(&DestinationString, L"DSS");
    SchEventWrite(&SSLEVENT_GLOBAL_ACQUIRE_CONTEXT_FAILED, L"ud", (__int64)&DestinationString, a2);
  }
}

//----- (00000001800450B8) ----------------------------------------------------
void __fastcall LogIncompleteCertificateChainEvent(
        unsigned int a1,
        const unsigned __int16 *a2,
        char a3,
        const struct _CERT_CONTEXT *a4,
        unsigned int a5)
{
  const WCHAR *v8; // rdx
  DWORD cbCertEncoded; // [rsp+30h] [rbp-38h]
  struct _UNICODE_STRING v11; // [rsp+40h] [rbp-28h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+50h] [rbp-18h] BYREF

  if ( (g_dwEventLogging & 1) != 0 )
  {
    RtlInitUnicodeString(&DestinationString, a2);
    v8 = (const WCHAR *)pszClientString;
    if ( a3 )
      v8 = pszServerString;
    RtlInitUnicodeString(&v11, v8);
    cbCertEncoded = a4->cbCertEncoded;
    SchEventWrite(
      &SSLEVENT_INCOMPLETE_CERT_CHAIN_FAILURE,
      L"duudb",
      a1,
      &DestinationString,
      &v11,
      a5,
      cbCertEncoded,
      a4->pbCertEncoded);
  }
}

//----- (0000000180045164) ----------------------------------------------------
void __fastcall LogNoPrivateKeyEvent(unsigned int a1, const unsigned __int16 *a2, char a3)
{
  const WCHAR *v5; // rdx
  struct _UNICODE_STRING v6; // [rsp+40h] [rbp-28h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+50h] [rbp-18h] BYREF

  if ( (g_dwEventLogging & 1) != 0 )
  {
    RtlInitUnicodeString(&DestinationString, a2);
    v5 = (const WCHAR *)pszClientString;
    if ( a3 )
      v5 = pszServerString;
    RtlInitUnicodeString(&v6, v5);
    SchEventWrite(&SSLEVENT_NO_PRIVATE_KEY, L"duub", a1, &DestinationString, &v6, 0i64, 0i64);
  }
}

//----- (00000001800451F4) ----------------------------------------------------
void __fastcall LogReceiveAlertEvent(unsigned int a1, const unsigned __int16 *a2, char a3, unsigned __int8 a4)
{
  int v5; // ebx
  int v6; // [rsp+20h] [rbp-28h]
  struct _UNICODE_STRING DestinationString; // [rsp+30h] [rbp-18h] BYREF

  v5 = a4;
  if ( (g_dwEventLogging & 4) != 0 && a3 == 2 )
  {
    RtlInitUnicodeString(&DestinationString, a2);
    v6 = v5;
    SchEventWrite(&SSLEVENT_RECEIVE_FATAL_ALERT, L"dud", a1, &DestinationString, v6);
  }
}

//----- (0000000180045258) ----------------------------------------------------
void __fastcall LogSessionTicketMisconfiguration(
        unsigned int a1,
        const unsigned __int16 *a2,
        const unsigned __int16 *a3)
{
  struct _UNICODE_STRING v5; // [rsp+30h] [rbp-28h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+40h] [rbp-18h] BYREF

  if ( (g_dwEventLogging & 1) != 0 )
  {
    RtlInitUnicodeString(&DestinationString, a2);
    RtlInitUnicodeString(&v5, a3);
    SchEventWrite(&SSLEVENT_SESSION_TICKET_MISCONFIGURATION, L"duu", a1, &DestinationString, &v5);
  }
}

//----- (00000001800452CC) ----------------------------------------------------
void __fastcall MapProtocolToString(unsigned int a1, struct _UNICODE_STRING *a2)
{
  unsigned int v3; // ecx
  unsigned int v4; // ecx
  unsigned int v5; // ecx
  unsigned int v6; // ecx
  unsigned int v7; // ecx
  unsigned int v8; // ecx
  const WCHAR *v9; // rdx

  if ( a1 > 0x200 )
  {
    switch ( a1 )
    {
      case 0x400u:
      case 0x800u:
        v9 = L"TLS 1.2";
        goto LABEL_24;
      case 0x10000u:
      case 0x20000u:
        v9 = L"DTLS 1.0";
        goto LABEL_24;
      case 0x40000u:
      case 0x80000u:
        v9 = L"DTLS 1.2";
        goto LABEL_24;
    }
    goto LABEL_20;
  }
  if ( a1 != 512 )
  {
    v3 = a1 - 4;
    if ( !v3 || (v4 = v3 - 4) == 0 )
    {
      v9 = L"SSL 2.0";
      goto LABEL_24;
    }
    v5 = v4 - 8;
    if ( !v5 || (v6 = v5 - 16) == 0 )
    {
      v9 = L"SSL 3.0";
      goto LABEL_24;
    }
    v7 = v6 - 32;
    if ( !v7 || (v8 = v7 - 64) == 0 )
    {
      v9 = L"TLS 1.0";
      goto LABEL_24;
    }
    if ( v8 != 128 )
    {
LABEL_20:
      v9 = L"unknown";
      goto LABEL_24;
    }
  }
  v9 = L"TLS 1.1";
LABEL_24:
  RtlInitUnicodeString(a2, v9);
}
// 180084DA0: using guessed type wchar_t aSsl20[8];
// 180084DB0: using guessed type wchar_t aSsl30[8];
// 180084DC0: using guessed type wchar_t aTls10[8];
// 180084DD0: using guessed type wchar_t aTls11[8];
// 180084DE0: using guessed type wchar_t aTls12[8];
// 180084DF0: using guessed type wchar_t aDtls10[9];
// 180084E08: using guessed type wchar_t aDtls12[9];

//----- (000000018004538C) ----------------------------------------------------
__int64 __fastcall RtlStringCchCopyNW(char *a1, __int64 a2, char *a3, unsigned __int64 a4)
{
  __int64 v4; // r10
  __int64 result; // rax
  __int64 v6; // r9
  signed __int64 v7; // r8
  unsigned __int16 v8; // ax
  unsigned __int16 *v9; // rax

  v4 = a2;
  if ( (unsigned __int64)(a2 - 1) > 0x7FFFFFFE )
  {
    result = 3221225485i64;
    if ( !a2 )
      return result;
    goto LABEL_12;
  }
  if ( a4 > 0x7FFFFFFE )
  {
    result = 3221225485i64;
LABEL_12:
    *(_WORD *)a1 = 0;
    return result;
  }
  v6 = a4 - a2;
  v7 = a3 - a1;
  do
  {
    if ( !(v6 + v4) )
      break;
    v8 = *(_WORD *)&a1[v7];
    if ( !v8 )
      break;
    *(_WORD *)a1 = v8;
    a1 += 2;
    --v4;
  }
  while ( v4 );
  v9 = (unsigned __int16 *)(a1 - 2);
  if ( v4 )
    v9 = (unsigned __int16 *)a1;
  *v9 = 0;
  return v4 == 0 ? 0x80000005 : 0;
}

//----- (0000000180045408) ----------------------------------------------------
__int64 SchEventWrite(const struct _EVENT_DESCRIPTOR *a1, unsigned __int16 *a2, __int64 a3, ...)
{
  const struct _EVENT_DESCRIPTOR *v3; // r15
  unsigned __int64 *v4; // r12
  unsigned int v5; // r8d
  unsigned __int64 *v6; // rdi
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // rdx
  unsigned int v9; // ebx
  __int64 v10; // r8
  __int64 v11; // rax
  unsigned __int64 v12; // r14
  __int64 v13; // rax
  unsigned int v14; // ecx
  unsigned __int16 v15; // ax
  int v16; // eax
  size_t v17; // rbx
  __int64 v18; // rsi
  unsigned __int64 v19; // rcx
  __int64 v20; // rcx
  signed __int64 v21; // rcx
  void *v22; // rsp
  void *v23; // rsp
  _DWORD *v24; // rax
  unsigned __int64 v25; // rbx
  unsigned __int64 v26; // rcx
  __int64 v27; // rcx
  signed __int64 v28; // rcx
  void *v29; // rsp
  void *v30; // rsp
  _DWORD *v31; // rax
  unsigned int v32; // r13d
  __int64 v33; // rcx
  unsigned __int16 **v34; // r15
  unsigned __int64 *v35; // r14
  int v36; // ecx
  int v37; // ecx
  int v38; // ecx
  int v39; // ecx
  int v40; // ecx
  char **v41; // r13
  __int64 v42; // rcx
  unsigned __int64 v43; // rcx
  unsigned __int64 v44; // rcx
  signed __int64 v45; // rcx
  void *v46; // rsp
  void *v47; // rsp
  _DWORD *v48; // rax
  unsigned __int64 v49; // rcx
  bool v50; // zf
  void *v51; // rcx
  _DWORD *v52; // rax
  unsigned __int64 v53; // rcx
  unsigned __int64 v54; // rax
  int v55; // ecx
  unsigned __int64 v56; // rax
  unsigned __int64 v57; // rbx
  DWORD LengthSid; // eax
  bool v59; // cf
  unsigned __int16 *v60; // rbx
  _DWORD *v61; // rax
  unsigned __int64 v62; // rax
  unsigned __int16 **v63; // rax
  _DWORD *v64; // rax
  unsigned __int64 v65; // rax
  int v66; // ebx
  _DWORD *v67; // rax
  unsigned __int64 v68; // rax
  _DWORD *v69; // rax
  _DWORD *v70; // rax
  unsigned __int64 v71; // rax
  int v72; // ebx
  _DWORD *v73; // rax
  unsigned __int64 v74; // rax
  _DWORD *v75; // rax
  _DWORD *v76; // rax
  unsigned __int64 v77; // rax
  unsigned __int64 v78; // rax
  int Id; // r9d
  __int64 v80; // rcx
  unsigned int v81; // r14d
  __int64 v82; // rax
  unsigned __int64 v83; // rcx
  _DWORD *v84; // rcx
  int v86[8]; // [rsp+0h] [rbp-30h] BYREF
  _QWORD v87[2]; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v88; // [rsp+30h] [rbp+0h] BYREF
  unsigned int v89; // [rsp+34h] [rbp+4h]
  unsigned __int64 v90; // [rsp+38h] [rbp+8h] BYREF
  const struct _EVENT_DESCRIPTOR *v91; // [rsp+40h] [rbp+10h]
  unsigned __int16 *v92; // [rsp+A8h] [rbp+78h] BYREF

  v92 = a2;
  v91 = a1;
  v3 = a1;
  v4 = 0i64;
  v88 = 0;
  v5 = 0;
  v6 = 0i64;
  v7 = 0i64;
  if ( !g_RegistrationHandle )
  {
    v9 = SchInitializeEvents();
    if ( v9 )
      goto LABEL_104;
    a2 = v92;
    v5 = 0;
  }
  if ( !a2 )
    goto LABEL_100;
  v11 = -1i64;
  do
    ++v11;
  while ( a2[v11] );
  v12 = 127i64;
  v90 = 127i64;
  if ( (unsigned int)v11 > 0x7Fui64 || (v90 = (unsigned int)v11, v12 = (unsigned int)v11, (_DWORD)v11) )
  {
    v13 = 0i64;
    v14 = 0;
    do
    {
      v15 = a2[v13];
      if ( v15 == 98 )
      {
        v16 = 2;
      }
      else
      {
        if ( v15 != 100 && v15 != 112 && (v15 <= 0x72u || v15 > 0x75u) )
          return 87;
        v16 = 1;
      }
      ++v14;
      v5 += v16;
      v13 = v14;
    }
    while ( v14 < v12 );
    v88 = v5;
  }
  v4 = 0i64;
  v17 = 16i64 * v5;
  v18 = v5;
  if ( !v17 )
    goto LABEL_27;
  if ( v17 > g_ulMaxStackAllocSize )
    goto LABEL_27;
  v19 = v17 + g_ulAdditionalProbeSize + 8;
  if ( v19 < v17 || !(unsigned int)VerifyStackAvailable(v19) )
    goto LABEL_27;
  v20 = v17 + 23;
  if ( v17 + 23 <= v17 + 8 )
    v20 = 0xFFFFFFFFFFFFFF0i64;
  v21 = v20 & 0xFFFFFFFFFFFFFFF0ui64;
  v22 = alloca(v21);
  v23 = alloca(v21);
  v4 = (unsigned __int64 *)&v88;
  if ( v86 == (int *)-48i64 || (v88 = 1801679955, (v4 = &v90) == 0i64) )
  {
LABEL_27:
    if ( v17 + 8 >= v17 )
    {
      v24 = (_DWORD *)((__int64 (*)(void))g_pfnAllocate)();
      if ( !v24 )
        return 8;
      *v24 = 1885431112;
      v4 = (unsigned __int64 *)(v24 + 2);
    }
    if ( !v4 )
      return 8;
  }
  memset_0(v4, 0, v17);
  v25 = 8 * v18;
  v6 = 0i64;
  if ( 8 * v18 )
  {
    if ( v25 <= g_ulMaxStackAllocSize )
    {
      v26 = v25 + g_ulAdditionalProbeSize + 8;
      if ( v26 >= v25 )
      {
        if ( (unsigned int)VerifyStackAvailable(v26) )
        {
          v27 = v25 + 23;
          if ( v25 + 23 <= v25 + 8 )
            v27 = 0xFFFFFFFFFFFFFF0i64;
          v28 = v27 & 0xFFFFFFFFFFFFFFF0ui64;
          v29 = alloca(v28);
          v30 = alloca(v28);
          v6 = (unsigned __int64 *)&v88;
          if ( v86 != (int *)-48i64 )
          {
            v88 = 1801679955;
            v6 = &v90;
            if ( &v90 )
            {
LABEL_46:
              memset_0(v6, 0, 8 * v18);
              v89 = 0;
              v7 = 0i64;
              v32 = 0;
              if ( v12 )
              {
                v33 = 0i64;
                v34 = &v92;
                v35 = v4;
                while ( 1 )
                {
                  v36 = v92[v33] - 98;
                  if ( v36 )
                  {
                    v37 = v36 - 2;
                    if ( !v37 )
                    {
                      ++v34;
                      v59 = (unsigned __int64)g_ulMaxStackAllocSize < 4;
                      v66 = *(_DWORD *)v34;
                      v6[v7] = 0i64;
                      if ( v59 || (unsigned __int64)(g_ulAdditionalProbeSize + 12) < 4 )
                        goto LABEL_121;
                      if ( (unsigned int)VerifyStackAvailable(g_ulAdditionalProbeSize + 12) )
                        v6[v7] = (unsigned __int64)v87;
                      v67 = (_DWORD *)v6[v7];
                      if ( !v67
                        || (*v67 = 1801679955,
                            v68 = v6[v7],
                            v50 = v68 == -8i64,
                            v69 = (_DWORD *)(v68 + 8),
                            v6[v7] = (unsigned __int64)v69,
                            v50) )
                      {
LABEL_121:
                        v70 = (_DWORD *)((__int64 (__fastcall *)(__int64))g_pfnAllocate)(12i64);
                        v6[v7] = (unsigned __int64)v70;
                        if ( !v70 )
                          goto LABEL_117;
                        *v70 = 1885431112;
                        v71 = v6[v7];
                        v50 = v71 == -8i64;
                        v69 = (_DWORD *)(v71 + 8);
                        v6[v7] = (unsigned __int64)v69;
                        if ( v50 )
                          goto LABEL_117;
                      }
                      *v69 = v66;
                      v56 = v6[v7];
                      v35[1] = 4i64;
                      goto LABEL_87;
                    }
                    v38 = v37 - 12;
                    if ( !v38 )
                    {
                      ++v34;
                      v59 = (unsigned __int64)g_ulMaxStackAllocSize < 8;
                      v60 = *v34;
                      v6[v7] = 0i64;
                      if ( v59 || (unsigned __int64)(g_ulAdditionalProbeSize + 16) < 8 )
                        goto LABEL_122;
                      if ( (unsigned int)VerifyStackAvailable(g_ulAdditionalProbeSize + 16) )
                        v6[v7] = (unsigned __int64)v87;
                      v61 = (_DWORD *)v6[v7];
                      if ( !v61
                        || (*v61 = 1801679955,
                            v62 = v6[v7],
                            v50 = v62 == -8i64,
                            v63 = (unsigned __int16 **)(v62 + 8),
                            v6[v7] = (unsigned __int64)v63,
                            v50) )
                      {
LABEL_122:
                        v64 = (_DWORD *)((__int64 (__fastcall *)(__int64))g_pfnAllocate)(16i64);
                        v6[v7] = (unsigned __int64)v64;
                        if ( !v64 )
                          goto LABEL_117;
                        *v64 = 1885431112;
                        v65 = v6[v7];
                        v50 = v65 == -8i64;
                        v63 = (unsigned __int16 **)(v65 + 8);
                        v6[v7] = (unsigned __int64)v63;
                        if ( v50 )
                          goto LABEL_117;
                      }
                      *v63 = v60;
                      v56 = v6[v7];
                      v35[1] = 8i64;
LABEL_87:
                      *v35 = v56;
                      goto LABEL_88;
                    }
                    v39 = v38 - 3;
                    if ( !v39 )
                    {
                      v57 = (unsigned __int64)*++v34;
                      LengthSid = GetLengthSid(*v34);
                      *v35 = v57;
                      *((_DWORD *)v35 + 3) = 0;
                      *((_DWORD *)v35 + 2) = LengthSid;
LABEL_88:
                      ++v7;
                      v35 += 2;
                      goto LABEL_98;
                    }
                    v40 = v39 - 1;
                    if ( !v40 )
                    {
                      v56 = (unsigned __int64)*++v34;
                      v35[1] = 16i64;
                      goto LABEL_87;
                    }
                    if ( v40 != 1 )
                    {
                      v9 = 87;
                      goto LABEL_104;
                    }
                    v41 = (char **)*++v34;
                    v6[v7] = 0i64;
                    v42 = *(unsigned __int16 *)v41;
                    v8 = v42 + 2;
                    if ( v42 + 2 > (unsigned __int64)g_ulMaxStackAllocSize )
                      goto LABEL_123;
                    v43 = g_ulAdditionalProbeSize + 10 + v42;
                    if ( v43 < v8 )
                      goto LABEL_123;
                    if ( (unsigned int)VerifyStackAvailable(v43) )
                    {
                      v44 = *(unsigned __int16 *)v41 + 25i64;
                      if ( v44 <= (unsigned __int64)*(unsigned __int16 *)v41 + 10 )
                        v44 = 0xFFFFFFFFFFFFFF0i64;
                      v45 = v44 & 0xFFFFFFFFFFFFFFF0ui64;
                      v46 = alloca(v45);
                      v47 = alloca(v45);
                      v6[v7] = (unsigned __int64)&v88;
                    }
                    v48 = (_DWORD *)v6[v7];
                    if ( !v48
                      || (*v48 = 1801679955,
                          v49 = v6[v7],
                          v50 = v49 == -8i64,
                          v51 = (void *)(v49 + 8),
                          v6[v7] = (unsigned __int64)v51,
                          v50) )
                    {
LABEL_123:
                      if ( (unsigned __int64)*(unsigned __int16 *)v41 + 10 < (unsigned __int64)*(unsigned __int16 *)v41
                                                                           + 2 )
                        goto LABEL_117;
                      v52 = (_DWORD *)((__int64 (*)(void))g_pfnAllocate)();
                      v6[v7] = (unsigned __int64)v52;
                      if ( !v52 )
                        goto LABEL_117;
                      *v52 = 1885431112;
                      v53 = v6[v7];
                      v50 = v53 == -8i64;
                      v51 = (void *)(v53 + 8);
                      v6[v7] = (unsigned __int64)v51;
                      if ( v50 )
                        goto LABEL_117;
                    }
                    memset_0(v51, 0, *(unsigned __int16 *)v41 + 2i64);
                    v9 = RtlStringCchCopyNW(
                           (char *)v6[v7],
                           ((unsigned __int64)*(unsigned __int16 *)v41 >> 1) + 1,
                           v41[1],
                           (unsigned __int64)*(unsigned __int16 *)v41 >> 1);
                    if ( v9 )
                      goto LABEL_104;
                    v54 = v6[v7];
                    v55 = *(unsigned __int16 *)v41 + 2;
                    v32 = v89;
                    ++v7;
                    *((_DWORD *)v35 + 2) = v55;
                    *v35 = v54;
                    *((_DWORD *)v35 + 3) = 0;
                    v35 += 2;
                  }
                  else
                  {
                    v59 = (unsigned __int64)g_ulMaxStackAllocSize < 4;
                    v72 = *((_DWORD *)v34 + 2);
                    v6[v7] = 0i64;
                    if ( v59 || (unsigned __int64)(g_ulAdditionalProbeSize + 12) < 4 )
                      goto LABEL_124;
                    if ( (unsigned int)VerifyStackAvailable(g_ulAdditionalProbeSize + 12) )
                      v6[v7] = (unsigned __int64)v87;
                    v73 = (_DWORD *)v6[v7];
                    if ( !v73
                      || (*v73 = 1801679955,
                          v74 = v6[v7],
                          v50 = v74 == -8i64,
                          v75 = (_DWORD *)(v74 + 8),
                          v6[v7] = (unsigned __int64)v75,
                          v50) )
                    {
LABEL_124:
                      v76 = (_DWORD *)((__int64 (__fastcall *)(__int64))g_pfnAllocate)(12i64);
                      v6[v7] = (unsigned __int64)v76;
                      if ( !v76
                        || (*v76 = 1885431112,
                            v77 = v6[v7],
                            v50 = v77 == -8i64,
                            v75 = (_DWORD *)(v77 + 8),
                            v6[v7] = (unsigned __int64)v75,
                            v50) )
                      {
LABEL_117:
                        v9 = 8;
                        goto LABEL_104;
                      }
                    }
                    *v75 = v72;
                    v34 += 2;
                    v78 = v6[v7];
                    v7 += 2i64;
                    *v35 = v78;
                    v35[1] = 4i64;
                    v35[2] = (unsigned __int64)*v34;
                    *((_DWORD *)v35 + 6) = v72;
                    *((_DWORD *)v35 + 7) = 0;
                    v35 += 4;
                  }
LABEL_98:
                  v33 = ++v32;
                  v89 = v32;
                  if ( v32 >= v90 )
                  {
                    v3 = v91;
                    break;
                  }
                }
              }
LABEL_100:
              v9 = EtwEventWrite(g_RegistrationHandle, v3, v88, v4);
              if ( v9
                && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                Id = v3->Id;
                v80 = *((_QWORD *)WPP_GLOBAL_Control + 2);
                LODWORD(v87[0]) = v9;
                WPP_SF_DD(v80, 0xAu, (__int64)&WPP_9cc880ee923835bef0ce0974c4127801_Traceguids, Id, v87[0]);
              }
LABEL_104:
              v81 = 0;
              if ( v7 )
              {
                v82 = 0i64;
                do
                {
                  v83 = v6[v82];
                  if ( v83 )
                  {
                    v84 = (_DWORD *)(v83 - 8);
                    if ( *v84 == 1885431112 )
                      ((void (__fastcall *)(_DWORD *, unsigned __int64, __int64, _QWORD))g_pfnFree)(v84, v8, v10, 0i64);
                  }
                  v82 = ++v81;
                }
                while ( v81 < v7 );
              }
              if ( v6 && *((_DWORD *)v6 - 2) == 1885431112 )
                ((void (__fastcall *)(unsigned __int64 *, unsigned __int64, __int64, _QWORD))g_pfnFree)(
                  v6 - 1,
                  v8,
                  v10,
                  0i64);
              goto LABEL_113;
            }
          }
        }
      }
    }
  }
  if ( v25 + 8 < v25 )
  {
LABEL_44:
    if ( !v6 )
      goto LABEL_45;
    goto LABEL_46;
  }
  v31 = (_DWORD *)((__int64 (*)(void))g_pfnAllocate)();
  if ( v31 )
  {
    *v31 = 1885431112;
    v6 = (unsigned __int64 *)(v31 + 2);
    goto LABEL_44;
  }
LABEL_45:
  v9 = 8;
LABEL_113:
  if ( v4 && *((_DWORD *)v4 - 2) == 1885431112 )
    ((void (*)(void))g_pfnFree)();
  return v9;
}
// 180045B59: variable 'v8' is possibly undefined
// 180045B59: variable 'v10' is possibly undefined
// 180080E98: using guessed type __int64 __fastcall EtwEventWrite(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180092D80: using guessed type unsigned __int64 g_RegistrationHandle;
// 180045408: using guessed type _QWORD var_70[2];

//----- (0000000180045BF8) ----------------------------------------------------
void SchShutdownEvents(void)
{
  int v0; // eax
  int v1; // [rsp+20h] [rbp-18h]

  if ( g_RegistrationHandle )
  {
    v0 = EtwEventUnregister();
    if ( v0 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        v1 = v0;
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xBu,
          (__int64)&WPP_9cc880ee923835bef0ce0974c4127801_Traceguids,
          L"Schannel",
          v1);
      }
    }
  }
  if ( pszClientString )
  {
    LocalFree(pszClientString);
    pszClientString = 0i64;
  }
  if ( pszServerString )
  {
    LocalFree((HLOCAL)pszServerString);
    pszServerString = 0i64;
  }
}
// 180080EA0: using guessed type __int64 EtwEventUnregister(void);
// 180084F18: using guessed type wchar_t aSchannel_2[9];
// 180092D80: using guessed type unsigned __int64 g_RegistrationHandle;

//----- (0000000180045CA0) ----------------------------------------------------
BOOL __stdcall SslCrackCertificate(
        PUCHAR pbCertificate,
        DWORD cbCertificate,
        DWORD dwFlags,
        PX509Certificate *ppCertificate)
{
  DWORD v4; // ebx
  char v7; // r14
  struct _X509Certificate *v9; // rdi
  __int64 v10; // rcx
  PCCERT_CONTEXT CertificateContext; // rax
  const CERT_CONTEXT *v12; // rsi
  DWORD v13; // r14d
  PctPublicKey *pPublicKey; // rcx
  BOOL result; // eax
  DWORD v16; // eax
  __int64 csz; // rbp
  struct _X509Certificate *v18; // rax
  size_t cbData; // r8
  PCERT_INFO pCertInfo; // rdx
  CHAR *pszIssuer; // r9
  PctPublicKey *v22; // rax
  PctPublicKey *v23; // r14
  struct _PUBLICKEY *v24; // r8
  __int64 v25; // rcx
  bool v26; // zf
  DWORD v27; // eax
  DWORD v28; // edx
  struct _PUBLICKEY *v29; // [rsp+30h] [rbp-28h] BYREF

  v4 = 0;
  v7 = dwFlags;
  v9 = 0i64;
  if ( !(unsigned int)SchannelInit(1) )
    return 0;
  if ( (v7 & 2) != 0 )
  {
    if ( cbCertificate < 0x12 )
      return 0;
    v10 = *(_QWORD *)(pbCertificate + 4) - 0x6669747265630B04i64;
    if ( *(_QWORD *)(pbCertificate + 4) == 0x6669747265630B04i64 )
    {
      v10 = *((unsigned int *)pbCertificate + 3) - 1952539497i64;
      if ( *((_DWORD *)pbCertificate + 3) == 1952539497i64 )
        v10 = pbCertificate[16] - 101i64;
    }
    if ( !v10 )
    {
      pbCertificate += 17;
      cbCertificate -= 17;
    }
  }
  CertificateContext = CertCreateCertificateContext(1u, pbCertificate, cbCertificate);
  v12 = CertificateContext;
  if ( !CertificateContext )
  {
    GetLastError();
    return 0;
  }
  v13 = CertNameToStrA(
          CertificateContext->dwCertEncodingType,
          &CertificateContext->pCertInfo->Subject,
          0x20000003u,
          0i64,
          0);
  if ( !v13 )
    goto LABEL_12;
  v16 = CertNameToStrA(v12->dwCertEncodingType, &v12->pCertInfo->Issuer, 0x20000003u, 0i64, 0);
  csz = v16;
  if ( !v16 )
    goto LABEL_12;
  v18 = (struct _X509Certificate *)SPExternalAlloc(v16 + v13 + 66);
  v9 = v18;
  if ( !v18 )
    goto LABEL_13;
  v18->pPublicKey = 0i64;
  v18->pszIssuer = (PSTR)&v18[1];
  v18->pszSubject = (char *)&v18[1] + csz;
  cbData = 16i64;
  v18->Version = v12->pCertInfo->dwVersion;
  pCertInfo = v12->pCertInfo;
  if ( pCertInfo->SerialNumber.cbData <= 0x10 )
    cbData = pCertInfo->SerialNumber.cbData;
  memcpy_0(v18->SerialNumber, pCertInfo->SerialNumber.pbData, cbData);
  pszIssuer = v9->pszIssuer;
  v9->ValidFrom = v12->pCertInfo->NotBefore;
  v9->ValidUntil = v12->pCertInfo->NotAfter;
  if ( !CertNameToStrA(v12->dwCertEncodingType, &v12->pCertInfo->Issuer, 0x20000003u, pszIssuer, csz)
    || !CertNameToStrA(v12->dwCertEncodingType, &v12->pCertInfo->Subject, 0x20000003u, v9->pszSubject, v13) )
  {
LABEL_12:
    GetLastError();
    goto LABEL_13;
  }
  v29 = 0i64;
  v22 = (PctPublicKey *)SPExternalAlloc(0x20u);
  v9->pPublicKey = v22;
  if ( !v22
    || (v22->Type = 0,
        v9->pPublicKey->cbKey = 20,
        v23 = v9->pPublicKey,
        *(_DWORD *)v23->pKey = 826364754,
        GetPublicKeyFromCert(v12, &v29, 0i64)) )
  {
LABEL_13:
    CertFreeCertificateContext(v12);
    if ( v9 )
    {
      pPublicKey = v9->pPublicKey;
      if ( pPublicKey )
        SPExternalFree(pPublicKey);
      SPExternalFree(v9);
    }
    return 0;
  }
  v24 = v29;
  v25 = *(_QWORD *)v29;
  v26 = *(_DWORD *)(*(_QWORD *)v29 + 4i64) == 41984;
  v23[1].Type = *(_DWORD *)(*(_QWORD *)v29 + 12i64) >> 3;
  if ( v26 )
  {
    v27 = *(_DWORD *)(v25 + 12);
    v23[1].cbKey = v27;
    *(_DWORD *)v23[1].pKey = (v27 >> 3) - 1;
    v4 = *(_DWORD *)(v25 + 16);
  }
  else
  {
    v28 = *(_DWORD *)(v25 + 12) >> 3;
    v23[1].cbKey = v28;
    *(_DWORD *)v23[1].pKey = (v28 >> 3) - 1;
  }
  v23[2].Type = v4;
  SPExternalFree(v24);
  CertFreeCertificateContext(v12);
  result = 1;
  *ppCertificate = v9;
  return result;
}

//----- (0000000180045F80) ----------------------------------------------------
void __stdcall SslFreeCertificate(PX509Certificate pCertificate)
{
  if ( pCertificate )
  {
    SPExternalFree(pCertificate->pPublicKey);
    SPExternalFree(pCertificate);
  }
}

//----- (0000000180045FC0) ----------------------------------------------------
DWORD __stdcall SslGetMaximumKeySize(DWORD Reserved)
{
  return 2048;
}

//----- (0000000180045FD0) ----------------------------------------------------
__int64 SslLoadCertificate()
{
  return 0i64;
}

//----- (0000000180045FDC) ----------------------------------------------------
__int64 __fastcall CSslContext::QueryAppData(CSslContext *this, void *a2)
{
  __int64 v5; // rcx
  int v6; // edi
  unsigned int CacheAppData; // ebx
  unsigned __int8 *v8; // rsi
  unsigned int v9; // ebx
  NTSTATUS v10; // eax
  __int64 *v11; // r9
  __int64 v12; // [rsp+30h] [rbp-19h] BYREF
  unsigned int v13; // [rsp+38h] [rbp-11h] BYREF
  unsigned __int8 *v14; // [rsp+40h] [rbp-9h] BYREF
  __int128 v15; // [rsp+48h] [rbp-1h] BYREF
  char v16[24]; // [rsp+58h] [rbp+Fh] BYREF
  __int64 v17; // [rsp+70h] [rbp+27h] BYREF
  int v18; // [rsp+78h] [rbp+2Fh]

  v14 = 0i64;
  v12 = 0i64;
  v13 = 0;
  v17 = 0i64;
  v18 = 0;
  v15 = 0i64;
  if ( !(*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v16) )
    return 1359i64;
  v5 = *((_QWORD *)this + 11);
  v6 = v16[8] & 0x40;
  if ( !v5 )
    return 2148074241i64;
  RtlAcquireResourceShared((PRTL_RESOURCE)(v5 + 72), 1u);
  CacheAppData = CSessionCacheItem::GetCacheAppData(*((CSessionCacheItem **)this + 11), &v14, &v13);
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
  v8 = v14;
  if ( !CacheAppData )
  {
    v9 = v13;
    if ( v14 )
    {
      v10 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64 *))(LsaTable + 56))(0i64, v13, &v12);
      if ( v10 < 0 )
        goto LABEL_8;
      v10 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, unsigned __int8 *))(LsaTable + 72))(0i64, v9, v12, v8);
      if ( v10 < 0 )
        goto LABEL_8;
    }
    if ( v6 )
    {
      v18 = v12;
      HIDWORD(v17) = v9;
    }
    else
    {
      *((_QWORD *)&v15 + 1) = v12;
      DWORD1(v15) = v9;
    }
    v11 = &v17;
    if ( !v6 )
      v11 = (__int64 *)&v15;
    v10 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, void *, __int64 *))(LsaTable + 72))(
            0i64,
            v6 != 0 ? 12 : 16,
            a2,
            v11);
    CacheAppData = v10;
    if ( v10 < 0 )
LABEL_8:
      CacheAppData = RtlNtStatusToDosError(v10);
    else
      v12 = 0i64;
  }
  if ( v12 )
    (*(void (__fastcall **)(_QWORD))(LsaTable + 64))(0i64);
  if ( v8 )
    SPExternalFree(v8);
  return CacheAppData;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (00000001800461E4) ----------------------------------------------------
__int64 __fastcall CSslContext::QueryAuthority(CSslContext *this, void *a2)
{
  WCHAR *v2; // r15
  signed int v5; // ebx
  int v6; // esi
  __int64 v7; // rcx
  unsigned __int8 *v8; // rax
  PCCERT_CONTEXT v9; // r14
  PCERT_INFO pCertInfo; // rax
  DWORD v11; // eax
  DWORD csz; // ebx
  ULONG LastError; // eax
  unsigned int v14; // r12d
  WCHAR *v15; // rax
  NTSTATUS v16; // eax
  PCCERT_CONTEXT pCertContext; // [rsp+30h] [rbp-20h] BYREF
  __int128 v19; // [rsp+38h] [rbp-18h] BYREF
  __int64 v20; // [rsp+48h] [rbp-8h]
  __int64 v21; // [rsp+A0h] [rbp+50h] BYREF
  __int64 v22; // [rsp+A8h] [rbp+58h] BYREF

  pCertContext = 0i64;
  v2 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v19 = 0i64;
  if ( !(*(unsigned __int8 (__fastcall **)(__int128 *))(LsaTable + 192))(&v19) )
    return 1359;
  v6 = BYTE8(v19) & 0x40;
  if ( !a2 )
    return 87;
  RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
  v7 = *((_QWORD *)this + 11);
  v8 = *(unsigned __int8 **)(v7 + 24);
  if ( !v8 )
  {
    RtlReleaseResource((PRTL_RESOURCE)(v7 + 72));
    return 120;
  }
  v5 = SPLoadCertificate(v8, *(_DWORD *)(v7 + 32), &pCertContext);
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
  v9 = pCertContext;
  if ( !v5 )
  {
    pCertInfo = pCertContext->pCertInfo;
    if ( !pCertInfo->Issuer.cbData || !pCertInfo->Issuer.pbData )
    {
      v5 = 120;
      goto LABEL_25;
    }
    v11 = CertNameToStrW(pCertContext->dwCertEncodingType, &pCertInfo->Issuer, 0x20000003u, 0i64, 0);
    csz = v11;
    if ( !v11 )
      goto LABEL_11;
    v14 = 2 * v11;
    v15 = (WCHAR *)SPExternalAlloc(2 * v11);
    v2 = v15;
    if ( !v15 )
    {
      v5 = 14;
      goto LABEL_25;
    }
    if ( CertNameToStrW(v9->dwCertEncodingType, &v9->pCertInfo->Issuer, 0x20000003u, v15, csz) )
    {
      v16 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64 *))(LsaTable + 56))(0i64, v14, &v21);
      if ( v16 >= 0 )
      {
        v16 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, WCHAR *))(LsaTable + 72))(0i64, v14, v21, v2);
        if ( v16 >= 0 )
        {
          if ( v6 )
            LODWORD(v22) = v21;
          else
            v22 = v21;
          v16 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, void *, __int64 *))(LsaTable + 72))(
                  0i64,
                  v6 != 0 ? 4 : 8,
                  a2,
                  &v22);
          v5 = v16;
          if ( v16 >= 0 )
            goto LABEL_25;
        }
      }
      LastError = RtlNtStatusToDosError(v16);
    }
    else
    {
LABEL_11:
      LastError = GetLastError();
    }
    v5 = LastError;
  }
LABEL_25:
  if ( v9 )
    CertFreeCertificateContext(v9);
  if ( v2 )
    SPExternalFree(v2);
  if ( v5 < 0 && v21 )
    (*(void (__fastcall **)(_QWORD))(LsaTable + 64))(0i64);
  return (unsigned int)v5;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004648C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::QueryCertificateValidationResult(CSsl3TlsContext *this, void *a2)
{
  __int64 v2; // rax
  int v3; // r8d
  int v4; // r9d
  __int64 result; // rax
  int v6; // [rsp+40h] [rbp+8h] BYREF
  int v7; // [rsp+44h] [rbp+Ch]

  v2 = *((_QWORD *)this + 11);
  v3 = *(_DWORD *)(v2 + 216);
  v4 = *(_DWORD *)(v2 + 220);
  if ( (*((_DWORD *)this + 34) & 0x4000i64) != 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 114i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
    return 2148074241i64;
  }
  else
  {
    result = 2148074254i64;
    if ( v3 != -2146893042 )
    {
      v6 = v4;
      v7 = v3;
      return (*(__int64 (__fastcall **)(_QWORD, __int64, void *, int *))(LsaTable + 72))(0i64, 8i64, a2, &v6);
    }
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180046538) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::QueryEapKeyBlock(CSsl3TlsContext *this, void *a2)
{
  __int64 v4; // rcx
  __int64 v5; // rdx
  __int64 *v7; // rax
  __int64 v8; // rcx
  int v9; // ebx
  unsigned int v10[4]; // [rsp+40h] [rbp-E8h] BYREF
  char v11[192]; // [rsp+50h] [rbp-D8h] BYREF

  v10[0] = 192;
  RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
  v4 = *((_QWORD *)this + 11);
  v5 = *(_QWORD *)(v4 + 16);
  if ( v5 )
  {
    v7 = (__int64 *)*((_QWORD *)this + 1);
    if ( v7 )
      v8 = *v7;
    else
      v8 = 0i64;
    v9 = SslComputeEapKeyBlock(v8, v5, (char *)this + 272, 64i64, v11, v10[0], v10, *((_DWORD *)this + 84));
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
    if ( v9 )
      return 1359i64;
    else
      return (*(__int64 (__fastcall **)(_QWORD, _QWORD, void *, char *))(LsaTable + 72))(0i64, v10[0], a2, v11);
  }
  else
  {
    RtlReleaseResource((PRTL_RESOURCE)(v4 + 72));
    return 2148074241i64;
  }
}
// 180092620: using guessed type __int64 LsaTable;
// 180098568: using guessed type __int64 __fastcall SslComputeEapKeyBlock(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 180046538: using guessed type unsigned int var_E8[4];

//----- (0000000180046670) ----------------------------------------------------
ULONG __fastcall CSsl3TlsContext::QueryIssuerList(CSsl3TlsContext *this, void *a2)
{
  void *v2; // rsi
  unsigned int v4; // r14d
  int v6; // r15d
  __int64 v7; // rdi
  unsigned int v8; // eax
  unsigned __int8 *v9; // rdi
  unsigned int v10; // r13d
  unsigned __int8 *v11; // rdx
  unsigned __int8 *v12; // r8
  unsigned __int8 *i; // rax
  unsigned int v14; // esi
  HLOCAL v15; // rbx
  int v16; // r12d
  NTSTATUS v17; // ecx
  __int64 v18; // rdx
  __int64 v19; // r9
  int *v20; // r8
  int v21; // ecx
  __int64 v22; // rcx
  int v23; // ecx
  __int64 v24; // rcx
  int v25; // edi
  __int64 v26; // rax
  __int64 *v27; // r9
  __int64 v28; // rdx
  int v29; // ebx
  __int64 v30; // [rsp+30h] [rbp-30h] BYREF
  unsigned int v31; // [rsp+38h] [rbp-28h]
  char v32[32]; // [rsp+40h] [rbp-20h] BYREF
  __int64 v34; // [rsp+B0h] [rbp+50h] BYREF
  int v35; // [rsp+B8h] [rbp+58h] BYREF
  unsigned int v36; // [rsp+BCh] [rbp+5Ch]

  v34 = 0i64;
  v2 = a2;
  v4 = 0;
  if ( !(*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v32) )
    return 1359;
  v31 = 0;
  v6 = v32[8] & 0x40;
  v30 = 0i64;
  v7 = *((_QWORD *)this + 112);
  if ( v7 )
  {
    v8 = *((_DWORD *)this + 222);
    if ( v8 > 2 )
    {
      v9 = (unsigned __int8 *)(v7 + 2);
      v10 = v8 - 2;
      v11 = v9;
      v12 = &v9[v8 - 2];
      for ( i = v9 + 1; i < v12; i = v11 + 1 )
      {
        v11 += (*i | ((unsigned __int64)*v11 << 8)) + 2;
        ++v4;
      }
      v14 = v4 * (v6 != 0 ? 8 : 16);
      v15 = SPExternalAlloc(v14);
      if ( !v15 )
        return -2146893056;
      v16 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64 *))(LsaTable + 56))(0i64, v14 + v10, &v34);
      if ( v16 < 0 )
      {
        SPExternalFree(v15);
LABEL_12:
        v17 = v16;
        return RtlNtStatusToDosError(v17);
      }
      v16 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, unsigned __int8 *))(LsaTable + 72))(
              0i64,
              v10,
              v34 + v14,
              v9);
      if ( v16 < 0 )
      {
        SPExternalFree(v15);
        (*(void (__fastcall **)(_QWORD, __int64))(LsaTable + 64))(0i64, v34);
        goto LABEL_12;
      }
      v18 = v34 + v14;
      if ( v4 )
      {
        v19 = v4;
        v20 = (int *)v15;
        if ( v6 )
        {
          do
          {
            v21 = v9[1] | (*v9 << 8);
            *v20 = v21;
            v22 = (unsigned int)(v21 + 2);
            v9 += v22;
            v20[1] = v18 + 2;
            v18 += v22;
            v20 += 2;
            --v19;
          }
          while ( v19 );
        }
        else
        {
          do
          {
            v23 = v9[1] | (*v9 << 8);
            *v20 = v23;
            v24 = (unsigned int)(v23 + 2);
            v9 += v24;
            *((_QWORD *)v20 + 1) = v18 + 2;
            v18 += v24;
            v20 += 4;
            --v19;
          }
          while ( v19 );
        }
      }
      v25 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, HLOCAL))(LsaTable + 72))(0i64, v14, v34, v15);
      if ( v25 < 0 )
      {
        SPExternalFree(v15);
        (*(void (__fastcall **)(_QWORD, __int64))(LsaTable + 64))(0i64, v34);
        v17 = v25;
        return RtlNtStatusToDosError(v17);
      }
      SPExternalFree(v15);
      v2 = a2;
    }
  }
  if ( v6 )
  {
    v35 = v34;
    v26 = LsaTable;
    v36 = v4;
    v27 = (__int64 *)&v35;
    v28 = 8i64;
  }
  else
  {
    v30 = v34;
    v26 = LsaTable;
    v31 = v4;
    v27 = &v30;
    v28 = 16i64;
  }
  v29 = (*(__int64 (__fastcall **)(_QWORD, __int64, void *, __int64 *))(v26 + 72))(0i64, v28, v2, v27);
  if ( v29 < 0 )
  {
    if ( v34 )
      (*(void (__fastcall **)(_QWORD))(LsaTable + 64))(0i64);
    v17 = v29;
    return RtlNtStatusToDosError(v17);
  }
  return 0;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180046990) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::QueryKeyingMaterial(CSsl3TlsContext *this, void *a2)
{
  __int64 v3; // rbx
  __int64 v4; // rcx
  __int64 v7; // rcx
  __int64 v8; // r8
  unsigned int v9; // ebx
  __int64 *v10; // rax
  unsigned int KeyingMaterialCommon; // eax

  v3 = 0i64;
  v4 = *((_QWORD *)this + 11);
  if ( !v4 )
    return 2148074241i64;
  RtlAcquireResourceShared((PRTL_RESOURCE)(v4 + 72), 1u);
  v7 = *((_QWORD *)this + 11);
  v8 = *(_QWORD *)(v7 + 16);
  if ( v8 )
  {
    v10 = (__int64 *)*((_QWORD *)this + 1);
    if ( v10 )
      v3 = *v10;
    KeyingMaterialCommon = CSsl3TlsContext::QueryKeyingMaterialCommon(
                             this,
                             v3,
                             v8,
                             (unsigned __int8 *)this + 272,
                             0x40u,
                             a2);
    v7 = *((_QWORD *)this + 11);
    v9 = KeyingMaterialCommon;
  }
  else
  {
    v9 = -2146893055;
  }
  RtlReleaseResource((PRTL_RESOURCE)(v7 + 72));
  return v9;
}

//----- (0000000180046A38) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::QueryKeyingMaterialCommon(
        CSsl3TlsContext *this,
        __int64 a2,
        __int64 a3,
        unsigned __int8 *a4,
        unsigned int a5,
        void *a6)
{
  void *v6; // rsi
  unsigned int v9; // edi
  ULONG v10; // ebx
  int v11; // r15d
  __int64 v12; // rax
  HLOCAL v14; // rax
  NTSTATUS v15; // eax
  __int64 v16; // [rsp+50h] [rbp-30h] BYREF
  __int128 v17; // [rsp+58h] [rbp-28h] BYREF
  __int128 v18; // [rsp+68h] [rbp-18h] BYREF
  __int64 v19; // [rsp+78h] [rbp-8h]

  v6 = 0i64;
  v19 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v9 = 0;
  v18 = 0i64;
  if ( !(*(unsigned __int8 (__fastcall **)(__int128 *))(LsaTable + 192))(&v18) )
  {
    v10 = 1359;
    goto LABEL_12;
  }
  v11 = BYTE8(v18) & 0x40;
  if ( !a6 )
  {
    v10 = 87;
    goto LABEL_12;
  }
  if ( !a2 )
    goto LABEL_11;
  v12 = *((_QWORD *)this + 105);
  if ( !v12 )
    goto LABEL_11;
  if ( !a3 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids);
LABEL_11:
    v10 = -2146893055;
    goto LABEL_12;
  }
  v9 = *(_DWORD *)(v12 + 32);
  v14 = SPExternalAlloc(v9);
  v6 = v14;
  if ( v14 )
  {
    v10 = SslExportKeyingMaterial(
            a2,
            a3,
            *(_QWORD *)(*((_QWORD *)this + 105) + 8i64),
            a4,
            a5,
            *(_QWORD *)(*((_QWORD *)this + 105) + 24i64),
            *(_WORD *)(*((_QWORD *)this + 105) + 16i64),
            v14,
            v9,
            0);
    if ( !v10 )
    {
      v15 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64 *))(LsaTable + 56))(0i64, v9, &v16);
      if ( v15 < 0
        || (v15 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, void *))(LsaTable + 72))(0i64, v9, v16, v6),
            v15 < 0)
        || ((LODWORD(v17) = v9, !v11) ? (*((_QWORD *)&v17 + 1) = v16) : (DWORD1(v17) = v16),
            v15 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, void *, __int128 *))(LsaTable + 72))(
                    0i64,
                    v11 != 0 ? 8 : 16,
                    a6,
                    &v17),
            v10 = v15,
            v15 < 0) )
      {
        v10 = RtlNtStatusToDosError(v15);
      }
      if ( !v10 )
        goto LABEL_15;
    }
  }
  else
  {
    v10 = 14;
  }
LABEL_12:
  if ( v16 )
    (*(void (__fastcall **)(_QWORD))(LsaTable + 64))(0i64);
  if ( v6 )
  {
LABEL_15:
    memset(v6, 0, v9);
    SPExternalFree(v6);
  }
  return v10;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;
// 180098560: using guessed type __int64 __fastcall SslExportKeyingMaterial(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180046CA0) ----------------------------------------------------
ULONG __fastcall CSslContext::QueryLocalCred(CSslContext *this, void *a2)
{
  __int64 v2; // rax
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  DWORD PublicKeyLength; // eax
  int v8; // eax
  NTSTATUS v9; // ecx
  int v11; // ebx
  __int128 v12; // [rsp+30h] [rbp-20h] BYREF
  __int128 v13; // [rsp+40h] [rbp-10h]
  __int64 v14; // [rsp+60h] [rbp+10h] BYREF

  v14 = 0i64;
  v2 = *(_QWORD *)this;
  v12 = 0i64;
  v13 = 0i64;
  v4 = (*(__int64 (__fastcall **)(CSslContext *))(v2 + 248))(this);
  if ( v4 )
  {
    v5 = *(_QWORD *)(v4 + 32);
    v6 = *(_QWORD *)(v4 + 432);
    if ( v5 )
    {
      *(_QWORD *)((char *)&v13 + 4) = DWORD1(v13) | 1i64;
      *((_QWORD *)&v12 + 1) = *(_QWORD *)(v5 + 8);
      LODWORD(v12) = *(_DWORD *)(v5 + 16);
      LODWORD(v13) = 1;
      if ( v6 )
      {
        if ( *(_QWORD *)v6 == -8i64 )
          PublicKeyLength = CertGetPublicKeyLength(1u, (PCERT_PUBLIC_KEY_INFO)(*(_QWORD *)(v5 + 24) + 96i64));
        else
          PublicKeyLength = *(_DWORD *)(*(_QWORD *)v6 + 12i64);
        DWORD2(v13) = PublicKeyLength;
      }
    }
  }
  if ( *((_QWORD *)&v12 + 1) )
  {
    v8 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64 *))(LsaTable + 56))(0i64, (unsigned int)v12, &v14);
    if ( v8 < 0 )
    {
      v9 = v8;
      return RtlNtStatusToDosError(v9);
    }
    v11 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, _QWORD))(LsaTable + 72))(
            0i64,
            (unsigned int)v12,
            v14,
            *((_QWORD *)&v12 + 1));
    if ( v11 < 0 )
    {
LABEL_13:
      (*(void (__fastcall **)(_QWORD, __int64))(LsaTable + 64))(0i64, v14);
      v9 = v11;
      return RtlNtStatusToDosError(v9);
    }
    *((_QWORD *)&v12 + 1) = v14;
  }
  v11 = (*(__int64 (__fastcall **)(_QWORD, __int64, void *, __int128 *))(LsaTable + 72))(0i64, 32i64, a2, &v12);
  if ( v11 < 0 )
    goto LABEL_13;
  return 0;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180046E2C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::QuerySupportedMTU(CSsl3TlsContext *this, void *a2)
{
  bool v2; // zf
  unsigned int v3; // ebx
  int v5; // [rsp+40h] [rbp+8h] BYREF

  v2 = *((_BYTE *)this + 233) == 0;
  v3 = 1359;
  v5 = *((unsigned __int16 *)this + 108);
  if ( v2 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 19i64, &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids);
  }
  else
  {
    return (*(unsigned int (__fastcall **)(_QWORD, __int64, void *, int *))(LsaTable + 72))(0i64, 4i64, a2, &v5);
  }
  return v3;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180046EB8) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::QuerySupportedSignatures(CSsl3TlsContext *this, void *a2)
{
  int v5; // ebx
  int v6; // edi
  NTSTATUS v7; // eax
  ULONG v8; // ebx
  __int64 *v9; // r9
  __int128 v10; // [rsp+30h] [rbp-30h] BYREF
  char v11[32]; // [rsp+40h] [rbp-20h] BYREF
  __int64 v12; // [rsp+A0h] [rbp+40h] BYREF
  __int64 v13; // [rsp+A8h] [rbp+48h] BYREF

  v13 = 0i64;
  v10 = 0i64;
  v12 = 0i64;
  if ( !(*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v11) )
    return 1359i64;
  v5 = v11[8] & 0x40;
  if ( (*((_DWORD *)this + 16) & 0x82800) == 0 )
    return 2148074242i64;
  v6 = *((unsigned __int16 *)this + 255);
  if ( (_WORD)v6 )
  {
    v7 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64 *))(LsaTable + 56))(0i64, (unsigned int)(2 * v6), &v12);
    if ( v7 < 0 )
      goto LABEL_7;
    v7 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, char *))(LsaTable + 72))(
           0i64,
           (unsigned int)(2 * v6),
           v12,
           (char *)this + 512);
    if ( v7 < 0 )
      goto LABEL_7;
  }
  if ( v5 )
  {
    HIDWORD(v13) = v12;
    LOWORD(v13) = v6;
  }
  else
  {
    *((_QWORD *)&v10 + 1) = v12;
    LOWORD(v10) = v6;
  }
  v9 = &v13;
  if ( !v5 )
    v9 = (__int64 *)&v10;
  v7 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, void *, __int64 *))(LsaTable + 72))(0i64, v5 != 0 ? 8 : 16, a2, v9);
  if ( v7 < 0 )
  {
LABEL_7:
    v8 = RtlNtStatusToDosError(v7);
  }
  else
  {
    v12 = 0i64;
    v8 = 0;
  }
  if ( v12 )
    (*(void (__fastcall **)(_QWORD))(LsaTable + 64))(0i64);
  return v8;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004705C) ----------------------------------------------------
__int64 __fastcall CSslContext::SetApplicationData(CSslContext *this, void *a2, unsigned int a3)
{
  unsigned int AppDataForSca; // edi
  __int64 v6; // rdi
  void *v7; // rcx
  unsigned __int8 *v8; // rcx
  unsigned int v9; // [rsp+30h] [rbp+8h] BYREF
  unsigned __int8 *v10; // [rsp+48h] [rbp+20h] BYREF

  v10 = 0i64;
  v9 = 0;
  if ( !*((_QWORD *)this + 11) )
    return 2148074241i64;
  AppDataForSca = SpGetAppDataForSca(a2, a3, &v10, &v9);
  if ( AppDataForSca )
  {
    v8 = v10;
  }
  else
  {
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
    v6 = *((_QWORD *)this + 11);
    v7 = *(void **)(v6 + 56);
    if ( v7 )
      SPExternalFree(v7);
    *(_QWORD *)(v6 + 56) = v10;
    *(_DWORD *)(v6 + 64) = v9;
    AppDataForSca = 0;
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
    v8 = 0i64;
  }
  if ( v8 )
    SPExternalFree(v8);
  return AppDataForSca;
}

//----- (0000000180047118) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetEapPrfType(CSsl3TlsContext *this, void *a2, unsigned int a3)
{
  unsigned int AppDataForSca; // eax
  void *v5; // rdx
  unsigned int v6; // ebx
  void *v8; // [rsp+20h] [rbp-18h] BYREF
  unsigned int v9; // [rsp+58h] [rbp+20h] BYREF

  v8 = 0i64;
  v9 = 0;
  AppDataForSca = SpGetAppDataForSca(a2, a3, (unsigned __int8 **)&v8, &v9);
  v5 = v8;
  v6 = AppDataForSca;
  if ( !AppDataForSca )
  {
    if ( v9 == 4 )
      *((_DWORD *)this + 84) = *(_DWORD *)v8;
    else
      v6 = 87;
  }
  if ( v5 )
    SPExternalFree(v5);
  return v6;
}

//----- (000000018004718C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetKeyingMaterialInfo(CSsl3TlsContext *this, void *a2, unsigned int a3)
{
  struct _SecPkgContext_KeyingMaterialInfo *v6; // rax
  struct _SecPkgContext_KeyingMaterialInfo *v7; // rdi
  unsigned int KeyingMaterialInfoForSca; // esi
  void **v9; // rcx

  v6 = (struct _SecPkgContext_KeyingMaterialInfo *)SPExternalAlloc(0x28u);
  v7 = v6;
  if ( v6 )
  {
    KeyingMaterialInfoForSca = SpGetKeyingMaterialInfoForSca(a2, a3, v6);
    if ( KeyingMaterialInfoForSca )
    {
      SPExternalFree(v7);
    }
    else
    {
      v9 = (void **)*((_QWORD *)this + 105);
      if ( v9 )
      {
        if ( v9[1] )
        {
          SPExternalFree(v9[1]);
          v9 = (void **)*((_QWORD *)this + 105);
        }
        if ( v9[3] )
        {
          SPExternalFree(v9[3]);
          v9 = (void **)*((_QWORD *)this + 105);
        }
        SPExternalFree(v9);
      }
      *((_QWORD *)this + 105) = v7;
    }
  }
  else
  {
    return 14;
  }
  return KeyingMaterialInfoForSca;
}

//----- (0000000180047244) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetSupportedMTU(CSsl3TlsContext *this, void *a2, int a3)
{
  __int64 result; // rax
  unsigned __int16 v5; // ax
  struct CSslContext *v6; // rcx
  __int16 v7; // r10
  bool v8; // zf
  unsigned int v9; // [rsp+40h] [rbp+8h] BYREF

  if ( *((_BYTE *)this + 233) )
  {
    if ( a3 != 4 )
      return 87i64;
    result = (*(__int64 (__fastcall **)(_QWORD, __int64, unsigned int *, void *))(LsaTable + 80))(0i64, 4i64, &v9, a2);
    if ( (int)result < 0 )
      return result;
    if ( v9 - 200 <= 0xFF38 && (v5 = CSslContext::computeMaxPayload(this, v9)) != 0 )
    {
      v8 = *((_DWORD *)this + 17) == 4;
      *((_WORD *)this + 108) = v7;
      *((_WORD *)this + 109) = v5;
      if ( !v8 )
        return 0i64;
      result = RemotelySetMtu(v6);
      if ( !(_DWORD)result )
        return 0i64;
    }
    else
    {
      return 87i64;
    }
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids);
    return 1359i64;
  }
  return result;
}
// 1800472EA: variable 'v7' is possibly undefined
// 1800472FB: variable 'v6' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180047320) ----------------------------------------------------
__int64 __fastcall CSslContext::SetUiInformation(CSslContext *this, void *a2, unsigned int a3)
{
  int v7; // ebx
  int v8; // esi
  char v9[24]; // [rsp+30h] [rbp-48h] BYREF
  __int64 v10; // [rsp+48h] [rbp-30h] BYREF

  v10 = 0i64;
  if ( !(*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v9) )
    return 1359i64;
  v7 = v9[8] & 0x40;
  if ( a3 == (v7 != 0 ? 4 : 8) )
  {
    v8 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64 *, void *))(LsaTable + 80))(0i64, a3, &v10, a2);
    if ( v8 >= 0 )
    {
      if ( v7 )
      {
        *((_QWORD *)this + 13) = (unsigned int)v10;
        *((_DWORD *)this + 27) = 0;
      }
      else
      {
        *((_QWORD *)this + 13) = v10;
      }
    }
    else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        11i64,
        &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids,
        (unsigned int)v8);
    }
    return (unsigned int)v8;
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids, a3);
    return 87i64;
  }
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004746C) ----------------------------------------------------
__int64 __fastcall SpGetAppDataForSca(void *a1, unsigned int a2, unsigned __int8 **a3, unsigned int *a4)
{
  int v9; // ebx
  __int64 v10; // rdx
  NTSTATUS v11; // eax
  ULONG v12; // ebx
  bool v13; // zf
  __int64 v14; // rbx
  unsigned int v15; // edi
  unsigned __int8 *v16; // rsi
  NTSTATUS v17; // eax
  __int128 v18; // [rsp+30h] [rbp-38h] BYREF
  char v19[32]; // [rsp+40h] [rbp-28h] BYREF

  v18 = 0i64;
  if ( !(*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v19) )
    return 1359i64;
  v9 = v19[8] & 0x40;
  v10 = v9 != 0 ? 12 : 16;
  if ( a2 < (unsigned int)v10 )
    return 87;
  v11 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int128 *, void *))(LsaTable + 80))(0i64, v10, &v18, a1);
  if ( v11 >= 0 )
  {
    v13 = v9 == 0;
    v14 = *((_QWORD *)&v18 + 1);
    v15 = DWORD1(v18);
    if ( !v13 )
      v14 = DWORD2(v18);
    if ( DWORD1(v18) <= 0x10000 && DWORD1(v18) && v14 )
    {
      v16 = (unsigned __int8 *)SPExternalAlloc(DWORD1(v18));
      if ( v16 )
      {
        v17 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, unsigned __int8 *, __int64))(LsaTable + 80))(
                0i64,
                v15,
                v16,
                v14);
        v12 = v17;
        if ( v17 >= 0 )
        {
          *a3 = v16;
          *a4 = v15;
        }
        else
        {
          v12 = RtlNtStatusToDosError(v17);
        }
        if ( v12 )
          SPExternalFree(v16);
      }
      else
      {
        return 14;
      }
      return v12;
    }
    return 87;
  }
  return RtlNtStatusToDosError(v11);
}
// 180092620: using guessed type __int64 LsaTable;

//----- (00000001800475D8) ----------------------------------------------------
__int64 __fastcall SpGetKeyingMaterialInfoForSca(
        void *a1,
        unsigned int a2,
        struct _SecPkgContext_KeyingMaterialInfo *a3)
{
  CHAR *v6; // rdi
  BYTE *v7; // rsi
  ULONG v8; // ebx
  int v9; // ebx
  __int64 v10; // rdx
  int v11; // eax
  NTSTATUS v12; // ecx
  WORD v13; // r15
  __int64 v14; // rbx
  WORD v15; // r12
  DWORD v16; // r13d
  int v17; // eax
  __int64 v19; // [rsp+30h] [rbp-50h]
  __int128 v20; // [rsp+38h] [rbp-48h] BYREF
  __int64 v21; // [rsp+48h] [rbp-38h]
  __int128 v22; // [rsp+50h] [rbp-30h] BYREF
  __int128 v23; // [rsp+60h] [rbp-20h]
  __int64 v24; // [rsp+70h] [rbp-10h]
  unsigned int v25; // [rsp+C8h] [rbp+48h]

  v24 = 0i64;
  v21 = 0i64;
  v6 = 0i64;
  v22 = 0i64;
  v7 = 0i64;
  v23 = 0i64;
  v20 = 0i64;
  if ( !(*(unsigned __int8 (__fastcall **)(__int128 *))(LsaTable + 192))(&v20) )
    return 1359;
  v9 = BYTE8(v20) & 0x40;
  v10 = v9 != 0 ? 20 : 40;
  if ( !a1 || a2 < (unsigned int)v10 || !a3 )
    return 87;
  v11 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int128 *, void *))(LsaTable + 80))(0i64, v10, &v22, a1);
  if ( v11 < 0 )
  {
LABEL_7:
    v12 = v11;
LABEL_8:
    v8 = RtlNtStatusToDosError(v12);
    goto LABEL_27;
  }
  v13 = v22;
  if ( v9 )
  {
    v14 = DWORD1(v22);
    v15 = WORD4(v22);
    v16 = v23;
    v19 = HIDWORD(v22);
  }
  else
  {
    v14 = *((_QWORD *)&v22 + 1);
    v15 = v23;
    v16 = v24;
    v19 = *((_QWORD *)&v23 + 1);
  }
  if ( (unsigned __int16)(v22 - 1) > 0x103u || !v14 || !v16 )
    return 87;
  v25 = (unsigned __int16)v22;
  v6 = (CHAR *)SPExternalAlloc((unsigned __int16)v22);
  if ( !v6 )
    return 14;
  v11 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, CHAR *, __int64))(LsaTable + 80))(0i64, v25, v6, v14);
  v8 = v11;
  if ( v11 < 0 )
    goto LABEL_7;
  if ( v6[v13 - 1] )
    goto LABEL_19;
  if ( !v15 )
  {
LABEL_26:
    a3->cbLabel = v13;
    a3->pszLabel = v6;
    a3->cbContextValue = v15;
    a3->pbContextValue = v7;
    a3->cbKeyingMaterial = v16;
LABEL_27:
    if ( !v8 )
      return v8;
    if ( !v6 )
      goto LABEL_30;
    goto LABEL_29;
  }
  if ( v19 )
  {
    v7 = (BYTE *)SPExternalAlloc(v15);
    if ( !v7 )
    {
      v8 = 14;
      goto LABEL_29;
    }
    v17 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, BYTE *, __int64))(LsaTable + 80))(0i64, v15, v7, v19);
    v8 = v17;
    if ( v17 < 0 )
    {
      v12 = v17;
      goto LABEL_8;
    }
    goto LABEL_26;
  }
LABEL_19:
  v8 = 87;
LABEL_29:
  SPExternalFree(v6);
LABEL_30:
  if ( v7 )
    SPExternalFree(v7);
  return v8;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180047838) ----------------------------------------------------
void __fastcall ConvertNameString(struct _UNICODE_STRING *a1)
{
  PWSTR Buffer; // rdx
  unsigned __int16 v2; // r10
  PWSTR v3; // r9
  __int64 v4; // rax

  Buffer = a1->Buffer;
  v2 = 0;
  if ( Buffer && a1->MaximumLength )
  {
    v3 = a1->Buffer;
    if ( a1->MaximumLength != 2i64 )
    {
      do
      {
        if ( !*Buffer )
          break;
        *v3 = *Buffer;
        if ( *Buffer == 13 && Buffer[1] == 10 )
        {
          ++Buffer;
          *v3 = 44;
        }
        v2 += 2;
        ++v3;
        ++Buffer;
      }
      while ( v2 < (unsigned __int64)a1->MaximumLength - 2 );
    }
    *v3 = 0;
    v4 = -1i64;
    do
      ++v4;
    while ( a1->Buffer[v4] );
    a1->Length = 2 * v4;
  }
}

//----- (00000001800478D4) ----------------------------------------------------
__int64 __fastcall MapperVerifyClientChain(
        struct CCredentialGroup *a1,
        const struct _CERT_CONTEXT *a2,
        __int64 a3,
        unsigned int a4,
        unsigned int *a5,
        int *a6,
        const struct _CERT_CHAIN_CONTEXT **a7)
{
  int v11; // edx
  int v12; // r8d
  int v13; // edx
  int v14; // ecx
  unsigned int v15; // edx
  unsigned int LastError; // ebx
  _DWORD *v17; // rcx
  __int64 v18; // r8
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  const CERT_CHAIN_CONTEXT *v22; // rcx
  unsigned int v24; // r12d
  __int64 v25; // r9
  const CERT_CHAIN_CONTEXT *v26; // rcx
  DWORD dwFlags; // [rsp+40h] [rbp-91h]
  PCCERT_CHAIN_CONTEXT pChainContext; // [rsp+48h] [rbp-89h] BYREF
  int v29; // [rsp+50h] [rbp-81h] BYREF
  unsigned int v30; // [rsp+54h] [rbp-7Dh]
  const char *v31; // [rsp+58h] [rbp-79h] BYREF
  struct _CERT_CHAIN_PARA pChainPara; // [rsp+60h] [rbp-71h] BYREF
  int v33; // [rsp+98h] [rbp-39h]
  int v34; // [rsp+9Ch] [rbp-35h]
  int v35; // [rsp+A0h] [rbp-31h]
  char v36[16]; // [rsp+C0h] [rbp-11h] BYREF

  pChainContext = 0i64;
  v29 = 0;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 31i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
  *a5 = 0;
  *a6 = 0;
  if ( a7 )
    *a7 = 0i64;
  v11 = (16 * (a4 & 0x1000000)) | 0x20000000;
  if ( (a4 & 0x2000000) == 0 )
    v11 = 16 * (a4 & 0x1000000);
  v12 = v11 | 0x40000000;
  if ( (a4 & 0x4000000) == 0 )
    v12 = v11;
  v13 = HIWORD(a4) & 0x800 | 0x1000;
  if ( (a4 & 0x10000000) == 0 )
    v13 = HIWORD(a4) & 0x800;
  v14 = v12 | 4;
  v30 = v13;
  if ( (a4 & 0x200000) == 0 )
    v14 = v12;
  v15 = v14 | 0x80000000;
  if ( (a4 & 0x400000) == 0 )
    v15 = v14;
  dwFlags = v15;
  LastError = SslImpersonateClient(a3, &v29);
  if ( LastError )
    goto LABEL_30;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x20u,
      (__int64)&WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
      dwFlags,
      a4);
  v31 = "1.3.6.1.5.5.7.3.2";
  memset_0(&pChainPara, 0, 0x60ui64);
  pChainPara.cbSize = 96;
  pChainPara.RequestedUsage.dwType = 1;
  pChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
  pChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = (LPSTR *)&v31;
  if ( a1 )
  {
    v17 = (_DWORD *)*((_QWORD *)a1 + 106);
    if ( v17 )
    {
      v33 = v17[5];
      v34 = v17[6];
      v35 = v17[7];
      if ( v17[8] == 1 )
      {
        pChainPara.RequestedUsage.dwType = 0;
        pChainPara.RequestedUsage.Usage.cUsageIdentifier = 0;
        pChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = 0i64;
      }
    }
  }
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EtwEventWriteTransfer((__int64)v17, (__int64)&ChainBuildStart, v18, 1, (__int64)v36);
  if ( CertGetCertificateChain(0i64, a2, 0i64, a2->hCertStore, &pChainPara, dwFlags, 0i64, &pChainContext) )
  {
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McGenEventWrite_EtwEventWriteTransfer(v19, (__int64)&ChainBuildStop, v20, 1, (__int64)v36);
    if ( (a4 & 0x800000) != 0 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 33i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
      *a5 |= 0x70u;
    }
    else
    {
      v24 = v30;
      LastError = VerifyClientCertificate(pChainContext, (LPCSTR)4, v30, v21);
      if ( LastError )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            34i64,
            &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
            LastError);
        LogBogusClientCertEvent(*((_DWORD *)a1 + 53), (const unsigned __int16 *)a1 + 108, a2, LastError);
      }
      else
      {
        v26 = pChainContext;
        *a5 |= 0x60u;
        LastError = VerifyClientCertificate(v26, (LPCSTR)6, v24, v25);
        if ( !LastError )
        {
          *a5 |= 0x10u;
          goto LABEL_56;
        }
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            35i64,
            &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
            LastError);
        LogFastMappingFailureEvent(*((_DWORD *)a1 + 53), (const unsigned __int16 *)a1 + 108, a2, LastError);
      }
      *a6 = LastError;
    }
    LastError = 0;
    goto LABEL_56;
  }
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EtwEventWriteTransfer(v19, (__int64)&ChainBuildStop, v20, 1, (__int64)v36);
  LastError = GetLastError();
  if ( LastError )
    goto LABEL_30;
LABEL_56:
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 36i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, *a5);
  if ( !a7 )
  {
LABEL_30:
    v22 = pChainContext;
    goto LABEL_31;
  }
  v22 = 0i64;
  *a7 = pChainContext;
  pChainContext = 0i64;
LABEL_31:
  if ( v22 )
    CertFreeCertificateChain(v22);
  if ( v29 )
    RevertToSelf();
  return LastError;
}
// 180047AB5: variable 'v17' is possibly undefined
// 180047AB5: variable 'v18' is possibly undefined
// 180047B16: variable 'v19' is possibly undefined
// 180047B16: variable 'v20' is possibly undefined
// 180047BF6: variable 'v21' is possibly undefined
// 180047C0F: variable 'v25' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180084C80: using guessed type EVENT_DESCRIPTOR ChainBuildStop;
// 180084C90: using guessed type EVENT_DESCRIPTOR ChainBuildStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;

//----- (0000000180047D14) ----------------------------------------------------
__int64 __fastcall SslBuildCertLogonRequest(
        const struct _CERT_CHAIN_CONTEXT *a1,
        int a2,
        struct _SSL_CERT_LOGON_REQ **a3,
        unsigned int *a4)
{
  PCERT_SIMPLE_CHAIN v5; // r13
  PCCERT_CONTEXT pCertContext; // r15
  unsigned int v7; // ebx
  __int64 v8; // rsi
  __int64 v9; // rdi
  PCCERT_CONTEXT v10; // r14
  unsigned int v11; // ebp
  _DWORD *v12; // rax
  _DWORD *v13; // rdi
  unsigned int v15; // r14d
  DWORD v16; // r14d
  _DWORD *v17; // r12
  __int64 v18; // rbx

  v5 = *a1->rgpChain;
  pCertContext = (*v5->rgpElement)->pCertContext;
  v7 = pCertContext->cbCertEncoded + 32;
  if ( pCertContext->cbCertEncoded >= 0xFFFFFFE0 )
    return 534i64;
  v8 = 0i64;
  v9 = 0i64;
  if ( v5->cElement )
  {
    while ( 1 )
    {
      v10 = v5->rgpElement[v9]->pCertContext;
      if ( (_DWORD)v9 )
      {
        if ( CertCompareCertificateName(v10->dwCertEncodingType, &v10->pCertInfo->Issuer, &v10->pCertInfo->Subject) )
          goto LABEL_8;
        v7 += 8;
      }
      if ( v7 + v10->pCertInfo->Issuer.cbData < v7 )
        return 3221225621i64;
      v8 = (unsigned int)(v8 + 1);
      v9 = (unsigned int)(v9 + 1);
      v7 += v10->pCertInfo->Issuer.cbData;
      if ( (unsigned int)v9 >= v5->cElement )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    v11 = (v7 + 3) & 0xFFFFFFFC;
    v12 = LocalAlloc(0x40u, v11);
    v13 = v12;
    if ( v12 )
    {
      *v12 = 2;
      v15 = 8 * v8 + 24;
      v12[2] = v15;
      v12[1] = v11;
      v12[3] = pCertContext->cbCertEncoded;
      v12[4] = a2 | 0x80;
      memcpy_0((char *)v12 + v15, pCertContext->pbCertEncoded, pCertContext->cbCertEncoded);
      v16 = pCertContext->cbCertEncoded + v15;
      v13[5] = v8;
      if ( (_DWORD)v8 )
      {
        v17 = v13 + 7;
        do
        {
          v18 = *(_QWORD *)(*(_QWORD *)((char *)v17 + (unsigned __int64)v5->rgpElement - (_QWORD)v13 - 28) + 8i64);
          *(v17 - 1) = v16;
          *v17 = *(_DWORD *)(*(_QWORD *)(v18 + 24) + 48i64);
          memcpy_0(
            (char *)v13 + v16,
            *(const void **)(*(_QWORD *)(v18 + 24) + 56i64),
            *(unsigned int *)(*(_QWORD *)(v18 + 24) + 48i64));
          v17 += 2;
          v16 += *(_DWORD *)(*(_QWORD *)(v18 + 24) + 48i64);
          --v8;
        }
        while ( v8 );
      }
      *a3 = (struct _SSL_CERT_LOGON_REQ *)v13;
      *a4 = v11;
      return 0i64;
    }
    else
    {
      return 2148074240i64;
    }
  }
}

//----- (0000000180047EB0) ----------------------------------------------------
__int64 __fastcall SslCrackSingleName(
        unsigned int a1,
        __int64 a2,
        struct _UNICODE_STRING *a3,
        struct _UNICODE_STRING *a4,
        unsigned int a5,
        struct _UNICODE_STRING *a6,
        struct _UNICODE_STRING *a7,
        unsigned int *a8)
{
  int v10; // edi
  USHORT v12; // cx
  WCHAR *v13; // rax
  SIZE_T v14; // rdx
  _WORD *v15; // rax
  _WORD *v16; // rsi
  int v17; // [rsp+54h] [rbp-64h] BYREF
  struct _UNICODE_STRING v18; // [rsp+58h] [rbp-60h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+68h] [rbp-50h] BYREF
  __int128 v20; // [rsp+78h] [rbp-40h] BYREF
  unsigned __int16 v22; // [rsp+C8h] [rbp+10h]

  v10 = 0;
  v20 = 0i64;
  if ( !(unsigned __int8)SampUsingDsData() )
    return 2148074242i64;
  if ( a4 )
  {
    if ( a3 )
    {
      v12 = a4->Length + a3->Length;
      if ( v12 < a3->Length || (unsigned __int16)(v12 + 4) < v12 )
        return 2148074240i64;
    }
  }
  v18.Buffer = (PWSTR)LocalAlloc(0x40u, 0x410ui64);
  v13 = (WCHAR *)LocalAlloc(0x40u, 0x208ui64);
  DestinationString.Buffer = v13;
  if ( v18.Buffer && v13 )
  {
    *(_DWORD *)&v18.Length = 68157440;
    *(_DWORD *)&DestinationString.Length = 34078720;
    a5 = 520;
    v17 = 260;
    if ( a4 )
    {
      v14 = (unsigned __int16)(a4->Length + a3->Length + 4);
      WORD1(v20) = v14;
      v22 = v14 - 2;
      LOWORD(v20) = v14 - 2;
      v15 = LocalAlloc(0x40u, v14);
      v16 = v15;
      *((_QWORD *)&v20 + 1) = v15;
      if ( v15 )
      {
        memcpy_0(v15, a4->Buffer, a4->Length);
        v16[(unsigned __int64)a4->Length >> 1] = 58;
        memcpy_0(&v16[((unsigned __int64)a4->Length >> 1) + 1], a3->Buffer, a3->Length);
        v16[(unsigned __int64)v22 >> 1] = 0;
        a3 = (struct _UNICODE_STRING *)&v20;
      }
      else
      {
        a3 = 0i64;
      }
    }
    else
    {
      v16 = (_WORD *)*((_QWORD *)&v20 + 1);
    }
    if ( a3 )
    {
      if ( IsCrackSingleNamePresent() )
      {
        if ( (unsigned int)CrackSingleName(
                             a1,
                             4i64,
                             a3->Buffer,
                             2i64,
                             &v17,
                             DestinationString.Buffer,
                             &a5,
                             v18.Buffer,
                             a8) )
        {
          v10 = -1073741823;
        }
        else
        {
          v10 = 0;
          RtlInitUnicodeString(&DestinationString, DestinationString.Buffer);
          RtlInitUnicodeString(&v18, v18.Buffer);
          *a6 = v18;
          *a7 = DestinationString;
        }
      }
      else
      {
        v10 = -1073741637;
      }
      if ( v16 )
        LocalFree(v16);
    }
  }
  else
  {
    v10 = -2146893056;
  }
  if ( v10 < 0 )
  {
    if ( v18.Buffer )
      LocalFree(v18.Buffer);
    if ( DestinationString.Buffer )
      LocalFree(DestinationString.Buffer);
  }
  return (unsigned int)v10;
}
// 1800982A0: using guessed type __int64 SampUsingDsData(void);
// 180098400: using guessed type __int64 __fastcall CrackSingleName(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800481B0) ----------------------------------------------------
__int64 __fastcall SslCreateTokenFromPac(
        unsigned __int8 *a1,
        __int64 a2,
        struct _UNICODE_STRING *a3,
        struct _LUID *a4,
        void **a5)
{
  unsigned int v7; // ebx
  __int64 v8; // rcx
  struct _LUID v10; // [rsp+60h] [rbp-71h] BYREF
  void *v11; // [rsp+68h] [rbp-69h] BYREF
  char v12[8]; // [rsp+70h] [rbp-61h] BYREF
  char v13[8]; // [rsp+78h] [rbp-59h] BYREF
  __int64 v14; // [rsp+80h] [rbp-51h]
  unsigned __int8 v15[80]; // [rsp+90h] [rbp-41h] BYREF

  v14 = 0i64;
  v7 = (*(__int64 (__fastcall **)(unsigned __int8 *, __int64, __int64, struct _TOKEN_SOURCE *, int, struct _UNICODE_STRING *, void **, struct _LUID *, char *, char *))(LsaTable + 272))(
         a1,
         a2,
         2i64,
         &SslTokenSource,
         3,
         a3,
         &v11,
         &v10,
         v13,
         v12);
  if ( (v7 & 0x80000000) != 0 )
  {
    (*(void (__fastcall **)(_QWORD, _QWORD, void *, void *, _QWORD, _QWORD, int, struct _TOKEN_SOURCE *, struct _LUID *))(LsaTable + 168))(
      v7,
      v7,
      &SslNullString,
      &SslNullString,
      0i64,
      0i64,
      3,
      &SslTokenSource,
      &v10);
  }
  else
  {
    if ( (unsigned int)GetTokenUserSid(v11, v15) )
      (*(void (__fastcall **)(_QWORD, _QWORD, char *, struct _UNICODE_STRING *, _QWORD, unsigned __int8 *, int, int, struct _TOKEN_SOURCE *, struct _LUID *))(LsaTable + 464))(
        0i64,
        0i64,
        v13,
        a3,
        0i64,
        v15,
        3,
        2,
        &SslTokenSource,
        &v10);
    v8 = v14;
    *a5 = v11;
    *a4 = v10;
    if ( v8 )
      (*(void (**)(void))(LsaTable + 48))();
  }
  return v7;
}
// 180092620: using guessed type __int64 LsaTable;
// 1800481B0: using guessed type char var_B0[8];
// 1800481B0: using guessed type char var_A8[8];

//----- (000000018004835C) ----------------------------------------------------
__int64 __fastcall SslDoClientRequest(
        void **a1,
        void *a2,
        size_t a3,
        unsigned int a4,
        void **a5,
        unsigned int *a6,
        int *a7)
{
  int v7; // edi
  void *v8; // r13
  struct _MSV1_0_PASSTHROUGH_RESPONSE *v9; // r14
  void **v12; // r12
  unsigned int v13; // eax
  int v14; // ebx
  const wchar_t *v15; // rsi
  unsigned int v16; // ecx
  SIZE_T v17; // rdx
  _DWORD *v18; // rax
  _DWORD *v19; // rbx
  int v20; // edx
  __int64 v21; // rcx
  unsigned int *v22; // rax
  unsigned int v23; // ebx
  int v25; // eax
  PUCHAR ValidationData; // rdi
  wchar_t *v27; // rax
  struct _MSV1_0_PASSTHROUGH_RESPONSE *v28; // [rsp+48h] [rbp-41h] BYREF
  void *v29; // [rsp+50h] [rbp-39h] BYREF
  PCWSTR SourceString; // [rsp+58h] [rbp-31h] BYREF
  void *v31; // [rsp+60h] [rbp-29h]
  struct _UNICODE_STRING DestinationString; // [rsp+68h] [rbp-21h] BYREF
  char v33[80]; // [rsp+78h] [rbp-11h] BYREF
  void **v34; // [rsp+D8h] [rbp+4Fh] BYREF
  void *Src; // [rsp+E0h] [rbp+57h] BYREF
  size_t Size; // [rsp+E8h] [rbp+5Fh] BYREF

  Size = a3;
  v34 = a1;
  v7 = 0;
  Src = 0i64;
  v8 = 0i64;
  v31 = 0i64;
  v9 = 0i64;
  v29 = 0i64;
  SourceString = 0i64;
  DestinationString = 0i64;
  v28 = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 51i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
  v12 = a5;
  if ( a5 )
    *a5 = 0i64;
  v13 = SslMapCertToUserPac(
          (struct _SSL_CERT_LOGON_REQ *)a2,
          a4,
          (unsigned __int8 **)&Src,
          (unsigned int *)&Size,
          (unsigned __int16 **)&SourceString);
  v14 = v13;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 52i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, v13);
  v15 = SourceString;
  if ( v14 >= 0 )
  {
    v8 = Src;
LABEL_11:
    DestinationString = SslDomainName;
    goto LABEL_12;
  }
  if ( !SourceString )
    goto LABEL_11;
  RtlInitUnicodeString(&DestinationString, SourceString);
  RtlAcquireResourceShared(&SslGlobalLock, 1u);
  if ( RtlEqualUnicodeString(&DestinationString, &SslGlobalDnsDomainName, 1u)
    || RtlEqualUnicodeString(&DestinationString, &SslDomainName, 1u) )
  {
    v7 = 1;
  }
  RtlReleaseResource(&SslGlobalLock);
  if ( v7 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 53i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
    v14 = -1073741715;
    goto LABEL_27;
  }
  if ( (*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v33) && (v33[8] & 8) != 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 54i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
    goto LABEL_27;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
    WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x37u, (__int64)&WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, v15);
  v25 = SslMapCertAtDC(
          &DestinationString,
          a2,
          *((_DWORD *)a2 + 1),
          1,
          0,
          (unsigned __int8 **)&Src,
          (unsigned int *)&Size,
          &v28);
  v9 = v28;
  v14 = v25;
  if ( v25 < 0 )
    goto LABEL_27;
  ValidationData = v28->ValidationData;
  v31 = Src;
  v27 = wcschr(v15, 0x2Eu);
  if ( v27 )
  {
    *v27 = 0;
    RtlInitUnicodeString(&DestinationString, v15);
  }
  if ( (unsigned int)(*((_DWORD *)ValidationData + 1) - *((_DWORD *)ValidationData + 3)) <= 0x20
    || *((_DWORD *)ValidationData + 6) >= 0x10000u )
  {
    goto LABEL_13;
  }
  DestinationString.Length = *((_WORD *)ValidationData + 12);
  DestinationString.MaximumLength = DestinationString.Length;
  DestinationString.Buffer = (PWSTR)&ValidationData[*((unsigned int *)ValidationData + 5)];
LABEL_12:
  if ( v14 < 0 )
  {
LABEL_27:
    *a6 = 0;
    *a7 = v14;
    goto LABEL_28;
  }
LABEL_13:
  v14 = (*(__int64 (__fastcall **)(void *, _QWORD, _QWORD, void **, void ***))(LsaTable + 376))(
          Src,
          (unsigned int)Size,
          0i64,
          &v29,
          &v34);
  if ( v14 < 0 )
    goto LABEL_27;
  Src = v29;
  LODWORD(Size) = (_DWORD)v34;
  v16 = (_DWORD)v34 + 32;
  if ( (unsigned int)v34 >= 0xFFFFFFE0 || (v17 = v16 + DestinationString.Length, (unsigned int)v17 < v16) )
  {
    v23 = -1073741675;
  }
  else
  {
    v18 = VirtualAlloc(0i64, v17, 0x1000u, 4u);
    v19 = v18;
    if ( v18 )
    {
      *v18 = 2;
      v20 = Size + 32 + DestinationString.Length;
      v18[2] = 32;
      v18[1] = v20;
      v18[3] = Size;
      memcpy_0(v18 + 8, Src, (unsigned int)Size);
      v21 = (unsigned int)(Size + 32);
      v19[5] = v21;
      v19[6] = DestinationString.Length;
      memcpy_0((char *)v19 + v21, DestinationString.Buffer, DestinationString.Length);
      v22 = a6;
      *v12 = v19;
      *v22 = v19[1];
      *a7 = 0;
LABEL_28:
      v23 = 0;
      goto LABEL_29;
    }
    v23 = -1073741801;
  }
LABEL_29:
  if ( v9 )
    (*(void (__fastcall **)(struct _MSV1_0_PASSTHROUGH_RESPONSE *))(LsaTable + 184))(v9);
  if ( v8 )
    (*(void (__fastcall **)(void *))(LsaTable + 48))(v8);
  if ( v31 )
    (*(void (**)(void))(LsaTable + 48))();
  if ( v29 )
    (*(void (**)(void))(LsaTable + 48))();
  if ( v15 )
    (*(void (__fastcall **)(const wchar_t *))(LsaTable + 48))(v15);
  return v23;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180048860) ----------------------------------------------------
void __fastcall SslDomainChangeCallback(enum _POLICY_NOTIFICATION_INFORMATION_CLASS a1)
{
  int v1; // eax
  struct _UNICODE_STRING v2; // xmm0
  struct _UNICODE_STRING v3; // [rsp+20h] [rbp-18h] BYREF
  struct _UNICODE_STRING *v4; // [rsp+48h] [rbp+10h] BYREF

  if ( a1 == PolicyNotifyDnsDomainInformation )
  {
    v4 = 0i64;
    v3 = 0i64;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 88i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
    v1 = LsaIQueryInformationPolicyTrusted(12i64, &v4);
    if ( v1 >= 0 )
    {
      if ( (int)SslDuplicateString(&v3, v4 + 1) >= 0 )
      {
        if ( RtlAcquireResourceExclusive(&SslGlobalLock, 1u) )
        {
          SslFreeString(&SslGlobalDnsDomainName);
          v2 = v3;
          v3.Buffer = 0i64;
          SslGlobalDnsDomainName = v2;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_S(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x5Bu,
              (__int64)&WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
              SslGlobalDnsDomainName.Buffer);
          }
          RtlReleaseResource(&SslGlobalLock);
        }
        else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
               && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 90i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
        }
      }
    }
    else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        89i64,
        &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
        (unsigned int)v1);
    }
    if ( v4 )
      LsaIFree_LSAPR_POLICY_INFORMATION(12i64);
    SslFreeString(&v3);
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098220: using guessed type __int64 __fastcall LsaIFree_LSAPR_POLICY_INFORMATION(_QWORD);
// 180098228: using guessed type __int64 __fastcall LsaIQueryInformationPolicyTrusted(_QWORD, _QWORD);

//----- (00000001800489EC) ----------------------------------------------------
__int64 __fastcall SslGetNameFromCertificate(PCCERT_CONTEXT pCertContext, unsigned __int16 **a2, int *a3)
{
  PCERT_INFO pCertInfo; // rax
  unsigned __int16 *v4; // rbx
  unsigned int v5; // r12d
  PCERT_EXTENSION rgExtension; // rsi
  __int64 v9; // rdi
  _QWORD *v10; // rdi
  __int64 v11; // rsi
  __int64 v12; // rax
  __int64 v13; // r14
  unsigned __int16 *v14; // rax
  unsigned int v15; // r14d
  PCERT_EXTENSION v16; // rsi
  __int64 v17; // rdi
  void *v18; // rcx
  __int64 v19; // rdx
  __int64 v20; // rsi
  __int64 v21; // rdi
  HLOCAL v22; // rcx
  SIZE_T v24; // r12
  unsigned __int16 *v25; // rax
  DWORD NameStringW; // eax
  DWORD cchNameString; // edi
  WCHAR *v28; // rax
  HLOCAL pvStructInfo[3]; // [rsp+40h] [rbp-18h] BYREF
  DWORD pcbStructInfo; // [rsp+A0h] [rbp+48h] BYREF
  unsigned __int16 **v31; // [rsp+A8h] [rbp+50h]
  _QWORD *v32; // [rsp+B0h] [rbp+58h] BYREF
  HLOCAL hMem; // [rsp+B8h] [rbp+60h] BYREF

  v31 = a2;
  pCertInfo = pCertContext->pCertInfo;
  v4 = 0i64;
  *a3 = 0;
  v5 = 0;
  if ( pCertInfo->cExtension )
  {
    while ( 1 )
    {
      rgExtension = pCertInfo->rgExtension;
      v9 = v5;
      if ( !strcmp_0(rgExtension[v9].pszObjId, "2.5.29.17") )
      {
        pcbStructInfo = 0;
        pvStructInfo[0] = 0i64;
        if ( CryptDecodeObjectEx(
               pCertContext->dwCertEncodingType,
               (LPCSTR)0xC,
               rgExtension[v9].Value.pbData,
               rgExtension[v9].Value.cbData,
               0x2008000u,
               0i64,
               pvStructInfo,
               &pcbStructInfo) )
        {
          v10 = pvStructInfo[0];
          v11 = 0i64;
          if ( *(_DWORD *)pvStructInfo[0] )
          {
            do
            {
              v12 = v10[1];
              if ( *(_DWORD *)(v12 + 24 * v11) == 1 )
              {
                v13 = *(_QWORD *)(v12 + 24 * v11 + 8);
                if ( v13 )
                {
                  if ( !strcmp_0("1.3.6.1.4.1.311.20.2.3", *(const char **)v13) )
                  {
                    LODWORD(v32) = 0;
                    hMem = 0i64;
                    if ( CryptDecodeObjectEx(
                           pCertContext->dwCertEncodingType,
                           (LPCSTR)0x18,
                           *(const BYTE **)(v13 + 16),
                           *(_DWORD *)(v13 + 8),
                           0x2008000u,
                           0i64,
                           &hMem,
                           (DWORD *)&v32) )
                    {
                      v14 = (unsigned __int16 *)LocalAlloc(0x40u, *((unsigned int *)hMem + 2) + 2i64);
                      v4 = v14;
                      if ( v14 )
                        memcpy_0(v14, *((const void **)hMem + 2), *((unsigned int *)hMem + 2));
                      LocalFree(hMem);
                      hMem = 0i64;
                      if ( !v4 )
                      {
                        v22 = pvStructInfo[0];
                        goto LABEL_26;
                      }
                    }
                    v10 = pvStructInfo[0];
                    if ( v4 )
                      break;
                  }
                }
              }
              v11 = (unsigned int)(v11 + 1);
            }
            while ( (unsigned int)v11 < *(_DWORD *)v10 );
          }
          LocalFree(v10);
          if ( v4 )
            break;
        }
      }
      pCertInfo = pCertContext->pCertInfo;
      if ( ++v5 >= pCertInfo->cExtension )
        goto LABEL_16;
    }
LABEL_37:
    *v31 = v4;
    return 0i64;
  }
LABEL_16:
  v15 = 0;
  if ( !pCertInfo->cExtension )
  {
LABEL_32:
    NameStringW = CertGetNameStringW(pCertContext, 3u, 0, "2.5.4.3", 0i64, 0);
    cchNameString = NameStringW;
    if ( !NameStringW )
      return 3221226021i64;
    v28 = (WCHAR *)LocalAlloc(0x40u, 2i64 * NameStringW);
    v4 = v28;
    if ( !v28 )
      return 3221225495i64;
    if ( !CertGetNameStringW(pCertContext, 3u, 0, "2.5.4.3", v28, cchNameString) )
    {
      LocalFree(v4);
      return 3221225524i64;
    }
    goto LABEL_37;
  }
  while ( 1 )
  {
    v16 = pCertInfo->rgExtension;
    v17 = v15;
    if ( !strcmp_0(v16[v17].pszObjId, "2.5.29.17") )
    {
      pcbStructInfo = 0;
      v32 = 0i64;
      if ( CryptDecodeObjectEx(
             pCertContext->dwCertEncodingType,
             (LPCSTR)0xC,
             v16[v17].Value.pbData,
             v16[v17].Value.cbData,
             0x2008000u,
             0i64,
             &v32,
             &pcbStructInfo) )
      {
        break;
      }
    }
LABEL_31:
    pCertInfo = pCertContext->pCertInfo;
    if ( ++v15 >= pCertInfo->cExtension )
      goto LABEL_32;
  }
  v18 = v32;
  v19 = 0i64;
  if ( !*(_DWORD *)v32 )
  {
LABEL_30:
    LocalFree(v18);
    if ( v4 )
      goto LABEL_37;
    goto LABEL_31;
  }
  v20 = v32[1];
  while ( 1 )
  {
    v21 = 3 * v19;
    if ( *(_DWORD *)(v20 + 24 * v19) == 3 )
    {
      if ( *(_QWORD *)(v20 + 24 * v19 + 8) )
        break;
    }
    v19 = (unsigned int)(v19 + 1);
    if ( (unsigned int)v19 >= *(_DWORD *)v32 )
      goto LABEL_30;
  }
  v24 = (unsigned int)(2 * lstrlenW(*(LPCWSTR *)(v20 + 24 * v19 + 8)) + 2);
  v25 = (unsigned __int16 *)LocalAlloc(0x40u, v24);
  v4 = v25;
  if ( v25 )
  {
    memcpy_0(v25, *(const void **)(v20 + 8 * v21 + 8), (unsigned int)v24);
    v18 = v32;
    *a3 = 1;
    goto LABEL_30;
  }
  v22 = v32;
LABEL_26:
  LocalFree(v22);
  return 3221225495i64;
}
// 180048BBD: conditional instruction was optimized away because rbx.8==0
// 180048D0F: conditional instruction was optimized away because rbx.8==0
// 1800489EC: using guessed type HLOCAL var_18[3];

//----- (0000000180048DD8) ----------------------------------------------------
__int64 __fastcall SslLocalMapCredential(
        struct CCredentialGroup *a1,
        __int64 a2,
        int a3,
        __int64 a4,
        unsigned int a5,
        struct _CERT_CONTEXT *a6,
        struct _LUID a7,
        unsigned __int16 *a8,
        unsigned __int16 *a9,
        unsigned __int64 *a10)
{
  struct _MSV1_0_PASSTHROUGH_RESPONSE *v10; // r13
  unsigned __int8 *v11; // r14
  unsigned __int8 *v12; // r12
  __int64 result; // rax
  int v14; // esi
  PCCERT_CHAIN_CONTEXT v15; // rdi
  int v16; // ebx
  CCipherMill *v17; // rcx
  __int64 v18; // rdx
  CCipherMill *v19; // rcx
  __int64 v20; // rdx
  unsigned int *v21; // r15
  int v22; // eax
  CCipherMill *v23; // rcx
  const WCHAR *v24; // rsi
  int v25; // edi
  int v26; // eax
  PUCHAR ValidationData; // rcx
  int v28; // esi
  unsigned __int8 *v29; // [rsp+48h] [rbp-59h] BYREF
  void *v30; // [rsp+50h] [rbp-51h] BYREF
  PCCERT_CHAIN_CONTEXT pChainContext; // [rsp+58h] [rbp-49h] BYREF
  unsigned int v32; // [rsp+60h] [rbp-41h] BYREF
  unsigned __int8 *v33; // [rsp+68h] [rbp-39h] BYREF
  struct _UNICODE_STRING v34; // [rsp+70h] [rbp-31h] BYREF
  HLOCAL hMem; // [rsp+80h] [rbp-21h] BYREF
  struct _MSV1_0_PASSTHROUGH_RESPONSE *v36; // [rsp+88h] [rbp-19h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+90h] [rbp-11h] BYREF
  __int64 v39; // [rsp+F0h] [rbp+4Fh] BYREF
  int v40; // [rsp+F8h] [rbp+57h] BYREF

  v39 = a2;
  v36 = 0i64;
  hMem = 0i64;
  v10 = 0i64;
  a7.LowPart = 0;
  v11 = 0i64;
  v29 = 0i64;
  v12 = 0i64;
  v33 = 0i64;
  v40 = 0;
  pChainContext = 0i64;
  v34 = 0i64;
  if ( a3 != 1 )
    return 2148074253i64;
  result = MapperVerifyClientChain(a1, a6, a4, a5, &v32, &v40, &pChainContext);
  if ( !(_DWORD)result )
  {
    v14 = v32;
    v15 = pChainContext;
    if ( (v32 & 0x10) != 0 )
    {
      if ( (g_dwCertMappingMethods & 8) != 0 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 37i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
        }
        v16 = SslTryS4U2Self(v15, &v30, 0, a8, a9);
        if ( v16 >= 0 )
        {
          v17 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) == 0 )
          {
            goto LABEL_14;
          }
          v18 = 38i64;
LABEL_13:
          WPP_SF_(*((_QWORD *)v17 + 2), v18, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
LABEL_14:
          CertFreeCertificateChain(v15);
          *a10 = (unsigned __int64)v30;
          return (unsigned int)v16;
        }
        v19 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
        {
          v20 = 39i64;
LABEL_29:
          WPP_SF_D(*((_QWORD *)v19 + 2), v20, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, (unsigned int)v16);
          goto LABEL_30;
        }
        goto LABEL_31;
      }
    }
    else if ( (v32 & 0x60) != 0 && (g_dwCertMappingMethods & 0x10) != 0 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 40i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
      }
      v16 = SslTryS4U2Self(v15, &v30, 4, a8, a9);
      if ( v16 >= 0 )
      {
        v17 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
          || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) == 0 )
        {
          goto LABEL_14;
        }
        v18 = 41i64;
        goto LABEL_13;
      }
      v19 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      {
        v20 = 42i64;
        goto LABEL_29;
      }
LABEL_31:
      if ( !v14 )
      {
        if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)v19 + 7) & 0x100) != 0 )
          WPP_SF_(*((_QWORD *)v19 + 2), 43i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
        v16 = -2146893017;
        if ( v40 < 0 )
          v16 = v40;
        CertFreeCertificateChain(v15);
        return (unsigned int)v16;
      }
      v16 = SslBuildCertLogonRequest(v15, v14, (struct _SSL_CERT_LOGON_REQ **)&hMem, (unsigned int *)&a7);
      CertFreeCertificateChain(v15);
      if ( v16 < 0 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
        {
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            44i64,
            &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
            (unsigned int)v16);
        }
        return (unsigned int)v16;
      }
      CSchannelTelemetryContext::LogRCMPUsage(1);
      v21 = (unsigned int *)hMem;
      v22 = SslMapCertToUserPac(
              (struct _SSL_CERT_LOGON_REQ *)hMem,
              a7.LowPart,
              &v29,
              (unsigned int *)&v39,
              (unsigned __int16 **)&pChainContext);
      v23 = WPP_GLOBAL_Control;
      v16 = v22;
      if ( v22 < 0 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
        {
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            45i64,
            &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
            (unsigned int)v22);
          v23 = WPP_GLOBAL_Control;
        }
        v24 = (const WCHAR *)pChainContext;
        if ( pChainContext || v16 == -1073740943 )
        {
          v25 = 0;
          if ( v23 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)v23 + 7) & 0x100) != 0 )
            WPP_SF_(*((_QWORD *)v23 + 2), 46i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
          if ( v16 == -1073740943 )
          {
            v25 = 1;
            DestinationString = SslDomainName;
          }
          else
          {
            RtlInitUnicodeString(&DestinationString, v24);
          }
          v26 = SslMapCertAtDC(&DestinationString, v21, v21[1], 1, v25, &v29, (unsigned int *)&v39, &v36);
          v10 = v36;
          v16 = v26;
          if ( v26 < 0 )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
            {
              WPP_SF_D(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                47i64,
                &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
                (unsigned int)v26);
            }
          }
          else
          {
            ValidationData = v36->ValidationData;
            v12 = v29;
            if ( (unsigned int)(*((_DWORD *)ValidationData + 1) - *((_DWORD *)ValidationData + 3)) <= 0x20
              || *((_DWORD *)ValidationData + 6) >= 0x10000u )
            {
              v34 = SslDomainName;
            }
            else
            {
              v34.Length = *((_WORD *)ValidationData + 12);
              v34.MaximumLength = v34.Length;
              v34.Buffer = (PWSTR)&ValidationData[*((unsigned int *)ValidationData + 5)];
            }
          }
          (*(void (__fastcall **)(const WCHAR *))(LsaTable + 48))(v24);
          v23 = WPP_GLOBAL_Control;
LABEL_65:
          if ( v16 >= 0 )
          {
            v16 = (*(__int64 (__fastcall **)(unsigned __int8 *, _QWORD, _QWORD, unsigned __int8 **, struct _CERT_CONTEXT **))(LsaTable + 376))(
                    v29,
                    (unsigned int)v39,
                    0i64,
                    &v33,
                    &a6);
            if ( v16 >= 0 )
            {
              v29 = v33;
              v28 = 0;
              LODWORD(v39) = (_DWORD)a6;
              v16 = SslCreateTokenFromPac(v33, (unsigned int)a6, &v34, &a7, &v30);
              if ( v16 < 0 )
              {
                v23 = WPP_GLOBAL_Control;
                if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
                  || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) == 0 )
                {
                  goto LABEL_77;
                }
                WPP_SF_D(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  49i64,
                  &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
                  (unsigned int)v16);
              }
              else
              {
                *a10 = (unsigned __int64)v30;
              }
              v23 = WPP_GLOBAL_Control;
LABEL_77:
              if ( v21 )
              {
                LocalFree(v21);
                v23 = WPP_GLOBAL_Control;
              }
              if ( v10 )
              {
                (*(void (__fastcall **)(struct _MSV1_0_PASSTHROUGH_RESPONSE *))(LsaTable + 184))(v10);
                v23 = WPP_GLOBAL_Control;
              }
              if ( v11 )
              {
                (*(void (__fastcall **)(unsigned __int8 *))(LsaTable + 48))(v11);
                v23 = WPP_GLOBAL_Control;
              }
              if ( v12 )
              {
                (*(void (__fastcall **)(unsigned __int8 *))(LsaTable + 48))(v12);
                v23 = WPP_GLOBAL_Control;
              }
              if ( v33 )
              {
                (*(void (__fastcall **)(unsigned __int8 *))(LsaTable + 48))(v33);
                v23 = WPP_GLOBAL_Control;
              }
              if ( v16 < 0 )
              {
                if ( v23 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v23 + 28) & 2) != 0 )
                  WPP_SF_D(
                    *((_QWORD *)v23 + 2),
                    50i64,
                    &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
                    (unsigned int)v16);
                LogCertMappingFailureEvent(*((_DWORD *)a1 + 53), (const unsigned __int16 *)a1 + 108, v16);
                if ( v28 < 0 && (v16 & 0x1FFF0000) != 589824 )
                  return (unsigned int)v28;
              }
              return (unsigned int)v16;
            }
            v23 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
            {
              WPP_SF_D(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                48i64,
                &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
                (unsigned int)v16);
              v23 = WPP_GLOBAL_Control;
            }
          }
          v28 = v40;
          goto LABEL_77;
        }
      }
      else
      {
        v11 = v29;
      }
      v34 = SslDomainName;
      goto LABEL_65;
    }
LABEL_30:
    v19 = WPP_GLOBAL_Control;
    goto LABEL_31;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (00000001800494F8) ----------------------------------------------------
__int64 __fastcall SslMapCertAtDC(
        struct _UNICODE_STRING *a1,
        void *a2,
        unsigned int a3,
        int a4,
        int a5,
        unsigned __int8 **a6,
        unsigned int *a7,
        struct _MSV1_0_PASSTHROUGH_RESPONSE **a8)
{
  size_t v10; // r13
  int v12; // eax
  unsigned int v13; // ebx
  CCipherMill *v14; // rcx
  __int64 v15; // rdx
  __int64 v16; // r9
  int v17; // r14d
  PVOID *p_ProtocolReturnBuffer; // rdi
  ULONG v19; // esi
  unsigned __int64 v20; // rcx
  unsigned __int64 v21; // rax
  void *v22; // rsp
  _DWORD *v23; // rax
  char *v24; // rbx
  void *v25; // rdx
  unsigned __int64 v26; // rcx
  int v27; // eax
  __int64 v28; // r14
  size_t v29; // rdi
  void *v30; // rax
  unsigned __int8 *v31; // rsi
  int v32; // eax
  void *v33; // rdi
  struct _MSV1_0_PASSTHROUGH_RESPONSE *v34; // rcx
  __int64 v35; // [rsp+0h] [rbp-40h] BYREF
  PVOID ProtocolReturnBuffer; // [rsp+40h] [rbp+0h] BYREF
  void *Src; // [rsp+48h] [rbp+8h] BYREF
  int v38; // [rsp+50h] [rbp+10h] BYREF
  int ProtocolStatus; // [rsp+54h] [rbp+14h] BYREF
  unsigned int v40; // [rsp+58h] [rbp+18h] BYREF
  void *v41; // [rsp+60h] [rbp+20h] BYREF
  ULONG ReturnBufferLength; // [rsp+68h] [rbp+28h] BYREF

  ProtocolReturnBuffer = 0i64;
  v41 = 0i64;
  v10 = a3;
  Src = a2;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 58i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
  if ( (unsigned int)v10 > 0x4000 )
    return 2148074278i64;
  if ( a4 && !a5 )
  {
    v38 = 1;
    v12 = LsaIIsDomainWithinForest(a1, &v38, 0i64, &v41, 0i64, 0i64, 0i64);
    v13 = v12;
    if ( v12 < 0 )
    {
      v14 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        goto LABEL_56;
      v15 = 59i64;
      v16 = (unsigned int)v12;
      goto LABEL_12;
    }
    if ( !v38 )
    {
      v13 = -2146893039;
      v14 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        goto LABEL_56;
      v15 = 60i64;
      v16 = 2148074257i64;
      goto LABEL_12;
    }
  }
  v17 = (v10 + 3) & 0xFFFFFFFC;
  p_ProtocolReturnBuffer = 0i64;
  v19 = ((SslLegacyPackageName.Length + 3 + a1->Length) & 0xFFFFFFFC) + v17 + 64;
  if ( !v19 )
    goto LABEL_25;
  if ( v19 > (unsigned __int64)g_ulMaxStackAllocSize )
    goto LABEL_25;
  v20 = v19 + g_ulAdditionalProbeSize + 8;
  if ( v20 < v19 || !(unsigned int)VerifyStackAvailable(v20) )
    goto LABEL_25;
  v21 = v19 + 8 + 15i64;
  if ( v21 <= v19 + 8 )
    v21 = 0xFFFFFFFFFFFFFF0i64;
  v22 = alloca(v21 & 0xFFFFFFFFFFFFFFF0ui64);
  p_ProtocolReturnBuffer = &ProtocolReturnBuffer;
  if ( &v35 == (__int64 *)-64i64
    || (LODWORD(ProtocolReturnBuffer) = 1801679955, (p_ProtocolReturnBuffer = &Src) == 0i64) )
  {
LABEL_25:
    if ( v19 + 8 >= v19 )
    {
      v23 = (_DWORD *)((__int64 (__fastcall *)(_QWORD))g_pfnAllocate)(v19 + 8);
      if ( !v23 )
      {
LABEL_29:
        v13 = -2146893056;
        goto LABEL_56;
      }
      *v23 = 1885431112;
      p_ProtocolReturnBuffer = (PVOID *)(v23 + 2);
    }
    if ( !p_ProtocolReturnBuffer )
      goto LABEL_29;
  }
  *(_DWORD *)p_ProtocolReturnBuffer = 7;
  *(struct _UNICODE_STRING *)(p_ProtocolReturnBuffer + 1) = *a1;
  p_ProtocolReturnBuffer[2] = p_ProtocolReturnBuffer + 8;
  memcpy_0(p_ProtocolReturnBuffer + 8, a1->Buffer, a1->Length);
  v24 = (char *)p_ProtocolReturnBuffer + a1->Length + 64;
  *(struct _UNICODE_STRING *)(p_ProtocolReturnBuffer + 3) = SslLegacyPackageName;
  p_ProtocolReturnBuffer[4] = v24;
  memcpy_0(v24, SslLegacyPackageName.Buffer, SslLegacyPackageName.Length);
  v25 = Src;
  v26 = (unsigned __int64)&v24[SslLegacyPackageName.Length + 3];
  *((_DWORD *)p_ProtocolReturnBuffer + 10) = v17;
  v26 &= 0xFFFFFFFFFFFFFFFCui64;
  p_ProtocolReturnBuffer[6] = (PVOID)v26;
  memcpy_0((void *)v26, v25, v10);
  v13 = LsaCallAuthenticationPackage(
          SslLogonHandle,
          SslMsvPackageId,
          p_ProtocolReturnBuffer,
          v19,
          &ProtocolReturnBuffer,
          &ReturnBufferLength,
          &ProtocolStatus);
  if ( *((_DWORD *)p_ProtocolReturnBuffer - 2) == 1885431112 )
    ((void (*)(void))g_pfnFree)();
  if ( (v13 & 0x80000000) == 0 )
  {
    v27 = ProtocolStatus;
    if ( ProtocolStatus < 0 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      {
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          62i64,
          &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
          (unsigned int)ProtocolStatus);
        v27 = ProtocolStatus;
      }
      v13 = v27;
      goto LABEL_56;
    }
    v28 = *((_QWORD *)ProtocolReturnBuffer + 2);
    v40 = *(_DWORD *)(v28 + 12);
    v29 = v40;
    v30 = MIDL_user_allocate(v40);
    Src = v30;
    v31 = (unsigned __int8 *)v30;
    if ( !v30 )
    {
      v13 = -1073741801;
      goto LABEL_56;
    }
    memcpy_0(v30, (const void *)(v28 + *(unsigned int *)(v28 + 8)), v29);
    if ( !a5 )
    {
      v32 = SslCheckPacForSidFiltering(v41, (unsigned __int8 **)&Src, &v40);
      v13 = v32;
      if ( v32 < 0 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
        {
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            63i64,
            &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
            (unsigned int)v32);
        }
        v33 = Src;
LABEL_54:
        if ( v33 )
          (*(void (__fastcall **)(void *))(LsaTable + 48))(v33);
        goto LABEL_56;
      }
      v31 = (unsigned __int8 *)Src;
      LODWORD(v29) = v40;
    }
    v34 = (struct _MSV1_0_PASSTHROUGH_RESPONSE *)ProtocolReturnBuffer;
    *a6 = v31;
    *a7 = v29;
    v33 = 0i64;
    ProtocolReturnBuffer = 0i64;
    *a8 = v34;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 64i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, v13);
    v13 = 0;
    goto LABEL_54;
  }
  ProtocolReturnBuffer = 0i64;
  v14 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) == 0 )
    goto LABEL_56;
  v15 = 61i64;
  v16 = v13;
LABEL_12:
  WPP_SF_D(*((_QWORD *)v14 + 2), v15, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, v16);
LABEL_56:
  if ( v41 )
    (*(void (**)(void))(LsaTable + 48))();
  if ( ProtocolReturnBuffer )
    (*(void (**)(void))(LsaTable + 184))();
  return v13;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180092620: using guessed type __int64 LsaTable;
// 180098240: using guessed type __int64 __fastcall LsaIIsDomainWithinForest(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800499FC) ----------------------------------------------------
__int64 __fastcall SslMapCertToUserPac(
        struct _SSL_CERT_LOGON_REQ *a1,
        unsigned int a2,
        unsigned __int8 **a3,
        unsigned int *a4,
        unsigned __int16 **a5)
{
  unsigned __int64 v7; // rbp
  unsigned int v9; // ebx
  int v10; // r12d
  __int64 v11; // rcx
  DWORD v12; // r8d
  PCCERT_CONTEXT CertificateContext; // r15
  int v14; // eax
  CCipherMill *v15; // rcx
  __int64 v16; // rdx
  CCipherMill *v17; // r10
  int v18; // edx
  int v19; // eax
  __int16 v20; // cx
  int v21; // eax
  __int64 v22; // rsi
  __int64 v23; // rcx
  unsigned int v24; // edx
  int v25; // eax
  int v26; // eax

  v7 = a2;
  v9 = -1073741715;
  v10 = -1073741275;
  *a5 = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 19i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
  if ( (unsigned int)(v7 - 32) > 0xFFE0 )
    return 3221225485i64;
  if ( *((_DWORD *)a1 + 1) > (unsigned int)v7 )
    return 3221225485i64;
  v11 = *((unsigned int *)a1 + 2);
  if ( (unsigned int)v11 > (unsigned int)v7 )
    return 3221225485i64;
  v12 = *((_DWORD *)a1 + 3);
  if ( v12 > 0x10000 || v12 + (unsigned int)v11 > (unsigned int)v7 )
    return 3221225485i64;
  CertificateContext = CertCreateCertificateContext(1u, (const BYTE *)a1 + v11, v12);
  if ( CertificateContext )
  {
    if ( (*((_BYTE *)a1 + 16) & 0x10) != 0 && (g_dwCertMappingMethods & 4) != 0 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
      }
      v14 = SslTryUpn(CertificateContext, a3, a4, a5);
      v9 = v14;
      if ( v14 >= 0 || *a5 )
      {
        v20 = 16;
        goto LABEL_37;
      }
      if ( v14 == -1073740943 )
      {
        v15 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
          || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) == 0 )
        {
          goto LABEL_77;
        }
        v16 = 21i64;
        goto LABEL_21;
      }
      v17 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) == 0 )
      {
LABEL_26:
        v18 = *((_DWORD *)a1 + 4);
        if ( (v18 & 0x20) != 0 && (g_dwCertMappingMethods & 1) != 0 )
        {
          if ( v17 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)v17 + 7) & 0x100) != 0 )
            WPP_SF_(*((_QWORD *)v17 + 2), 23i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
          v19 = SslTryCompoundName(CertificateContext, a3, a4, a5);
          v9 = v19;
          if ( v19 >= 0 || *a5 )
          {
            v20 = 8;
            goto LABEL_37;
          }
          if ( v19 == -1073740943 )
          {
            v15 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) == 0 )
            {
              goto LABEL_77;
            }
            v16 = 24i64;
            goto LABEL_21;
          }
          v17 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
          {
            WPP_SF_D(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              25i64,
              &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
              (unsigned int)v19);
            v17 = WPP_GLOBAL_Control;
          }
          v18 = *((_DWORD *)a1 + 4);
          v10 = v9;
        }
        if ( (v18 & 0x40) == 0 || (g_dwCertMappingMethods & 2) == 0 )
          goto LABEL_62;
        if ( v17 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)v17 + 7) & 0x100) != 0 )
        {
          WPP_SF_(*((_QWORD *)v17 + 2), 26i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
          v18 = *((_DWORD *)a1 + 4);
        }
        if ( (v18 & 0x80u) != 0 )
        {
          v21 = *((_DWORD *)a1 + 5);
          if ( v21 )
          {
            if ( 8 * (unsigned __int64)(unsigned int)(v21 - 1) + 32 > v7 )
            {
              v9 = -1073741811;
              goto LABEL_77;
            }
            v22 = 0i64;
            while ( 1 )
            {
              v23 = *((unsigned int *)a1 + 2 * v22 + 6);
              v24 = *((_DWORD *)a1 + 2 * v22 + 7);
              if ( (unsigned int)v23 > (unsigned int)v7 || v24 > 0x10000 || v24 + (unsigned int)v23 > (unsigned int)v7 )
                return 3221225485i64;
              v25 = SslTryIssuer((unsigned __int8 *)a1 + v23, v24, a3, a4, a5);
              v9 = v25;
              if ( v25 >= 0 || *a5 )
                goto LABEL_69;
              if ( v25 == -1073740943 )
              {
                v15 = WPP_GLOBAL_Control;
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
                {
                  v16 = 27i64;
                  goto LABEL_21;
                }
                goto LABEL_77;
              }
              v22 = (unsigned int)(v22 + 1);
              if ( (unsigned int)v22 >= *((_DWORD *)a1 + 5) )
                goto LABEL_59;
            }
          }
        }
        v26 = SslTryIssuer(
                CertificateContext->pCertInfo->Issuer.pbData,
                CertificateContext->pCertInfo->Issuer.cbData,
                a3,
                a4,
                a5);
        v9 = v26;
        if ( v26 < 0 && !*a5 )
        {
          if ( v26 == -1073740943 )
          {
            v15 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) == 0 )
            {
              goto LABEL_77;
            }
            v16 = 28i64;
LABEL_21:
            WPP_SF_D(*((_QWORD *)v15 + 2), v16, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, 3221226353i64);
LABEL_77:
            CertFreeCertificateContext(CertificateContext);
            goto LABEL_78;
          }
LABEL_59:
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
          {
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 29i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, v9);
          }
LABEL_62:
          if ( v9 == -1073741771 || v10 == -1073741771 )
          {
            v9 = -2146892985;
          }
          else if ( v9 != -1073741801 )
          {
            v9 = -1073741715;
          }
          goto LABEL_77;
        }
LABEL_69:
        v20 = 4;
LABEL_37:
        CSchannelTelemetryContext::LogRCMPUsage(v20);
        goto LABEL_77;
      }
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        22i64,
        &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
        (unsigned int)v14);
    }
    v17 = WPP_GLOBAL_Control;
    goto LABEL_26;
  }
  v9 = -1073741801;
LABEL_78:
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 30i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, v9);
  return v9;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180049EF4) ----------------------------------------------------
__int64 __fastcall SslMapEncodedCredential(
        void **a1,
        unsigned int *a2,
        void *a3,
        unsigned int a4,
        void **a5,
        unsigned int *a6,
        int *a7)
{
  const CERT_CONTEXT *CertificateContext; // r15
  void *v9; // rsi
  void **v11; // r14
  int v12; // ebx
  unsigned int *v13; // r12
  BYTE *v14; // rax
  BYTE *v15; // r13
  int v16; // eax
  CCipherMill *v17; // rcx
  __int64 v18; // rdx
  void **v19; // rcx
  void *v20; // r8
  int LastError; // eax
  __int64 v22; // rdx
  __int64 v23; // r8
  int v24; // eax
  int *v25; // rdi
  __int64 v26; // r9
  unsigned int v27; // edi
  int v28; // eax
  void *v30; // [rsp+40h] [rbp-30h] BYREF
  HANDLE hObject; // [rsp+48h] [rbp-28h]
  int v32[4]; // [rsp+50h] [rbp-20h] BYREF
  const CERT_CONTEXT *v33; // [rsp+60h] [rbp-10h]
  int v34; // [rsp+68h] [rbp-8h]
  int v35; // [rsp+6Ch] [rbp-4h]
  void *v36; // [rsp+B0h] [rbp+40h] BYREF
  unsigned int v37; // [rsp+C0h] [rbp+50h] BYREF
  int v38; // [rsp+C4h] [rbp+54h]

  v38 = HIDWORD(a3);
  CertificateContext = 0i64;
  v32[3] = 0;
  v35 = 0;
  v9 = 0i64;
  v30 = 0i64;
  v37 = 0;
  v36 = 0i64;
  hObject = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 65i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
  v11 = a5;
  if ( !a5 || (v13 = a6, *a5 = 0i64, *v13 = 0, a4 < 0x28) || a2[1] != 40 )
  {
    v12 = -1073741811;
    goto LABEL_47;
  }
  v14 = (BYTE *)SPExternalAlloc(a2[4]);
  v15 = v14;
  if ( !v14 )
  {
    v12 = -1073741801;
    goto LABEL_47;
  }
  v16 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, BYTE *, _QWORD))(LsaTable + 80))(
          0i64,
          a2[4],
          v14,
          *((_QWORD *)a2 + 3));
  v12 = v16;
  if ( v16 < 0 )
  {
    v17 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) == 0 )
      goto LABEL_41;
    v18 = 66i64;
    goto LABEL_15;
  }
  CertificateContext = CertCreateCertificateContext(a2[3], v15, a2[4]);
  if ( !CertificateContext )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      LastError = GetLastError();
      WPP_SF_l(*((_QWORD *)WPP_GLOBAL_Control + 2), v22, v23, LastError);
    }
    v12 = -1073741811;
    goto LABEL_41;
  }
  v32[2] = a2[2];
  v24 = a2[8];
  v25 = a7;
  v34 = v24;
  v32[0] = 6;
  v32[1] = 32;
  v33 = CertificateContext;
  v12 = SslMapExternalCredential(v19, v32, v20, 0x20u, &v30, &v37, a7);
  if ( v12 < 0 )
  {
LABEL_40:
    v9 = v30;
    goto LABEL_41;
  }
  v26 = (unsigned int)*v25;
  if ( (int)v26 < 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 68i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, v26);
    goto LABEL_40;
  }
  v9 = v30;
  hObject = (HANDLE)*((_QWORD *)v30 + 1);
  v16 = (*(__int64 (**)(void))(LsaTable + 440))();
  v12 = v16;
  if ( v16 < 0 )
  {
    v17 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) == 0 )
      goto LABEL_41;
    v18 = 69i64;
    goto LABEL_15;
  }
  v27 = v37;
  v16 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, void **))(LsaTable + 56))(0i64, v37, &v36);
  v12 = v16;
  if ( v16 >= 0 )
  {
    v28 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, void *, void *))(LsaTable + 72))(0i64, v27, v36, v9);
    v12 = v28;
    if ( v28 >= 0 )
    {
      *v11 = v36;
      *v13 = v27;
    }
    else
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      {
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          71i64,
          &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
          (unsigned int)v28);
      }
      (*(void (__fastcall **)(_QWORD, void *))(LsaTable + 64))(0i64, v36);
    }
    goto LABEL_41;
  }
  v17 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
  {
    v18 = 70i64;
LABEL_15:
    WPP_SF_D(*((_QWORD *)v17 + 2), v18, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, (unsigned int)v16);
  }
LABEL_41:
  SPExternalFree(v15);
  if ( hObject )
    CloseHandle(hObject);
  if ( v9 )
    VirtualFree(v9, 0i64, 0x8000u);
  if ( CertificateContext )
    CertFreeCertificateContext(CertificateContext);
LABEL_47:
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
    WPP_SF_D(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      72i64,
      &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
      (unsigned int)v12);
  return (unsigned int)v12;
}
// 18004A072: variable 'v22' is possibly undefined
// 18004A072: variable 'v23' is possibly undefined
// 18004A0C1: variable 'v19' is possibly undefined
// 18004A0C1: variable 'v20' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004A314) ----------------------------------------------------
__int64 __fastcall SslMapExternalCredential(
        void **a1,
        _DWORD *a2,
        void *a3,
        unsigned int a4,
        void **a5,
        unsigned int *a6,
        int *a7)
{
  void **v9; // rdi
  unsigned int v10; // ebx
  struct _CERT_CONTEXT *v11; // rdx
  int v12; // r8d
  unsigned int v13; // ecx
  int v14; // eax
  _DWORD *v15; // rax
  HANDLE v16; // rcx
  void *v18; // [rsp+30h] [rbp-38h]
  HANDLE hObject; // [rsp+80h] [rbp+18h] BYREF
  enum _NT_PRODUCT_TYPE ProductType; // [rsp+88h] [rbp+20h] BYREF

  hObject = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 73i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
  v9 = a5;
  if ( a5 )
    *a5 = 0i64;
  if ( a4 < 0x20 || a2[1] != 32 )
  {
    v10 = -1073741811;
    goto LABEL_18;
  }
  if ( RtlGetNtProductType(&ProductType) )
  {
    v11 = (struct _CERT_CONTEXT *)*((_QWORD *)a2 + 2);
    v12 = a2[2];
    v13 = a2[6] | 0x80000000;
    if ( ProductType == NtProductLanManNt )
      v14 = SslLocalMapCredential(0i64, 0i64, v12, 0i64, v13, v11, 0i64, 0i64, 0i64, (unsigned __int64 *)&hObject);
    else
      v14 = SslRemoteMapCredential(0i64, v11, v12, 0i64, v13, v11, v18, 0i64, 0i64, (unsigned __int64 *)&hObject);
    if ( v14 < 0 )
    {
      *a6 = 0;
      v10 = 0;
      *a7 = v14;
      goto LABEL_18;
    }
    v15 = VirtualAlloc(0i64, 0x18ui64, 0x1000u, 4u);
    if ( v15 )
    {
      v15[1] = 24;
      *v15 = 6;
      v16 = hObject;
      v15[4] = 0;
      *((_QWORD *)v15 + 1) = v16;
      *v9 = v15;
      LODWORD(v16) = v15[1];
      hObject = 0i64;
      *a6 = (unsigned int)v16;
      *a7 = 0;
      v10 = 0;
      goto LABEL_20;
    }
  }
  v10 = -1073741801;
LABEL_18:
  if ( hObject )
    CloseHandle(hObject);
LABEL_20:
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 74i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, v10);
  return v10;
}
// 18004A40F: variable 'v18' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018004A500) ----------------------------------------------------
_BOOL8 __fastcall SslRelocateToken(__int64 a1, unsigned __int64 *a2)
{
  return (*(int (__fastcall **)(__int64, unsigned __int64 *))(LsaTable + 104))(a1, a2) >= 0;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004A534) ----------------------------------------------------
__int64 __fastcall SslRemoteMapCredential(
        struct CCredentialGroup *a1,
        void *a2,
        int a3,
        __int64 a4,
        unsigned int a5,
        struct _CERT_CONTEXT *a6,
        void *a7,
        unsigned __int16 *a8,
        unsigned __int16 *a9,
        unsigned __int64 *a10)
{
  __int64 result; // rax
  PCCERT_CHAIN_CONTEXT v14; // rdi
  CCipherMill *v15; // rcx
  const wchar_t *v16; // rbx
  int v17; // ebx
  CCipherMill *v18; // rcx
  __int64 v19; // rdx
  CCipherMill *v20; // rcx
  __int64 v21; // rdx
  int v22; // edi
  PCCERT_CHAIN_CONTEXT v23; // rdi
  PCERT_SIMPLE_CHAIN *rgpChain; // rcx
  int v25; // eax
  HLOCAL hMem; // [rsp+50h] [rbp-30h] BYREF
  unsigned __int8 *v27; // [rsp+58h] [rbp-28h] BYREF
  PCCERT_CHAIN_CONTEXT pChainContext; // [rsp+60h] [rbp-20h] BYREF
  struct _LUID v29; // [rsp+68h] [rbp-18h] BYREF
  struct _UNICODE_STRING v30; // [rsp+70h] [rbp-10h] BYREF
  int v31; // [rsp+B8h] [rbp+38h] BYREF
  int v32; // [rsp+BCh] [rbp+3Ch]
  unsigned int v33; // [rsp+C0h] [rbp+40h] BYREF

  v32 = HIDWORD(a2);
  v31 = 0;
  v29 = 0i64;
  pChainContext = 0i64;
  hMem = 0i64;
  v27 = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
    WPP_SF_q(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x4Bu,
      (__int64)&WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
      0i64);
  if ( a3 != 1 )
    return 2148074253i64;
  result = MapperVerifyClientChain(a1, a6, a4, a5, &v33, &v31, &pChainContext);
  if ( !(_DWORD)result )
  {
    v14 = pChainContext;
    if ( (v33 & 0x10) != 0 )
    {
      if ( (g_dwCertMappingMethods & 8) != 0 )
      {
        v15 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 76i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
          v15 = WPP_GLOBAL_Control;
        }
        v16 = a9;
        if ( a1 && v15 != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)v15 + 28) & 4) != 0 )
          {
            WPP_SF_S(*((_QWORD *)v15 + 2), 0x4Du, (__int64)&WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, a8);
            v15 = WPP_GLOBAL_Control;
          }
          if ( v15 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v15 + 28) & 4) != 0 )
            WPP_SF_S(*((_QWORD *)v15 + 2), 0x4Eu, (__int64)&WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, v16);
        }
        v17 = SslTryS4U2Self(v14, &a7, 0, a8, v16);
        if ( v17 >= 0 )
        {
          v18 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) == 0 )
          {
            goto LABEL_24;
          }
          v19 = 79i64;
LABEL_23:
          WPP_SF_(*((_QWORD *)v18 + 2), v19, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
LABEL_24:
          CertFreeCertificateChain(v14);
          *a10 = (unsigned __int64)a7;
          return (unsigned int)v17;
        }
        v20 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
        {
          v21 = 80i64;
LABEL_39:
          WPP_SF_D(*((_QWORD *)v20 + 2), v21, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, (unsigned int)v17);
          goto LABEL_40;
        }
        goto LABEL_41;
      }
    }
    else if ( (v33 & 0x60) != 0 && (g_dwCertMappingMethods & 0x10) != 0 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 81i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
      }
      v17 = SslTryS4U2Self(v14, &a7, 4, a8, a9);
      if ( v17 >= 0 )
      {
        v18 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
          || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) == 0 )
        {
          goto LABEL_24;
        }
        v19 = 82i64;
        goto LABEL_23;
      }
      v20 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      {
        v21 = 83i64;
        goto LABEL_39;
      }
LABEL_41:
      if ( v33 )
      {
        CSchannelTelemetryContext::LogRCMPUsage(2);
        v17 = SslBuildCertLogonRequest(v14, v33, (struct _SSL_CERT_LOGON_REQ **)&hMem, (unsigned int *)&a6);
        CertFreeCertificateChain(v14);
        if ( v17 >= 0 )
        {
          v17 = SslMapCertAtDC(
                  &SslDomainName,
                  hMem,
                  (unsigned int)a6,
                  0,
                  0,
                  &v27,
                  &v33,
                  (struct _MSV1_0_PASSTHROUGH_RESPONSE **)&pChainContext);
          LocalFree(hMem);
          if ( v17 >= 0 )
          {
            v23 = pChainContext;
            rgpChain = pChainContext->rgpChain;
            if ( (unsigned int)(*((_DWORD *)rgpChain + 1) - *((_DWORD *)rgpChain + 3)) <= 0x20
              || *((_DWORD *)rgpChain + 6) >= 0x10000u )
            {
              v30 = SslDomainName;
            }
            else
            {
              v30.Length = *((_WORD *)rgpChain + 12);
              v30.MaximumLength = v30.Length;
              v30.Buffer = (PWSTR)((char *)rgpChain + *((unsigned int *)rgpChain + 5));
            }
            v25 = SslCreateTokenFromPac(v27, v33, &v30, &v29, &a7);
            v17 = v25;
            if ( v25 < 0 )
            {
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
              {
                WPP_SF_D(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  87i64,
                  &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
                  (unsigned int)v25);
              }
              LogCertMappingFailureEvent(*((_DWORD *)a1 + 53), (const unsigned __int16 *)a1 + 108, v17);
            }
            else
            {
              *a10 = (unsigned __int64)a7;
            }
            (*(void (__fastcall **)(PCCERT_CHAIN_CONTEXT))(LsaTable + 184))(v23);
            (*(void (__fastcall **)(unsigned __int8 *))(LsaTable + 48))(v27);
          }
          else
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
            {
              WPP_SF_D(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                86i64,
                &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
                (unsigned int)v17);
            }
            v22 = v31;
            (*(void (__fastcall **)(_QWORD, _QWORD, void *, void *, _QWORD, _QWORD, int, struct _TOKEN_SOURCE *, struct _LUID *))(LsaTable + 168))(
              (unsigned int)v17,
              (unsigned int)v31,
              &SslNullString,
              &SslNullString,
              0i64,
              0i64,
              3,
              &SslTokenSource,
              &v29);
            LogCertMappingFailureEvent(*((_DWORD *)a1 + 53), (const unsigned __int16 *)a1 + 108, v17);
            if ( v22 < 0 && (v17 & 0x1FFF0000) != 589824 )
              return (unsigned int)v22;
          }
        }
        else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
               && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
        {
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            85i64,
            &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
            (unsigned int)v17);
        }
      }
      else
      {
        if ( v20 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)v20 + 7) & 0x100) != 0 )
          WPP_SF_(*((_QWORD *)v20 + 2), 84i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids);
        v17 = -2146893017;
        if ( v31 < 0 )
          v17 = v31;
        CertFreeCertificateChain(v14);
      }
      return (unsigned int)v17;
    }
LABEL_40:
    v20 = WPP_GLOBAL_Control;
    goto LABEL_41;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004AA94) ----------------------------------------------------
__int64 __fastcall SslTryCompoundName(
        const struct _CERT_CONTEXT *a1,
        unsigned __int8 **a2,
        unsigned int *a3,
        unsigned __int16 **a4)
{
  PCERT_INFO pCertInfo; // rdx
  int v7; // r12d
  DWORD dwCertEncodingType; // ecx
  unsigned int v10; // edi
  DWORD v11; // eax
  DWORD v12; // esi
  unsigned int v13; // ecx
  __int16 v14; // r8
  struct _UNICODE_STRING *Buffer; // rdx
  bool v16; // zf
  USHORT MaximumLength; // r8
  unsigned __int64 v18; // rcx
  int v19; // eax
  unsigned __int64 v20; // rax
  void *v21; // rsp
  WCHAR *v22; // rax
  PWSTR v23; // rbx
  __int64 v24; // rcx
  int v25; // eax
  __int64 v26; // rdx
  int v27; // ebx
  PWSTR v28; // rbx
  unsigned int *csz; // [rsp+20h] [rbp-20h]
  struct _UNICODE_STRING v31; // [rsp+40h] [rbp+0h] BYREF
  unsigned int v32; // [rsp+50h] [rbp+10h] BYREF
  unsigned int v33[4]; // [rsp+58h] [rbp+18h] BYREF
  struct _UNICODE_STRING v34; // [rsp+68h] [rbp+28h] BYREF
  struct _UNICODE_STRING v35; // [rsp+78h] [rbp+38h] BYREF

  pCertInfo = a1->pCertInfo;
  *a4 = 0i64;
  v7 = (int)a3;
  dwCertEncodingType = a1->dwCertEncodingType;
  v35 = 0i64;
  v34 = 0i64;
  *(_OWORD *)v33 = 0i64;
  v10 = CertNameToStrW(dwCertEncodingType, &pCertInfo->Issuer, 0x28000003u, 0i64, 0);
  v11 = CertNameToStrW(a1->dwCertEncodingType, &a1->pCertInfo->Subject, 0x28000003u, 0i64, 0);
  v12 = v11;
  if ( v10 )
  {
    if ( v11 )
    {
      v13 = v11 + v10;
      if ( v11 + v10 >= v10 && v13 <= 0xFFFF && (unsigned __int16)v13 <= 0x7FF9u )
      {
        v31.Buffer = 0i64;
        v14 = v11 + v10 + 6;
        Buffer = 0i64;
        v16 = 2 * v14 == 0;
        MaximumLength = 2 * v14;
        v31.MaximumLength = MaximumLength;
        if ( !v16 && MaximumLength <= (unsigned __int64)g_ulMaxStackAllocSize )
        {
          v18 = MaximumLength + g_ulAdditionalProbeSize + 8;
          if ( v18 >= MaximumLength )
          {
            v19 = VerifyStackAvailable(v18);
            MaximumLength = v31.MaximumLength;
            if ( v19 )
            {
              v20 = (unsigned int)v31.MaximumLength + 8 + 15i64;
              if ( v20 <= (unsigned int)v31.MaximumLength + 8 )
                v20 = 0xFFFFFFFFFFFFFF0i64;
              v21 = alloca(v20 & 0xFFFFFFFFFFFFFFF0ui64);
              Buffer = &v31;
              v31.Buffer = (PWSTR)&v31;
            }
            else
            {
              Buffer = (struct _UNICODE_STRING *)v31.Buffer;
            }
            if ( Buffer )
            {
              *(_DWORD *)&Buffer->Length = 1801679955;
              v16 = v31.Buffer == (PWSTR)-8i64;
              Buffer = (struct _UNICODE_STRING *)(v31.Buffer + 4);
              v31.Buffer += 4;
              if ( !v16 )
              {
LABEL_21:
                *(_QWORD *)&Buffer->Length = 0x3E0049003Ci64;
                v23 = v31.Buffer;
                v24 = CertNameToStrW(a1->dwCertEncodingType, &a1->pCertInfo->Issuer, 0x28000003u, v31.Buffer + 3, v10)
                    - 1;
                *(_QWORD *)&v23[v24 + 3] = 0x3E0053003Ci64;
                CertNameToStrW(a1->dwCertEncodingType, &a1->pCertInfo->Subject, 0x28000003u, &v23[v24 + 6], v12);
                ConvertNameString(&v31);
                LODWORD(csz) = v7;
                v25 = (*(__int64 (__fastcall **)(struct _UNICODE_STRING *, __int64, struct _UNICODE_STRING *, unsigned __int8 **))(LsaTable + 296))(
                        &v31,
                        1i64,
                        &SslNamePrefix,
                        a2);
                v27 = v25;
                if ( LOWORD(v33[0]) )
                {
                  LOBYTE(v26) = v25 >= 0;
                  csz = v33;
                  (*(void (__fastcall **)(__int64, __int64, struct _UNICODE_STRING *, struct _UNICODE_STRING *))(LsaTable + 312))(
                    678i64,
                    v26,
                    &SslPackageName,
                    &v31);
                  (*(void (__fastcall **)(_QWORD))(LsaTable + 48))(*(_QWORD *)&v33[2]);
                }
                if ( v27 == -1073741275 )
                {
                  v27 = SslCrackSingleName(0xFFFFFFF5, v26, &v31, &SslNamePrefix, (unsigned int)csz, &v35, &v34, &v32);
                  if ( v27 >= 0 )
                  {
                    if ( v32 )
                    {
                      v28 = v34.Buffer;
                    }
                    else
                    {
                      v28 = 0i64;
                      *a4 = v34.Buffer;
                    }
                    if ( v35.Buffer )
                      (*(void (**)(void))(LsaTable + 48))();
                    if ( v28 )
                      (*(void (__fastcall **)(PWSTR))(LsaTable + 48))(v28);
                    v27 = -1073741275;
                  }
                }
                if ( v31.Buffer )
                {
                  if ( *((_DWORD *)v31.Buffer - 2) == 1885431112 )
                    ((void (*)(void))g_pfnFree)();
                }
                return (unsigned int)v27;
              }
              MaximumLength = v31.MaximumLength;
            }
          }
        }
        if ( (unsigned int)MaximumLength + 8 >= MaximumLength )
        {
          v22 = (WCHAR *)((__int64 (__fastcall *)(__int64, struct _UNICODE_STRING *))g_pfnAllocate)(
                           MaximumLength + 8i64,
                           Buffer);
          v31.Buffer = v22;
          if ( !v22 )
            return (unsigned int)-1073741801;
          *(_DWORD *)v22 = 1885431112;
          Buffer = (struct _UNICODE_STRING *)(v31.Buffer + 4);
          v31.Buffer += 4;
        }
        if ( Buffer )
          goto LABEL_21;
        return (unsigned int)-1073741801;
      }
    }
  }
  return 3221225495i64;
}
// 18004AD56: variable 'v26' is possibly undefined
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004AE90) ----------------------------------------------------
__int64 __fastcall SslTryIssuer(
        unsigned __int8 *a1,
        unsigned int a2,
        unsigned __int8 **a3,
        unsigned int *a4,
        unsigned __int16 **a5)
{
  int v5; // r14d
  int v6; // r12d
  DWORD v11; // ebx
  struct _UNICODE_STRING *Buffer; // rdx
  USHORT MaximumLength; // r8
  unsigned __int64 v14; // rcx
  int v15; // eax
  unsigned __int64 v16; // rax
  void *v17; // rsp
  bool v18; // zf
  WCHAR *v19; // rax
  int v20; // eax
  __int64 v21; // rdx
  int v22; // ebx
  PWSTR v23; // rbx
  unsigned int *csz; // [rsp+20h] [rbp-20h]
  struct _UNICODE_STRING v25; // [rsp+40h] [rbp+0h] BYREF
  unsigned int v26; // [rsp+50h] [rbp+10h] BYREF
  unsigned int v27[4]; // [rsp+58h] [rbp+18h] BYREF
  struct _CRYPTOAPI_BLOB pName; // [rsp+68h] [rbp+28h] BYREF
  struct _UNICODE_STRING v29; // [rsp+78h] [rbp+38h] BYREF
  HLOCAL hMem[2]; // [rsp+88h] [rbp+48h] BYREF

  v5 = 0;
  v6 = (int)a4;
  *a5 = 0i64;
  *(_OWORD *)hMem = 0i64;
  v29 = 0i64;
  *(_OWORD *)v27 = 0i64;
  if ( (unsigned int)SPFindIssuerInCache(a1, a2) )
    return 3221226021i64;
  pName.pbData = a1;
  pName.cbData = a2;
  v11 = CertNameToStrW(1u, &pName, 0x28000003u, 0i64, 0);
  if ( v11 <= 0xFFFF && (unsigned __int16)v11 <= 0x7FFCu )
  {
    Buffer = 0i64;
    MaximumLength = 2 * (v11 + 3);
    v25.Buffer = 0i64;
    v25.MaximumLength = MaximumLength;
    if ( MaximumLength )
    {
      if ( MaximumLength <= (unsigned __int64)g_ulMaxStackAllocSize )
      {
        v14 = MaximumLength + g_ulAdditionalProbeSize + 8;
        if ( v14 >= MaximumLength )
        {
          v15 = VerifyStackAvailable(v14);
          MaximumLength = v25.MaximumLength;
          if ( v15 )
          {
            v16 = (unsigned int)v25.MaximumLength + 8 + 15i64;
            if ( v16 <= (unsigned int)v25.MaximumLength + 8 )
              v16 = 0xFFFFFFFFFFFFFF0i64;
            v17 = alloca(v16 & 0xFFFFFFFFFFFFFFF0ui64);
            Buffer = &v25;
            v25.Buffer = (PWSTR)&v25;
          }
          else
          {
            Buffer = (struct _UNICODE_STRING *)v25.Buffer;
          }
          if ( Buffer )
          {
            *(_DWORD *)&Buffer->Length = 1801679955;
            v18 = v25.Buffer == (PWSTR)-8i64;
            Buffer = (struct _UNICODE_STRING *)(v25.Buffer + 4);
            v25.Buffer += 4;
            if ( !v18 )
            {
LABEL_20:
              *(_QWORD *)&Buffer->Length = 0x3E0049003Ci64;
              CertNameToStrW(1u, &pName, 0x28000003u, v25.Buffer + 3, v11);
              ConvertNameString(&v25);
              LODWORD(csz) = v6;
              v20 = (*(__int64 (__fastcall **)(struct _UNICODE_STRING *, __int64, struct _UNICODE_STRING *, unsigned __int8 **))(LsaTable + 296))(
                      &v25,
                      1i64,
                      &SslNamePrefix,
                      a3);
              v22 = v20;
              if ( LOWORD(v27[0]) )
              {
                LOBYTE(v21) = v20 >= 0;
                csz = v27;
                (*(void (__fastcall **)(__int64, __int64, struct _UNICODE_STRING *, struct _UNICODE_STRING *))(LsaTable + 312))(
                  678i64,
                  v21,
                  &SslPackageName,
                  &v25);
                (*(void (__fastcall **)(_QWORD))(LsaTable + 48))(*(_QWORD *)&v27[2]);
              }
              if ( v22 == -1073741275 )
              {
                v22 = SslCrackSingleName(
                        0xFFFFFFF5,
                        v21,
                        &v25,
                        &SslNamePrefix,
                        (unsigned int)csz,
                        (struct _UNICODE_STRING *)hMem,
                        &v29,
                        &v26);
                if ( v22 < 0 )
                  goto LABEL_32;
                if ( v26 )
                {
                  v23 = v29.Buffer;
                }
                else
                {
                  v23 = 0i64;
                  *a5 = v29.Buffer;
                  v5 = 1;
                }
                if ( hMem[1] )
                  LocalFree(hMem[1]);
                if ( v23 )
                  LocalFree(v23);
                v22 = -1073741275;
                if ( !v5 )
LABEL_32:
                  SPAddIssuerToCache(a1, a2);
              }
              if ( v25.Buffer )
              {
                if ( *((_DWORD *)v25.Buffer - 2) == 1885431112 )
                  ((void (*)(void))g_pfnFree)();
              }
              return (unsigned int)v22;
            }
            MaximumLength = v25.MaximumLength;
          }
        }
      }
    }
    if ( (unsigned int)MaximumLength + 8 >= MaximumLength )
    {
      v19 = (WCHAR *)((__int64 (__fastcall *)(__int64))g_pfnAllocate)(MaximumLength + 8i64);
      v25.Buffer = v19;
      if ( !v19 )
        return (unsigned int)-1073741801;
      *(_DWORD *)v19 = 1885431112;
      Buffer = (struct _UNICODE_STRING *)(v25.Buffer + 4);
      v25.Buffer += 4;
    }
    if ( Buffer )
      goto LABEL_20;
    return (unsigned int)-1073741801;
  }
  return 3221225485i64;
}
// 18004B0F3: variable 'v21' is possibly undefined
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004B228) ----------------------------------------------------
__int64 __fastcall SslTryS4U2Self(
        const struct _CERT_CHAIN_CONTEXT *a1,
        void **a2,
        int a3,
        const unsigned __int16 *a4,
        const unsigned __int16 *Src)
{
  bool v7; // zf
  _DWORD *AuthenticationInformation; // rdi
  unsigned __int16 v9; // si
  unsigned __int16 v10; // r15
  __int64 result; // rax
  PCCERT_CONTEXT pCertContext; // r14
  NTSTATUS v13; // ebx
  ULONG AuthenticationInformationLength; // r14d
  __int64 v15; // rcx
  __int64 v16; // rsi
  _DWORD *v17; // rax
  char *v18; // rbx
  __int64 v19; // rdx
  PHANDLE v20; // rsi
  HLOCAL hMem; // [rsp+70h] [rbp-51h] BYREF
  int v22; // [rsp+78h] [rbp-49h] BYREF
  int SubStatus; // [rsp+7Ch] [rbp-45h] BYREF
  PVOID Buffer; // [rsp+80h] [rbp-41h] BYREF
  ULONG ProfileBufferLength; // [rsp+88h] [rbp-39h] BYREF
  PCCERT_CONTEXT v26; // [rsp+90h] [rbp-31h]
  PHANDLE Token; // [rsp+98h] [rbp-29h]
  struct _LUID LogonId; // [rsp+A0h] [rbp-21h] BYREF
  struct _QUOTA_LIMITS Quotas; // [rsp+A8h] [rbp-19h] BYREF

  Token = a2;
  v7 = g_SslS4U2SelfInitialized == 0;
  AuthenticationInformation = 0i64;
  *a2 = 0i64;
  v9 = 0;
  hMem = 0i64;
  v10 = 0;
  Buffer = 0i64;
  LogonId = 0i64;
  if ( v7 )
    return 3221225659i64;
  pCertContext = (*(*a1->rgpChain)->rgpElement)->pCertContext;
  v26 = pCertContext;
  result = SslGetNameFromCertificate(pCertContext, (unsigned __int16 **)&hMem, &v22);
  if ( (int)result >= 0 )
  {
    if ( v22 )
    {
      v13 = -1073741275;
LABEL_35:
      if ( Buffer )
        LsaFreeReturnBuffer(Buffer);
      if ( AuthenticationInformation )
        LocalFree(AuthenticationInformation);
      if ( hMem )
        LocalFree(hMem);
      return (unsigned int)v13;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      WPP_SF_S(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xAu,
        (__int64)&WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
        (const wchar_t *)hMem);
    AuthenticationInformationLength = pCertContext->cbCertEncoded + 56;
    if ( AuthenticationInformationLength >= 0x38 )
    {
      v15 = -1i64;
      if ( a4 )
      {
        v16 = -1i64;
        do
          ++v16;
        while ( a4[v16] );
        v9 = 2 * (v16 + 1);
        if ( AuthenticationInformationLength + v9 < AuthenticationInformationLength )
          goto LABEL_34;
        AuthenticationInformationLength += v9;
      }
      if ( !Src )
        goto LABEL_19;
      do
        ++v15;
      while ( Src[v15] );
      v10 = 2 * (v15 + 1);
      if ( AuthenticationInformationLength + v10 >= AuthenticationInformationLength )
      {
        AuthenticationInformationLength += v10;
LABEL_19:
        v17 = LocalAlloc(0x40u, AuthenticationInformationLength);
        AuthenticationInformation = v17;
        if ( v17 )
        {
          *v17 = 14;
          v17[1] = a3 | 2;
          v18 = (char *)(v17 + 14);
          if ( a4 )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
            {
              WPP_SF_S(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0xBu,
                (__int64)&WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
                a4);
            }
            *((_WORD *)AuthenticationInformation + 4) = v9 - 2;
            *((_QWORD *)AuthenticationInformation + 2) = v18;
            *((_WORD *)AuthenticationInformation + 5) = v9;
            memcpy_0(v18, a4, v9);
            v18 += *((unsigned __int16 *)AuthenticationInformation + 5);
          }
          if ( Src )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
            {
              WPP_SF_S(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0xCu,
                (__int64)&WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
                Src);
            }
            *((_WORD *)AuthenticationInformation + 12) = v10 - 2;
            *((_QWORD *)AuthenticationInformation + 4) = v18;
            *((_WORD *)AuthenticationInformation + 13) = v10;
            memcpy_0(v18, Src, v10);
            v18 += *((unsigned __int16 *)AuthenticationInformation + 13);
          }
          v19 = (__int64)v26;
          AuthenticationInformation[10] = v26->cbCertEncoded;
          *((_QWORD *)AuthenticationInformation + 6) = v18;
          memcpy_0(v18, *(const void **)(v19 + 8), *(unsigned int *)(v19 + 16));
          v20 = Token;
          v13 = LsaLogonUser(
                  SslLogonHandle,
                  (PLSA_STRING)&SslPackageNameA,
                  Network,
                  SslKerberosPackageId,
                  AuthenticationInformation,
                  AuthenticationInformationLength,
                  SslPackageSid,
                  &SslTokenSource,
                  &Buffer,
                  &ProfileBufferLength,
                  &LogonId,
                  Token,
                  &Quotas,
                  &SubStatus);
          if ( v13 >= 0 )
          {
            v13 = SubStatus;
            if ( SubStatus >= 0 )
              v13 = LsaISetTokenDacl(*v20);
          }
        }
        else
        {
          v13 = -1073741801;
        }
        goto LABEL_35;
      }
    }
LABEL_34:
    v13 = -1073741675;
    goto LABEL_35;
  }
  return result;
}
// 180092784: using guessed type int g_SslS4U2SelfInitialized;
// 180098248: using guessed type __int64 __fastcall LsaISetTokenDacl(_QWORD);

//----- (000000018004B59C) ----------------------------------------------------
__int64 __fastcall SslTryUpn(
        const struct _CERT_CONTEXT *a1,
        unsigned __int8 **a2,
        unsigned int *a3,
        unsigned __int16 **a4)
{
  const WCHAR *p_DestinationString; // rdi
  __int64 result; // rax
  int v7; // r13d
  wchar_t *v8; // rsi
  int v9; // ebx
  __int64 v10; // r15
  unsigned __int64 v11; // rbx
  unsigned __int64 v12; // rcx
  __int64 v13; // rax
  void *v14; // rsp
  WCHAR *v15; // rax
  int v16; // ebx
  __int64 (__fastcall *v17)(struct _UNICODE_STRING *, __int64, _QWORD, unsigned __int8 **); // rax
  int v18; // eax
  __int64 v19; // rdx
  void (__fastcall *v20)(__int64, __int64, struct _UNICODE_STRING *, struct _UNICODE_STRING *); // rax
  __int64 (__fastcall *v21)(struct _UNICODE_STRING *, __int64, _QWORD, unsigned __int8 **); // rax
  int v22; // eax
  wchar_t *v23; // rax
  wchar_t *v24; // r13
  int v25; // ebx
  __int64 (__fastcall *v26)(struct _UNICODE_STRING *, _QWORD, _QWORD, unsigned __int8 **); // rax
  wchar_t *v27; // rax
  wchar_t *v28; // r13
  int v29; // ebx
  __int64 (__fastcall *v30)(struct _UNICODE_STRING *, _QWORD, _QWORD, unsigned __int8 **); // rax
  __int64 v31; // rdx
  unsigned int v32; // ecx
  PWSTR Buffer; // rbx
  __int64 v34; // [rsp+0h] [rbp-40h] BYREF
  unsigned int v35[2]; // [rsp+20h] [rbp-20h]
  struct _UNICODE_STRING *v36; // [rsp+28h] [rbp-18h]
  struct _UNICODE_STRING DestinationString; // [rsp+40h] [rbp+0h] BYREF
  wchar_t v38; // [rsp+50h] [rbp+10h]
  int v39; // [rsp+54h] [rbp+14h] BYREF
  unsigned int v40; // [rsp+58h] [rbp+18h] BYREF
  unsigned __int8 **v41; // [rsp+60h] [rbp+20h]
  unsigned int v42[4]; // [rsp+68h] [rbp+28h] BYREF
  struct _UNICODE_STRING lpString; // [rsp+78h] [rbp+38h] BYREF
  unsigned int *v44; // [rsp+88h] [rbp+48h]
  struct _UNICODE_STRING v45; // [rsp+90h] [rbp+50h] BYREF
  unsigned __int16 **v46; // [rsp+A0h] [rbp+60h]
  HLOCAL hMem[2]; // [rsp+A8h] [rbp+68h] BYREF

  v41 = a2;
  *(_DWORD *)&DestinationString.Length = 0;
  v44 = a3;
  DestinationString.Buffer = 0i64;
  *(_QWORD *)&lpString.Length = 0i64;
  *a4 = 0i64;
  *(_OWORD *)hMem = 0i64;
  p_DestinationString = 0i64;
  v46 = a4;
  v45 = 0i64;
  *(_OWORD *)v42 = 0i64;
  result = SslGetNameFromCertificate(a1, (unsigned __int16 **)&lpString, &v39);
  if ( (int)result < 0 )
    return result;
  v7 = v39;
  v8 = *(wchar_t **)&lpString.Length;
  if ( !v39 )
  {
    RtlInitUnicodeString(&DestinationString, *(PCWSTR *)&lpString.Length);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      WPP_SF_S(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xEu,
        (__int64)&WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
        DestinationString.Buffer);
    v21 = *(__int64 (__fastcall **)(struct _UNICODE_STRING *, __int64, _QWORD, unsigned __int8 **))(LsaTable + 296);
    v36 = (struct _UNICODE_STRING *)v42;
    *(_QWORD *)v35 = a3;
    v22 = v21(&DestinationString, 2i64, 0i64, v41);
    v19 = 0i64;
    v16 = v22;
    if ( LOWORD(v42[0]) )
    {
      LOBYTE(v19) = v22 >= 0;
      v20 = *(void (__fastcall **)(__int64, __int64, struct _UNICODE_STRING *, struct _UNICODE_STRING *))(LsaTable + 312);
      goto LABEL_26;
    }
LABEL_27:
    if ( v16 != -1073741275 )
      goto LABEL_60;
    if ( v7 )
    {
      v23 = wcschr(v8, 0x2Eu);
      v24 = v23;
      if ( !v23 )
        goto LABEL_42;
      RtlInitUnicodeString(&lpString, v23 + 1);
      RtlAcquireResourceShared(&SslGlobalLock, 1u);
      v25 = RtlEqualUnicodeString(&lpString, &SslGlobalDnsDomainName, 1u);
      RtlReleaseResource(&SslGlobalLock);
      if ( !v25 )
        goto LABEL_42;
      v38 = v24[1];
      *(_DWORD *)v24 = 36;
      RtlInitUnicodeString(&DestinationString, v8);
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      {
        WPP_SF_S(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xFu,
          (__int64)&WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
          DestinationString.Buffer);
      }
      v26 = *(__int64 (__fastcall **)(struct _UNICODE_STRING *, _QWORD, _QWORD, unsigned __int8 **))(LsaTable + 296);
      v36 = 0i64;
      *(_QWORD *)v35 = v44;
      v16 = v26(&DestinationString, 0i64, 0i64, v41);
      *v24 = 46;
      v24[1] = v38;
    }
    else
    {
      v27 = wcschr(v8, 0x40u);
      v28 = v27;
      if ( !v27 )
        goto LABEL_47;
      RtlInitUnicodeString(&lpString, v27 + 1);
      RtlAcquireResourceShared(&SslGlobalLock, 1u);
      v29 = RtlEqualUnicodeString(&lpString, &SslGlobalDnsDomainName, 1u);
      RtlReleaseResource(&SslGlobalLock);
      if ( !v29 )
        goto LABEL_47;
      *v28 = 0;
      RtlInitUnicodeString(&DestinationString, v8);
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      {
        WPP_SF_S(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x10u,
          (__int64)&WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
          DestinationString.Buffer);
      }
      v30 = *(__int64 (__fastcall **)(struct _UNICODE_STRING *, _QWORD, _QWORD, unsigned __int8 **))(LsaTable + 296);
      v36 = 0i64;
      *(_QWORD *)v35 = v44;
      v16 = v30(&DestinationString, 0i64, 0i64, v41);
      *v28 = 64;
    }
    if ( v16 != -1073741275 )
      goto LABEL_60;
LABEL_42:
    if ( v39 )
    {
      RtlInitUnicodeString(&DestinationString, p_DestinationString);
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      {
        WPP_SF_S(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x11u,
          (__int64)&WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
          DestinationString.Buffer);
      }
      v32 = 10;
LABEL_51:
      v16 = SslCrackSingleName(v32, v31, &DestinationString, 0i64, v35[0], (struct _UNICODE_STRING *)hMem, &v45, &v40);
      if ( v16 >= 0 )
      {
        if ( v40 )
        {
          Buffer = v45.Buffer;
        }
        else
        {
          Buffer = 0i64;
          *v46 = v45.Buffer;
        }
        if ( hMem[1] )
          LocalFree(hMem[1]);
        if ( Buffer )
          LocalFree(Buffer);
        v16 = -1073741275;
      }
      goto LABEL_60;
    }
LABEL_47:
    RtlInitUnicodeString(&DestinationString, v8);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
      WPP_SF_S(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x12u,
        (__int64)&WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
        DestinationString.Buffer);
    v32 = 8;
    goto LABEL_51;
  }
  v9 = lstrlenW(*(LPCWSTR *)&lpString.Length);
  v10 = (unsigned int)(lstrlenW(L"host/") + v9 + 1);
  v11 = 2 * v10;
  if ( 2 * v10 )
  {
    if ( v11 <= g_ulMaxStackAllocSize )
    {
      v12 = v11 + 8 + g_ulAdditionalProbeSize;
      if ( v12 >= v11 )
      {
        if ( (unsigned int)VerifyStackAvailable(v12) )
        {
          v13 = v11 + 23;
          if ( v11 + 23 <= v11 + 8 )
            v13 = 0xFFFFFFFFFFFFFF0i64;
          v14 = alloca(v13 & 0xFFFFFFFFFFFFFFF0ui64);
          p_DestinationString = (const WCHAR *)&DestinationString;
          if ( &v34 != (__int64 *)-64i64 )
          {
            *(_DWORD *)&DestinationString.Length = 1801679955;
            p_DestinationString = (const WCHAR *)&DestinationString.Buffer;
            if ( &DestinationString != (struct _UNICODE_STRING *)-8i64 )
            {
LABEL_16:
              _o_wcscpy_s(p_DestinationString, v10, L"host/");
              _o_wcscat_s(p_DestinationString, v10, v8);
              RtlInitUnicodeString(&DestinationString, p_DestinationString);
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
              {
                WPP_SF_S(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  0xDu,
                  (__int64)&WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids,
                  DestinationString.Buffer);
              }
              v17 = *(__int64 (__fastcall **)(struct _UNICODE_STRING *, __int64, _QWORD, unsigned __int8 **))(LsaTable + 296);
              v36 = (struct _UNICODE_STRING *)v42;
              *(_QWORD *)v35 = v44;
              v18 = v17(&DestinationString, 4i64, 0i64, v41);
              v19 = 0i64;
              v16 = v18;
              if ( LOWORD(v42[0]) )
              {
                LOBYTE(v19) = v18 >= 0;
                v20 = *(void (__fastcall **)(__int64, __int64, struct _UNICODE_STRING *, struct _UNICODE_STRING *))(LsaTable + 312);
LABEL_26:
                LODWORD(v36) = v16;
                *(_QWORD *)v35 = v42;
                v20(678i64, v19, &SslPackageName, &DestinationString);
                (*(void (__fastcall **)(_QWORD))(LsaTable + 48))(*(_QWORD *)&v42[2]);
                goto LABEL_27;
              }
              goto LABEL_27;
            }
          }
        }
      }
    }
  }
  if ( v11 + 8 < v11 )
  {
LABEL_14:
    if ( !p_DestinationString )
      goto LABEL_15;
    goto LABEL_16;
  }
  v15 = (WCHAR *)((__int64 (*)(void))g_pfnAllocate)();
  p_DestinationString = v15;
  if ( v15 )
  {
    *(_DWORD *)v15 = 1885431112;
    p_DestinationString = v15 + 4;
    goto LABEL_14;
  }
LABEL_15:
  v16 = -1073741801;
LABEL_60:
  if ( v8 )
    LocalFree(v8);
  if ( p_DestinationString )
  {
    if ( *((_DWORD *)p_DestinationString - 2) == 1885431112 )
      ((void (*)(void))g_pfnFree)();
  }
  return (unsigned int)v16;
}
// 18004BBCE: variable 'v31' is possibly undefined
// 180080C68: using guessed type __int64 __fastcall _o_wcscat_s(_QWORD, _QWORD, _QWORD);
// 180080C70: using guessed type __int64 __fastcall _o_wcscpy_s(_QWORD, _QWORD, _QWORD);
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004BC9C) ----------------------------------------------------
__int64 __fastcall WPP_SF_l(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v5; // [rsp+38h] [rbp-10h]
  __int64 v6; // [rsp+40h] [rbp-8h]
  int v7; // [rsp+68h] [rbp+20h] BYREF

  v7 = a4;
  return EtwTraceMessage(a1, 43i64, &WPP_dd7b7bddfdb936bf76d1675dae523069_Traceguids, 67i64, &v7, 4i64, 0i64, v5, v6);
}
// 18004BCD1: variable 'v5' is possibly undefined
// 18004BCD1: variable 'v6' is possibly undefined

//----- (000000018004BCEC) ----------------------------------------------------
void __fastcall SslFreeString(struct _UNICODE_STRING *a1)
{
  PWSTR Buffer; // rcx

  if ( a1 )
  {
    Buffer = a1->Buffer;
    if ( Buffer )
    {
      SPExternalFree(Buffer);
      *a1 = 0i64;
    }
  }
}

//----- (000000018004BD20) ----------------------------------------------------
BOOL __stdcall SslEmptyCacheA(LPSTR pszTargetName, DWORD dwFlags)
{
  WCHAR *Buffer; // rcx
  BOOL v6; // ebx
  struct _UNICODE_STRING DestinationString; // [rsp+20h] [rbp-28h] BYREF
  struct _STRING SourceString; // [rsp+30h] [rbp-18h] BYREF

  *(_DWORD *)&DestinationString.Length = 0;
  Buffer = 0i64;
  DestinationString.Buffer = 0i64;
  if ( pszTargetName )
  {
    RtlInitAnsiString(&SourceString, pszTargetName);
    if ( RtlAnsiStringToUnicodeString(&DestinationString, &SourceString, 1u) < 0 )
    {
      SetLastError(0x80090300);
      return 0;
    }
    Buffer = DestinationString.Buffer;
  }
  v6 = SslEmptyCacheW(Buffer, dwFlags);
  if ( DestinationString.Buffer )
    RtlFreeUnicodeString(&DestinationString);
  return v6;
}

//----- (000000018004BDC0) ----------------------------------------------------
BOOL __stdcall SslEmptyCacheW(LPWSTR pszTargetName, DWORD dwFlags)
{
  _QWORD *v3; // rdi
  signed int v4; // ebx
  unsigned int v5; // ebp
  int v6; // eax
  unsigned int v7; // r14d
  char *v8; // rax
  char *v9; // rbx
  __int64 v10; // rax
  void *LsaHandle; // [rsp+40h] [rbp-48h] BYREF
  struct _STRING DestinationString; // [rsp+48h] [rbp-40h] BYREF
  ULONG AuthenticationPackage; // [rsp+A0h] [rbp+18h] BYREF
  int ProtocolStatus; // [rsp+A8h] [rbp+20h] BYREF

  LsaHandle = 0i64;
  v3 = 0i64;
  v4 = LsaConnectUntrusted(&LsaHandle);
  if ( v4 >= 0 )
  {
    RtlInitAnsiString(&DestinationString, "Schannel");
    v4 = LsaLookupAuthenticationPackage(LsaHandle, (PLSA_STRING)&DestinationString, &AuthenticationPackage);
    if ( v4 >= 0 )
    {
      v5 = 40;
      if ( pszTargetName )
      {
        v6 = lstrlenW(pszTargetName);
        v7 = 2 * v6 + 2;
        v5 = 2 * v6 + 42;
        v8 = (char *)SPExternalAlloc(v5);
        v3 = v8;
        if ( !v8 )
          goto LABEL_5;
        v9 = v8 + 40;
        memcpy_0(v8 + 40, pszTargetName, v7);
        v10 = -1i64;
        v3[3] = v9;
        do
          ++v10;
        while ( pszTargetName[v10] );
        *((_WORD *)v3 + 9) = v7;
        *((_WORD *)v3 + 8) = 2 * v10;
      }
      else
      {
        v3 = SPExternalAlloc(0x28u);
        if ( !v3 )
        {
LABEL_5:
          v4 = -2146893056;
          goto LABEL_13;
        }
      }
      *(_DWORD *)v3 = 3;
      *((_DWORD *)v3 + 8) = 3;
      v4 = LsaCallAuthenticationPackage(LsaHandle, AuthenticationPackage, v3, v5, 0i64, 0i64, &ProtocolStatus);
      if ( v4 >= 0 && ProtocolStatus < 0 )
        v4 = ProtocolStatus;
    }
  }
LABEL_13:
  if ( LsaHandle )
    LsaDeregisterLogonProcess(LsaHandle);
  if ( v3 )
    SPExternalFree(v3);
  if ( v4 >= 0 )
    return 1;
  SetLastError(v4);
  return 0;
}

//----- (000000018004BF60) ----------------------------------------------------
__int64 __fastcall SslGetStreamSizes(void **a1, void *a2, void *a3, __int64 a4, void **a5, unsigned int *a6, int *a7)
{
  int v7; // ebx
  void *v9; // [rsp+30h] [rbp-28h] BYREF
  __int64 v10; // [rsp+38h] [rbp-20h] BYREF
  int v11; // [rsp+40h] [rbp-18h]
  int v12; // [rsp+44h] [rbp-14h]

  v9 = 0i64;
  v10 = 0i64;
  *a5 = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_6672ee5dd6af34547aa752f96a369f0c_Traceguids);
  v11 = dword_1800925D4;
  v12 = dword_1800925D8;
  v7 = (*(__int64 (__fastcall **)(_QWORD, __int64, void **))(LsaTable + 56))(0i64, 16i64, &v9);
  if ( v7 >= 0 )
  {
    v7 = (*(__int64 (__fastcall **)(_QWORD, __int64, void *, __int64 *))(LsaTable + 72))(0i64, 16i64, v9, &v10);
    if ( v7 >= 0 )
    {
      *a5 = v9;
      *a6 = 16;
    }
    else
    {
      (*(void (__fastcall **)(_QWORD, void *))(LsaTable + 64))(0i64, v9);
    }
  }
  *a7 = v7;
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 1800925D4: using guessed type int dword_1800925D4;
// 1800925D8: using guessed type int dword_1800925D8;
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004C0AC) ----------------------------------------------------
__int64 __fastcall SslPurgeSessionCache(
        void **a1,
        char *a2,
        unsigned __int64 a3,
        unsigned int a4,
        void **a5,
        unsigned int *a6,
        int *a7)
{
  unsigned __int64 v7; // r14
  int *v8; // rsi
  int v11; // ebx
  int *v12; // rdi
  __int64 v13; // rdx
  unsigned __int64 v14; // rcx
  struct _LUID *v16; // r14
  __int64 v17; // r8
  __int64 v18; // rdx
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // rcx
  unsigned __int64 v22; // rcx
  signed __int64 v23; // rcx
  void *v24; // rsp
  void *v25; // rsp
  _DWORD *v26; // rax
  unsigned int v27; // eax
  unsigned __int16 *v28; // rcx
  __int64 v29; // [rsp+0h] [rbp-30h] BYREF
  int v30; // [rsp+30h] [rbp+0h] BYREF
  __int64 v31; // [rsp+34h] [rbp+4h] BYREF
  int v32; // [rsp+3Ch] [rbp+Ch]
  __int16 v33; // [rsp+40h] [rbp+10h]
  __int16 v34; // [rsp+42h] [rbp+12h]
  int v35; // [rsp+44h] [rbp+14h]
  __int64 v36; // [rsp+48h] [rbp+18h]
  int v37; // [rsp+50h] [rbp+20h]
  int v38; // [rsp+54h] [rbp+24h]
  char v39[8]; // [rsp+58h] [rbp+28h] BYREF
  unsigned int v40; // [rsp+60h] [rbp+30h]
  char v41; // [rsp+68h] [rbp+38h]
  char v42[24]; // [rsp+78h] [rbp+48h] BYREF

  v7 = a4;
  v8 = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_6672ee5dd6af34547aa752f96a369f0c_Traceguids);
  if ( !(*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v42) )
    goto LABEL_5;
  if ( (v42[8] & 0x40) != 0 )
  {
    if ( (unsigned int)v7 >= 0x18 )
    {
      v12 = &v30;
      v30 = *(_DWORD *)a2;
      v31 = *(_QWORD *)(a2 + 4);
      v37 = *((_DWORD *)a2 + 5);
      v33 = *((_WORD *)a2 + 6);
      v34 = *((_WORD *)a2 + 7);
      v36 = *((unsigned int *)a2 + 4);
      v32 = 0;
      v35 = 0;
      v38 = 0;
      goto LABEL_11;
    }
LABEL_14:
    v11 = -1073741811;
    goto LABEL_15;
  }
  if ( (unsigned int)v7 < 0x28 )
    goto LABEL_14;
  v12 = (int *)a2;
LABEL_11:
  v13 = *((unsigned __int16 *)v12 + 8);
  if ( (v13 & 1) != 0 )
    goto LABEL_14;
  v14 = *((_QWORD *)v12 + 3);
  if ( v14 )
  {
    if ( (_WORD)v13 )
    {
      if ( v14 >= a3 )
        v14 -= a3;
      if ( !v14 || v14 > v7 || v14 + v13 > v7 || v14 < 0x28 || (v14 & 1) != 0 )
        goto LABEL_14;
      *((_WORD *)v12 + 9) = v13;
      *((_QWORD *)v12 + 3) = &a2[v14];
    }
    else
    {
      *((_QWORD *)v12 + 3) = 0i64;
    }
  }
  else if ( (_WORD)v13 )
  {
    goto LABEL_14;
  }
  v11 = (*(__int64 (__fastcall **)(char *))(LsaTable + 128))(v39);
  if ( v11 < 0 )
    goto LABEL_15;
  v16 = (struct _LUID *)(v12 + 1);
  if ( !*(_QWORD *)(v12 + 1) && (v12[8] & 0x30000) == 0 )
    goto LABEL_32;
  if ( !v41 )
  {
    v11 = -1073741727;
    goto LABEL_15;
  }
  if ( !*(_QWORD *)(v12 + 1) )
LABEL_32:
    v16 = (struct _LUID *)v39;
  v17 = *((_QWORD *)v12 + 3);
  if ( v17 )
  {
    v18 = *((unsigned __int16 *)v12 + 8);
    if ( (_WORD)v18 )
    {
      v19 = *((unsigned __int16 *)v12 + 8);
      if ( *(_WORD *)(v17 + 2 * ((unsigned __int64)(v18 - 2) >> 1)) )
      {
        if ( (unsigned __int16)v18 > 0xFFFDu )
          goto LABEL_14;
        v20 = v18 + 2;
        if ( *((unsigned __int16 *)v12 + 9) >= v20 )
        {
          *(_WORD *)(v17 + 2 * (v19 >> 1)) = 0;
          *((_WORD *)v12 + 8) += 2;
          goto LABEL_51;
        }
        if ( v20 <= g_ulMaxStackAllocSize )
        {
          v21 = g_ulAdditionalProbeSize + 10 + v19;
          if ( v21 >= v20 )
          {
            if ( (unsigned int)VerifyStackAvailable(v21) )
            {
              v22 = *((unsigned __int16 *)v12 + 8) + 25i64;
              if ( v22 <= (unsigned __int64)*((unsigned __int16 *)v12 + 8) + 10 )
                v22 = 0xFFFFFFFFFFFFFF0i64;
              v23 = v22 & 0xFFFFFFFFFFFFFFF0ui64;
              v24 = alloca(v23);
              v25 = alloca(v23);
              v8 = &v30;
              if ( &v29 != (__int64 *)-48i64 )
              {
                v30 = 1801679955;
                v8 = (int *)&v31 + 1;
                if ( &v31 != (__int64 *)-4i64 )
                {
LABEL_50:
                  _o_wcsncpy_s(
                    v8,
                    ((unsigned __int64)*((unsigned __int16 *)v12 + 8) + 2) >> 1,
                    *((_QWORD *)v12 + 3),
                    (unsigned __int64)*((unsigned __int16 *)v12 + 8) >> 1);
                  *((_WORD *)v8 + ((unsigned __int64)*((unsigned __int16 *)v12 + 8) >> 1)) = 0;
                  goto LABEL_51;
                }
              }
            }
          }
        }
        if ( (unsigned __int64)*((unsigned __int16 *)v12 + 8) + 10 >= (unsigned __int64)*((unsigned __int16 *)v12 + 8)
                                                                    + 2 )
        {
          v26 = (_DWORD *)((__int64 (*)(void))g_pfnAllocate)();
          if ( !v26 )
            goto LABEL_5;
          *v26 = 1885431112;
          v8 = v26 + 2;
        }
        if ( v8 )
          goto LABEL_50;
LABEL_5:
        v11 = -1073741595;
        goto LABEL_15;
      }
    }
  }
LABEL_51:
  v27 = v12[8];
  if ( (v27 & 0xFFF7FFFF) != 0 )
  {
    v28 = (unsigned __int16 *)v8;
    if ( !v8 )
      v28 = (unsigned __int16 *)*((_QWORD *)v12 + 3);
    v11 = CSessionCacheManager::PurgeCacheEntries(CSessionCacheManager::m_pSessionCacheManager, v27, v16, v40, v28);
    v27 = v12[8];
    if ( (v27 & 2) != 0 )
    {
      SPPurgeIssuerCache();
      v27 = v12[8];
    }
  }
  if ( (v27 & 0x80000) != 0 )
  {
    CertFreeCertificateChainEngine(0i64);
    CertFreeCertificateChainEngine((HCERTCHAINENGINE)1);
  }
  *a5 = 0i64;
  *a6 = 0;
  if ( v8 && *(v8 - 2) == 1885431112 )
    ((void (*)(void))g_pfnFree)();
LABEL_15:
  *a7 = v11;
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080C78: using guessed type __int64 __fastcall _o_wcsncpy_s(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180092620: using guessed type __int64 LsaTable;
// 18004C0AC: using guessed type char var_58[8];

//----- (000000018004C488) ----------------------------------------------------
__int64 __fastcall SslSessionCacheInfo(
        void **a1,
        char *a2,
        unsigned __int64 a3,
        unsigned int a4,
        void **a5,
        unsigned int *a6,
        int *a7)
{
  void **v7; // r15
  unsigned int *v8; // r12
  __int64 v10; // rax
  unsigned __int64 v12; // rsi
  int Info; // ebx
  int *v14; // rbx
  unsigned __int64 v15; // rcx
  __int64 v16; // rdx
  struct _SSL_SESSION_CACHE_INFO_RESPONSE *v18; // rax
  struct _SSL_SESSION_CACHE_INFO_RESPONSE *v19; // rdi
  char v20[24]; // [rsp+30h] [rbp-40h] BYREF
  int v21; // [rsp+48h] [rbp-28h] BYREF
  __int64 v22; // [rsp+4Ch] [rbp-24h]
  int v23; // [rsp+54h] [rbp-1Ch]
  __int16 v24; // [rsp+58h] [rbp-18h]
  __int16 v25; // [rsp+5Ah] [rbp-16h]
  int v26; // [rsp+5Ch] [rbp-14h]
  __int64 v27; // [rsp+60h] [rbp-10h]
  int v28; // [rsp+68h] [rbp-8h]
  int v29; // [rsp+6Ch] [rbp-4h]
  void **v30; // [rsp+A0h] [rbp+30h] BYREF

  v30 = a1;
  v7 = a5;
  v8 = a6;
  v10 = LsaTable;
  v12 = a4;
  *a5 = 0i64;
  *v8 = 0;
  if ( !(*(unsigned __int8 (__fastcall **)(char *))(v10 + 192))(v20) )
  {
    Info = -1073741595;
    goto LABEL_11;
  }
  if ( (v20[8] & 0x40) != 0 )
  {
    if ( (unsigned int)v12 >= 0x18 )
    {
      v14 = &v21;
      v21 = *(_DWORD *)a2;
      v22 = *(_QWORD *)(a2 + 4);
      v28 = *((_DWORD *)a2 + 5);
      v24 = *((_WORD *)a2 + 6);
      v25 = *((_WORD *)a2 + 7);
      v27 = *((unsigned int *)a2 + 4);
      v23 = 0;
      v26 = 0;
      v29 = 0;
      goto LABEL_8;
    }
LABEL_10:
    Info = -1073741811;
    goto LABEL_11;
  }
  if ( (unsigned int)v12 < 0x28 )
    goto LABEL_10;
  v14 = (int *)a2;
LABEL_8:
  v15 = *((_QWORD *)v14 + 3);
  v16 = *((unsigned __int16 *)v14 + 8);
  if ( v15 )
  {
    if ( (_WORD)v16 )
    {
      if ( v15 >= a3 )
        v15 -= a3;
      if ( !v15 )
        goto LABEL_10;
      if ( v15 > v12 )
        goto LABEL_10;
      if ( v15 + v16 > v12 )
        goto LABEL_10;
      if ( v15 < 0x28 )
        goto LABEL_10;
      if ( (v15 & 1) != 0 )
        goto LABEL_10;
      *((_WORD *)v14 + 9) = v16;
      *((_QWORD *)v14 + 3) = &a2[v15];
      if ( (v16 & 1) != 0 )
        goto LABEL_10;
    }
    else
    {
      *((_QWORD *)v14 + 3) = 0i64;
    }
  }
  else if ( (_WORD)v16 )
  {
    goto LABEL_10;
  }
  v18 = (struct _SSL_SESSION_CACHE_INFO_RESPONSE *)SPExternalAlloc(0x1Cu);
  v19 = v18;
  if ( v18 )
  {
    Info = CSessionCacheManager::CacheGetInfo(CSessionCacheManager::m_pSessionCacheManager, v14[8], v18);
    if ( Info >= 0 )
    {
      Info = (*(__int64 (__fastcall **)(_QWORD, __int64, void ***))(LsaTable + 56))(0i64, 28i64, &v30);
      if ( Info >= 0 )
      {
        Info = (*(__int64 (__fastcall **)(_QWORD, __int64, void **, struct _SSL_SESSION_CACHE_INFO_RESPONSE *))(LsaTable + 72))(
                 0i64,
                 28i64,
                 v30,
                 v19);
        if ( Info >= 0 )
        {
          *v7 = v30;
          *v8 = 28;
        }
        else
        {
          (*(void (__fastcall **)(_QWORD, void **))(LsaTable + 64))(0i64, v30);
        }
      }
    }
    SPExternalFree(v19);
  }
  else
  {
    Info = -1073741801;
  }
LABEL_11:
  *a7 = Info;
  return 0i64;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004C6A0) ----------------------------------------------------
__int64 __fastcall SpCallPackage(
        __int64 a1,
        _DWORD *a2,
        unsigned __int64 a3,
        unsigned int a4,
        void **a5,
        unsigned int *a6,
        int *a7)
{
  int v11; // esi
  int v12; // ebp
  void *v13; // rdx
  void **v14; // rcx
  void *v15; // r8
  __int64 v16; // r9
  CCipherMill *v17; // rcx
  __int64 v18; // rdx
  __int64 v19; // [rsp+40h] [rbp-28h] BYREF
  int v20; // [rsp+48h] [rbp-20h]

  if ( (*(unsigned __int8 (__fastcall **)(__int64 *))(LsaTable + 192))(&v19) )
  {
    v11 = v20 & 0x10;
    v12 = v20 & 0x200;
    if ( !a2 || a4 < 4 )
      return 3221225485i64;
    if ( (unsigned int)SchannelInit(0) )
    {
      switch ( *a2 )
      {
        case 2:
          return SslDoClientRequest(v14, a2, (size_t)v15, a4, a5, a6, a7);
        case 6:
          if ( v11 )
            return SslMapExternalCredential(v14, a2, v15, a4, a5, a6, a7);
          break;
        case 7:
          if ( !v11 )
          {
            if ( v12 )
              return SslMapEncodedCredential(v14, a2, v15, a4, a5, a6, a7);
            else
              return 3221225569i64;
          }
          break;
        case 4:
          return SslSessionCacheInfo(v14, (char *)a2, a3, a4, a5, a6, a7);
        case 3:
          return SslPurgeSessionCache(v14, (char *)a2, a3, a4, a5, a6, a7);
        case 8:
          return SslGetStreamSizes(v14, v13, v15, v16, a5, a6, a7);
      }
      v17 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074242i64;
      v18 = 14i64;
    }
    else
    {
      v17 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074242i64;
      v18 = 13i64;
    }
    WPP_SF_(*((_QWORD *)v17 + 2), v18, &WPP_6672ee5dd6af34547aa752f96a369f0c_Traceguids);
    return 2148074242i64;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_6672ee5dd6af34547aa752f96a369f0c_Traceguids);
  return 3221225701i64;
}
// 18004C7B6: variable 'v14' is possibly undefined
// 18004C7B6: variable 'v15' is possibly undefined
// 18004C8FD: variable 'v13' is possibly undefined
// 18004C8FD: variable 'v16' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004C960) ----------------------------------------------------
__int64 __fastcall SpCallPackagePassthrough(
        __int64 a1,
        _DWORD *a2,
        unsigned __int64 a3,
        unsigned int a4,
        void **a5,
        unsigned int *a6,
        int *a7)
{
  if ( !a2 || a4 < 4 )
    return 3221225485i64;
  if ( *a2 == 2 )
    return SpCallPackage(a1, a2, a3, a4, a5, a6, a7);
  return 2148074242i64;
}

//----- (000000018004C990) ----------------------------------------------------
__int64 __fastcall SpCallPackageUntrusted(
        __int64 a1,
        char *a2,
        unsigned __int64 a3,
        unsigned int a4,
        void **a5,
        unsigned int *a6,
        int *a7)
{
  int v10; // ebx
  void *v11; // r8
  __int64 v12; // r9
  int v14; // ebx
  int v15; // ebx

  if ( !a2 || a4 < 4 )
    return 3221225485i64;
  v10 = *(_DWORD *)a2;
  if ( !(unsigned int)SchannelInit(0) )
    return 2148074242i64;
  *a5 = 0i64;
  *a6 = 0;
  v14 = v10 - 3;
  if ( !v14 )
    return SslPurgeSessionCache(a5, a2, a3, a4, a5, a6, a7);
  v15 = v14 - 1;
  if ( !v15 )
    return SslSessionCacheInfo(a5, a2, a3, a4, a5, a6, a7);
  if ( v15 != 4 )
    return 2148074242i64;
  return SslGetStreamSizes(a5, a6, v11, v12, a5, a6, a7);
}
// 18004CA0E: variable 'v11' is possibly undefined
// 18004CA0E: variable 'v12' is possibly undefined

//----- (000000018004CA84) ----------------------------------------------------
__int64 __fastcall SslCheckPacForSidFiltering(void *a1, unsigned __int8 **a2, unsigned int *a3)
{
  struct _PACTYPE *v3; // rbx
  unsigned __int8 *v4; // rdi
  unsigned int v5; // r14d
  int v6; // esi
  CCipherMill *v10; // rcx
  unsigned __int64 i; // rdx
  __int64 v12; // rdx
  unsigned int v13; // edx
  struct _PACTYPE *v14; // r8
  __int64 v15; // rcx
  int v17; // eax
  void *v18; // r8
  int updated; // eax
  __int64 v20; // rdx
  int *v21; // rcx
  int v22; // eax
  __int128 v23; // [rsp+30h] [rbp-10h] BYREF
  struct _PACTYPE *v24; // [rsp+88h] [rbp+48h] BYREF
  struct _NETLOGON_VALIDATION_SAM_INFO3 *v25; // [rsp+90h] [rbp+50h] BYREF

  v3 = (struct _PACTYPE *)*a2;
  v4 = 0i64;
  v5 = *a3;
  v6 = 0;
  v25 = 0i64;
  v24 = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_30aed76c620c331e1998e7b09f72e2d4_Traceguids);
  if ( !(unsigned int)PAC_UnMarshal((unsigned __int64)v3, v5) )
  {
    v10 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_30aed76c620c331e1998e7b09f72e2d4_Traceguids);
      v10 = WPP_GLOBAL_Control;
    }
    v6 = -2146893047;
    goto LABEL_32;
  }
  v23 = 0i64;
  if ( v3 )
  {
    for ( i = (unsigned __int64)v3 + 8; i < (unsigned __int64)v3 + 16 * *(unsigned int *)v3 + 8; i += 16i64 )
    {
      if ( *(_DWORD *)i == 1 )
      {
        if ( !i )
          break;
        v17 = PAC_UnmarshallValidationInfo(&v25, *(unsigned __int8 **)(i + 8), *(_DWORD *)(i + 4));
        v6 = v17;
        if ( v17 >= 0 )
        {
          v6 = SslFilterSids(a1, v25);
          if ( v6 >= 0 )
          {
            updated = PAC_InitAndUpdateGroupsEx(v25, (struct _SAMPR_PSID_ARRAY *)&v23, v18, v3, &v24);
            v6 = updated;
            if ( updated >= 0 )
            {
              v4 = (unsigned __int8 *)v24;
              v5 = 0;
              if ( v24 )
              {
                v5 = (16 * *(_DWORD *)v24 + 15) & 0xFFFFFFF8;
                if ( *(_DWORD *)v24 )
                {
                  v20 = *(unsigned int *)v24;
                  v21 = (int *)((char *)v24 + 12);
                  do
                  {
                    v22 = *v21;
                    v21 += 4;
                    v5 += (v22 + 7) & 0xFFFFFFF8;
                    --v20;
                  }
                  while ( v20 );
                }
              }
              v3 = v24;
              goto LABEL_18;
            }
            v10 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              WPP_SF_D(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                15i64,
                &WPP_30aed76c620c331e1998e7b09f72e2d4_Traceguids,
                (unsigned int)updated);
              v4 = (unsigned __int8 *)v24;
              goto LABEL_18;
            }
            v4 = (unsigned __int8 *)v24;
          }
          else
          {
            v10 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v12 = 14i64;
              goto LABEL_17;
            }
          }
        }
        else
        {
          v10 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            WPP_SF_D(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              13i64,
              &WPP_30aed76c620c331e1998e7b09f72e2d4_Traceguids,
              (unsigned int)v17);
            goto LABEL_18;
          }
        }
        goto LABEL_19;
      }
    }
  }
  v10 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
  {
    v12 = 12i64;
LABEL_17:
    WPP_SF_(*((_QWORD *)v10 + 2), v12, &WPP_30aed76c620c331e1998e7b09f72e2d4_Traceguids);
LABEL_18:
    v10 = WPP_GLOBAL_Control;
  }
LABEL_19:
  if ( v3 )
  {
    v13 = 0;
    if ( *(_DWORD *)v3 )
    {
      v14 = (struct _PACTYPE *)((char *)v3 + v5);
      while ( 1 )
      {
        v15 = 2 * (v13 + 1i64);
        if ( *((_QWORD *)v3 + 2 * v13 + 2) > (unsigned __int64)v14 || v3 > v14 )
          break;
        ++v13;
        *((_QWORD *)v3 + v15) = (unsigned int)(*((_DWORD *)v3 + 2 * v15) - (_DWORD)v3);
        if ( v13 >= *(_DWORD *)v3 )
        {
          v10 = WPP_GLOBAL_Control;
          goto LABEL_26;
        }
      }
      v6 = -2146893047;
    }
    else
    {
LABEL_26:
      if ( !v4 )
        goto LABEL_32;
      if ( *a2 == v4 )
        goto LABEL_30;
      (*(void (__fastcall **)(_QWORD))(LsaTable + 48))(*a2);
      *a2 = v4;
      v4 = 0i64;
      *a3 = v5;
    }
    v10 = WPP_GLOBAL_Control;
  }
LABEL_30:
  if ( v4 )
  {
    (*(void (__fastcall **)(unsigned __int8 *))(LsaTable + 48))(v4);
    v10 = WPP_GLOBAL_Control;
  }
LABEL_32:
  if ( v25 )
  {
    (*(void (__fastcall **)(struct _NETLOGON_VALIDATION_SAM_INFO3 *))(LsaTable + 48))(v25);
    v10 = WPP_GLOBAL_Control;
  }
  if ( v10 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v10 + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)v10 + 2), 16i64, &WPP_30aed76c620c331e1998e7b09f72e2d4_Traceguids, (unsigned int)v6);
  return (unsigned int)v6;
}
// 18004CD56: variable 'v18' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004CE04) ----------------------------------------------------
__int64 __fastcall SslFilterSids(void *a1, struct _NETLOGON_VALIDATION_SAM_INFO3 *a2)
{
  __int64 v2; // r8
  __int64 v3; // rdx
  int v4; // ebx
  CCipherMill *v5; // rcx
  __int64 v6; // rdx

  if ( a1 )
  {
    v3 = 2i64;
    v2 = 2i64;
  }
  else
  {
    v2 = 0i64;
    v3 = 0i64;
  }
  v4 = LsaIFilterSids(0i64, v3, v2);
  if ( v4 >= 0 )
  {
    v5 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      v6 = 18i64;
      goto LABEL_11;
    }
  }
  else
  {
    v5 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      v6 = 17i64;
LABEL_11:
      WPP_SF_D(*((_QWORD *)v5 + 2), v6, &WPP_30aed76c620c331e1998e7b09f72e2d4_Traceguids, (unsigned int)v4);
    }
  }
  return (unsigned int)v4;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098230: using guessed type __int64 __fastcall LsaIFilterSids(_QWORD, _QWORD, _QWORD);

//----- (000000018004CEC0) ----------------------------------------------------
void *__stdcall MIDL_user_allocate(size_t size)
{
  if ( (((_DWORD)size + 7) & 0xFFFFFFF8) >= size )
    return (void *)(*(__int64 (__fastcall **)(_QWORD))(LsaTable + 40))(((_DWORD)size + 7) & 0xFFFFFFF8);
  else
    return 0i64;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004CF00) ----------------------------------------------------
void __stdcall MIDL_user_free(void *a1)
{
  (*(void (__fastcall **)(void *))(LsaTable + 48))(a1);
}
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018004CF24) ----------------------------------------------------
void UnloadSslRegOptions(void)
{
  __int64 v0; // rsi
  void ***v1; // rdi
  void **v2; // rbx
  void *v3; // rcx
  HKEY v4; // rcx
  void *v5; // rcx
  _QWORD v6[3]; // [rsp+20h] [rbp-28h] BYREF

  v0 = 3i64;
  v6[0] = &g_BaseSslRegOptions;
  v1 = (void ***)v6;
  v6[1] = &g_FipsRegOptions;
  v6[2] = &g_UserMappingRegOptions;
  do
  {
    v2 = *v1;
    v3 = **v1;
    if ( v3 )
    {
      RtlDeregisterWait(v3);
      *v2 = 0i64;
    }
    v4 = (HKEY)v2[2];
    if ( v4 )
    {
      RegCloseKey(v4);
      v2[2] = 0i64;
    }
    v5 = v2[1];
    if ( v5 )
    {
      CloseHandle(v5);
      v2[1] = 0i64;
    }
    ++v1;
    --v0;
  }
  while ( v0 );
  if ( g_hBcryptWait )
  {
    RtlDeregisterWait(g_hBcryptWait);
    g_hBcryptWait = 0i64;
  }
  if ( g_hBcryptEvent )
  {
    BCryptUnregisterConfigChangeNotify(g_hBcryptEvent);
    g_hBcryptEvent = 0i64;
  }
  if ( g_pszDomainList )
  {
    LocalFree(g_pszDomainList);
    g_pszDomainList = 0i64;
  }
  if ( g_pszOcspReadDirectory )
  {
    LocalFree(g_pszOcspReadDirectory);
    g_pszOcspReadDirectory = 0i64;
  }
}

//----- (000000018004D070) ----------------------------------------------------
void __fastcall WatchBcryptEvent(PVOID a1)
{
  CCipherMill *v1; // rcx

  if ( !_InterlockedCompareExchange(&g_fBuildingCiphers, 1, 0) )
  {
    Sleep(0x64u);
    _InterlockedExchange(&g_fBuildingCiphers, 0);
    CCipherMill::BuildCipherMill(v1);
    NotifyWNFConfigChangeEvent(WNF_SCH_BCRYPT_RELOAD);
  }
}
// 18004D09E: variable 'v1' is possibly undefined
// 180092F44: using guessed type int g_fBuildingCiphers;

//----- (000000018004D0C0) ----------------------------------------------------
CSessionCacheManager *__fastcall CSessionCacheManager::`vector deleting destructor'(
        CSessionCacheManager *this,
        char a2)
{
  *(_QWORD *)this = &IAllocate::`vftable';
  if ( (a2 & 1) != 0 )
  {
    if ( (a2 & 4) != 0 )
      __global_delete(this, 0x68ui64);
    else
      SPExternalFree(this);
  }
  return this;
}
// 18007C298: using guessed type void *IAllocate::`vftable';

//----- (000000018004D0F8) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void *__fastcall sub_18004D0F8(CSslBasicAllocator *a1, unsigned int a2)
{
  char v2; // cf
  char v3; // of

  if ( !v3 )
    JUMPOUT(0x18004D11Bi64);
  if ( !v2 )
    JUMPOUT(0x18004D085i64);
  return CSslBasicAllocator::`vector deleting destructor'(a1, a2);
}
// 18004D0FB: positive sp value 8 has been found
// 18004D0F8: control flows out of bounds to 18004D11B
// 18004D0FC: control flows out of bounds to 18004D085
// 18004D0F8: variable 'v3' is possibly undefined
// 18004D0FC: variable 'v2' is possibly undefined

//----- (000000018004D100) ----------------------------------------------------
CSslBasicAllocator *__fastcall CSslBasicAllocator::`vector deleting destructor'(CSslBasicAllocator *this, char a2)
{
  *(_QWORD *)this = &IAllocate::`vftable';
  if ( (a2 & 1) != 0 )
  {
    if ( (a2 & 4) != 0 )
      __global_delete(this, 8ui64);
    else
      SPExternalFree(this);
  }
  return this;
}
// 18007C298: using guessed type void *IAllocate::`vftable';

//----- (000000018004D140) ----------------------------------------------------
CSslCredManager *__fastcall CSslCredManager::`vector deleting destructor'(CSslCredManager *this, char a2)
{
  *(_QWORD *)this = &IAllocate::`vftable';
  if ( (a2 & 1) != 0 )
  {
    if ( (a2 & 4) != 0 )
      __global_delete(this, 0x60ui64);
    else
      SPExternalFree(this);
  }
  return this;
}
// 18007C298: using guessed type void *IAllocate::`vftable';

//----- (000000018004D180) ----------------------------------------------------
IAllocate *__fastcall IAllocate::`vector deleting destructor'(IAllocate *this, char a2)
{
  *(_QWORD *)this = &IAllocate::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this, 8ui64);
  return this;
}
// 18007C298: using guessed type void *IAllocate::`vftable';

//----- (000000018004D1C0) ----------------------------------------------------
HLOCAL __fastcall CSslBasicAllocator::Allocate(CSslBasicAllocator *this, unsigned int a2)
{
  return SPExternalAlloc(a2);
}

//----- (000000018004D1D0) ----------------------------------------------------
void __fastcall CSslBasicAllocator::Deallocate(CSslBasicAllocator *this, void *a2)
{
  SPExternalFree(a2);
}

//----- (000000018004D1E0) ----------------------------------------------------
void __fastcall McGenControlCallbackV2(__int64 a1, int a2, char a3, __int64 a4, __int64 a5, int a6, __int64 a7)
{
  unsigned int v7; // r9d
  unsigned __int8 v8; // cl
  __int64 v9; // rcx
  bool v10; // r11
  __int64 v11; // rax
  unsigned __int64 v12; // rdx
  int v13; // r8d

  if ( a7 )
  {
    if ( a2 )
    {
      if ( a2 == 1 )
      {
        *(_QWORD *)(a7 + 16) = a4;
        v7 = 0;
        *(_QWORD *)(a7 + 24) = a5;
        *(_BYTE *)(a7 + 40) = a3;
        for ( *(_DWORD *)(a7 + 36) = 1; v7 < *(unsigned __int16 *)(a7 + 42); ++v7 )
        {
          v8 = *(_BYTE *)(a7 + 40);
          v10 = 0;
          if ( *(_BYTE *)(v7 + *(_QWORD *)(a7 + 64)) <= v8 || !v8 )
          {
            v9 = *(_QWORD *)(*(_QWORD *)(a7 + 56) + 8i64 * v7);
            if ( !v9 || (v9 & *(_QWORD *)(a7 + 16)) != 0 && (v9 & *(_QWORD *)(a7 + 24)) == *(_QWORD *)(a7 + 24) )
              v10 = 1;
          }
          v11 = *(_QWORD *)(a7 + 48);
          v12 = (unsigned __int64)v7 >> 5;
          v13 = 1 << (v7 & 0x1F);
          if ( v10 )
            *(_DWORD *)(v11 + 4 * v12) |= v13;
          else
            *(_DWORD *)(v11 + 4 * v12) &= ~v13;
        }
      }
    }
    else
    {
      *(_DWORD *)(a7 + 36) = 0;
      *(_BYTE *)(a7 + 40) = 0;
      *(_QWORD *)(a7 + 16) = 0i64;
      *(_QWORD *)(a7 + 24) = 0i64;
      if ( *(_WORD *)(a7 + 42) )
        memset_0(*(void **)(a7 + 48), 0, 4i64 * ((*(unsigned __int16 *)(a7 + 42) - 1) / 32 + 1));
    }
  }
}

//----- (000000018004D2F0) ----------------------------------------------------
__int64 __fastcall WppControlCallback(int a1, __int64 a2, _DWORD *a3, __int64 a4)
{
  int v5; // ecx
  __int64 result; // rax
  __int64 TraceLoggerHandle; // rdi
  int TraceEnableFlags; // eax
  char TraceEnableLevel; // si

  *a3 = 0;
  v5 = a1 - 4;
  if ( v5 )
  {
    if ( v5 != 1 )
      return 87i64;
    TraceLoggerHandle = 0i64;
    TraceEnableFlags = 0;
    TraceEnableLevel = 0;
  }
  else
  {
    TraceLoggerHandle = EtwGetTraceLoggerHandle(a4);
    TraceEnableLevel = EtwGetTraceEnableLevel(TraceLoggerHandle);
    TraceEnableFlags = EtwGetTraceEnableFlags(TraceLoggerHandle);
  }
  if ( (*(_BYTE *)(a2 + 26) & 2) != 0 )
  {
    if ( *(_QWORD *)(a2 + 16) )
      a2 = *(_QWORD *)(a2 + 16);
  }
  *(_DWORD *)(a2 + 28) = TraceEnableFlags;
  result = 0i64;
  *(_QWORD *)(a2 + 16) = TraceLoggerHandle;
  *(_BYTE *)(a2 + 25) = TraceEnableLevel;
  return result;
}
// 180080E18: using guessed type __int64 __fastcall EtwGetTraceEnableFlags(_QWORD);
// 180080E20: using guessed type __int64 __fastcall EtwGetTraceEnableLevel(_QWORD);
// 180080E28: using guessed type __int64 __fastcall EtwGetTraceLoggerHandle(_QWORD);

//----- (000000018004D388) ----------------------------------------------------
__int64 __fastcall ParseClientHello(
        const unsigned __int8 *a1,
        unsigned int a2,
        struct _SCH_EXTENSION_DATA *a3,
        unsigned __int8 a4)
{
  unsigned int v4; // r10d
  unsigned int v7; // edx
  const unsigned __int8 *v8; // r11
  unsigned int v9; // edx
  unsigned int v10; // ecx
  unsigned int v11; // edx
  unsigned int v12; // edx
  unsigned __int16 *v13; // r9
  unsigned __int16 v14; // cx
  unsigned int v15; // edx
  unsigned int v16; // edx
  _BYTE *v17; // rcx
  unsigned int v18; // eax
  unsigned int v19; // edx
  __int64 v20; // r8
  unsigned int v21; // edx
  unsigned int v22; // r11d

  v4 = 0;
  if ( !a1 || !a2 || !a3 || !a4 )
    return 2148074333i64;
  if ( a2 < 2 )
    return (unsigned int)-2146893018;
  if ( ((*a1 << 8) | (unsigned int)a1[1]) - 769 > 0xFBFB )
    return (unsigned int)-2146893018;
  v7 = a2 - 2;
  if ( v7 < 0x20 )
    return (unsigned int)-2146893018;
  v8 = a1 + 34;
  v9 = v7 - 32;
  if ( !v9 )
    return (unsigned int)-2146893018;
  if ( *v8 > 0x20u )
    return (unsigned int)-2146893018;
  v10 = *v8;
  v11 = v9 - 1;
  if ( v11 < v10 )
    return (unsigned int)-2146893018;
  v12 = v11 - v10;
  v13 = (unsigned __int16 *)&v8[*v8 + 1];
  if ( v12 < 2 )
    return (unsigned int)-2146893018;
  v14 = _byteswap_ushort(*v13);
  if ( v14 >= 2u
    && (v14 & 1) == 0
    && (v15 = v12 - 2, v15 >= v14)
    && (v16 = v15 - v14, v17 = (char *)v13 + v14 + 2, v16)
    && *v17
    && (v18 = (unsigned __int8)*v17, v19 = v16 - 1, v19 >= v18) )
  {
    v20 = (unsigned __int8)*v17;
    v21 = v19 - v18;
    if ( v21 >= 2 )
    {
      v22 = (unsigned __int8)v17[v20 + 2] | ((unsigned __int8)v17[v20 + 1] << 8);
      if ( v21 >= v22 )
        return (unsigned int)ParseTlsHelloExtensions(&v17[v20 + 3], v22, a3, a4);
    }
  }
  else
  {
    return (unsigned int)-2146893018;
  }
  return v4;
}

//----- (000000018004D4E4) ----------------------------------------------------
__int64 __fastcall ParseTlsHelloExtensions(
        const unsigned __int8 *a1,
        unsigned int a2,
        struct _SCH_EXTENSION_DATA *a3,
        unsigned __int8 a4)
{
  unsigned int v4; // esi
  const unsigned __int8 *v6; // r10
  unsigned int v7; // edx
  int v8; // ebx
  int v9; // r8d
  int v10; // eax
  const unsigned __int8 *v11; // r10
  unsigned int v12; // r8d
  __int64 v13; // rcx
  struct _SCH_EXTENSION_DATA *v14; // r9
  __int64 v15; // rcx

  v4 = a4;
  v6 = a1;
  if ( !a1 || !a3 || !a4 )
    return 2148074333i64;
  if ( !a2 )
    return 0i64;
  while ( a2 >= 4 )
  {
    v7 = a2 - 4;
    v8 = v6[1] | (*v6 << 8);
    v9 = v6[2] << 8;
    v10 = v6[3];
    v11 = v6 + 4;
    v12 = v10 | v9;
    if ( v7 < v12 )
      break;
    v13 = 0i64;
    if ( (_BYTE)v4 )
    {
      v14 = a3;
      while ( v8 != *(unsigned __int16 *)v14 )
      {
        v13 = (unsigned int)(v13 + 1);
        v14 = (struct _SCH_EXTENSION_DATA *)((char *)v14 + 24);
        if ( (unsigned int)v13 >= v4 )
          goto LABEL_13;
      }
      v15 = 3 * v13;
      *((_QWORD *)a3 + v15 + 1) = v11;
      *((_DWORD *)a3 + 2 * v15 + 4) = v12;
    }
LABEL_13:
    v6 = &v11[v12];
    a2 = v7 - v12;
    if ( !a2 )
      return 0i64;
  }
  return 2148074278i64;
}

//----- (000000018004D5A4) ----------------------------------------------------
__int64 __fastcall ProcessRecord(
        const unsigned __int8 *a1,
        unsigned int a2,
        struct _SCH_EXTENSION_DATA *a3,
        unsigned __int8 a4,
        unsigned int *a5)
{
  unsigned int v5; // r10d
  unsigned __int64 v6; // rbx
  __int64 v8; // rdx

  v5 = 0;
  v6 = a2;
  if ( !a1 || !a3 || !a4 || !a5 )
    return 2148074333i64;
  if ( a2 < 4 )
  {
    *a5 = 4 - a2;
    return 2148074264i64;
  }
  v8 = a1[3] + ((a1[2] + (a1[1] << 8)) << 8);
  if ( v8 + 4 > v6 )
  {
    *a5 = v8 - v6 + 4;
    return 2148074264i64;
  }
  if ( *a1 == 1 )
    return (unsigned int)ParseClientHello(a1 + 4, v8, a3, a4);
  return v5;
}

//----- (000000018004D660) ----------------------------------------------------
__int64 __fastcall SslGetExtensions(
        __int64 a1,
        unsigned int a2,
        struct _SCH_EXTENSION_DATA *a3,
        unsigned __int8 a4,
        unsigned int *a5,
        int a6)
{
  __int64 v6; // rdi
  unsigned int v8; // r9d
  unsigned __int16 v10; // r8
  _DWORD *v11; // rax
  __int64 v12; // rcx

  v6 = a4;
  v8 = 0;
  if ( a1 && a3 && (_BYTE)v6 && a5 )
  {
    if ( !a6 )
    {
      if ( a2 < 5 )
      {
        *a5 = 5 - a2;
        return 2148074264i64;
      }
      if ( ((((*(unsigned __int8 *)(a1 + 1) << 8) | *(unsigned __int8 *)(a1 + 2)) - 65277) & 0xFFFFFFFD) == 0 )
        return 2148074278i64;
      v10 = _byteswap_ushort(*(_WORD *)(a1 + 3));
      if ( (unsigned __int64)v10 + 5 > a2 )
      {
        *a5 = v10 - a2 + 5;
        return 2148074264i64;
      }
      if ( *(_BYTE *)a1 != 22 )
        goto LABEL_19;
      v8 = ProcessRecord((const unsigned __int8 *)(a1 + 5), v10, a3, v6, a5);
      if ( !v8 )
        goto LABEL_19;
      goto LABEL_18;
    }
    if ( (a6 & 1) != 0 )
    {
      v8 = ProcessRecord((const unsigned __int8 *)a1, a2, a3, v6, a5);
LABEL_18:
      if ( v8 )
      {
        v11 = (_DWORD *)((char *)a3 + 16);
        v12 = v6;
        do
        {
          *((_QWORD *)v11 - 1) = 0i64;
          *v11 = 0;
          v11 += 6;
          --v12;
        }
        while ( v12 );
        return v8;
      }
LABEL_19:
      *a5 = 0;
      return v8;
    }
  }
  return 2148074333i64;
}
// 18004D763: conditional instruction was optimized away because di.1!=0

//----- (000000018004D7A0) ----------------------------------------------------
__int64 __fastcall ParseClientHello(unsigned __int8 *a1, unsigned int a2, struct SPBuffer *a3)
{
  unsigned int v3; // r9d
  unsigned int v5; // r10d
  unsigned int v6; // edx
  unsigned int v7; // edx
  __int64 v8; // r8
  unsigned int v9; // edx
  unsigned int v10; // edx
  unsigned __int8 *v11; // r11
  int v12; // eax
  unsigned int v13; // ecx
  unsigned int v14; // edx
  unsigned int v15; // edx
  unsigned __int8 *v16; // r8
  __int64 v17; // rax
  unsigned int v18; // edx
  unsigned int v19; // edx
  unsigned int v20; // r9d
  __int64 result; // rax

  v3 = 0;
  if ( a2 < 2 )
    return 2148074278i64;
  v5 = a1[1] + (*a1 << 8);
  if ( v5 < 0x300 )
    return 2148074278i64;
  v6 = a2 - 2;
  if ( v6 < 0x20 )
    return 2148074278i64;
  v7 = v6 - 32;
  if ( !v7 )
    return 2148074278i64;
  v8 = a1[34];
  if ( (unsigned int)v8 > 0x20 )
    return 2148074278i64;
  v9 = v7 - 1;
  if ( v9 < (unsigned int)v8 )
    return 2148074278i64;
  v10 = v9 - v8;
  v11 = &a1[v8 + 35];
  if ( v10 < 2 )
    return 2148074278i64;
  v12 = v11[1];
  v13 = v12 + (*v11 << 8);
  if ( (v12 & 1) != 0 )
    return 2148074278i64;
  v14 = v10 - 2;
  if ( v14 < v13 )
    return 2148074278i64;
  v15 = v14 - v13;
  v16 = &v11[v13];
  if ( !v15 )
    return 2148074278i64;
  v17 = v16[2];
  if ( !v16[2] )
    return 2148074278i64;
  v18 = v15 - 1;
  if ( v18 < (unsigned int)v17 )
    return 2148074278i64;
  v19 = v18 - v17;
  if ( v5 < 0x301 )
    return v3;
  if ( v19 >= 2 )
  {
    v20 = v16[v17 + 4] | (v16[v17 + 3] << 8);
    if ( v19 - 2 >= v20 )
    {
      result = ParseTlsHelloExtensions(&v16[v16[2] + 5], v20, a3);
      v3 = result;
      if ( (_DWORD)result )
        return result;
      return v3;
    }
  }
  return 0i64;
}

//----- (000000018004D8B0) ----------------------------------------------------
__int64 __fastcall ParseSniExtension(unsigned __int8 *a1, unsigned int a2, struct SPBuffer *a3)
{
  char v3; // r11
  unsigned __int8 *v4; // rcx
  unsigned int v5; // edx
  unsigned __int8 v6; // bl
  unsigned int v7; // edx
  __int16 v8; // r9
  unsigned int v9; // edx
  __int16 v10; // ax
  unsigned __int8 *v11; // rcx
  unsigned __int16 v12; // r9

  v3 = 0;
  if ( a2 >= 2 && (a1[1] | (*a1 << 8)) >= 3u )
  {
    v4 = a1 + 2;
    v5 = a2 - 2;
    if ( !v5 )
      return 0i64;
    while ( 1 )
    {
      v6 = *v4;
      v7 = v5 - 1;
      if ( v7 < 2 )
        break;
      v8 = v4[1];
      v9 = v7 - 2;
      v10 = v4[2];
      v11 = v4 + 3;
      v12 = v10 | (v8 << 8);
      if ( v9 < v12 )
        break;
      if ( !v6 && !v3 )
      {
        *(_DWORD *)a3 = v12;
        v3 = 1;
        *((_DWORD *)a3 + 1) = v12;
        *((_QWORD *)a3 + 1) = v11;
      }
      v4 = &v11[v12];
      v5 = v9 - v12;
      if ( !v5 )
        return 0i64;
    }
  }
  return 2148074278i64;
}

//----- (000000018004D944) ----------------------------------------------------
__int64 __fastcall ParseSsl2Hello(struct SPBuffer *a1)
{
  unsigned __int8 *v1; // r8
  unsigned int v2; // r9d

  v1 = (unsigned __int8 *)*((_QWORD *)a1 + 1);
  if ( *(_DWORD *)a1 >= 2u
    && (v2 = ((((char)*v1 >> 31) & 0x4000) + 0x3FFF) & (v1[1] | (*v1 << 8)), v2 + 2 <= *(_DWORD *)a1)
    && v2 >= 0xB
    && v1[2] == 1
    && (v1[4] | (v1[3] << 8)) >= 2u
    && (v1[8] | ((unsigned __int64)v1[7] << 8))
     + (v1[10] | ((unsigned __int64)v1[9] << 8))
     + (v1[6] | ((unsigned __int64)v1[5] << 8))
     + 9 <= v2 )
  {
    return 0i64;
  }
  else
  {
    return 2148074278i64;
  }
}

//----- (000000018004D9F8) ----------------------------------------------------
__int64 __fastcall ParseTlsHelloExtensions(unsigned __int8 *a1, unsigned int a2, struct SPBuffer *a3)
{
  unsigned int v4; // ebx
  unsigned int v6; // ebx
  unsigned int v7; // edx
  int v8; // r8d
  int v9; // eax
  unsigned __int8 *v10; // rdi
  int v11; // r8d
  unsigned __int8 *v12; // rcx
  __int64 result; // rax

  v4 = a2;
  if ( !a2 )
    return 0i64;
  while ( v4 >= 4 )
  {
    v6 = v4 - 4;
    v7 = a1[3] | (a1[2] << 8);
    v8 = *a1 << 8;
    v9 = a1[1];
    v10 = a1 + 4;
    v11 = v9 | v8;
    if ( v6 < v7 )
      break;
    v12 = v10;
    a1 = &v10[v7];
    v4 = v6 - v7;
    if ( !v11 )
    {
      result = ParseSniExtension(v12, v7, a3);
      if ( (_DWORD)result )
        return result;
    }
    if ( !v4 )
      return 0i64;
  }
  return 2148074278i64;
}

//----- (000000018004DA80) ----------------------------------------------------
__int64 __fastcall ProcessRecord(int a1, _BYTE *a2, unsigned int a3, __int64 a4)
{
  __int64 result; // rax
  __int64 v8; // rbx

  if ( a1 != 22 )
    return 0i64;
  while ( a3 >= 4 )
  {
    if ( *a2 != 1 )
      return 2148074248i64;
    v8 = (unsigned __int8)a2[3] + ((unsigned __int8)a2[1] << 16) + ((unsigned __int8)a2[2] << 8);
    if ( v8 + 4 > (unsigned __int64)a3 )
    {
      *(_QWORD *)(a4 + 8) = 0i64;
      *(_DWORD *)a4 = v8 - a3 + 4;
      return 2148074264i64;
    }
    result = ParseClientHello(a2 + 4, v8, (struct SPBuffer *)a4);
    if ( !(_DWORD)result )
    {
      a2 += v8 + 4;
      a3 += -4 - v8;
      if ( a3 )
        continue;
    }
    return result;
  }
  *(_QWORD *)(a4 + 8) = 0i64;
  *(_DWORD *)a4 = 4 - a3;
  return 2148074264i64;
}

//----- (000000018004DB50) ----------------------------------------------------
SECURITY_STATUS __stdcall SslGetServerIdentity(
        PBYTE ClientHello,
        DWORD ClientHelloSize,
        PBYTE *ServerIdentity,
        PDWORD ServerIdentitySize,
        DWORD Flags)
{
  int v6; // r13d
  SECURITY_STATUS v7; // edx
  PBYTE v10; // rbp
  SECURITY_STATUS result; // eax
  int v12; // ecx
  int v13; // edi
  SECURITY_STATUS v14; // eax
  _OWORD v15[3]; // [rsp+20h] [rbp-38h] BYREF

  v6 = 0;
  v7 = 0;
  v10 = ClientHello;
  v15[0] = 0i64;
  if ( !ClientHello || !ServerIdentity || !ServerIdentitySize )
    return -2146892963;
  if ( ClientHelloSize < 5 )
  {
    *ServerIdentitySize = 5 - ClientHelloSize;
    return -2146893032;
  }
  if ( *ClientHello == 22 )
  {
    while ( ClientHelloSize >= 5 )
    {
      v12 = *v10;
      if ( (unsigned int)(v12 - 20) > 3 )
        return -2146893048;
      v13 = v10[4] | (v10[3] << 8);
      if ( v13 + 5 > ClientHelloSize )
      {
        *ServerIdentitySize = v13 - ClientHelloSize + 5;
        return -2146893032;
      }
      v6 += v13 + 5;
      v14 = ProcessRecord(v12, v10 + 5, v13, (__int64)v15);
      v7 = v14;
      if ( v14 )
      {
        if ( v14 == -2146893032 )
LABEL_16:
          *ServerIdentitySize = v15[0];
        return v7;
      }
      v10 += (unsigned int)(v13 + 5);
      ClientHelloSize += -5 - v13;
      if ( !ClientHelloSize )
        goto LABEL_15;
    }
    if ( v6 )
    {
LABEL_15:
      *ServerIdentity = (PBYTE)*((_QWORD *)&v15[0] + 1);
      goto LABEL_16;
    }
    *ServerIdentitySize = 5 - ClientHelloSize;
    return -2146893032;
  }
  *((_QWORD *)&v15[0] + 1) = ClientHello;
  LODWORD(v15[0]) = ClientHelloSize;
  result = ParseSsl2Hello((struct SPBuffer *)v15);
  if ( !result )
    *ServerIdentitySize = 0;
  return result;
}

//----- (000000018004DC98) ----------------------------------------------------
__int64 __fastcall CSslSerializeHelper::SerializeContext(
        CSslSerializeHelper *this,
        void (__fastcall *a2)(__int64, __int64 *),
        unsigned __int8 **a3,
        unsigned int *a4)
{
  __int64 result; // rax
  __int64 v9; // rax
  __int64 v10; // rcx
  int v11; // eax
  unsigned int v12; // edi

  result = CSslSerializeHelper::SerializeContextWorker(this, a2);
  if ( !(_DWORD)result )
  {
    v9 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)this + 8i64))(
           *(_QWORD *)this,
           *((unsigned int *)this + 6));
    *((_QWORD *)this + 1) = v9;
    v10 = v9;
    if ( v9 )
    {
      v11 = *((_DWORD *)this + 6);
      *((_QWORD *)this + 2) = v10;
      *((_DWORD *)this + 7) = v11;
      v12 = CSslSerializeHelper::SerializeContextWorker(this, a2);
      if ( v12 )
      {
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)this + 16i64))(*(_QWORD *)this, *((_QWORD *)this + 1));
        return v12;
      }
      else
      {
        *a3 = (unsigned __int8 *)*((_QWORD *)this + 1);
        *a4 = *((_DWORD *)this + 6);
        return 0i64;
      }
    }
    else
    {
      return 14i64;
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (000000018004DD58) ----------------------------------------------------
__int64 __fastcall CSslSerializeHelper::SerializeEncryptionKey(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  _DWORD *v4; // rdi
  __int64 result; // rax
  unsigned int v8; // edx
  int v9; // [rsp+50h] [rbp+8h]

  v4 = *(_DWORD **)(a1 + 16);
  if ( *(_QWORD *)(a1 + 8) )
  {
    *(_DWORD *)(a1 + 28) -= 16;
    *(_QWORD *)(a1 + 16) = v4 + 4;
  }
  v9 = *(_DWORD *)(a1 + 28);
  result = SslExportKey(a3, a4, L"OpaqueKeyBlob");
  if ( !(_DWORD)result || (_DWORD)result == -2146893784 )
  {
    v8 = (v9 + 23) & 0xFFFFFFF8;
    if ( *(_QWORD *)(a1 + 8) )
    {
      *v4 = a2;
      v4[1] = v8 - 16;
      v4[2] = v9;
      *(_QWORD *)(a1 + 16) += v8 - 16;
      *(_DWORD *)(a1 + 28) += 16 - v8;
    }
    else
    {
      *(_DWORD *)(a1 + 24) += v8;
    }
    return 0i64;
  }
  return result;
}
// 180082320: using guessed type wchar_t aOpaquekeyblob[14];
// 180098528: using guessed type __int64 __fastcall SslExportKey(_QWORD, _QWORD, _QWORD);

//----- (000000018004DE20) ----------------------------------------------------
ISslSerialize *__fastcall ISslSerialize::`scalar deleting destructor'(ISslSerialize *this)
{
  *(_QWORD *)this = &ISslSerialize::`vftable';
  return this;
}
// 18007CFB8: using guessed type void *ISslSerialize::`vftable';

//----- (000000018004DE38) ----------------------------------------------------
char __fastcall CSslUserContext::DTLSCheckRecordValidity(CSslUserContext *this, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // r10
  char v5; // cl
  __int64 v6; // rax
  unsigned __int64 v7; // r8
  __int64 v8; // rax

  v2 = *((_QWORD *)this + 16) + 63i64;
  v3 = a2 & 0xFFFFFFFFFFFFi64;
  if ( *((_DWORD *)this + 29) == -1 )
    return 1;
  if ( HIWORD(a2) != *((_DWORD *)this + 29) )
    return 0;
  if ( v3 <= v2 )
  {
    v7 = v2 - v3;
    if ( v7 >= 0x40 )
      return 0;
    v8 = *((_QWORD *)this + 15);
    if ( _bittest64(&v8, v7) )
      return 0;
    *((_QWORD *)this + 15) = v8 | (1i64 << v7);
    return 1;
  }
  v5 = 1;
  if ( v3 - v2 >= 0x40 )
    v6 = 1i64;
  else
    v6 = (*((_QWORD *)this + 15) << ((unsigned __int8)a2 - (unsigned __int8)v2)) | 1i64;
  *((_QWORD *)this + 15) = v6;
  *((_QWORD *)this + 16) = v3 - 63;
  return v5;
}

//----- (000000018004DEE0) ----------------------------------------------------
void __fastcall CSslUserContext::FreeMemory(CSslUserContext *this, void *a2)
{
  LocalFree(a2);
}

//----- (000000018004DEF8) ----------------------------------------------------
__int64 __fastcall CSslUserContext::GenerateKeyUpdateRecord(CSslUserContext *this, struct SPBuffer *a2)
{
  __int64 result; // rax
  CCipherMill *v5; // rcx
  int v6; // [rsp+50h] [rbp-28h] BYREF
  __int16 v7; // [rsp+54h] [rbp-24h]

  if ( !a2 )
    return 2148074333i64;
  v6 = 16777240;
  v7 = 5632;
  v5 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 123i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
      v5 = WPP_GLOBAL_Control;
    }
    if ( v5 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v5 + 28) & 4) != 0 )
      WPP_SF_D(
        *((_QWORD *)v5 + 2),
        124i64,
        &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
        *((unsigned int *)this + 26));
  }
  result = SslEncryptPacket(
             *((_QWORD *)this + 11),
             *((_QWORD *)this + 6),
             &v6,
             6i64,
             *((_QWORD *)a2 + 1),
             *(_DWORD *)a2,
             (char *)a2 + 4,
             *((_QWORD *)this + 13),
             23,
             0);
  if ( !(_DWORD)result )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 125i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
    return UpdateTrafficSecretAndDeriveNewKey(
             *((_QWORD *)this + 11),
             (unsigned __int64 *)this + 56,
             (unsigned __int64 *)this + 6,
             (unsigned __int64 *)this + 13);
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098508: using guessed type __int64 __fastcall SslEncryptPacket(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (000000018004E050) ----------------------------------------------------
void __fastcall GenerateUserFatalAlertMessage(struct CSslUserContext *a1, __int64 a2, char a3)
{
  _BYTE *v4; // rdx
  unsigned int v5; // ebx
  struct _SecBufferDesc v6; // [rsp+20h] [rbp-30h] BYREF
  int v7[2]; // [rsp+30h] [rbp-20h] BYREF
  _BYTE *v8; // [rsp+38h] [rbp-18h]
  unsigned int v9; // [rsp+40h] [rbp-10h]
  int v10; // [rsp+44h] [rbp-Ch]
  _BYTE *v11; // [rsp+48h] [rbp-8h]

  v4 = *(_BYTE **)(a2 + 8);
  v5 = *(_DWORD *)a2;
  *(_DWORD *)a2 = 0;
  if ( a3 )
  {
    if ( v4 )
    {
      if ( v5 >= *((_DWORD *)a1 + 16) + *((_DWORD *)a1 + 17) + 2 )
      {
        v4[1] = a3;
        *v4 = 2;
        v6.ulVersion = 0;
        v11 = v4 + 2;
        v9 = v5 - 2;
        v8 = v4;
        v7[0] = 2;
        v10 = 2;
        v6.cBuffers = 2;
        v6.pBuffers = (PSecBuffer)v7;
        v7[1] = 1;
        if ( !(unsigned int)SslSealMessageConnection(a1, 0x40000000, &v6) )
        {
          if ( v5 >= v7[0] + v9 )
            v5 = v7[0] + v9;
          *(_DWORD *)a2 = v5;
        }
      }
    }
  }
}

//----- (000000018004E0FC) ----------------------------------------------------
__int64 __fastcall GetAppDataStatusCallback(
        struct CSslUserContext *a1,
        void *(__stdcall *a2)(unsigned int),
        void (__stdcall *a3)(void *),
        char a4,
        struct _SecBuffer *a5)
{
  _BYTE *v6; // rax
  unsigned int v7; // ebx
  _BYTE *v8; // rdx
  unsigned int v9; // esi
  char v10; // al
  __int64 result; // rax

  if ( (a4 & 8) != 0 )
    v6 = SPExternalAlloc(1u);
  else
    v6 = PvExtVirtualAlloc(1u);
  v7 = 0;
  v8 = v6;
  if ( v6 )
  {
    v10 = *((_BYTE *)a1 + 140);
    v9 = 0;
    *v8 = v10;
    a5->pvBuffer = v8;
    v7 = 1;
  }
  else
  {
    v9 = -2146893056;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 137i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
  }
  a5->BufferType = v7;
  result = v9;
  a5->cbBuffer = v7;
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018004E1A0) ----------------------------------------------------
HLOCAL __fastcall CSslUserContext::GetMemory(CSslUserContext *this, SIZE_T a2)
{
  return LocalAlloc(0x40u, a2);
}

//----- (000000018004E1C0) ----------------------------------------------------
__int64 __fastcall CSslUserContext::GetPeerCertValidationResults(CSslUserContext *this, int *a2, unsigned int *a3)
{
  if ( !a2 || !a3 )
    return 87i64;
  *a2 = *((_DWORD *)this + 94);
  *a3 = *((_DWORD *)this + 95);
  return 0i64;
}

//----- (000000018004E1F0) ----------------------------------------------------
__int64 __fastcall CSslUserContext::GetProviderInfo(char **this, char *a2, unsigned __int64 *a3)
{
  __int64 v4; // r11
  __int64 result; // rax

  StringCchCopyW(a2, 256i64, this[10]);
  result = 0i64;
  *a3 = *(_QWORD *)(v4 + 88);
  return result;
}
// 18004E210: variable 'v4' is possibly undefined

//----- (000000018004E228) ----------------------------------------------------
__int64 __fastcall HandleSpecialMessage(
        struct CSslUserContext *a1,
        unsigned __int8 *a2,
        int a3,
        enum eTlsRecordType *a4)
{
  int v4; // eax
  int v8; // eax

  v4 = *((_DWORD *)a1 + 6);
  if ( (v4 & 0x800A2AAA) != 0 && !a3 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
    return 2148074248i64;
  }
  if ( (v4 & 0x40051555) != 0 && a3 == 4 )
  {
    if ( *a2 || a2[1] || a2[2] || a2[3] || (v4 & 0x1000) != 0 )
      return 2148074248i64;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
    v8 = 22;
  }
  else
  {
    if ( a3 != 2 || (unsigned __int8)(*a2 - 1) > 1u )
      return 2148074248i64;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_dd(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xCu,
        (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
        *a2,
        a2[1]);
    if ( !IsValidAlert(a2[1]) )
      return 2148074248i64;
    v8 = 21;
  }
  *(_DWORD *)a4 = v8;
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018004E350) ----------------------------------------------------
unsigned __int8 __fastcall IsValidAlert(unsigned __int8 a1)
{
  bool v1; // zf

  if ( a1 > 0x47u )
  {
    if ( a1 == 80 || a1 == 90 || a1 == 100 || a1 == 110 || a1 == 115 )
      return 1;
    v1 = a1 == 120;
    goto LABEL_18;
  }
  if ( a1 >= 0x46u || !a1 || a1 == 10 )
    return 1;
  if ( a1 <= 0x13u )
    return 0;
  if ( a1 <= 0x16u || a1 == 30 || a1 == 40 )
    return 1;
  if ( a1 <= 0x29u )
    return 0;
  if ( a1 > 0x33u )
  {
    v1 = a1 == 60;
LABEL_18:
    if ( !v1 )
      return 0;
  }
  return 1;
}

//----- (000000018004E3B4) ----------------------------------------------------
__int64 __fastcall SetMtuCallback(struct CSslUserContext *a1, char a2, struct _SecBuffer *a3)
{
  unsigned int cbBuffer; // r9d
  _WORD *pvBuffer; // rax
  char v6; // si
  _WORD *v7; // r8
  unsigned int v8; // eax
  unsigned int v9; // edi

  cbBuffer = a3->cbBuffer;
  pvBuffer = a3->pvBuffer;
  v6 = a2 & 8;
  v7 = pvBuffer + 4;
  if ( cbBuffer <= 4 )
    v7 = pvBuffer;
  v8 = cbBuffer - 8;
  if ( cbBuffer <= 4 )
    v8 = cbBuffer;
  if ( v8 == 4 )
  {
    v9 = 0;
    *((_WORD *)a1 + 68) = *v7;
    *((_WORD *)a1 + 69) = v7[1];
  }
  else
  {
    v9 = -2146892963;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 136i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
  }
  if ( v6 )
  {
    SPExternalFree(a3->pvBuffer);
    a3->pvBuffer = 0i64;
    a3->cbBuffer = 0;
    a3->BufferType = 0;
  }
  return v9;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018004E470) ----------------------------------------------------
__int64 __fastcall SpQueryCertificateValidationResult(
        __int16 a1,
        unsigned int a2,
        unsigned int a3,
        struct _SecPkgContext_CertificateValidationResult *a4)
{
  __int64 result; // rax

  if ( !a4 )
    return 2148074333i64;
  if ( (a1 & 0x4000) != 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 114i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
    return 2148074241i64;
  }
  else
  {
    result = 2148074254i64;
    if ( a3 != -2146893042 )
    {
      *(_QWORD *)a4 = __PAIR64__(a3, a2);
      return 0i64;
    }
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018004E4E8) ----------------------------------------------------
__int64 __fastcall SpQueryConnectionInfoEx(struct CSslUserContext *a1, struct _SecPkgContext_ConnectionInfoEx *a2)
{
  unsigned __int16 v4; // ax
  unsigned int v5; // esi
  char v7[140]; // [rsp+30h] [rbp-2D8h] BYREF
  wchar_t Source[64]; // [rsp+BCh] [rbp-24Ch] BYREF
  DWORD v9; // [rsp+13Ch] [rbp-1CCh]
  wchar_t v10[64]; // [rsp+144h] [rbp-1C4h] BYREF
  DWORD v11; // [rsp+1C4h] [rbp-144h]
  wchar_t v12[140]; // [rsp+1C8h] [rbp-140h] BYREF

  memset_0(v7, 0, 0x2A4ui64);
  v4 = ConvertSchannelProtocolToSsl(*((_DWORD *)a1 + 6));
  v5 = SslLookupCipherSuiteInfo(*((_QWORD *)a1 + 11), v4, *((unsigned int *)a1 + 14), *((unsigned int *)a1 + 15), v7, 0);
  if ( !v5 )
  {
    a2->dwVersion = 1;
    a2->dwProtocol = *((_DWORD *)a1 + 6);
    wcscpy_s(a2->szCipher, 0x40ui64, Source);
    a2->dwCipherStrength = v9;
    wcscpy_s(a2->szHash, 0x40ui64, v10);
    a2->dwHashStrength = v11;
    wcscpy_s(a2->szExchange, 0x40ui64, v12);
    a2->dwExchStrength = *((_DWORD *)a1 + 7);
  }
  return v5;
}
// 180098510: using guessed type __int64 __fastcall SslLookupCipherSuiteInfo(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 18004E4E8: using guessed type wchar_t Source[64];
// 18004E4E8: using guessed type wchar_t var_1C4[64];
// 18004E4E8: using guessed type wchar_t var_140[140];

//----- (000000018004E5F8) ----------------------------------------------------
__int64 __fastcall SpQueryKeyingMaterial(struct CSslUserContext *a1, struct _SecPkgContext_KeyingMaterial_Inproc *a2)
{
  WORD cbContextValue; // [rsp+30h] [rbp-28h]

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 112i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
  cbContextValue = a2->cbContextValue;
  return SslExportKeyingMaterial(
           *((_QWORD *)a1 + 11),
           *((_QWORD *)a1 + 54),
           a2->pszLabel,
           0i64,
           0,
           a2->pbContextValue,
           cbContextValue,
           a2->pbKeyingMaterial,
           a2->cbKeyingMaterial,
           0);
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180098560: using guessed type __int64 __fastcall SslExportKeyingMaterial(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD, _QWORD, _DWORD, _DWORD);

//----- (000000018004E694) ----------------------------------------------------
__int64 __fastcall SpQueryNegotiatedTlsExtensions(
        struct CSslUserContext *a1,
        struct _SecPkgContext_NegotiatedTlsExtensions *a2)
{
  __int64 v4; // rax
  bool v5; // zf
  __int64 v6; // rax
  unsigned int v7; // ebx
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  unsigned __int16 *v12; // rax
  unsigned __int16 *v13; // rdi
  __int64 Src; // [rsp+20h] [rbp-28h] BYREF
  int v16; // [rsp+28h] [rbp-20h]

  Src = 0i64;
  v16 = 0;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 113i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
  v4 = *((_QWORD *)a1 + 2) & 0x20000i64;
  if ( (*((_QWORD *)a1 + 2) & 0x20000) != 0 )
    LOWORD(Src) = 5;
  v5 = v4 == 0;
  v6 = *((_QWORD *)a1 + 49);
  v7 = !v5;
  if ( v6 && *(_DWORD *)(v6 + 4) == 2 )
  {
    v7 = !v5 + 1;
    *((_WORD *)&Src + !v5) = 16;
  }
  if ( *((_QWORD *)a1 + 50) )
  {
    v8 = v7++;
    *((_WORD *)&Src + v8) = 14;
  }
  if ( *((_QWORD *)a1 + 51) )
  {
    v9 = v7++;
    *((_WORD *)&Src + v9) = 24;
  }
  if ( (*((_QWORD *)a1 + 2) & 0x8000000i64) != 0 )
  {
    v10 = v7++;
    *((_WORD *)&Src + v10) = 23;
  }
  if ( *((_BYTE *)a1 + 32) )
  {
    v11 = v7++;
    *((_WORD *)&Src + v11) = -255;
  }
  if ( v7 )
  {
    v12 = (unsigned __int16 *)LocalAlloc(0x40u, 2 * v7);
    v13 = v12;
    if ( !v12 )
      return 2148074240i64;
    memcpy_0(v12, &Src, 2 * v7);
    a2->Extensions = v13;
    a2->ExtensionsCount = v7;
  }
  else
  {
    *a2 = 0i64;
  }
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018004E80C) ----------------------------------------------------
__int64 __fastcall SpQuerySizes(struct CSslUserContext *a1, struct _SecPkgContext_Sizes *a2)
{
  CCipherMill *v4; // rcx
  unsigned int v6; // eax
  unsigned int v7; // ecx
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // eax
  bool v14; // zf
  unsigned int v15; // eax
  unsigned int *v16; // [rsp+20h] [rbp-38h]
  unsigned int v17; // [rsp+60h] [rbp+8h] BYREF
  unsigned int v18; // [rsp+70h] [rbp+18h] BYREF
  unsigned int v19; // [rsp+78h] [rbp+20h] BYREF

  v19 = 0;
  v18 = 0;
  v17 = 0;
  v4 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 95i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
      v4 = WPP_GLOBAL_Control;
    }
    if ( v4 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v4 + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)v4 + 2), 96i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
  }
  if ( (unsigned int)QueryStreamSizes(
                       *((_QWORD *)a1 + 11),
                       *((_DWORD *)a1 + 14),
                       *((_DWORD *)a1 + 6),
                       *((_DWORD *)a1 + 15),
                       &v19,
                       &v18,
                       &v17) )
    return 2148074244i64;
  v6 = *((_DWORD *)a1 + 6);
  v7 = v18;
  if ( v6 > 0x800 )
  {
    if ( v6 == 4096 || v6 == 0x2000 || v6 == 0x10000 || v6 == 0x20000 || v6 == 0x40000 )
      goto LABEL_26;
    v14 = v6 == 0x80000;
  }
  else
  {
    if ( v6 == 2048 )
      goto LABEL_26;
    v8 = v6 - 16;
    if ( !v8 )
      goto LABEL_26;
    v9 = v8 - 16;
    if ( !v9 )
      goto LABEL_26;
    v10 = v9 - 32;
    if ( !v10 )
      goto LABEL_26;
    v11 = v10 - 64;
    if ( !v11 )
      goto LABEL_26;
    v12 = v11 - 128;
    if ( !v12 )
      goto LABEL_26;
    v13 = v12 - 256;
    if ( !v13 )
      goto LABEL_26;
    v14 = v13 == 512;
  }
  if ( v14 )
  {
LABEL_26:
    a2->cbMaxToken = 0x4000 - v17 - v18;
    v15 = v7 + v17 + *((_DWORD *)a1 + 16) + *((_DWORD *)a1 + 17) + ((*((_DWORD *)a1 + 6) & 0x3000) != 0);
    goto LABEL_27;
  }
  a2->cbMaxToken = 0x4000;
  v15 = 0;
LABEL_27:
  a2->cbSecurityTrailer = v15;
  a2->cbBlockSize = v19;
  a2->cbMaxSignature = v7;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    LODWORD(v16) = 0;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x61u,
      (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
      0,
      v16);
  }
  return 0i64;
}
// 18004E98D: variable 'v16' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018004E9A4) ----------------------------------------------------
__int64 __fastcall SpQuerySrtpParameters(struct CSslUserContext *a1, struct _SecPkgContext_SrtpParameters *a2)
{
  struct _SecPkgContext_SrtpParameters *v2; // rbx
  BYTE *v4; // rsi
  PBYTE MasterKeyIdentifier; // rbp
  SIZE_T MasterKeyIdentifierSize; // r14
  BYTE *v7; // rax

  v2 = (struct _SecPkgContext_SrtpParameters *)*((_QWORD *)a1 + 50);
  v4 = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 109i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
  if ( v2 )
  {
    MasterKeyIdentifier = v2->MasterKeyIdentifier;
    if ( MasterKeyIdentifier )
    {
      MasterKeyIdentifierSize = v2->MasterKeyIdentifierSize;
      v7 = (BYTE *)LocalAlloc(0x40u, MasterKeyIdentifierSize);
      v4 = v7;
      if ( !v7 )
        return 2148074240i64;
      memcpy_0(v7, MasterKeyIdentifier, MasterKeyIdentifierSize);
    }
    *a2 = *v2;
    a2->MasterKeyIdentifier = v4;
  }
  else
  {
    *a2 = 0i64;
  }
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018004EA70) ----------------------------------------------------
__int64 __fastcall SpQueryTokenBindingEKM(struct CSslUserContext *a1, struct _SecPkgContext_KeyingMaterial *a2)
{
  BYTE *v4; // rax
  BYTE *v5; // rsi

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 111i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
  *a2 = 0i64;
  if ( *((_QWORD *)a1 + 53) )
  {
    v4 = (BYTE *)LocalAlloc(0x40u, *((unsigned int *)a1 + 104));
    v5 = v4;
    if ( !v4 )
      return 2148074240i64;
    memcpy_0(v4, *((const void **)a1 + 53), *((unsigned int *)a1 + 104));
    a2->cbKeyingMaterial = *((_DWORD *)a1 + 104);
    a2->pbKeyingMaterial = v5;
  }
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018004EB24) ----------------------------------------------------
__int64 __fastcall SpQueryUniqueBindings(struct CSslUserContext *a1, struct _SecPkgContext_Bindings *a2)
{
  unsigned int v5; // ebx
  SEC_CHANNEL_BINDINGS *v6; // rax
  SEC_CHANNEL_BINDINGS *Bindings; // rcx
  int v8; // [rsp+20h] [rbp-18h]
  int v9; // [rsp+20h] [rbp-18h]
  int v10; // [rsp+20h] [rbp-18h]
  int v11; // [rsp+20h] [rbp-18h]
  size_t Size; // [rsp+40h] [rbp+8h] BYREF
  void *Src; // [rsp+48h] [rbp+10h] BYREF

  (*(void (__fastcall **)(struct CSslUserContext *, void **, size_t *))(*(_QWORD *)a1 + 80i64))(a1, &Src, &Size);
  a2->BindingsLength = 0;
  a2->Bindings = 0i64;
  if ( (*((_BYTE *)a1 + 24) & 0xC) != 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
    {
      v8 = -2146893054;
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x68u,
        (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
        -2146893054,
        v8);
    }
    return 2148074242i64;
  }
  if ( Src && (_DWORD)Size )
  {
    v5 = Size + 43;
    if ( (int)Size + 43 < (unsigned int)Size )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
      {
        v9 = -2146893052;
        WPP_SF_DD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x69u,
          (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
          -2146893052,
          v9);
      }
      return 2148074244i64;
    }
    v6 = (SEC_CHANNEL_BINDINGS *)LocalAlloc(0x40u, v5);
    a2->Bindings = v6;
    if ( !v6 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
      {
        v10 = -2146893056;
        WPP_SF_DD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x6Au,
          (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
          -2146893056,
          v10);
      }
      return 2148074240i64;
    }
    v6->cbApplicationDataLength = Size + 11;
    a2->Bindings->dwApplicationDataOffset = 32;
    Bindings = a2->Bindings;
    qmemcpy(&Bindings[1], "tls-unique:", 11);
    memcpy_0((char *)&Bindings[1].dwInitiatorOffset + 3, Src, (unsigned int)Size);
    a2->BindingsLength = v5;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    v11 = 0;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x6Bu,
      (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
      0,
      v11);
  }
  return 0i64;
}

//----- (000000018004ED04) ----------------------------------------------------
__int64 __fastcall SslSealMessageConnection(struct CSslUserContext *a1, int a2, struct _SecBufferDesc *a3)
{
  struct _SecBuffer *v5; // rdi
  struct _SecBuffer *v6; // rsi
  CCipherMill *v7; // rcx
  unsigned int cBuffers; // r11d
  unsigned int v9; // edx
  PSecBuffer pBuffers; // r10
  unsigned int *p_BufferType; // r9
  char *pvBuffer; // rdx
  __int64 cbBuffer; // r8
  int v15; // eax
  unsigned __int8 *v16; // r12
  __int64 v17; // r15
  __int64 v18; // r14
  unsigned int v19; // eax
  unsigned int v20; // ebx
  int v21; // ebx
  unsigned int v22; // eax
  unsigned int v23; // eax
  unsigned int v24; // ecx
  unsigned __int16 v25; // dx
  __int64 v26; // [rsp+20h] [rbp-50h]
  int v27; // [rsp+50h] [rbp-20h] BYREF
  unsigned int v28; // [rsp+58h] [rbp-18h]
  unsigned int v29; // [rsp+5Ch] [rbp-14h] BYREF
  void *Src; // [rsp+60h] [rbp-10h]
  int v32; // [rsp+C0h] [rbp+50h]
  int v33; // [rsp+C8h] [rbp+58h]

  v32 = 0;
  v5 = 0i64;
  v6 = 0i64;
  v33 = 23;
  v27 = 23;
  v7 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 50i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
    v7 = WPP_GLOBAL_Control;
  }
  cBuffers = a3->cBuffers;
  v9 = 0;
  if ( !cBuffers )
    goto LABEL_96;
  pBuffers = a3->pBuffers;
  p_BufferType = &pBuffers->BufferType;
  do
  {
    if ( *p_BufferType == 1 )
    {
      v5 = &pBuffers[v9];
    }
    else if ( *p_BufferType == 2 && !v6 )
    {
      v6 = &pBuffers[v9];
    }
    ++v9;
    p_BufferType += 4;
  }
  while ( v9 < cBuffers );
  if ( !v6 || !v5 )
  {
LABEL_96:
    if ( v7 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v7 + 28) & 5) == 0 )
      return 2148074248i64;
    v25 = 51;
    goto LABEL_98;
  }
  pvBuffer = (char *)v5->pvBuffer;
  if ( !pvBuffer || !v6->pvBuffer )
  {
    if ( v7 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v7 + 28) & 5) == 0 )
      return 2148074248i64;
    v25 = 52;
LABEL_98:
    WPP_SF_DD(
      *((_QWORD *)v7 + 2),
      v25,
      (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
      -2146893048,
      -2146893048);
    return 2148074248i64;
  }
  if ( (*((_DWORD *)a1 + 6) & 0xF0000) != 0 )
  {
    if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v7 + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)v7 + 2),
        0x35u,
        (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
        -2146893054,
        -2146893054);
    return 2148074242i64;
  }
  cbBuffer = v5->cbBuffer;
  if ( v6->pvBuffer == &pvBuffer[cbBuffer] )
  {
    Src = v5->pvBuffer;
    v29 = 0;
    v15 = v5->cbBuffer + v6->cbBuffer;
    goto LABEL_29;
  }
  v32 = 1;
  Src = LocalAlloc(0x40u, (unsigned int)(cbBuffer + v6->cbBuffer));
  if ( Src )
  {
    v15 = v5->cbBuffer + v6->cbBuffer;
    v7 = WPP_GLOBAL_Control;
    v29 = 0;
LABEL_29:
    v28 = v15;
    v16 = (unsigned __int8 *)v5->pvBuffer;
    v17 = v5->cbBuffer;
    if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v7 + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)v7 + 2), 57i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
        v7 = WPP_GLOBAL_Control;
      }
      if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)v7 + 28) & 4) != 0 )
        {
          WPP_SF_D(*((_QWORD *)v7 + 2), 58i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, (unsigned int)v17);
          v7 = WPP_GLOBAL_Control;
        }
        if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)v7 + 28) & 4) != 0 )
          {
            WPP_SF_D(*((_QWORD *)v7 + 2), 59i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, (unsigned int)v17);
            v7 = WPP_GLOBAL_Control;
          }
          if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control )
          {
            if ( (*((_BYTE *)v7 + 28) & 4) != 0 )
            {
              WPP_SF_D(*((_QWORD *)v7 + 2), 60i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v29);
              v7 = WPP_GLOBAL_Control;
            }
            if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v7 + 28) & 4) != 0 )
            {
              WPP_SF_D(*((_QWORD *)v7 + 2), 61i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v28);
              v7 = WPP_GLOBAL_Control;
            }
          }
        }
      }
    }
    v18 = (unsigned int)(*((_DWORD *)a1 + 16) + *((_DWORD *)a1 + 17));
    if ( a2 == 0x40000000 )
    {
      v19 = HandleSpecialMessage(a1, v16, v17, (enum eTlsRecordType *)&v27);
      v7 = WPP_GLOBAL_Control;
      v20 = v19;
      if ( v19 )
        goto LABEL_76;
      v33 = v27;
    }
    if ( !v32 )
    {
      memmove_s((char *)v5->pvBuffer + v18, v5->cbBuffer, v5->pvBuffer, v5->cbBuffer);
      v7 = WPP_GLOBAL_Control;
      v16 += (unsigned int)v18;
    }
    if ( (*((_DWORD *)a1 + 6) & 0x3000) != 0 )
    {
      v21 = 23;
      v16[v17] = v33;
      LODWORD(v17) = v17 + 1;
      v7 = WPP_GLOBAL_Control;
    }
    else
    {
      v21 = v33;
    }
    if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v7 + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)v7 + 2), 62i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
        v7 = WPP_GLOBAL_Control;
      }
      if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)v7 + 28) & 4) != 0 )
        {
          WPP_SF_D(*((_QWORD *)v7 + 2), 63i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, (unsigned int)v17);
          v7 = WPP_GLOBAL_Control;
        }
        if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)v7 + 28) & 4) != 0 )
          {
            WPP_SF_q(
              *((_QWORD *)v7 + 2),
              0x40u,
              (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
              (char *)Src + (unsigned int)v18);
            v7 = WPP_GLOBAL_Control;
          }
          if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control )
          {
            if ( (*((_BYTE *)v7 + 28) & 4) != 0 )
            {
              WPP_SF_D(
                *((_QWORD *)v7 + 2),
                65i64,
                &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
                v28 - (unsigned int)v18);
              v7 = WPP_GLOBAL_Control;
            }
            if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_BYTE *)v7 + 28) & 4) != 0 )
              {
                WPP_SF_D(*((_QWORD *)v7 + 2), 66i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v29);
                v7 = WPP_GLOBAL_Control;
              }
              if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v7 + 28) & 4) != 0 )
                WPP_SF_D(
                  *((_QWORD *)v7 + 2),
                  67i64,
                  &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
                  *((unsigned int *)a1 + 26));
            }
          }
        }
      }
    }
    v22 = SslEncryptPacket(
            *((_QWORD *)a1 + 11),
            *((_QWORD *)a1 + 6),
            v16,
            (unsigned int)v17,
            Src,
            v28,
            &v29,
            *((_QWORD *)a1 + 13),
            v21,
            0);
    ++*((_QWORD *)a1 + 13);
    v20 = v22;
    if ( !v22 )
    {
      v23 = v29;
      if ( v29 >= v5->cbBuffer )
        v23 = v5->cbBuffer;
      v24 = v29 - v23;
      v5->cbBuffer = v23;
      if ( v24 >= v6->cbBuffer )
        v24 = v6->cbBuffer;
      v6->cbBuffer = v24;
      if ( !v32 )
        goto LABEL_85;
      memcpy_0(v5->pvBuffer, Src, v5->cbBuffer);
      memcpy_0(v6->pvBuffer, (char *)Src + v5->cbBuffer, v6->cbBuffer);
LABEL_84:
      LocalFree(Src);
LABEL_85:
      v7 = WPP_GLOBAL_Control;
LABEL_86:
      if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control
        && ((*((_BYTE *)v7 + 28) & 1) != 0 && v20 || (*((_BYTE *)v7 + 28) & 4) != 0) )
      {
        LODWORD(v26) = v20;
        WPP_SF_DD(*((_QWORD *)v7 + 2), 0x47u, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v20, v26);
      }
      return v20;
    }
    v7 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 68i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v22);
      v7 = WPP_GLOBAL_Control;
    }
    v20 = -2146893015;
LABEL_76:
    if ( !v32 )
      goto LABEL_86;
    goto LABEL_84;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x38u,
      (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
      -2146893056,
      -2146893056);
  return 2148074240i64;
}
// 18004F255: variable 'v26' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098508: using guessed type __int64 __fastcall SslEncryptPacket(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (000000018004F2BC) ----------------------------------------------------
__int64 __fastcall SslUnsealMessageConnection(struct CSslUserContext *a1, struct _SecBufferDesc *a2)
{
  struct _SecBuffer *v2; // rsi
  struct _SecBuffer *v3; // rdi
  __int64 v4; // r15
  int v5; // r12d
  CCipherMill *v8; // rcx
  unsigned int cBuffers; // r11d
  unsigned int v10; // r8d
  PSecBuffer pBuffers; // r10
  unsigned int *p_BufferType; // r9
  __int64 pvBuffer; // rdx
  unsigned int v15; // ebx
  __int64 cbBuffer; // rdx
  char *v17; // r8
  unsigned int v18; // r9d
  bool v19; // zf
  unsigned int v20; // ebx
  int v21; // r11d
  unsigned int v22; // r10d
  int v23; // edx
  int v24; // eax
  unsigned int v25; // eax
  unsigned int v26; // eax
  unsigned __int16 v27; // dx
  unsigned int v28; // [rsp+30h] [rbp-20h] BYREF
  unsigned int v29; // [rsp+34h] [rbp-1Ch]
  char *v30; // [rsp+38h] [rbp-18h]
  unsigned int v31; // [rsp+40h] [rbp-10h] BYREF
  unsigned int v32; // [rsp+44h] [rbp-Ch]
  __int64 v33; // [rsp+48h] [rbp-8h]
  unsigned __int8 v34; // [rsp+88h] [rbp+38h] BYREF

  v2 = 0i64;
  v3 = 0i64;
  v4 = 0i64;
  v34 = 0;
  v5 = 0;
  v8 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 83i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
    v8 = WPP_GLOBAL_Control;
  }
  cBuffers = a2->cBuffers;
  v10 = 0;
  if ( !cBuffers )
    goto LABEL_86;
  pBuffers = a2->pBuffers;
  p_BufferType = &pBuffers->BufferType;
  do
  {
    switch ( *p_BufferType )
    {
      case 1u:
        v2 = &pBuffers[v10];
        break;
      case 2u:
        if ( !v3 )
          v3 = &pBuffers[v10];
        break;
      case 0x11u:
        v4 = (__int64)&pBuffers[v10];
        break;
    }
    ++v10;
    p_BufferType += 4;
  }
  while ( v10 < cBuffers );
  if ( !v3 || !v2 )
  {
LABEL_86:
    if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 5) == 0 )
      return 2148074248i64;
    v27 = 84;
    goto LABEL_88;
  }
  pvBuffer = (__int64)v2->pvBuffer;
  if ( !pvBuffer || !v3->pvBuffer )
  {
    if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 5) == 0 )
      return 2148074248i64;
    v27 = 85;
LABEL_88:
    WPP_SF_DD(
      *((_QWORD *)v8 + 2),
      v27,
      (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
      -2146893048,
      -2146893048);
    return 2148074248i64;
  }
  if ( v2->cbBuffer > ~v3->cbBuffer )
  {
    if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)v8 + 2),
        0x56u,
        (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
        -2146892963,
        -2146892963);
    return 2148074333i64;
  }
  v15 = *((_DWORD *)a1 + 6);
  if ( (v15 & 0xF0000) != 0 )
  {
    if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)v8 + 2),
        0x57u,
        (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
        -2146893054,
        -2146893054);
    return 2148074242i64;
  }
  v32 = 0;
  v33 = pvBuffer;
  cbBuffer = v2->cbBuffer;
  v17 = (char *)v2->pvBuffer;
  if ( &v17[cbBuffer] == v3->pvBuffer )
  {
    v30 = (char *)v2->pvBuffer;
    v18 = v2->cbBuffer + v3->cbBuffer;
    v29 = v18;
    v28 = v18;
    v31 = v18;
    goto LABEL_36;
  }
  v29 = cbBuffer + v3->cbBuffer;
  v30 = (char *)LocalAlloc(0x40u, v29);
  if ( v30 )
  {
    v28 = v29;
    memcpy_0(v30, v2->pvBuffer, v2->cbBuffer);
    memcpy_0(&v30[v2->cbBuffer], v3->pvBuffer, v3->cbBuffer);
    v5 = 1;
    v15 = *((_DWORD *)a1 + 6);
    v17 = v30;
    v18 = v29;
    v8 = WPP_GLOBAL_Control;
    v31 = v2->cbBuffer;
LABEL_36:
    if ( v15 > 0x800 )
    {
      if ( v15 == 4096 || v15 == 0x2000 || v15 == 0x10000 || v15 == 0x20000 || v15 == 0x40000 )
        goto LABEL_53;
      v19 = v15 == 0x80000;
    }
    else
    {
      if ( v15 == 2048 || v15 == 16 || v15 == 32 || v15 == 64 || v15 == 128 || v15 == 256 || v15 == 512 )
        goto LABEL_53;
      v19 = v15 == 1024;
    }
    if ( !v19 )
    {
      v20 = -2146893055;
      goto LABEL_72;
    }
LABEL_53:
    v21 = *((_DWORD *)a1 + 17);
    v22 = v21 + *((_DWORD *)a1 + 16);
    if ( v18 >= v22 )
    {
      if ( v17[1] == -2 && ((unsigned __int8)v17[2] | ((unsigned __int8)v17[1] << 8)) <= 0xFEFFu )
      {
        v23 = (unsigned __int8)v17[11];
        v24 = (unsigned __int8)v17[12];
      }
      else
      {
        v23 = (unsigned __int8)v17[3];
        v24 = (unsigned __int8)v17[4];
      }
      v25 = v21 + (v24 | (v23 << 8));
      if ( v25 < v22 )
      {
        v20 = -2146893048;
        v34 = 50;
        goto LABEL_72;
      }
      if ( v18 >= v25 )
      {
        if ( (v15 & 0x3000) != 0 )
          v26 = Tls13DecryptHandler(a1, (struct SPBuffer *)&v28, (struct SPBuffer *)&v31, &v34);
        else
          v26 = TlsDecryptHandler(a1, (struct SPBuffer *)&v28, (struct SPBuffer *)&v31, &v34);
        v20 = v26;
        if ( !v26 || v26 == 590625 )
        {
          v2->cbBuffer = v32;
          v3->cbBuffer = v29 - v32;
          if ( v26 == 590625 )
            *((_DWORD *)a1 + 2) = 76;
        }
        v8 = WPP_GLOBAL_Control;
        v17 = v30;
        goto LABEL_72;
      }
      v29 = v25;
    }
    else
    {
      v29 = v21 + *((_DWORD *)a1 + 16);
    }
    v20 = -2146893032;
LABEL_72:
    if ( v5 )
    {
      LocalFree(v17);
      v8 = WPP_GLOBAL_Control;
    }
    if ( v4 )
    {
      GenerateUserFatalAlertMessage(a1, v4, v34);
      v8 = WPP_GLOBAL_Control;
    }
    if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control
      && ((*((_BYTE *)v8 + 28) & 1) != 0 && v20 || (*((_BYTE *)v8 + 28) & 4) != 0) )
    {
      WPP_SF_DD(*((_QWORD *)v8 + 2), 0x5Du, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v20, v20);
    }
    return v20;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x5Au,
      (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
      -2146893056,
      -2146893056);
  return 2148074240i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018004F728) ----------------------------------------------------
__int64 __fastcall UpdateTrafficSecretAndDeriveNewKey(
        __int64 a1,
        unsigned __int64 *a2,
        unsigned __int64 *a3,
        unsigned __int64 *a4)
{
  unsigned int v8; // eax
  unsigned int v9; // ebx
  CCipherMill *v10; // rcx
  __int64 v11; // rdx
  unsigned __int64 v12; // rax
  unsigned __int64 v14[5]; // [rsp+30h] [rbp-28h] BYREF
  unsigned __int64 v15; // [rsp+60h] [rbp+8h] BYREF

  v15 = 0i64;
  v14[0] = 0i64;
  if ( a1 && a2 && a3 && a4 )
  {
    v8 = SslExpandNextGenTrafficKey(a1, *a2, &v15, 0i64, 0);
    v9 = v8;
    if ( v8 )
    {
      v10 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        goto LABEL_21;
      v11 = 138i64;
    }
    else
    {
      v8 = SslExpandWriteKey(a1, v15, v14, 0i64, 0);
      v9 = v8;
      if ( !v8 )
      {
        if ( *a2 )
          SslFreeObject(*a2, 0i64);
        if ( *a3 )
          SslFreeObject(*a3, 0i64);
        v12 = v15;
        v15 = 0i64;
        *a2 = v12;
        *a3 = v14[0];
        *a4 = 0i64;
        v14[0] = 0i64;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          return v9;
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 140i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
LABEL_21:
        if ( v15 )
          SslFreeObject(v15, 0i64);
        if ( v14[0] )
          SslFreeObject(v14[0], 0i64);
        return v9;
      }
      v10 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        goto LABEL_21;
      v11 = 139i64;
    }
    WPP_SF_D(*((_QWORD *)v10 + 2), v11, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v8);
    goto LABEL_21;
  }
  return 2148074333i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098500: using guessed type __int64 __fastcall SslExpandNextGenTrafficKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098520: using guessed type __int64 __fastcall SslExpandWriteKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);
// 18004F728: using guessed type unsigned __int64 var_28[5];

//----- (000000018004F8F0) ----------------------------------------------------
ULONG WPP_SF_DDDDD(TRACEHANDLE a1, __int64 a2, __int64 a3, int a4, ...)
{
  int v5; // [rsp+A8h] [rbp+20h] BYREF
  __int64 v6; // [rsp+B0h] [rbp+28h] BYREF
  va_list va; // [rsp+B0h] [rbp+28h]
  __int64 v8; // [rsp+B8h] [rbp+30h] BYREF
  va_list va1; // [rsp+B8h] [rbp+30h]
  __int64 v10; // [rsp+C0h] [rbp+38h] BYREF
  va_list va2; // [rsp+C0h] [rbp+38h]
  va_list va3; // [rsp+C8h] [rbp+40h] BYREF

  va_start(va3, a4);
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  v6 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v8 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v10 = va_arg(va3, _QWORD);
  v5 = a4;
  return TraceMessage(
           a1,
           0x2Bu,
           &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
           0x65u,
           &v5,
           4i64,
           va,
           4i64,
           va1,
           4i64,
           va2,
           4i64,
           va3,
           4i64,
           0i64);
}

//----- (000000018004F974) ----------------------------------------------------
ULONG WPP_SF_ddd(TRACEHANDLE a1, __int64 a2, __int64 a3, int a4, ...)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF
  __int64 v6; // [rsp+90h] [rbp+28h] BYREF
  va_list va; // [rsp+90h] [rbp+28h]
  va_list va1; // [rsp+98h] [rbp+30h] BYREF

  va_start(va1, a4);
  va_start(va, a4);
  v6 = va_arg(va1, _QWORD);
  v5 = a4;
  return TraceMessage(
           a1,
           0x2Bu,
           &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
           0x51u,
           &v5,
           4i64,
           va,
           4i64,
           va1,
           4i64,
           0i64);
}

//----- (000000018004F9DC) ----------------------------------------------------
__int64 __fastcall SpMarshallSupplementalCredsV4(__int64 a1, unsigned __int8 *a2, unsigned int *a3, char **a4)
{
  unsigned int v4; // ebx
  unsigned int v8; // r14d
  CCipherMill *v9; // rcx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  char *v13; // rax
  char *v14; // rsi
  bool v15; // zf
  char *v16; // r15

  v4 = 0;
  v8 = 80;
  v9 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 28i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
    v9 = WPP_GLOBAL_Control;
  }
  if ( a2 && a4 && a3 && (unsigned int)(*(_DWORD *)a2 - 3) <= 1 )
  {
    v10 = *((_DWORD *)a2 + 1);
    if ( v10 )
      v8 = 8 * v10 + 80;
    v11 = *((_DWORD *)a2 + 10);
    if ( v11 )
      v8 += 4 * v11;
    v12 = *((_DWORD *)a2 + 6);
    if ( v12 )
      v8 += 8 * v12;
    v13 = (char *)LocalAlloc(0x40u, v8);
    v14 = v13;
    if ( v13 )
    {
      v15 = *(_DWORD *)a2 == 3;
      *(_OWORD *)v13 = *(_OWORD *)a2;
      *((_OWORD *)v13 + 1) = *((_OWORD *)a2 + 1);
      *((_OWORD *)v13 + 2) = *((_OWORD *)a2 + 2);
      *((_OWORD *)v13 + 3) = *((_OWORD *)a2 + 3);
      if ( v15 )
        *((_QWORD *)v13 + 8) = *((_QWORD *)a2 + 8);
      else
        *((_OWORD *)v13 + 4) = *((_OWORD *)a2 + 4);
      v16 = v13 + 80;
      if ( *((_DWORD *)a2 + 1) )
      {
        memcpy_0(v13 + 80, *((const void **)a2 + 1), 8i64 * *((unsigned int *)a2 + 1));
        *((_QWORD *)v14 + 1) = v16;
        *((_DWORD *)v14 + 1) = *((_DWORD *)a2 + 1);
        v16 += 8 * *((unsigned int *)a2 + 1);
      }
      if ( *((_DWORD *)a2 + 6) )
      {
        memcpy_0(v16, *((const void **)a2 + 4), 8i64 * *((unsigned int *)a2 + 6));
        *((_QWORD *)v14 + 4) = v16;
        *((_DWORD *)v14 + 6) = *((_DWORD *)a2 + 6);
        v16 += 8 * *((unsigned int *)a2 + 6);
      }
      if ( *((_DWORD *)a2 + 10) )
      {
        memcpy_0(v16, *((const void **)a2 + 6), 4i64 * *((unsigned int *)a2 + 10));
        *((_QWORD *)v14 + 6) = v16;
        *((_DWORD *)v14 + 10) = *((_DWORD *)a2 + 10);
      }
      *a3 = v8;
      *a4 = v14;
    }
    else
    {
      v4 = -1073741801;
    }
    v9 = WPP_GLOBAL_Control;
  }
  else
  {
    v4 = -1073741811;
  }
  if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)v9 + 2), 29i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, v4);
  return v4;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018004FBD0) ----------------------------------------------------
__int64 __fastcall SpExportSecurityContext(__int64 a1, char a2, __int64 a3, void **a4)
{
  _QWORD *v8; // r14
  struct CSslUserContext *UserContext; // rax
  __int64 v10; // rdi
  int v12; // r15d
  unsigned int v13; // ebp
  CCipherMill *v14; // rcx
  void *v15; // rdx
  int v16; // ebx
  __int64 v17; // [rsp+20h] [rbp-58h]
  __int64 v18; // [rsp+40h] [rbp-38h] BYREF
  __int128 v19; // [rsp+48h] [rbp-30h]
  int v20; // [rsp+58h] [rbp-20h]
  int v21; // [rsp+5Ch] [rbp-1Ch]

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 32i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
  if ( a4 )
    *a4 = 0i64;
  *(_DWORD *)a3 = 0;
  v8 = (_QWORD *)(a3 + 8);
  *(_QWORD *)(a3 + 8) = 0i64;
  *(_DWORD *)(a3 + 4) = 0;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x21u, (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, a1);
  UserContext = SslFindUserContext(a1);
  v10 = (__int64)UserContext;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_q(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x22u,
      (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids,
      UserContext);
  if ( !v10 )
    return 2148074241i64;
  if ( *(_DWORD *)(v10 + 8) != 4 )
    return 2148074263i64;
  v20 = 0;
  v21 = 0;
  v12 = a2 & 2;
  v18 = v10;
  v19 = 0i64;
  v13 = CSslSerializeHelper::SerializeContext(
          (CSslSerializeHelper *)&v18,
          0i64,
          (unsigned __int8 **)(a3 + 8),
          (unsigned int *)a3);
  v14 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 35i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, v13);
    v14 = WPP_GLOBAL_Control;
  }
  if ( v13 )
    return 2148074281i64;
  if ( !a4 )
    goto LABEL_26;
  v15 = *(void **)(v10 + 264);
  if ( !v15 )
    goto LABEL_26;
  if ( v12 )
  {
    *a4 = v15;
    *(_QWORD *)(v10 + 264) = 0i64;
LABEL_25:
    v14 = WPP_GLOBAL_Control;
LABEL_26:
    v16 = 0;
    goto LABEL_27;
  }
  v16 = NtDuplicateObject((HANDLE)0xFFFFFFFFFFFFFFFFi64, v15, (HANDLE)0xFFFFFFFFFFFFFFFFi64, a4, 0, 0, 2u);
  if ( v16 >= 0 )
    goto LABEL_25;
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v10 + 16i64))(v10, *v8);
  *v8 = 0i64;
  *(_DWORD *)a3 = 0;
  v14 = WPP_GLOBAL_Control;
LABEL_27:
  if ( v14 != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)v14 + 28) & 1) != 0 && v16 || (*((_BYTE *)v14 + 28) & 4) != 0) )
  {
    LODWORD(v17) = v16;
    WPP_SF_DD(*((_QWORD *)v14 + 2), 0x24u, (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, v16, v17);
  }
  return (unsigned int)v16;
}
// 18004FD7F: variable 'v17' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (000000018004FE10) ----------------------------------------------------
__int64 __fastcall SpGetContextToken(__int64 a1, _QWORD *a2)
{
  struct CSslUserContext *UserContext; // rax
  struct CSslUserContext *v5; // rcx
  __int64 result; // rax
  __int64 v7; // rax
  unsigned int v8; // ecx

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 27i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
  UserContext = SslFindUserContext(a1);
  v5 = UserContext;
  if ( !UserContext )
    return 2148074241i64;
  v7 = *((_QWORD *)UserContext + 33);
  if ( v7 )
  {
    *a2 = v7;
    return 0i64;
  }
  else
  {
    v8 = *((_DWORD *)v5 + 68);
    result = 2148074251i64;
    if ( v8 )
      return v8;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018004FEA0) ----------------------------------------------------
__int64 __fastcall SpImportSecurityContext(struct _SecBuffer *a1, void *a2, _QWORD *a3)
{
  CCipherMill *v6; // rcx
  __int64 result; // rax
  signed __int32 v8; // eax
  __int64 v9; // rbx
  int v10; // [rsp+20h] [rbp-18h]

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 37i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
  if ( (unsigned int)SchannelInit(1) )
  {
    do
    {
      v8 = _InterlockedIncrement((volatile signed __int32 *)&ExportedContext);
      v9 = v8;
    }
    while ( (v8 & 7) == 0 );
    result = SslAddUserContext(v8, a2, a1, 1);
    if ( (int)result >= 0 )
      *a3 = v9;
  }
  else
  {
    v6 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 38i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
        v6 = WPP_GLOBAL_Control;
      }
      if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 5) != 0 )
      {
        v10 = -2146893052;
        WPP_SF_DD(
          *((_QWORD *)v6 + 2),
          0x27u,
          (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids,
          -2146893052,
          v10);
      }
    }
    return 2148074244i64;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180092F50: using guessed type unsigned __int64 ExportedContext;

//----- (000000018004FFB0) ----------------------------------------------------
__int64 __fastcall ConvertCertificateAlgToTlsSignatureAlgorithm(unsigned int a1, __int64 a2, __int64 a3)
{
  unsigned int v4; // ebx
  int SignatureDetailsFromAlgId; // eax
  unsigned int v7; // [rsp+40h] [rbp+8h] BYREF

  if ( a1 == 8704 )
  {
    return 2;
  }
  else
  {
    v4 = 3;
    if ( a1 != 8707 )
    {
      if ( a1 == 9216 || a1 == 41984 )
      {
        return 1;
      }
      else
      {
        SignatureDetailsFromAlgId = I_GetSignatureDetailsFromAlgId(a1, a2, a3, &v7, 0i64);
        v4 = v7;
        if ( (SignatureDetailsFromAlgId || !v7)
          && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids, a1);
        }
      }
    }
  }
  return v4;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018005004C) ----------------------------------------------------
ULONG WPP_SF_qD(TRACEHANDLE a1, USHORT a2, const GUID *a3, ...)
{
  __int64 v4; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+78h] [rbp+20h]
  va_list va1; // [rsp+80h] [rbp+28h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  return TraceMessage(a1, 0x2Bu, a3, a2, va, 8i64, va1, 4i64, 0i64);
}

//----- (00000001800500A0) ----------------------------------------------------
ULONG WPP_SF_qSD(TRACEHANDLE a1, __int64 a2, __int64 a3, ...)
{
  const wchar_t *v3; // rdx
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v7; // [rsp+88h] [rbp+20h] BYREF
  va_list va; // [rsp+88h] [rbp+20h]
  const wchar_t *v9; // [rsp+90h] [rbp+28h]
  va_list va1; // [rsp+98h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, const wchar_t *);
  v3 = v9;
  if ( v9 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( v9[v4] );
    v5 = 2 * v4 + 2;
  }
  else
  {
    v5 = 10i64;
  }
  if ( !v9 )
    v3 = L"NULL";
  return TraceMessage(
           a1,
           0x2Bu,
           &WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids,
           0x17u,
           va,
           8i64,
           v3,
           v5,
           va1,
           4i64,
           0i64);
}
// 180083C60: using guessed type wchar_t aNull_0[5];

//----- (0000000180050148) ----------------------------------------------------
__int64 __fastcall Tls13DecryptHandler(
        struct CSslUserContext *a1,
        struct SPBuffer *a2,
        struct SPBuffer *a3,
        unsigned __int8 *a4)
{
  _BYTE *v8; // r14
  CCipherMill *v10; // rcx
  unsigned __int16 v11; // dx
  unsigned int v12; // r8d
  int v13; // r9d
  unsigned int v14; // edx
  CCipherMill *v15; // rcx
  unsigned __int16 v16; // dx
  int v17; // ecx
  int v18; // eax
  unsigned int v19; // r12d
  int v20; // r8d
  __int64 v21; // rcx
  __int64 v22; // rdx
  __int64 v23; // rcx
  unsigned int v24; // eax
  CCipherMill *v25; // rcx
  CCipherMill *v26; // rcx
  __int64 v27; // rcx
  unsigned __int8 *v28; // rdx
  bool v29; // zf
  int v30; // ecx
  CCipherMill *v31; // rcx
  int v32; // r9d
  int v33; // r12d
  int v34; // ecx
  int v35; // ecx
  unsigned __int8 *v36; // rcx
  CCipherMill *v37; // rcx
  __int16 v38; // ax
  CCipherMill *v39; // rcx
  unsigned int v40; // esi
  unsigned __int16 v41; // dx
  unsigned int v42; // eax
  _BYTE *v43; // [rsp+20h] [rbp-68h]
  int v44; // [rsp+28h] [rbp-60h]
  __int64 v45; // [rsp+38h] [rbp-50h]
  unsigned int v46; // [rsp+50h] [rbp-38h]
  unsigned int v47; // [rsp+54h] [rbp-34h]
  unsigned __int8 *Src; // [rsp+58h] [rbp-30h]
  size_t Size; // [rsp+90h] [rbp+8h] BYREF

  if ( !a1 || !a2 || (v8 = (_BYTE *)*((_QWORD *)a2 + 1)) == 0i64 || !a3 || !*((_QWORD *)a3 + 1) || !a4 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xAu,
        (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
        -2146892963,
        -2146892963);
    return 2148074333i64;
  }
  if ( (*((_DWORD *)a1 + 6) & 0x3000) == 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xBu,
        (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
        -2146893055,
        -2146893055);
    return 2148074241i64;
  }
  if ( *((_DWORD *)a1 + 2) != 4 && *((_DWORD *)a1 + 2) != 79 )
  {
    v10 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
      return 2148074248i64;
    v11 = 12;
LABEL_96:
    LODWORD(v43) = -2146893048;
    WPP_SF_DD(*((_QWORD *)v10 + 2), v11, (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, -2146893048, v43);
    return 2148074248i64;
  }
  v12 = *((_DWORD *)a2 + 1);
  v13 = *((_DWORD *)a1 + 17);
  v14 = v13 + *((_DWORD *)a1 + 16);
  *((_DWORD *)a2 + 1) = 0;
  if ( v12 < v14 )
  {
    *((_DWORD *)a2 + 1) = v14;
    v15 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
      return 2148074264i64;
    v16 = 13;
LABEL_29:
    WPP_SF_DD(
      *((_QWORD *)v15 + 2),
      v16,
      (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
      -2146893032,
      -2146893032);
    return 2148074264i64;
  }
  if ( v8[1] == 0xFE && ((unsigned __int8)v8[2] | ((unsigned __int8)v8[1] << 8)) <= 0xFEFFu )
  {
    v17 = (unsigned __int8)v8[11];
    v18 = (unsigned __int8)v8[12];
  }
  else
  {
    v17 = (unsigned __int8)v8[3];
    v18 = (unsigned __int8)v8[4];
  }
  v19 = (v18 | (v17 << 8)) + v13;
  v47 = v19;
  if ( v12 < v19 )
  {
    *((_DWORD *)a2 + 1) = v19;
    v15 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
      return 2148074264i64;
    v16 = 14;
    goto LABEL_29;
  }
  v20 = v12 - v14;
  v45 = *((_QWORD *)a1 + 12);
  v21 = v14;
  v22 = *((_QWORD *)a1 + 5);
  v44 = v20;
  v43 = &v8[v21];
  Src = &v8[v21];
  v23 = *((_QWORD *)a1 + 11);
  LODWORD(Size) = v20;
  v24 = SslDecryptPacket(v23, v22, v8);
  v46 = v24;
  v25 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v24);
      v25 = WPP_GLOBAL_Control;
    }
    if ( v25 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v25 + 28) & 4) != 0 )
      {
        WPP_SF_D(*((_QWORD *)v25 + 2), 16i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, (unsigned int)Size);
        v25 = WPP_GLOBAL_Control;
      }
      if ( v25 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v25 + 28) & 4) != 0 )
        WPP_SF_i(
          *((_QWORD *)v25 + 2),
          0x11u,
          (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
          *((_QWORD *)a1 + 12),
          v43,
          v44,
          &Size,
          v45,
          0);
    }
  }
  *((_DWORD *)a2 + 1) += v19;
  ++*((_QWORD *)a1 + 12);
  if ( v46 )
  {
    v26 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v46);
      v26 = WPP_GLOBAL_Control;
    }
    *a4 = 20;
    if ( v26 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v26 + 28) & 5) != 0 )
    {
      LODWORD(v43) = -2146893008;
      WPP_SF_Dd(
        *((_QWORD *)v26 + 2),
        0x13u,
        (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
        -2146893008,
        v43);
    }
    return 2148074288i64;
  }
  LODWORD(v27) = Size;
  v28 = Src;
  do
  {
    v29 = (_DWORD)v27 == 1;
    v27 = (unsigned int)(v27 - 1);
    LODWORD(Size) = v27;
  }
  while ( !v29 && !Src[v27] );
  v30 = Src[v27];
  if ( !(_BYTE)v30 )
  {
    v31 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
      v31 = WPP_GLOBAL_Control;
    }
    *a4 = 10;
    if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v31 + 28) & 5) != 0 )
    {
      LODWORD(v43) = -2146893048;
      WPP_SF_Dd(
        *((_QWORD *)v31 + 2),
        0x15u,
        (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
        -2146893048,
        v43);
    }
    return 2148074248i64;
  }
  *v8 = v30;
  v32 = v30;
  v33 = *Src;
  v34 = v30 - 21;
  if ( !v34 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 30i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
    v42 = TlsParseAlertMessage(Src, Size, (unsigned __int8 *)a1 + 112, 0i64);
    *((_DWORD *)a3 + 1) = 0;
    v40 = v42;
    v39 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
      || ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 || !v42) && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
    {
      return v40;
    }
    v41 = 31;
    goto LABEL_101;
  }
  v35 = v34 - 1;
  if ( !v35 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
    *((_BYTE *)a1 + 112) = 0;
    *((_DWORD *)a3 + 1) = 0;
    if ( v33 != 4 && (_BYTE)v33 != 11 && (_BYTE)v33 != 13 && (_BYTE)v33 != 24 )
    {
      v10 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_d(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x18u,
          (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
          v33);
        v10 = WPP_GLOBAL_Control;
      }
      *a4 = 10;
      if ( v10 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v10 + 28) & 5) == 0 )
        return 2148074248i64;
      v11 = 25;
      goto LABEL_96;
    }
    v38 = Size;
    *((_DWORD *)a2 + 1) -= v47;
    *(_WORD *)&v8[v47 - 2] = v38;
    *((_DWORD *)a1 + 2) = 78;
    v39 = WPP_GLOBAL_Control;
    v40 = 590625;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
      return v40;
    v41 = 23;
LABEL_101:
    LODWORD(v43) = v40;
    WPP_SF_DD(*((_QWORD *)v39 + 2), v41, (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v40, v43);
    return v40;
  }
  if ( v35 != 1 )
  {
    v10 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_d(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x20u,
        (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
        v32);
      v10 = WPP_GLOBAL_Control;
    }
    *a4 = 10;
    if ( v10 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v10 + 28) & 5) == 0 )
      return 2148074248i64;
    v11 = 33;
    goto LABEL_96;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 26i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
    v28 = Src;
  }
  *((_BYTE *)a1 + 112) = 0;
  v36 = (unsigned __int8 *)*((_QWORD *)a3 + 1);
  if ( v36 != v28 )
  {
    if ( *(_DWORD *)a3 < (unsigned int)Size )
    {
      v37 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 27i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
        v37 = WPP_GLOBAL_Control;
      }
      *a4 = 20;
      if ( v37 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v37 + 28) & 5) != 0 )
      {
        LODWORD(v43) = -2146893008;
        WPP_SF_DD(
          *((_QWORD *)v37 + 2),
          0x1Cu,
          (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
          -2146893008,
          v43);
      }
      return 2148074288i64;
    }
    memcpy_0(v36, v28, (unsigned int)Size);
  }
  *((_DWORD *)a3 + 1) = Size;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    LODWORD(v43) = 0;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x1Du,
      (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
      0,
      v43);
  }
  return 0i64;
}
// 180050454: variable 'v43' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800984E0: using guessed type __int64 __fastcall SslDecryptPacket(_QWORD, _QWORD, _QWORD);

//----- (0000000180050800) ----------------------------------------------------
struct CSslUserContext *__fastcall SslFindUserContextEx(union _LARGE_INTEGER *a1)
{
  CCipherMill *v2; // rcx
  unsigned int v3; // edi
  __int64 v4; // rsi
  _QWORD **v5; // rdx
  _QWORD *v6; // rax
  _QWORD *v7; // rbx

  v2 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 24i64, &WPP_ba773d91511536867a821af0ee22c47a_Traceguids);
      v2 = WPP_GLOBAL_Control;
    }
    if ( v2 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v2 + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)v2 + 2), 25i64, &WPP_ba773d91511536867a821af0ee22c47a_Traceguids);
      v2 = WPP_GLOBAL_Control;
    }
  }
  v3 = 0;
  if ( dwSslContextListCount )
  {
    while ( 1 )
    {
      v4 = 96i64 * (v3 & (dwSslContextLockCount - 1));
      RtlAcquireResourceShared((PRTL_RESOURCE)((char *)SslContextLock + v4), 1u);
      v5 = (_QWORD **)((char *)SslContextList + 16 * v3);
      v6 = *v5;
      if ( *v5 != v5 )
        break;
LABEL_11:
      RtlReleaseResource((PRTL_RESOURCE)((char *)SslContextLock + v4));
      if ( ++v3 >= dwSslContextListCount )
      {
        v2 = WPP_GLOBAL_Control;
        goto LABEL_13;
      }
    }
    while ( 1 )
    {
      v7 = v6 - 38;
      if ( a1->QuadPart == *(v6 - 1) )
        break;
      v6 = (_QWORD *)*v6;
      if ( v6 == v5 )
        goto LABEL_11;
    }
    RtlReleaseResource((PRTL_RESOURCE)((char *)SslContextLock + v4));
    v2 = WPP_GLOBAL_Control;
  }
  else
  {
LABEL_13:
    v7 = 0i64;
  }
  if ( v2 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v2 + 28) & 4) != 0 )
    WPP_SF_q(*((_QWORD *)v2 + 2), 0x1Au, (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids, v7);
  return (struct CSslUserContext *)v7;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800919E0: using guessed type unsigned int dwSslContextListCount;
// 1800919E4: using guessed type unsigned int dwSslContextLockCount;

//----- (0000000180050980) ----------------------------------------------------
void __fastcall FreeExtVirtualAlloc(void *a1)
{
  HANDLE CurrentProcess; // rax
  PVOID BaseAddress; // [rsp+30h] [rbp+8h] BYREF
  ULONG_PTR RegionSize; // [rsp+38h] [rbp+10h] BYREF

  BaseAddress = a1;
  RegionSize = 0i64;
  CurrentProcess = GetCurrentProcess();
  NtFreeVirtualMemory(CurrentProcess, &BaseAddress, &RegionSize, 0x8000u);
}

//----- (00000001800509D0) ----------------------------------------------------
PVOID __fastcall PvExtVirtualAlloc(unsigned int a1)
{
  HANDLE CurrentProcess; // rax
  NTSTATUS v2; // eax
  PVOID v3; // rcx
  PVOID BaseAddress; // [rsp+48h] [rbp+10h] BYREF
  ULONG_PTR RegionSize; // [rsp+50h] [rbp+18h] BYREF

  BaseAddress = 0i64;
  RegionSize = a1;
  CurrentProcess = GetCurrentProcess();
  v2 = NtAllocateVirtualMemory(CurrentProcess, &BaseAddress, 0i64, &RegionSize, 0x1000u, 4u);
  v3 = BaseAddress;
  if ( v2 < 0 )
    return 0i64;
  return v3;
}

//----- (0000000180050A40) ----------------------------------------------------
__int64 __fastcall CloseClientKeyHandleCallback(__int64 a1, DWORD a2, unsigned int *a3)
{
  int v4; // esi
  NCRYPT_HANDLE *v7; // rbx
  __int64 result; // rax
  CCipherMill *v9; // rcx
  SECURITY_STATUS v10; // eax
  BOOL v11; // eax

  v4 = 0;
  if ( !(unsigned int)SchannelInit(1) )
    return 1359i64;
  if ( !a3 )
    return 1359i64;
  v7 = (NCRYPT_HANDLE *)*((_QWORD *)a3 + 1);
  if ( !v7 )
    return 1359i64;
  if ( *a3 < (unsigned __int64)(16 * a1) )
    return 2148074264i64;
  if ( !a1 )
    goto LABEL_22;
  v9 = WPP_GLOBAL_Control;
  do
  {
    if ( *v7 )
    {
      v10 = NCryptFreeObject(*v7);
      v9 = WPP_GLOBAL_Control;
      v4 = v10;
    }
    if ( v4 < 0 && v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 1) != 0 )
    {
      WPP_SF_q(*((_QWORD *)v9 + 2), 0x30u, (__int64)&WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, v7);
      v9 = WPP_GLOBAL_Control;
    }
    if ( v7[1] )
    {
      v11 = CryptReleaseContext(v7[1], a2);
      v9 = WPP_GLOBAL_Control;
      v4 = v11;
    }
    if ( v4 < 0 && v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 1) != 0 )
    {
      WPP_SF_q(*((_QWORD *)v9 + 2), 0x31u, (__int64)&WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, v7 + 1);
      v9 = WPP_GLOBAL_Control;
    }
    v7 += 2;
    --a1;
  }
  while ( a1 );
  v7 = (NCRYPT_HANDLE *)*((_QWORD *)a3 + 1);
  if ( v7 )
  {
LABEL_22:
    SPExternalFree(v7);
    *((_QWORD *)a3 + 1) = 0i64;
  }
  a3[1] = 0;
  result = (unsigned int)v4;
  *a3 = 0;
  return result;
}

//----- (0000000180050BB0) ----------------------------------------------------
__int64 __fastcall GetAppAppDataStatusCallback(__int64 a1, char a2, __int64 a3, struct _SecBuffer *a4)
{
  union _LARGE_INTEGER *v8; // rcx
  struct CSslUserContext *UserContext; // rax
  void *(__stdcall *v10)(unsigned int); // rdx
  void (__stdcall *v11)(void *); // r8
  unsigned int AppDataStatusCallback; // ebx

  if ( !(unsigned int)SchannelInit(1) || !a3 || !a4 )
    return 2148074244i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 61i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
  v8 = *(union _LARGE_INTEGER **)(a3 + 8);
  if ( v8 && *(_DWORD *)a3 == 8 )
    UserContext = SslFindUserContextEx(v8);
  else
    UserContext = SslFindUserContext(a1);
  if ( UserContext )
  {
    AppDataStatusCallback = GetAppDataStatusCallback(UserContext, v10, v11, a2, a4);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 63i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
    return AppDataStatusCallback;
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 62i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
    return 2148074241i64;
  }
}
// 180050C80: variable 'v10' is possibly undefined
// 180050C80: variable 'v11' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180050CE0) ----------------------------------------------------
__int64 __fastcall GetUserAppCertDataCallback(__int64 a1, char a2, __int64 a3, __int64 a4)
{
  int v4; // ebx
  void *v7; // r13
  unsigned int v8; // esi
  int v9; // edi
  __int64 *v11; // rcx
  __int64 v12; // rcx
  DWORD v13; // eax
  __int64 v14; // rdx
  int v15; // r8d
  void *v16; // r12
  unsigned int v17; // r14d
  const CERT_CONTEXT **v18; // r15
  const CERT_CONTEXT *v19; // rax
  unsigned int v20; // esi
  HCERTSTORE hCertStore; // rcx
  unsigned int v22; // esi
  unsigned int v23; // esi
  DWORD LastError; // eax
  __int64 v25; // rdx
  HLOCAL v26; // rax
  HLOCAL v27; // r12
  _DWORD *v28; // r15
  unsigned int v29; // r14d
  __int64 *v30; // rcx
  int v31; // r14d
  int v32; // eax
  __int64 v33; // rcx
  int v34; // r14d
  __int64 v35; // rax
  CCipherMill *v36; // rcx
  __int64 v37; // rdx
  DWORD pcbElement; // [rsp+38h] [rbp-39h] BYREF
  DWORD v39; // [rsp+3Ch] [rbp-35h]
  int v40; // [rsp+40h] [rbp-31h]
  int v41[2]; // [rsp+48h] [rbp-29h] BYREF
  _DWORD *v42; // [rsp+50h] [rbp-21h]
  __int64 *v43; // [rsp+58h] [rbp-19h]
  int v44[2]; // [rsp+60h] [rbp-11h] BYREF
  __int64 v45; // [rsp+68h] [rbp-9h]
  __int64 v46; // [rsp+70h] [rbp-1h]
  __int128 pvSaveToPara; // [rsp+78h] [rbp+7h] BYREF
  const CERT_CONTEXT *v48; // [rsp+88h] [rbp+17h]

  v4 = 0;
  v44[0] = 0;
  v45 = 0i64;
  v7 = 0i64;
  v41[0] = 0;
  v8 = 0;
  v42 = 0i64;
  v9 = 1;
  v44[1] = 1;
  v41[1] = 1;
  if ( !(unsigned int)SchannelInit(1) )
    return 2148074244i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 64i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
  if ( !a4 )
    goto LABEL_64;
  if ( !a3 )
    goto LABEL_64;
  v11 = *(__int64 **)(a3 + 8);
  if ( !v11 )
    goto LABEL_64;
  v12 = *v11;
  if ( (unsigned int)(*(_DWORD *)v12 - 1) > 4 )
    goto LABEL_64;
  if ( *(_DWORD *)v12 == 4 )
  {
    v13 = *(_DWORD *)(v12 + 4);
    v14 = *(_QWORD *)(v12 + 8);
    v15 = *(_DWORD *)(v12 + 72);
    v16 = *(void **)(v12 + 16);
  }
  else
  {
    v13 = *(_DWORD *)(v12 + 8);
    v14 = *(_QWORD *)(v12 + 16);
    v15 = *(_DWORD *)(v12 + 52);
    v16 = *(void **)(v12 + 24);
  }
  v17 = 0;
  v46 = (__int64)v16;
  v40 = v15;
  v43 = (__int64 *)v14;
  v39 = v13;
  if ( v13 )
  {
    v18 = (const CERT_CONTEXT **)v14;
    while ( 1 )
    {
      v19 = *v18;
      pcbElement = 0;
      v48 = v19;
      v20 = v8 + 16;
      if ( !CertSerializeCertificateStoreElement(v19, 0, 0i64, &pcbElement) )
        break;
      v8 = pcbElement + v20;
      if ( (v40 & 0x10000) != 0 )
      {
        hCertStore = v48->hCertStore;
        v22 = v8 + 8;
        pvSaveToPara = 0i64;
        if ( !CertSaveStore(hCertStore, 1u, 1u, 2u, &pvSaveToPara, 0) )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            LastError = GetLastError();
            v25 = 66i64;
            goto LABEL_31;
          }
          goto LABEL_32;
        }
        v8 = pvSaveToPara + v22;
      }
      ++v17;
      ++v18;
      if ( v17 >= v39 )
        goto LABEL_20;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      LastError = GetLastError();
      v25 = 65i64;
      goto LABEL_31;
    }
    goto LABEL_32;
  }
LABEL_20:
  if ( !v16 )
  {
LABEL_34:
    if ( v8 )
    {
      if ( (a2 & 8) != 0 )
        v26 = SPExternalAlloc(v8);
      else
        v26 = PvExtVirtualAlloc(v8);
      v7 = v26;
      v27 = v26;
      if ( !v26 )
        goto LABEL_39;
      pcbElement = 0;
      v28 = v26;
      v29 = v8;
      if ( v39 )
      {
        v30 = v43;
        while ( 1 )
        {
          v45 = *v30;
          v44[0] = 40;
          v31 = v29 - 4;
          v42 = v28 + 1;
          v41[0] = v31;
          v32 = UploadCertContextCallback(0i64, 0i64, (__int64)v44, (__int64)v41);
          v4 = v32;
          if ( v32 < 0 )
            break;
          v33 = (unsigned int)v41[0];
          v29 = v31 - v41[0];
          *v28 = v41[0];
          v28 = (_DWORD *)((char *)v28 + v33 + 4);
          if ( (v40 & 0x10000) != 0 )
          {
            if ( v29 < 4 )
              goto LABEL_39;
            v34 = v29 - 4;
            v42 = v28 + 1;
            v41[0] = v34;
            v32 = UploadCertStoreCallback(1i64, 0i64, (__int64)v44, v41);
            v4 = v32;
            if ( v32 < 0 )
            {
              v36 = WPP_GLOBAL_Control;
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                v37 = 69i64;
                goto LABEL_60;
              }
              goto LABEL_65;
            }
            v35 = (unsigned int)v41[0];
            v29 = v34 - v41[0];
            *v28 = v41[0];
            v28 = (_DWORD *)((char *)v28 + v35 + 4);
          }
          v30 = v43 + 1;
          ++pcbElement;
          ++v43;
          if ( pcbElement >= v39 )
            goto LABEL_48;
        }
        v36 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          v37 = 68i64;
          goto LABEL_60;
        }
        goto LABEL_65;
      }
LABEL_48:
      if ( v46 )
      {
        v45 = v46;
        v44[0] = 8;
        if ( v29 < 4 )
        {
LABEL_39:
          v4 = -2146893056;
          goto LABEL_65;
        }
        v42 = v28 + 1;
        v41[0] = v29 - 4;
        v32 = UploadCertStoreCallback(0i64, 0i64, (__int64)v44, v41);
        v4 = v32;
        if ( v32 < 0 )
        {
          v36 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            v37 = 70i64;
LABEL_60:
            WPP_SF_D(*((_QWORD *)v36 + 2), v37, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, (unsigned int)v32);
          }
          goto LABEL_65;
        }
        *v28 = v41[0];
      }
      if ( v4 >= 0 )
        goto LABEL_69;
      goto LABEL_65;
    }
LABEL_64:
    v4 = -2146893052;
    goto LABEL_65;
  }
  pvSaveToPara = 0i64;
  v23 = v8 + 8;
  if ( CertSaveStore(v16, 1u, 1u, 2u, &pvSaveToPara, 0) )
  {
    v8 = pvSaveToPara + v23;
    goto LABEL_34;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    LastError = GetLastError();
    v25 = 67i64;
LABEL_31:
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), v25, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, LastError);
  }
LABEL_32:
  v4 = -2146893043;
LABEL_65:
  if ( (a2 & 8) != 0 )
    SPExternalFree(v7);
  else
    FreeExtVirtualAlloc(v7);
  v8 = 0;
  v27 = 0i64;
  v9 = 0;
LABEL_69:
  *(_DWORD *)(a4 + 4) = v9;
  *(_QWORD *)(a4 + 8) = v27;
  *(_DWORD *)a4 = v8;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 71i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
  return (unsigned int)v4;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800511B0) ----------------------------------------------------
__int64 __fastcall OpenClientKeyHandleCallback(unsigned __int64 a1, char a2, int *a3, __int64 a4)
{
  unsigned int v4; // ebx
  char v8; // r14
  CCipherMill *v9; // rcx
  int v10; // r12d
  unsigned int v11; // ecx
  int v12; // r14d
  _QWORD *v13; // rax
  _QWORD *v14; // r15
  int v15; // r10d
  __int64 v16; // r14
  int v17; // r10d
  int v18; // eax
  unsigned int v19; // r10d
  __int64 v20; // rcx
  __int128 v21; // xmm0
  DWORD v22; // r13d
  unsigned int v23; // esi
  DWORD v24; // ebx
  __int64 v25; // rdx
  const WCHAR *v26; // r9
  unsigned int v27; // eax
  const WCHAR *v28; // r8
  bool v29; // zf
  CCipherMill *v30; // rcx
  CCipherMill *v31; // rcx
  int v32; // eax
  unsigned __int64 v33; // r8
  unsigned __int64 *v34; // r15
  void *v35; // rcx
  int v37; // [rsp+48h] [rbp-29h] BYREF
  LPCWSTR pszProviderName; // [rsp+50h] [rbp-21h]
  LPCWSTR pszKeyName; // [rsp+58h] [rbp-19h]
  NCRYPT_KEY_HANDLE phKey; // [rsp+60h] [rbp-11h] BYREF
  int v41; // [rsp+68h] [rbp-9h]
  int v42; // [rsp+6Ch] [rbp-5h]
  unsigned __int64 v43; // [rsp+70h] [rbp-1h] BYREF
  __int64 v44; // [rsp+78h] [rbp+7h]
  __int128 v45; // [rsp+80h] [rbp+Fh]

  pszKeyName = 0i64;
  v4 = 0;
  pszProviderName = 0i64;
  v37 = 0;
  phKey = 0i64;
  v43 = 0i64;
  v8 = a2;
  if ( !(unsigned int)SchannelInit(1) || !a3 || !a4 )
    return 1359i64;
  *(_DWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0i64;
  *(_DWORD *)(a4 + 4) = 0;
  v9 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 36i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
    v9 = WPP_GLOBAL_Control;
  }
  v10 = 8;
  if ( *((_QWORD *)a3 + 1) )
  {
    *(_DWORD *)(a4 + 4) = 1;
    v11 = 36 * a1;
    *(_DWORD *)a4 = 36 * a1;
    v12 = v8 & 4;
    if ( v12 )
    {
      v11 += 8;
      *(_DWORD *)a4 = v11;
    }
    v13 = SPExternalAlloc(v11);
    *(_QWORD *)(a4 + 8) = v13;
    v14 = v13;
    if ( v13 )
    {
      if ( v12 )
      {
        *v13 = **((_QWORD **)a3 + 1);
        v14 = v13 + 1;
      }
      v15 = *a3;
      v16 = *((_QWORD *)a3 + 1) + 8i64;
      v44 = 0i64;
      v17 = v15 - 8;
      if ( a1 )
      {
        while ( 1 )
        {
          v18 = *(_DWORD *)(v16 + 20);
          v19 = v17 - *(_DWORD *)v16;
          v20 = *(unsigned int *)(v16 + 36);
          v21 = *(_OWORD *)(v16 + 4);
          v22 = *(_DWORD *)(v16 + 24);
          v23 = *(_DWORD *)(v16 + 28);
          v24 = *(_DWORD *)(v16 + 32);
          v25 = *(unsigned int *)(v16 + 40);
          v16 += 44i64;
          v41 = v18;
          v26 = (const WCHAR *)v16;
          v27 = v20 + 44;
          v42 = v19;
          v45 = v21;
          if ( (unsigned int)v20 >= 0xFFFFFFD4 || (unsigned int)v25 + v27 < v27 )
            break;
          if ( v19 < (unsigned int)v25 + v27 )
          {
            v4 = 1359;
            goto LABEL_66;
          }
          if ( (_DWORD)v20 )
            v16 += v20;
          v28 = (const WCHAR *)v16;
          if ( !(_DWORD)v20 )
            v26 = pszKeyName;
          pszKeyName = v26;
          v29 = (_DWORD)v25 == 0;
          if ( (_DWORD)v25 )
          {
            v16 += v25;
            v29 = (_DWORD)v25 == 0;
          }
          if ( v29 )
            v28 = pszProviderName;
          v30 = WPP_GLOBAL_Control;
          pszProviderName = v28;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
          {
            if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_S(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0x25u,
                (__int64)&WPP_e7a188b1921532aa285b79366435dd9d_Traceguids,
                v26);
              v30 = WPP_GLOBAL_Control;
              v28 = pszProviderName;
            }
            if ( v30 != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_BYTE *)v30 + 28) & 4) != 0 )
              {
                WPP_SF_S(*((_QWORD *)v30 + 2), 0x26u, (__int64)&WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, v28);
                v30 = WPP_GLOBAL_Control;
              }
              if ( v30 != (CCipherMill *)&WPP_GLOBAL_Control )
              {
                if ( (*((_BYTE *)v30 + 28) & 4) != 0 )
                {
                  WPP_SF_D(*((_QWORD *)v30 + 2), 39i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, v24);
                  v30 = WPP_GLOBAL_Control;
                }
                if ( v30 != (CCipherMill *)&WPP_GLOBAL_Control )
                {
                  if ( (*((_BYTE *)v30 + 28) & 4) != 0 )
                  {
                    WPP_SF_D(*((_QWORD *)v30 + 2), 40i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, v22);
                    v30 = WPP_GLOBAL_Control;
                  }
                  if ( v30 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v30 + 28) & 4) != 0 )
                    WPP_SF_D(*((_QWORD *)v30 + 2), 41i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, v23);
                }
              }
            }
          }
          v4 = OpenKeyUsingCng(&phKey, pszKeyName, pszProviderName, v24, v23, 1, &v37);
          if ( v4 )
          {
            if ( v37 )
            {
              v9 = WPP_GLOBAL_Control;
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
              {
                WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 42i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
LABEL_59:
                v9 = WPP_GLOBAL_Control;
              }
LABEL_60:
              v4 = -2146893043;
              goto LABEL_67;
            }
            phKey = 0i64;
            v4 = OpenKeyUsingCAPI(&v43, pszKeyName, pszProviderName, v22, v23);
            if ( v4 )
            {
              v9 = WPP_GLOBAL_Control;
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                WPP_SF_D(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  43i64,
                  &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids,
                  v4);
                goto LABEL_59;
              }
              goto LABEL_60;
            }
          }
          v31 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
          {
            if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 44i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
              v31 = WPP_GLOBAL_Control;
            }
            if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_BYTE *)v31 + 28) & 4) != 0 )
              {
                WPP_SF_q(*((_QWORD *)v31 + 2), 0x2Du, (__int64)&WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, phKey);
                v31 = WPP_GLOBAL_Control;
              }
              if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v31 + 28) & 4) != 0 )
                WPP_SF_q(*((_QWORD *)v31 + 2), 0x2Eu, (__int64)&WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, v43);
            }
          }
          v32 = v41;
          v33 = ++v44;
          *(_OWORD *)v14 = v45;
          *((_DWORD *)v14 + 4) = v32;
          v34 = (_QWORD *)((char *)v14 + 20);
          *v34++ = phKey;
          *v34 = v43;
          v14 = v34 + 1;
          if ( v33 >= a1 )
            goto LABEL_66;
          v17 = v42;
        }
        v4 = 534;
      }
    }
    else
    {
      v4 = 14;
    }
LABEL_66:
    v9 = WPP_GLOBAL_Control;
LABEL_67:
    v8 = a2;
  }
  else
  {
    v4 = 1359;
  }
  if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)v9 + 2), 47i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
  if ( v4 )
  {
    if ( (v8 & 4) == 0 )
    {
      v35 = *(void **)(a4 + 8);
      if ( v35 )
        SPExternalFree(v35);
      *(_QWORD *)(a4 + 8) = 0i64;
      *(_DWORD *)(a4 + 4) = 0;
      v10 = 0;
    }
    *(_DWORD *)a4 = v10;
    return 0;
  }
  return v4;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180051690) ----------------------------------------------------
__int64 __fastcall SetAppMtuCallback(__int64 a1, char a2, struct _SecBuffer *a3)
{
  struct CSslUserContext *UserContext; // rax
  unsigned int v8; // ebx

  if ( !(unsigned int)SchannelInit(1) || !a3 )
    return 2148074244i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 58i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
  if ( a3->cbBuffer == 12 )
    UserContext = SslFindUserContextEx((union _LARGE_INTEGER *)a3->pvBuffer);
  else
    UserContext = SslFindUserContext(a1);
  if ( UserContext )
  {
    v8 = SetMtuCallback(UserContext, a2, a3);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 60i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
    return v8;
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 59i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
    return 2148074241i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (00000001800517A0) ----------------------------------------------------
__int64 __fastcall SignHashCallback(NCRYPT_HANDLE a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // r14d
  unsigned int v7; // esi
  __int64 v8; // r13
  CCipherMill *v9; // rcx
  unsigned int v10; // r14d
  unsigned int *v11; // rdx
  __int64 v13; // r9
  DWORD v14; // r8d
  DWORD v15; // ebx
  __int64 v16; // rsi
  __int64 v17; // r12
  __int64 v18; // r15
  unsigned int v19; // eax
  unsigned int v20; // edx
  unsigned int v21; // eax
  DWORD v22; // ebx
  const wchar_t *v23; // r9
  DWORD v24; // r12d
  BYTE *v25; // r14
  __int64 *v26; // rsi
  DWORD v27; // r15d
  NCRYPT_KEY_HANDLE v28; // r13
  unsigned int v29; // eax
  BYTE *pbSignature; // rax
  CCipherMill *v31; // rcx
  __int64 v32; // rdx
  __int64 v33; // r9
  HCRYPTPROV v34; // r13
  DWORD LastError; // eax
  DWORD v36; // eax
  DWORD v37; // esi
  BYTE *v38; // rax
  void *v39; // rcx
  DWORD cbSignature; // [rsp+28h] [rbp-58h]
  DWORD dwKeySpec; // [rsp+40h] [rbp-40h] BYREF
  HCRYPTHASH phHash; // [rsp+48h] [rbp-38h] BYREF
  DWORD dwFlags; // [rsp+50h] [rbp-30h]
  __int64 v44; // [rsp+58h] [rbp-28h] BYREF
  BYTE pbInput[8]; // [rsp+60h] [rbp-20h] BYREF
  DWORD cbHashValue; // [rsp+68h] [rbp-18h]
  ALG_ID Algid; // [rsp+6Ch] [rbp-14h]
  __int128 v48; // [rsp+70h] [rbp-10h] BYREF

  v4 = a1;
  phHash = 0i64;
  v7 = a2;
  v8 = 0i64;
  if ( (unsigned int)SchannelInit(1) && a3 && a4 )
  {
    *(_QWORD *)a4 = 0i64;
    *(_QWORD *)(a4 + 8) = 0i64;
    v9 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
        v9 = WPP_GLOBAL_Control;
      }
      if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
        {
          WPP_SF_D(*((_QWORD *)v9 + 2), 11i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, v4);
          v9 = WPP_GLOBAL_Control;
        }
        if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
        {
          WPP_SF_D(*((_QWORD *)v9 + 2), 12i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, v7);
          v9 = WPP_GLOBAL_Control;
        }
      }
    }
    v10 = *(_DWORD *)a3;
    v11 = *(unsigned int **)(a3 + 8);
    if ( *(_DWORD *)a3 < 0x24u )
      return 2148074264i64;
    v13 = *v11;
    v14 = v11[2];
    dwFlags = v11[1];
    *(_QWORD *)pbInput = *(_QWORD *)(v11 + 3);
    v15 = v11[8];
    v16 = v11[6];
    v17 = v11[7];
    LODWORD(v44) = v11[5];
    *(_QWORD *)&v48 = v11 + 9;
    v18 = (__int64)(v11 + 9);
    Algid = v13;
    dwKeySpec = v14;
    cbHashValue = v15;
    if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
      {
        WPP_SF_D(*((_QWORD *)v9 + 2), 13i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, v13);
        v9 = WPP_GLOBAL_Control;
        v14 = dwKeySpec;
      }
      if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
      {
        WPP_SF_D(*((_QWORD *)v9 + 2), 14i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, v14);
        v9 = WPP_GLOBAL_Control;
      }
    }
    v19 = v16 + 24;
    if ( (unsigned int)v16 >= 0xFFFFFFE8 )
      return 534i64;
    v20 = v19 + v17;
    if ( v19 + (unsigned int)v17 < v19 )
      return 534i64;
    v21 = v20 + v15;
    if ( v20 + v15 < v20 )
      return 534i64;
    v22 = 0;
    if ( v10 >= v21 )
    {
      if ( (_DWORD)v16 )
        v18 += v16;
      v23 = (const wchar_t *)(v48 & -(__int64)((_DWORD)v16 != 0));
      if ( !(_DWORD)v17 )
      {
LABEL_30:
        v24 = cbHashValue;
        v25 = (BYTE *)(v18 & -(__int64)(cbHashValue != 0));
        if ( a2 )
        {
          dwKeySpec = 0;
          v44 = 0i64;
          v26 = 0i64;
          v48 = 0i64;
          if ( v23 && v25 )
          {
            v27 = dwFlags;
            if ( wcsncmp(v23, L"RSA", 3ui64) )
              goto LABEL_38;
            if ( dwFlags == 8 )
            {
              v26 = (__int64 *)&v48;
              *(_QWORD *)&v48 = v8;
              DWORD2(v48) = cbHashValue;
              goto LABEL_38;
            }
            if ( dwFlags == 2 )
            {
              v26 = &v44;
              v44 = v8;
LABEL_38:
              if ( *(_QWORD *)pbInput )
              {
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
                {
                  WPP_SF_q(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    0xFu,
                    (__int64)&WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
                }
                v28 = a1;
                v29 = NCryptSetProperty(a1, L"HWND Handle", pbInput, 8u, 0);
                if ( v29
                  && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                {
                  WPP_SF_D(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    16i64,
                    &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids,
                    v29);
                }
              }
              else
              {
                v28 = a1;
              }
              v22 = NCryptSignHash(v28, v26, v25, v24, 0i64, dwKeySpec, &dwKeySpec, dwFlags);
              if ( v22 )
              {
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                {
                  WPP_SF_D(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    17i64,
                    &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids,
                    v22);
                }
                return v22;
              }
              pbSignature = (BYTE *)SPExternalAlloc(dwKeySpec);
              *(_QWORD *)(a4 + 8) = pbSignature;
              if ( !pbSignature )
                return 14i64;
              cbSignature = dwKeySpec;
              *(_DWORD *)a4 = dwKeySpec;
              v22 = NCryptSignHash(v28, v26, v25, v24, pbSignature, cbSignature, &dwKeySpec, v27);
              if ( v22 )
              {
                v31 = WPP_GLOBAL_Control;
                if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
                  || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
                {
                  goto LABEL_99;
                }
                v32 = 18i64;
                goto LABEL_58;
              }
LABEL_96:
              *(_DWORD *)(a4 + 4) = 1;
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
              {
                WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 27i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
              }
              goto LABEL_99;
            }
          }
          return 1359i64;
        }
        if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
        {
          WPP_SF_(*((_QWORD *)v9 + 2), 19i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
          v9 = WPP_GLOBAL_Control;
        }
        if ( *(_QWORD *)pbInput )
        {
          if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
            WPP_SF_q(*((_QWORD *)v9 + 2), 0x14u, (__int64)&WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
          v34 = a1;
          if ( !CryptSetProvParam(a1, 1u, pbInput, 0)
            && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            LastError = GetLastError();
            WPP_SF_D(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              21i64,
              &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids,
              LastError);
          }
        }
        else
        {
          v34 = a1;
        }
        if ( !CryptCreateHash(v34, Algid, 0i64, 0, &phHash) )
        {
          v36 = GetLastError();
          v22 = v36;
          v31 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_99;
          }
          v32 = 22i64;
          goto LABEL_76;
        }
        if ( (_DWORD)v44 )
        {
          if ( !CryptHashData(phHash, v25, v24, 0) )
          {
            v36 = GetLastError();
            v22 = v36;
            v31 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
            {
              goto LABEL_99;
            }
            v32 = 24i64;
LABEL_76:
            v33 = v36;
            goto LABEL_59;
          }
        }
        else if ( !CryptSetHashParam(phHash, 2u, v25, 0) )
        {
          v36 = GetLastError();
          v22 = v36;
          v31 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_99;
          }
          v32 = 23i64;
          goto LABEL_76;
        }
        v37 = dwKeySpec;
        if ( CryptSignHashW(phHash, dwKeySpec, 0i64, 0, 0i64, (DWORD *)a4) )
        {
          v38 = (BYTE *)SPExternalAlloc(*(_DWORD *)a4);
          *(_QWORD *)(a4 + 8) = v38;
          if ( !v38 )
          {
            v22 = 14;
            goto LABEL_99;
          }
          if ( CryptSignHashW(phHash, v37, 0i64, 0, v38, (DWORD *)a4) )
            goto LABEL_96;
          v22 = GetLastError();
          v31 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_99;
          }
          v32 = 26i64;
        }
        else
        {
          v22 = GetLastError();
          v31 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_99;
          }
          v32 = 25i64;
        }
LABEL_58:
        v33 = v22;
LABEL_59:
        WPP_SF_D(*((_QWORD *)v31 + 2), v32, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, v33);
LABEL_99:
        if ( phHash )
          CryptDestroyHash(phHash);
        if ( v22 )
        {
          v39 = *(void **)(a4 + 8);
          if ( v39 )
          {
            SPExternalFree(v39);
            *(_QWORD *)(a4 + 8) = 0i64;
          }
          *(_DWORD *)a4 = 0;
        }
        return v22;
      }
      if ( (v16 & 1) == 0 )
      {
        v8 = v18;
        v18 += v17;
        goto LABEL_30;
      }
    }
  }
  return 1359i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180051F10) ----------------------------------------------------
__int64 __fastcall UploadCertContextCallback(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // ebx
  CCipherMill *v8; // rcx
  const CERT_CONTEXT *v9; // r14
  __int64 v10; // rcx
  __int64 v11; // rsi
  DWORD pcbElement; // [rsp+20h] [rbp-10h] BYREF
  DWORD pcbData; // [rsp+24h] [rbp-Ch] BYREF
  __int64 pvData; // [rsp+28h] [rbp-8h] BYREF

  v4 = 0;
  pcbData = 8;
  pvData = 0i64;
  pcbElement = 0;
  if ( !(unsigned int)SchannelInit(1) )
    return 2148074244i64;
  v8 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 28i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
    v8 = WPP_GLOBAL_Control;
  }
  if ( a4
    && *(_QWORD *)(a4 + 8)
    && *(_DWORD *)a4 >= 0xCu
    && a3
    && (v9 = *(const CERT_CONTEXT **)(a3 + 8)) != 0i64
    && *(_DWORD *)a3 == 40 )
  {
    if ( CertGetCertificateContextProperty(*(PCCERT_CONTEXT *)(a3 + 8), 1u, &pvData, &pcbData) )
    {
      v10 = pvData;
    }
    else
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 29i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
      v10 = 0i64;
      pvData = 0i64;
    }
    v11 = *(_QWORD *)(a4 + 8);
    pcbElement = *(_DWORD *)a4;
    *(_QWORD *)v11 = v10;
    pcbElement -= 12;
    if ( CertSerializeCertificateStoreElement(v9, 0, (BYTE *)(v11 + 12), &pcbElement) )
    {
      *(_DWORD *)(v11 + 8) = pcbElement;
      *(_DWORD *)a4 = pcbElement + 12;
      v8 = WPP_GLOBAL_Control;
    }
    else
    {
      v8 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 30i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
        v8 = WPP_GLOBAL_Control;
      }
      v4 = -2146893043;
    }
  }
  else
  {
    v4 = -2146893052;
  }
  if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)v8 + 2), 31i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
  return v4;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (00000001800520E0) ----------------------------------------------------
__int64 __fastcall UploadCertStoreCallback(__int64 a1, __int64 a2, __int64 a3, int *a4)
{
  unsigned int v5; // ebx
  CCipherMill *v9; // rcx
  _DWORD *v10; // r14
  int v11; // edx
  _QWORD *v12; // r10
  DWORD LastError; // eax
  __int128 pvSaveToPara; // [rsp+30h] [rbp-28h] BYREF

  v5 = 0;
  pvSaveToPara = 0i64;
  if ( !(unsigned int)SchannelInit(1) )
    return 2148074244i64;
  v9 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 32i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
      v9 = WPP_GLOBAL_Control;
    }
    if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 0x20) != 0 )
    {
      WPP_SF_(*((_QWORD *)v9 + 2), 33i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
      v9 = WPP_GLOBAL_Control;
    }
  }
  if ( a4 )
  {
    v10 = (_DWORD *)*((_QWORD *)a4 + 1);
    if ( v10 )
    {
      v11 = *a4;
      if ( (unsigned int)*a4 >= 4 )
      {
        if ( a3 )
        {
          v12 = *(_QWORD **)(a3 + 8);
          if ( v12 )
          {
            if ( a1 )
            {
              if ( a1 == 1 && *(_DWORD *)a3 == 40 )
              {
                v12 = (_QWORD *)v12[4];
LABEL_19:
                *((_QWORD *)&pvSaveToPara + 1) = v10 + 1;
                LODWORD(pvSaveToPara) = v11 - 4;
                if ( !CertSaveStore(v12, 1u, 1u, 2u, &pvSaveToPara, 0) )
                {
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                  {
                    LastError = GetLastError();
                    WPP_SF_D(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      34i64,
                      &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids,
                      LastError);
                  }
                  v5 = -2146893043;
                }
                *v10 = pvSaveToPara;
                *a4 = pvSaveToPara + 4;
                v9 = WPP_GLOBAL_Control;
                goto LABEL_26;
              }
            }
            else if ( *(_DWORD *)a3 == 8 )
            {
              goto LABEL_19;
            }
          }
        }
      }
    }
  }
  v5 = -2146893052;
LABEL_26:
  if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)v9 + 2), 35i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
  return v5;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800522BC) ----------------------------------------------------
__int64 SslUnsealComputeDecryptErrorDelay(void)
{
  UCHAR v1; // [rsp+40h] [rbp+18h] BYREF
  int v2; // [rsp+48h] [rbp+20h] BYREF
  int pbBuffer; // [rsp+50h] [rbp+28h] BYREF
  int v4; // [rsp+58h] [rbp+30h] BYREF

  pbBuffer = 0;
  BCryptGenRandom(0i64, (PUCHAR)&pbBuffer, 4u, 2u);
  BCryptGenRandom(0i64, (PUCHAR)&v4, 4u, 2u);
  pbBuffer &= 0x3FFFFFu;
  v4 &= 0x3FFFFFu;
  BCryptGenRandom(0i64, (PUCHAR)&v2, 4u, 2u);
  v2 &= 0x1FFFu;
  while ( BCryptGenRandom(0i64, &v1, 1u, 2u) >= 0 && v1 )
    v2 += 0x2000;
  return (unsigned int)(pbBuffer + v4 + v2);
}

//----- (0000000180052374) ----------------------------------------------------
void SslUnsealHideDecryptErrorDelay(void)
{
  int v0; // ebx
  unsigned int v1; // eax
  __int64 v2; // rcx
  int v3; // eax
  int v4; // [rsp+30h] [rbp+8h] BYREF
  int pbBuffer; // [rsp+38h] [rbp+10h] BYREF

  BCryptGenRandom(0i64, (PUCHAR)&pbBuffer, 4u, 2u);
  v0 = pbBuffer;
  BCryptGenRandom(0i64, (PUCHAR)&v4, 4u, 2u);
  v4 |= 1u;
  v1 = (unsigned int)SslUnsealComputeDecryptErrorDelay() >> 1;
  if ( v1 )
  {
    v2 = v1;
    v3 = v4;
    do
    {
      v0 += v3;
      v3 ^= v0;
      --v2;
    }
    while ( v2 );
  }
}

//----- (00000001800523F4) ----------------------------------------------------
unsigned __int16 *__fastcall AllocateAndCopyString(wchar_t *Source)
{
  __int64 v1; // rax
  SIZE_T v3; // rbx
  wchar_t *v4; // rax
  wchar_t *v5; // rdi

  v1 = -1i64;
  do
    ++v1;
  while ( Source[v1] );
  v3 = (unsigned int)(2 * v1 + 2);
  v4 = (wchar_t *)LocalAlloc(0x40u, v3);
  v5 = v4;
  if ( v4 )
  {
    wcscpy_s(v4, v3 >> 1, Source);
    return v5;
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids);
    return 0i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (00000001800524A0) ----------------------------------------------------
__int64 __fastcall SpQueryKeyInfo(struct CSslUserContext *a1, _OWORD *a2)
{
  unsigned __int16 v4; // ax
  unsigned int v5; // edi
  __int64 v6; // rdx
  unsigned __int16 *v7; // rax
  bool v8; // zf
  void *v9; // rcx
  int v11; // [rsp+30h] [rbp-348h] BYREF
  char v12[4]; // [rsp+34h] [rbp-344h] BYREF
  int v13; // [rsp+38h] [rbp-340h]
  wchar_t Source[64]; // [rsp+C0h] [rbp-2B8h] BYREF
  int v15; // [rsp+140h] [rbp-238h]
  wchar_t v16[134]; // [rsp+254h] [rbp-124h] BYREF

  v11 = 1;
  memset_0(v12, 0, 0x324ui64);
  *a2 = 0i64;
  a2[1] = 0i64;
  v4 = ConvertSchannelProtocolToSsl(*((_DWORD *)a1 + 6));
  v5 = SslLookupCipherSuiteInfo(
         *((_QWORD *)a1 + 11),
         v4,
         *((unsigned int *)a1 + 14),
         *((unsigned int *)a1 + 15),
         v12,
         0);
  if ( v5 || v13 != *((_DWORD *)a1 + 14) )
  {
    v5 = -2146893052;
  }
  else
  {
    *((_DWORD *)a2 + 4) = v15;
    *((_DWORD *)a2 + 6) = LookupSymmetricCipherAlg((struct _NCRYPT_SSL_CIPHER_SUITE_EX *)&v11);
    *((_DWORD *)a2 + 5) = LookupCertificateAlg((wchar_t *)&v11, v6);
    *((_QWORD *)a2 + 1) = AllocateAndCopyString(Source);
    v7 = AllocateAndCopyString(v16);
    v8 = *((_QWORD *)a2 + 1) == 0i64;
    *(_QWORD *)a2 = v7;
    if ( !v8 && v7 )
      return v5;
    v5 = -2146893056;
  }
  if ( *(_QWORD *)a2 )
  {
    LocalFree(*(HLOCAL *)a2);
    *(_QWORD *)a2 = 0i64;
  }
  v9 = (void *)*((_QWORD *)a2 + 1);
  if ( v9 )
  {
    LocalFree(v9);
    *((_QWORD *)a2 + 1) = 0i64;
  }
  return v5;
}
// 18005254B: variable 'v6' is possibly undefined
// 180098510: using guessed type __int64 __fastcall SslLookupCipherSuiteInfo(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 1800524A0: using guessed type wchar_t Source[64];
// 1800524A0: using guessed type wchar_t var_124[134];

//----- (00000001800525EC) ----------------------------------------------------
__int64 __fastcall SpQueryLifespan(struct CSslUserContext *a1, struct _SecPkgContext_Lifespan *a2)
{
  unsigned __int8 *v4; // rcx
  PCCERT_CONTEXT v6; // rcx
  PCCERT_CONTEXT pCertContext; // [rsp+30h] [rbp+8h] BYREF

  pCertContext = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids);
  v4 = (unsigned __int8 *)*((_QWORD *)a1 + 19);
  if ( v4 )
  {
    if ( SPLoadCertificate(v4, *((_DWORD *)a1 + 40), &pCertContext) )
      return 2148074240i64;
    v6 = pCertContext;
    a2->tsStart.QuadPart = (LONGLONG)pCertContext->pCertInfo->NotBefore;
    a2->tsExpiry.QuadPart = (LONGLONG)v6->pCertInfo->NotAfter;
    CertFreeCertificateContext(v6);
  }
  else
  {
    a2->tsStart.QuadPart = 0i64;
    a2->tsExpiry.QuadPart = 0x7FFFFF36D5969FFFi64;
  }
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (00000001800526A8) ----------------------------------------------------
DWORD __fastcall SpQueryNames(struct CSslUserContext *a1, struct _SecPkgContext_NamesW *a2)
{
  int v2; // ebx
  unsigned __int8 *v5; // rcx
  DWORD result; // eax
  PCCERT_CONTEXT v7; // rdi
  DWORD v8; // eax
  DWORD csz; // r14d
  SEC_WCHAR *v10; // rax
  PCCERT_CONTEXT pCertContext; // [rsp+40h] [rbp+8h] BYREF

  v2 = 0;
  pCertContext = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 16i64, &WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids);
  v5 = (unsigned __int8 *)*((_QWORD *)a1 + 19);
  if ( !v5 )
    return -2146893054;
  result = SPLoadCertificate(v5, *((_DWORD *)a1 + 40), &pCertContext);
  if ( !result )
  {
    v7 = pCertContext;
    v8 = CertNameToStrW(pCertContext->dwCertEncodingType, &pCertContext->pCertInfo->Subject, 0x20000003u, 0i64, 0);
    csz = v8;
    if ( v8 > 1 )
    {
      v10 = (SEC_WCHAR *)LocalAlloc(0x40u, 2 * v8);
      a2->sUserName = v10;
      if ( v10 )
      {
        if ( CertNameToStrW(v7->dwCertEncodingType, &v7->pCertInfo->Subject, 0x20000003u, v10, csz) <= 1 )
        {
          CertFreeCertificateContext(v7);
          LocalFree(a2->sUserName);
          return -2146893054;
        }
      }
      else
      {
        v2 = -2146893056;
      }
    }
    else
    {
      v2 = -2146893054;
    }
    CertFreeCertificateContext(v7);
    return v2;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (00000001800527F0) ----------------------------------------------------
__int64 __fastcall SpQueryPackageInfo(struct CSslUserContext *a1, void *a2)
{
  unsigned __int64 v3; // rbx
  unsigned __int64 v4; // rsi
  _WORD *v5; // rax

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 17i64, &WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids);
  v3 = (unsigned int)(2 * lstrlenW(L"Schannel") + 2);
  v4 = (unsigned int)(2 * lstrlenW(L"Schannel Security Package") + 2);
  v5 = LocalAlloc(0x40u, v4 + v3 + 32);
  *(_QWORD *)a2 = v5;
  if ( !v5 )
    return 3221225626i64;
  v5[2] = 1;
  *(_WORD *)(*(_QWORD *)a2 + 6i64) = 14;
  **(_DWORD **)a2 = 4261811;
  *(_DWORD *)(*(_QWORD *)a2 + 8i64) = 24576;
  *(_QWORD *)(*(_QWORD *)a2 + 16i64) = *(_QWORD *)a2 + 32i64;
  *(_QWORD *)(*(_QWORD *)a2 + 24i64) = v3 + *(_QWORD *)(*(_QWORD *)a2 + 16i64);
  wcscpy_s(*(wchar_t **)(*(_QWORD *)a2 + 16i64), v3 >> 1, L"Schannel");
  wcscpy_s(*(wchar_t **)(*(_QWORD *)a2 + 24i64), v4 >> 1, L"Schannel Security Package");
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180052918) ----------------------------------------------------
__int64 __fastcall SpQueryProtoInfo(struct CSslUserContext *a1, _DWORD *a2)
{
  _DWORD *v4; // rcx
  __int64 v5; // rax
  __int64 v7; // rbx
  SIZE_T v8; // rsi
  wchar_t *v9; // rax

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, &WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids);
  v4 = &unk_18007FD60;
  v5 = 0i64;
  while ( *((_DWORD *)a1 + 6) != *v4 )
  {
    v5 = (unsigned int)(v5 + 1);
    v4 += 6;
    if ( (unsigned int)v5 >= 0xC )
      return 2148074242i64;
  }
  v7 = 3 * v5;
  v8 = (unsigned int)(2 * lstrlenW(*((LPCWSTR *)&unk_18007FD60 + 3 * v5 + 1)) + 2);
  v9 = (wchar_t *)LocalAlloc(0x40u, v8);
  *(_QWORD *)a2 = v9;
  if ( !v9 )
    return 2148074240i64;
  wcscpy_s(v9, v8 >> 1, *((const wchar_t **)&unk_18007FD60 + v7 + 1));
  a2[2] = *((_DWORD *)&unk_18007FD60 + 2 * v7 + 4);
  a2[3] = *((_DWORD *)&unk_18007FD60 + 2 * v7 + 5);
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180052A04) ----------------------------------------------------
DWORD __fastcall SpQueryRemoteCred(struct CSslUserContext *a1, _OWORD *a2)
{
  unsigned __int8 *v4; // rcx
  DWORD result; // eax
  PCCERT_CONTEXT v6; // rbx
  HLOCAL v7; // rax
  HLOCAL v8; // rsi
  DWORD cbCertEncoded; // eax
  struct _PUBLICKEY *v10; // rcx
  PCCERT_CONTEXT pCertContext; // [rsp+30h] [rbp+8h] BYREF
  struct _PUBLICKEY *v12; // [rsp+38h] [rbp+10h] BYREF

  pCertContext = 0i64;
  v12 = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids);
  *a2 = 0i64;
  a2[1] = 0i64;
  v4 = (unsigned __int8 *)*((_QWORD *)a1 + 19);
  if ( v4 )
  {
    result = SPLoadCertificate(v4, *((_DWORD *)a1 + 40), &pCertContext);
    if ( result )
      return result;
    v6 = pCertContext;
    if ( pCertContext )
    {
      v7 = LocalAlloc(0x40u, pCertContext->cbCertEncoded);
      v8 = v7;
      if ( !v7 )
      {
        CertFreeCertificateContext(v6);
        return -2146893056;
      }
      memcpy_0(v7, v6->pbCertEncoded, v6->cbCertEncoded);
      *((_DWORD *)a2 + 5) |= 1u;
      *((_QWORD *)a2 + 1) = v8;
      cbCertEncoded = v6->cbCertEncoded;
      *((_DWORD *)a2 + 6) = 0;
      *(_DWORD *)a2 = cbCertEncoded;
      *((_DWORD *)a2 + 4) = 1;
      if ( !GetPublicKeyFromCert(v6, &v12, 0i64) )
      {
        v10 = v12;
        if ( v12 )
        {
          if ( *(_QWORD *)v12 != -8i64 )
            *((_DWORD *)a2 + 6) = *(_DWORD *)(*(_QWORD *)v12 + 12i64);
          SPExternalFree(v10);
        }
        else
        {
          *((_DWORD *)a2 + 6) = CertGetPublicKeyLength(1u, &v6->pCertInfo->SubjectPublicKeyInfo);
        }
      }
      CertFreeCertificateContext(v6);
    }
  }
  return 0;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180052B68) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteAgg(_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),void const *>::Write<_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        const WCHAR **a6)
{
  const WCHAR *v7; // rcx
  __int64 v8; // rax
  int v9; // edx
  ULONG result; // eax
  unsigned __int8 AggregateFieldTypes; // al
  EVENT_DESCRIPTOR EventDescriptor; // [rsp+30h] [rbp-39h] BYREF
  unsigned int v13; // [rsp+40h] [rbp-29h]
  struct _EVENT_DATA_DESCRIPTOR UserData; // [rsp+50h] [rbp-19h] BYREF
  unsigned __int8 *v15; // [rsp+60h] [rbp-9h]
  int v16; // [rsp+68h] [rbp-1h]
  int v17; // [rsp+6Ch] [rbp+3h]
  __int64 v18; // [rsp+70h] [rbp+7h]
  __int64 v19; // [rsp+78h] [rbp+Fh]
  __int64 v20; // [rsp+80h] [rbp+17h]
  __int64 v21; // [rsp+88h] [rbp+1Fh]
  const WCHAR *v22; // [rsp+90h] [rbp+27h]
  int v23; // [rsp+98h] [rbp+2Fh]
  int v24; // [rsp+9Ch] [rbp+33h]

  v7 = *a6;
  if ( *a6 )
  {
    v8 = -1i64;
    do
      ++v8;
    while ( v7[v8] );
    v9 = 2 * v8 + 2;
  }
  else
  {
    v7 = &Class;
    v9 = 2;
  }
  v20 = a5;
  *(_DWORD *)&EventDescriptor.Id = *a2 << 24;
  v22 = v7;
  *(_DWORD *)&EventDescriptor.Level = *(unsigned __int16 *)(a2 + 1);
  EventDescriptor.Keyword = *(_QWORD *)(a2 + 3);
  UserData.Ptr = (ULONGLONG)off_180091488;
  v23 = v9;
  v24 = 0;
  v21 = 4i64;
  v18 = a4;
  v19 = 4i64;
  UserData.Size = *(unsigned __int16 *)off_180091488;
  v16 = *(unsigned __int16 *)(a2 + 11);
  v15 = a2 + 11;
  UserData.Reserved = 2;
  v17 = 1;
  v13 = (unsigned int)&TraceLoggingMetadataEnd - (unsigned int)&TraceLoggingMetadata;
  result = -1073741811;
  if ( (void (__fastcall *)(const struct _GUID *, unsigned int, __int64, __int64, unsigned __int64, struct _EVENT_FILTER_DESCRIPTOR *, _QWORD *))qword_1800914A8 == TlgAggregateInternalRegisteredProviderEtwCallback )
  {
    AggregateFieldTypes = ExtractAggregateFieldTypes(
                            (__int64)TlgAggregateInternalRegisteredProviderEtwCallback,
                            (__int64)&UserData);
    if ( AggregateFieldTypes )
      return InsertEventEntryInLookUpTable(
               (__int64)&dword_180091480,
               (__int128 *)&EventDescriptor,
               5u,
               (__int64)&UserData,
               AggregateFieldTypes);
    else
      return EventWriteTransfer_0(RegHandle, &EventDescriptor, 0i64, 0i64, 5u, &UserData);
  }
  return result;
}
// 180091488: using guessed type void *off_180091488;
// 1800914A8: using guessed type __int64 qword_1800914A8;

//----- (0000000180052CC4) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteAgg(_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),void const *>::Write<_tlgWrapperByVal<8>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<1>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<2>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperArray<4>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<1>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperArray<4>,_tlgWrapperByVal<4>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        const WCHAR **a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16,
        __int64 a17,
        __int64 a18,
        __int64 a19,
        __int64 a20,
        __int64 a21,
        __int64 a22,
        __int64 a23,
        __int64 a24,
        __int64 a25,
        __int64 a26)
{
  const WCHAR *v27; // rcx
  __int64 v28; // rax
  int v29; // edx
  ULONG result; // eax
  unsigned __int8 AggregateFieldTypes; // al
  EVENT_DESCRIPTOR EventDescriptor; // [rsp+30h] [rbp-D0h] BYREF
  unsigned int v33; // [rsp+40h] [rbp-C0h]
  struct _EVENT_DATA_DESCRIPTOR UserData; // [rsp+50h] [rbp-B0h] BYREF
  unsigned __int8 *v35; // [rsp+60h] [rbp-A0h]
  int v36; // [rsp+68h] [rbp-98h]
  int v37; // [rsp+6Ch] [rbp-94h]
  __int64 v38; // [rsp+70h] [rbp-90h]
  __int64 v39; // [rsp+78h] [rbp-88h]
  const WCHAR *v40; // [rsp+80h] [rbp-80h]
  int v41; // [rsp+88h] [rbp-78h]
  int v42; // [rsp+8Ch] [rbp-74h]
  __int64 v43; // [rsp+90h] [rbp-70h]
  __int64 v44; // [rsp+98h] [rbp-68h]
  __int64 v45; // [rsp+A0h] [rbp-60h]
  __int64 v46; // [rsp+A8h] [rbp-58h]
  __int64 v47; // [rsp+B0h] [rbp-50h]
  __int64 v48; // [rsp+B8h] [rbp-48h]
  __int64 v49; // [rsp+C0h] [rbp-40h]
  __int64 v50; // [rsp+C8h] [rbp-38h]
  __int64 v51; // [rsp+D0h] [rbp-30h]
  __int64 v52; // [rsp+D8h] [rbp-28h]
  __int64 v53; // [rsp+E0h] [rbp-20h]
  __int64 v54; // [rsp+E8h] [rbp-18h]
  __int64 v55; // [rsp+F0h] [rbp-10h]
  __int64 v56; // [rsp+F8h] [rbp-8h]
  __int64 v57; // [rsp+100h] [rbp+0h]
  __int64 v58; // [rsp+108h] [rbp+8h]
  __int64 v59; // [rsp+110h] [rbp+10h]
  int v60; // [rsp+118h] [rbp+18h]
  int v61; // [rsp+11Ch] [rbp+1Ch]
  __int64 v62; // [rsp+120h] [rbp+20h]
  __int64 v63; // [rsp+128h] [rbp+28h]
  __int64 v64; // [rsp+130h] [rbp+30h]
  __int64 v65; // [rsp+138h] [rbp+38h]
  __int64 v66; // [rsp+140h] [rbp+40h]
  __int64 v67; // [rsp+148h] [rbp+48h]
  __int64 v68; // [rsp+150h] [rbp+50h]
  __int64 v69; // [rsp+158h] [rbp+58h]
  __int64 v70; // [rsp+160h] [rbp+60h]
  __int64 v71; // [rsp+168h] [rbp+68h]
  __int64 v72; // [rsp+170h] [rbp+70h]
  __int64 v73; // [rsp+178h] [rbp+78h]
  __int64 v74; // [rsp+180h] [rbp+80h]
  __int64 v75; // [rsp+188h] [rbp+88h]
  __int64 v76; // [rsp+190h] [rbp+90h]
  __int64 v77; // [rsp+198h] [rbp+98h]
  __int64 v78; // [rsp+1A0h] [rbp+A0h]
  __int64 v79; // [rsp+1A8h] [rbp+A8h]
  __int64 v80; // [rsp+1B0h] [rbp+B0h]
  __int64 v81; // [rsp+1B8h] [rbp+B8h]
  __int64 v82; // [rsp+1C0h] [rbp+C0h]
  __int64 v83; // [rsp+1C8h] [rbp+C8h]
  __int64 v84; // [rsp+1D0h] [rbp+D0h]
  __int64 v85; // [rsp+1D8h] [rbp+D8h]
  __int64 v86; // [rsp+1E0h] [rbp+E0h]
  int v87; // [rsp+1E8h] [rbp+E8h]
  int v88; // [rsp+1ECh] [rbp+ECh]
  __int64 v89; // [rsp+1F0h] [rbp+F0h]
  __int64 v90; // [rsp+1F8h] [rbp+F8h]

  v89 = a26;
  v90 = 4i64;
  v88 = 0;
  v85 = 2i64;
  v83 = 4i64;
  v86 = *(_QWORD *)a25;
  v87 = 4 * *(unsigned __int16 *)(a25 + 8);
  v82 = a24;
  v80 = a23;
  v78 = a22;
  v76 = a21;
  v74 = a20;
  v72 = a19;
  v70 = a18;
  v68 = a17;
  v66 = a16;
  v64 = a15;
  v62 = a14;
  v84 = a25 + 8;
  v81 = 4i64;
  v79 = 1i64;
  v77 = 4i64;
  v59 = *(_QWORD *)a13;
  v60 = 4 * *(unsigned __int16 *)(a13 + 8);
  v55 = a12;
  v53 = a11;
  v51 = a10;
  v49 = a9;
  v47 = a8;
  v45 = a7;
  v43 = a6;
  v75 = 4i64;
  v73 = 4i64;
  v71 = 4i64;
  v69 = 4i64;
  v67 = 4i64;
  v65 = 4i64;
  v63 = 2i64;
  v57 = a13 + 8;
  v58 = 2i64;
  v61 = 0;
  v56 = 4i64;
  v54 = 4i64;
  v52 = 2i64;
  v50 = 2i64;
  v48 = 8i64;
  v46 = 8i64;
  v44 = 1i64;
  v27 = *a5;
  if ( *a5 )
  {
    v28 = -1i64;
    do
      ++v28;
    while ( v27[v28] );
    v29 = 2 * v28 + 2;
  }
  else
  {
    v27 = &Class;
    v29 = 2;
  }
  *(_DWORD *)&EventDescriptor.Id = *a2 << 24;
  v40 = v27;
  *(_DWORD *)&EventDescriptor.Level = *(unsigned __int16 *)(a2 + 1);
  v41 = v29;
  v42 = 0;
  EventDescriptor.Keyword = *(_QWORD *)(a2 + 3);
  UserData.Ptr = (ULONGLONG)off_180091488;
  v38 = a4;
  v39 = 8i64;
  UserData.Size = *(unsigned __int16 *)off_180091488;
  v36 = *(unsigned __int16 *)(a2 + 11);
  v35 = a2 + 11;
  UserData.Reserved = 2;
  v37 = 1;
  v33 = (unsigned int)&TraceLoggingMetadataEnd - (unsigned int)&TraceLoggingMetadata;
  result = -1073741811;
  if ( (void (__fastcall *)(const struct _GUID *, unsigned int, __int64, __int64, unsigned __int64, struct _EVENT_FILTER_DESCRIPTOR *, _QWORD *))qword_1800914A8 == TlgAggregateInternalRegisteredProviderEtwCallback )
  {
    AggregateFieldTypes = ExtractAggregateFieldTypes(
                            (__int64)TlgAggregateInternalRegisteredProviderEtwCallback,
                            (__int64)&UserData);
    if ( AggregateFieldTypes )
      return InsertEventEntryInLookUpTable(
               (__int64)&dword_180091480,
               (__int128 *)&EventDescriptor,
               0x1Bu,
               (__int64)&UserData,
               AggregateFieldTypes);
    else
      return EventWriteTransfer_0(RegHandle, &EventDescriptor, 0i64, 0i64, 0x1Bu, &UserData);
  }
  return result;
}
// 180091488: using guessed type void *off_180091488;
// 1800914A8: using guessed type __int64 qword_1800914A8;

//----- (0000000180053000) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::LogCertKeyUsageError(__int64 a1, int a2, const unsigned __int16 *a3)
{
  int v3; // [rsp+30h] [rbp-18h] BYREF
  const WCHAR *v4; // [rsp+38h] [rbp-10h] BYREF
  int v5; // [rsp+68h] [rbp+20h] BYREF

  if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized
    && (unsigned int)dword_180091480 > 5
    && (qword_180091490 & 0x400000000000i64) != 0
    && (qword_180091498 & 0x400000000000i64) == qword_180091498 )
  {
    v5 = a2;
    v4 = a3;
    v3 = a1;
    _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteAgg(_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),void const *>::Write<_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>>(
      a1,
      byte_180084988,
      (__int64)a3,
      (__int64)&v3,
      (__int64)&v5,
      &v4);
  }
}
// 180084988: using guessed type unsigned __int8 byte_180084988[80];
// 180091490: using guessed type __int64 qword_180091490;
// 180091498: using guessed type __int64 qword_180091498;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180053078) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::LogRCMPUsage(__int16 a1)
{
  __int16 v1; // [rsp+30h] [rbp-48h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v2; // [rsp+38h] [rbp-40h] BYREF
  __int16 *v3; // [rsp+58h] [rbp-20h]
  int v4; // [rsp+60h] [rbp-18h]
  int v5; // [rsp+64h] [rbp-14h]

  if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized
    && (unsigned int)dword_180091480 > 5
    && (qword_180091490 & 0x400000000000i64) != 0
    && (qword_180091498 & 0x400000000000i64) == qword_180091498 )
  {
    v1 = a1;
    v3 = &v1;
    v5 = 0;
    v4 = 2;
    tlgWriteTransfer_EventWriteTransfer(
      (__int64)&dword_180091480,
      (unsigned __int8 *)dword_18008495B,
      0i64,
      0i64,
      3u,
      &v2);
  }
}
// 18008495B: using guessed type int dword_18008495B[11];
// 180091490: using guessed type __int64 qword_180091490;
// 180091498: using guessed type __int64 qword_180091498;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180053124) ----------------------------------------------------
bool __fastcall CSchannelTelemetryContext::LogRenegoStart(__int64 a1, int a2, __int64 a3)
{
  bool v5; // zf
  bool result; // al

  if ( a1 )
  {
    if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    {
      *(_BYTE *)(a1 + 16) = 1;
      *(_DWORD *)(a1 + 12) = a2;
      QueryPerformanceCounter((LARGE_INTEGER *)(a1 + 80));
      v5 = *(_DWORD *)(a1 + 12) == 1;
      *(_DWORD *)(a1 + 24) = 2;
      result = v5;
      *(_QWORD *)(a1 + 120) = a3;
      *(_BYTE *)(a1 + 28) = v5;
    }
  }
  return result;
}
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180053180) ----------------------------------------------------
ULONG WPP_SF_SSSdiiDDDDDddiDDd(
        TRACEHANDLE LoggerHandle,
        __int64 a2,
        __int64 a3,
        const wchar_t *a4,
        const wchar_t *a5,
        const wchar_t *a6,
        char a7,
        char a8,
        char a9,
        char a10,
        char a11,
        char a12,
        char a13,
        char a14,
        char a15,
        char a16,
        ...)
{
  const wchar_t *v16; // r8
  __int64 v17; // rax
  __int64 v19; // rdx
  __int64 v20; // r10
  const wchar_t *v21; // rcx
  __int64 v22; // rdx
  __int64 v23; // rdx
  __int64 v24; // rax
  __int64 v26; // [rsp+1D8h] [rbp+10h] BYREF
  va_list va; // [rsp+1D8h] [rbp+10h]
  __int64 v28; // [rsp+1E0h] [rbp+18h] BYREF
  va_list va1; // [rsp+1E0h] [rbp+18h]
  __int64 v30; // [rsp+1E8h] [rbp+20h] BYREF
  va_list va2; // [rsp+1E8h] [rbp+20h]
  va_list va3; // [rsp+1F0h] [rbp+28h] BYREF

  va_start(va3, a16);
  va_start(va2, a16);
  va_start(va1, a16);
  va_start(va, a16);
  v26 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v28 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v30 = va_arg(va3, _QWORD);
  v16 = a6;
  v17 = -1i64;
  if ( a6 )
  {
    v19 = -1i64;
    do
      ++v19;
    while ( a6[v19] );
    v20 = 2 * v19 + 2;
  }
  else
  {
    v20 = 10i64;
  }
  v21 = a5;
  if ( !a6 )
    v16 = L"NULL";
  if ( a5 )
  {
    v22 = -1i64;
    do
      ++v22;
    while ( a5[v22] );
    v23 = 2 * v22 + 2;
  }
  else
  {
    v23 = 10i64;
  }
  if ( !a5 )
    v21 = L"NULL";
  if ( a4 )
  {
    do
      ++v17;
    while ( a4[v17] );
    v24 = 2 * v17 + 2;
  }
  else
  {
    v24 = 10i64;
  }
  if ( !a4 )
    a4 = L"NULL";
  return TraceMessage(
           LoggerHandle,
           0x2Bu,
           &WPP_809cf5b92bc53f9217359848f5040da5_Traceguids,
           0xAu,
           a4,
           v24,
           v21,
           v23,
           v16,
           v20,
           &a7,
           4i64,
           &a8,
           8i64,
           &a9,
           8i64,
           &a10,
           4i64,
           &a11,
           4i64,
           &a12,
           4i64,
           &a13,
           4i64,
           &a14,
           4i64,
           &a15,
           4i64,
           &a16,
           4i64,
           va,
           8i64,
           va1,
           4i64,
           va2,
           4i64,
           va3,
           4i64,
           0i64);
}
// 180083C60: using guessed type wchar_t aNull_0[5];

//----- (00000001800533A0) ----------------------------------------------------
void tlgDefineProvider_annotation__Tlgg_hLoggingProviderProv()
{
  ;
}

//----- (00000001800533AC) ----------------------------------------------------
ULONG __fastcall tlgWriteTransfer_EventWriteTransfer(
        __int64 a1,
        unsigned __int8 *a2,
        const GUID *a3,
        const GUID *a4,
        ULONG UserDataCount,
        PEVENT_DATA_DESCRIPTOR UserData)
{
  EVENT_DESCRIPTOR EventDescriptor; // [rsp+30h] [rbp-18h] BYREF

  *(_DWORD *)&EventDescriptor.Id = *a2 << 24;
  *(_DWORD *)&EventDescriptor.Level = *(unsigned __int16 *)(a2 + 1);
  EventDescriptor.Keyword = *(_QWORD *)(a2 + 3);
  UserData->Ptr = *(_QWORD *)(a1 + 8);
  UserData->Size = **(unsigned __int16 **)(a1 + 8);
  UserData->Reserved = 2;
  UserData[1].Ptr = (ULONGLONG)(a2 + 11);
  UserData[1].Size = *(unsigned __int16 *)(a2 + 11);
  UserData[1].Reserved = 1;
  return EventWriteTransfer(*(_QWORD *)(a1 + 32), &EventDescriptor, a3, a4, UserDataCount, UserData);
}

//----- (0000000180053448) ----------------------------------------------------
__int64 __fastcall SslGetClientProcess(unsigned int *a1)
{
  DWORD CurrentProcessId; // eax
  DWORD v4[10]; // [rsp+20h] [rbp-28h] BYREF

  if ( !LsaTable )
  {
    CurrentProcessId = GetCurrentProcessId();
LABEL_3:
    *a1 = CurrentProcessId;
    return 1i64;
  }
  if ( (*(unsigned __int8 (__fastcall **)(DWORD *))(LsaTable + 192))(v4) )
  {
    CurrentProcessId = v4[0];
    goto LABEL_3;
  }
  *a1 = -1;
  return 0i64;
}
// 180092620: using guessed type __int64 LsaTable;
// 180053448: using guessed type DWORD var_28[10];

//----- (00000001800534AC) ----------------------------------------------------
__int64 __fastcall GetElapsedTime(DWORD a1)
{
  DWORD TickCount; // eax
  DWORD v3; // ecx

  TickCount = GetTickCount();
  v3 = TickCount - a1;
  if ( a1 > TickCount )
    --v3;
  return v3;
}

//----- (00000001800534DC) ----------------------------------------------------
__int64 __fastcall GetTokenUserSid(void *a1, unsigned __int8 *const a2)
{
  unsigned int v3; // ebx
  DWORD LengthSid; // eax
  DWORD ReturnLength[4]; // [rsp+30h] [rbp-88h] BYREF
  void *TokenInformation; // [rsp+40h] [rbp-78h] BYREF

  if ( a1 )
  {
    v3 = GetTokenInformation(a1, TokenUser, &TokenInformation, 0x54u, ReturnLength);
    if ( !v3 )
      return v3;
    LengthSid = GetLengthSid(TokenInformation);
    ReturnLength[0] = LengthSid;
    if ( LengthSid <= 0x44 )
    {
      memcpy_0(a2, TokenInformation, LengthSid);
      return v3;
    }
  }
  return 0i64;
}
// 1800534DC: using guessed type DWORD var_88[4];

//----- (0000000180053588) ----------------------------------------------------
__int64 __fastcall IsThreadLocalSystemOrNetworkService(unsigned __int8 *a1)
{
  DWORD LastError; // ebx
  HANDLE CurrentThread; // rax
  CCipherMill *v4; // rcx
  __int64 v5; // rdx
  DWORD cbSid; // [rsp+20h] [rbp-69h] BYREF
  void *TokenHandle; // [rsp+28h] [rbp-61h] BYREF
  char pSid[80]; // [rsp+30h] [rbp-59h] BYREF
  unsigned __int8 pSid2[80]; // [rsp+80h] [rbp-9h] BYREF

  TokenHandle = 0i64;
  LastError = 0;
  *a1 = 0;
  cbSid = 68;
  CurrentThread = GetCurrentThread();
  if ( !OpenThreadToken(CurrentThread, 8u, 1, &TokenHandle)
    || !(unsigned int)GetTokenUserSid(TokenHandle, pSid2)
    || !CreateWellKnownSid(WinLocalSystemSid, 0i64, pSid, &cbSid) )
  {
    goto LABEL_2;
  }
  if ( EqualSid(pSid, pSid2) )
  {
    v4 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      goto LABEL_15;
    v5 = 10i64;
    goto LABEL_14;
  }
  cbSid = 68;
  if ( !CreateWellKnownSid(WinNetworkServiceSid, 0i64, pSid, &cbSid) )
  {
LABEL_2:
    LastError = GetLastError();
    goto LABEL_16;
  }
  if ( !EqualSid(pSid, pSid2) )
    goto LABEL_16;
  v4 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    v5 = 11i64;
LABEL_14:
    WPP_SF_(*((_QWORD *)v4 + 2), v5, &WPP_515891eeb9b1375e41800a5e1897fca1_Traceguids);
  }
LABEL_15:
  *a1 = 1;
LABEL_16:
  if ( TokenHandle )
    CloseHandle(TokenHandle);
  return LastError;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180053714) ----------------------------------------------------
void __fastcall ReverseMemCopy(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *i; // r8
  unsigned __int8 v4; // al

  for ( i = &a1[a3 - 1]; i >= a1; --i )
  {
    v4 = *a2++;
    *i = v4;
  }
}

//----- (0000000180053738) ----------------------------------------------------
__int64 __fastcall CertHasServerAuthEku(PCCERT_CONTEXT pCertContext)
{
  unsigned int EnhancedKeyUsage; // ebx
  struct _CTL_USAGE *v3; // rax
  struct _CTL_USAGE *v4; // rdi
  __int64 v5; // rsi
  LPSTR *rgpszUsageIdentifier; // r14
  DWORD pcbUsage; // [rsp+38h] [rbp+10h] BYREF

  pcbUsage = 0;
  EnhancedKeyUsage = CertGetEnhancedKeyUsage(pCertContext, 2u, 0i64, &pcbUsage);
  if ( EnhancedKeyUsage )
  {
    v3 = (struct _CTL_USAGE *)SPExternalAlloc(pcbUsage);
    v4 = v3;
    if ( v3 )
    {
      EnhancedKeyUsage = CertGetEnhancedKeyUsage(pCertContext, 2u, v3, &pcbUsage);
      if ( EnhancedKeyUsage )
      {
        v5 = 0i64;
        if ( v4->cUsageIdentifier )
        {
          rgpszUsageIdentifier = v4->rgpszUsageIdentifier;
          EnhancedKeyUsage = 1;
          while ( strcmp_0(rgpszUsageIdentifier[v5], "1.3.6.1.5.5.7.3.1") )
          {
            v5 = (unsigned int)(v5 + 1);
            if ( (unsigned int)v5 >= v4->cUsageIdentifier )
              goto LABEL_10;
          }
        }
        else
        {
LABEL_10:
          EnhancedKeyUsage = 0;
        }
      }
      else
      {
        GetLastError();
      }
      SPExternalFree(v4);
    }
  }
  else
  {
    GetLastError();
  }
  return EnhancedKeyUsage;
}

//----- (0000000180053810) ----------------------------------------------------
__int64 __fastcall CheckForLocalStoreCertificateRenewal(
        HCERTSTORE hCertStore,
        PCCERT_CONTEXT pCertContext,
        char a3,
        const struct _CERT_CONTEXT **a4)
{
  unsigned int v4; // r14d
  unsigned int v5; // r12d
  DWORD LastError; // eax
  __int64 v8; // rdx
  const CERT_CONTEXT *CertificateInStore; // rsi
  PCCERT_CONTEXT v11; // r15
  DWORD v12; // eax
  DWORD pcbData; // [rsp+30h] [rbp-40h] BYREF
  DWORD pvFindPara; // [rsp+38h] [rbp-38h] BYREF
  char *v15; // [rsp+40h] [rbp-30h]
  const struct _CERT_CONTEXT **v16; // [rsp+48h] [rbp-28h]
  char pvData[24]; // [rsp+50h] [rbp-20h] BYREF

  v4 = 0;
  v16 = a4;
  v5 = 0;
  pcbData = 20;
  if ( a3 )
  {
    if ( CertGetCertificateContextProperty(pCertContext, 3u, pvData, &pcbData) )
    {
      pvFindPara = pcbData;
      v15 = pvData;
      CertificateInStore = CertFindCertificateInStore(hCertStore, 1u, 0, 0x10000u, &pvFindPara, 0i64);
      if ( CertificateInStore )
        goto LABEL_13;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 0i64;
      LastError = GetLastError();
      v8 = 26i64;
    }
    else
    {
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 0i64;
      LastError = GetLastError();
      v8 = 25i64;
    }
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), v8, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids, LastError);
    return 0i64;
  }
  CertificateInStore = CertDuplicateCertificateContext(pCertContext);
LABEL_13:
  while ( 1 )
  {
    pcbData = 20;
    if ( !CertGetCertificateContextProperty(CertificateInStore, 0x40u, pvData, &pcbData) )
      break;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 28i64, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids);
    pvFindPara = pcbData;
    v15 = pvData;
    v11 = CertFindCertificateInStore(hCertStore, 1u, 0, 0x10000u, &pvFindPara, 0i64);
    if ( !v11 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        v12 = GetLastError();
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 29i64, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids, v12);
      }
      goto LABEL_29;
    }
    CertFreeCertificateContext(CertificateInStore);
    ++v5;
    CertificateInStore = v11;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 30i64, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids);
    v4 = 1;
    if ( v5 >= 0x53A )
      goto LABEL_30;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 27i64, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids);
LABEL_29:
  if ( v4 )
  {
LABEL_30:
    *v16 = CertificateInStore;
    return v4;
  }
  CertFreeCertificateContext(CertificateInStore);
  return v4;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180053AD0) ----------------------------------------------------
__int64 __fastcall ConstructIssuersListFromStore(void *a1, unsigned __int8 **a2, unsigned int *a3)
{
  __int64 result; // rax
  unsigned __int8 *v7; // rax
  unsigned int v8; // edi
  unsigned __int8 v9; // [rsp+30h] [rbp+8h] BYREF

  v9 = 0;
  if ( !a1 )
    return 87i64;
  result = ExtractIssuerNamesFromStore(a1, 0i64, a3, &v9);
  if ( !(_DWORD)result )
  {
    v7 = (unsigned __int8 *)SPExternalAlloc(*a3);
    *a2 = v7;
    if ( v7 )
    {
      v8 = ExtractIssuerNamesFromStore(a1, v7, a3, &v9);
      if ( v8 )
      {
        SPExternalFree(*a2);
        *a2 = 0i64;
        return v8;
      }
      else
      {
        return 0i64;
      }
    }
    else
    {
      return 14i64;
    }
  }
  return result;
}

//----- (0000000180053B60) ----------------------------------------------------
DWORD __fastcall DssPublicKeyFromCert(struct _CERT_PUBLIC_KEY_INFO *a1, struct _PUBLICKEYSTRUC *a2, unsigned int *a3)
{
  DWORD cbData; // r9d
  DWORD LastError; // esi
  BYTE *pbData; // r8
  DWORD v10; // edi
  const void **pvStructInfo; // r15
  unsigned int *v12; // r14
  unsigned int v13; // edx
  unsigned int v14; // r8d
  unsigned int v15; // eax
  unsigned int v16; // ecx
  unsigned int v17; // eax
  char *v18; // rdi
  char *v19; // rdi
  __int64 v20; // rcx
  char *v21; // rdi
  size_t v22; // rbx
  __int64 v23; // rcx
  char *v24; // rdi
  size_t v25; // rbx
  DWORD pcbStructInfo; // [rsp+70h] [rbp+8h] BYREF
  DWORD v27; // [rsp+88h] [rbp+20h] BYREF

  cbData = a1->PublicKey.cbData;
  LastError = 0;
  pbData = a1->PublicKey.pbData;
  pcbStructInfo = 0;
  if ( !CryptDecodeObject(1u, (LPCSTR)0x26, pbData, cbData, 0, 0i64, &pcbStructInfo)
    || !CryptDecodeObject(
          1u,
          (LPCSTR)0x27,
          a1->Algorithm.Parameters.pbData,
          a1->Algorithm.Parameters.cbData,
          0,
          0i64,
          &v27) )
  {
    return GetLastError();
  }
  v10 = pcbStructInfo + v27 + 40;
  if ( !a2 )
    goto LABEL_7;
  if ( *a3 < v10 )
  {
    LastError = -2146893023;
LABEL_7:
    *a3 = v10;
    return LastError;
  }
  pvStructInfo = (const void **)SPExternalAlloc(pcbStructInfo + v27);
  if ( !pvStructInfo )
    return -2146893056;
  v12 = (unsigned int *)((char *)pvStructInfo + pcbStructInfo);
  if ( CryptDecodeObject(1u, (LPCSTR)0x26, a1->PublicKey.pbData, a1->PublicKey.cbData, 0, pvStructInfo, &pcbStructInfo)
    && CryptDecodeObject(
         1u,
         (LPCSTR)0x27,
         a1->Algorithm.Parameters.pbData,
         a1->Algorithm.Parameters.cbData,
         0,
         v12,
         &v27) )
  {
    v13 = *v12;
    if ( *v12 > 0x100000 || (v14 = v12[4], v14 > 0x100000) || v12[8] > 0x100000 || *(_DWORD *)pvStructInfo > 0x100000u )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids);
      LastError = -2146893048;
    }
    else
    {
      v15 = *v12;
      v16 = *v12;
      if ( v13 <= *(_DWORD *)pvStructInfo )
        v15 = *(_DWORD *)pvStructInfo;
      if ( v13 <= v12[8] )
        v16 = v12[8];
      v17 = v14 + v15 + v16 + v13 + 40;
      if ( v10 < v17 )
      {
        *a3 = v17;
        return -2146893023;
      }
      *(_DWORD *)&a2->bType = 518;
      a2->aiKeyAlg = 8704;
      *(_DWORD *)&a2[1].bType = 827544388;
      a2[1].aiKeyAlg = 8 * *v12;
      memcpy_0(&a2[2], *((const void **)v12 + 1), *v12);
      v18 = (char *)&a2[2] + *v12;
      memcpy_0(v18, *((const void **)v12 + 3), v12[4]);
      v19 = &v18[v12[4]];
      memcpy_0(v19, *((const void **)v12 + 5), v12[8]);
      v20 = v12[8];
      v21 = &v19[v20];
      if ( (unsigned int)v20 < *v12 )
      {
        v22 = *v12 - (unsigned int)v20;
        memset_0(v21, 0, v22);
        v21 += v22;
      }
      memcpy_0(v21, pvStructInfo[1], *(unsigned int *)pvStructInfo);
      v23 = *(unsigned int *)pvStructInfo;
      v24 = &v21[v23];
      if ( (unsigned int)v23 < *v12 )
      {
        v25 = *v12 - (unsigned int)v23;
        memset_0(v24, 0, v25);
        v24 += v25;
      }
      *(_DWORD *)v24 = -1;
      *(_OWORD *)(v24 + 4) = 0i64;
      *((_DWORD *)v24 + 5) = 0;
      *a3 = (_DWORD)v24 - (_DWORD)a2 + 24;
    }
  }
  else
  {
    LastError = GetLastError();
  }
  SPExternalFree(pvStructInfo);
  return LastError;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180053E4C) ----------------------------------------------------
__int64 __fastcall ExtractIssuerNamesFromStore(void *a1, unsigned __int8 *a2, unsigned int *a3, unsigned __int8 *a4)
{
  unsigned int v4; // r12d
  unsigned int v6; // ebp
  unsigned __int8 *v7; // rsi
  char v8; // bl
  PCCERT_CONTEXT v11; // rdi
  __int128 *pCertInfo; // rcx
  __int128 v13; // xmm1
  __int128 v14; // xmm0
  __int128 v15; // xmm1
  __int128 v16; // xmm0
  __int128 v17; // xmm1
  __int128 v18; // xmm0
  __int128 v19; // xmm1
  __int128 v20; // xmm0
  __int128 v21; // xmm1
  __int128 v22; // xmm0
  __int128 v23; // xmm1
  __int128 v24; // xmm0
  size_t v25; // rbx
  BOOL v26; // eax
  DWORD LastError; // eax
  const void *v28; // rdx
  char *v29; // rsi
  int v31; // [rsp+20h] [rbp-118h] BYREF
  DWORD pcbData; // [rsp+24h] [rbp-114h] BYREF
  int pvData; // [rsp+28h] [rbp-110h] BYREF
  __int128 v34; // [rsp+30h] [rbp-108h]
  __int128 v35; // [rsp+40h] [rbp-F8h]
  __int128 v36; // [rsp+50h] [rbp-E8h]
  __int128 v37; // [rsp+60h] [rbp-D8h]
  __int128 v38; // [rsp+70h] [rbp-C8h]
  __int128 Size; // [rsp+80h] [rbp-B8h]
  __int128 v40; // [rsp+90h] [rbp-A8h]
  __int128 v41; // [rsp+A0h] [rbp-98h]
  __int128 v42; // [rsp+B0h] [rbp-88h]
  __int128 v43; // [rsp+C0h] [rbp-78h]
  __int128 v44; // [rsp+D0h] [rbp-68h]
  __int128 v45; // [rsp+E0h] [rbp-58h]
  __int128 v46; // [rsp+F0h] [rbp-48h]
  char v48; // [rsp+148h] [rbp+10h]
  char v49; // [rsp+150h] [rbp+18h]

  v4 = *a3;
  v6 = 0;
  v7 = a2;
  *a3 = 0;
  v8 = 0;
  v49 = 0;
  v48 = 0;
  v11 = CertEnumCertificatesInStore(a1, 0i64);
  if ( v11 )
  {
    while ( 1 )
    {
      pCertInfo = (__int128 *)v11->pCertInfo;
      if ( !pCertInfo )
      {
LABEL_27:
        v8 = v48;
        break;
      }
      v13 = pCertInfo[1];
      v34 = *pCertInfo;
      v14 = pCertInfo[2];
      v35 = v13;
      v15 = pCertInfo[3];
      v36 = v14;
      v16 = pCertInfo[4];
      v37 = v15;
      v17 = pCertInfo[5];
      v38 = v16;
      v18 = pCertInfo[6];
      Size = v17;
      v19 = pCertInfo[7];
      v40 = v18;
      v20 = pCertInfo[8];
      v41 = v19;
      v21 = pCertInfo[9];
      v42 = v20;
      v22 = pCertInfo[10];
      v43 = v21;
      v23 = pCertInfo[11];
      v44 = v22;
      v24 = pCertInfo[12];
      v45 = v23;
      v46 = v24;
      v25 = (unsigned int)Size;
      if ( (unsigned int)Size <= 0xFFFF )
      {
        if ( !(unsigned int)SPCheckKeyUsage(v11, (char *)&WPP_GLOBAL_Control, 0, &v31) && v31 )
        {
          v26 = IsCertSelfSigned(v11);
          if ( v26 )
            v49 = 1;
          else
            v48 = 1;
          if ( a2
            && v26
            && a4
            && *a4
            && (pvData = 0, pcbData = 4, !CertGetCertificateContextProperty(v11, 0x66u, &pvData, &pcbData)) )
          {
            LastError = GetLastError();
            if ( LastError != 1168
              && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              WPP_SF_D(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                12i64,
                &WPP_145b996ecad4340088f3534b93eceddb_Traceguids,
                LastError);
            }
          }
          else
          {
            v6 += v25 + 2;
            if ( a2 )
            {
              if ( v6 > v4 || v4 < 2 || (unsigned int)v25 > v4 )
              {
                CertFreeCertificateContext(v11);
                return 1359i64;
              }
              v28 = (const void *)*((_QWORD *)&Size + 1);
              *v7 = BYTE1(v25);
              v7[1] = v25;
              v29 = (char *)(v7 + 2);
              memcpy_0(v29, v28, v25);
              v7 = (unsigned __int8 *)&v29[v25];
            }
          }
        }
      }
      else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
             && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids);
      }
      v11 = CertEnumCertificatesInStore(a1, v11);
      if ( !v11 )
        goto LABEL_27;
    }
  }
  if ( a4 && v49 )
  {
    if ( v8 )
      *a4 = 1;
  }
  *a3 = v6;
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180054118) ----------------------------------------------------
__int64 __fastcall GetEndpointCerts(HCERTSTORE hCertStore, struct LSA_SCHANNEL_SUB_CRED *a2, unsigned int *a3)
{
  unsigned int v3; // ebx
  const CERT_CONTEXT *i; // rax
  const CERT_CONTEXT *pPrevCertContext; // rdi

  v3 = 0;
  for ( i = CertFindCertificateInStore(hCertStore, 1u, 0, 0x150000u, 0i64, 0i64);
        ;
        i = CertFindCertificateInStore(hCertStore, 1u, 0, 0x150000u, 0i64, pPrevCertContext) )
  {
    pPrevCertContext = i;
    if ( !i )
      break;
    if ( (unsigned int)CertHasServerAuthEku(i) )
    {
      if ( a2 )
        *((_QWORD *)a2 + 7 * v3) = CertDuplicateCertificateContext(pPrevCertContext);
      ++v3;
    }
    else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 31i64, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids);
    }
  }
  if ( a3 )
    *a3 = v3;
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180054200) ----------------------------------------------------
__int64 __fastcall GetPublicKeyAlgIdFromCert(const struct _CERT_CONTEXT *a1, unsigned int *a2)
{
  PCERT_INFO pCertInfo; // rax
  char **p_pszObjId; // rax
  unsigned int v5; // eax

  if ( !a1 || !a2 )
    return 2148074333i64;
  pCertInfo = a1->pCertInfo;
  if ( !pCertInfo )
    return 2148074244i64;
  p_pszObjId = &pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;
  if ( !p_pszObjId || !*p_pszObjId )
    return 2148074244i64;
  v5 = MapOidToKeyExch(*p_pszObjId);
  if ( !v5 )
    return 2148074253i64;
  *a2 = v5;
  return 0i64;
}

//----- (000000018005425C) ----------------------------------------------------
_BOOL8 __fastcall IsCertSelfSigned(const struct _CERT_CONTEXT *a1)
{
  PCERT_INFO pCertInfo; // rcx
  DWORD cbData; // eax

  pCertInfo = a1->pCertInfo;
  cbData = pCertInfo->Issuer.cbData;
  return pCertInfo->Subject.cbData == cbData && !memcmp_0(pCertInfo->Subject.pbData, pCertInfo->Issuer.pbData, cbData);
}

//----- (0000000180054298) ----------------------------------------------------
__int64 __fastcall LoadCertificatesFromLocator(void *a1, struct LSA_SCHANNEL_CRED *a2, __int64 a3, __int64 a4)
{
  __int64 v6; // rcx
  void *Content; // rdi
  __int64 v8; // r8
  __int64 v9; // r9
  DWORD LastError; // eax
  unsigned int v11; // ebx
  CCipherMill *v12; // rcx
  unsigned int EndpointCerts; // eax
  __int64 v14; // rdx
  __int64 v15; // r9
  struct LSA_SCHANNEL_SUB_CRED *v16; // rax
  PEVENT_DATA_DESCRIPTOR v18; // [rsp+20h] [rbp-58h]
  unsigned int v19; // [rsp+30h] [rbp-48h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v20; // [rsp+38h] [rbp-40h] BYREF

  v19 = 0;
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EventWriteTransfer((__int64)a1, &LocatorGetContentStart, a3, a4, &v20);
  Content = CryptObjectLocatorGetContent(a1);
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EventWriteTransfer(v6, &LocatorGetContentStop, v8, v9, &v20);
  if ( !Content )
  {
    LastError = GetLastError();
    v11 = LastError;
    v12 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 32i64, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids, LastError);
      v12 = WPP_GLOBAL_Control;
    }
    if ( !v11 )
      goto LABEL_34;
    goto LABEL_28;
  }
  EndpointCerts = GetEndpointCerts(Content, 0i64, &v19);
  v11 = EndpointCerts;
  if ( EndpointCerts )
  {
    v12 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      v14 = 33i64;
LABEL_25:
      v15 = EndpointCerts;
      goto LABEL_26;
    }
  }
  else
  {
    if ( v19 )
    {
      v16 = (struct LSA_SCHANNEL_SUB_CRED *)SPExternalAlloc(56 * v19);
      *((_QWORD *)a2 + 1) = v16;
      if ( !v16 )
      {
        v11 = 14;
LABEL_27:
        v12 = WPP_GLOBAL_Control;
        goto LABEL_28;
      }
      EndpointCerts = GetEndpointCerts(Content, v16, &v19);
      v11 = EndpointCerts;
      if ( !EndpointCerts )
      {
        *((_DWORD *)a2 + 1) = v19;
        *((_QWORD *)a2 + 3) = a1;
        *((_QWORD *)a2 + 4) = Content;
        goto LABEL_33;
      }
      v12 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        goto LABEL_28;
      v14 = 35i64;
      goto LABEL_25;
    }
    v11 = -2146893042;
    v12 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      v14 = v19 + 34;
      v15 = 2148074254i64;
LABEL_26:
      WPP_SF_D(*((_QWORD *)v12 + 2), v14, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids, v15);
      goto LABEL_27;
    }
  }
LABEL_28:
  if ( *((_QWORD *)a2 + 1) )
  {
    SPExternalFree(*((void **)a2 + 1));
    v12 = WPP_GLOBAL_Control;
  }
  if ( Content )
  {
    CertCloseStore(Content, 0);
LABEL_33:
    v12 = WPP_GLOBAL_Control;
  }
LABEL_34:
  if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 0x20) != 0 )
  {
    LODWORD(v18) = v11;
    WPP_SF_DD(*((_QWORD *)v12 + 2), 0x24u, (__int64)&WPP_145b996ecad4340088f3534b93eceddb_Traceguids, v11, v18);
  }
  return v11;
}
// 18005430D: variable 'v6' is possibly undefined
// 18005430D: variable 'v8' is possibly undefined
// 18005430D: variable 'v9' is possibly undefined
// 180054484: variable 'v18' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180084C20: using guessed type EVENT_DESCRIPTOR LocatorGetContentStop;
// 180084C30: using guessed type EVENT_DESCRIPTOR LocatorGetContentStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 180098168: using guessed type void *__stdcall CryptObjectLocatorGetContent(void *);

//----- (00000001800544B4) ----------------------------------------------------
__int64 __fastcall SPCheckKeyUsage(PCCERT_CONTEXT pCertContext, char *a2, int a3, int *a4)
{
  int v4; // edi
  DWORD v7; // esi
  DWORD v8; // edx
  struct _CTL_USAGE *p_pcbUsage; // rbx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rax
  void *v12; // rsp
  _DWORD *v13; // rax
  int v15; // esi
  LPSTR *rgpszUsageIdentifier; // r15
  __int64 v17; // [rsp+0h] [rbp-20h] BYREF
  DWORD pcbUsage; // [rsp+20h] [rbp+0h] BYREF
  __int64 v19[3]; // [rsp+28h] [rbp+8h] BYREF

  v4 = 0;
  pcbUsage = 0;
  v7 = a3 != 0 ? 2 : 0;
  if ( !CertGetEnhancedKeyUsage(pCertContext, v7, 0i64, &pcbUsage) )
    goto LABEL_19;
  v8 = pcbUsage;
  p_pcbUsage = 0i64;
  if ( !pcbUsage )
    goto LABEL_11;
  if ( pcbUsage > (unsigned __int64)g_ulMaxStackAllocSize )
    goto LABEL_11;
  v10 = pcbUsage + g_ulAdditionalProbeSize + 8;
  if ( v10 < pcbUsage )
    goto LABEL_11;
  if ( !(unsigned int)VerifyStackAvailable(v10) )
    goto LABEL_10;
  v8 = pcbUsage;
  v11 = pcbUsage + 8 + 15i64;
  if ( v11 <= pcbUsage + 8 )
    v11 = 0xFFFFFFFFFFFFFF0i64;
  v12 = alloca(v11 & 0xFFFFFFFFFFFFFFF0ui64);
  p_pcbUsage = (struct _CTL_USAGE *)&pcbUsage;
  if ( &v17 == (__int64 *)-32i64 )
    goto LABEL_11;
  pcbUsage = 1801679955;
  p_pcbUsage = (struct _CTL_USAGE *)v19;
  if ( !v19 )
  {
LABEL_10:
    v8 = pcbUsage;
LABEL_11:
    if ( v8 + 8 >= v8 )
    {
      v13 = (_DWORD *)((__int64 (__fastcall *)(_QWORD))g_pfnAllocate)(v8 + 8);
      if ( !v13 )
      {
LABEL_15:
        *a4 = 0;
        return 2148074240i64;
      }
      *v13 = 1885431112;
      p_pcbUsage = (struct _CTL_USAGE *)(v13 + 2);
    }
    if ( !p_pcbUsage )
      goto LABEL_15;
  }
  if ( CertGetEnhancedKeyUsage(pCertContext, v7, p_pcbUsage, &pcbUsage)
    && (p_pcbUsage->cUsageIdentifier || GetLastError() != -2146885628) )
  {
    v15 = 0;
    if ( p_pcbUsage->cUsageIdentifier )
    {
      rgpszUsageIdentifier = p_pcbUsage->rgpszUsageIdentifier;
      while ( strcmp_0("1.3.6.1.5.5.7.3.2", rgpszUsageIdentifier[v15]) )
      {
        if ( ++v15 >= p_pcbUsage->cUsageIdentifier )
          goto LABEL_29;
      }
      v4 = 1;
    }
LABEL_29:
    if ( LODWORD(p_pcbUsage[-1].rgpszUsageIdentifier) == 1885431112 )
      ((void (*)(void))g_pfnFree)();
    *a4 = v4;
    return 0i64;
  }
  if ( LODWORD(p_pcbUsage[-1].rgpszUsageIdentifier) == 1885431112 )
    ((void (*)(void))g_pfnFree)();
LABEL_19:
  *a4 = 1;
  return 0i64;
}
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;

//----- (00000001800546A4) ----------------------------------------------------
__int64 __fastcall SchGetTrustedRoots(void **a1, __int64 a2)
{
  HCERTSTORE v4; // r15
  DWORD LastError; // ebx
  HCERTSTORE v6; // rax
  void *v7; // r14
  DWORD v8; // eax
  PCCERT_CONTEXT i; // rsi
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  DWORD v15; // eax
  __int64 v16; // rdx
  char v17; // al
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  DWORD v21; // eax
  const CERT_CHAIN_CONTEXT *v22; // rcx
  int v24; // [rsp+40h] [rbp-158h] BYREF
  PCCERT_CHAIN_CONTEXT pChainContext; // [rsp+48h] [rbp-150h] BYREF
  const char *v26; // [rsp+50h] [rbp-148h] BYREF
  struct _CERT_CHAIN_POLICY_PARA pPolicyPara; // [rsp+58h] [rbp-140h] BYREF
  int v28[4]; // [rsp+68h] [rbp-130h] BYREF
  __int64 v29; // [rsp+78h] [rbp-120h]
  struct _CERT_CHAIN_POLICY_STATUS pPolicyStatus; // [rsp+80h] [rbp-118h] BYREF
  struct _CERT_CHAIN_PARA pChainPara; // [rsp+A0h] [rbp-F8h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v32; // [rsp+100h] [rbp-98h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v33; // [rsp+110h] [rbp-88h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v34; // [rsp+120h] [rbp-78h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v35; // [rsp+130h] [rbp-68h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v36; // [rsp+140h] [rbp-58h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v37; // [rsp+150h] [rbp-48h] BYREF

  pChainContext = 0i64;
  v24 = 0;
  v4 = CertOpenStore((LPCSTR)2, 0, 0i64, 4u, 0i64);
  if ( !v4 )
  {
    LastError = GetLastError();
    goto LABEL_42;
  }
  LastError = SslImpersonateClient(a2, &v24);
  if ( !LastError )
  {
    v6 = CertOpenStore((LPCSTR)0xA, 0, 0i64, 0x18001u, L"ROOT");
    v7 = v6;
    if ( !v6 )
    {
      v8 = GetLastError();
      LastError = v8;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids, v8);
      goto LABEL_40;
    }
    for ( i = CertEnumCertificatesInStore(v6, 0i64); i; i = CertEnumCertificatesInStore(v7, i) )
    {
      if ( IsCertSelfSigned(i) )
      {
        v26 = "1.3.6.1.5.5.7.3.2";
        memset_0(&pChainPara, 0, 0x60ui64);
        pChainPara.cbSize = 96;
        pChainPara.RequestedUsage.dwType = 1;
        pChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
        pChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = (LPSTR *)&v26;
        if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
          McGenEventWrite_EventWriteTransfer(1i64, &ChainBuildStart, v10, v11, &v32);
        if ( !CertGetCertificateChain(0i64, i, 0i64, 0i64, &pChainPara, 0, 0i64, &pChainContext) )
        {
          if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
            McGenEventWrite_EventWriteTransfer(v12, &ChainBuildStop, v13, v14, &v33);
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            continue;
          }
          v15 = GetLastError();
          v16 = 14i64;
LABEL_37:
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), v16, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids, v15);
          continue;
        }
        v17 = Microsoft_Windows_Schannel_EventsEnableBits;
        if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
        {
          McGenEventWrite_EventWriteTransfer(v12, &ChainBuildStop, v13, v14, &v34);
          v17 = Microsoft_Windows_Schannel_EventsEnableBits;
        }
        v28[3] = 0;
        v28[2] = 0;
        v29 = 0i64;
        pPolicyPara.pvExtraPolicyPara = v28;
        v28[0] = 24;
        v28[1] = 1;
        pPolicyPara.cbSize = 16;
        pPolicyPara.dwFlags = 7;
        memset(&pPolicyStatus, 0, sizeof(pPolicyStatus));
        pPolicyStatus.cbSize = 24;
        if ( (v17 & 1) != 0 )
          McGenEventWrite_EventWriteTransfer((__int64)v28, &ChainVerifyStart, v13, v14, &v35);
        if ( CertVerifyCertificateChainPolicy((LPCSTR)4, pChainContext, &pPolicyPara, &pPolicyStatus) )
        {
          if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
            McGenEventWrite_EventWriteTransfer(v18, &ChainVerifyStop, v19, v20, &v37);
          v22 = pChainContext;
          if ( !pPolicyStatus.dwError )
          {
            CertFreeCertificateChain(pChainContext);
            if ( CertAddCertificateContextToStore(v4, i, 2u, 0i64)
              || WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
            {
              continue;
            }
            v15 = GetLastError();
            v16 = 16i64;
            goto LABEL_37;
          }
        }
        else
        {
          if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
            McGenEventWrite_EventWriteTransfer(v18, &ChainVerifyStop, v19, v20, &v36);
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            v21 = GetLastError();
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids, v21);
          }
          v22 = pChainContext;
        }
        CertFreeCertificateChain(v22);
      }
    }
    CertCloseStore(v7, 0);
  }
LABEL_40:
  if ( v24 )
    RevertToSelf();
LABEL_42:
  if ( LastError )
    CertCloseStore(v4, 0);
  else
    *a1 = v4;
  return LastError;
}
// 180054840: variable 'v10' is possibly undefined
// 180054840: variable 'v11' is possibly undefined
// 18005489F: variable 'v12' is possibly undefined
// 18005489F: variable 'v13' is possibly undefined
// 18005489F: variable 'v14' is possibly undefined
// 1800549B5: variable 'v18' is possibly undefined
// 1800549B5: variable 'v19' is possibly undefined
// 1800549B5: variable 'v20' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180084C60: using guessed type EVENT_DESCRIPTOR ChainVerifyStop;
// 180084C70: using guessed type EVENT_DESCRIPTOR ChainVerifyStart;
// 180084C80: using guessed type EVENT_DESCRIPTOR ChainBuildStop;
// 180084C90: using guessed type EVENT_DESCRIPTOR ChainBuildStart;
// 1800854C0: using guessed type wchar_t aRoot[5];
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;

//----- (0000000180054B34) ----------------------------------------------------
__int64 __fastcall SerializeCertChain(
        __int64 a1,
        const struct _CERT_CONTEXT *a2,
        const struct _CERT_CHAIN_CONTEXT *a3,
        char a4,
        unsigned __int8 **a5,
        unsigned int *a6)
{
  unsigned int v6; // ebx
  unsigned int v10; // edi
  unsigned __int8 *v11; // rax
  char *v12; // rcx
  PCERT_SIMPLE_CHAIN *rgpChain; // rax
  DWORD v14; // ebp
  PCERT_SIMPLE_CHAIN i; // r15
  PCCERT_CONTEXT pCertContext; // r14
  unsigned int v17; // ecx
  unsigned __int8 *v18; // rax
  DWORD v19; // ebp
  char *j; // rsi
  PCCERT_CONTEXT v21; // rdi
  char *v22; // rsi

  v6 = 0;
  if ( !a6 )
    return 2148074244i64;
  if ( a3 )
  {
    rgpChain = a3->rgpChain;
    v10 = 0;
    v14 = 0;
    for ( i = *rgpChain; v14 < i->cElement; v10 = v17 + 3 )
    {
      pCertContext = i->rgpElement[v14]->pCertContext;
      if ( v14 )
      {
        if ( !a4
          && CertCompareCertificateName(
               pCertContext->dwCertEncodingType,
               &pCertContext->pCertInfo->Issuer,
               &pCertContext->pCertInfo->Subject) )
        {
          break;
        }
      }
      v17 = v10 + pCertContext->cbCertEncoded;
      if ( v10 > v17 )
        return 534;
      ++v14;
    }
    if ( !a5 )
      goto LABEL_5;
    if ( *a5 )
    {
      if ( *a6 < v10 )
        return (unsigned int)-2146893023;
    }
    else
    {
      v18 = (unsigned __int8 *)SPExternalAlloc(v10);
      *a5 = v18;
      if ( !v18 )
        return (unsigned int)-2146893056;
    }
    *a6 = v10;
    v19 = 0;
    for ( j = (char *)*a5; v19 < i->cElement; j = &v22[v21->cbCertEncoded] )
    {
      v21 = i->rgpElement[v19]->pCertContext;
      if ( v19
        && !a4
        && CertCompareCertificateName(v21->dwCertEncodingType, &v21->pCertInfo->Issuer, &v21->pCertInfo->Subject) )
      {
        break;
      }
      *j = BYTE2(v21->cbCertEncoded);
      j[1] = BYTE1(v21->cbCertEncoded);
      j[2] = v21->cbCertEncoded;
      v22 = j + 3;
      memcpy_0(v22, v21->pbCertEncoded, v21->cbCertEncoded);
      ++v19;
    }
    return v6;
  }
  v10 = a2->cbCertEncoded + 3;
  if ( a5 )
  {
    if ( !*a5 )
    {
      v11 = (unsigned __int8 *)SPExternalAlloc(v10);
      *a5 = v11;
      if ( !v11 )
        return (unsigned int)-2146893056;
LABEL_11:
      *a6 = v10;
      v12 = (char *)*a5;
      *v12 = BYTE2(a2->cbCertEncoded);
      v12[1] = BYTE1(a2->cbCertEncoded);
      v12[2] = a2->cbCertEncoded;
      memcpy_0(v12 + 3, a2->pbCertEncoded, a2->cbCertEncoded);
      return v6;
    }
    if ( *a6 >= v10 )
      goto LABEL_11;
    return (unsigned int)-2146893023;
  }
LABEL_5:
  *a6 = v10;
  return v6;
}

//----- (0000000180054D10) ----------------------------------------------------
void __fastcall CTlsSignatureSuiteList::SetCertificateChainSignatureSuites(
        CTlsSignatureSuiteList *this,
        const struct _CERT_CONTEXT *a2,
        const struct _CERT_CHAIN_CONTEXT *a3,
        char a4)
{
  char v6; // si
  DWORD v7; // edi
  PCERT_SIMPLE_CHAIN v8; // rbp
  const CERT_CONTEXT *pCertContext; // r14

  *(_WORD *)this = 0;
  *((_WORD *)this + 17) = 0;
  v6 = 1;
  if ( a3 )
  {
    v7 = 0;
    v8 = *a3->rgpChain;
    if ( !v8->cElement )
      return;
    do
    {
      pCertContext = v8->rgpElement[v7]->pCertContext;
      if ( v7
        && !a4
        && CertCompareCertificateName(
             pCertContext->dwCertEncodingType,
             &pCertContext->pCertInfo->Issuer,
             &pCertContext->pCertInfo->Subject) )
      {
        break;
      }
      v6 = CTlsSignatureSuiteList::AddCertificateSignatureSuite(this, pCertContext);
      if ( !v6 )
        goto LABEL_10;
      ++v7;
    }
    while ( v7 < v8->cElement );
  }
  else
  {
    v6 = CTlsSignatureSuiteList::AddCertificateSignatureSuite(this, a2);
  }
  if ( !v6 )
  {
LABEL_10:
    *(_WORD *)this = 0;
    *((_WORD *)this + 17) = 0;
  }
}

//----- (0000000180054DE4) ----------------------------------------------------
__int64 __fastcall VerifyClientCertificate(
        PCCERT_CHAIN_CONTEXT pChainContext,
        LPCSTR pszPolicyOID,
        __int64 a3,
        __int64 a4)
{
  __int16 v5; // r14
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int v10; // edi
  struct _CERT_CHAIN_POLICY_PARA pPolicyPara; // [rsp+30h] [rbp-19h] BYREF
  int v13[3]; // [rsp+40h] [rbp-9h] BYREF
  __int64 v14; // [rsp+4Ch] [rbp+3h]
  int v15; // [rsp+54h] [rbp+Bh]
  struct _CERT_CHAIN_POLICY_STATUS pPolicyStatus; // [rsp+58h] [rbp+Fh] BYREF
  struct _EVENT_DATA_DESCRIPTOR v17; // [rsp+70h] [rbp+27h] BYREF

  pPolicyPara.cbSize = 16;
  v5 = a3;
  if ( pszPolicyOID == (LPCSTR)6 )
  {
    pPolicyPara.pvExtraPolicyPara = 0i64;
    pPolicyPara.dwFlags = 0x40000000;
  }
  else
  {
    v14 = 0i64;
    v15 = 0;
    v13[2] = 0;
    pPolicyPara.dwFlags = 0;
    pPolicyPara.pvExtraPolicyPara = v13;
    v13[0] = 24;
    v13[1] = 1;
  }
  memset(&pPolicyStatus, 0, sizeof(pPolicyStatus));
  pPolicyStatus.cbSize = 24;
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EventWriteTransfer(24i64, &ChainVerifyStart, a3, a4, &v17);
  if ( CertVerifyCertificateChainPolicy(pszPolicyOID, pChainContext, &pPolicyPara, &pPolicyStatus) )
  {
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McGenEventWrite_EventWriteTransfer(v7, &ChainVerifyStop, v8, v9, &v17);
    v10 = I_MapWinTrustErrorAndAlert(pPolicyStatus.dwError, 0, v5, 0i64);
    if ( v10 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids, v10);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McGenEventWrite_EventWriteTransfer(v7, &ChainVerifyStop, v8, v9, &v17);
    return GetLastError();
  }
  return v10;
}
// 180054EB8: variable 'v7' is possibly undefined
// 180054EB8: variable 'v8' is possibly undefined
// 180054EB8: variable 'v9' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180084C60: using guessed type EVENT_DESCRIPTOR ChainVerifyStop;
// 180084C70: using guessed type EVENT_DESCRIPTOR ChainVerifyStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;

//----- (0000000180054F60) ----------------------------------------------------
ULONG __fastcall McGenEventWrite_EventWriteTransfer(
        __int64 a1,
        const EVENT_DESCRIPTOR *a2,
        __int64 a3,
        __int64 a4,
        PEVENT_DATA_DESCRIPTOR UserData)
{
  unsigned __int16 *v5; // r8
  ULONG v6; // eax
  ULONG v7; // r8d

  v5 = (unsigned __int16 *)qword_180091388;
  v6 = 0;
  if ( qword_180091388 )
  {
    UserData->Ptr = qword_180091388;
    v6 = 2;
    v7 = *v5;
  }
  else
  {
    UserData->Ptr = 0i64;
    v7 = 0;
  }
  UserData->Size = v7;
  UserData->Reserved = v6;
  return EventWriteTransfer(MS_Schannel_Provider_Context, a2, 0i64, 0i64, 1u, UserData);
}
// 180091388: using guessed type __int64 qword_180091388;

//----- (0000000180054FC4) ----------------------------------------------------
void CSslGlobals::CleanupCryptLocatorEvents(void)
{
  if ( CSslGlobals::m_hImplicitCertChangeEvent )
  {
    CloseHandle(CSslGlobals::m_hImplicitCertChangeEvent);
    CSslGlobals::m_hImplicitCertChangeEvent = 0i64;
  }
  if ( CSslGlobals::m_hImplicitIssersChangeEvent )
  {
    CloseHandle(CSslGlobals::m_hImplicitIssersChangeEvent);
    CSslGlobals::m_hImplicitIssersChangeEvent = 0i64;
  }
}

//----- (0000000180055014) ----------------------------------------------------
void CSslGlobals::CleanupCryptLocatorHandles(void)
{
  if ( CSslGlobals::m_hCertLocator )
  {
    CryptObjectLocatorRelease(1u, CSslGlobals::m_hCertLocator);
    CSslGlobals::m_hCertLocator = 0i64;
  }
  if ( CSslGlobals::m_hIssuersLocator )
  {
    CryptObjectLocatorRelease(1u, CSslGlobals::m_hIssuersLocator);
    CSslGlobals::m_hIssuersLocator = 0i64;
  }
}
// 180092F60: using guessed type void *CSslGlobals::m_hIssuersLocator;
// 180092F68: using guessed type void *CSslGlobals::m_hCertLocator;
// 180098198: using guessed type void __stdcall CryptObjectLocatorRelease(unsigned int, void *);

//----- (0000000180055070) ----------------------------------------------------
void CSslGlobals::CleanupPeriodicCleanupHandler(void)
{
  int LastError; // eax

  if ( (unsigned int)_InterlockedIncrement((volatile signed __int32 *)&CSslGlobals::m_lReentryCount) <= 1 )
  {
    if ( CSslGlobals::m_hCleanupWaitObject )
    {
      if ( !UnregisterWaitEx(CSslGlobals::m_hCleanupWaitObject, (HANDLE)0xFFFFFFFFFFFFFFFFi64)
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      {
        LastError = GetLastError();
        WPP_SF_d(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xAu,
          (__int64)&WPP_092b895ef39c3c047a28e4103b904d61_Traceguids,
          LastError);
      }
      CSslGlobals::m_hCleanupWaitObject = 0i64;
    }
    if ( CSslGlobals::m_hCleanupEvent )
    {
      CloseHandle(CSslGlobals::m_hCleanupEvent);
      CSslGlobals::m_hCleanupEvent = 0i64;
    }
  }
  _InterlockedDecrement((volatile signed __int32 *)&CSslGlobals::m_lReentryCount);
}
// 180092EE0: using guessed type unsigned int CSslGlobals::m_lReentryCount;

//----- (000000018005512C) ----------------------------------------------------
__int64 CSslGlobals::InitializeCryptLocatorHandles(void)
{
  DWORD v0; // ebx
  void *v1; // rdi
  DWORD v2; // eax
  void *v3; // rsi
  DWORD LastError; // eax

  v0 = 0;
  RtlAcquireResourceExclusive(&SslGlobalLock, 1u);
  if ( !CSslGlobals::m_hCertLocator )
  {
    v1 = CryptObjectLocatorInitialize(
           "SslObjectLocatorInitializePfx",
           1u,
           0,
           0i64,
           CSslGlobals::m_hImplicitCertChangeEvent);
    if ( v1 )
    {
      v3 = CryptObjectLocatorInitialize(
             "SslObjectLocatorInitializeIssuerList",
             2u,
             0,
             0i64,
             CSslGlobals::m_hImplicitIssersChangeEvent);
      if ( !v3
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        LastError = GetLastError();
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          14i64,
          &WPP_092b895ef39c3c047a28e4103b904d61_Traceguids,
          LastError);
      }
      CSslGlobals::m_hCertLocator = v1;
      CSslGlobals::m_hIssuersLocator = v3;
    }
    else
    {
      v2 = GetLastError();
      v0 = v2;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_092b895ef39c3c047a28e4103b904d61_Traceguids, v2);
    }
  }
  RtlReleaseResource(&SslGlobalLock);
  return v0;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092F60: using guessed type void *CSslGlobals::m_hIssuersLocator;
// 180092F68: using guessed type void *CSslGlobals::m_hCertLocator;
// 180098190: using guessed type void *__stdcall CryptObjectLocatorInitialize(const char *, unsigned int, unsigned int, void *, void *);

//----- (0000000180055288) ----------------------------------------------------
DWORD __fastcall CCredentialGroup::CheckCertStoreChangeNotification(CCredentialGroup *this, void *a2, void *a3)
{
  DWORD v5; // eax
  void *pvCtrlPara; // [rsp+40h] [rbp+18h] BYREF

  pvCtrlPara = a3;
  if ( !a2 || !a3 )
    return 87;
  v5 = WaitForSingleObjectEx(a3, 0, 0);
  if ( v5 != -1 && (v5 || (*((_DWORD *)this + 39) |= 0x10u, CertControlStore(a2, 0, 1u, &pvCtrlPara))) )
    return 0;
  else
    return GetLastError();
}

//----- (0000000180055318) ----------------------------------------------------
void __fastcall CCredentialGroup::CheckForCertificateStoreChange(CCredentialGroup *this)
{
  void *v2; // rdx
  void *v3; // r8
  DWORD v4; // eax
  void *v5; // rdx
  void *v6; // r8
  DWORD v7; // eax
  void *v8; // rdx
  void *v9; // r8
  DWORD v10; // eax
  ULONG v11; // eax
  DWORD v12; // eax
  int v13; // [rsp+30h] [rbp+8h] BYREF

  v13 = 0;
  if ( _InterlockedIncrement((volatile signed __int32 *)this + 37) <= 1 )
  {
    if ( (*((_DWORD *)this + 38) & 0x40051555) != 0 )
      CCredentialGroup::InitializeCertificateStoreChange(this);
    v2 = (void *)*((_QWORD *)this + 96);
    if ( v2 )
    {
      v3 = (void *)*((_QWORD *)this + 97);
      if ( v3 )
      {
        v4 = CCredentialGroup::CheckCertStoreChangeNotification(this, v2, v3);
        if ( v4 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 29i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, v4);
          }
        }
      }
    }
    v5 = (void *)*((_QWORD *)this + 102);
    if ( v5 )
    {
      v6 = (void *)*((_QWORD *)this + 103);
      if ( v6 )
      {
        v7 = CCredentialGroup::CheckCertStoreChangeNotification(this, v5, v6);
        if ( v7 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 30i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, v7);
          }
        }
      }
    }
    v8 = (void *)*((_QWORD *)this + 104);
    if ( v8 )
    {
      v9 = (void *)*((_QWORD *)this + 105);
      if ( v9 )
      {
        v10 = CCredentialGroup::CheckCertStoreChangeNotification(this, v8, v9);
        if ( v10 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 31i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, v10);
          }
        }
      }
    }
    if ( *((_QWORD *)this + 98) && *((_QWORD *)this + 99) )
    {
      v11 = SslImpersonateClient(*((_QWORD *)this + 94), &v13);
      if ( v11 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 32i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, v11);
      }
      else
      {
        v12 = CCredentialGroup::CheckCertStoreChangeNotification(this, *((void **)this + 98), *((void **)this + 99));
        if ( v12
          && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 33i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, v12);
        }
        if ( v13 )
          RevertToSelf();
      }
    }
  }
  _InterlockedDecrement((volatile signed __int32 *)this + 37);
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082B38: using guessed type GUID WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids;

//----- (0000000180055510) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::CheckForCredentialRenewal(CCredentialGroup *this)
{
  unsigned int v3; // edi
  unsigned int v4; // eax

  if ( (*((_DWORD *)this + 38) & 0x40051555) == 0 )
    return 0i64;
  RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)this + 48), 1u);
  v3 = 0;
  if ( (*((_BYTE *)this + 156) & 0x40) != 0 )
  {
    if ( *((_QWORD *)this + 100) )
      v4 = CCredentialGroup::RenewImplicitCertificates((void **)this);
    else
      v4 = CCredentialGroup::RenewLocalStoreCertificates(this);
    if ( !v4 )
      *((_DWORD *)this + 39) &= ~0x40u;
    v3 = v4;
  }
  RtlReleaseResource((PRTL_RESOURCE)((char *)this + 48));
  return v3;
}

//----- (00000001800555A0) ----------------------------------------------------
char __fastcall CCredentialGroup::CheckForValidIssuer(CCredentialGroup *this, const struct _CERT_CHAIN_CONTEXT *a2)
{
  struct _RTL_RESOURCE *v2; // r12
  unsigned __int8 *v5; // rdi
  char v6; // bl
  __int64 v7; // rbp
  unsigned __int64 v8; // r13
  PCERT_SIMPLE_CHAIN v9; // r15
  int v10; // r14d
  PCCERT_CONTEXT pCertContext; // rax
  _BYTE *v12; // rsi
  struct _CRYPTOAPI_BLOB pCertName2; // [rsp+20h] [rbp-38h] BYREF

  v2 = (struct _RTL_RESOURCE *)((char *)this + 48);
  pCertName2 = 0i64;
  RtlAcquireResourceShared((PRTL_RESOURCE)((char *)this + 48), 1u);
  v5 = (unsigned __int8 *)*((_QWORD *)this + 108);
  v6 = 0;
  if ( v5 )
  {
    v7 = *((unsigned int *)this + 214);
    if ( (unsigned int)v7 >= 2 )
    {
      v8 = (unsigned __int64)&v5[v7];
      v9 = *a2->rgpChain;
      while ( 1 )
      {
        v12 = v5 + 1;
        if ( (unsigned __int64)(v5 + 1) >= v8 )
          break;
        pCertName2.pbData = v5 + 2;
        LOBYTE(pCertName2.cbData) = *v12;
        BYTE1(pCertName2.cbData) = *v5;
        if ( pCertName2.cbData > (unsigned int)v7 )
          break;
        v10 = 0;
        if ( v9->cElement )
        {
          while ( 1 )
          {
            pCertContext = v9->rgpElement[v10]->pCertContext;
            if ( CertCompareCertificateName(
                   pCertContext->dwCertEncodingType,
                   &pCertContext->pCertInfo->Issuer,
                   &pCertName2) )
            {
              break;
            }
            if ( ++v10 >= v9->cElement )
              goto LABEL_14;
          }
          v6 = 1;
          break;
        }
LABEL_14:
        v5 += ((unsigned __int8)*v12 | ((unsigned __int64)*v5 << 8)) + 2;
      }
    }
    else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
    {
      WPP_SF_d(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x27u,
        (__int64)&WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids,
        v7);
    }
  }
  else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 38i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids);
  }
  RtlReleaseResource(v2);
  return v6;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180082B38: using guessed type GUID WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids;

//----- (0000000180055730) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::ConstructIssuersList(CCredentialGroup *this)
{
  unsigned int TrustedRoots; // ebx
  unsigned int v2; // r15d
  unsigned __int8 *v4; // rdi
  void *v5; // rcx
  void *v6; // rcx
  unsigned __int8 *v7; // rax
  void *v8; // rcx
  void *v9; // rcx
  const CERT_CONTEXT *v10; // rax
  void *v11; // r14
  unsigned int v12; // ebx
  unsigned __int8 *v13; // rax
  CCredentialGroup *v14; // rcx
  __int64 v15; // rbx
  bool v16; // zf
  unsigned __int8 *v17; // rax
  unsigned int v18; // ebx
  int v19; // edx
  int v20; // ecx
  unsigned int v21; // eax
  unsigned int v22; // ebx
  struct _UNICODE_STRING DestinationString; // [rsp+20h] [rbp-10h] BYREF
  SIZE_T uBytes; // [rsp+70h] [rbp+40h] BYREF
  SIZE_T Size; // [rsp+78h] [rbp+48h] BYREF
  void *v27; // [rsp+80h] [rbp+50h] BYREF
  void *Src; // [rsp+88h] [rbp+58h] BYREF

  TrustedRoots = 0;
  v2 = 0;
  Src = 0i64;
  LODWORD(Size) = 0;
  v4 = 0i64;
  v27 = 0i64;
  v5 = (void *)*((_QWORD *)this + 108);
  LODWORD(uBytes) = 0;
  if ( v5 )
  {
    if ( (*((_BYTE *)this + 156) & 0x10) == 0 )
      return TrustedRoots;
    LocalFree(v5);
    *((_QWORD *)this + 108) = 0i64;
    *((_DWORD *)this + 214) = 0;
  }
  *((_DWORD *)this + 39) &= ~0x10u;
  v6 = (void *)*((_QWORD *)this + 96);
  if ( v6 )
  {
    if ( (unsigned int)ExtractIssuerNamesFromStore(v6, 0i64, (unsigned int *)&uBytes, 0i64) )
      goto LABEL_10;
    v7 = (unsigned __int8 *)LocalAlloc(0x40u, (unsigned int)uBytes);
    v4 = v7;
    if ( !v7 )
      return 14;
    if ( !(unsigned int)ExtractIssuerNamesFromStore(*((void **)this + 96), v7, (unsigned int *)&uBytes, 0i64) )
    {
LABEL_10:
      v2 = uBytes;
    }
    else
    {
      LocalFree(v4);
      v4 = 0i64;
    }
  }
  v8 = (void *)*((_QWORD *)this + 102);
  if ( v8 )
  {
LABEL_15:
    v27 = CertDuplicateStore(v8);
    v11 = v27;
    if ( v27 )
      goto LABEL_22;
    goto LABEL_16;
  }
  v9 = (void *)*((_QWORD *)this + 104);
  if ( v9 )
  {
    v10 = CertEnumCertificatesInStore(v9, 0i64);
    if ( v10 )
    {
      CertFreeCertificateContext(v10);
      v8 = (void *)*((_QWORD *)this + 104);
      goto LABEL_15;
    }
  }
LABEL_16:
  TrustedRoots = SchGetTrustedRoots(&v27, *((_QWORD *)this + 94));
  if ( TrustedRoots )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        35i64,
        &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids,
        TrustedRoots);
    v11 = v27;
    goto LABEL_38;
  }
  v11 = v27;
LABEL_22:
  TrustedRoots = ConstructIssuersListFromStore(v11, (unsigned __int8 **)&Src, (unsigned int *)&Size);
  if ( !TrustedRoots )
  {
    if ( v4 )
    {
      v12 = Size;
      if ( (unsigned int)Size + v2 < v2 )
      {
LABEL_30:
        TrustedRoots = 534;
LABEL_42:
        LocalFree(v4);
        goto LABEL_52;
      }
      v13 = (unsigned __int8 *)LocalReAlloc(v4, (unsigned int)Size + v2, 2u);
      if ( !v13 )
      {
        TrustedRoots = 14;
        goto LABEL_42;
      }
      v4 = v13;
    }
    else
    {
      v12 = Size;
      v4 = (unsigned __int8 *)LocalAlloc(0x40u, (unsigned int)Size);
      if ( !v4 )
      {
        TrustedRoots = 14;
        goto LABEL_52;
      }
    }
    memcpy_0(&v4[v2], Src, v12);
    v15 = v2 + v12;
    v16 = (*((_BYTE *)this + 156) & 1) == 0;
    LODWORD(uBytes) = v15;
    if ( !v16 )
      goto LABEL_41;
    if ( (int)v15 + 27 >= (unsigned int)v15 )
    {
      v17 = (unsigned __int8 *)LocalReAlloc(v4, (unsigned int)(v15 + 27), 2u);
      if ( !v17 )
      {
        TrustedRoots = 14;
        goto LABEL_38;
      }
      v4 = v17;
      LODWORD(uBytes) = v15 + 27;
      *(_OWORD *)&v17[v15] = *(_OWORD *)&SslNtAuthorityName;
      qmemcpy(&v17[v15 + 16], "T AUTHORITY", 11);
LABEL_41:
      TrustedRoots = CCredentialGroup::RemoveDuplicateIssuers(v14, v4, (unsigned int *)&uBytes);
      if ( !TrustedRoots )
      {
        v18 = uBytes;
        *((_DWORD *)this + 214) = uBytes;
        *((_QWORD *)this + 108) = v4;
        if ( v18 > 0x3FD0 )
        {
          v19 = 0;
          while ( 1 )
          {
            v20 = v4[1] | (*v4 << 8);
            v21 = v20 + v19 + 2;
            if ( v21 > 0x3FD0 )
              break;
            v19 += v20 + 2;
            v4 += (unsigned int)(v20 + 2);
            if ( v21 >= v18 )
              goto LABEL_49;
          }
          *((_DWORD *)this + 214) = v19;
LABEL_49:
          v22 = *((_DWORD *)this + 53);
          if ( (g_dwEventLogging & 1) != 0 )
          {
            RtlInitUnicodeString(&DestinationString, (PCWSTR)this + 108);
            SchEventWrite(&SSLEVENT_ISSUER_LIST_OVERFLOW_FAILURE, L"du", v22, &DestinationString);
          }
        }
        TrustedRoots = 0;
        goto LABEL_52;
      }
      goto LABEL_42;
    }
    goto LABEL_30;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 36i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, TrustedRoots);
LABEL_38:
  if ( v4 )
    goto LABEL_42;
LABEL_52:
  if ( v11 )
    CertCloseStore(v11, 0);
  if ( Src )
    SPExternalFree(Src);
  return TrustedRoots;
}
// 180055A6E: conditional instruction was optimized away because ebx.4>=3FD1u
// 18005599E: conditional instruction was optimized away because rdi.8!=0
// 180055A22: conditional instruction was optimized away because rdi.8!=0
// 180055A5D: conditional instruction was optimized away because rdi.8!=0
// 180055A2B: variable 'v14' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082B38: using guessed type GUID WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids;
// 180091A00: using guessed type unsigned __int8 near *SslNtAuthorityName;

//----- (0000000180055B18) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::CreateRenewedCredential(CCredentialGroup *this, struct LSA_SCHANNEL_SUB_CRED *a2)
{
  CSslCredential *v4; // rax
  CSslCredential *v5; // rdi
  _QWORD *v6; // rax
  _QWORD *v7; // rdi
  __int64 v8; // rcx

  v4 = (CSslCredential *)SPExternalAlloc(0x498u);
  if ( !v4 )
    return 14i64;
  v5 = CSslCredential::CSslCredential(v4);
  if ( !v5 )
    return 14i64;
  if ( (unsigned int)CSslCredential::CreateCredential(
                       v5,
                       *((_DWORD *)this + 53),
                       (char *)this + 216,
                       *((_QWORD *)this + 94),
                       a2,
                       0,
                       0,
                       *((_QWORD *)this + 100) != 0i64,
                       *((struct _TLS_PARAMETERS **)this + 25),
                       *((_DWORD *)this + 49)) )
  {
    (*(void (__fastcall **)(CSslCredential *, __int64))(*(_QWORD *)v5 + 8i64))(v5, 1i64);
  }
  else
  {
    if ( *((_DWORD *)v5 + 35) )
      *((_BYTE *)this + 900) = 1;
    v6 = (_QWORD *)((char *)this + 32);
    v7 = (_QWORD *)((char *)v5 + 8);
    v8 = *((_QWORD *)this + 4);
    if ( *(CCredentialGroup **)(v8 + 8) != (CCredentialGroup *)((char *)this + 32) )
      __fastfail(3u);
    *v7 = v8;
    v7[1] = v6;
    *(_QWORD *)(v8 + 8) = v7;
    *v6 = v7;
    ++*((_DWORD *)this + 7);
  }
  return 0i64;
}

//----- (0000000180055C40) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::DuplicateIssuerList(
        CCredentialGroup *this,
        unsigned __int8 **a2,
        unsigned int *a3)
{
  struct _RTL_RESOURCE *v6; // rdi
  unsigned int v7; // ecx
  unsigned __int8 *v8; // rax

  if ( !a2 || !a3 )
    return 87i64;
  *a2 = 0i64;
  v6 = (struct _RTL_RESOURCE *)((char *)this + 48);
  *a3 = 0;
  RtlAcquireResourceShared((PRTL_RESOURCE)((char *)this + 48), 1u);
  if ( *((_QWORD *)this + 108) )
  {
    v7 = *((_DWORD *)this + 214);
    if ( v7 )
    {
      v8 = (unsigned __int8 *)SPExternalAlloc(v7);
      *a2 = v8;
      if ( !v8 )
      {
        RtlReleaseResource(v6);
        return 14i64;
      }
      memcpy_0(v8, *((const void **)this + 108), *((unsigned int *)this + 214));
      *a3 = *((_DWORD *)this + 214);
    }
  }
  RtlReleaseResource(v6);
  return 0i64;
}

//----- (0000000180055D18) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::FindCredential(
        CCredentialGroup *this,
        unsigned __int8 *a2,
        int a3,
        struct CSslCredential **a4)
{
  unsigned int v8; // ebx
  CCredentialGroup *v9; // rdx
  char *v10; // r8
  unsigned __int64 v11; // rcx

  v8 = 1168;
  if ( !a2 || !a3 || !a4 )
    return 87i64;
  RtlAcquireResourceShared((PRTL_RESOURCE)((char *)this + 48), 1u);
  v9 = (CCredentialGroup *)*((_QWORD *)this + 4);
  while ( v9 != (CCredentialGroup *)((char *)this + 32) )
  {
    v10 = (char *)v9 - 8;
    v9 = *(CCredentialGroup **)v9;
    if ( a3 == 20 )
    {
      v11 = *((_QWORD *)v10 + 5) - *(_QWORD *)a2;
      if ( !v11 )
      {
        v11 = *((_QWORD *)v10 + 6) - *((_QWORD *)a2 + 1);
        if ( !v11 )
          v11 = *((unsigned int *)v10 + 14) - (unsigned __int64)*((unsigned int *)a2 + 4);
      }
      if ( !v11 )
      {
        v8 = 0;
        *a4 = (struct CSslCredential *)v10;
        break;
      }
    }
  }
  RtlReleaseResource((PRTL_RESOURCE)((char *)this + 48));
  return v8;
}

//----- (0000000180055DE0) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::GetFileFullPath(
        CCredentialGroup *this,
        const unsigned __int16 *a2,
        unsigned __int16 **a3)
{
  unsigned int v5; // ebx
  DWORD v6; // eax
  DWORD v7; // edi
  signed int v8; // eax
  WCHAR *v9; // rax
  unsigned __int16 *v10; // rsi
  signed int LastError; // eax
  unsigned int v12; // edi

  v5 = 0;
  v6 = ExpandEnvironmentStringsW(a2, 0i64, 0);
  v7 = v6;
  if ( v6 )
  {
    v9 = (WCHAR *)LocalAlloc(0x40u, 2i64 * v6);
    v10 = v9;
    if ( v9 )
    {
      if ( ExpandEnvironmentStringsW(a2, v9, v7) )
      {
        *a3 = v10;
      }
      else
      {
        LastError = GetLastError();
        v12 = LastError;
        if ( LastError > 0 )
          v12 = (unsigned __int16)LastError | 0x80070000;
        LocalFree(v10);
        return v12;
      }
    }
    else
    {
      return (unsigned int)-2146893810;
    }
  }
  else
  {
    v8 = GetLastError();
    if ( v8 > 0 )
      return (unsigned __int16)v8 | 0x80070000;
    else
      return (unsigned int)v8;
  }
  return v5;
}

//----- (0000000180055ED0) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::GetKeyFilePath(CCredentialGroup *this, unsigned __int16 **a2)
{
  DWORD LastError; // ebx
  struct _RTL_RESOURCE *v5; // r15
  unsigned __int16 *v6; // rdi
  unsigned __int16 **v7; // r14
  SIZE_T v8; // rsi
  wchar_t *v9; // rax
  size_t *v10; // r8
  CCredentialGroup *v11; // rcx
  size_t v13; // [rsp+20h] [rbp-E0h]
  LPWSTR StringSid; // [rsp+30h] [rbp-D0h] BYREF
  size_t pcchLength; // [rsp+38h] [rbp-C8h] BYREF
  unsigned __int16 v16[8]; // [rsp+40h] [rbp-C0h] BYREF
  __int128 v17; // [rsp+50h] [rbp-B0h]
  __int64 v18; // [rsp+60h] [rbp-A0h]
  int v19; // [rsp+68h] [rbp-98h]
  wchar_t pszSrc[64]; // [rsp+70h] [rbp-90h] BYREF
  unsigned __int8 Sid[80]; // [rsp+F0h] [rbp-10h] BYREF

  LastError = 0;
  memset_0(Sid, 0, 0x44ui64);
  v5 = (struct _RTL_RESOURCE *)((char *)this + 48);
  StringSid = 0i64;
  v6 = 0i64;
  wcscpy(pszSrc, L"%ALLUSERSPROFILE%\\Microsoft\\Crypto\\TlsSessionTicketKeys\\");
  v19 = *(_DWORD *)L"y";
  *(_OWORD *)v16 = *(_OWORD *)L"\\SessionTicketKey.key";
  v18 = *(_QWORD *)L"y.key";
  v17 = *(_OWORD *)L"TicketKey.key";
  RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)this + 48), 1u);
  v7 = (unsigned __int16 **)((char *)this + 888);
  if ( *((_QWORD *)this + 111) )
    goto LABEL_15;
  if ( !(unsigned int)GetTokenUserSid(*((void **)this + 94), Sid) || !ConvertSidToStringSidW(Sid, &StringSid) )
  {
    LastError = GetLastError();
    goto LABEL_16;
  }
  pcchLength = 0i64;
  if ( !StringSid || StringLengthWorkerW(StringSid, 0x7FFFFFFFui64, &pcchLength) < 0 )
    goto LABEL_14;
  v8 = (unsigned int)(2 * pcchLength + 156);
  v9 = (wchar_t *)LocalAlloc(0x40u, v8);
  v6 = v9;
  if ( !v9 )
  {
    LastError = 14;
    goto LABEL_16;
  }
  if ( v8 >> 1
    && StringCopyWorkerW(v9, v8 >> 1, v10, pszSrc, v13) >= 0
    && StringCbCatW(v6, v8, StringSid) >= 0
    && StringCbCatW(v6, v8, v16) >= 0
    && (int)CCredentialGroup::GetFileFullPath(v11, v6, v7) >= 0 )
  {
LABEL_15:
    *a2 = *v7;
  }
  else
  {
LABEL_14:
    LastError = 1359;
  }
LABEL_16:
  RtlReleaseResource(v5);
  if ( v6 )
    LocalFree(v6);
  if ( StringSid )
    LocalFree(StringSid);
  return LastError;
}
// 18005606C: variable 'v10' is possibly undefined
// 18005606C: variable 'v13' is possibly undefined
// 1800560A3: variable 'v11' is possibly undefined
// 180085560: using guessed type wchar_t aAllusersprofil[57];
// 1800855D8: using guessed type wchar_t aSessionticketk[22];

//----- (0000000180056124) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::GetNameFromFirstCred(CCredentialGroup *this, unsigned __int16 **a2)
{
  struct _RTL_RESOURCE *v5; // rbx
  NTSTATUS NameFromCertificate; // edi
  int v7; // [rsp+30h] [rbp+8h] BYREF

  if ( !*((_DWORD *)this + 7) )
    return 2148074254i64;
  v5 = (struct _RTL_RESOURCE *)((char *)this + 48);
  RtlAcquireResourceShared((PRTL_RESOURCE)((char *)this + 48), 1u);
  NameFromCertificate = SslGetNameFromCertificate(*(PCCERT_CONTEXT *)(*((_QWORD *)this + 4) + 24i64), a2, &v7);
  RtlReleaseResource(v5);
  if ( NameFromCertificate >= 0 )
    return 0i64;
  else
    return SspNtStatusToSecStatus(NameFromCertificate);
}

//----- (00000001800561B4) ----------------------------------------------------
void __fastcall CCredentialGroup::InitializeCertificateStoreChange(CCredentialGroup *this)
{
  void *v1; // rdx
  CCredentialGroup *v2; // rbx
  DWORD v3; // eax
  void *v4; // rdx
  DWORD v5; // eax
  HCERTSTORE v6; // rax
  CCredentialGroup *v7; // rcx
  DWORD LastError; // eax
  CCipherMill *v9; // rcx
  __int64 v10; // rdx
  ULONG v11; // eax
  HCERTSTORE v12; // rax
  CCredentialGroup *v13; // rcx
  DWORD v14; // eax
  CCipherMill *v15; // rcx
  __int64 v16; // rdx
  int v17; // [rsp+40h] [rbp+8h] BYREF

  v17 = 0;
  v1 = (void *)*((_QWORD *)this + 96);
  v2 = this;
  if ( v1 )
  {
    if ( !*((_QWORD *)this + 97) )
    {
      v3 = CCredentialGroup::SubscribeCertStoreChangeNotification(this, v1, (void **)this + 97);
      if ( v3 )
      {
        this = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, v3);
      }
    }
  }
  v4 = (void *)*((_QWORD *)v2 + 102);
  if ( v4 )
  {
    if ( !*((_QWORD *)v2 + 103) )
    {
      v5 = CCredentialGroup::SubscribeCertStoreChangeNotification(this, v4, (void **)v2 + 103);
      if ( v5 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, v5);
      }
    }
  }
  if ( !*((_QWORD *)v2 + 104) )
  {
    v6 = CertOpenStore((LPCSTR)0xA, 0, 0i64, 0x20000u, L"ClientAuthIssuer");
    *((_QWORD *)v2 + 104) = v6;
    if ( v6 )
    {
      if ( !*((_QWORD *)v2 + 105) )
      {
        LastError = CCredentialGroup::SubscribeCertStoreChangeNotification(v7, v6, (void **)v2 + 105);
        if ( LastError )
        {
          v9 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            v10 = 17i64;
            goto LABEL_23;
          }
        }
      }
    }
    else
    {
      LastError = GetLastError();
      v9 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        v10 = 16i64;
LABEL_23:
        WPP_SF_D(*((_QWORD *)v9 + 2), v10, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, LastError);
      }
    }
  }
  if ( *((_QWORD *)v2 + 98) )
    return;
  v11 = SslImpersonateClient(*((_QWORD *)v2 + 94), &v17);
  if ( v11 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, v11);
    return;
  }
  v12 = CertOpenStore((LPCSTR)0xA, 0, 0i64, 0x18001u, L"ROOT");
  *((_QWORD *)v2 + 98) = v12;
  if ( v12 )
  {
    if ( !*((_QWORD *)v2 + 99) )
    {
      v14 = CCredentialGroup::SubscribeCertStoreChangeNotification(v13, v12, (void **)v2 + 99);
      if ( v14 )
      {
        v15 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          v16 = 20i64;
          goto LABEL_38;
        }
      }
    }
  }
  else
  {
    v14 = GetLastError();
    v15 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      v16 = 19i64;
LABEL_38:
      WPP_SF_D(*((_QWORD *)v15 + 2), v16, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, v14);
    }
  }
  if ( v17 )
    RevertToSelf();
}
// 18005623B: variable 'this' is possibly undefined
// 1800562DF: variable 'v7' is possibly undefined
// 1800563CB: variable 'v13' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082B38: using guessed type GUID WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids;
// 1800854C0: using guessed type wchar_t aRoot[5];
// 180085538: using guessed type wchar_t aClientauthissu[17];

//----- (0000000180056428) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::InitializeClientNameInfo(CCredentialGroup *this, __int64 a2)
{
  ULONG v4; // ebx
  DWORD LastError; // eax
  wchar_t *v6; // rax
  wchar_t *v7; // rdi
  __int64 v8; // rsi
  __int64 v9; // rax
  unsigned int v10; // r14d
  HLOCAL v11; // rax
  HLOCAL v12; // rax
  ULONG nSize; // [rsp+20h] [rbp-E0h] BYREF
  int v15[3]; // [rsp+24h] [rbp-DCh] BYREF
  wchar_t NameBuffer[520]; // [rsp+30h] [rbp-D0h] BYREF

  memset_0(NameBuffer, 0, 0x404ui64);
  nSize = 514;
  v15[0] = 0;
  v4 = SslImpersonateClient(a2, v15);
  if ( !v4 )
  {
    if ( GetUserNameExW(NameDnsDomain, NameBuffer, &nSize) )
    {
      v6 = wcsrchr(NameBuffer, 0x5Cu);
      v7 = v6;
      if ( v6 )
      {
        v8 = -1i64;
        *v6 = 0;
        v9 = -1i64;
        do
          ++v9;
        while ( v7[v9 + 1] );
        v10 = (unsigned __int16)v9 + 1;
        v11 = SPExternalAlloc(2 * v10);
        *((_QWORD *)this + 109) = v11;
        if ( !v11 )
          goto LABEL_12;
        memcpy_0(v11, v7 + 1, 2i64 * v10);
        do
          ++v8;
        while ( NameBuffer[v8] );
        nSize = (unsigned __int16)v8 + 1;
        v12 = SPExternalAlloc(2 * nSize);
        *((_QWORD *)this + 110) = v12;
        if ( v12 )
          memcpy_0(v12, NameBuffer, 2i64 * nSize);
        else
LABEL_12:
          v4 = 14;
      }
      else
      {
        v4 = 1359;
      }
    }
    else if ( GetLastError() != 1332
           && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
           && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
    {
      LastError = GetLastError();
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, LastError);
    }
  }
  if ( v15[0] )
    RevertToSelf();
  return v4;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180056428: using guessed type wchar_t NameBuffer[520];
// 180056428: using guessed type int var_44C[3];

//----- (0000000180056618) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::NotifyProviderChange(CCredentialGroup *this)
{
  CCredentialGroup *v2; // r14
  __int64 v3; // rbx
  char *v4; // rsi

  RtlAcquireResourceShared((PRTL_RESOURCE)((char *)this + 48), 1u);
  v2 = (CCredentialGroup *)*((_QWORD *)this + 4);
  while ( v2 != (CCredentialGroup *)((char *)this + 32) )
  {
    v3 = *((_QWORD *)this + 94);
    v4 = (char *)v2 - 8;
    v2 = *(CCredentialGroup **)v2;
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(v4 + 552), 1u);
    CSslCredential::DeleteLocalServerKeys((CSslCredential *)v4);
    CSslCredential::GetLocalServerKeyFromProvider((const struct _CERT_CONTEXT **)v4, v3);
    RtlReleaseResource((PRTL_RESOURCE)(v4 + 552));
  }
  RtlReleaseResource((PRTL_RESOURCE)((char *)this + 48));
  return 0i64;
}

//----- (00000001800566DC) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::PickClientCredential(
        CCredentialGroup *this,
        int a2,
        int a3,
        struct CTlsSignatureSuiteList *a4,
        struct CSslCredential **a5)
{
  unsigned int v8; // ebx
  CCredentialGroup *v9; // rsi
  struct CSslCredential *v10; // r15

  v8 = -2146893007;
  if ( *((_DWORD *)this + 7) )
  {
    RtlAcquireResourceShared((PRTL_RESOURCE)((char *)this + 48), 1u);
    v9 = (CCredentialGroup *)*((_QWORD *)this + 4);
    while ( v9 != (CCredentialGroup *)((char *)this + 32) )
    {
      v10 = (CCredentialGroup *)((char *)v9 - 8);
      v9 = *(CCredentialGroup **)v9;
      if ( CSslCredential::IsClientCredApplicable(
             v10,
             a2,
             a3,
             a4,
             *((struct _TLS_PARAMETERS **)this + 25),
             *((_DWORD *)this + 49)) )
      {
        v8 = 0;
        *a5 = v10;
        break;
      }
    }
    RtlReleaseResource((PRTL_RESOURCE)((char *)this + 48));
  }
  return v8;
}

//----- (00000001800567A8) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::PickServerCredential(
        CCredentialGroup *this,
        struct CCipherSuiteInfo *a2,
        struct CEccCurveInfo *a3,
        int a4,
        char a5,
        const struct CTlsSignatureSuiteList *a6,
        struct _TLS_PARAMETERS *a7,
        unsigned int a8,
        struct _UNICODE_STRING *a9,
        unsigned __int8 a10,
        struct CSessionCacheServerItem *a11,
        struct CSslCredential **a12)
{
  struct CSslCredential **v12; // r15
  struct CSslCredential *v14; // rdi
  __int64 v15; // r12
  __int64 result; // rax
  unsigned int v17; // ebp
  struct CSessionCacheServerItem *v18; // rsi
  __int64 v19; // rax
  CCredentialGroup *v20; // r13
  CCredentialGroup *v21; // r14
  __int64 v22; // rbx
  int IsServerCredApplicable; // eax
  int Length; // [rsp+50h] [rbp-58h]
  void *Source1; // [rsp+58h] [rbp-50h]
  struct _RTL_RESOURCE *Resource; // [rsp+60h] [rbp-48h]

  v12 = a12;
  Source1 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  Length = 0;
  if ( !a12 )
    return 87i64;
  *a12 = 0i64;
  if ( !*((_DWORD *)this + 7) )
    return 2148074289i64;
  if ( (*((_BYTE *)this + 156) & 0x40) == 0 )
    goto LABEL_10;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 37i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids);
  result = CCredentialGroup::CheckForCredentialRenewal(this);
  if ( !(_DWORD)result )
  {
LABEL_10:
    Resource = (struct _RTL_RESOURCE *)((char *)this + 48);
    v17 = -2146893007;
    RtlAcquireResourceShared((PRTL_RESOURCE)((char *)this + 48), 1u);
    v18 = a11;
    if ( a11 )
    {
      RtlAcquireResourceShared((PRTL_RESOURCE)((char *)a11 + 72), 1u);
      v19 = *((_QWORD *)a11 + 42);
      if ( v19 )
      {
        Length = 20;
        Source1 = (void *)(v19 + 40);
      }
    }
    v20 = (CCredentialGroup *)((char *)this + 32);
    v21 = (CCredentialGroup *)*((_QWORD *)this + 4);
    if ( v21 != (CCredentialGroup *)((char *)this + 32) )
    {
      while ( 1 )
      {
        v22 = (__int64)v21 - 8;
        v21 = *(CCredentialGroup **)v21;
        if ( !Source1
          || v22 != -40 && Length == 20 && RtlCompareMemory(Source1, (const void *)(v22 + 40), 0x14ui64) == 20 )
        {
          IsServerCredApplicable = CSslCredential::IsServerCredApplicable(
                                     v22,
                                     (__int64)a2,
                                     (__int64)a3,
                                     a4,
                                     (__int64)a6,
                                     a7,
                                     a8,
                                     a9,
                                     a10);
          if ( IsServerCredApplicable == 1 )
          {
            if ( !v14 || *(_BYTE *)(v22 + 80) != a5 )
            {
              v17 = 0;
              v14 = (struct CSslCredential *)v22;
              if ( *(_BYTE *)(v22 + 80) != a5 )
              {
LABEL_27:
                v18 = a11;
                v12 = a12;
                break;
              }
            }
          }
          else if ( IsServerCredApplicable == 2 && !v15 )
          {
            v15 = v22;
          }
        }
        if ( v21 == v20 )
          goto LABEL_27;
      }
    }
    if ( v18 )
      RtlReleaseResource((PRTL_RESOURCE)((char *)v18 + 72));
    RtlReleaseResource(Resource);
    result = v17;
    if ( !v14 )
      v14 = (struct CSslCredential *)v15;
    *v12 = v14;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180082B38: using guessed type GUID WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids;

//----- (00000001800569FC) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::RemoveDuplicateIssuers(
        CCredentialGroup *this,
        unsigned __int8 *a2,
        unsigned int *a3)
{
  unsigned __int8 *v4; // rbx
  unsigned __int8 *v5; // r13
  int v6; // ecx
  unsigned __int8 *v7; // r9
  unsigned __int8 *v8; // rax
  const void **v9; // rbp
  unsigned int v11; // r15d
  unsigned __int8 *v12; // rdx
  __int64 v13; // rax
  unsigned int v14; // ecx
  __int64 v15; // rax
  const void **v16; // r14
  unsigned int v17; // esi
  const void **v18; // rbx
  __int64 v19; // r12
  unsigned int v20; // eax
  unsigned int *v21; // rsi
  unsigned __int8 *v22; // r14
  unsigned __int8 *v23; // rbx
  unsigned int v24; // r12d
  size_t v25; // r8
  __int64 v26; // [rsp+60h] [rbp+8h]

  if ( !a2 || *a3 < 2 )
    return 0i64;
  v4 = a2 + 1;
  v5 = &a2[*a3];
  v6 = 0;
  v7 = a2;
  if ( a2 + 1 < v5 )
  {
    v8 = a2 + 1;
    do
    {
      ++v6;
      v7 += (*v8 | ((unsigned __int64)*v7 << 8)) + 2;
      v8 = v7 + 1;
    }
    while ( v7 + 1 < v5 );
  }
  v9 = (const void **)SPExternalAlloc(16 * v6);
  if ( !v9 )
    return 14i64;
  v11 = 0;
  v12 = a2;
  if ( v4 >= v5 )
    goto LABEL_34;
  do
  {
    v13 = 2i64 * v11;
    v14 = (*v4 | (*v12 << 8)) + 2;
    ++v11;
    v9[v13 + 1] = v12;
    LODWORD(v9[v13]) = v14;
    v12 += v14;
    v4 = v12 + 1;
  }
  while ( v12 + 1 < v5 );
  if ( !v11 )
  {
LABEL_34:
    LODWORD(v23) = (_DWORD)a2;
LABEL_35:
    *a3 = (_DWORD)v23 - (_DWORD)a2;
    SPExternalFree(v9);
    return 0i64;
  }
  v15 = v11;
  v16 = v9 + 1;
  v26 = v11;
  v17 = 1;
  do
  {
    if ( *v16 && v17 < v11 )
    {
      v18 = &v9[2 * v17 + 1];
      v19 = v11 - v17;
      do
      {
        if ( *v18 )
        {
          v20 = *((_DWORD *)v18 - 2);
          if ( *((_DWORD *)v16 - 2) == v20 && !memcmp_0(*v16, *v18, v20) )
            *v18 = 0i64;
        }
        v18 += 2;
        --v19;
      }
      while ( v19 );
      v15 = v26;
    }
    ++v17;
    v16 += 2;
    v26 = --v15;
  }
  while ( v15 );
  v21 = (unsigned int *)v9;
  v22 = a2;
  v23 = a2;
  v24 = 0;
  while ( !*((_QWORD *)v21 + 1) )
  {
LABEL_28:
    ++v24;
    v22 += *v21;
    v21 += 4;
    if ( v24 >= v11 )
      goto LABEL_35;
  }
  if ( v23 == v22 )
  {
LABEL_27:
    v23 += *v21;
    goto LABEL_28;
  }
  v25 = *v21;
  if ( &v22[v25] <= v5 )
  {
    memmove_0(v23, v22, v25);
    goto LABEL_27;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 34i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids);
  SPExternalFree(v9);
  return 1359i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180082B38: using guessed type GUID WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids;

//----- (0000000180056BF0) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::RenewImplicitCertificates(void **this)
{
  __int64 v2; // rcx
  __int64 v3; // r8
  __int64 v4; // r9
  __int64 v5; // rcx
  void *Updated; // rbx
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int LastError; // edi
  CCipherMill *v10; // rcx
  __int64 v11; // rdx
  __int64 v13; // r8
  __int64 v14; // r9
  struct LSA_SCHANNEL_SUB_CRED *v15; // rdi
  __int64 v16; // rbp
  unsigned int RenewedCredential; // eax
  char v18[4]; // [rsp+30h] [rbp-98h] BYREF
  unsigned int v19; // [rsp+34h] [rbp-94h]
  struct LSA_SCHANNEL_SUB_CRED *v20; // [rsp+38h] [rbp-90h]
  HCERTSTORE hCertStore; // [rsp+50h] [rbp-78h]
  struct _EVENT_DATA_DESCRIPTOR v22; // [rsp+A0h] [rbp-28h] BYREF

  memset_0(v18, 0, 0x70ui64);
  if ( CryptObjectLocatorIsChanged(this[100]) )
  {
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McGenEventWrite_EventWriteTransfer(v2, &LocatorGetUpdatedStart, v3, v4, &v22);
    Updated = CryptObjectLocatorGetUpdated(this[100]);
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McGenEventWrite_EventWriteTransfer(v5, &LocatorGetUpdatedStop, v7, v8, &v22);
    if ( !Updated )
    {
      LastError = GetLastError();
      v10 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return LastError;
      v11 = 25i64;
LABEL_10:
      WPP_SF_D(*((_QWORD *)v10 + 2), v11, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, LastError);
      return LastError;
    }
    CryptObjectLocatorFree(this[100]);
    this[100] = Updated;
    LastError = LoadCertificatesFromLocator(Updated, (struct LSA_SCHANNEL_CRED *)v18, v13, v14);
    if ( LastError )
    {
      v10 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return LastError;
      v11 = 26i64;
      goto LABEL_10;
    }
    if ( v19 )
    {
      v15 = v20;
      v16 = v19;
      do
      {
        RenewedCredential = CCredentialGroup::CreateRenewedCredential((CCredentialGroup *)this, v15);
        if ( RenewedCredential
          && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            27i64,
            &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids,
            RenewedCredential);
        }
        v15 = (struct LSA_SCHANNEL_SUB_CRED *)((char *)v15 + 56);
        --v16;
      }
      while ( v16 );
    }
    if ( hCertStore )
      CertCloseStore(hCertStore, 0);
    FreeSchannelCred((struct LSA_SCHANNEL_CRED *)v18, 0);
  }
  return 0i64;
}
// 180056C64: variable 'v2' is possibly undefined
// 180056C64: variable 'v3' is possibly undefined
// 180056C64: variable 'v4' is possibly undefined
// 180056C9C: variable 'v5' is possibly undefined
// 180056C9C: variable 'v7' is possibly undefined
// 180056C9C: variable 'v8' is possibly undefined
// 180056D0E: variable 'v13' is possibly undefined
// 180056D0E: variable 'v14' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082B38: using guessed type GUID WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids;
// 180084C00: using guessed type EVENT_DESCRIPTOR LocatorGetUpdatedStop;
// 180084C10: using guessed type EVENT_DESCRIPTOR LocatorGetUpdatedStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 180098018: using guessed type void __stdcall CryptObjectLocatorFree(void *);
// 1800981A0: using guessed type _DWORD __stdcall CryptObjectLocatorIsChanged(void *);
// 1800981A8: using guessed type void *__stdcall CryptObjectLocatorGetUpdated(void *);

//----- (0000000180056DE8) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::RenewLocalStoreCertificates(CCredentialGroup *this)
{
  char *v1; // rdi
  char *v2; // rbx
  char *v4; // rsi
  const CERT_CONTEXT *v5; // rsi
  unsigned int RenewedCredential; // eax
  __int128 v8[3]; // [rsp+20h] [rbp-48h] BYREF
  __int64 v9; // [rsp+50h] [rbp-18h]
  PCCERT_CONTEXT pCertContext; // [rsp+70h] [rbp+8h] BYREF

  pCertContext = 0i64;
  v1 = (char *)this + 32;
  v2 = (char *)*((_QWORD *)this + 4);
  while ( v2 != v1 )
  {
    v4 = v2;
    v2 = *(char **)v2;
    if ( (*((_DWORD *)v4 + 4) & 0x21) == 32
      && (unsigned int)CheckForLocalStoreCertificateRenewal(
                         *((HCERTSTORE *)CSslCredManager::m_pCredManager + 9),
                         *((PCCERT_CONTEXT *)v4 + 3),
                         1,
                         &pCertContext) )
    {
      *((_DWORD *)v4 + 4) |= 1u;
      v5 = pCertContext;
      v8[0] = (unsigned __int64)pCertContext;
      v9 = 1i64;
      memset(&v8[1], 0, 32);
      RenewedCredential = CCredentialGroup::CreateRenewedCredential(this, (struct LSA_SCHANNEL_SUB_CRED *)v8);
      if ( RenewedCredential
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          28i64,
          &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids,
          RenewedCredential);
      }
      CertFreeCertificateContext(v5);
    }
  }
  return 0i64;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082B38: using guessed type GUID WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids;

//----- (0000000180056EF0) ----------------------------------------------------
int __fastcall StringCbCatW(unsigned __int16 *a1, unsigned __int64 a2, const unsigned __int16 *a3)
{
  int result; // eax
  size_t *v6; // r8
  __int64 v7; // r11
  size_t v8; // [rsp+20h] [rbp-18h]
  size_t pcchLength; // [rsp+48h] [rbp+10h] BYREF

  if ( (a2 >> 1) - 1 > 0x7FFFFFFE )
    return -2147024809;
  result = StringLengthWorkerW(a1, a2 >> 1, &pcchLength);
  if ( result >= 0 )
    return StringCopyWorkerW(&a1[pcchLength], v7 - pcchLength, v6, a3, v8);
  return result;
}
// 180056F35: variable 'v7' is possibly undefined
// 180056F3C: variable 'v6' is possibly undefined
// 180056F3C: variable 'v8' is possibly undefined

//----- (0000000180056F54) ----------------------------------------------------
HRESULT __stdcall StringCopyWorkerW(
        STRSAFE_LPWSTR pszDest,
        size_t cchDest,
        size_t *pcchNewDestLength,
        STRSAFE_PCNZWCH pszSrc,
        size_t cchToCopy)
{
  STRSAFE_LPWSTR v5; // r8
  __int64 v6; // rax
  signed __int64 v7; // r9
  wchar_t v8; // cx
  STRSAFE_LPWSTR v9; // rcx
  HRESULT result; // eax

  v5 = pszDest;
  if ( cchDest )
  {
    v6 = 2147483646i64;
    v7 = (char *)pszSrc - (char *)pszDest;
    do
    {
      if ( !v6 )
        break;
      v8 = *(STRSAFE_LPWSTR)((char *)v5 + v7);
      if ( !v8 )
        break;
      *v5 = v8;
      --v6;
      ++v5;
      --cchDest;
    }
    while ( cchDest );
  }
  v9 = v5 - 1;
  result = cchDest == 0 ? 0x8007007A : 0;
  if ( cchDest )
    v9 = v5;
  *v9 = 0;
  return result;
}

//----- (0000000180056FB0) ----------------------------------------------------
HRESULT __stdcall StringLengthWorkerW(STRSAFE_PCNZWCH psz, size_t cchMax, size_t *pcchLength)
{
  size_t i; // r9
  HRESULT result; // eax

  for ( i = cchMax; cchMax; --cchMax )
  {
    if ( !*psz )
      break;
    ++psz;
  }
  result = cchMax == 0 ? 0x80070057 : 0;
  if ( pcchLength )
  {
    if ( cchMax )
      *pcchLength = i - cchMax;
    else
      *pcchLength = 0i64;
  }
  return result;
}

//----- (0000000180056FF8) ----------------------------------------------------
DWORD __fastcall CCredentialGroup::SubscribeCertStoreChangeNotification(CCredentialGroup *this, void *a2, void **a3)
{
  DWORD LastError; // ebx
  HANDLE pvCtrlPara; // [rsp+30h] [rbp+8h] BYREF

  pvCtrlPara = this;
  if ( !a2 || !a3 )
    return 87;
  pvCtrlPara = CreateEventA(0i64, 0, 0, 0i64);
  if ( !pvCtrlPara )
    return GetLastError();
  if ( CertControlStore(a2, 0, 2u, &pvCtrlPara) )
  {
    *a3 = pvCtrlPara;
    return 0;
  }
  else
  {
    LastError = GetLastError();
    CloseHandle(pvCtrlPara);
    return LastError;
  }
}

//----- (00000001800570B0) ----------------------------------------------------
void __fastcall CCredentialGroup::UnsubscribeCertStoreChangeNotification(CCredentialGroup *this, void *a2, void **a3)
{
  if ( a2 && a3 )
  {
    if ( *a3 )
    {
      CertControlStore(a2, 0, 5u, a3);
      CloseHandle(*a3);
      *a3 = 0i64;
    }
  }
}

//----- (0000000180057104) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::UpdateIssuerList(CCredentialGroup *this)
{
  struct _RTL_RESOURCE *v2; // rdi
  unsigned int v3; // ebx

  CSslCredManager::CheckForGpEventAndUpdateIssuersList(CSslCredManager::m_pCredManager);
  CCredentialGroup::CheckForCertificateStoreChange(this);
  if ( !*((_QWORD *)this + 108) || (*((_BYTE *)this + 156) & 0x10) != 0 )
  {
    v2 = (struct _RTL_RESOURCE *)((char *)this + 48);
    RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)this + 48), 1u);
    if ( !*((_QWORD *)this + 108) || (*((_BYTE *)this + 156) & 0x10) != 0 )
    {
      v3 = CCredentialGroup::ConstructIssuersList(this);
      if ( v3 )
      {
        RtlReleaseResource(v2);
        return v3;
      }
    }
    RtlReleaseResource(v2);
  }
  return 0i64;
}

//----- (00000001800571A4) ----------------------------------------------------
__int64 __fastcall AcquireDefaultClientCredential(struct CSsl3TlsClientContext *this, int a2)
{
  DWORD v2; // r14d
  CERT_NAME_BLOB *v3; // r15
  unsigned __int8 v5; // si
  int CredentialManagerForCert; // ebx
  unsigned int v8; // eax
  unsigned __int16 *v9; // rax
  __int64 v10; // rbx
  __int64 v11; // r10
  unsigned int v12; // eax
  unsigned __int8 *v13; // rbx
  unsigned __int8 *v14; // rdx
  unsigned __int64 v15; // r8
  unsigned __int8 *v16; // rax
  CERT_NAME_BLOB *v17; // rax
  CERT_NAME_BLOB *v18; // rdx
  __int64 v19; // r8
  int v20; // ecx
  HCERTSTORE v21; // rsi
  int v22; // eax
  void *pvPara; // [rsp+20h] [rbp-60h]
  struct _CERT_CHAIN_FIND_BY_ISSUER_PARA v25; // [rsp+40h] [rbp-40h] BYREF
  unsigned __int8 v26; // [rsp+B0h] [rbp+30h] BYREF
  int v27; // [rsp+C0h] [rbp+40h] BYREF

  v2 = 0;
  v3 = 0i64;
  v27 = 0;
  v5 = 0;
  v26 = 0;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids);
  CredentialManagerForCert = SslImpersonateClient(*(_QWORD *)(*((_QWORD *)this + 10) + 752i64), &v27);
  if ( !CredentialManagerForCert )
  {
    if ( v27 )
    {
      v8 = IsThreadLocalSystemOrNetworkService(&v26);
      if ( v8
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      {
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          (unsigned int)(CredentialManagerForCert + 21),
          &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids,
          v8);
      }
      RevertToSelf();
      v27 = 0;
      v5 = v26;
    }
    if ( !*((_DWORD *)this + 262) )
    {
      v9 = (unsigned __int16 *)(*(__int64 (__fastcall **)(struct CSsl3TlsClientContext *))(*(_QWORD *)this + 320i64))(this);
      CredentialManagerForCert = QueryCredentialManagerForCert(this, v9);
      CSsl3TlsClientContext::SetDefCredSearched((__int64)this, 1);
      if ( CredentialManagerForCert >= 0 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids);
        goto LABEL_45;
      }
    }
    if ( a2 )
    {
      CredentialManagerForCert = 590624;
      goto LABEL_45;
    }
    v10 = *((_QWORD *)this + 112);
    v11 = v10;
    if ( v10 )
    {
      v12 = *((_DWORD *)this + 222);
      if ( v12 > 2 )
      {
        v13 = (unsigned __int8 *)(v10 + 2);
        v14 = v13;
        v15 = (unsigned __int64)&v13[v12 - 2];
        if ( v11 + 3 < v15 )
        {
          v16 = (unsigned __int8 *)(v11 + 3);
          do
          {
            ++v2;
            v14 += (*v16 | ((unsigned __int64)*v14 << 8)) + 2;
            v16 = v14 + 1;
          }
          while ( (unsigned __int64)(v14 + 1) < v15 );
        }
        v17 = (CERT_NAME_BLOB *)SPExternalAlloc(16 * v2);
        v3 = v17;
        if ( !v17 )
        {
          CredentialManagerForCert = -2146893056;
          goto LABEL_45;
        }
        if ( v2 )
        {
          v18 = v17;
          v19 = v2;
          do
          {
            v18->pbData = v13 + 2;
            v20 = v13[1] | (*v13 << 8);
            v18->cbData = v20;
            v13 += (unsigned int)(v20 + 2);
            ++v18;
            --v19;
          }
          while ( v19 );
        }
      }
    }
    CredentialManagerForCert = SslImpersonateClient(*(_QWORD *)(*((_QWORD *)this + 10) + 752i64), &v27);
    if ( !CredentialManagerForCert )
    {
      v21 = CertOpenStore((LPCSTR)0xA, 1u, 0i64, v5 != 0 ? 180228 : 114692, L"MY");
      if ( !v21 )
      {
        CredentialManagerForCert = GetLastError();
        goto LABEL_45;
      }
      v25.pvFindArg = 0i64;
      *(_QWORD *)&v25.cbSize = 0i64;
      v25.pszUsageIdentifier = "1.3.6.1.5.5.7.3.2";
      v22 = *((_DWORD *)this + 262);
      *(_OWORD *)&v25.dwKeySpec = 0i64;
      v25.dwKeySpec = 0;
      v25.cIssuer = v2;
      v25.cbSize = 56;
      v25.pfnFindCallback = 0i64;
      v25.rgIssuer = v3;
      if ( v22 == 1 )
      {
        CredentialManagerForCert = FindClientCertificate(
                                     this,
                                     v21,
                                     (const struct _CERT_CHAIN_CONTEXT **)this + 130,
                                     &v25,
                                     &v27,
                                     1,
                                     1);
        if ( CredentialManagerForCert >= 0 )
          goto LABEL_44;
        CSsl3TlsClientContext::SetDefCredSearched((__int64)this, 2);
        v22 = *((_DWORD *)this + 262);
      }
      if ( v22 == 2 )
      {
        CredentialManagerForCert = FindClientCertificate(
                                     this,
                                     v21,
                                     (const struct _CERT_CHAIN_CONTEXT **)this + 130,
                                     &v25,
                                     &v27,
                                     1,
                                     0);
        if ( CredentialManagerForCert >= 0 )
          goto LABEL_44;
        CSsl3TlsClientContext::SetDefCredSearched((__int64)this, 3);
        v22 = *((_DWORD *)this + 262);
      }
      if ( v22 == 3 )
      {
        CredentialManagerForCert = FindClientCertificate(
                                     this,
                                     v21,
                                     (const struct _CERT_CHAIN_CONTEXT **)this + 130,
                                     &v25,
                                     &v27,
                                     0,
                                     1);
        if ( CredentialManagerForCert >= 0 )
          goto LABEL_44;
        CSsl3TlsClientContext::SetDefCredSearched((__int64)this, 4);
        v22 = *((_DWORD *)this + 262);
      }
      if ( v22 != 4 )
      {
LABEL_43:
        CredentialManagerForCert = 590624;
        goto LABEL_44;
      }
      CredentialManagerForCert = FindClientCertificate(
                                   this,
                                   v21,
                                   (const struct _CERT_CHAIN_CONTEXT **)this + 130,
                                   &v25,
                                   &v27,
                                   0,
                                   0);
      if ( CredentialManagerForCert < 0 )
      {
        CSsl3TlsClientContext::SetDefCredSearched((__int64)this, 5);
        goto LABEL_43;
      }
LABEL_44:
      CertCloseStore(v21, 0);
    }
  }
LABEL_45:
  if ( v27 )
    RevertToSelf();
  if ( v3 )
    SPExternalFree(v3);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        23i64,
        &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids,
        (unsigned int)CredentialManagerForCert);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
      && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && CredentialManagerForCert
       || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
    {
      LODWORD(pvPara) = CredentialManagerForCert;
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x18u,
        (__int64)&WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids,
        CredentialManagerForCert,
        pvPara);
    }
  }
  return (unsigned int)CredentialManagerForCert;
}
// 180057616: variable 'pvPara' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 18008275C: using guessed type wchar_t aMy[3];

//----- (0000000180057640) ----------------------------------------------------
__int64 __fastcall AssignNewClientCredential(struct CSsl3TlsClientContext *this, const struct _CERT_CONTEXT *a2)
{
  int v3; // r14d
  __int64 v5; // r15
  unsigned int v6; // ecx
  const char **v7; // rdx
  int v8; // r8d
  unsigned int v9; // ecx
  _DWORD *v10; // rax
  unsigned int Credential; // ebx
  __int64 v13; // rbp
  CSslCredential *v14; // rax
  CSslCredential *v15; // rax
  int *v16; // rsi
  struct _TLS_PARAMETERS *v17; // [rsp+20h] [rbp-98h]
  void *v18[2]; // [rsp+50h] [rbp-68h] BYREF
  __int128 v19[3]; // [rsp+60h] [rbp-58h] BYREF
  __int64 v20; // [rsp+90h] [rbp-28h]

  v3 = *((_DWORD *)this + 16);
  v5 = *(_QWORD *)(*((_QWORD *)this + 10) + 752i64);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids);
  v6 = 0;
  v7 = (const char **)&g_CertTypes;
  while ( strcmp(a2->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId, *v7) )
  {
    ++v6;
    v7 += 2;
    if ( v6 >= 8 )
    {
      v8 = 0;
      goto LABEL_9;
    }
  }
  v8 = *((_DWORD *)&g_CertTypes + 4 * v6 + 3);
LABEL_9:
  v9 = 0;
  if ( *((_WORD *)this + 673) )
  {
    v10 = (_DWORD *)((char *)this + 1348);
    while ( *v10 != v8 )
    {
      ++v9;
      ++v10;
      if ( v9 >= *((unsigned __int16 *)this + 673) )
        goto LABEL_13;
    }
    v13 = *((_QWORD *)this + 10);
    if ( v13 )
    {
      v14 = (CSslCredential *)SPExternalAlloc(0x498u);
      if ( v14 && (v15 = CSslCredential::CSslCredential(v14), (v16 = (int *)v15) != 0i64) )
      {
        v20 = 0i64;
        v19[0] = (unsigned __int64)a2;
        memset(&v19[1], 0, 32);
        Credential = CSslCredential::CreateCredential(
                       v15,
                       *(_DWORD *)(v13 + 212),
                       (char *)(v13 + 216),
                       v5,
                       (struct LSA_SCHANNEL_SUB_CRED *)v19,
                       (*(_DWORD *)(v13 + 156) >> 4) & 8,
                       1u,
                       0,
                       0i64,
                       0);
        if ( !Credential )
        {
          if ( CSslCredential::IsClientCredApplicable(
                 (CSslCredential *)v16,
                 v16[33],
                 *((_DWORD *)this + 16),
                 (const struct CTlsSignatureSuiteList *)(((unsigned __int64)this + 510) & -(__int64)((v3 & 0x82800) != 0)),
                 *(struct _TLS_PARAMETERS **)(v13 + 200),
                 *(_DWORD *)(v13 + 196)) )
          {
            CSsl3TlsClientContext::SetActiveClientCred(this, (struct CSslCredential *)v16, 1);
            Credential = 0;
            goto LABEL_18;
          }
          Credential = -2146893043;
        }
        (*(void (__fastcall **)(int *, __int64))(*(_QWORD *)v16 + 8i64))(v16, 1i64);
      }
      else
      {
        Credential = 14;
      }
    }
    else
    {
      Credential = -2146893052;
    }
  }
  else
  {
LABEL_13:
    Credential = -2146893043;
  }
  if ( *((_BYTE *)this + 266) )
  {
    *(_OWORD *)v18 = 0i64;
    if ( LsaTable )
    {
      if ( !(*(unsigned int (__fastcall **)(_QWORD, _QWORD, _QWORD, void **, _QWORD))(LsaTable + 488))(
              0i64,
              0i64,
              0i64,
              v18,
              0i64) )
        CleanupAppModeInfo(v18[1]);
    }
  }
LABEL_18:
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && Credential || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    LODWORD(v17) = Credential;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xBu,
      (__int64)&WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids,
      Credential,
      v17);
  }
  return Credential;
}
// 1800577AF: variable 'v17' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18007D750: using guessed type const struct _OIDPROVMAP near *const g_CertTypes;
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018005792C) ----------------------------------------------------
_BOOL8 __fastcall DoesCertHaveBasicConstraintCA(const struct _CERT_CONTEXT *a1)
{
  PCERT_EXTENSION Extension; // rax
  DWORD cbData; // r9d
  const BYTE *pbData; // r8
  _BOOL8 result; // rax
  DWORD pcbStructInfo; // [rsp+40h] [rbp-28h] BYREF
  __int64 pvStructInfo; // [rsp+48h] [rbp-20h] BYREF
  int v7; // [rsp+50h] [rbp-18h]

  Extension = CertFindExtension("2.5.29.19", a1->pCertInfo->cExtension, a1->pCertInfo->rgExtension);
  result = 0;
  if ( Extension )
  {
    cbData = Extension->Value.cbData;
    pbData = Extension->Value.pbData;
    pvStructInfo = 0i64;
    v7 = 0;
    pcbStructInfo = 12;
    if ( CryptDecodeObject(1u, (LPCSTR)0xF, pbData, cbData, 0, &pvStructInfo, &pcbStructInfo) )
      return 1;
  }
  return result;
}

//----- (00000001800579D8) ----------------------------------------------------
__int64 __fastcall FindClientCertificate(
        struct CSsl3TlsClientContext *this,
        void *a2,
        const struct _CERT_CHAIN_CONTEXT **a3,
        struct _CERT_CHAIN_FIND_BY_ISSUER_PARA *a4,
        int *a5,
        int a6,
        int a7)
{
  const struct _CERT_CHAIN_CONTEXT *pPrevChainContext; // rdi
  signed int v12; // eax
  int v13; // ebx
  PCCERT_CHAIN_CONTEXT i; // rax
  char *v15; // rdx
  PCERT_SIMPLE_CHAIN *rgpChain; // rcx
  __int64 v17; // rbx
  PCERT_SIMPLE_CHAIN v18; // rsi
  __int64 v19; // r8
  __int64 v20; // r9
  int v21; // eax
  DWORD v22; // eax
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  unsigned int LastError; // eax
  CCipherMill *v27; // rcx
  __int64 v28; // rdx
  PCERT_SIMPLE_CHAIN v29; // rcx
  PCERT_CHAIN_ELEMENT *rgpElement; // rax
  PCERT_CHAIN_ELEMENT v31; // rax
  const struct _CERT_CONTEXT *pCertContext; // rbx
  void *pvFindPara; // [rsp+20h] [rbp-A1h]
  int v35; // [rsp+30h] [rbp-91h] BYREF
  unsigned int v36; // [rsp+34h] [rbp-8Dh] BYREF
  HCERTSTORE hCertStore; // [rsp+38h] [rbp-89h]
  struct _CERT_CHAIN_POLICY_PARA pPolicyPara; // [rsp+40h] [rbp-81h] BYREF
  int v39[4]; // [rsp+50h] [rbp-71h] BYREF
  __int64 v40; // [rsp+60h] [rbp-61h]
  struct _CERT_CHAIN_POLICY_STATUS pPolicyStatus; // [rsp+68h] [rbp-59h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v42; // [rsp+80h] [rbp-41h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v43; // [rsp+90h] [rbp-31h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v44; // [rsp+A0h] [rbp-21h] BYREF

  hCertStore = a2;
  pPrevChainContext = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 16i64, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids);
  if ( !a3 || !a5 || !this || !a4 )
  {
    v13 = 1359;
    goto LABEL_53;
  }
  if ( !*a5 )
  {
    v12 = SslImpersonateClient(*(_QWORD *)(*((_QWORD *)this + 10) + 752i64), a5);
    v13 = v12;
    if ( v12 )
    {
      if ( v12 < 0 )
        goto LABEL_50;
      goto LABEL_53;
    }
  }
  for ( i = CertFindChainInStore(a2, 1u, 0, 1u, a4, *a3);
        ;
        i = CertFindChainInStore(hCertStore, 1u, 0, 1u, a4, pPrevChainContext) )
  {
    pPrevChainContext = i;
    if ( !i )
    {
      v13 = -2146893024;
      goto LABEL_53;
    }
    rgpChain = i->rgpChain;
    v17 = 0i64;
    v35 = 0;
    v18 = *rgpChain;
    if ( !(*rgpChain)->cElement )
      continue;
    while ( !(unsigned int)SPCheckKeyUsage(v18->rgpElement[v17]->pCertContext, v15, 1, &v35) )
    {
      v21 = v35;
      if ( !v35 )
        break;
      v17 = (unsigned int)(v17 + 1);
      if ( (unsigned int)v17 >= v18->cElement )
        goto LABEL_19;
    }
    v21 = 0;
LABEL_19:
    if ( !v21 )
      continue;
    v39[3] = 0;
    v39[2] = 0;
    v40 = 0i64;
    pPolicyPara.pvExtraPolicyPara = v39;
    v22 = 48;
    memset(&pPolicyStatus, 0, sizeof(pPolicyStatus));
    v39[0] = 24;
    pPolicyStatus.cbSize = 24;
    if ( !a6 )
      v22 = 55;
    v39[1] = 1;
    pPolicyPara.dwFlags = v22;
    pPolicyPara.cbSize = 16;
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McGenEventWrite_EventWriteTransfer(55i64, &ChainVerifyStart, v19, v20, &v42);
    if ( !CertVerifyCertificateChainPolicy((LPCSTR)4, pPrevChainContext, &pPolicyPara, &pPolicyStatus) )
    {
      if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
        McGenEventWrite_EventWriteTransfer(v23, &ChainVerifyStop, v24, v25, &v43);
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      {
        LastError = GetLastError();
        v27 = WPP_GLOBAL_Control;
        v28 = 17i64;
LABEL_36:
        WPP_SF_D(*((_QWORD *)v27 + 2), v28, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids, LastError);
        continue;
      }
      continue;
    }
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McGenEventWrite_EventWriteTransfer(v23, &ChainVerifyStop, v24, v25, &v44);
    LastError = I_MapWinTrustErrorAndAlert(pPolicyStatus.dwError, 0, 0, 0i64);
    if ( !LastError )
      break;
    v27 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
    {
      v28 = 18i64;
      goto LABEL_36;
    }
LABEL_46:
    ;
  }
  if ( pPrevChainContext->cChain )
  {
    v29 = *pPrevChainContext->rgpChain;
    if ( v29 )
    {
      if ( v29->cElement )
      {
        rgpElement = v29->rgpElement;
        if ( rgpElement )
        {
          v31 = *rgpElement;
          pCertContext = v31->pCertContext;
          if ( !a7 || (GetImplementationType(v31->pCertContext, &v36), v36 == 2) )
          {
            if ( *a5 == 1 )
            {
              RevertToSelf();
              *a5 = 0;
            }
            v13 = AssignNewClientCredential(this, pCertContext);
            if ( v13 >= 0 )
              goto LABEL_53;
          }
          goto LABEL_46;
        }
      }
    }
  }
  v13 = -2146893052;
LABEL_50:
  if ( pPrevChainContext )
  {
    CertFreeCertificateChain(pPrevChainContext);
    pPrevChainContext = 0i64;
  }
LABEL_53:
  *a3 = pPrevChainContext;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v13 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    LODWORD(pvFindPara) = v13;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x13u,
      (__int64)&WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids,
      v13,
      pvFindPara);
  }
  return (unsigned int)v13;
}
// 180057ACD: variable 'v15' is possibly undefined
// 180057B56: variable 'v19' is possibly undefined
// 180057B56: variable 'v20' is possibly undefined
// 180057B95: variable 'v23' is possibly undefined
// 180057B95: variable 'v24' is possibly undefined
// 180057B95: variable 'v25' is possibly undefined
// 180057D54: variable 'pvFindPara' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180084C60: using guessed type EVENT_DESCRIPTOR ChainVerifyStop;
// 180084C70: using guessed type EVENT_DESCRIPTOR ChainVerifyStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;

//----- (0000000180057D84) ----------------------------------------------------
__int64 __fastcall FindDefaultMachineCred(
        struct CCredentialGroup **a1,
        unsigned int a2,
        struct _LUID *a3,
        void *a4,
        unsigned int a5,
        unsigned __int16 *SourceString)
{
  int v6; // ebx
  PCCERT_CONTEXT v8; // rsi
  HCERTSTORE v9; // r14
  WCHAR *v10; // rdi
  int v11; // r15d
  DWORD LastError; // eax
  __int64 v13; // rdx
  unsigned int v14; // ebx
  WCHAR *v15; // rax
  int v16; // eax
  __int64 v17; // rax
  const CERT_CONTEXT *i; // rdx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  DWORD v25; // eax
  char v26; // al
  __int64 v27; // rcx
  __int64 v28; // r8
  __int64 v29; // r9
  unsigned int v30; // eax
  CCipherMill *v31; // rcx
  __int64 v32; // rdx
  __int64 v33; // rdx
  void *pvPara; // [rsp+20h] [rbp-258h]
  DWORD nSize; // [rsp+40h] [rbp-238h] BYREF
  PCCERT_CHAIN_CONTEXT pChainContext; // [rsp+48h] [rbp-230h] BYREF
  unsigned int v38; // [rsp+50h] [rbp-228h]
  void *v39; // [rsp+58h] [rbp-220h]
  struct _UNICODE_STRING DestinationString; // [rsp+60h] [rbp-218h] BYREF
  struct _CERT_CHAIN_POLICY_PARA pPolicyPara; // [rsp+70h] [rbp-208h] BYREF
  int v42[4]; // [rsp+80h] [rbp-1F8h] BYREF
  WCHAR *v43; // [rsp+90h] [rbp-1E8h]
  struct _CERT_CHAIN_POLICY_STATUS pPolicyStatus; // [rsp+98h] [rbp-1E0h] BYREF
  __int128 v45[3]; // [rsp+B0h] [rbp-1C8h] BYREF
  __int64 v46; // [rsp+E0h] [rbp-198h]
  struct _CERT_CHAIN_PARA pChainPara; // [rsp+F0h] [rbp-188h] BYREF
  int v48[2]; // [rsp+150h] [rbp-128h] BYREF
  __int128 *v49; // [rsp+158h] [rbp-120h]
  char v50[96]; // [rsp+160h] [rbp-118h] BYREF
  __int64 v51[3]; // [rsp+1C0h] [rbp-B8h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v52; // [rsp+1D8h] [rbp-A0h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v53; // [rsp+1E8h] [rbp-90h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v54; // [rsp+1F8h] [rbp-80h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v55; // [rsp+208h] [rbp-70h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v56; // [rsp+218h] [rbp-60h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v57; // [rsp+228h] [rbp-50h] BYREF

  v6 = 0;
  v51[0] = (__int64)"1.3.6.1.5.5.7.3.1";
  v39 = a4;
  v51[1] = (__int64)"1.3.6.1.4.1.311.10.3.3";
  *(_QWORD *)&DestinationString.Length = a3;
  v51[2] = (__int64)"2.16.840.1.113730.4.1";
  v8 = 0i64;
  v38 = a2;
  v9 = 0i64;
  pChainContext = 0i64;
  v10 = 0i64;
  v11 = 0;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 25i64, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids);
  nSize = 0;
  if ( !GetComputerNameExW(ComputerNameDnsFullyQualified, 0i64, &nSize) && GetLastError() != 234 )
  {
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      goto LABEL_10;
    LastError = GetLastError();
    v13 = 26i64;
LABEL_9:
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), v13, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids, LastError);
LABEL_10:
    v14 = -2146893022;
    goto LABEL_82;
  }
  v15 = (WCHAR *)SPExternalAlloc(2 * nSize);
  v10 = v15;
  if ( !v15 )
  {
    v14 = -2146893056;
    goto LABEL_82;
  }
  if ( !GetComputerNameExW(ComputerNameDnsFullyQualified, v15, &nSize) )
  {
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      goto LABEL_10;
    LastError = GetLastError();
    v13 = 27i64;
    goto LABEL_9;
  }
  v16 = lstrlenW(v10);
  nSize = v16;
  if ( v16 )
  {
    v17 = (unsigned int)(v16 - 1);
    if ( v10[v17] == 46 )
      v10[v17] = 0;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x1Cu, (__int64)&WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids, v10);
  v9 = CertOpenStore((LPCSTR)0xA, 1u, 0i64, 0x2C000u, L"MY");
  if ( !v9 )
  {
    GetLastError();
    v14 = GetLastError();
    if ( v14 )
      goto LABEL_82;
    goto LABEL_85;
  }
  while ( 2 )
  {
    for ( i = 0i64; ; i = v8 )
    {
      v8 = CertEnumCertificatesInStore(v9, i);
      if ( !v8 )
        break;
      memset_0(&pChainPara, 0, 0x60ui64);
      pChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = (LPSTR *)v51;
      pChainPara.cbSize = 96;
      pChainPara.RequestedUsage.dwType = 1;
      pChainPara.RequestedUsage.Usage.cUsageIdentifier = 3;
      if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
        McGenEventWrite_EventWriteTransfer(v19, &ChainBuildStart, v20, v21, &v52);
      if ( !CertGetCertificateChain(0i64, v8, 0i64, 0i64, &pChainPara, 0x90000004, 0i64, &pChainContext) )
      {
        if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
          McGenEventWrite_EventWriteTransfer(v22, &ChainBuildStop, v23, v24, &v53);
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        {
          v25 = GetLastError();
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 29i64, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids, v25);
        }
        continue;
      }
      v26 = Microsoft_Windows_Schannel_EventsEnableBits;
      if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      {
        McGenEventWrite_EventWriteTransfer(v22, &ChainBuildStop, v23, v24, &v54);
        v26 = Microsoft_Windows_Schannel_EventsEnableBits;
      }
      v42[3] = 0;
      v42[2] = 0;
      v42[0] = 24;
      pPolicyPara.pvExtraPolicyPara = v42;
      v42[1] = 2;
      memset(&pPolicyStatus, 0, sizeof(pPolicyStatus));
      pPolicyStatus.cbSize = 24;
      v43 = v10;
      pPolicyPara.cbSize = 16;
      pPolicyPara.dwFlags = v6 != 0 ? 7 : 0;
      if ( (v26 & 1) != 0 )
        McGenEventWrite_EventWriteTransfer((unsigned int)-v6, &ChainVerifyStart, v23, v24, &v55);
      if ( !CertVerifyCertificateChainPolicy((LPCSTR)4, pChainContext, &pPolicyPara, &pPolicyStatus) )
      {
        if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
          McGenEventWrite_EventWriteTransfer(v27, &ChainVerifyStop, v28, v29, &v56);
        GetLastError();
LABEL_49:
        CertFreeCertificateChain(pChainContext);
        continue;
      }
      if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
        McGenEventWrite_EventWriteTransfer(v27, &ChainVerifyStop, v28, v29, &v57);
      v30 = I_MapWinTrustErrorAndAlert(pPolicyStatus.dwError, 0, 6144, 0i64);
      if ( v30 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 30i64, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids, v30);
        goto LABEL_49;
      }
      CertFreeCertificateChain(pChainContext);
      if ( DoesCertHaveBasicConstraintCA(v8) )
      {
        v31 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 31i64, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids);
          v31 = WPP_GLOBAL_Control;
        }
        v11 = 1;
        if ( v6 )
        {
          if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v31 + 28) & 4) != 0 )
          {
            v33 = 33i64;
            goto LABEL_76;
          }
          goto LABEL_77;
        }
        if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v31 + 28) & 4) != 0 )
        {
          v32 = 32i64;
LABEL_72:
          WPP_SF_(*((_QWORD *)v31 + 2), v32, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids);
          continue;
        }
      }
      else
      {
        v31 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 34i64, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids);
          v31 = WPP_GLOBAL_Control;
        }
        if ( !v6 )
        {
          if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v31 + 28) & 4) != 0 )
          {
            v33 = 35i64;
            goto LABEL_76;
          }
          goto LABEL_77;
        }
        if ( v11 != 1 )
        {
          if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v31 + 28) & 4) != 0 )
          {
            v33 = 37i64;
LABEL_76:
            WPP_SF_(*((_QWORD *)v31 + 2), v33, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids);
          }
LABEL_77:
          memset_0(v50, 0, sizeof(v50));
          v49 = v45;
          v46 = 0i64;
          v48[0] = 4;
          v48[1] = 1;
          memset(&v45[1], 0, 32);
          v45[0] = (unsigned __int64)v8;
          if ( !(unsigned int)CSslCredManager::CreateCredentialGroup(
                                CSslCredManager::m_pCredManager,
                                a1,
                                v38,
                                *(struct _LUID **)&DestinationString.Length,
                                v39,
                                (struct LSA_SCHANNEL_CRED *)v48,
                                SourceString) )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 38i64, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids);
            }
            v14 = 0;
            goto LABEL_85;
          }
          continue;
        }
        if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v31 + 28) & 4) != 0 )
        {
          v32 = 36i64;
          goto LABEL_72;
        }
      }
    }
    if ( (unsigned int)++v6 < 2 )
      continue;
    break;
  }
  v14 = -2146893042;
LABEL_82:
  if ( (g_dwEventLogging & 1) != 0 )
  {
    RtlInitUnicodeString(&DestinationString, SourceString);
    SchEventWrite(&SSLEVENT_NO_DEFAULT_SERVER_CRED, L"du", a5, &DestinationString);
  }
  if ( v10 )
LABEL_85:
    SPExternalFree(v10);
  if ( v8 )
    CertFreeCertificateContext(v8);
  if ( v9 )
    CertCloseStore(v9, 0);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v14 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    LODWORD(pvPara) = v14;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x27u,
      (__int64)&WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids,
      v14,
      pvPara);
  }
  return v14;
}
// 180058028: variable 'v19' is possibly undefined
// 180058028: variable 'v20' is possibly undefined
// 180058028: variable 'v21' is possibly undefined
// 18005808A: variable 'v22' is possibly undefined
// 18005808A: variable 'v23' is possibly undefined
// 18005808A: variable 'v24' is possibly undefined
// 1800581D7: variable 'v27' is possibly undefined
// 1800581D7: variable 'v28' is possibly undefined
// 1800581D7: variable 'v29' is possibly undefined
// 180058531: variable 'pvPara' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 18008275C: using guessed type wchar_t aMy[3];
// 180084C60: using guessed type EVENT_DESCRIPTOR ChainVerifyStop;
// 180084C70: using guessed type EVENT_DESCRIPTOR ChainVerifyStart;
// 180084C80: using guessed type EVENT_DESCRIPTOR ChainBuildStop;
// 180084C90: using guessed type EVENT_DESCRIPTOR ChainBuildStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 180057D84: using guessed type char var_118[96];

//----- (0000000180058598) ----------------------------------------------------
void __fastcall GetImplementationType(PCCERT_CONTEXT pCertContext, unsigned int *a2)
{
  HLOCAL v4; // rax
  HLOCAL v5; // rbx
  DWORD pcbData; // [rsp+58h] [rbp+10h] BYREF
  unsigned int pbData; // [rsp+60h] [rbp+18h] BYREF
  HCRYPTPROV phProv; // [rsp+68h] [rbp+20h] BYREF

  phProv = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 40i64, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids);
  *a2 = 4;
  if ( CertGetCertificateContextProperty(pCertContext, 2u, 0i64, &pcbData) )
  {
    v4 = SPExternalAlloc(pcbData);
    v5 = v4;
    if ( v4 )
    {
      if ( CertGetCertificateContextProperty(pCertContext, 2u, v4, &pcbData) )
      {
        *((_DWORD *)v5 + 5) &= ~1u;
        if ( CryptAcquireContextW(
               &phProv,
               *(LPCWSTR *)v5,
               *((LPCWSTR *)v5 + 1),
               *((_DWORD *)v5 + 4),
               *((_DWORD *)v5 + 5) | 0x40) )
        {
          pcbData = 4;
          if ( CryptGetProvParam(phProv, 3u, (BYTE *)&pbData, &pcbData, 0) )
            *a2 = pbData;
        }
      }
      SPExternalFree(v5);
    }
  }
  if ( phProv )
    CryptReleaseContext(phProv, 0);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 41i64, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids);
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (00000001800586FC) ----------------------------------------------------
__int64 __fastcall QueryCredentialManagerForCert(struct CSsl3TlsClientContext *this, unsigned __int16 *a2)
{
  int ClientLogonId; // ebx
  int v5; // eax
  HCERTSTORE v6; // rdi
  PCCERT_CONTEXT CertificateInStore; // rsi
  DWORD LastError; // eax
  void *pvPara; // [rsp+20h] [rbp-50h]
  __int64 v11; // [rsp+40h] [rbp-30h] BYREF
  PVOID Credential; // [rsp+48h] [rbp-28h] BYREF
  struct _LUID v13; // [rsp+50h] [rbp-20h] BYREF
  int pvFindPara; // [rsp+58h] [rbp-18h] BYREF
  __int64 v15; // [rsp+60h] [rbp-10h]
  int v16; // [rsp+B0h] [rbp+40h] BYREF
  enum _CRED_MARSHAL_TYPE CredType; // [rsp+B8h] [rbp+48h] BYREF

  v11 = 0i64;
  v16 = 0;
  Credential = 0i64;
  v13 = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids);
  ClientLogonId = SslGetClientLogonId(&v13);
  if ( !ClientLogonId )
  {
    ClientLogonId = SslImpersonateClient(*(_QWORD *)(*((_QWORD *)this + 10) + 752i64), &v16);
    if ( !ClientLogonId )
    {
      v5 = (*(__int64 (__fastcall **)(struct _LUID *, __int64, unsigned __int16 *, __int64, _DWORD, __int64 *))(LsaTable + 328))(
             &v13,
             1i64,
             a2,
             3i64,
             0,
             &v11);
      ClientLogonId = v5;
      if ( v5 >= 0 )
      {
        if ( CredIsMarshaledCredentialW(*(LPCWSTR *)(v11 + 72))
          && CredUnmarshalCredentialW(*(LPCWSTR *)(v11 + 72), &CredType, &Credential)
          && CredType == CertCredential )
        {
          v6 = CertOpenStore((LPCSTR)0xA, 1u, 0i64, 0x10004u, L"MY");
          if ( v6 )
          {
            v15 = (__int64)Credential + 4;
            pvFindPara = 20;
            CertificateInStore = CertFindCertificateInStore(v6, 1u, 0, 0x10000u, &pvFindPara, 0i64);
            if ( CertificateInStore )
            {
              if ( v16 )
              {
                RevertToSelf();
                v16 = 0;
              }
              ClientLogonId = AssignNewClientCredential(this, CertificateInStore);
              if ( ClientLogonId >= 0 )
                ClientLogonId = 0;
              CertFreeCertificateContext(CertificateInStore);
            }
            else
            {
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                LastError = GetLastError();
                WPP_SF_D(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  14i64,
                  &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids,
                  LastError);
              }
              ClientLogonId = -2146893042;
            }
            CertCloseStore(v6, 0);
          }
          else
          {
            GetLastError();
            ClientLogonId = -2146893042;
          }
        }
        else
        {
          ClientLogonId = -2146893043;
        }
      }
      else if ( v5 == -1073741275
             && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
             && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids);
      }
    }
  }
  if ( v11 )
    (*(void (**)(void))(LsaTable + 48))();
  if ( Credential )
    CredFree(Credential);
  if ( v16 )
    RevertToSelf();
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && ClientLogonId || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    LODWORD(pvPara) = ClientLogonId;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xFu,
      (__int64)&WPP_d5302f0819dd3315699237cebd9fbb35_Traceguids,
      ClientLogonId,
      pvPara);
  }
  return (unsigned int)ClientLogonId;
}
// 1800589EE: variable 'pvPara' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 18008275C: using guessed type wchar_t aMy[3];
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180058A18) ----------------------------------------------------
unsigned __int8 __fastcall CSslCredManager::CheckForGpEventAndUpdateIssuersList(CSslCredManager *this)
{
  void *v2; // rcx
  _DWORD *i; // rax

  v2 = (void *)*((_QWORD *)this + 8);
  if ( !v2 || WaitForSingleObjectEx(v2, 0, 0) )
    return 0;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids);
  RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
  for ( i = (_DWORD *)*((_QWORD *)this + 6); i != (_DWORD *)((char *)this + 48); i = *(_DWORD **)i )
    i[37] |= 0x10u;
  RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
  return 1;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180058AC4) ----------------------------------------------------
void __fastcall DbgDumpSubCreds(struct LSA_SCHANNEL_SUB_CRED *a1, unsigned int a2, __int64 a3)
{
  unsigned int v3; // edi
  struct LSA_SCHANNEL_SUB_CRED *v5; // rbx
  CCipherMill *v6; // rcx
  __int64 v7; // rdx
  __int64 v8; // [rsp+20h] [rbp-28h]

  if ( a1 )
  {
    v3 = 0;
    v5 = a1;
    if ( a2 )
    {
      v6 = WPP_GLOBAL_Control;
      do
      {
        if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 4) != 0 )
        {
          LODWORD(v8) = *((_DWORD *)v5 + 12);
          WPP_SF_dD(*((_QWORD *)v6 + 2), 0xBu, a3, v3, v8);
          v6 = WPP_GLOBAL_Control;
        }
        v7 = *(_QWORD *)v5;
        if ( *(_QWORD *)v5 )
        {
          a3 = *(_QWORD *)(v7 + 24);
          if ( a3 )
          {
            if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 4) != 0 )
            {
              WPP_SF_dDDs(*((_QWORD *)v6 + 2), v7, a3, v3, *(_DWORD *)v7, *(_DWORD *)a3, *(_QWORD *)(a3 + 24));
              v6 = WPP_GLOBAL_Control;
            }
          }
        }
        ++v3;
        v5 = (struct LSA_SCHANNEL_SUB_CRED *)((char *)v5 + 56);
      }
      while ( v3 < a2 );
    }
  }
}
// 180058B1C: variable 'a3' is possibly undefined
// 180058B1C: variable 'v8' is possibly undefined

//----- (0000000180058B94) ----------------------------------------------------
void __fastcall DbgDumpTlsParams(struct _TLS_PARAMETERS *a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // r15d
  unsigned int v4; // esi
  CCipherMill *v5; // rbx
  _DWORD *v6; // rdi
  __int64 v7; // r14
  unsigned int v8; // r12d
  unsigned int v9; // ebp
  __int64 v10; // r14
  __m128i v11; // xmm0
  char *v12; // rcx
  unsigned __int64 v13; // r9
  __int16 v14; // ax
  char *v15; // rax
  __int64 v16; // [rsp+20h] [rbp-F8h]
  __int64 v17; // [rsp+28h] [rbp-F0h]
  unsigned int v18; // [rsp+50h] [rbp-C8h]
  char v19[128]; // [rsp+60h] [rbp-B8h] BYREF

  if ( a1 )
  {
    v18 = a2;
    v3 = a2;
    v4 = 0;
    if ( (_DWORD)a2 )
    {
      v5 = WPP_GLOBAL_Control;
      v6 = (_DWORD *)((char *)a1 + 32);
      do
      {
        if ( v5 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v5 + 28) & 4) != 0 )
        {
          LODWORD(v17) = *(v6 - 4);
          LODWORD(v16) = *v6;
          WPP_SF_dDD(*((_QWORD *)v5 + 2), a2, a3, v4, v16, v17);
          v5 = WPP_GLOBAL_Control;
        }
        v7 = *((_QWORD *)v6 - 1);
        v8 = *(v6 - 3);
        if ( v7 )
        {
          v9 = 0;
          if ( v8 )
          {
            v10 = v7 + 40;
            do
            {
              memset_0(v19, 0, sizeof(v19));
              v11 = *(__m128i *)(v10 - 32);
              a2 = 64i64;
              v12 = v19;
              a3 = (unsigned __int64)(unsigned __int16)_mm_cvtsi128_si32(v11) >> 1;
              v13 = _mm_srli_si128(v11, 8).m128i_u64[0] - (_QWORD)v19;
              do
              {
                if ( !(a3 + a2 - 64) )
                  break;
                v14 = *(_WORD *)&v12[v13];
                if ( !v14 )
                  break;
                *(_WORD *)v12 = v14;
                v12 += 2;
                --a2;
              }
              while ( a2 );
              v15 = v12 - 2;
              if ( a2 )
                v15 = v12;
              *(_WORD *)v15 = 0;
              if ( v5 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v5 + 28) & 4) != 0 )
              {
                WPP_SF_dddSdd(*((_QWORD *)v5 + 2), a2, a3, v4, v9, *(_DWORD *)(v10 - 40), (__int64)v19);
                v5 = WPP_GLOBAL_Control;
              }
              ++v9;
              v10 += 48i64;
            }
            while ( v9 < v8 );
            v3 = v18;
          }
        }
        ++v4;
        v6 += 10;
      }
      while ( v4 < v3 );
    }
  }
}
// 180058C14: variable 'a2' is possibly undefined
// 180058C14: variable 'a3' is possibly undefined
// 180058C14: variable 'v16' is possibly undefined
// 180058C14: variable 'v17' is possibly undefined

//----- (0000000180058D5C) ----------------------------------------------------
void __fastcall CSslCredManager::FreeCredentialManager(CSslCredManager *this)
{
  CSslCredManager *v1; // rbx
  void *v2; // rcx
  void *v3; // rcx
  __int64 v4; // rax

  v1 = CSslCredManager::m_pCredManager;
  if ( CSslCredManager::m_pCredManager )
  {
    v2 = (void *)*((_QWORD *)CSslCredManager::m_pCredManager + 8);
    if ( v2 )
    {
      UnregisterGPNotification(v2);
      CloseHandle(*((HANDLE *)v1 + 8));
    }
    v3 = (void *)*((_QWORD *)v1 + 9);
    if ( v3 )
    {
      if ( *((_QWORD *)v1 + 10) )
      {
        CertControlStore(v3, 0, 5u, (char *)v1 + 80);
        CloseHandle(*((HANDLE *)v1 + 10));
        v3 = (void *)*((_QWORD *)v1 + 9);
      }
      CertCloseStore(v3, 0);
    }
    RtlDeleteCriticalSection((PRTL_CRITICAL_SECTION)((char *)v1 + 8));
    v4 = *(_QWORD *)v1;
    CSslCredManager::m_pCredManager = 0i64;
    (*(void (__fastcall **)(CSslCredManager *, __int64))(v4 + 8))(v1, 1i64);
  }
}

//----- (0000000180058E30) ----------------------------------------------------
__int64 __fastcall CSslCredManager::NotifyProviderChange(CSslCredManager *this)
{
  struct _RTL_CRITICAL_SECTION *v1; // rsi
  _QWORD **v2; // rdi
  _QWORD *i; // rbx

  v1 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 8);
  v2 = (_QWORD **)((char *)this + 48);
  RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
  for ( i = *v2; i != v2; i = (_QWORD *)*i )
    CCredentialGroup::NotifyProviderChange((CCredentialGroup *)(i - 1));
  RtlLeaveCriticalSection(v1);
  return 0i64;
}

//----- (0000000180058E94) ----------------------------------------------------
__int64 WPP_SF_dD(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, ...)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+80h] [rbp+28h] BYREF

  va_start(va, a4);
  v5 = a4;
  return EtwTraceMessage(
           a1,
           43i64,
           &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids,
           a2,
           &v5,
           4i64,
           (__int64 *)va,
           4i64,
           0i64);
}

//----- (0000000180058EEC) ----------------------------------------------------
__int64 WPP_SF_dDD(__int64 a1, __int64 a2, __int64 a3, int a4, ...)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF
  __int64 v6; // [rsp+90h] [rbp+28h] BYREF
  va_list va; // [rsp+90h] [rbp+28h]
  va_list va1; // [rsp+98h] [rbp+30h] BYREF

  va_start(va1, a4);
  va_start(va, a4);
  v6 = va_arg(va1, _QWORD);
  v5 = a4;
  return EtwTraceMessage(
           a1,
           43i64,
           &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids,
           13i64,
           &v5,
           4i64,
           (__int64 *)va,
           4i64,
           va1);
}

//----- (0000000180058F54) ----------------------------------------------------
__int64 __fastcall WPP_SF_dDDs(__int64 a1, __int64 a2, __int64 a3, int a4, char a5, char a6, __int64 a7)
{
  __int64 v7; // rax
  int v9; // [rsp+98h] [rbp+20h] BYREF

  v9 = a4;
  if ( a7 )
  {
    v7 = -1i64;
    do
      ++v7;
    while ( *(_BYTE *)(a7 + v7) );
  }
  return EtwTraceMessage(a1, 43i64, &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids, 12i64, &v9, 4i64, &a5, 4i64, &a6);
}

//----- (0000000180059008) ----------------------------------------------------
__int64 __fastcall WPP_SF_dddSdd(__int64 a1, __int64 a2, __int64 a3, int a4, char a5, char a6, __int64 a7)
{
  __int64 v7; // rax
  int v9; // [rsp+B8h] [rbp+20h] BYREF

  v9 = a4;
  if ( a7 )
  {
    v7 = -1i64;
    do
      ++v7;
    while ( *(_WORD *)(a7 + 2 * v7) );
  }
  return EtwTraceMessage(a1, 43i64, &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids, 14i64, &v9, 4i64, &a5, 4i64, &a6);
}

//----- (00000001800590F0) ----------------------------------------------------
void __fastcall CSessionCacheTable::~CSessionCacheTable(CSessionCacheTable *this)
{
  char *v1; // rsi
  char *i; // rbx

  v1 = (char *)this + 16;
  for ( i = (char *)*((_QWORD *)this + 2); i != v1; i = *(char **)i )
  {
    if ( i != (char *)304 )
      (*(void (__fastcall **)(_QWORD *, __int64))(*((_QWORD *)i - 38) + 8i64))((_QWORD *)i - 38, 1i64);
  }
  if ( *((_BYTE *)this + 144) )
    RtlDeleteResource((PRTL_RESOURCE)((char *)this + 48));
}

//----- (000000018005916C) ----------------------------------------------------
__int64 __fastcall CSessionCacheManager::CacheGetInfo(
        CSessionCacheManager *this,
        char a2,
        struct _SSL_SESSION_CACHE_INFO_RESPONSE *a3)
{
  unsigned int v3; // ebx

  *(_OWORD *)a3 = 0i64;
  *((_QWORD *)a3 + 2) = 0i64;
  v3 = 0;
  *((_DWORD *)a3 + 6) = 0;
  for ( *(_DWORD *)a3 = *((_DWORD *)this + 7); v3 < *((_DWORD *)this + 12); ++v3 )
    CSessionCacheTable::CacheGetInfo((CSessionCacheTable *)(*((_QWORD *)this + 5) + 152i64 * v3), a2, a3);
  return 0i64;
}

//----- (00000001800591E4) ----------------------------------------------------
__int64 __fastcall CSessionCacheTable::CacheGetInfo(
        CSessionCacheTable *this,
        char a2,
        struct _SSL_SESSION_CACHE_INFO_RESPONSE *a3)
{
  struct _RTL_RESOURCE *v6; // rbp
  unsigned int TickCount; // r12d
  char *v8; // r14
  char *v9; // rsi
  unsigned int *v10; // rbx
  int v11; // eax
  bool v12; // zf

  v6 = (struct _RTL_RESOURCE *)((char *)this + 48);
  TickCount = GetTickCount();
  RtlAcquireResourceExclusive(v6, 1u);
  v8 = (char *)this + 16;
  v9 = (char *)*((_QWORD *)this + 2);
  while ( v9 != v8 )
  {
    v10 = (unsigned int *)(v9 - 304);
    v9 = *(char **)v9;
    v11 = (*(__int64 (__fastcall **)(unsigned int *))(*(_QWORD *)v10 + 88i64))(v10);
    if ( v11 == 1 )
    {
      v12 = (a2 & 1) == 0;
LABEL_6:
      if ( !v12 )
      {
        ++*((_DWORD *)a3 + 1);
        if ( v10[58] == 1 )
        {
          ++*((_DWORD *)a3 + 3);
          if ( HasTimeElapsed(v10[69], TickCount, v10[70]) )
            ++*((_DWORD *)a3 + 4);
          if ( !*((_BYTE *)v10 + 236) )
            ++*((_DWORD *)a3 + 5);
        }
        else
        {
          ++*((_DWORD *)a3 + 2);
        }
      }
    }
    else if ( v11 == 2 )
    {
      v12 = (a2 & 2) == 0;
      goto LABEL_6;
    }
  }
  RtlReleaseResource(v6);
  return 0i64;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (00000001800592E8) ----------------------------------------------------
__int64 __fastcall CSessionCacheManager::CacheRetrieveNewServerItem(
        CSessionCacheManager *this,
        int a2,
        unsigned __int8 *const a3,
        struct CSessionCacheServerItem **a4)
{
  __int64 result; // rax
  struct CSessionCacheItem *v7; // rcx
  struct CSessionCacheItem *v8; // [rsp+30h] [rbp-18h] BYREF

  result = CSessionCacheManager::CacheRetrieveNewItem(this, 1, 0i64, a3, &v8);
  if ( !(_DWORD)result )
  {
    v7 = v8;
    *a4 = v8;
    if ( v7 )
      *((_DWORD *)v7 + 42) = a2;
    else
      return 87i64;
  }
  return result;
}

//----- (000000018005933C) ----------------------------------------------------
bool __fastcall CSessionCacheTable::LookupCacheBySessionId(
        CSessionCacheTable *this,
        unsigned int a2,
        struct CSslContext *a3,
        unsigned __int8 *a4,
        size_t Size,
        struct CSessionCacheItem **a6)
{
  __int64 v6; // r14
  int v8; // edi
  __int64 v9; // r14
  _QWORD **v10; // rcx
  _QWORD *v11; // rsi
  unsigned int v12; // r12d
  _QWORD *v13; // rbx
  CSessionCacheTable *v14; // rcx
  _QWORD *v15; // rbx
  __int64 v16; // rcx
  _QWORD *v17; // rax
  __int64 v19[11]; // [rsp+30h] [rbp-58h] BYREF
  DWORD TickCount; // [rsp+90h] [rbp+8h]
  unsigned int v21; // [rsp+98h] [rbp+10h] BYREF
  struct CSslContext *v22; // [rsp+A0h] [rbp+18h]
  void *Buf1; // [rsp+A8h] [rbp+20h]

  Buf1 = a4;
  v22 = a3;
  v6 = a2;
  v8 = 0;
  TickCount = GetTickCount();
  SslGetClientProcess(&v21);
  RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)this + 48), 1u);
  v9 = 16 * v6;
  v10 = (_QWORD **)(v9 + *(_QWORD *)this);
  v11 = *v10;
  if ( *v10 != v10 )
  {
    v12 = v21;
    while ( 1 )
    {
      v13 = v11 - 36;
      v11 = (_QWORD *)*v11;
      RtlAcquireResourceShared((PRTL_RESOURCE)(v13 + 9), 1u);
      if ( *((_BYTE *)v13 + 236) )
      {
        if ( !HasTimeElapsed(*((_DWORD *)v13 + 69), TickCount, *((_DWORD *)v13 + 70))
          && (_DWORD)Size == *((unsigned __int16 *)v13 + 119)
          && !memcmp_0(Buf1, v13 + 30, (unsigned int)Size)
          && *((_DWORD *)v13 + 68) == v12 )
        {
          v19[0] = *(_QWORD *)(*((_QWORD *)v22 + 10) + 760i64);
          if ( (*(unsigned __int8 (__fastcall **)(_QWORD *, _QWORD, _QWORD, __int64 *, _DWORD))(*v13 + 80i64))(
                 v13,
                 0i64,
                 0i64,
                 v19,
                 *((_DWORD *)v22 + 16)) )
          {
            break;
          }
        }
      }
      RtlReleaseResource((PRTL_RESOURCE)(v13 + 9));
      if ( v11 == (_QWORD *)(v9 + *(_QWORD *)this) )
        goto LABEL_20;
    }
    v8 = CSessionCacheTable::ReferenceCacheItemInternal(v14, (struct CSessionCacheItem *)v13);
    RtlReleaseResource((PRTL_RESOURCE)(v13 + 9));
    if ( v8 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_q(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xAu,
          (__int64)&WPP_54aae497645f38b3b161e68e12f6f932_Traceguids,
          v13);
      *a6 = (struct CSessionCacheItem *)v13;
      if ( v8 == 2 )
      {
        v15 = v13 + 40;
        v16 = *v15;
        if ( *(_QWORD **)(*v15 + 8i64) != v15 || (v17 = (_QWORD *)v15[1], (_QWORD *)*v17 != v15) )
          __fastfail(3u);
        *v17 = v16;
        *(_QWORD *)(v16 + 8) = v17;
      }
      LsaIModifyPerformanceCounter(9i64);
    }
  }
LABEL_20:
  RtlReleaseResource((PRTL_RESOURCE)((char *)this + 48));
  return v8 > 0;
}
// 1800594A4: variable 'v14' is possibly undefined
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);
// 18005933C: using guessed type __int64 var_58[11];

//----- (0000000180059568) ----------------------------------------------------
unsigned __int8 __fastcall CSessionCacheManager::LookupCacheForServerItem(
        CSessionCacheManager *this,
        struct CSslContext *a2,
        unsigned __int8 *a3,
        unsigned int a4,
        struct CSessionCacheServerItem **a5)
{
  size_t Size; // [rsp+20h] [rbp-28h]
  struct CSessionCacheItem *v7; // [rsp+30h] [rbp-18h] BYREF

  if ( a4 >= 4 && *(_DWORD *)a3 < *((_DWORD *)this + 4) )
  {
    LODWORD(Size) = a4;
    if ( CSessionCacheTable::LookupCacheBySessionId(
           (CSessionCacheTable *)(*((_QWORD *)this + 5) + 152i64
                                                        * (unsigned int)(*(_DWORD *)a3 / *((_DWORD *)this + 13))),
           *(_DWORD *)a3 % *((_DWORD *)this + 13),
           a2,
           a3,
           Size,
           &v7) )
    {
      *a5 = v7;
      return 1;
    }
    *a5 = 0i64;
  }
  return 0;
}
// 1800595AD: variable 'Size' is possibly undefined

//----- (00000001800595E0) ----------------------------------------------------
__int64 __fastcall CSessionCacheManager::PurgeCacheEntries(
        CSessionCacheManager *this,
        unsigned int a2,
        struct _LUID *a3,
        int a4,
        unsigned __int16 *a5)
{
  int *v5; // rsi
  unsigned int v6; // ebx

  v5 = (int *)((char *)this + 32);
  v6 = 0;
  if ( *((_DWORD *)this + 8) && *((_DWORD *)this + 12) )
  {
    do
      CSessionCacheTable::PurgeCacheEntries(
        (CSessionCacheTable *)(*((_QWORD *)this + 5) + 152i64 * v6++),
        a2,
        a3,
        a4,
        v5,
        a5);
    while ( v6 < *((_DWORD *)this + 12) );
  }
  return 0i64;
}

//----- (0000000180059674) ----------------------------------------------------
__int64 __fastcall CSessionCacheTable::PurgeCacheEntries(
        CSessionCacheTable *this,
        unsigned int a2,
        struct _LUID *a3,
        int a4,
        int *a5,
        const unsigned __int16 *a6)
{
  struct _RTL_RESOURCE *v7; // r15
  __int64 **v8; // r14
  __int64 *v9; // rsi
  __int64 *v10; // rbx
  __int64 **v11; // rdi
  struct _RTL_RESOURCE *v12; // rbp
  __int64 v13; // rdx
  __int64 **v14; // rcx
  __int64 *v15; // rcx
  __int64 ***v16; // rax
  _QWORD *v17; // rbx
  __int64 v18; // rcx
  _QWORD *v19; // rax
  __int64 **v20; // rax
  __int64 *v21; // rbx
  __int64 *v22; // rcx
  __int64 *v24; // [rsp+30h] [rbp-48h] BYREF
  __int64 **v25; // [rsp+38h] [rbp-40h]

  v25 = &v24;
  v7 = (struct _RTL_RESOURCE *)((char *)this + 48);
  v8 = (__int64 **)((char *)this + 16);
  v24 = (__int64 *)&v24;
  RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)this + 48), 1u);
  v9 = *v8;
  while ( v9 != (__int64 *)v8 )
  {
    v10 = v9 - 38;
    v11 = (__int64 **)v9;
    v9 = (__int64 *)*v9;
    v12 = (struct _RTL_RESOURCE *)(v10 + 9);
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(v10 + 9), 1u);
    if ( (a4 == *((_DWORD *)v10 + 68) || (a2 & 0x20000) != 0)
      && (*(unsigned __int8 (__fastcall **)(__int64 *, struct _LUID *, const unsigned __int16 *, _QWORD))(*v10 + 72))(
           v10,
           a3,
           a6,
           a2) )
    {
      if ( *((int *)v10 + 58) <= 1 )
      {
        v13 = v10[36];
        if ( *(__int64 **)(v13 + 8) != v10 + 36 )
          goto LABEL_17;
        v14 = (__int64 **)v10[37];
        if ( *v14 != v10 + 36 )
          goto LABEL_17;
        *v14 = (__int64 *)v13;
        *(_QWORD *)(v13 + 8) = v14;
        v15 = *v11;
        if ( (__int64 **)(*v11)[1] != v11 )
          goto LABEL_17;
        v16 = (__int64 ***)v11[1];
        if ( *v16 != v11 )
          goto LABEL_17;
        *v16 = (__int64 **)v15;
        v17 = v10 + 40;
        v15[1] = (__int64)v16;
        v18 = *v17;
        if ( *(_QWORD **)(*v17 + 8i64) != v17
          || (v19 = (_QWORD *)v17[1], (_QWORD *)*v19 != v17)
          || (*v19 = v18,
              *(_QWORD *)(v18 + 8) = v19,
              _InterlockedDecrement(a5),
              LsaIModifyPerformanceCounter(4i64),
              v20 = v25,
              *v25 != (__int64 *)&v24) )
        {
LABEL_17:
          __fastfail(3u);
        }
        v11[1] = (__int64 *)v25;
        *v11 = (__int64 *)&v24;
        *v20 = (__int64 *)v11;
        v25 = v11;
      }
      else
      {
        *((_WORD *)v10 + 118) = 0;
      }
    }
    RtlReleaseResource(v12);
  }
  RtlReleaseResource(v7);
  v21 = v24;
  while ( v21 != (__int64 *)&v24 )
  {
    v22 = v21 - 38;
    v21 = (__int64 *)*v21;
    if ( v22 )
      (*(void (__fastcall **)(__int64 *, __int64))(*v22 + 8))(v22, 1i64);
  }
  return 0i64;
}
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);

//----- (000000018005988C) ----------------------------------------------------
__int64 __fastcall CSessionCacheManager::ShutdownSessionCache(CSessionCacheManager *this)
{
  void *v3; // rcx
  unsigned int v4; // edi

  if ( !this )
    return 1359i64;
  if ( *((_QWORD *)this + 1) )
  {
    v3 = (void *)*((_QWORD *)this + 5);
    if ( v3 )
    {
      v4 = 0;
      if ( *((_DWORD *)this + 12) )
      {
        do
          CSessionCacheTable::~CSessionCacheTable((CSessionCacheTable *)(*((_QWORD *)this + 5) + 152i64 * v4++));
        while ( v4 < *((_DWORD *)this + 12) );
        v3 = (void *)*((_QWORD *)this + 5);
      }
      SPExternalFree(v3);
      *((_QWORD *)this + 5) = 0i64;
    }
    SPExternalFree(*((void **)this + 1));
    *((_QWORD *)this + 1) = 0i64;
  }
  if ( *((_BYTE *)this + 96) )
    RtlDeleteCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 56));
  (*(void (__fastcall **)(CSessionCacheManager *, __int64))(*(_QWORD *)this + 8i64))(this, 1i64);
  return 0i64;
}

//----- (0000000180059940) ----------------------------------------------------
__int64 __fastcall BuildLegacySupportedAlgsList(struct CCredentialGroup *a1, unsigned int **a2, unsigned int *a3)
{
  int v3; // ebp
  int v4; // r15d
  unsigned int *v9; // rax
  __int64 v10; // rdx
  __int64 v11; // r9
  __int64 v12; // r13
  __int64 v13; // r12
  unsigned int v14; // esi
  _DWORD *v15; // rax
  int v16; // r8d
  unsigned int v17; // ecx
  int v18; // eax
  _DWORD *v19; // rcx
  __int64 v20; // rdx
  struct hsel *HashInfo; // rax
  struct kexch *KeyExchangeInfo; // rax
  _DWORD *v23; // r15
  unsigned __int8 v24; // al
  int v25; // edx
  _DWORD *v26; // rsi
  unsigned int v27; // eax
  _DWORD *v28; // r15
  int v29; // edx
  int v30; // r8d
  int *v31; // rsi
  __int64 v32; // rbp
  _DWORD *v33; // r15
  int v34; // edx
  int v35; // r8d
  int *v36; // rsi
  __int64 v37; // rbp
  _DWORD *v38; // r15
  int v39; // edx
  int v40; // r8d
  unsigned int v41; // [rsp+20h] [rbp-48h]
  __int64 v42; // [rsp+28h] [rbp-40h]
  int v43; // [rsp+70h] [rbp+8h]
  int v44; // [rsp+88h] [rbp+20h]

  v3 = 0;
  v4 = 0;
  v44 = 0;
  v43 = 0;
  if ( !a1 )
    return 87i64;
  *a3 = 0;
  v9 = (unsigned int *)SPExternalAlloc(0x58u);
  *a2 = v9;
  if ( !v9 )
    return 14i64;
  v10 = *((_QWORD *)a1 + 23);
  v42 = v10;
  v11 = 4i64;
  v12 = 8i64;
  if ( v10 )
  {
    v13 = 0i64;
    v41 = *((_DWORD *)a1 + 44);
    if ( v41 )
    {
      while ( 2 )
      {
        v14 = *(_DWORD *)(v10 + 4 * v13);
        v15 = &unk_180085640;
        v16 = 0;
        v17 = 0;
        while ( v14 != *v15 )
        {
          ++v17;
          v15 = (_DWORD *)((char *)v15 + v11);
          if ( v17 >= 0x11 )
          {
            if ( v17 == 17 )
            {
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                WPP_SF_D(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  10i64,
                  &WPP_f57d92ef57843aa8f0882fb6fd501a9b_Traceguids,
                  v14);
              }
              SPExternalFree(*a2);
              *a2 = 0i64;
              return 87i64;
            }
            break;
          }
        }
        v18 = *(_DWORD *)(v10 + 4 * v13) & 0xE000;
        switch ( v18 )
        {
          case 24576:
            v19 = &unk_180091108;
            v20 = 8i64;
            do
            {
              if ( *(v19 - 2) == v14
                && *v19 >= *((_DWORD *)a1 + 41)
                && *v19 <= *((_DWORD *)a1 + 42)
                && (*((_DWORD *)a1 + 38) & *(v19 - 10)) != 0 )
              {
                v16 = 1;
              }
              v19 += 14;
              --v20;
            }
            while ( v20 );
            v43 = v4;
            v3 = 1;
            if ( !v16 )
              goto LABEL_24;
            break;
          case 32768:
            v44 = 1;
            HashInfo = GetHashInfo(v14);
            if ( !HashInfo || (*(_DWORD *)HashInfo & *((_DWORD *)a1 + 38)) == 0 )
              goto LABEL_24;
            break;
          case 40960:
            v4 = 1;
            v43 = 1;
            KeyExchangeInfo = GetKeyExchangeInfo(v14);
            if ( !KeyExchangeInfo || (*((_DWORD *)KeyExchangeInfo + 1) & *((_DWORD *)a1 + 38)) == 0 )
            {
LABEL_24:
              v10 = v42;
              goto LABEL_25;
            }
            break;
          default:
LABEL_25:
            v13 = (unsigned int)(v13 + 1);
            if ( (unsigned int)v13 < v41 )
              continue;
            if ( v3 )
              goto LABEL_46;
            goto LABEL_39;
        }
        break;
      }
      v23 = *a2;
      v24 = DoesCredAllowAlgId(*a2, *a3, v14);
      v11 = 4i64;
      if ( !v24 )
      {
        v23[v25] = v14;
        ++*a3;
      }
      v4 = v43;
      goto LABEL_24;
    }
  }
LABEL_39:
  v26 = &g_AvailableCiphers;
  do
  {
    v27 = v26[10];
    if ( v27 >= *((_DWORD *)a1 + 41) && v27 <= *((_DWORD *)a1 + 42) && (*((_DWORD *)a1 + 38) & *v26) != 0 )
    {
      v28 = *a2;
      if ( !DoesCredAllowAlgId(*a2, *a3, v26[8]) )
      {
        v28[v29] = v30;
        ++*a3;
      }
    }
    v26 += 14;
    --v12;
  }
  while ( v12 );
LABEL_46:
  if ( !v44 )
  {
    v31 = (int *)&unk_180091028;
    v32 = 5i64;
    do
    {
      if ( (*(v31 - 6) & *((_DWORD *)a1 + 38)) != 0 )
      {
        v33 = *a2;
        if ( !DoesCredAllowAlgId(*a2, *a3, *v31) )
        {
          v33[v34] = v35;
          ++*a3;
        }
      }
      v31 += 10;
      --v32;
    }
    while ( v32 );
  }
  if ( !v43 )
  {
    v36 = (int *)&g_AvailableExch;
    v37 = 4i64;
    do
    {
      if ( (v36[1] & *((_DWORD *)a1 + 38)) != 0 )
      {
        v38 = *a2;
        if ( !DoesCredAllowAlgId(*a2, *a3, *v36) )
        {
          v38[v39] = v40;
          ++*a3;
        }
      }
      v36 += 16;
      --v37;
    }
    while ( v37 );
    (*a2)[(*a3)++] = 8704;
    (*a2)[(*a3)++] = 8707;
  }
  return 0i64;
}
// 1800599F1: variable 'v11' is possibly undefined
// 180059AEF: variable 'v25' is possibly undefined
// 180059B8E: variable 'v30' is possibly undefined
// 180059B8C: variable 'v29' is possibly undefined
// 180059BD5: variable 'v35' is possibly undefined
// 180059BD3: variable 'v34' is possibly undefined
// 180059C19: variable 'v40' is possibly undefined
// 180059C17: variable 'v39' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180059C68) ----------------------------------------------------
unsigned __int8 __fastcall DoesCredAllowAlgId(unsigned int *a1, unsigned int a2, int a3)
{
  unsigned int v3; // r9d
  int v5; // ecx
  bool v6; // zf

  v3 = 0;
  if ( !a2 )
    return 0;
  while ( 1 )
  {
    v5 = *a1;
    if ( ((*a1 - 9216) & 0xFFFF7FFF) != 0 )
    {
      if ( v5 == 43522 || v5 == 8704 )
      {
        if ( a3 == 43522 )
          return 1;
        v6 = a3 == 8704;
      }
      else
      {
        v6 = v5 == a3;
      }
    }
    else
    {
      v6 = ((a3 - 9216) & 0xFFFF7FFF) == 0;
    }
    if ( v6 )
      break;
    ++v3;
    ++a1;
    if ( v3 >= a2 )
      return 0;
  }
  return 1;
}

//----- (0000000180059CD0) ----------------------------------------------------
struct csel *__fastcall GetCipherInfo(int a1)
{
  __int64 v1; // rax
  _DWORD *i; // rdx

  v1 = 0i64;
  for ( i = &unk_180091100; *i != a1; i += 14 )
  {
    v1 = (unsigned int)(v1 + 1);
    if ( (unsigned int)v1 >= 8 )
      return 0i64;
  }
  return (struct csel *)((char *)&g_AvailableCiphers + 56 * v1);
}

//----- (0000000180059D04) ----------------------------------------------------
struct hsel *__fastcall GetHashInfo(int a1)
{
  __int64 v1; // rax
  _DWORD *i; // rdx

  v1 = 0i64;
  for ( i = &unk_180091028; *i != a1; i += 10 )
  {
    v1 = (unsigned int)(v1 + 1);
    if ( (unsigned int)v1 >= 5 )
      return 0i64;
  }
  return (struct hsel *)((char *)&g_AvailableHashes + 40 * v1);
}

//----- (0000000180059D38) ----------------------------------------------------
struct kexch *__fastcall GetKeyExchangeInfo(int a1)
{
  __int64 v1; // rax
  _DWORD *i; // rdx

  v1 = 0i64;
  for ( i = &g_AvailableExch; *i != a1; i += 16 )
  {
    v1 = (unsigned int)(v1 + 1);
    if ( (unsigned int)v1 >= 4 )
      return 0i64;
  }
  return (struct kexch *)((char *)&g_AvailableExch + 64 * v1);
}

//----- (0000000180059D68) ----------------------------------------------------
struct sigsel *__fastcall GetSigInfo(int a1)
{
  __int64 v1; // rax
  _DWORD *i; // rdx

  v1 = 0i64;
  for ( i = &unk_1800913EC; *i != a1; i += 8 )
  {
    v1 = (unsigned int)(v1 + 1);
    if ( (unsigned int)v1 >= 5 )
      return 0i64;
  }
  return (struct sigsel *)((char *)&g_AvailableSigs + 32 * v1);
}

//----- (0000000180059D9C) ----------------------------------------------------
__int64 __fastcall CCipherMill::GetCipherState(
        CCipherMill *this,
        struct CSslContext *a2,
        struct CCipherSuiteInfo **a3,
        int a4,
        unsigned int a5)
{
  CMasterCipherInfo *v8; // rax
  unsigned int v9; // edi
  unsigned int v10; // ebx
  _QWORD *v11; // rdx
  struct CCipherSuiteInfo *v12; // r8
  __int64 v13; // rax
  unsigned int v14; // r10d
  unsigned int v15; // r9d
  __int64 result; // rax

  RtlAcquireResourceShared(&Resource, 1u);
  v8 = xmmword_1800925B0;
  if ( (*((_DWORD *)a2 + 34) & 0x20000000) != 0 )
    v8 = *(&xmmword_1800925B0 + 1);
  v9 = 0;
  if ( v8 )
  {
    v10 = *((_DWORD *)v8 + 2);
    if ( v10 )
    {
      v11 = (_QWORD *)(*(_QWORD *)v8 + 848i64);
      while ( 1 )
      {
        v12 = (struct CCipherSuiteInfo *)(v11 - 106);
        if ( *((_DWORD *)v11 - 205) == a4 )
        {
          v13 = *v11;
          if ( !a5 )
            goto LABEL_15;
          if ( v13 )
          {
            v14 = *(_DWORD *)(v13 + 8);
            v15 = 0;
            if ( v14 )
              break;
          }
        }
LABEL_12:
        ++v9;
        v11 += 108;
        if ( v9 >= v10 )
          goto LABEL_19;
      }
      while ( a5 != *(_DWORD *)(780i64 * v15 + *(_QWORD *)v13 + 772) )
      {
        if ( ++v15 >= v14 )
          goto LABEL_12;
      }
      v13 = *v11;
LABEL_15:
      if ( v13 )
        _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v13 + 16) + 12i64));
      _InterlockedIncrement((volatile signed __int32 *)(*((_QWORD *)v12 + 107) + 12i64));
      *a3 = v12;
    }
  }
  else
  {
    v10 = 0;
  }
LABEL_19:
  RtlReleaseResource(&Resource);
  result = 1168i64;
  if ( v9 != v10 )
    return 0i64;
  return result;
}

//----- (0000000180059ED0) ----------------------------------------------------
__int64 __fastcall CCipherMill::GetPrivateKeyFromProvider(
        CCipherMill *this,
        const struct _CERT_CONTEXT *a2,
        struct ProviderToPrivateKey **a3,
        unsigned int *a4)
{
  unsigned int *v5; // r13
  unsigned int v7; // ebp
  __int64 v8; // rsi
  CCipherMill *v9; // rcx
  struct ProviderToPrivateKey *v10; // r14
  __int64 v11; // r15
  unsigned __int64 *v12; // rbx
  __int64 v13; // rax
  __int64 v16[32]; // [rsp+30h] [rbp-148h] BYREF

  v5 = a4;
  v7 = 1168;
  RtlAcquireResourceShared(&Resource, 1u);
  v8 = 0i64;
  if ( qword_180092498 )
  {
    while ( 1 )
    {
      v7 = SslOpenPrivateKey(*(_QWORD *)&g_cCipherMill[8 * v8 + 128], &v16[v8], a2, 64i64);
      if ( v7 )
        break;
      v8 = (unsigned int)(v8 + 1);
      if ( (unsigned int)v8 >= qword_180092498 )
      {
        v10 = (struct ProviderToPrivateKey *)SPExternalAlloc(16 * qword_180092498);
        if ( v10 )
        {
          v11 = 0i64;
          if ( qword_180092498 )
          {
            do
            {
              v12 = (unsigned __int64 *)((char *)v10 + 16 * (unsigned int)v11);
              CCipherMill::ReferenceProvider(v9, *(_QWORD *)&g_cCipherMill[8 * v11 + 128], v12);
              v13 = v16[v11];
              v11 = (unsigned int)(v11 + 1);
              v12[1] = v13;
            }
            while ( (unsigned int)v11 < qword_180092498 );
            v5 = a4;
          }
          *a3 = v10;
          *v5 = qword_180092498;
        }
        else
        {
          v7 = 14;
        }
        break;
      }
    }
  }
  RtlReleaseResource(&Resource);
  if ( v7 )
  {
    while ( (_DWORD)v8 )
    {
      v8 = (unsigned int)(v8 - 1);
      SslFreeObject(v16[v8], 0i64);
    }
  }
  return v7;
}
// 180059FB9: variable 'v9' is possibly undefined
// 180098448: using guessed type __int64 __fastcall SslOpenPrivateKey(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);
// 180059ED0: using guessed type __int64 var_148[32];

//----- (000000018005A04C) ----------------------------------------------------
__int64 __fastcall WPP_SF_DS(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, const wchar_t *a5)
{
  const wchar_t *v5; // r8
  __int64 v6; // rax
  __int64 v7; // rax
  int v9; // [rsp+78h] [rbp+20h] BYREF

  v9 = a4;
  v5 = a5;
  if ( a5 )
  {
    v6 = -1i64;
    do
      ++v6;
    while ( a5[v6] );
    v7 = 2 * v6 + 2;
  }
  else
  {
    v7 = 10i64;
  }
  if ( !a5 )
    v5 = L"NULL";
  return EtwTraceMessage(a1, 43i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids, a2, &v9, 4i64, v5, v7, 0i64);
}
// 180083C60: using guessed type wchar_t aNull_0[5];

//----- (000000018005A0DC) ----------------------------------------------------
__int64 WPP_SF_SDD(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, ...)
{
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v7; // [rsp+90h] [rbp+28h] BYREF
  va_list va; // [rsp+90h] [rbp+28h]
  va_list va1; // [rsp+98h] [rbp+30h] BYREF

  va_start(va1, a4);
  va_start(va, a4);
  v7 = va_arg(va1, _QWORD);
  if ( a4 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( a4[v4] );
    v5 = 2 * v4 + 2;
  }
  else
  {
    v5 = 10i64;
  }
  if ( !a4 )
    a4 = L"NULL";
  return EtwTraceMessage(
           a1,
           43i64,
           &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
           a2,
           a4,
           v5,
           (__int64 *)va,
           4i64,
           va1);
}
// 180083C60: using guessed type wchar_t aNull_0[5];

//----- (000000018005A174) ----------------------------------------------------
__int64 WPP_SF_Sd(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, ...)
{
  __int64 v4; // rax
  __int64 v5; // rax
  va_list va; // [rsp+80h] [rbp+28h] BYREF

  va_start(va, a4);
  if ( a4 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( a4[v4] );
    v5 = 2 * v4 + 2;
  }
  else
  {
    v5 = 10i64;
  }
  if ( !a4 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43i64, a3, a2, a4, v5, va, 4i64, 0i64);
}
// 180083C60: using guessed type wchar_t aNull_0[5];

//----- (000000018005A1F4) ----------------------------------------------------
__int64 __fastcall WPP_SF_sS(__int64 a1, __int64 a2, __int64 a3, const char *a4, const wchar_t *a5)
{
  const wchar_t *v5; // rdx
  __int64 v6; // rax
  __int64 v7; // r8
  __int64 v8; // r8
  __int64 v9; // rax

  v5 = a5;
  v6 = -1i64;
  if ( a5 )
  {
    v7 = -1i64;
    do
      ++v7;
    while ( a5[v7] );
    v8 = 2 * v7 + 2;
  }
  else
  {
    v8 = 10i64;
  }
  if ( !a5 )
    v5 = L"NULL";
  if ( a4 )
  {
    do
      ++v6;
    while ( a4[v6] );
    v9 = v6 + 1;
  }
  else
  {
    v9 = 5i64;
  }
  if ( !a4 )
    a4 = "NULL";
  return EtwTraceMessage(a1, 43i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids, 28i64, a4, v9, v5, v8, 0i64);
}
// 180083C60: using guessed type wchar_t aNull_0[5];

//----- (000000018005A2A4) ----------------------------------------------------
__int64 WPP_SF_sSD(__int64 a1, __int64 a2, __int64 a3, const char *a4, const wchar_t *a5, ...)
{
  const wchar_t *v5; // rdx
  __int64 v6; // rax
  __int64 v7; // r8
  __int64 v8; // r8
  __int64 v9; // rax
  va_list va; // [rsp+98h] [rbp+30h] BYREF

  va_start(va, a5);
  v5 = a5;
  v6 = -1i64;
  if ( a5 )
  {
    v7 = -1i64;
    do
      ++v7;
    while ( a5[v7] );
    v8 = 2 * v7 + 2;
  }
  else
  {
    v8 = 10i64;
  }
  if ( !a5 )
    v5 = L"NULL";
  if ( a4 )
  {
    do
      ++v6;
    while ( a4[v6] );
    v9 = v6 + 1;
  }
  else
  {
    v9 = 5i64;
  }
  if ( !a4 )
    a4 = "NULL";
  return EtwTraceMessage(a1, 43i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids, 30i64, a4, v9, v5, v8, va);
}
// 180083C60: using guessed type wchar_t aNull_0[5];

//----- (000000018005A36C) ----------------------------------------------------
CTls13ClientContext *__fastcall CTls13ClientContext::CTls13ClientContext(
        CTls13ClientContext *this,
        struct CTlsRecord *a2,
        struct CSessionCacheClientItem *a3,
        int a4,
        unsigned __int16 *a5)
{
  __int64 v7; // r8
  _QWORD *v8; // rcx
  CTls13ClientContext *result; // rax

  CSsl3TlsClientContext::CSsl3TlsClientContext(this, a3, a4, a5);
  CTls13Context::CTls13Context((CTls13ClientContext *)((char *)this + 1368), a2);
  v7 = *((_QWORD *)this + 197);
  *v8 = &CTls13ClientContext::`vftable'{for `CTls13Context'};
  *(_QWORD *)this = &CTls13ClientContext::`vftable'{for `CSsl3TlsClientContext'};
  CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::CTls13Handshake<CTls13ClientContext,CTls13ExtClient>(
    (__int64)this + 1656,
    (__int64)this,
    v7);
  *((_QWORD *)this + 207) = &CTls13ClientHandshake::`vftable';
  *((_QWORD *)this + 227) = 0i64;
  *((_WORD *)this + 912) = 0;
  *((_QWORD *)this + 229) = 0i64;
  *((_QWORD *)this + 230) = 0i64;
  *((_WORD *)this + 924) = 0;
  *((_DWORD *)this + 463) = *((_DWORD *)this + 16);
  result = this;
  *((_BYTE *)this + 1850) = 1;
  return result;
}
// 18005A3B6: variable 'v8' is possibly undefined
// 18007D550: using guessed type void *CTls13ClientHandshake::`vftable';
// 18007FAE0: using guessed type void *CTls13ClientContext::`vftable'{for `CSsl3TlsClientContext'};
// 18007FCF0: using guessed type void *CTls13ClientContext::`vftable'{for `CTls13Context'};

//----- (000000018005A424) ----------------------------------------------------
CTls13Context *__fastcall CTls13Context::CTls13Context(CTls13Context *this, struct CTlsRecord *a2)
{
  CTls13Context *result; // rax

  *((_QWORD *)this + 3) = a2;
  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)this = &CTls13Context::`vftable';
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 2) = &CTls13ChangeCipherSpec::`vftable';
  *((_QWORD *)this + 5) = 0i64;
  *((_QWORD *)this + 6) = 0i64;
  *((_QWORD *)this + 7) = 0i64;
  *((_QWORD *)this + 8) = 0i64;
  *((_QWORD *)this + 9) = 0i64;
  *((_QWORD *)this + 10) = 0i64;
  *((_QWORD *)this + 11) = 0i64;
  *((_QWORD *)this + 12) = 0i64;
  *((_QWORD *)this + 13) = 0i64;
  *((_QWORD *)this + 14) = 0i64;
  result = this;
  *((_BYTE *)this + 120) = 0;
  *((_QWORD *)this + 16) = 0i64;
  *((_BYTE *)this + 136) = 0;
  *((_QWORD *)this + 18) = 0i64;
  *(_OWORD *)((char *)this + 152) = 0i64;
  *(_OWORD *)((char *)this + 168) = 0i64;
  *(_OWORD *)((char *)this + 184) = 0i64;
  *((_WORD *)this + 100) = 256;
  *((_QWORD *)this + 26) = a2;
  *((_BYTE *)this + 216) = 0;
  *((_QWORD *)this + 28) = 0i64;
  *((_WORD *)this + 116) = 0;
  *((_QWORD *)this + 30) = 0i64;
  *((_BYTE *)this + 248) = 0;
  *(_OWORD *)((char *)this + 249) = 0i64;
  *(_OWORD *)((char *)this + 265) = 0i64;
  *(_WORD *)((char *)this + 281) = 0;
  return result;
}
// 18007CB58: using guessed type void *CTls13ChangeCipherSpec::`vftable';
// 18007CB60: using guessed type void *CTls13Context::`vftable';

//----- (000000018005A4F8) ----------------------------------------------------
void __fastcall CTls13ClientContext::~CTls13ClientContext(CTls13ClientContext *this)
{
  CTls13Context *v1; // rbx

  v1 = (CTls13ClientContext *)((char *)this + 1368);
  *(_QWORD *)this = &CTls13ClientContext::`vftable'{for `CSsl3TlsClientContext'};
  *((_QWORD *)this + 171) = &CTls13ClientContext::`vftable'{for `CTls13Context'};
  CTls13Context::CleanupTls13SharedConnectedState((CTls13ClientContext *)((char *)this + 1368));
  CSsl3TlsClientContext::CleanupConnectedState(this);
  *((_QWORD *)this + 207) = &CTls13ClientHandshake::`vftable';
  CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::~CTls13Handshake<CTls13ClientContext,CTls13ExtClient>((_QWORD *)this + 207);
  CTls13Context::~CTls13Context(v1);
  CSsl3TlsClientContext::~CSsl3TlsClientContext((struct CSessionCacheItem **)this);
}
// 18007D550: using guessed type void *CTls13ClientHandshake::`vftable';
// 18007FAE0: using guessed type void *CTls13ClientContext::`vftable'{for `CSsl3TlsClientContext'};
// 18007FCF0: using guessed type void *CTls13ClientContext::`vftable'{for `CTls13Context'};

//----- (000000018005A570) ----------------------------------------------------
CSsl3TlsContext *__fastcall CSsl3TlsContext::`scalar deleting destructor'(CSsl3TlsContext *this)
{
  bool v1; // zf
  void *v3; // rdx
  void *v4; // rdi
  DTlsMsgMgr *v5; // rcx
  _QWORD *v6; // rdi
  void *v7; // rdx
  void *v8; // rdx
  void *v9; // rdx
  void *v10; // rdx
  void *v11; // rdx
  __int64 v12; // rdx
  void **v13; // rcx
  void *v14; // rdx
  void *v15; // rdx
  void *v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // rcx
  __int64 v21; // rcx
  __int64 v22; // rdi
  __int64 v23; // rcx
  CSslServerKey *v24; // rcx
  int v25; // ecx
  __int64 v26; // rax
  struct CCredentialGroup *v27; // rdx
  __int64 v28; // rcx
  volatile signed __int32 *v29; // rcx

  v1 = *((_BYTE *)this + 233) == 0;
  *(_QWORD *)this = &CSsl3TlsContext::`vftable';
  if ( v1 )
  {
    v6 = (_QWORD *)*((_QWORD *)this + 58);
    if ( v6 )
    {
      v7 = (void *)*((_QWORD *)this + 58);
      if ( *v6 && v6[3] )
      {
        (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*v6 + 16i64))(*v6, v6[3]);
        v6[3] = 0i64;
        *((_DWORD *)v6 + 4) = 0;
        v7 = (void *)*((_QWORD *)this + 58);
      }
      CSslContext::FreeMemory(this, v7);
    }
  }
  else
  {
    v3 = (void *)*((_QWORD *)this + 71);
    if ( v3 )
      CSslContext::FreeMemory(this, v3);
    v4 = (void *)*((_QWORD *)this + 73);
    if ( v4 )
    {
      DTlsHandshakeQueue::~DTlsHandshakeQueue(*((DTlsHandshakeQueue **)this + 73));
      operator delete(v4);
      *((_QWORD *)this + 73) = 0i64;
    }
    v5 = (DTlsMsgMgr *)*((_QWORD *)this + 72);
    if ( v5 )
    {
      DTlsMsgMgr::`scalar deleting destructor'(v5);
      *((_QWORD *)this + 72) = 0i64;
    }
    CSsl3TlsContext::FreeSavedWriteCipherState(this);
  }
  v8 = (void *)*((_QWORD *)this + 98);
  if ( v8 )
    CSslContext::FreeMemory(this, v8);
  v9 = (void *)*((_QWORD *)this + 99);
  if ( v9 )
    CSslContext::FreeMemory(this, v9);
  v10 = (void *)*((_QWORD *)this + 100);
  if ( v10 )
    CSslContext::FreeMemory(this, v10);
  CSsl3TlsContext::FreeSelectedSrtpParameters(this);
  v11 = (void *)*((_QWORD *)this + 102);
  if ( v11 )
    CSslContext::FreeMemory(this, v11);
  CSsl3TlsContext::FreeSelectedTBParameters(this);
  v12 = *((_QWORD *)this + 104);
  if ( v12 )
  {
    if ( *(_QWORD *)(v12 + 8) )
    {
      (*(void (__fastcall **)(CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 16i64))(this, *(_QWORD *)(v12 + 8));
      v12 = *((_QWORD *)this + 104);
    }
    (*(void (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 16i64))(this, v12);
    *((_QWORD *)this + 104) = 0i64;
  }
  v13 = (void **)*((_QWORD *)this + 105);
  if ( v13 )
  {
    if ( v13[1] )
    {
      SPExternalFree(v13[1]);
      v13 = (void **)*((_QWORD *)this + 105);
    }
    if ( v13[3] )
    {
      SPExternalFree(v13[3]);
      v13 = (void **)*((_QWORD *)this + 105);
    }
    SPExternalFree(v13);
    *((_QWORD *)this + 105) = 0i64;
  }
  v14 = (void *)*((_QWORD *)this + 106);
  if ( v14 )
    CSslContext::FreeMemory(this, v14);
  v15 = (void *)*((_QWORD *)this + 107);
  if ( v15 )
    CSslContext::FreeMemory(this, v15);
  v16 = (void *)*((_QWORD *)this + 108);
  if ( v16 )
    CSslContext::FreeMemory(this, v16);
  CSsl3TlsContext::FreeHandshakeHash(this);
  v17 = *((_QWORD *)this + 18);
  *(_QWORD *)this = &CSslContext::`vftable';
  if ( v17 )
    SslFreeObject(v17, 0i64);
  v18 = *((_QWORD *)this + 19);
  if ( v18 )
    SslFreeObject(v18, 0i64);
  v19 = *((_QWORD *)this + 20);
  if ( v19 )
    SslFreeObject(v19, 0i64);
  v20 = *((_QWORD *)this + 21);
  if ( v20 )
    SslFreeObject(v20, 0i64);
  v21 = *((_QWORD *)this + 14);
  if ( v21 )
    SslFreeObject(v21, 0i64);
  v22 = *((_QWORD *)this + 1);
  if ( v22 )
  {
    v23 = *(_QWORD *)(v22 + 848);
    if ( v23 )
      CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v23 + 16));
    CMasterCipherInfo::Dereference(*(CMasterCipherInfo **)(v22 + 856));
  }
  v24 = (CSslServerKey *)*((_QWORD *)this + 3);
  if ( v24 )
    CSslServerKey::Dereference(v24);
  v25 = *((_DWORD *)this + 17);
  if ( (unsigned int)(v25 - 3) > 1 && v25 != 79 && (*((_DWORD *)this + 34) & 0x40000) == 0 )
  {
    v26 = *((_QWORD *)this + 11);
    if ( v26 )
      *(_BYTE *)(v26 + 236) = 0;
  }
  v27 = (struct CCredentialGroup *)*((_QWORD *)this + 10);
  if ( v27 )
    CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, v27);
  v28 = *((_QWORD *)this + 11);
  if ( v28 )
    CSessionCacheTable::DereferenceCacheItemInternal(
      *(CSessionCacheTable **)(v28 + 224),
      *((struct CSessionCacheItem **)this + 11),
      1,
      0);
  v29 = (volatile signed __int32 *)*((_QWORD *)this + 15);
  if ( v29 && _InterlockedExchangeAdd(v29 + 5, 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(volatile signed __int32 *, __int64))(*(_QWORD *)v29 + 8i64))(v29, 1i64);
  *(_QWORD *)this = &ISslSerialize::`vftable';
  return this;
}
// 18007CBA8: using guessed type void *CSsl3TlsContext::`vftable';
// 18007CDB8: using guessed type void *CSslContext::`vftable';
// 18007CFB8: using guessed type void *ISslSerialize::`vftable';
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018005A900) ----------------------------------------------------
CSslContext *__fastcall CSslContext::`vector deleting destructor'(CSslContext *this)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rdi
  __int64 v8; // rcx
  CSslServerKey *v9; // rcx
  int v10; // ecx
  __int64 v11; // rax
  struct CCredentialGroup *v12; // rdx
  __int64 v13; // rcx
  volatile signed __int32 *v14; // rcx

  *(_QWORD *)this = &CSslContext::`vftable';
  v2 = *((_QWORD *)this + 18);
  if ( v2 )
    SslFreeObject(v2, 0i64);
  v3 = *((_QWORD *)this + 19);
  if ( v3 )
    SslFreeObject(v3, 0i64);
  v4 = *((_QWORD *)this + 20);
  if ( v4 )
    SslFreeObject(v4, 0i64);
  v5 = *((_QWORD *)this + 21);
  if ( v5 )
    SslFreeObject(v5, 0i64);
  v6 = *((_QWORD *)this + 14);
  if ( v6 )
    SslFreeObject(v6, 0i64);
  v7 = *((_QWORD *)this + 1);
  if ( v7 )
  {
    v8 = *(_QWORD *)(v7 + 848);
    if ( v8 )
      CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v8 + 16));
    CMasterCipherInfo::Dereference(*(CMasterCipherInfo **)(v7 + 856));
  }
  v9 = (CSslServerKey *)*((_QWORD *)this + 3);
  if ( v9 )
    CSslServerKey::Dereference(v9);
  v10 = *((_DWORD *)this + 17);
  if ( (unsigned int)(v10 - 3) > 1 && v10 != 79 && (*((_DWORD *)this + 34) & 0x40000) == 0 )
  {
    v11 = *((_QWORD *)this + 11);
    if ( v11 )
      *(_BYTE *)(v11 + 236) = 0;
  }
  v12 = (struct CCredentialGroup *)*((_QWORD *)this + 10);
  if ( v12 )
    CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, v12);
  v13 = *((_QWORD *)this + 11);
  if ( v13 )
    CSessionCacheTable::DereferenceCacheItemInternal(
      *(CSessionCacheTable **)(v13 + 224),
      *((struct CSessionCacheItem **)this + 11),
      1,
      0);
  v14 = (volatile signed __int32 *)*((_QWORD *)this + 15);
  if ( v14 && _InterlockedExchangeAdd(v14 + 5, 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(volatile signed __int32 *, __int64))(*(_QWORD *)v14 + 8i64))(v14, 1i64);
  *(_QWORD *)this = &ISslSerialize::`vftable';
  return this;
}
// 18007CDB8: using guessed type void *CSslContext::`vftable';
// 18007CFB8: using guessed type void *ISslSerialize::`vftable';
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018005AA90) ----------------------------------------------------
CSslScratchAllocator *__fastcall CSslScratchAllocator::`vector deleting destructor'(
        CSslScratchAllocator *this,
        char a2)
{
  *(_QWORD *)this = &IAllocate::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 18007C298: using guessed type void *IAllocate::`vftable';

//----- (000000018005AAC0) ----------------------------------------------------
CTls13ChangeCipherSpec *__fastcall CTls13ChangeCipherSpec::`vector deleting destructor'(
        CTls13ChangeCipherSpec *this,
        char a2)
{
  *(_QWORD *)this = &CTls13ChangeCipherSpec::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 18007CB58: using guessed type void *CTls13ChangeCipherSpec::`vftable';

//----- (000000018005AAF0) ----------------------------------------------------
CTls13ClientContext *__fastcall CTls13ClientContext::`vector deleting destructor'(CTls13ClientContext *this)
{
  CTls13ClientContext::~CTls13ClientContext(this);
  return this;
}

//----- (000000018005AB10) ----------------------------------------------------
CTls13ClientHandshake *__fastcall CTls13ClientHandshake::`vector deleting destructor'(
        CTls13ClientHandshake *this,
        char a2)
{
  *(_QWORD *)this = &CTls13ClientHandshake::`vftable';
  CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::~CTls13Handshake<CTls13ClientContext,CTls13ExtClient>(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 18007D550: using guessed type void *CTls13ClientHandshake::`vftable';

//----- (000000018005AB60) ----------------------------------------------------
CTls13Context *__fastcall CTls13Context::`vector deleting destructor'(CTls13Context *this, char a2)
{
  CTls13Context::~CTls13Context(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (000000018005ABA0) ----------------------------------------------------
CTls13ServerHandshake *__fastcall CTls13ServerHandshake::`scalar deleting destructor'(
        CTls13ServerHandshake *this,
        char a2)
{
  CTls13ServerHandshake::~CTls13ServerHandshake(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (000000018005ABD8) ----------------------------------------------------
DTlsMsgMgr *__fastcall DTlsMsgMgr::`scalar deleting destructor'(DTlsMsgMgr *this)
{
  DTlsMsgMgr::~DTlsMsgMgr(this);
  operator delete(this);
  return this;
}

//----- (000000018005AC00) ----------------------------------------------------
__int64 __fastcall CSslScratchAllocator::Allocate(CSslScratchAllocator *this, __int64 a2)
{
  return (*(__int64 (__fastcall **)(CSslScratchAllocator *, __int64, _QWORD))(*(_QWORD *)this + 48i64))(this, a2, 0i64);
}

//----- (000000018005AC30) ----------------------------------------------------
void __fastcall CTls13ClientContext::CleanupLsaModeKeys(CTls13ClientContext *this)
{
  __int64 v2; // rcx
  __int64 v3; // rcx

  if ( *((_BYTE *)this + 1569) )
    CTls13Context::FreeApplicationTrafficKeys((CTls13ClientContext *)((char *)this + 1368));
  v2 = *((_QWORD *)this + 19);
  if ( v2 )
  {
    SslFreeObject(v2, 0i64);
    *((_QWORD *)this + 19) = 0i64;
  }
  v3 = *((_QWORD *)this + 18);
  if ( v3 )
  {
    SslFreeObject(v3, 0i64);
    *((_QWORD *)this + 18) = 0i64;
  }
  if ( *((_BYTE *)this + 233) )
  {
    if ( *((_BYTE *)this + 264) )
      *((_QWORD *)this + 31) = 0i64;
  }
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018005ACC0) ----------------------------------------------------
void __fastcall CTls13ServerContext::CleanupLsaModeKeys(CTls13ServerContext *this)
{
  __int64 v2; // rcx
  __int64 v3; // rcx

  if ( *((_BYTE *)this + 1201) )
    CTls13Context::FreeApplicationTrafficKeys((CTls13ServerContext *)((char *)this + 1000));
  v2 = *((_QWORD *)this + 19);
  if ( v2 )
  {
    SslFreeObject(v2, 0i64);
    *((_QWORD *)this + 19) = 0i64;
  }
  v3 = *((_QWORD *)this + 18);
  if ( v3 )
  {
    SslFreeObject(v3, 0i64);
    *((_QWORD *)this + 18) = 0i64;
  }
  if ( *((_BYTE *)this + 233) )
  {
    if ( *((_BYTE *)this + 264) )
      *((_QWORD *)this + 31) = 0i64;
  }
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018005AD50) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::ClearCacheItem(CSsl3TlsClientContext *this)
{
  CSessionCacheTable **v2; // rcx

  v2 = (CSessionCacheTable **)*((_QWORD *)this + 165);
  if ( v2 )
  {
    CSessionCacheTable::DereferenceCacheItemInternal(v2[28], (struct CSessionCacheItem *)v2, 1, 0);
    *((_QWORD *)this + 165) = 0i64;
  }
}

//----- (000000018005AD90) ----------------------------------------------------
void __fastcall CSslContextManager::DeleteContextScratch(__int64 a1, __int64 a2, char a3, int a4)
{
  unsigned int v7; // ecx
  unsigned int v8; // eax
  bool v9; // zf
  void *v10; // rax
  void *v11; // rax
  __int64 v12; // rdi
  void (__fastcall *v13)(__int64, __int64); // rbx
  __int64 v14; // rax
  void *v15; // rax

  if ( a2 )
  {
    if ( a4 != 4 )
      goto LABEL_15;
    v7 = (*(unsigned __int16 (__fastcall **)(__int64))(*(_QWORD *)a2 + 64i64))(a2);
    v8 = *(_DWORD *)(a1 + 24);
    if ( v8 <= v7 )
      v8 = v7;
    *(_DWORD *)(a1 + 24) = v8;
    if ( _InterlockedIncrement((volatile signed __int32 *)(a1 + 20)) != 100 || !*(_QWORD *)(a1 + 56) )
      goto LABEL_15;
    v9 = *(_DWORD *)(a1 + 64) == 0;
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 24);
    if ( v9 )
    {
      v11 = operator new(0x50ui64);
      if ( !v11 )
      {
LABEL_15:
        if ( a3 )
        {
          v15 = (void *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 40i64))(a2);
          SPExternalFree(v15);
        }
        else
        {
          v12 = *(_QWORD *)(a1 + 56);
          v13 = *(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v12 + 32i64);
          v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 40i64))(a2);
          v13(v12, v14);
        }
        return;
      }
      v10 = (void *)CSslLookaside::CSslLookaside((__int64)v11, *(_DWORD *)(a1 + 32), 1);
    }
    else
    {
      v10 = operator new(0x80ui64);
      if ( v10 )
        v10 = (void *)CSslLookasidePreallocate::CSslLookasidePreallocate(
                        (__int64)v10,
                        *(_DWORD *)(a1 + 32),
                        *(_DWORD *)(a1 + 64));
    }
    if ( v10 )
      *(_QWORD *)(a1 + 56) = v10;
    goto LABEL_15;
  }
}

//----- (000000018005AECC) ----------------------------------------------------
void __fastcall CSslContextManager::DeleteFullSslContext(CSslContextManager *this, struct CSslParentContext *a2)
{
  __int64 v4; // rcx
  int v5; // esi
  int v6; // r14d
  int v7; // ebx

  v4 = *((_QWORD *)a2 + 1);
  v5 = *(_DWORD *)(v4 + 64);
  v6 = *(_DWORD *)(v4 + 68);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x12u, (__int64)&WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids, a2);
    v4 = *((_QWORD *)a2 + 1);
  }
  if ( v4 )
  {
    v7 = *(_DWORD *)(v4 + 64);
    (**(void (__fastcall ***)(__int64, _QWORD))v4)(v4, 0i64);
    if ( (v7 & 0x800A2AAA) != 0 )
      SPExternalFree(*((void **)a2 + 1));
    *((_QWORD *)a2 + 1) = 0i64;
  }
  if ( (v5 & 0x51550) != 0 )
  {
    CSslContextManager::DeleteContextScratch((__int64)this, *((_QWORD *)a2 + 3), *((_BYTE *)a2 + 32), v6);
    *((_QWORD *)a2 + 3) = 0i64;
    (*(void (__fastcall **)(_QWORD, struct CSslParentContext *))(**((_QWORD **)this + 6) + 32i64))(
      *((_QWORD *)this + 6),
      a2);
  }
  else
  {
    SPExternalFree(a2);
  }
}

//----- (000000018005AFCC) ----------------------------------------------------
void __fastcall CTls13Context::FreeApplicationTrafficKeys(CTls13Context *this)
{
  __int64 v2; // rcx
  __int64 v3; // rcx

  v2 = *((_QWORD *)this + 10);
  if ( v2 )
  {
    SslFreeObject(v2, 0i64);
    *((_QWORD *)this + 10) = 0i64;
  }
  v3 = *((_QWORD *)this + 11);
  if ( v3 )
  {
    SslFreeObject(v3, 0i64);
    *((_QWORD *)this + 11) = 0i64;
  }
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018005B01C) ----------------------------------------------------
void __fastcall CTls13Context::GetApplicationTrafficSecrets(
        CTls13Context *this,
        unsigned __int64 *a2,
        unsigned __int64 *a3)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // r9

  v3 = 0i64;
  if ( a2 )
  {
    if ( *((_BYTE *)this + 201) )
      v4 = *((_QWORD *)this + 10);
    else
      v4 = 0i64;
    *a2 = v4;
  }
  if ( a3 )
  {
    if ( *((_BYTE *)this + 201) )
      v3 = *((_QWORD *)this + 11);
    *a3 = v3;
  }
}

//----- (000000018005B060) ----------------------------------------------------
unsigned __int64 __fastcall CTls13ClientContext::GetHandshakeHash(
        CTls13ClientContext *this,
        enum _eTlsHashAlgorithm a2)
{
  if ( *((_BYTE *)this + 1601) )
    return *((_QWORD *)this + 201);
  else
    return *((_QWORD *)this + 74);
}

//----- (000000018005B090) ----------------------------------------------------
unsigned __int64 __fastcall CTls13ServerContext::GetHandshakeHash(
        CTls13ServerContext *this,
        enum _eTlsHashAlgorithm a2)
{
  if ( *((_BYTE *)this + 1233) )
    return *((_QWORD *)this + 155);
  else
    return *((_QWORD *)this + 74);
}

//----- (000000018005B0C0) ----------------------------------------------------
unsigned __int16 __fastcall CSslScratchAllocator::GetLengthNeeded(CSslScratchAllocator *this)
{
  unsigned __int16 result; // ax

  result = *((_WORD *)this + 10);
  if ( result <= *((_WORD *)this + 9) )
    return *((_WORD *)this + 9);
  return result;
}

//----- (000000018005B0E0) ----------------------------------------------------
void __fastcall CTls13ClientContext::GetReadWriteApplicationTrafficSecrets(
        CTls13ClientContext *this,
        unsigned __int64 *a2,
        unsigned __int64 *a3)
{
  CTls13Context::GetApplicationTrafficSecrets((CTls13ClientContext *)((char *)this + 1368), a3, a2);
}

//----- (000000018005B100) ----------------------------------------------------
void __fastcall CTls13ServerContext::GetReadWriteApplicationTrafficSecrets(
        CTls13ServerContext *this,
        unsigned __int64 *a2,
        unsigned __int64 *a3)
{
  CTls13Context::GetApplicationTrafficSecrets((CTls13ServerContext *)((char *)this + 1000), a2, a3);
}

//----- (000000018005B120) ----------------------------------------------------
unsigned int __fastcall CTls13ClientContext::ImportApplicationTrafficSecret(
        CTls13ClientContext *this,
        unsigned __int64 a2,
        char a3,
        unsigned __int8 *a4,
        unsigned int a5)
{
  return CTls13Context::ImportApplicationTrafficSecret(
           (CTls13ClientContext *)((char *)this + 1448),
           a2,
           (unsigned __int64 *)((char *)this + (a3 != 0 ? 8 : 0) + 1448),
           a4,
           a5);
}

//----- (000000018005B150) ----------------------------------------------------
unsigned int __fastcall CTls13ServerContext::ImportApplicationTrafficSecret(
        CTls13ServerContext *this,
        unsigned __int64 a2,
        char a3,
        unsigned __int8 *a4,
        unsigned int a5)
{
  return CTls13Context::ImportApplicationTrafficSecret(
           (CTls13ServerContext *)((char *)this + 1088),
           a2,
           (unsigned __int64 *)((char *)this + (-(__int64)(a3 != 0) & 0xFFFFFFFFFFFFFFF8ui64) + 1088),
           a4,
           a5);
}

//----- (000000018005B180) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::ParseCcsRecord(
        CTls13ClientContext *this,
        unsigned __int8 *const a2,
        unsigned int a3,
        int a4)
{
  return CTls13Context::ParseCcsRecord((__int64)this + 1368, (__int64)a2, a3, a4, *((_DWORD *)this + 17));
}

//----- (000000018005B1B0) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::ParseCcsRecord(
        CTls13ServerContext *this,
        unsigned __int8 *const a2,
        unsigned int a3,
        int a4)
{
  return CTls13Context::ParseCcsRecord((__int64)this + 1000, (__int64)a2, a3, a4, *((_DWORD *)this + 17));
}

//----- (000000018005B1E0) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::PreparseMessage(CTls13ClientContext *this, struct SPBuffer *a2)
{
  return CTls13Context::PreparseMessage(this, a2, this, 0);
}

//----- (000000018005B200) ----------------------------------------------------
unsigned int __fastcall CTls13ClientContext::ReturnGenericExtensions(CTls13ClientContext *this)
{
  return CTls13Context::ReturnGenericExtensions((CTls13ClientContext *)((char *)this + 1368));
}

//----- (000000018005B220) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::ReturnGenericExtensions(CTls13ServerContext *this)
{
  return CTls13Context::ReturnGenericExtensions((CTls13ServerContext *)((char *)this + 1000));
}

//----- (000000018005B240) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::SetActiveCred(CSsl3TlsClientContext *this, struct CSslCredential *a2)
{
  CSsl3TlsClientContext::SetActiveClientCred(this, a2, 0);
}

//----- (000000018005B250) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::SetGenericExtensionBuffers(
        CTls13ClientContext *this,
        struct _SecBufferDesc *const a2,
        struct _SecBuffer *const a3)
{
  return CTls13Context::SetGenericExtensionBuffers((CTls13ClientContext *)((char *)this + 1368), a2, a3);
}

//----- (000000018005B270) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::SetSrtpMasterKeyIdentifier(
        CSsl3TlsServerContext *this,
        struct _SEC_SRTP_MASTER_KEY_IDENTIFIER *const a2)
{
  *((_BYTE *)this + 988) = a2 != 0i64;
  return 0i64;
}

//----- (000000018005B290) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::SetTrafficSecretsBuffers(
        CTls13ClientContext *this,
        struct _SecBufferDesc *const a2,
        char a3,
        char a4)
{
  return CTls13Context::SetTrafficSecretsBuffers((CTls13ClientContext *)((char *)this + 1368), a2, a3, a4);
}

//----- (000000018005B2A4) ----------------------------------------------------
__int64 __fastcall WPP_SF_Ss(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4, const char *a5)
{
  const char *v5; // r8
  __int64 v6; // rdx
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rdx

  v5 = a5;
  v6 = -1i64;
  if ( a5 )
  {
    v7 = -1i64;
    do
      ++v7;
    while ( a5[v7] );
    v8 = v7 + 1;
  }
  else
  {
    v8 = 5i64;
  }
  if ( !a5 )
    v5 = "NULL";
  if ( a4 )
  {
    do
      ++v6;
    while ( a4[v6] );
    v9 = 2 * v6 + 2;
  }
  else
  {
    v9 = 10i64;
  }
  if ( !a4 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43i64, &WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids, 10i64, a4, v9, v5, v8, 0i64);
}
// 180083C60: using guessed type wchar_t aNull_0[5];

//----- (000000018005B354) ----------------------------------------------------
ULONG __fastcall CSslContext::ImpersonateNonLsNs(CSslContext *this, int *a2)
{
  __int64 v2; // r8
  __int64 v3; // rax

  v2 = *((_QWORD *)this + 10);
  *a2 = 0;
  v3 = *(_QWORD *)(v2 + 740);
  if ( v3 == 999 || v3 == 996 )
    return 0;
  else
    return SslImpersonateClient(*(_QWORD *)(v2 + 752), a2);
}

//----- (000000018005B3A0) ----------------------------------------------------
signed int __fastcall CSslContext::QueryContextAttributesA(CSslContext *this, int a2, void *a3)
{
  __int64 v5; // rax

  switch ( a2 )
  {
    case 6:
      return CSslContext::QueryAuthority(this, a3);
    case 82:
      return CSslContext::QueryLocalCred(this, a3);
    case 84:
      v5 = (*(__int64 (__fastcall **)(CSslContext *))(*(_QWORD *)this + 248i64))(this);
      if ( v5 )
        return SslTransferCertChainToClientProcess((PCCERT_CONTEXT *)a3, *(const struct _CERT_CONTEXT **)(v5 + 32));
      else
        return -2146893042;
    case 94:
      return CSslContext::QueryAppData(this, a3);
    default:
      return 120;
  }
}

//----- (000000018005B440) ----------------------------------------------------
__int64 __fastcall CSslContext::SetContextAttributesA(CSslContext *this, int a2, void *a3, unsigned int a4)
{
  if ( a2 == 94 )
    return CSslContext::SetApplicationData(this, a3, a4);
  if ( a2 == 104 )
    return CSslContext::SetUiInformation(this, a3, a4);
  return 120i64;
}

//----- (000000018005B470) ----------------------------------------------------
void __fastcall CSslContext::SetErrorAndFatalAlert(__int64 a1, int a2, int a3, unsigned __int8 a4)
{
  int v5; // ebp
  __int64 v8; // rax
  __int64 v9; // rcx
  __int64 v10; // rdx
  const WCHAR *v11; // rdi
  unsigned int v12; // r14d
  __int64 v13; // r8
  __int64 v14; // rcx
  int v15; // edi
  int v16; // r14d
  __int64 v17; // r15
  __int64 v18; // rax
  __int64 v19; // rcx
  CSchannelTelemetryContext *v20; // rax
  struct _UNICODE_STRING v21; // [rsp+40h] [rbp-738h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+50h] [rbp-728h] BYREF
  char v23[8]; // [rsp+60h] [rbp-718h] BYREF
  int v24; // [rsp+68h] [rbp-710h]
  int v25; // [rsp+6Ch] [rbp-70Ch]

  v5 = a4;
  v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 320i64))(a1);
  v9 = *(_QWORD *)(a1 + 128);
  if ( !*(_WORD *)(v9 + 34) )
  {
    *(_WORD *)(v9 + 34) = a2;
    *(_DWORD *)(v9 + 36) = a3;
  }
  v10 = *(_QWORD *)(a1 + 80);
  v11 = &Class;
  *(_BYTE *)(a1 + 96) = 2;
  *(_BYTE *)(a1 + 97) = v5;
  if ( v8 )
    v11 = (const WCHAR *)v8;
  v12 = *(_DWORD *)(v10 + 212);
  if ( (g_dwEventLogging & 4) != 0 )
  {
    RtlInitUnicodeString(&DestinationString, (PCWSTR)(v10 + 216));
    RtlInitUnicodeString(&v21, v11);
    SchEventWrite(&SSLEVENT_GENERATE_FATAL_ALERT, L"duddu", v12, &DestinationString, v5, a2, &v21);
  }
  memset_0(v23, 0, 0x6E8ui64);
  v14 = *(_QWORD *)(a1 + 8);
  if ( v14 )
  {
    v15 = *(_DWORD *)(v14 + 28);
    v24 = v15;
  }
  else
  {
    v15 = 0;
    v24 = 0;
  }
  v16 = *(unsigned __int16 *)(a1 + 34);
  v17 = *(_QWORD *)(a1 + 136);
  v25 = *(_DWORD *)(a1 + 16);
  if ( v14 )
  {
    v18 = *(_QWORD *)(a1 + 88);
    if ( v18 )
      CSchannelTelemetryContext::LogKeyExchange(
        *(CSchannelTelemetryContext **)(a1 + 120),
        *(_DWORD *)(v14 + 32),
        *(_DWORD *)(v18 + 8));
  }
  v19 = *(_QWORD *)(a1 + 120);
  v20 = (CSchannelTelemetryContext *)v19;
  if ( v19 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
  {
    *(_DWORD *)(v19 + 36) = v25;
    *(_BYTE *)(v19 + 108) = v5;
    *(_DWORD *)(v19 + 104) = a3;
    *(_DWORD *)(v19 + 112) = a2;
    *(_DWORD *)(v19 + 32) = v15;
    *(_DWORD *)(v19 + 40) = v16;
    *(_QWORD *)(v19 + 128) = v17;
    CSchannelTelemetryContext::WriteEvent((CSchannelTelemetryContext *)v19, 1, v13);
    v20 = *(CSchannelTelemetryContext **)(a1 + 120);
  }
  CSchannelTelemetryContext::LogDebugTraceHandshakeInfo(v20, L"Fatal Error");
}
// 18005B5EA: variable 'v13' is possibly undefined
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 18005B470: using guessed type char var_718[8];

//----- (000000018005B628) ----------------------------------------------------
unsigned __int16 __fastcall CSslContext::computeMaxPayload(CSslContext *this, int a2)
{
  unsigned __int16 result; // ax
  int v3; // r9d
  int v4; // r8d
  int v5; // edx

  result = 0;
  if ( (*((_BYTE *)this + 32) & 2) != 0 )
    v3 = *((_DWORD *)this + 12);
  else
    v3 = 0;
  if ( (*((_BYTE *)this + 32) & 4) != 0 )
    v4 = *((_DWORD *)this + 11);
  else
    v4 = 0;
  v5 = a2 - *((_DWORD *)this + 13) - v4 - v3 - *((_DWORD *)this + 15);
  if ( v5 >= 0 )
    return v5;
  return result;
}

//----- (000000018005B660) ----------------------------------------------------
unsigned int __fastcall CSsl3TlsContext::ComputeRsaServerExchangeHashes(
        UCHAR *this,
        unsigned __int8 *a2,
        ULONG a3,
        unsigned __int8 *a4)
{
  unsigned int result; // eax

  result = GenerateHash(g_hMD5Provider, this, a2, a3, a4, 0x10u);
  if ( !result )
    return GenerateHash(g_hSHAProvider, this, a2, a3, a4 + 16, 0x14u);
  return result;
}

//----- (000000018005B6E8) ----------------------------------------------------
unsigned __int64 __fastcall CSsl3TlsContext::FindTlsClientAuthHandshakeHash(
        CSsl3TlsContext *this,
        enum _eTlsHashAlgorithm a2)
{
  unsigned int v2; // r9d
  __int64 v3; // rax
  _DWORD *i; // r8

  v2 = *((_DWORD *)this + 137);
  v3 = 0i64;
  if ( !v2 )
    return 0i64;
  for ( i = (_DWORD *)((char *)this + 720); *i != a2; ++i )
  {
    v3 = (unsigned int)(v3 + 1);
    if ( (unsigned int)v3 >= v2 )
      return 0i64;
  }
  return *((_QWORD *)this + v3 + 74);
}

//----- (000000018005B730) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::GenerateTlsAlertMessage(
        CSsl3TlsContext *this,
        struct SPBuffer *a2,
        char a3,
        char a4)
{
  int v8; // r10d
  __int16 v9; // r11
  unsigned int v10; // ecx
  unsigned int v11; // r10d
  __int64 v12; // rsi
  unsigned int v13; // edi
  __int64 result; // rax
  __int64 v15; // rcx

  v8 = 2;
  v9 = *((_WORD *)this + 16) & 4;
  if ( v9 )
  {
    v10 = *((_DWORD *)this + 13);
    v11 = *((_DWORD *)this + 12) + 2;
    if ( v10 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v10 -= v11 % v10;
      v11 += v10;
    }
    v8 = *((_DWORD *)this + 11) + v11;
  }
  v12 = *((unsigned int *)this + 15);
  if ( v9 )
    v13 = *((_DWORD *)this + 11);
  else
    v13 = 0;
  if ( (unsigned __int8)(a3 - 1) > 1u )
    return 87i64;
  result = CSsl3TlsContext::AllocateOutputBuffer(this, a2, (int)v12 + v8);
  if ( !(_DWORD)result )
  {
    v15 = v12 + *((_QWORD *)a2 + 1);
    *(_BYTE *)(v15 + v13) = a3;
    *(_BYTE *)(v15 + v13 + 1) = a4;
    return CSsl3TlsContext::WrapMessage((__int64)this, (__int64)a2, 21, 2u);
  }
  return result;
}

//----- (000000018005B81C) ----------------------------------------------------
__int64 WPP_SF_Di(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, ...)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+80h] [rbp+28h] BYREF

  va_start(va, a4);
  v5 = a4;
  return EtwTraceMessage(a1, 43i64, a3, a2, &v5, 4i64, (__int64 *)va, 8i64, 0i64);
}

//----- (000000018005B870) ----------------------------------------------------
void __fastcall DTLSCookieManager::~DTLSCookieManager(DTLSCookieManager *this)
{
  void *v2; // rcx
  void *v3; // rcx

  v2 = (void *)*((_QWORD *)this + 3);
  if ( v2 )
  {
    BCryptCloseAlgorithmProvider(v2, 0);
    *((_QWORD *)this + 3) = 0i64;
  }
  v3 = (void *)*((_QWORD *)this + 1);
  if ( v3 )
    SPExternalFree(v3);
  *((_DWORD *)this + 4) = 0;
}

//----- (000000018005B8B4) ----------------------------------------------------
DTLSCookieManager *__fastcall DTLSCookieManager::`scalar deleting destructor'(DTLSCookieManager *this)
{
  DTLSCookieManager::~DTLSCookieManager(this);
  operator delete(this);
  return this;
}

//----- (000000018005B8DC) ----------------------------------------------------
__int64 __fastcall DTLSCookieManager::ComputeCookie(
        DTLSCookieManager *this,
        unsigned __int8 *const a2,
        ULONG a3,
        unsigned __int8 *const a4,
        ULONG cbInput,
        unsigned __int8 *const pbInput,
        ULONG a7,
        unsigned __int8 *pbOutput)
{
  void *v12; // rcx
  NTSTATUS v13; // ebx
  UCHAR *v15; // [rsp+20h] [rbp-38h]
  ULONG cbSecret; // [rsp+28h] [rbp-30h]
  BCRYPT_HASH_HANDLE hHash; // [rsp+60h] [rbp+8h] BYREF

  cbSecret = *(_DWORD *)this;
  v15 = (UCHAR *)*((_QWORD *)this + 1);
  v12 = (void *)*((_QWORD *)this + 3);
  hHash = 0i64;
  v13 = BCryptCreateHash(v12, &hHash, 0i64, 0, v15, cbSecret, 0);
  if ( v13 >= 0 )
  {
    v13 = BCryptHashData(hHash, a2, a3, 0);
    if ( v13 >= 0 )
    {
      v13 = BCryptHashData(hHash, a4, cbInput, 0);
      if ( v13 >= 0 )
      {
        v13 = BCryptHashData(hHash, pbInput, a7, 0);
        if ( v13 >= 0 )
        {
          v13 = BCryptFinishHash(hHash, pbOutput, *((_DWORD *)this + 8), 0);
          if ( v13 >= 0 )
            v13 = 0;
        }
      }
    }
  }
  if ( hHash )
    BCryptDestroyHash(hHash);
  return (unsigned int)v13;
}

//----- (000000018005BA0C) ----------------------------------------------------
__int64 __fastcall DTLSCookieManager::ResetSecret(PUCHAR *this)
{
  signed int RandomBits; // ebx

  if ( DTLSCookieManager::m_pCookieMgr )
  {
    RandomBits = GenerateRandomBits(this[1], *(_DWORD *)this);
    if ( RandomBits >= 0 )
      this[7] = (PUCHAR)GetTickCount64();
  }
  else
  {
    return 12;
  }
  return (unsigned int)RandomBits;
}

//----- (000000018005BA60) ----------------------------------------------------
__int64 __fastcall DTLSCookieManager::ValidateCookie(
        DTLSCookieManager *this,
        unsigned __int8 *const a2,
        ULONG a3,
        unsigned __int8 *const a4,
        unsigned int a5,
        unsigned __int8 *const a6,
        unsigned int a7)
{
  unsigned int v8; // ebx
  __int128 Buf2[2]; // [rsp+40h] [rbp-48h] BYREF

  memset(Buf2, 0, sizeof(Buf2));
  v8 = 0;
  if ( (int)DTLSCookieManager::ComputeCookie(this, a2, a3, a4, a5, a6, a7, (unsigned __int8 *)Buf2) < 0 )
    return 0i64;
  LOBYTE(v8) = memcmp_0(a4 - 32, Buf2, 0x20ui64) == 0;
  return v8;
}

//----- (000000018005BAF8) ----------------------------------------------------
__int64 __fastcall DTLSCookieManager::getDTlsCookieManager(struct DTLSCookieManager **a1)
{
  struct DTLSCookieManager *v1; // rax
  int v2; // edi
  DTLSCookieManager *v4; // rax
  const unsigned __int16 *v5; // rdx
  DTLSCookieManager *v6; // rbx

  v1 = DTLSCookieManager::m_pCookieMgr;
  v2 = 0;
  if ( !DTLSCookieManager::m_pCookieMgr )
  {
    RtlEnterCriticalSection(&CSslGlobals::m_DTLSInitCriticalSection);
    if ( !DTLSCookieManager::m_pCookieMgr )
    {
      v4 = (DTLSCookieManager *)operator new(0x40ui64);
      v6 = v4;
      if ( v4 )
      {
        *((_QWORD *)v4 + 1) = 0i64;
        *((_DWORD *)v4 + 4) = 0;
        *((_QWORD *)v4 + 3) = 0i64;
        *((_DWORD *)v4 + 8) = 0;
        *((_DWORD *)v4 + 9) = 0;
        *((_DWORD *)v4 + 10) = 0;
        *(_DWORD *)v4 = 32;
        *((_QWORD *)v4 + 6) = 600000i64;
        v2 = DTLSCookieManager::init(v4, v5);
        if ( v2 >= 0 )
          DTLSCookieManager::m_pCookieMgr = v6;
        else
          DTLSCookieManager::`scalar deleting destructor'(v6);
      }
      else
      {
        v2 = -1073741801;
      }
    }
    RtlLeaveCriticalSection(&CSslGlobals::m_DTLSInitCriticalSection);
    v1 = DTLSCookieManager::m_pCookieMgr;
  }
  *a1 = v1;
  return (unsigned int)v2;
}
// 18005BB6D: variable 'v5' is possibly undefined

//----- (000000018005BBC8) ----------------------------------------------------
int __fastcall DTLSCookieManager::init(DTLSCookieManager *this, const unsigned __int16 *a2)
{
  UCHAR *v3; // rax
  int result; // eax
  BCRYPT_HANDLE *v5; // rdi

  v3 = (UCHAR *)SPExternalAlloc(*(_DWORD *)this);
  *((_QWORD *)this + 1) = v3;
  if ( !v3 )
    return -1073741670;
  result = GenerateRandomBits(v3, *(_DWORD *)this);
  if ( result >= 0 )
  {
    v5 = (BCRYPT_HANDLE *)((char *)this + 24);
    result = BCryptOpenAlgorithmProvider((BCRYPT_ALG_HANDLE *)this + 3, L"SHA256", 0i64, 8u);
    if ( result >= 0 )
    {
      result = BCryptGetProperty(*v5, L"HashDigestLength", (PUCHAR)this + 32, 4u, (ULONG *)this + 9, 0);
      if ( result >= 0 )
      {
        result = BCryptGetProperty(*v5, L"ObjectLength", (PUCHAR)this + 40, 4u, (ULONG *)this + 9, 0);
        if ( result >= 0 )
        {
          *((_DWORD *)this + 4) = 1;
          return 0;
        }
      }
    }
  }
  return result;
}

//----- (000000018005BCB0) ----------------------------------------------------
__int64 __fastcall CheckClientVerifyMessage(
        struct CSsl3TlsServerContext *a1,
        const unsigned __int16 *a2,
        const unsigned __int16 *a3,
        unsigned int a4,
        unsigned int a5,
        ULONG a6,
        unsigned __int8 *pbEncoded,
        DWORD cbEncoded)
{
  UCHAR *v8; // r12
  unsigned __int8 *v12; // rsi
  const unsigned __int16 **v14; // r13
  __int64 v15; // rax
  __int64 v16; // r8
  unsigned int Property; // ebx
  int v18; // r8d
  int v19; // edx
  struct CSsl3TlsServerContext *v20; // rcx
  __int64 *v21; // rax
  __int64 v22; // rcx
  unsigned int v23; // eax
  __int64 v24; // r15
  int v25; // ecx
  unsigned __int8 *v26; // rax
  int v27; // eax
  DWORD v28; // eax
  int v29; // eax
  UCHAR pbOutput[4]; // [rsp+40h] [rbp-89h] BYREF
  ULONG cbSignature; // [rsp+44h] [rbp-85h] BYREF
  ULONG cbHash; // [rsp+48h] [rbp-81h] BYREF
  __int64 v34; // [rsp+50h] [rbp-79h] BYREF
  BCRYPT_HANDLE hObject; // [rsp+58h] [rbp-71h] BYREF
  ULONG pcbResult[2]; // [rsp+60h] [rbp-69h] BYREF
  const unsigned __int16 *v37; // [rsp+68h] [rbp-61h] BYREF
  __int128 v38; // [rsp+70h] [rbp-59h] BYREF
  UCHAR pbHash[64]; // [rsp+80h] [rbp-49h] BYREF

  v8 = pbEncoded;
  hObject = 0i64;
  v12 = 0i64;
  v14 = 0i64;
  cbHash = 64;
  memset_0(pbHash, 0, sizeof(pbHash));
  v37 = 0i64;
  v15 = *(_QWORD *)a1;
  v38 = 0i64;
  (*(void (__fastcall **)(struct CSsl3TlsServerContext *, __int64 *))(v15 + 232))(a1, &v34);
  RtlAcquireResourceShared((PRTL_RESOURCE)(v34 + 72), 1u);
  *(_QWORD *)pcbResult = *(_QWORD *)(v34 + 16);
  if ( !wcsncmp(a2, L"RSA", 3ui64) )
  {
    if ( a6 == 8 )
    {
      v14 = (const unsigned __int16 **)&v38;
      DWORD2(v38) = a5;
      *(_QWORD *)&v38 = a3;
    }
    else
    {
      if ( a6 != 2 )
      {
        Property = 1359;
        goto LABEL_33;
      }
      v14 = &v37;
      v37 = a3;
    }
  }
  v16 = (*(__int64 (__fastcall **)(struct CSsl3TlsServerContext *, _QWORD))(*(_QWORD *)a1 + 512i64))(a1, a4);
  if ( !v16 )
  {
    RtlReleaseResource((PRTL_RESOURCE)(v34 + 72));
    Property = 1359;
    v18 = 1359;
    v19 = 1303;
LABEL_6:
    v20 = a1;
LABEL_7:
    CSslContext::SetErrorAndFatalAlert((__int64)v20, v19, v18, 0x50u);
    goto LABEL_33;
  }
  v21 = (__int64 *)*((_QWORD *)a1 + 1);
  if ( v21 )
    v22 = *v21;
  else
    v22 = 0i64;
  Property = SslComputeClientAuthHash(v22, *(_QWORD *)pcbResult, v16, a2, pbHash, 64, &cbHash, 0);
  RtlReleaseResource((PRTL_RESOURCE)(v34 + 72));
  v20 = a1;
  if ( Property )
  {
    v18 = Property;
    v19 = 1303;
    goto LABEL_7;
  }
  v23 = ConvertPubKeyToBcryptHdl(a1, a2, &hObject);
  Property = v23;
  if ( v23 )
  {
    v18 = v23;
    v19 = 1304;
    goto LABEL_6;
  }
  if ( !wcsncmp(a2, L"RSA", 3ui64) )
  {
    v28 = cbEncoded;
  }
  else
  {
    *(_DWORD *)pbOutput = 0;
    pcbResult[0] = 0;
    v24 = 47i64;
    if ( !wcsncmp(a2, L"DSA", 3ui64) )
      v24 = 40i64;
    Property = BCryptGetProperty(hObject, L"KeyLength", pbOutput, 4u, pcbResult, 0);
    if ( Property )
      goto LABEL_33;
    v25 = ((pbOutput[0] & 7) != 0) + (*(_DWORD *)pbOutput >> 3);
    if ( !v25 )
      goto LABEL_33;
    cbSignature = 2 * v25;
    v26 = (unsigned __int8 *)SPExternalAlloc(2 * v25);
    v12 = v26;
    if ( !v26 )
    {
      Property = 14;
      goto LABEL_33;
    }
    v27 = DecodeSigAndReverse(pbEncoded, cbEncoded, v26, &cbSignature, (const char *)v24);
    Property = v27;
    if ( v27 )
    {
      CSslContext::SetErrorAndFatalAlert((__int64)a1, 1305, v27, 0x32u);
LABEL_32:
      LocalFree(v12);
      goto LABEL_33;
    }
    v28 = cbSignature;
    v8 = v12;
  }
  v29 = BCryptVerifySignature(hObject, v14, pbHash, cbHash, v8, v28, a6);
  Property = v29;
  if ( v29 )
    CSslContext::SetErrorAndFatalAlert((__int64)a1, 1306, v29, 0x33u);
  if ( v12 )
    goto LABEL_32;
LABEL_33:
  if ( hObject )
    BCryptDestroyKey(hObject);
  return Property;
}
// 180098588: using guessed type __int64 __fastcall SslComputeClientAuthHash(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);

//----- (000000018005C020) ----------------------------------------------------
__int64 __fastcall ConvertPubKeyToBcryptHdl(struct CSslContext *a1, const unsigned __int16 *a2, void **a3)
{
  unsigned int v6; // edi
  BOOL v7; // ebx

  v6 = 0;
  if ( !wcsncmp(a2, L"ECDSA", 5ui64) )
  {
    RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)a1 + 11) + 72i64), 1u);
    v7 = CryptImportPublicKeyInfoEx2(
           **(_DWORD **)(*((_QWORD *)a1 + 11) + 48i64),
           (PCERT_PUBLIC_KEY_INFO)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 11) + 48i64) + 24i64) + 96i64),
           0x80000000,
           0i64,
           a3);
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)a1 + 11) + 72i64));
    if ( !v7 )
      return (unsigned int)-2146893052;
  }
  else
  {
    return (unsigned int)ImportNcryptExportBcrypt(a1, a2, a3);
  }
  return v6;
}

//----- (000000018005C0F0) ----------------------------------------------------
ULONG __fastcall CreateUnicodeStringFromAlpnId(
        unsigned __int8 *a1,
        unsigned int a2,
        char a3,
        struct _UNICODE_STRING *a4)
{
  unsigned __int8 *v4; // r10
  unsigned int v5; // r8d
  NTSTATUS v7; // eax
  struct _STRING SourceString; // [rsp+20h] [rbp-18h] BYREF

  *(_DWORD *)(&SourceString.MaximumLength + 1) = 0;
  v4 = a1;
  if ( a1 && a4 && a4->Buffer && a2 )
  {
    if ( !a3 )
    {
      v5 = *a1;
      if ( v5 > a2 - 1 )
        return 1359;
      v4 = a1 + 1;
      goto LABEL_11;
    }
    if ( a2 <= 0xFF )
    {
      LOWORD(v5) = a2;
LABEL_11:
      SourceString.Length = v5;
      SourceString.MaximumLength = v5;
      SourceString.Buffer = (PCHAR)v4;
      v7 = RtlAnsiStringToUnicodeString(a4, &SourceString, 0);
      return RtlNtStatusToDosError(v7);
    }
  }
  return 87;
}

//----- (000000018005C184) ----------------------------------------------------
__int64 __fastcall DecodeSigAndReverse(
        BYTE *pbEncoded,
        DWORD cbEncoded,
        unsigned __int8 *a3,
        unsigned int *a4,
        const char *lpszStructType)
{
  unsigned int v5; // ebx
  const void **pvStructInfo; // rdi
  unsigned int v11; // esi
  DWORD pcbStructInfo[4]; // [rsp+40h] [rbp-28h] BYREF

  v5 = 0;
  pcbStructInfo[0] = 0;
  if ( CryptDecodeObject(1u, lpszStructType, pbEncoded, cbEncoded, 0, 0i64, pcbStructInfo) )
  {
    pvStructInfo = (const void **)SPExternalAlloc(pcbStructInfo[0]);
    if ( !pvStructInfo )
      return (unsigned int)-2146893056;
    if ( CryptDecodeObject(1u, lpszStructType, pbEncoded, cbEncoded, 0, pvStructInfo, pcbStructInfo) )
    {
      if ( lpszStructType == (const char *)47 )
      {
        v11 = *a4 >> 1;
        if ( *(_DWORD *)pvStructInfo <= v11 && *((_DWORD *)pvStructInfo + 4) <= v11 )
        {
          memcpy_0(a3, pvStructInfo[1], *(unsigned int *)pvStructInfo);
          memcpy_0(&a3[(unsigned __int64)*a4 >> 1], pvStructInfo[3], *((unsigned int *)pvStructInfo + 4));
          ReverseInPlace(a3, v11);
          ReverseInPlace(&a3[(unsigned __int64)*a4 >> 1], *a4 >> 1);
LABEL_15:
          SPExternalFree(pvStructInfo);
          return v5;
        }
LABEL_10:
        v5 = -2146893018;
        goto LABEL_15;
      }
      if ( lpszStructType == (const char *)40 )
      {
        if ( pcbStructInfo[0] <= *a4 )
        {
          ReverseMemCopy(a3, (unsigned __int8 *)pvStructInfo, pcbStructInfo[0] >> 1);
          ReverseMemCopy(
            &a3[(unsigned __int64)pcbStructInfo[0] >> 1],
            (unsigned __int8 *)pvStructInfo + ((unsigned __int64)pcbStructInfo[0] >> 1),
            pcbStructInfo[0] >> 1);
          *a4 = pcbStructInfo[0];
          goto LABEL_15;
        }
        goto LABEL_10;
      }
    }
    v5 = -2146893052;
    goto LABEL_15;
  }
  return (unsigned int)-2146893052;
}

//----- (000000018005C318) ----------------------------------------------------
unsigned __int8 __fastcall DoesTlsParameterContainAlpnId(struct _TLS_PARAMETERS *a1, struct _UNICODE_STRING *a2)
{
  unsigned int v4; // edi

  if ( !a1 || !*(_DWORD *)a1 || !a2 )
    return 0;
  v4 = 0;
  while ( RtlCompareUnicodeString((PCUNICODE_STRING)(*((_QWORD *)a1 + 1) + 16i64 * v4), a2, 1u) )
  {
    if ( ++v4 >= *(_DWORD *)a1 )
      return 0;
  }
  return 1;
}

//----- (000000018005C384) ----------------------------------------------------
__int64 __fastcall DssGetCertPublicKeyBlob(const struct _CERT_CONTEXT *a1, HLOCAL *a2, unsigned int *a3)
{
  unsigned int v5; // ebx
  unsigned __int8 *pbData; // rax
  BOOL v7; // eax
  int v8; // ecx
  HCRYPTKEY hKey; // [rsp+50h] [rbp+8h] BYREF

  *a2 = 0i64;
  hKey = 0i64;
  if ( CryptImportPublicKeyInfoEx(
         g_hDhSchannelProv,
         a1->dwCertEncodingType,
         &a1->pCertInfo->SubjectPublicKeyInfo,
         0x2200u,
         0,
         0i64,
         &hKey)
    && CryptExportKey(hKey, 0i64, 6u, 0x80u, 0i64, a3) )
  {
    pbData = (unsigned __int8 *)SPExternalAlloc(*a3);
    *a2 = pbData;
    if ( pbData )
    {
      v7 = CryptExportKey(hKey, 0i64, 6u, 0x80u, pbData, a3);
      v8 = 0;
      if ( !v7 )
        v8 = -2146893052;
      v5 = v8;
    }
    else
    {
      v5 = -2146893056;
    }
  }
  else
  {
    v5 = -2146893052;
  }
  if ( hKey )
    CryptDestroyKey(hKey);
  if ( v5 )
  {
    LocalFree(*a2);
    *a2 = 0i64;
  }
  return v5;
}

//----- (000000018005C498) ----------------------------------------------------
__int64 __fastcall ImportNcryptExportBcrypt(struct CSslContext *a1, const unsigned __int16 *a2, void **a3)
{
  BYTE *v6; // rdi
  PBYTE v7; // rsi
  BCRYPT_ALG_HANDLE v8; // r13
  const WCHAR *v9; // r15
  struct _RTL_RESOURCE *v10; // rcx
  int CertPublicKeyBlob; // ebx
  DWORD cbData; // ecx
  BYTE *pbData; // rax
  struct _RTL_RESOURCE *v14; // rcx
  __int64 v15; // rcx
  NCRYPT_KEY_HANDLE hKey; // [rsp+40h] [rbp-20h] BYREF
  PBYTE v18; // [rsp+48h] [rbp-18h] BYREF
  LPCWSTR pszBlobType; // [rsp+50h] [rbp-10h]
  DWORD pcbResult; // [rsp+B0h] [rbp+50h] BYREF
  DWORD v21; // [rsp+B8h] [rbp+58h] BYREF

  *a3 = 0i64;
  hKey = 0i64;
  pcbResult = 0;
  v18 = 0i64;
  v21 = 0;
  v6 = 0i64;
  v7 = 0i64;
  if ( !wcsncmp(a2, L"DSA", 3ui64) )
  {
    v8 = g_hDSAProvider;
    v9 = L"DSAPUBLICBLOB";
    v10 = (struct _RTL_RESOURCE *)(*((_QWORD *)a1 + 11) + 72i64);
    pszBlobType = L"CAPIDSAPUBLICBLOB";
    RtlAcquireResourceShared(v10, 1u);
    CertPublicKeyBlob = DssGetCertPublicKeyBlob(
                          *(const struct _CERT_CONTEXT **)(*((_QWORD *)a1 + 11) + 48i64),
                          (HLOCAL *)&v18,
                          &v21);
    if ( CertPublicKeyBlob )
    {
      RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)a1 + 11) + 72i64));
      v7 = v18;
      goto LABEL_15;
    }
    v7 = v18;
    cbData = v21;
    pbData = v18;
  }
  else
  {
    if ( wcsncmp(a2, L"RSA", 3ui64) )
    {
      CertPublicKeyBlob = -2146893052;
      goto LABEL_15;
    }
    v8 = g_hRSAProvider;
    v9 = L"RSAPUBLICBLOB";
    v14 = (struct _RTL_RESOURCE *)(*((_QWORD *)a1 + 11) + 72i64);
    pszBlobType = L"CAPIPUBLICBLOB";
    RtlAcquireResourceShared(v14, 1u);
    v15 = *(_QWORD *)(*((_QWORD *)a1 + 11) + 40i64);
    pbData = *(BYTE **)v15;
    cbData = *(_DWORD *)(v15 + 8);
  }
  CertPublicKeyBlob = NCryptImportKey(hProvider, 0i64, pszBlobType, 0i64, &hKey, pbData, cbData, 8u);
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)a1 + 11) + 72i64));
  if ( !CertPublicKeyBlob )
  {
    CertPublicKeyBlob = NCryptExportKey(hKey, 0i64, v9, 0i64, 0i64, 0, &pcbResult, 0);
    if ( CertPublicKeyBlob >= 0 )
    {
      v6 = (BYTE *)SPExternalAlloc(pcbResult);
      if ( v6 )
      {
        CertPublicKeyBlob = NCryptExportKey(hKey, 0i64, v9, 0i64, v6, pcbResult, &pcbResult, 0);
        if ( !CertPublicKeyBlob )
        {
          CertPublicKeyBlob = BCryptImportKeyPair(v8, 0i64, v9, a3, v6, pcbResult, 0);
          if ( CertPublicKeyBlob )
            CertPublicKeyBlob = -2146893043;
        }
      }
      else
      {
        CertPublicKeyBlob = -2146893056;
      }
    }
  }
LABEL_15:
  if ( v7 )
    LocalFree(v7);
  if ( v6 )
    SPExternalFree(v6);
  if ( hKey )
    NCryptFreeObject(hKey);
  return (unsigned int)CertPublicKeyBlob;
}

//----- (000000018005C734) ----------------------------------------------------
char __fastcall IsDheAlgorithmBlacklisted(
        struct _TLS_PARAMETERS *a1,
        unsigned int a2,
        unsigned int a3,
        struct _UNICODE_STRING *a4,
        unsigned __int8 a5)
{
  __int64 v5; // r10
  unsigned int v7; // ebp
  struct _TLS_PARAMETERS *v8; // rbx
  struct kexch *KeyExchangeInfo; // rax
  struct _TLS_PARAMETERS *v10; // r14
  char v11; // si
  unsigned int v12; // edi
  unsigned __int64 v13; // rdi
  unsigned __int64 i; // rcx
  int v16; // [rsp+20h] [rbp-28h]
  int v17; // [rsp+20h] [rbp-28h]
  int v18; // [rsp+28h] [rbp-20h]

  v5 = a2;
  v7 = a3;
  v8 = a1;
  if ( !a2 || !a1 )
    return 0;
  if ( !a3 )
  {
    KeyExchangeInfo = GetKeyExchangeInfo(43522);
    if ( KeyExchangeInfo )
    {
      v7 = *((_DWORD *)KeyExchangeInfo + 12);
      goto LABEL_6;
    }
    return 0;
  }
LABEL_6:
  v10 = (struct _TLS_PARAMETERS *)((char *)v8 + 40 * v5);
  if ( v8 < v10 )
  {
    v11 = 1;
    do
    {
      if ( *((_DWORD *)v8 + 5) )
      {
        if ( *(_DWORD *)v8 )
        {
          if ( !a4 )
            goto LABEL_33;
          v12 = 0;
          while ( RtlCompareUnicodeString((PCUNICODE_STRING)(*((_QWORD *)v8 + 1) + 16i64 * v12), a4, 1u) )
          {
            if ( ++v12 >= *(_DWORD *)v8 )
              goto LABEL_33;
          }
        }
        if ( !a5 || (*((_BYTE *)v8 + 32) & 1) == 0 )
        {
          v13 = *((_QWORD *)v8 + 3);
          for ( i = v13 + 48i64 * *((unsigned int *)v8 + 5);
                v13 < i;
                i = *((_QWORD *)v8 + 3) + 48i64 * *((unsigned int *)v8 + 5) )
          {
            if ( !*(_DWORD *)v13 && *(_WORD *)(v13 + 8) == 4 && !wcsncmp(*(const wchar_t **)(v13 + 16), L"DH", 2ui64) )
            {
              if ( !*(_DWORD *)(v13 + 24) && !*(_DWORD *)(v13 + 40) && !*(_DWORD *)(v13 + 44) )
              {
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
                {
                  v16 = 0;
                  WPP_SF_Sd(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    0xCu,
                    (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
                    L"DH",
                    v16);
                }
                return v11;
              }
              if ( v7 )
              {
                if ( *(_DWORD *)(v13 + 40) )
                {
                  if ( *(_DWORD *)(v13 + 40) > v7 )
                    goto LABEL_39;
                }
                else if ( !*(_DWORD *)(v13 + 44) )
                {
                  goto LABEL_31;
                }
                if ( *(_DWORD *)(v13 + 44) && *(_DWORD *)(v13 + 44) < v7 )
                {
LABEL_39:
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
                  {
                    v18 = 0;
                    v17 = v7;
                    WPP_SF_Sdd(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      0xEu,
                      (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
                      L"DH",
                      v17,
                      v18);
                  }
                  return v11;
                }
              }
            }
LABEL_31:
            v13 += 48i64;
          }
        }
      }
LABEL_33:
      v8 = (struct _TLS_PARAMETERS *)((char *)v8 + 40);
    }
    while ( v8 < v10 );
  }
  return 0;
}
// 18005C790: variable 'v5' is possibly undefined

//----- (000000018005C948) ----------------------------------------------------
char __fastcall IsSignatureTypeBlacklisted(unsigned __int64 a1, unsigned int a2, int a3, const UNICODE_STRING *a4)
{
  int v5; // r8d
  int v6; // r8d
  const wchar_t *v7; // r9

  if ( a2 && a1 )
  {
    v5 = a3 - 1;
    if ( !v5 )
    {
      v7 = L"RSA";
      return IsCngAlgorithmBlacklisted(a1, a2, 1, v7, 0i64, 0, a4, 1);
    }
    v6 = v5 - 1;
    if ( !v6 )
    {
      v7 = L"DSA";
      return IsCngAlgorithmBlacklisted(a1, a2, 1, v7, 0i64, 0, a4, 1);
    }
    if ( v6 == 62 )
    {
      v7 = L"ECDSA";
      return IsCngAlgorithmBlacklisted(a1, a2, 1, v7, 0i64, 0, a4, 1);
    }
  }
  return 0;
}

//----- (000000018005C9B4) ----------------------------------------------------
__int64 __fastcall OpenKeyUsingCAPI(
        unsigned __int64 *a1,
        const unsigned __int16 *a2,
        const unsigned __int16 *a3,
        DWORD a4,
        unsigned int a5)
{
  unsigned int LastError; // ebx
  unsigned int CurrentProcessId; // eax

  LastError = 0;
  if ( !CryptAcquireContextW(a1, a2, a3, a4, a5 & 0xFFFFFFFE) )
  {
    LastError = GetLastError();
    CurrentProcessId = GetCurrentProcessId();
    LogCredAcquireContextFailedEvent(CurrentProcessId, L"<UNKNOWN>", 0, LastError, 10014);
  }
  return LastError;
}
// 180085488: using guessed type wchar_t aUnknown_0[10];

//----- (000000018005CA1C) ----------------------------------------------------
__int64 __fastcall OpenKeyUsingCng(
        NCRYPT_KEY_HANDLE *phKey,
        LPCWSTR pszKeyName,
        LPCWSTR pszProviderName,
        DWORD dwLegacyKeySpec,
        unsigned int a5,
        int a6,
        int *a7)
{
  unsigned int v10; // esi
  unsigned int dwFlags; // esi
  unsigned int v12; // ebx
  CCipherMill *v13; // rcx
  __int64 v14; // rdx
  NCRYPT_PROV_HANDLE phProvider[5]; // [rsp+30h] [rbp-28h] BYREF

  phProvider[0] = 0i64;
  if ( a7 )
    *a7 = 0;
  v10 = a5 | 0x40;
  if ( a6 )
    v10 = a5;
  dwFlags = v10 & 0xFFFFFFFE;
  v12 = NCryptOpenStorageProvider(phProvider, pszProviderName, 0);
  if ( v12 )
  {
    v13 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      v14 = 10i64;
LABEL_15:
      WPP_SF_D(*((_QWORD *)v13 + 2), v14, &WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids, v12);
    }
  }
  else
  {
    if ( a7 )
      *a7 = 1;
    v12 = NCryptOpenKey(phProvider[0], phKey, pszKeyName, dwLegacyKeySpec, dwFlags);
    if ( v12 )
    {
      v13 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        v14 = 11i64;
        goto LABEL_15;
      }
    }
  }
  if ( phProvider[0] )
    NCryptFreeObject(phProvider[0]);
  return v12;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 18005CA1C: using guessed type NCRYPT_PROV_HANDLE phProvider[5];

//----- (000000018005CB48) ----------------------------------------------------
__int64 WPP_SF_SSd(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4, const wchar_t *a5, ...)
{
  const wchar_t *v5; // r8
  __int64 v6; // rax
  __int64 v7; // r10
  __int64 v8; // rdx
  __int64 v9; // rdx
  bool v10; // zf
  va_list va; // [rsp+98h] [rbp+30h] BYREF

  va_start(va, a5);
  v5 = a5;
  v6 = -1i64;
  v7 = 10i64;
  if ( a5 )
  {
    v8 = -1i64;
    do
      ++v8;
    while ( a5[v8] );
    v9 = 2 * v8 + 2;
  }
  else
  {
    v9 = 10i64;
  }
  if ( !a5 )
    v5 = L"NULL";
  v10 = a4 == 0i64;
  if ( a4 )
  {
    do
      ++v6;
    while ( a4[v6] );
    v7 = 2 * v6 + 2;
    v10 = a4 == 0i64;
  }
  if ( v10 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43i64, &WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids, 13i64, a4, v7, v5, v9, va);
}
// 180083C60: using guessed type wchar_t aNull_0[5];

//----- (000000018005CC0C) ----------------------------------------------------
__int64 WPP_SF_Sdd(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, ...)
{
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v7; // [rsp+90h] [rbp+28h] BYREF
  va_list va; // [rsp+90h] [rbp+28h]
  va_list va1; // [rsp+98h] [rbp+30h] BYREF

  va_start(va1, a4);
  va_start(va, a4);
  v7 = va_arg(va1, _QWORD);
  if ( a4 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( a4[v4] );
    v5 = 2 * v4 + 2;
  }
  else
  {
    v5 = 10i64;
  }
  if ( !a4 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43i64, a3, a2, a4, v5, (__int64 *)va, 4i64, va1);
}
// 180083C60: using guessed type wchar_t aNull_0[5];

//----- (000000018005CCA0) ----------------------------------------------------
CSessionCacheItem *__fastcall CSessionCacheItem::`scalar deleting destructor'(CSessionCacheItem *this, char a2)
{
  CSessionCacheItem::~CSessionCacheItem(this);
  if ( (a2 & 1) != 0 )
    SPExternalFree(this);
  return this;
}

//----- (000000018005CCE0) ----------------------------------------------------
bool __fastcall CSessionCacheClientItem::CanEntryBePurged(
        CSessionCacheClientItem *this,
        struct _LUID *a2,
        char *a3,
        int a4)
{
  return (a4 & 0x10001) != 0
      && ((a4 & 0x10000) != 0 || a2 && *((_DWORD *)this + 94) == a2->LowPart && *((_DWORD *)this + 95) == a2->HighPart)
      && (!a3 || CSessionCacheClientItem::IsSameTargetName(this, a3));
}

//----- (000000018005CD40) ----------------------------------------------------
bool __fastcall CSessionCacheServerItem::CanEntryBePurged(
        CSessionCacheServerItem *this,
        struct _LUID *a2,
        const unsigned __int16 *a3,
        int a4)
{
  return (a4 & 0x20002) != 0;
}

//----- (000000018005CD60) ----------------------------------------------------
void __fastcall CSessionCacheItem::CompleteCacheAdd(
        CSessionCacheItem *this,
        struct CSessionCacheManager *a2,
        struct CSslContext *a3)
{
  __int64 v3; // rdx
  __int64 v4; // rax

  v3 = *((_QWORD *)a3 + 1);
  *((_QWORD *)this + 22) = v3;
  *((_DWORD *)this + 46) = *((_DWORD *)a3 + 4);
  v4 = *(_QWORD *)(v3 + 848);
  if ( v4 )
    _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v4 + 16) + 12i64));
  _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v3 + 856) + 12i64));
}

//----- (000000018005CDA0) ----------------------------------------------------
__int64 __fastcall CSessionCacheItem::ComputeSerializedCacheItemLen(
        CSessionCacheItem *this,
        struct CSslContext *a2,
        unsigned int *a3)
{
  __int64 result; // rax
  unsigned int v6; // [rsp+38h] [rbp+10h] BYREF

  v6 = 0;
  if ( !a2 || !a3 )
    return 87i64;
  result = CSessionCacheItem::ComputeSerializedNcryptMasterKeyLen(this, a2, &v6);
  if ( !(_DWORD)result )
  {
    *a3 = v6 + 67 + *((_DWORD *)this + 8) + *((_DWORD *)this + 16) + *((unsigned __int8 *)this + 208);
    return 0i64;
  }
  return result;
}

//----- (000000018005CE10) ----------------------------------------------------
__int64 __fastcall CSessionCacheServerItem::ComputeSerializedCacheItemLen(
        CSessionCacheServerItem *this,
        struct CSslContext *a2,
        unsigned int *a3)
{
  __int64 result; // rax
  unsigned int v6; // [rsp+38h] [rbp+10h] BYREF

  v6 = 0;
  if ( !a2 || !a3 )
    return 87i64;
  result = CSessionCacheItem::ComputeSerializedCacheItemLen(this, a2, &v6);
  if ( !(_DWORD)result )
  {
    *a3 = (*((_QWORD *)this + 42) != 0i64 ? 0x14 : 0) + v6 + 39;
    return 0i64;
  }
  return result;
}

//----- (000000018005CE74) ----------------------------------------------------
__int64 __fastcall CSessionCacheItem::ComputeSerializedNcryptMasterKeyLen(
        CSessionCacheItem *this,
        struct CSslContext *a2,
        unsigned int *a3)
{
  __int64 result; // rax
  __int64 *v5; // rax
  __int64 v6; // rcx

  if ( !a2 || !a3 )
    return 87i64;
  if ( *((_QWORD *)this + 2) )
  {
    v5 = (__int64 *)*((_QWORD *)a2 + 1);
    if ( v5 )
      v6 = *v5;
    else
      v6 = 0i64;
    result = SslExportKey(v6, *((_QWORD *)this + 2), L"OpaqueKeyBlob");
    if ( (_DWORD)result == -2146893784 )
      return 0i64;
  }
  else
  {
    *a3 = 0;
    return 0i64;
  }
  return result;
}
// 180082320: using guessed type wchar_t aOpaquekeyblob[14];
// 180098528: using guessed type __int64 __fastcall SslExportKey(_QWORD, _QWORD, _QWORD);

//----- (000000018005CEF0) ----------------------------------------------------
unsigned int __fastcall CSessionCacheItem::Deserialize(
        CSessionCacheItem *this,
        struct CSslContext *a2,
        unsigned __int8 *a3,
        unsigned int a4)
{
  CCipherMill *v8; // rcx
  unsigned int result; // eax
  int v10; // r8d
  __int64 v11; // rcx
  unsigned int v12; // r9d
  __int64 v13; // rcx
  unsigned int v14; // r8d

  if ( !a2 || !a3 || a4 < 0x44 || *(_DWORD *)a3 != 1 )
    return 87;
  *((_DWORD *)this + 2) = *((_DWORD *)a3 + 1);
  v8 = (CCipherMill *)*((unsigned int *)a3 + 8);
  *((_DWORD *)this + 42) = (_DWORD)v8;
  *((_DWORD *)this + 46) = *((_DWORD *)a3 + 10);
  if ( ((unsigned int)v8 & *((_DWORD *)a2 + 16)) == 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_3f0b3b553bfa392717596024a0f8b3a2_Traceguids);
    return 87;
  }
  result = CCipherMill::GetCipherState(
             v8,
             a2,
             (struct CCipherSuiteInfo **)this + 22,
             *((_DWORD *)a3 + 9),
             *((_DWORD *)a3 + 10));
  if ( !result )
  {
    *(_QWORD *)((char *)this + 188) = *(_QWORD *)(a3 + 52);
    *((_DWORD *)this + 54) = *((_DWORD *)a3 + 11);
    *((_DWORD *)this + 55) = *((_DWORD *)a3 + 12);
    if ( *((_DWORD *)a3 + 2) == 65 )
    {
      v10 = *((_DWORD *)a3 + 3);
      if ( v10 + 65 <= a4 )
      {
        result = CSessionCacheItem::DeserializeNcryptMasterKey(this, a3 + 65, v10);
        if ( result )
          return result;
        v11 = *((unsigned int *)a3 + 4);
        if ( (_DWORD)v11 == *((_DWORD *)a3 + 3) + *((_DWORD *)a3 + 2) )
        {
          v12 = *((_DWORD *)a3 + 5);
          if ( v12 + (unsigned int)v11 <= a4 )
          {
            result = CSessionCacheItem::DeserializeRemoteChain(this, a2, &a3[v11], v12);
            if ( result )
              return result;
            v13 = *((unsigned int *)a3 + 6);
            if ( (_DWORD)v13 == *((_DWORD *)a3 + 4) + *((_DWORD *)a3 + 5) )
            {
              v14 = *((_DWORD *)a3 + 7);
              if ( v14 + (unsigned int)v13 <= a4 )
              {
                result = CSessionCacheItem::DeserializeAppData(this, &a3[v13], v14);
                if ( !result )
                {
                  if ( *((_DWORD *)a3 + 15) == *((_DWORD *)a3 + 6) + *((_DWORD *)a3 + 7)
                    && *((_DWORD *)a3 + 15) + (unsigned int)a3[64] <= a4 )
                  {
                    return CSessionCacheItem::DeserializeTicketNonce(this, &a3[*((unsigned int *)a3 + 15)], a3[64]);
                  }
                  return 87;
                }
                return result;
              }
            }
          }
        }
      }
    }
    return 87;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018005D0A0) ----------------------------------------------------
__int64 __fastcall CSessionCacheServerItem::Deserialize(
        CSessionCacheServerItem *this,
        CCredentialGroup **a2,
        unsigned __int8 *a3,
        unsigned int a4)
{
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  unsigned int v11; // r9d
  unsigned int Credential; // ebx
  __int64 v13; // rcx
  int v14; // r8d
  unsigned __int8 *v15; // rdx
  CCredentialGroup *v16; // rcx
  unsigned __int64 v17; // [rsp+48h] [rbp+10h] BYREF

  v17 = 0i64;
  if ( !a2 || !a3 || a4 < 0x28 || *(_DWORD *)a3 )
    return 87i64;
  GetSystemTimeAsFileTime((LPFILETIME)&v17);
  v8 = v17 / 0x2710;
  v9 = *((_QWORD *)a3 + 3) / 0x2710ui64;
  v17 = v8;
  if ( v9 > CSslGlobals::m_dwSessionTicketTimeSkew + v8 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_3f0b3b553bfa392717596024a0f8b3a2_Traceguids);
    return 1398i64;
  }
  if ( v8 <= CSslGlobals::m_dwSessionTicketTimeSkew + v9 + CSslGlobals::m_dwSessionTicketLifespan )
  {
    RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)this + 72), 1u);
    if ( *((_DWORD *)a3 + 1) == 32 )
    {
      v11 = *((_DWORD *)a3 + 2);
      if ( v11 + 32 <= a4 )
      {
        Credential = CSessionCacheItem::Deserialize(this, (struct CSslContext *)a2, a3 + 32, v11);
        if ( Credential )
        {
LABEL_28:
          RtlReleaseResource((PRTL_RESOURCE)((char *)this + 72));
          return Credential;
        }
        v13 = *((unsigned int *)a3 + 3);
        if ( (_DWORD)v13 == *((_DWORD *)a3 + 2) + *((_DWORD *)a3 + 1) )
        {
          v14 = *((_DWORD *)a3 + 4);
          if ( v14 + (int)v13 <= a4 )
          {
            v15 = &a3[v13];
            if ( *((_QWORD *)this + 42) )
            {
              Credential = 1359;
              goto LABEL_28;
            }
            if ( !v14 )
            {
              Credential = 0;
              goto LABEL_28;
            }
            if ( v15 )
            {
              v16 = a2[10];
              if ( v16 )
              {
                Credential = CCredentialGroup::FindCredential(v16, v15, v14, (struct CSslCredential **)this + 42);
                goto LABEL_28;
              }
            }
          }
        }
      }
    }
    Credential = 87;
    goto LABEL_28;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_3f0b3b553bfa392717596024a0f8b3a2_Traceguids);
  return 1460i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018005D284) ----------------------------------------------------
__int64 __fastcall CSessionCacheItem::DeserializeAppData(CSessionCacheItem *this, unsigned __int8 *a2, unsigned int a3)
{
  size_t v4; // rbx
  HLOCAL v7; // rax

  v4 = a3;
  if ( *((_QWORD *)this + 7) || *((_DWORD *)this + 16) )
    return 1359i64;
  if ( !a3 )
    return 0i64;
  if ( !a2 )
    return 87i64;
  v7 = SPExternalAlloc(a3);
  *((_QWORD *)this + 7) = v7;
  if ( v7 )
  {
    memcpy_0(v7, a2, v4);
    *((_DWORD *)this + 16) = v4;
    return 0i64;
  }
  return 14i64;
}

//----- (000000018005D304) ----------------------------------------------------
__int64 __fastcall CSessionCacheItem::DeserializeNcryptMasterKey(CSessionCacheItem *this, unsigned __int8 *a2, int a3)
{
  char *v3; // r10
  __int64 *v5; // rax
  __int64 v6; // rcx

  v3 = (char *)this + 16;
  if ( *((_QWORD *)this + 2) )
    return 1359i64;
  if ( !a3 )
    return 0i64;
  if ( !a2 )
    return 87i64;
  v5 = (__int64 *)*((_QWORD *)this + 22);
  if ( v5 )
    v6 = *v5;
  else
    v6 = 0i64;
  return SslImportKey(v6, v3, L"OpaqueKeyBlob", a2, a3, 0);
}
// 180082320: using guessed type wchar_t aOpaquekeyblob[14];
// 1800985A0: using guessed type __int64 __fastcall SslImportKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (000000018005D370) ----------------------------------------------------
DWORD __fastcall CSessionCacheItem::DeserializeRemoteChain(
        CSessionCacheItem *this,
        struct CSslContext *a2,
        unsigned __int8 *a3,
        unsigned int a4)
{
  size_t v5; // rdi
  const struct _CERT_CONTEXT *CertificateContext; // rax
  const CERT_CONTEXT *v9; // rbp
  DWORD PublicKeyFromCert; // esi
  HLOCAL v11; // rax
  struct _PUBLICKEY *v12; // [rsp+40h] [rbp+8h] BYREF

  v5 = a4;
  if ( !*((_QWORD *)this + 3) && !*((_DWORD *)this + 8) && !*((_QWORD *)this + 5) && !*((_QWORD *)this + 6) )
  {
    if ( a2 )
    {
      if ( !a4 )
      {
        if ( (*((_DWORD *)a2 + 34) & 0x100i64) != 0 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_3f0b3b553bfa392717596024a0f8b3a2_Traceguids);
          }
          return 87;
        }
        return 0;
      }
      if ( a3 && a4 > 4 && (unsigned __int64)a4 - 4 >= *(unsigned int *)a3 )
      {
        CertificateContext = CertCreateCertificateContext(1u, a3 + 4, *(_DWORD *)a3);
        v9 = CertificateContext;
        if ( !CertificateContext )
          return GetLastError();
        v12 = 0i64;
        PublicKeyFromCert = GetPublicKeyFromCert(CertificateContext, &v12, 0i64);
        if ( !PublicKeyFromCert )
        {
          v11 = SPExternalAlloc(v5);
          *((_QWORD *)this + 3) = v11;
          if ( v11 )
          {
            *((_QWORD *)this + 5) = v12;
            *((_QWORD *)this + 6) = v9;
            memcpy_0(v11, a3, v5);
            *((_DWORD *)this + 8) = v5;
            return 0;
          }
          SPExternalFree(v12);
          PublicKeyFromCert = 14;
        }
        CertFreeCertificateContext(v9);
        return PublicKeyFromCert;
      }
    }
    return 87;
  }
  return 1359;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018005D4E8) ----------------------------------------------------
__int64 __fastcall CSessionCacheItem::DeserializeTicketNonce(
        CSessionCacheItem *this,
        unsigned __int8 *a2,
        unsigned __int8 a3)
{
  size_t v4; // rbx
  HLOCAL v7; // rax

  v4 = a3;
  if ( *((_QWORD *)this + 25) || *((_BYTE *)this + 208) )
    return 1359i64;
  if ( !a3 )
    return 0i64;
  if ( !a2 )
    return 87i64;
  v7 = SPExternalAlloc(a3);
  *((_QWORD *)this + 25) = v7;
  if ( v7 )
  {
    memcpy_0(v7, a2, v4);
    *((_BYTE *)this + 208) = v4;
    return 0i64;
  }
  return 14i64;
}

//----- (000000018005D574) ----------------------------------------------------
__int64 __fastcall CSessionCacheItem::GetCacheAppData(CSessionCacheItem *this, unsigned __int8 **a2, unsigned int *a3)
{
  unsigned int v5; // ecx
  unsigned __int8 *v6; // rax

  if ( *((_QWORD *)this + 7) )
  {
    v5 = *((_DWORD *)this + 16);
    *a3 = v5;
    v6 = (unsigned __int8 *)SPExternalAlloc(v5);
    *a2 = v6;
    if ( !v6 )
      return 14i64;
    memcpy_0(v6, *((const void **)this + 7), *((unsigned int *)this + 16));
  }
  else
  {
    *a2 = 0i64;
    *a3 = 0;
  }
  return 0i64;
}

//----- (000000018005D5D4) ----------------------------------------------------
__int64 __fastcall CSessionCacheItem::GetPrfHashDetails(
        CSessionCacheItem *this,
        unsigned __int8 *a2,
        enum _eTlsHashAlgorithm *a3)
{
  __int64 v3; // rax
  struct hsel *HashInfo; // rax
  _DWORD *v5; // r8
  _BYTE *v6; // r10

  v3 = *((_QWORD *)this + 22);
  if ( !v3 )
    return 1359i64;
  HashInfo = GetHashInfo(*(_DWORD *)(v3 + 44));
  if ( !HashInfo )
    return 1359i64;
  if ( v6 )
  {
    if ( *((_DWORD *)HashInfo + 7) > 0x40u )
    {
      *v6 = 0;
      return 1359i64;
    }
    *v6 = *((_BYTE *)HashInfo + 28);
  }
  if ( v5 )
    *v5 = *((_DWORD *)HashInfo + 8);
  return 0i64;
}
// 18005D5FA: variable 'v6' is possibly undefined
// 18005D61A: variable 'v5' is possibly undefined

//----- (000000018005D630) ----------------------------------------------------
__int64 __fastcall CSessionCacheItem::Serialize(
        CSessionCacheItem *this,
        struct CSslContext *a2,
        unsigned __int8 *a3,
        unsigned int a4,
        unsigned int *a5)
{
  __int64 v8; // rax
  int v9; // ecx
  unsigned __int8 *v10; // r15
  __int64 result; // rax
  __int64 v12; // rdx
  __int64 v13; // rdx
  __int64 v14; // rdx

  if ( !a2 || !a3 || !a5 )
    return 87i64;
  if ( a4 < 0x44 )
    return 122i64;
  *(_DWORD *)a3 = 1;
  *((_DWORD *)a3 + 1) = *((_DWORD *)this + 2);
  *((_DWORD *)a3 + 8) = *((_DWORD *)this + 42);
  if ( (*((_BYTE *)a2 + 32) & 8) != 0 && (v8 = *((_QWORD *)a2 + 1)) != 0 )
    v9 = *(_DWORD *)(v8 + 28);
  else
    v9 = 0;
  *((_DWORD *)a3 + 9) = v9;
  v10 = a3 + 12;
  *((_DWORD *)a3 + 10) = *((_DWORD *)a2 + 4);
  *(_QWORD *)(a3 + 52) = *(_QWORD *)((char *)this + 188);
  *((_DWORD *)a3 + 11) = *((_DWORD *)this + 54);
  *((_DWORD *)a3 + 12) = *((_DWORD *)this + 55);
  *((_DWORD *)a3 + 2) = 65;
  result = CSessionCacheItem::SerializeNcryptMasterKey(this, a2, a3 + 65, a4 - 65, (unsigned int *)a3 + 3);
  if ( !(_DWORD)result )
  {
    v12 = (unsigned int)(*((_DWORD *)a3 + 2) + *(_DWORD *)v10);
    *((_DWORD *)a3 + 4) = v12;
    if ( a4 >= (unsigned int)v12 )
    {
      result = CSessionCacheItem::SerializeRemoteChain(this, &a3[v12], a4 - (unsigned int)v12, (unsigned int *)a3 + 5);
      if ( (_DWORD)result )
        return result;
      v13 = (unsigned int)(*((_DWORD *)a3 + 4) + *((_DWORD *)a3 + 5));
      *((_DWORD *)a3 + 6) = v13;
      if ( a4 >= (unsigned int)v13 )
      {
        result = CSessionCacheItem::SerializeAppData(this, &a3[v13], a4 - (unsigned int)v13, (unsigned int *)a3 + 7);
        if ( (_DWORD)result )
          return result;
        v14 = (unsigned int)(*((_DWORD *)a3 + 6) + *((_DWORD *)a3 + 7));
        *((_DWORD *)a3 + 15) = v14;
        if ( a4 >= (unsigned int)v14 )
        {
          result = CSessionCacheItem::SerializeTicketNonce(this, &a3[v14], a4 - (unsigned int)v14, a3 + 64);
          if ( !(_DWORD)result )
          {
            *a5 = *((_DWORD *)a3 + 15) + a3[64];
            return 0i64;
          }
          return result;
        }
      }
    }
    return 122i64;
  }
  return result;
}

//----- (000000018005D7B0) ----------------------------------------------------
__int64 __fastcall CSessionCacheServerItem::Serialize(
        CSessionCacheServerItem *this,
        struct CSslContext *a2,
        unsigned __int8 *a3,
        unsigned int a4,
        unsigned int *a5)
{
  unsigned int v10; // ebx
  __int64 v11; // rdx
  unsigned int v12; // esi
  unsigned __int8 *v13; // rcx
  unsigned __int8 *v14; // rdx
  __int64 v15; // rax

  if ( !a2 || !a3 || !a5 )
    return 87i64;
  if ( a4 < 0x28 )
    return 122i64;
  RtlAcquireResourceShared((PRTL_RESOURCE)((char *)this + 72), 1u);
  *(_DWORD *)a3 = 0;
  GetSystemTimeAsFileTime((LPFILETIME)a3 + 3);
  *((_DWORD *)a3 + 1) = 32;
  v10 = CSessionCacheItem::Serialize(this, a2, a3 + 32, a4 - 32, (unsigned int *)a3 + 2);
  if ( !v10 )
  {
    v11 = (unsigned int)(*((_DWORD *)a3 + 1) + *((_DWORD *)a3 + 2));
    *((_DWORD *)a3 + 3) = v11;
    if ( a4 < (unsigned int)v11 )
    {
LABEL_8:
      v10 = 122;
      goto LABEL_18;
    }
    v12 = a4 - v11;
    v13 = a3 + 16;
    v14 = &a3[v11];
    if ( !v14 && v12 || a3 == (unsigned __int8 *)-16i64 )
    {
      v10 = 87;
      goto LABEL_18;
    }
    v15 = *((_QWORD *)this + 42);
    if ( v15 )
    {
      if ( v12 < 0x14 )
        goto LABEL_8;
      *(_OWORD *)v14 = *(_OWORD *)(v15 + 40);
      *((_DWORD *)v14 + 4) = *(_DWORD *)(v15 + 56);
      *(_DWORD *)v13 = 20;
    }
    else
    {
      *(_DWORD *)v13 = 0;
    }
    v10 = 0;
  }
LABEL_18:
  RtlReleaseResource((PRTL_RESOURCE)((char *)this + 72));
  if ( !v10 )
    *a5 = *((_DWORD *)a3 + 3) + *((_DWORD *)a3 + 4);
  return v10;
}

//----- (000000018005D8FC) ----------------------------------------------------
__int64 __fastcall CSessionCacheItem::SerializeAppData(
        CSessionCacheItem *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned int *a4)
{
  const void *v8; // rdx

  if ( !a2 && a3 || !a4 )
    return 87i64;
  v8 = (const void *)*((_QWORD *)this + 7);
  if ( v8 )
  {
    if ( a3 < *((_DWORD *)this + 16) )
      return 122i64;
    memcpy_0(a2, v8, *((unsigned int *)this + 16));
    *a4 = *((_DWORD *)this + 16);
  }
  else
  {
    *a4 = 0;
  }
  return 0i64;
}

//----- (000000018005D968) ----------------------------------------------------
__int64 __fastcall CSessionCacheItem::SerializeNcryptMasterKey(
        CSessionCacheItem *this,
        struct CSslContext *a2,
        unsigned __int8 *a3,
        int a4,
        unsigned int *a5)
{
  __int64 v6; // rdx
  _QWORD *v8; // rcx

  if ( !a2 || !a3 && a4 || !a5 )
    return 87i64;
  v6 = *((_QWORD *)this + 2);
  if ( v6 )
  {
    v8 = (_QWORD *)*((_QWORD *)a2 + 1);
    if ( v8 )
      v8 = (_QWORD *)*v8;
    return SslExportKey(v8, v6, L"OpaqueKeyBlob");
  }
  else
  {
    *a5 = 0;
    return 0i64;
  }
}
// 180082320: using guessed type wchar_t aOpaquekeyblob[14];
// 180098528: using guessed type __int64 __fastcall SslExportKey(_QWORD, _QWORD, _QWORD);

//----- (000000018005D9DC) ----------------------------------------------------
__int64 __fastcall CSessionCacheItem::SerializeRemoteChain(
        CSessionCacheItem *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned int *a4)
{
  const void *v8; // rdx

  if ( !a2 && a3 || !a4 )
    return 87i64;
  v8 = (const void *)*((_QWORD *)this + 3);
  if ( v8 )
  {
    if ( a3 < *((_DWORD *)this + 8) )
      return 122i64;
    memcpy_0(a2, v8, *((unsigned int *)this + 8));
    *a4 = *((_DWORD *)this + 8);
  }
  else
  {
    *a4 = 0;
  }
  return 0i64;
}

//----- (000000018005DA48) ----------------------------------------------------
__int64 __fastcall CSessionCacheItem::SerializeTicketNonce(
        CSessionCacheItem *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int8 *a4)
{
  const void *v8; // rdx

  if ( !a2 && a3 || !a4 )
    return 87i64;
  v8 = (const void *)*((_QWORD *)this + 25);
  if ( v8 )
  {
    if ( a3 < *((unsigned __int8 *)this + 208) )
      return 122i64;
    memcpy_0(a2, v8, *((unsigned __int8 *)this + 208));
    *a4 = *((_BYTE *)this + 208);
  }
  else
  {
    *a4 = 0;
  }
  return 0i64;
}

//----- (000000018005DABC) ----------------------------------------------------
DWORD __fastcall CSessionCacheClientItem::UpdateRemoteEndpointBindings(CSessionCacheClientItem *this)
{
  unsigned __int8 **v2; // rdi
  void *v3; // rcx
  const struct _CERT_CONTEXT *v4; // rcx

  v2 = (unsigned __int8 **)((char *)this + 400);
  v3 = (void *)*((_QWORD *)this + 50);
  if ( v3 )
  {
    SPExternalFree(v3);
    *v2 = 0i64;
    *((_DWORD *)this + 102) = 0;
  }
  v4 = (const struct _CERT_CONTEXT *)*((_QWORD *)this + 6);
  if ( v4 )
    return GetCertEndpointBindings(v4, v2, (unsigned int *)this + 102);
  else
    return 0;
}

//----- (000000018005DB20) ----------------------------------------------------
__int64 __fastcall ComputeIssuerCacheIndex(unsigned __int8 *a1, unsigned int a2)
{
  __int64 result; // rax
  unsigned __int8 *v3; // r8
  __int64 v4; // r9
  int v5; // ecx

  result = 0i64;
  v3 = a1;
  if ( a1 )
  {
    if ( a2 )
    {
      v4 = a2;
      do
      {
        v5 = *v3++;
        LODWORD(result) = (v5 ^ 0x55) + result;
        --v4;
      }
      while ( v4 );
    }
    return (unsigned int)result % dword_1800926FC;
  }
  return result;
}
// 1800926FC: using guessed type int dword_1800926FC;

//----- (000000018005DB58) ----------------------------------------------------
void __fastcall SPAddIssuerToCache(unsigned __int8 *a1, unsigned int a2)
{
  size_t v2; // rbx
  __int64 v4; // rbp
  DWORD TickCount; // r14d
  _QWORD *v6; // rdi
  HLOCAL v7; // rax
  char *v8; // rax
  char *v9; // rdx
  char **v10; // rcx
  _QWORD *v11; // rax
  _QWORD *v12; // rdx

  if ( a1 )
  {
    v2 = a2;
    if ( a2 )
    {
      if ( dword_180092778 )
      {
        if ( !(unsigned int)SPFindIssuerInCache(a1, a2) )
        {
          v4 = (unsigned int)ComputeIssuerCacheIndex(a1, v2) % dword_1800926FC;
          TickCount = GetTickCount();
          v6 = SPExternalAlloc(0x38u);
          if ( v6 )
          {
            v7 = SPExternalAlloc(v2);
            v6[1] = v7;
            if ( v7 )
            {
              *((_DWORD *)v6 + 4) = v2;
              memcpy_0(v7, a1, v2);
              *(_DWORD *)v6 = TickCount;
              RtlAcquireResourceExclusive(&stru_180092718, 1u);
              v8 = (char *)(v6 + 3);
              v9 = (char *)IssuerCache + 16 * v4;
              v10 = (char **)*((_QWORD *)v9 + 1);
              if ( *v10 != v9
                || (*(_QWORD *)v8 = v9,
                    v6[4] = v10,
                    *v10 = v8,
                    *((_QWORD *)v9 + 1) = v8,
                    v11 = v6 + 5,
                    v12 = (_QWORD *)qword_180092710,
                    *(__int64 **)qword_180092710 != &qword_180092708) )
              {
                __fastfail(3u);
              }
              *v11 = &qword_180092708;
              v6[6] = v12;
              *v12 = v11;
              ++dword_180092704;
              qword_180092710 = (__int64)(v6 + 5);
              RtlReleaseResource(&stru_180092718);
            }
            else
            {
              SPExternalFree(v6);
            }
          }
        }
      }
    }
  }
}
// 1800926FC: using guessed type int dword_1800926FC;
// 180092704: using guessed type int dword_180092704;
// 180092708: using guessed type __int64 qword_180092708;
// 180092710: using guessed type __int64 qword_180092710;
// 180092778: using guessed type int dword_180092778;

//----- (000000018005DCA8) ----------------------------------------------------
void __fastcall SPDeleteIssuerEntry(struct ISSUER_CACHE_ENTRY *a1)
{
  void *v2; // rcx

  if ( a1 )
  {
    v2 = (void *)*((_QWORD *)a1 + 1);
    if ( v2 )
      SPExternalFree(v2);
    SPExternalFree(a1);
  }
}

//----- (000000018005DCD8) ----------------------------------------------------
__int64 __fastcall SPFindIssuerInCache(unsigned __int8 *Buf1, unsigned int a2)
{
  unsigned int v2; // edi
  size_t v3; // rsi
  __int64 v5; // r14
  unsigned int TickCount; // r15d
  _QWORD **v7; // r14
  _QWORD *v8; // rbx
  unsigned int v9; // ecx
  __int64 v10; // r9

  v2 = 0;
  v3 = a2;
  if ( !Buf1 || !a2 || !dword_180092778 )
    return 0i64;
  v5 = (unsigned int)ComputeIssuerCacheIndex(Buf1, a2) % dword_1800926FC;
  TickCount = GetTickCount();
  RtlAcquireResourceShared(&stru_180092718, 1u);
  v7 = (_QWORD **)((char *)IssuerCache + 16 * v5);
  v8 = *v7;
  while ( v8 != v7 )
  {
    v9 = *((_DWORD *)v8 - 6);
    v8 = (_QWORD *)*v8;
    if ( !HasTimeElapsed(v9, TickCount, dword_1800926F8)
      && (_DWORD)v3 == *(_DWORD *)(v10 + 16)
      && !memcmp_0(Buf1, *(const void **)(v10 + 8), v3) )
    {
      v2 = 1;
      break;
    }
  }
  RtlReleaseResource(&stru_180092718);
  return v2;
}
// 18005DD7A: variable 'v10' is possibly undefined
// 1800926FC: using guessed type int dword_1800926FC;
// 180092778: using guessed type int dword_180092778;

//----- (000000018005DDD0) ----------------------------------------------------
void SPPurgeIssuerCache(void)
{
  __int64 *v0; // rbx
  __int64 *v1; // r9
  __int64 *v2; // rcx
  __int64 v3; // rdx
  __int64 **v4; // r8
  __int64 v5; // rdx
  __int64 **v6; // rax

  if ( dword_180092778 && dword_180092704 )
  {
    RtlAcquireResourceExclusive(&stru_180092718, 1u);
    v0 = (__int64 *)qword_180092708;
    while ( v0 != &qword_180092708 )
    {
      v1 = v0 - 5;
      v2 = v0;
      v0 = (__int64 *)*v0;
      v3 = v1[3];
      if ( *(__int64 **)(v3 + 8) != v1 + 3
        || (v4 = (__int64 **)v1[4], *v4 != v1 + 3)
        || (*v4 = (__int64 *)v3, *(_QWORD *)(v3 + 8) = v4, v5 = *v2, *(__int64 **)(*v2 + 8) != v2)
        || (v6 = (__int64 **)v2[1], *v6 != v2) )
      {
        __fastfail(3u);
      }
      *v6 = (__int64 *)v5;
      *(_QWORD *)(v5 + 8) = v6;
      --dword_180092704;
      SPDeleteIssuerEntry((struct ISSUER_CACHE_ENTRY *)v1);
    }
    RtlReleaseResource(&stru_180092718);
  }
}
// 180092704: using guessed type int dword_180092704;
// 180092708: using guessed type __int64 qword_180092708;
// 180092778: using guessed type int dword_180092778;

//----- (000000018005DE98) ----------------------------------------------------
void ShutdownIssuerCache(void)
{
  void *v0; // rcx
  __int64 *v1; // rbx
  struct ISSUER_CACHE_ENTRY *v2; // rcx

  if ( dword_180092778 )
    RtlAcquireResourceExclusive(&stru_180092718, 1u);
  v0 = IssuerCache;
  if ( IssuerCache )
  {
    v1 = (__int64 *)qword_180092708;
    if ( (__int64 *)qword_180092708 != &qword_180092708 )
    {
      do
      {
        v2 = (struct ISSUER_CACHE_ENTRY *)(v1 - 5);
        v1 = (__int64 *)*v1;
        SPDeleteIssuerEntry(v2);
      }
      while ( v1 != &qword_180092708 );
      v0 = IssuerCache;
    }
    SPExternalFree(v0);
    IssuerCache = 0i64;
  }
  if ( dword_180092778 )
  {
    RtlDeleteResource(&stru_180092718);
    dword_180092778 = 0;
  }
}
// 180092708: using guessed type __int64 qword_180092708;
// 180092778: using guessed type int dword_180092778;

//----- (000000018005DF3C) ----------------------------------------------------
__int64 __fastcall CSslLookasidePreallocate::CSslLookasidePreallocate(__int64 a1, int a2, int a3)
{
  SIZE_T v6; // rdx
  struct _SYSTEM_INFO SystemInfo; // [rsp+40h] [rbp-38h] BYREF

  CSslLookaside::CSslLookaside(a1, a2, 1);
  *(_QWORD *)(a1 + 96) = 0i64;
  *(_DWORD *)(a1 + 112) = 0;
  *(_QWORD *)a1 = &CSslLookasidePreallocate::`vftable';
  GetSystemInfo(&SystemInfo);
  InitializeSListHead((PSLIST_HEADER)(a1 + 80));
  v6 = ~(SystemInfo.dwPageSize - 1) & (a3 * a2 + SystemInfo.dwPageSize - 1);
  *(_DWORD *)(a1 + 104) = v6;
  *(_DWORD *)(a1 + 108) = (a2 + 23) & 0xFFFFFFF8;
  *(_QWORD *)(a1 + 96) = VirtualAlloc(0i64, v6, 0x3000u, 4u);
  return a1;
}
// 18007FCF8: using guessed type void *CSslLookasidePreallocate::`vftable';

//----- (000000018005DFE8) ----------------------------------------------------
void __fastcall CSslLookaside::~CSslLookaside(CSslLookaside *this)
{
  bool v1; // zf
  union _SLIST_HEADER *i; // rcx
  PSLIST_ENTRY v4; // rax

  v1 = *((_BYTE *)this + 32) == 0;
  *(_QWORD *)this = &CSslLookaside::`vftable';
  if ( !v1 )
  {
    for ( i = (union _SLIST_HEADER *)((char *)this + 16); ; i = (union _SLIST_HEADER *)((char *)this + 16) )
    {
      v4 = InterlockedPopEntrySList(i);
      if ( !v4 )
        break;
      SPExternalFree(v4);
    }
  }
  InterlockedFlushSList((PSLIST_HEADER)this + 1);
  *(_QWORD *)this = &IAllocate::`vftable';
}
// 18007C298: using guessed type void *IAllocate::`vftable';
// 18007D428: using guessed type void *CSslLookaside::`vftable';

//----- (000000018005E054) ----------------------------------------------------
void __fastcall CSslLookasidePreallocate::~CSslLookasidePreallocate(CSslLookasidePreallocate *this)
{
  void *v2; // rcx

  *(_QWORD *)this = &CSslLookasidePreallocate::`vftable';
  v2 = (void *)*((_QWORD *)this + 12);
  if ( v2 )
    VirtualFree(v2, 0i64, 0x8000u);
  CSslLookaside::~CSslLookaside(this);
}
// 18007FCF8: using guessed type void *CSslLookasidePreallocate::`vftable';

//----- (000000018005E0A0) ----------------------------------------------------
CSslLookaside *__fastcall CSslLookaside::`vector deleting destructor'(CSslLookaside *this, char a2)
{
  CSslLookaside::~CSslLookaside(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (000000018005E0E0) ----------------------------------------------------
CSslLookasidePreallocate *__fastcall CSslLookasidePreallocate::`scalar deleting destructor'(
        CSslLookasidePreallocate *this,
        char a2)
{
  CSslLookasidePreallocate::~CSslLookasidePreallocate(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (000000018005E120) ----------------------------------------------------
struct _SLIST_ENTRY *__fastcall CSslLookasidePreallocate::Allocate(CSslLookasidePreallocate *this)
{
  PSLIST_ENTRY v3; // rdi
  unsigned __int32 v4; // edx
  int v5; // ecx

  if ( !*((_QWORD *)this + 12) )
    return 0i64;
  v3 = InterlockedPopEntrySList((PSLIST_HEADER)this + 5);
  if ( !v3 )
  {
    v4 = _InterlockedExchangeAdd((volatile signed __int32 *)this + 28, *((_DWORD *)this + 27));
    v5 = *((_DWORD *)this + 27);
    if ( v5 + v4 > *((_DWORD *)this + 26) )
    {
      _InterlockedExchangeAdd((volatile signed __int32 *)this + 28, -v5);
      return CSslLookaside::Allocate(this);
    }
    v3 = (PSLIST_ENTRY)(*((_QWORD *)this + 12) + v4);
  }
  memset_0(&v3[1], 0, *((unsigned int *)this + 27) - 16i64);
  return v3 + 1;
}

//----- (000000018005E1B0) ----------------------------------------------------
char *__fastcall CSslScratchAllocator::Allocate(CSslScratchAllocator *this, unsigned __int64 a2, char a3)
{
  unsigned __int16 v4; // ax
  unsigned __int16 *v5; // r8
  __int64 v7; // r11
  char *v8; // rcx

  if ( a2 > 0xFFFF )
    return 0i64;
  v4 = a2 + *((_WORD *)this + 10);
  if ( v4 < (unsigned __int16)a2 )
    return 0i64;
  v5 = (unsigned __int16 *)*((_QWORD *)this + 1);
  *((_WORD *)this + 10) = v4;
  if ( !v5 )
    return (char *)SPExternalAlloc((unsigned __int16)a2);
  v7 = *v5;
  if ( v5[1] - (int)v7 <= (unsigned __int16)a2 )
    return (char *)SPExternalAlloc((unsigned __int16)a2);
  if ( a3 )
  {
    v5[1] -= a2;
    v8 = (char *)(*((_QWORD *)this + 1) + *(unsigned __int16 *)(*((_QWORD *)this + 1) + 2i64));
  }
  else
  {
    *v5 = a2 + v7;
    v8 = (char *)v5 + v7;
  }
  return v8 + 4;
}

//----- (000000018005E240) ----------------------------------------------------
void __fastcall CSslLookasidePreallocate::Deallocate(union _SLIST_HEADER *this, struct _SLIST_ENTRY *a2)
{
  if ( a2
    && (unsigned __int64)a2 >= this[6].Alignment
    && (unsigned __int64)a2 < this[6].Alignment + *((unsigned int *)&this[6].HeaderX64 + 2) )
  {
    InterlockedPushEntrySList(this + 5, a2 - 1);
  }
  else
  {
    CSslLookaside::Deallocate((CSslLookaside *)this, a2);
  }
}

//----- (000000018005E280) ----------------------------------------------------
void __fastcall CSslScratchAllocator::Deallocate(CSslScratchAllocator *this, void *a2)
{
  unsigned __int64 v2; // r8

  v2 = *((_QWORD *)this + 1);
  if ( !v2 || (unsigned __int64)a2 < v2 || (unsigned __int64)a2 > v2 + *((unsigned __int16 *)this + 8) )
    SPExternalFree(a2);
}

//----- (000000018005E2C0) ----------------------------------------------------
void __fastcall CSslScratchAllocator::Reset(CSslScratchAllocator *this)
{
  unsigned __int16 v1; // ax
  unsigned __int16 *v3; // rcx

  v1 = *((_WORD *)this + 10);
  if ( v1 > *((_WORD *)this + 9) )
    *((_WORD *)this + 9) = v1;
  *((_WORD *)this + 10) = 0;
  v3 = (unsigned __int16 *)*((_QWORD *)this + 1);
  if ( v3 )
  {
    memset_0(v3 + 2, 0, *v3);
    **((_WORD **)this + 1) = 0;
    *((_WORD *)this + 10) = *((_WORD *)this + 8) - *(_WORD *)(*((_QWORD *)this + 1) + 2i64) - 4;
  }
}

//----- (000000018005E328) ----------------------------------------------------
char __fastcall CTlsSignatureSuiteList::FindMinimumHashToSignRow(
        CTlsSignatureSuiteList *this,
        enum _eTlsSignatureAlgorithm a2,
        unsigned int a3,
        int a4,
        unsigned int a5)
{
  _DWORD *v5; // r10
  unsigned __int8 v6; // bl
  unsigned __int8 v8; // r11
  char v12; // di
  __int64 v13; // rsi
  int v14; // eax
  unsigned __int8 v15; // r8

  v5 = &unk_18007C3A8;
  v6 = 0;
  v8 = 0;
  v12 = -1;
  v13 = 12i64;
  do
  {
    if ( v5[1] == a2 && (a4 & *v5) != 0 && v8 < 0xCu )
    {
      v14 = *((unsigned __int16 *)this + 17);
      if ( _bittest(&v14, v8) )
      {
        if ( IsSignatureKeySizeSufficient(a2, a3, *((unsigned __int8 *)v5 + 32), v5[9])
          && ((a4 & 0x3000) == 0 || v5[1] != 3 || v5[10] == a5)
          && (v15 < v6 && v15 > 0x14u || v6 <= 0x14u) )
        {
          v12 = v8;
          v6 = v15;
        }
      }
    }
    v5 += 18;
    ++v8;
    --v13;
  }
  while ( v13 );
  return v12;
}
// 18005E3A9: variable 'v5' is possibly undefined
// 18005E3B9: variable 'v15' is possibly undefined
// 18005E3C6: variable 'v8' is possibly undefined

//----- (000000018005E400) ----------------------------------------------------
__int64 __fastcall CTlsSignatureSuiteList::GetMinimumCodePointToSign(
        CTlsSignatureSuiteList *this,
        enum _eTlsSignatureAlgorithm a2,
        unsigned int a3,
        int a4,
        unsigned int a5)
{
  unsigned __int16 v5; // bx
  unsigned __int8 MinimumHashToSignRow; // al

  v5 = 0;
  MinimumHashToSignRow = CTlsSignatureSuiteList::FindMinimumHashToSignRow(this, a2, a3, a4, a5);
  if ( MinimumHashToSignRow < 0xCu )
    return *((unsigned __int16 *)&unk_18007C390 + 36 * MinimumHashToSignRow);
  return v5;
}

//----- (000000018005E43C) ----------------------------------------------------
bool __fastcall IsSignatureKeySizeSufficient(enum _eTlsSignatureAlgorithm a1, unsigned int a2, int a3, int a4)
{
  return a1 != TlsSignatureAlgorithm_Rsa || a4 != 8 || a2 >> 3 >= 2 * a3 + 2;
}

//----- (000000018005E464) ----------------------------------------------------
unsigned __int8 __fastcall CTlsSignatureSuiteList::IsSupportedSignatureKey(
        CTlsSignatureSuiteList *this,
        int a2,
        unsigned int a3,
        int a4,
        unsigned int a5)
{
  int v8; // edx
  int v9; // edx
  int v10; // edx
  enum _eTlsSignatureAlgorithm v11; // r11d
  _DWORD *v12; // r10
  unsigned __int8 i; // bl
  int v14; // eax

  v8 = a2 - 8704;
  if ( v8 )
  {
    v9 = v8 - 3;
    if ( v9 )
    {
      v10 = v9 - 509;
      if ( v10 && v10 != 0x8000 )
        return 0;
      v11 = TlsSignatureAlgorithm_Rsa;
    }
    else
    {
      v11 = TlsSignatureAlgorithm_Ecdsa;
    }
  }
  else
  {
    v11 = TlsSignatureAlgorithm_Dsa;
  }
  v12 = &unk_18007C3A8;
  for ( i = 0; ; ++i )
  {
    if ( v12[1] == v11
      && (a4 & *v12) != 0
      && (!a3 || IsSignatureKeySizeSufficient(v11, a3, *((unsigned __int8 *)v12 + 32), v12[9]))
      && ((a4 & 0x3000) == 0 || v12[1] != 3 || v12[10] == a5)
      && i < 0xCu )
    {
      v14 = *((unsigned __int16 *)this + 17);
      if ( _bittest(&v14, i) )
        break;
    }
    v12 += 18;
    if ( v12 - 6 >= (_DWORD *)&CSsl3TlsServerContext::`vftable' )
      return 0;
  }
  return 1;
}
// 18005E4CE: variable 'v11' is possibly undefined
// 18005E4F8: variable 'v12' is possibly undefined
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';

//----- (000000018005E558) ----------------------------------------------------
__int64 __fastcall CTlsSignatureSuiteList::ParseSupportedSignatureAlgorithmsAndSet(
        CTlsSignatureSuiteList *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned int *a4)
{
  unsigned __int8 *v6; // r11
  unsigned int v7; // r10d
  unsigned int v8; // ecx
  __int64 v9; // rdi
  unsigned __int8 SignatureSuiteInfoRowByCodePoint; // al
  int v11; // r10d
  __int64 v12; // r11

  if ( !a2 )
    return 2148074278i64;
  if ( a3 < 2 )
    return 2148074278i64;
  *(_WORD *)this = 0;
  v6 = a2 + 2;
  *((_WORD *)this + 17) = 0;
  v7 = a2[1] | (*a2 << 8);
  v8 = v7 >> 1;
  if ( v7 > a3 - 2 || (v7 & 1) != 0 || v8 - 1 > 0x4F )
    return 2148074278i64;
  if ( !v8 )
    return 2148074289i64;
  v9 = v8;
  do
  {
    SignatureSuiteInfoRowByCodePoint = GetSignatureSuiteInfoRowByCodePoint(*v6 | (v6[1] << 8));
    CTlsSignatureSuiteList::AddSignatureSuite(this, SignatureSuiteInfoRowByCodePoint);
    v6 = (unsigned __int8 *)(v12 + 2);
    --v9;
  }
  while ( v9 );
  if ( !*(_WORD *)this )
    return 2148074289i64;
  *a4 = v11 + 2;
  return 0i64;
}
// 18005E5E1: variable 'v12' is possibly undefined
// 18005E5F0: variable 'v11' is possibly undefined

//----- (000000018005E624) ----------------------------------------------------
void __fastcall CTlsSignatureSuiteList::SetDefaultClientHello(CTlsSignatureSuiteList *this)
{
  unsigned __int8 v1; // r11
  void **v2; // r10

  v1 = 0;
  v2 = (void **)&unk_18007C390;
  *(_WORD *)this = 0;
  *((_WORD *)this + 17) = 0;
  do
  {
    if ( *((_DWORD *)v2 + 10) == 2 )
      CTlsSignatureSuiteList::AddSignatureSuite(this, v1);
    v2 += 9;
    ++v1;
  }
  while ( v2 < &CSsl3TlsServerContext::`vftable' );
}
// 18005E652: variable 'v2' is possibly undefined
// 18005E65D: variable 'v1' is possibly undefined
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';

//----- (000000018005E674) ----------------------------------------------------
void TlsCloseBCryptHashProviders(void)
{
  int v0; // eax
  int v1; // edi
  BCRYPT_ALG_HANDLE *v2; // rbx

  v0 = g_dwHashInfoTotalCount;
  v1 = 1;
  if ( g_dwHashInfoTotalCount > 1 )
  {
    v2 = (BCRYPT_ALG_HANDLE *)&unk_180092CF8;
    do
    {
      if ( *v2 )
      {
        BCryptCloseAlgorithmProvider(*v2, 0);
        *v2 = 0i64;
        v0 = g_dwHashInfoTotalCount;
      }
      ++v1;
      ++v2;
    }
    while ( v1 < v0 );
  }
}
// 180092324: using guessed type int g_dwHashInfoTotalCount;

//----- (000000018005E6D0) ----------------------------------------------------
CSslCredential *__fastcall CSslCredential::CSslCredential(CSslCredential *this)
{
  char v2; // r9
  char v3; // r8
  char v4; // dl

  CSslBasicAllocator::CSslBasicAllocator(this);
  *(_QWORD *)this = &CSslCredential::`vftable';
  *((_BYTE *)this + 77) = v2;
  *((_BYTE *)this + 78) = v3;
  *((_BYTE *)this + 79) = v4;
  *((_BYTE *)this + 80) = 0;
  *((_DWORD *)this + 31) = 1;
  *((_DWORD *)this + 32) = 1;
  *(_OWORD *)((char *)this + 514) = 0i64;
  *(_OWORD *)((char *)this + 530) = 0i64;
  *((_WORD *)this + 256) = 0;
  *((_WORD *)this + 273) = 0;
  *(_QWORD *)((char *)this + 652) = 0i64;
  memset_0((char *)this + 660, 0, 0x204ui64);
  RtlInitializeResource((PRTL_RESOURCE)((char *)this + 552));
  *((_BYTE *)this + 648) = 1;
  *((_QWORD *)this + 61) = (char *)this + 480;
  *((_QWORD *)this + 60) = (char *)this + 480;
  return this;
}
// 18005E6EC: variable 'v2' is possibly undefined
// 18005E6F0: variable 'v3' is possibly undefined
// 18005E6F4: variable 'v4' is possibly undefined
// 18007FD20: using guessed type void *CSslCredential::`vftable';

//----- (000000018005E790) ----------------------------------------------------
void __fastcall CSslCredential::~CSslCredential(CSslCredential *this)
{
  *(_QWORD *)this = &CSslCredential::`vftable';
  CSslCredential::DeleteCredential(this);
  *(_QWORD *)this = &IAllocate::`vftable';
}
// 18007C298: using guessed type void *IAllocate::`vftable';
// 18007FD20: using guessed type void *CSslCredential::`vftable';

//----- (000000018005E7C0) ----------------------------------------------------
void __fastcall CSslServerKey::~CSslServerKey(CSslServerKey *this)
{
  CCipherMill *v2; // rcx

  *(_QWORD *)this = &CSslServerKey::`vftable';
  v2 = (CCipherMill *)*((_QWORD *)this + 1);
  if ( v2 )
  {
    SslFreeObject(v2, 0i64);
    *((_QWORD *)this + 1) = 0i64;
  }
  if ( *((_QWORD *)this + 2) )
  {
    CCipherMill::DeferenceProvider(v2, (unsigned __int64 *)this + 2);
    *((_QWORD *)this + 2) = 0i64;
  }
  *(_QWORD *)this = &IAllocate::`vftable';
}
// 18005E800: variable 'v2' is possibly undefined
// 18007C298: using guessed type void *IAllocate::`vftable';
// 18007D568: using guessed type void *CSslServerKey::`vftable';
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018005E830) ----------------------------------------------------
CSslCredential *__fastcall CSslCredential::`vector deleting destructor'(CSslCredential *this, char a2)
{
  CSslCredential::~CSslCredential(this);
  if ( (a2 & 1) != 0 )
    SPExternalFree(this);
  return this;
}

//----- (000000018005E870) ----------------------------------------------------
CSslServerKey *__fastcall CSslServerKey::`vector deleting destructor'(CSslServerKey *this, char a2)
{
  CSslServerKey::~CSslServerKey(this);
  if ( (a2 & 1) != 0 )
    SPExternalFree(this);
  return this;
}

//----- (000000018005E8A8) ----------------------------------------------------
__int64 __fastcall CSslCredential::CreateCredential(
        CSslCredential *this,
        int a2,
        char *a3,
        __int64 a4,
        struct LSA_SCHANNEL_SUB_CRED *a5,
        char a6,
        unsigned __int8 a7,
        int a8,
        struct _TLS_PARAMETERS *a9,
        unsigned int a10)
{
  void *v14; // r12
  char v15; // r11
  CCipherMill *v16; // rcx
  const struct _CERT_CONTEXT *v18; // rax
  DWORD LastError; // eax
  unsigned int PublicKeyFromCert; // ebx
  const CERT_CONTEXT *v21; // rcx
  void *v22; // rcx
  CCipherMill *v23; // rcx
  __int64 v24; // rdx
  NTSTATUS v25; // ebx
  ULONG v26; // eax
  __int64 v27; // r8
  __int64 v28; // r9
  DWORD PublicKeyLength; // eax
  PCCERT_CHAIN_CONTEXT *v30; // r13
  __int64 v31; // rcx
  __int64 v32; // r8
  __int64 v33; // r9
  int v34; // eax
  unsigned int v35; // eax
  __int64 v36; // rcx
  char v37; // al
  __int64 v38; // r8
  __int64 v39; // r9
  DWORD v40; // eax
  DWORD dwError; // eax
  struct _CERT_SERVER_OCSP_RESPONSE_OPEN_PARA *p_pOpenPara; // r8
  HCERT_SERVER_OCSP_RESPONSE v43; // rax
  DWORD v44; // eax
  bool v45; // r15
  unsigned int v46; // eax
  unsigned int v47; // eax
  const struct _CERT_CONTEXT *v48; // rcx
  const wchar_t *v49; // rcx
  CCipherMill *v50; // rcx
  unsigned __int8 v51; // cl
  int v52; // r8d
  unsigned __int8 v53; // al
  unsigned int v54; // r9d
  PCERT_CHAIN_PARA pChainPara; // [rsp+20h] [rbp-168h]
  DWORD pChainParaa; // [rsp+20h] [rbp-168h]
  int v57; // [rsp+60h] [rbp-128h] BYREF
  unsigned int v58; // [rsp+64h] [rbp-124h] BYREF
  struct CEccCurveInfo *v59; // [rsp+68h] [rbp-120h] BYREF
  struct _TLS_PARAMETERS *v60; // [rsp+70h] [rbp-118h]
  struct _CERT_CHAIN_POLICY_PARA pPolicyPara; // [rsp+78h] [rbp-110h] BYREF
  int v62[4]; // [rsp+88h] [rbp-100h] BYREF
  __int64 v63; // [rsp+98h] [rbp-F0h]
  struct _CERT_CHAIN_POLICY_STATUS pPolicyStatus; // [rsp+A0h] [rbp-E8h] BYREF
  struct _CERT_SERVER_OCSP_RESPONSE_OPEN_PARA pOpenPara; // [rsp+B8h] [rbp-D0h] BYREF
  struct _CERT_CHAIN_PARA v66; // [rsp+E0h] [rbp-A8h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v67; // [rsp+140h] [rbp-48h] BYREF

  v60 = a9;
  v14 = 0i64;
  memset_0(&v66, 0, 0x60ui64);
  v15 = 0;
  *((_DWORD *)this + 163) = a2;
  v57 = 0;
  v59 = 0i64;
  v63 = 0i64;
  pPolicyPara = 0i64;
  *(_OWORD *)v62 = 0i64;
  memset(&pPolicyStatus, 0, sizeof(pPolicyStatus));
  if ( a3 )
  {
    StringCchCopyW((char *)this + 656, 260i64, a3);
    goto LABEL_6;
  }
  v16 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids);
    v15 = 0;
LABEL_6:
    v16 = WPP_GLOBAL_Control;
  }
  if ( *((_BYTE *)this + 648) == v15 )
    return 14i64;
  if ( !a5 )
  {
    if ( v16 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v16 + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)v16 + 2), 11i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids);
    return 87i64;
  }
  if ( (*((_BYTE *)a5 + 48) & 1) != 0 )
    *((_DWORD *)this + 6) |= 0x20u;
  v18 = CertDuplicateCertificateContext(*(PCCERT_CONTEXT *)a5);
  *((_QWORD *)this + 4) = v18;
  if ( !v18 )
  {
    *((_DWORD *)this + 18) = 10004;
    LastError = GetLastError();
    PublicKeyFromCert = LastError;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids, LastError);
    goto LABEL_20;
  }
  PublicKeyFromCert = GetPublicKeyFromCert(v18, (struct _PUBLICKEY **)this + 54, (unsigned int *)this + 33);
  if ( PublicKeyFromCert )
  {
    *((_DWORD *)this + 18) = 10005;
    v23 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      goto LABEL_21;
    v24 = 13i64;
    goto LABEL_32;
  }
  v25 = BCryptHash(
          49i64,
          0i64,
          0i64,
          *(_QWORD *)(*((_QWORD *)this + 4) + 8i64),
          *(_DWORD *)(*((_QWORD *)this + 4) + 16i64),
          (char *)this + 40,
          20);
  if ( v25 < 0 )
  {
    *((_DWORD *)this + 18) = 10016;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        14i64,
        &WPP_221bc911720835f3baa7a86739b227e3_Traceguids,
        (unsigned int)v25);
    v26 = RtlNtStatusToDosError(v25);
    goto LABEL_38;
  }
  PublicKeyFromCert = CSslCredential::GetPrivateFromCert(this, a4, a5);
  if ( PublicKeyFromCert )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        15i64,
        &WPP_221bc911720835f3baa7a86739b227e3_Traceguids,
        PublicKeyFromCert);
    *((_BYTE *)this + 76) = 1;
    goto LABEL_21;
  }
  if ( *((_BYTE *)this + 79) )
  {
    PublicKeyFromCert = GetCertEndpointBindings(
                          *((const struct _CERT_CONTEXT **)this + 4),
                          (unsigned __int8 **)this + 58,
                          (unsigned int *)this + 118);
    if ( PublicKeyFromCert )
    {
      *((_DWORD *)this + 18) = 10015;
      v23 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        goto LABEL_21;
      v24 = 16i64;
LABEL_32:
      WPP_SF_D(*((_QWORD *)v23 + 2), v24, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids, PublicKeyFromCert);
      goto LABEL_21;
    }
  }
  PublicKeyFromCert = SslImpersonateClient(a4, &v57);
  if ( PublicKeyFromCert )
    goto LABEL_21;
  if ( *((_DWORD *)this + 33) == 8707 )
  {
    PublicKeyLength = CertGetPublicKeyLength(
                        1u,
                        (PCERT_PUBLIC_KEY_INFO)(*(_QWORD *)(*((_QWORD *)this + 4) + 24i64) + 96i64));
    *((_DWORD *)this + 34) = PublicKeyLength;
    if ( !PublicKeyLength )
    {
      *((_DWORD *)this + 18) = 10006;
      v26 = GetLastError();
LABEL_38:
      PublicKeyFromCert = v26;
      goto LABEL_20;
    }
    PublicKeyFromCert = CertGetEccCurveType(*((_QWORD *)this + 4), (unsigned int *)this + 35);
    if ( PublicKeyFromCert )
    {
      *((_DWORD *)this + 18) = 10006;
      goto LABEL_21;
    }
  }
  if ( (a6 & 1) != 0 || a8 )
    v14 = *(void **)(*((_QWORD *)this + 4) + 32i64);
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EventWriteTransfer(0i64, &ChainBuildStart, v27, v28, &v67);
  v30 = (PCCERT_CHAIN_CONTEXT *)((char *)this + 64);
  if ( !CertGetCertificateChain(
          0i64,
          *((PCCERT_CONTEXT *)this + 4),
          0i64,
          v14,
          &v66,
          a6 & 4,
          0i64,
          (PCCERT_CHAIN_CONTEXT *)this + 8) )
  {
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McGenEventWrite_EventWriteTransfer(v31, &ChainBuildStop, v32, v33, &v67);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      v34 = GetLastError();
      LODWORD(pChainPara) = a6 & 4;
      WPP_SF_Dd(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x11u,
        (__int64)&WPP_221bc911720835f3baa7a86739b227e3_Traceguids,
        v34,
        pChainPara);
    }
    *v30 = 0i64;
    v35 = GetLastError();
    LogGetCertificateChainFailureEvent(
      *((_DWORD *)this + 163),
      (const unsigned __int16 *)this + 328,
      *((_BYTE *)this + 79),
      *((const struct _CERT_CONTEXT **)this + 4),
      v35,
      a6 & 4);
    goto LABEL_84;
  }
  v37 = Microsoft_Windows_Schannel_EventsEnableBits;
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
  {
    McGenEventWrite_EventWriteTransfer(v31, &ChainBuildStop, v32, v33, &v67);
    v37 = Microsoft_Windows_Schannel_EventsEnableBits;
  }
  v62[0] = 24;
  pPolicyPara.pvExtraPolicyPara = v62;
  v62[1] = 2;
  v62[2] = 640;
  pPolicyPara.cbSize = 16;
  if ( (v37 & 1) != 0 )
    McGenEventWrite_EventWriteTransfer((__int64)v62, &ChainVerifyStart, v32, v33, &v67);
  if ( !CertVerifyCertificateChainPolicy((LPCSTR)4, *v30, &pPolicyPara, &pPolicyStatus) )
  {
    v36 = (__int64)WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      goto LABEL_76;
    v40 = GetLastError();
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids, v40);
  }
  v36 = (__int64)WPP_GLOBAL_Control;
LABEL_76:
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
  {
    McGenEventWrite_EventWriteTransfer(v36, &ChainVerifyStop, v38, v39, &v67);
    v36 = (__int64)WPP_GLOBAL_Control;
  }
  dwError = pPolicyStatus.dwError;
  if ( pPolicyStatus.dwError )
  {
    if ( (CCipherMill **)v36 != &WPP_GLOBAL_Control && (*(_BYTE *)(v36 + 28) & 1) != 0 )
    {
      WPP_SF_D(*(_QWORD *)(v36 + 16), 19i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids, pPolicyStatus.dwError);
      dwError = pPolicyStatus.dwError;
    }
    v36 = 2148204810i64;
    if ( dwError == -2146762486 )
      LogIncompleteCertificateChainEvent(
        *((_DWORD *)this + 163),
        (const unsigned __int16 *)this + 328,
        *((_BYTE *)this + 79),
        *((const struct _CERT_CONTEXT **)this + 4),
        0x800B010A);
  }
LABEL_84:
  if ( v57 )
  {
    RevertToSelf();
    v57 = 0;
  }
  if ( *((_BYTE *)this + 79) )
  {
    v36 = (__int64)*v30;
    if ( *v30 )
    {
      if ( (a6 & 0x10) == 0 )
      {
        p_pOpenPara = 0i64;
        if ( g_pszOcspReadDirectory )
        {
          pOpenPara.pcbUsedSize = 0i64;
          *(_OWORD *)&pOpenPara.pfnUpdateCallback = 0i64;
          pOpenPara.cbSize = 40;
          p_pOpenPara = &pOpenPara;
          pOpenPara.dwFlags = 1;
          pOpenPara.pwszOcspDirectory = (PWSTR)g_pszOcspReadDirectory;
        }
        v43 = CertOpenServerOcspResponse((PCCERT_CHAIN_CONTEXT)v36, 1u, p_pOpenPara);
        *((_QWORD *)this + 57) = v43;
        if ( !v43
          && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        {
          v44 = GetLastError();
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids, v44);
        }
      }
    }
  }
  v45 = (a6 & 8) != 0;
  v46 = SerializeCertChain(
          v36,
          *((const struct _CERT_CONTEXT **)this + 4),
          *v30,
          v45,
          (unsigned __int8 **)this + 55,
          (unsigned int *)this + 112);
  PublicKeyFromCert = v46;
  if ( v46 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 21i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids, v46);
    *((_DWORD *)this + 18) = 10007;
    goto LABEL_21;
  }
  if ( *((_DWORD *)this + 112) > 0x4000u )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids);
    *((_DWORD *)this + 18) = 10008;
    PublicKeyFromCert = 87;
    goto LABEL_21;
  }
  v47 = CSslCredential::FillInCredStructWithCertInfo(this);
  PublicKeyFromCert = v47;
  if ( v47 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 23i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids, v47);
    *((_DWORD *)this + 18) = 10009;
    goto LABEL_21;
  }
  CTlsSignatureSuiteList::SetCertificateChainSignatureSuites(
    (CSslCredential *)((char *)this + 512),
    *((const struct _CERT_CONTEXT **)this + 4),
    *v30,
    v45);
  v48 = (const struct _CERT_CONTEXT *)*((_QWORD *)this + 4);
  v58 = 64;
  PublicKeyFromCert = GetCngHashAndSignatureString(
                        v48,
                        (unsigned __int16 *)this + 136,
                        &v58,
                        (char *)this + 144,
                        pChainParaa);
  v49 = (const wchar_t *)((char *)this + 144);
  if ( PublicKeyFromCert )
  {
    *v49 = 0;
    *((_WORD *)this + 136) = 0;
    v50 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 24i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids);
  }
  else
  {
    *((_BYTE *)this + 80) = wcscmp_0(v49, L"SHA1") == 0;
  }
  if ( !a10 )
    goto LABEL_20;
  if ( *((_DWORD *)this + 33) == 8707 )
  {
    PublicKeyFromCert = CCipherMill::GetCurveInfo(v50, *((_DWORD *)this + 35), &v59);
    if ( PublicKeyFromCert )
    {
      *((_DWORD *)this + 18) = 10018;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 25i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids);
      goto LABEL_21;
    }
  }
  v51 = *((_BYTE *)this + 79);
  if ( v51 )
  {
    v52 = 41984;
    if ( *((_DWORD *)this + 33) == 41984 )
    {
      v53 = 1;
LABEL_124:
      v54 = *((_DWORD *)this + 107);
      goto LABEL_125;
    }
  }
  v52 = *((_DWORD *)this + 33);
  v53 = 0;
  if ( v52 != 8707 )
    goto LABEL_124;
  v54 = *((_DWORD *)this + 34);
LABEL_125:
  if ( IsCertificateBlacklisted(
         v60,
         a10,
         v52,
         v54,
         v59,
         v53,
         v51,
         (const unsigned __int16 *)this + 72,
         (const unsigned __int16 *)this + 136,
         0i64,
         1) )
  {
    PublicKeyFromCert = -2146893007;
    *((_DWORD *)this + 18) = 10018;
    goto LABEL_21;
  }
LABEL_20:
  if ( PublicKeyFromCert )
  {
LABEL_21:
    v21 = (const CERT_CONTEXT *)*((_QWORD *)this + 4);
    if ( v21 )
    {
      CertFreeCertificateContext(v21);
      *((_QWORD *)this + 4) = 0i64;
    }
    v22 = (void *)*((_QWORD *)this + 54);
    if ( v22 )
    {
      SPExternalFree(v22);
      *((_QWORD *)this + 54) = 0i64;
    }
  }
  if ( v57 )
    RevertToSelf();
  return PublicKeyFromCert;
}
// 18005E9A4: variable 'v15' is possibly undefined
// 18005ED1A: variable 'v27' is possibly undefined
// 18005ED1A: variable 'v28' is possibly undefined
// 18005ED7E: variable 'v31' is possibly undefined
// 18005ED7E: variable 'v32' is possibly undefined
// 18005ED7E: variable 'v33' is possibly undefined
// 18005EDC6: variable 'pChainPara' is possibly undefined
// 18005EF1C: variable 'v38' is possibly undefined
// 18005EF1C: variable 'v39' is possibly undefined
// 18005F080: variable 'v36' is possibly undefined
// 18005F182: variable 'pChainParaa' is possibly undefined
// 18005F210: variable 'v50' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180084C60: using guessed type EVENT_DESCRIPTOR ChainVerifyStop;
// 180084C70: using guessed type EVENT_DESCRIPTOR ChainVerifyStart;
// 180084C80: using guessed type EVENT_DESCRIPTOR ChainBuildStop;
// 180084C90: using guessed type EVENT_DESCRIPTOR ChainBuildStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 180098360: using guessed type __int64 __fastcall BCryptHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);

//----- (000000018005F2E8) ----------------------------------------------------
void __fastcall CSslCredential::DeleteCredential(CSslCredential *this)
{
  void *v2; // rcx
  void *v3; // rcx
  const CERT_CHAIN_CONTEXT *v4; // rcx
  CERT_CONTEXT *v5; // rcx
  CSslCredential *v6; // rcx
  CSslCredential *v7; // rcx
  void **v8; // rsi
  void *v9; // rdi
  void **v10; // rax
  __int64 v11; // rdx
  int v12; // r8d
  NCRYPT_HANDLE v13; // rcx
  void *v14; // rcx
  void *v15; // rcx
  void *v16; // rcx
  void *v17; // rcx

  v2 = (void *)*((_QWORD *)this + 54);
  if ( v2 )
    SPExternalFree(v2);
  v3 = (void *)*((_QWORD *)this + 57);
  if ( v3 )
    CertCloseServerOcspResponse(v3, 0);
  v4 = (const CERT_CHAIN_CONTEXT *)*((_QWORD *)this + 8);
  if ( v4 )
    CertFreeCertificateChain(v4);
  v5 = (CERT_CONTEXT *)*((_QWORD *)this + 4);
  if ( v5 )
    CertFreeCertificateContext(v5);
  CSslCredential::ReleaseEphemeralKeyData((CSslCredential *)v5, *((struct CEphemKeyData **)this + 62));
  CSslCredential::ReleaseEphemeralKeyData(v6, *((struct CEphemKeyData **)this + 63));
  v8 = (void **)((char *)this + 480);
  while ( 1 )
  {
    v9 = *v8;
    if ( *v8 == v8 )
      break;
    if ( *((void ***)v9 + 1) != v8 || (v10 = *(void ***)v9, *(void **)(*(_QWORD *)v9 + 8i64) != v9) )
      __fastfail(3u);
    *v8 = v10;
    v10[1] = v8;
    CSslCredential::ReleaseEphemeralKeyData(v7, *((struct CEphemKeyData **)v9 + 3));
    LocalFree(v9);
  }
  CSslCredential::DeleteLocalServerKeys(this);
  if ( !*((_BYTE *)this + 120) )
    CSslCredential::RemoteCloseKeyHandle(this, v11, v12);
  if ( !*((_BYTE *)this + 78) )
  {
    v13 = *((_QWORD *)this + 13);
    if ( v13 )
      NCryptFreeObject(v13);
  }
  v14 = (void *)*((_QWORD *)this + 55);
  if ( v14 )
    SPExternalFree(v14);
  v15 = (void *)*((_QWORD *)this + 52);
  if ( v15 )
    SPExternalFree(v15);
  v16 = (void *)*((_QWORD *)this + 50);
  if ( v16 )
    SPExternalFree(v16);
  v17 = (void *)*((_QWORD *)this + 58);
  if ( v17 )
    SPExternalFree(v17);
  if ( *((_BYTE *)this + 648) )
    RtlDeleteResource((PRTL_RESOURCE)((char *)this + 552));
}
// 18005F356: variable 'v5' is possibly undefined
// 18005F362: variable 'v6' is possibly undefined
// 18005F390: variable 'v7' is possibly undefined
// 18005F3BE: variable 'v11' is possibly undefined
// 18005F3BE: variable 'v12' is possibly undefined

//----- (000000018005F458) ----------------------------------------------------
void __fastcall CSslCredential::DeleteLocalServerKeys(CSslCredential *this)
{
  void *v2; // rcx

  v2 = (void *)*((_QWORD *)this + 11);
  if ( v2 )
  {
    if ( *((_DWORD *)this + 24) )
    {
      do
        CSslServerKey::Dereference(*(CSslServerKey **)(*((_QWORD *)this + 11)
                                                     + 8i64 * (unsigned int)(*((_DWORD *)this + 24) - 1)));
      while ( (*((_DWORD *)this + 24))-- != 1 );
      v2 = (void *)*((_QWORD *)this + 11);
    }
    SPExternalFree(v2);
    *((_QWORD *)this + 11) = 0i64;
  }
}

//----- (000000018005F4A4) ----------------------------------------------------
__int64 __fastcall CSslCredential::FillInCredStructWithCertInfo(CSslCredential *this)
{
  __int64 v1; // rbx
  DWORD v3; // eax
  DWORD csz; // esi
  WCHAR *v5; // rax
  DWORD LastError; // ebx
  DWORD PublicKeyLength; // eax
  DWORD v8; // eax
  DWORD v9; // esi
  WCHAR *v10; // rax
  void *v11; // rcx
  void *v12; // rcx

  v1 = *((_QWORD *)this + 4);
  v3 = CertNameToStrW(*(_DWORD *)v1, (PCERT_NAME_BLOB)(*(_QWORD *)(v1 + 24) + 48i64), 0x20000003u, 0i64, 0);
  csz = v3;
  if ( !v3 )
    goto LABEL_12;
  *((_DWORD *)this + 106) = 2 * v3;
  v5 = (WCHAR *)SPExternalAlloc(2 * v3);
  *((_QWORD *)this + 52) = v5;
  if ( v5 )
  {
    if ( CertNameToStrW(*(_DWORD *)v1, (PCERT_NAME_BLOB)(*(_QWORD *)(v1 + 24) + 48i64), 0x20000003u, v5, csz) )
    {
      PublicKeyLength = CertGetPublicKeyLength(0x10001u, (PCERT_PUBLIC_KEY_INFO)(*(_QWORD *)(v1 + 24) + 96i64));
      *((_DWORD *)this + 107) = PublicKeyLength;
      if ( !PublicKeyLength )
      {
        LastError = GetLastError();
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            39i64,
            &WPP_221bc911720835f3baa7a86739b227e3_Traceguids,
            LastError);
        goto LABEL_13;
      }
      v8 = CertNameToStrW(*(_DWORD *)v1, (PCERT_NAME_BLOB)(*(_QWORD *)(v1 + 24) + 80i64), 0x20000003u, 0i64, 0);
      v9 = v8;
      if ( v8 )
      {
        *((_DWORD *)this + 102) = 2 * v8;
        v10 = (WCHAR *)SPExternalAlloc(2 * v8);
        *((_QWORD *)this + 50) = v10;
        if ( !v10 )
          goto LABEL_3;
        if ( CertNameToStrW(*(_DWORD *)v1, (PCERT_NAME_BLOB)(*(_QWORD *)(v1 + 24) + 80i64), 0x20000003u, v10, v9) )
          return 0i64;
      }
    }
LABEL_12:
    LastError = GetLastError();
    goto LABEL_13;
  }
LABEL_3:
  LastError = 14;
LABEL_13:
  v11 = (void *)*((_QWORD *)this + 50);
  if ( v11 )
  {
    SPExternalFree(v11);
    *((_QWORD *)this + 50) = 0i64;
  }
  v12 = (void *)*((_QWORD *)this + 52);
  if ( v12 )
  {
    SPExternalFree(v12);
    *((_QWORD *)this + 52) = 0i64;
  }
  return LastError;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018005F670) ----------------------------------------------------
unsigned int __fastcall CSslCredential::GetEccEphemeralKeyInfo(
        CSslCredential *this,
        unsigned int a2,
        struct CEphemKeyData **a3)
{
  unsigned int v4; // esi
  CSslCredential *v5; // rdi
  struct CEphemKeyData **v6; // r8
  struct _RTL_RESOURCE *v7; // r14
  char *v8; // rbx
  char *i; // rax
  struct CEphemKeyData **v10; // rbp
  _DWORD *v11; // rax
  __int64 v13; // rcx

  v4 = a2;
  v5 = this;
  if ( a2 == *((_DWORD *)this + 35) )
  {
    v6 = (struct CEphemKeyData **)((char *)this + 504);
  }
  else
  {
    *a3 = 0i64;
    v7 = (struct _RTL_RESOURCE *)((char *)this + 552);
    RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)this + 552), 1u);
    v8 = (char *)v5 + 480;
    for ( i = (char *)*((_QWORD *)v5 + 60); i != v8; i = *(char **)i )
    {
      if ( *((_DWORD *)i + 4) == v4 )
      {
        v10 = (struct CEphemKeyData **)(i + 24);
        if ( i != (char *)-24i64 )
          goto LABEL_14;
        break;
      }
    }
    v11 = LocalAlloc(0x40u, 0x20ui64);
    if ( !v11 )
    {
      RtlReleaseResource(v7);
      return 14;
    }
    v11[4] = v4;
    *((_QWORD *)v11 + 1) = v11;
    *(_QWORD *)v11 = v11;
    v13 = *(_QWORD *)v8;
    if ( *(char **)(*(_QWORD *)v8 + 8i64) != v8 )
      __fastfail(3u);
    *(_QWORD *)v11 = v13;
    v10 = (struct CEphemKeyData **)(v11 + 6);
    *((_QWORD *)v11 + 1) = v8;
    *(_QWORD *)(v13 + 8) = v11;
    *(_QWORD *)v8 = v11;
LABEL_14:
    RtlReleaseResource(v7);
    v6 = v10;
    a2 = v4;
    this = v5;
  }
  return CSslCredential::GetEphemeralKeyInfo(this, a2, v6, a3);
}

//----- (000000018005F780) ----------------------------------------------------
ULONG __fastcall CSslCredential::GetLocalClientKeyFromProvider(
        NCRYPT_KEY_HANDLE *this,
        struct _CRYPT_KEY_PROV_INFO *a2,
        __int64 a3)
{
  ULONG result; // eax
  unsigned int v6; // ebx
  int v7[6]; // [rsp+40h] [rbp-18h] BYREF
  int v8; // [rsp+78h] [rbp+20h] BYREF

  v8 = 0;
  v7[0] = 0;
  result = SslImpersonateClient(a3, &v8);
  if ( !result )
  {
    v6 = OpenKeyUsingCng(this + 13, a2->pwszContainerName, a2->pwszProvName, a2->dwKeySpec, a2->dwFlags, 0, v7);
    if ( v6 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 27i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids, v6);
      *((_DWORD *)this + 18) = 10002;
    }
    if ( v8 )
      RevertToSelf();
    return v6;
  }
  return result;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 18005F780: using guessed type int var_18[6];

//----- (000000018005F83C) ----------------------------------------------------
ULONG __fastcall CSslCredential::GetLocalServerKeyFromProvider(const struct _CERT_CONTEXT **this, __int64 a2)
{
  __int64 v3; // rsi
  ULONG result; // eax
  CCipherMill *v5; // rcx
  int PrivateKeyFromProvider; // edi
  unsigned int v7; // ebp
  const struct _CERT_CONTEXT *v8; // rax
  struct ProviderToPrivateKey *v9; // r14
  _QWORD *v10; // rax
  _QWORD *v11; // r9
  __int64 v12; // r8
  unsigned __int64 *v13; // rbx
  CCipherMill *v14; // rcx
  struct ProviderToPrivateKey *v15; // [rsp+20h] [rbp-28h] BYREF
  int v16; // [rsp+60h] [rbp+18h] BYREF
  unsigned int v17; // [rsp+68h] [rbp+20h] BYREF

  v16 = 0;
  v15 = 0i64;
  v17 = 0;
  v3 = 0i64;
  result = SslImpersonateClient(a2, &v16);
  if ( result )
    return result;
  PrivateKeyFromProvider = CCipherMill::GetPrivateKeyFromProvider(v5, this[4], &v15, &v17);
  if ( v16 )
    RevertToSelf();
  if ( PrivateKeyFromProvider )
  {
    *((_DWORD *)this + 18) = 10001;
    return -2146893043;
  }
  v7 = v17;
  v8 = (const struct _CERT_CONTEXT *)SPExternalAlloc(8 * v17);
  v9 = v15;
  this[11] = v8;
  if ( v8 )
  {
    if ( v7 )
    {
      while ( 1 )
      {
        v10 = SPExternalAlloc(0x20u);
        v11 = v10;
        if ( v10 )
        {
          v12 = *((_QWORD *)v9 + 2 * (unsigned int)v3);
          v10[1] = *((_QWORD *)v9 + 2 * (unsigned int)v3 + 1);
          v10[2] = v12;
          *v10 = &CSslServerKey::`vftable';
          *((_DWORD *)v10 + 6) = 1;
        }
        else
        {
          v11 = 0i64;
        }
        *((_QWORD *)&this[11]->dwCertEncodingType + v3) = v11;
        if ( !*((_QWORD *)&this[11]->dwCertEncodingType + v3) )
          break;
        v3 = (unsigned int)(v3 + 1);
        if ( (unsigned int)v3 >= v7 )
          goto LABEL_16;
      }
      PrivateKeyFromProvider = 14;
    }
LABEL_16:
    *((_DWORD *)this + 24) = v3;
    if ( !PrivateKeyFromProvider )
      goto LABEL_20;
  }
  else
  {
    PrivateKeyFromProvider = 14;
  }
  while ( v7 > (unsigned int)v3 )
  {
    v13 = (unsigned __int64 *)((char *)v9 + 16 * --v7);
    SslFreeObject(v13[1], 0i64);
    CCipherMill::DeferenceProvider(v14, v13);
  }
LABEL_20:
  if ( v9 )
    SPExternalFree(v9);
  return PrivateKeyFromProvider;
}
// 18005F888: variable 'v5' is possibly undefined
// 18005F96C: variable 'v14' is possibly undefined
// 18007D568: using guessed type void *CSslServerKey::`vftable';
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018005F9A0) ----------------------------------------------------
__int64 __fastcall CSslCredential::GetPrivateFromCert(
        CSslCredential *this,
        __int64 a2,
        struct LSA_SCHANNEL_SUB_CRED *a3)
{
  struct _CRYPT_KEY_PROV_INFO *p_pcbData; // rbx
  unsigned int v4; // esi
  __int64 v8; // rax
  DWORD v9; // edx
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rax
  void *v12; // rsp
  _DWORD *v13; // rax
  CCipherMill *v14; // rcx
  CCipherMill *v15; // rcx
  DWORD LastError; // eax
  ULONG LocalServerKeyFromProvider; // eax
  char v18; // r8
  const unsigned __int16 *v19; // rdx
  unsigned int v20; // ecx
  __int64 v22; // [rsp+0h] [rbp-30h] BYREF
  DWORD pcbData; // [rsp+30h] [rbp+0h] BYREF
  DWORD v24; // [rsp+34h] [rbp+4h] BYREF
  __int64 v25[3]; // [rsp+38h] [rbp+8h] BYREF

  p_pcbData = 0i64;
  v24 = 0;
  v4 = 0;
  pcbData = 0;
  if ( !*((_BYTE *)this + 79) && *((_QWORD *)a3 + 2) )
  {
    v8 = *((_QWORD *)a3 + 2);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x1Cu, (__int64)&WPP_221bc911720835f3baa7a86739b227e3_Traceguids);
      v8 = *((_QWORD *)a3 + 2);
    }
    *((_QWORD *)this + 14) = v8;
    *((_BYTE *)this + 120) = 1;
  }
  if ( CertGetCertificateContextProperty(*((PCCERT_CONTEXT *)this + 4), 2u, 0i64, &pcbData) )
  {
    v9 = pcbData;
    if ( pcbData )
    {
      if ( pcbData <= (unsigned __int64)g_ulMaxStackAllocSize )
      {
        v10 = pcbData + g_ulAdditionalProbeSize + 8;
        if ( v10 >= pcbData )
        {
          if ( (unsigned int)VerifyStackAvailable(v10) )
          {
            v9 = pcbData;
            v11 = pcbData + 8 + 15i64;
            if ( v11 <= pcbData + 8 )
              v11 = 0xFFFFFFFFFFFFFF0i64;
            v12 = alloca(v11 & 0xFFFFFFFFFFFFFFF0ui64);
            p_pcbData = (struct _CRYPT_KEY_PROV_INFO *)&pcbData;
            if ( &v22 == (__int64 *)-48i64 )
              goto LABEL_17;
            pcbData = 1801679955;
            p_pcbData = (struct _CRYPT_KEY_PROV_INFO *)v25;
            if ( v25 )
            {
LABEL_22:
              if ( CertGetCertificateContextProperty(*((PCCERT_CONTEXT *)this + 4), 2u, p_pcbData, &pcbData) )
              {
                *((_DWORD *)this + 31) = p_pcbData->dwProvType;
                *((_DWORD *)this + 32) = p_pcbData->dwKeySpec;
                v14 = WPP_GLOBAL_Control;
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
                {
                  if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
                  {
                    WPP_SF_S(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      0x1Du,
                      (__int64)&WPP_221bc911720835f3baa7a86739b227e3_Traceguids,
                      p_pcbData->pwszContainerName);
                    v14 = WPP_GLOBAL_Control;
                  }
                  if ( v14 != (CCipherMill *)&WPP_GLOBAL_Control )
                  {
                    if ( (*((_BYTE *)v14 + 28) & 4) != 0 )
                    {
                      WPP_SF_S(
                        *((_QWORD *)v14 + 2),
                        0x1Eu,
                        (__int64)&WPP_221bc911720835f3baa7a86739b227e3_Traceguids,
                        p_pcbData->pwszProvName);
                      v14 = WPP_GLOBAL_Control;
                    }
                    if ( v14 != (CCipherMill *)&WPP_GLOBAL_Control )
                    {
                      if ( (*((_BYTE *)v14 + 28) & 4) != 0 )
                      {
                        WPP_SF_D(
                          *((_QWORD *)v14 + 2),
                          31i64,
                          &WPP_221bc911720835f3baa7a86739b227e3_Traceguids,
                          p_pcbData->dwProvType);
                        v14 = WPP_GLOBAL_Control;
                      }
                      if ( v14 != (CCipherMill *)&WPP_GLOBAL_Control )
                      {
                        if ( (*((_BYTE *)v14 + 28) & 4) != 0 )
                        {
                          WPP_SF_D(
                            *((_QWORD *)v14 + 2),
                            32i64,
                            &WPP_221bc911720835f3baa7a86739b227e3_Traceguids,
                            p_pcbData->dwFlags);
                          v14 = WPP_GLOBAL_Control;
                        }
                        if ( v14 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v14 + 28) & 4) != 0 )
                          WPP_SF_d(
                            *((_QWORD *)v14 + 2),
                            0x21u,
                            (__int64)&WPP_221bc911720835f3baa7a86739b227e3_Traceguids,
                            p_pcbData->dwKeySpec);
                      }
                    }
                  }
                }
                LogCredPropertiesEvent(*((_BYTE *)this + 79), p_pcbData, *((const struct _CERT_CONTEXT **)this + 4));
              }
              else
              {
                if ( p_pcbData[-1].dwKeySpec == 1885431112 )
                  ((void (*)(void))g_pfnFree)();
                p_pcbData = 0i64;
              }
              goto LABEL_46;
            }
          }
          v9 = pcbData;
        }
      }
    }
LABEL_17:
    if ( v9 + 8 >= v9 )
    {
      v13 = (_DWORD *)((__int64 (__fastcall *)(_QWORD))g_pfnAllocate)(v9 + 8);
      p_pcbData = (struct _CRYPT_KEY_PROV_INFO *)v13;
      if ( !v13 )
      {
LABEL_21:
        v4 = 14;
LABEL_77:
        v18 = *((_BYTE *)this + 79);
        v19 = (const unsigned __int16 *)((char *)this + 656);
        v20 = *((_DWORD *)this + 163);
        if ( !p_pcbData )
        {
          LogNoPrivateKeyEvent(v20, v19, v18);
          return v4;
        }
        LogCreateCredFailedEvent(v20, v19, v18, *((_DWORD *)this + 18));
        goto LABEL_80;
      }
      *v13 = 1885431112;
      p_pcbData = (struct _CRYPT_KEY_PROV_INFO *)(v13 + 2);
    }
    if ( !p_pcbData )
      goto LABEL_21;
    goto LABEL_22;
  }
  if ( CertGetCertificateContextProperty(*((PCCERT_CONTEXT *)this + 4), 5u, 0i64, &v24) )
  {
LABEL_46:
    v15 = WPP_GLOBAL_Control;
    goto LABEL_47;
  }
  v15 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
  {
    LastError = GetLastError();
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 34i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids, LastError);
    goto LABEL_46;
  }
LABEL_47:
  if ( *((_BYTE *)this + 120) )
  {
    if ( !p_pcbData )
      return v4;
    goto LABEL_80;
  }
  if ( p_pcbData )
  {
    if ( *((_BYTE *)this + 79) )
    {
      if ( v15 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v15 + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)v15 + 2), 35i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids);
      p_pcbData->dwFlags &= ~1u;
      p_pcbData->dwFlags |= 0x40u;
      LocalServerKeyFromProvider = CSslCredential::GetLocalServerKeyFromProvider(
                                     (const struct _CERT_CONTEXT **)this,
                                     a2);
    }
    else
    {
      if ( *((_BYTE *)this + 78) )
      {
        if ( v15 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v15 + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)v15 + 2), 37i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids);
        v4 = RemotelyOpenClientKeyHandle(
               p_pcbData->pwszContainerName,
               p_pcbData->pwszProvName,
               (unsigned __int8 *)this + 40,
               p_pcbData->dwKeySpec,
               p_pcbData->dwProvType,
               p_pcbData->dwFlags);
        if ( !v4 )
          goto LABEL_80;
        *((_DWORD *)this + 18) = 10003;
LABEL_68:
        LogCredAcquireContextFailedEvent(
          *((_DWORD *)this + 163),
          (const WCHAR *)this + 328,
          *((_BYTE *)this + 79),
          v4,
          *((_DWORD *)this + 18));
LABEL_80:
        if ( p_pcbData[-1].dwKeySpec == 1885431112 )
          ((void (*)(void))g_pfnFree)();
        return v4;
      }
      if ( v15 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v15 + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)v15 + 2), 36i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids);
      LocalServerKeyFromProvider = CSslCredential::GetLocalClientKeyFromProvider(
                                     (NCRYPT_KEY_HANDLE *)this,
                                     p_pcbData,
                                     a2);
    }
    v4 = LocalServerKeyFromProvider;
    if ( !LocalServerKeyFromProvider )
      goto LABEL_80;
    goto LABEL_68;
  }
  if ( !v24 )
  {
    v4 = -2146893042;
    goto LABEL_77;
  }
  if ( *((_BYTE *)this + 79) )
  {
    if ( v15 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v15 + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)v15 + 2), 38i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids);
    v4 = CSslCredential::GetLocalServerKeyFromProvider((const struct _CERT_CONTEXT **)this, a2);
    if ( v4 )
      LogCredAcquireContextFailedEvent(
        *((_DWORD *)this + 163),
        (const WCHAR *)this + 328,
        *((_BYTE *)this + 79),
        v4,
        *((_DWORD *)this + 18));
  }
  return v4;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;

//----- (000000018005FE8C) ----------------------------------------------------
__int64 __fastcall CSslCredential::GetProviderSpecificMasterKey(
        CSslCredential *this,
        __int64 a2,
        struct CSslServerKey **a3)
{
  struct _RTL_RESOURCE *v3; // rsi
  unsigned int v7; // edi
  __int64 v8; // rax
  __int64 v9; // rcx

  v3 = (struct _RTL_RESOURCE *)((char *)this + 552);
  v7 = 1168;
  RtlAcquireResourceShared((PRTL_RESOURCE)((char *)this + 552), 1u);
  v8 = 0i64;
  if ( *((_DWORD *)this + 24) )
  {
    while ( 1 )
    {
      v9 = *(_QWORD *)(*((_QWORD *)this + 11) + 8 * v8);
      if ( *(_QWORD *)(v9 + 16) == a2 )
        break;
      v8 = (unsigned int)(v8 + 1);
      if ( (unsigned int)v8 >= *((_DWORD *)this + 24) )
        goto LABEL_6;
    }
    _InterlockedIncrement((volatile signed __int32 *)(v9 + 24));
    v7 = 0;
    *a3 = *(struct CSslServerKey **)(*((_QWORD *)this + 11) + 8i64 * (unsigned int)v8);
  }
LABEL_6:
  RtlReleaseResource(v3);
  return v7;
}

//----- (000000018005FF30) ----------------------------------------------------
unsigned __int8 __fastcall CSslCredential::IsClientCredApplicable(
        CSslCredential *this,
        int a2,
        int a3,
        const struct CTlsSignatureSuiteList *a4,
        struct _TLS_PARAMETERS *a5,
        unsigned int a6)
{
  struct CEccCurveInfo *v6; // rbp
  _DWORD *v9; // rax
  int v10; // edi
  CCipherMill *v11; // rcx
  unsigned __int16 v12; // dx
  const wchar_t *v13; // r9
  __int64 v14; // rcx
  int v16; // r8d
  unsigned int v17; // r9d
  struct CEccCurveInfo *v18; // [rsp+70h] [rbp+8h] BYREF

  v6 = 0i64;
  v18 = 0i64;
  v9 = (_DWORD *)*((_QWORD *)this + 4);
  if ( !v9 || *v9 != 1 || !*((_QWORD *)this + 54) && !*((_DWORD *)this + 33) )
    return 0;
  v10 = *((_DWORD *)this + 33);
  if ( a2 != v10 || (a3 & 0xA2A80) == 0 && v10 == 8707 )
    return 0;
  if ( a4 )
  {
    if ( !CTlsSignatureSuiteList::IsSupportedSignatureKey(a4, v10, *((_DWORD *)this + 107), a3, *((_DWORD *)this + 35)) )
    {
      v11 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        v12 = 40;
LABEL_17:
        v13 = &Class;
        v14 = *((_QWORD *)v11 + 2);
        if ( *((_QWORD *)this + 50) )
          v13 = (const wchar_t *)*((_QWORD *)this + 50);
        WPP_SF_S(v14, v12, (__int64)&WPP_221bc911720835f3baa7a86739b227e3_Traceguids, v13);
        return 0;
      }
      return 0;
    }
    if ( !CTlsSignatureSuiteList::IsSupportedSignatureSuiteList(a4, (CSslCredential *)((char *)this + 512)) )
    {
      v11 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        v12 = 41;
        goto LABEL_17;
      }
      return 0;
    }
  }
  if ( v10 == 8707 )
  {
    if ( (unsigned int)CCipherMill::GetCurveInfo(this, *((_DWORD *)this + 35), &v18) )
      return 0;
    v6 = v18;
  }
  if ( a6 )
  {
    v16 = *((_DWORD *)this + 33);
    v17 = v16 == 8707 ? *((_DWORD *)this + 34) : *((_DWORD *)this + 107);
    if ( IsCertificateBlacklisted(
           a5,
           a6,
           v16,
           v17,
           v6,
           0,
           0,
           (const unsigned __int16 *)this + 72,
           (const unsigned __int16 *)this + 136,
           0i64,
           1) )
    {
      return 0;
    }
  }
  return 1;
}
// 18006006B: variable 'this' is possibly undefined

//----- (00000001800600F8) ----------------------------------------------------
void __fastcall CSslCredential::RemoteCloseKeyHandle(CSslCredential *this, __int64 a2, int a3)
{
  __int64 v3; // rdx

  v3 = *((_QWORD *)this + 14);
  if ( v3 || *((_QWORD *)this + 13) && *((_BYTE *)this + 78) )
  {
    RemotelyCloseClientKeyHandle(*((_QWORD *)this + 13), v3, a3);
    *((_QWORD *)this + 13) = 0i64;
    *((_QWORD *)this + 14) = 0i64;
  }
}

//----- (0000000180060138) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::CSsl3TlsClientContext(__int64 a1, __int64 a2)
{
  CSsl3TlsContext::CSsl3TlsContext((CSsl3TlsContext *)a1, a2);
  *(_QWORD *)a1 = &CSsl3TlsClientContext::`vftable';
  *(_QWORD *)(a1 + 928) = *(_QWORD *)(a2 + 928);
  *(_QWORD *)(a1 + 936) = *(_QWORD *)(a2 + 936);
  *(_DWORD *)(a1 + 944) = *(_DWORD *)(a2 + 944);
  *(_QWORD *)(a1 + 952) = *(_QWORD *)(a2 + 952);
  *(_DWORD *)(a1 + 960) = *(_DWORD *)(a2 + 960);
  *(_QWORD *)(a1 + 968) = *(_QWORD *)(a2 + 968);
  *(_DWORD *)(a1 + 976) = *(_DWORD *)(a2 + 976);
  *(_WORD *)(a1 + 980) = *(_WORD *)(a2 + 980);
  *(_QWORD *)(a1 + 1016) = *(_QWORD *)(a2 + 1016);
  *(_QWORD *)(a1 + 1024) = *(_QWORD *)(a2 + 1024);
  *(_BYTE *)(a1 + 1032) = *(_BYTE *)(a2 + 1032);
  *(_QWORD *)(a1 + 1040) = *(_QWORD *)(a2 + 1040);
  *(_DWORD *)(a1 + 1048) = *(_DWORD *)(a2 + 1048);
  *(_DWORD *)(a1 + 1308) = *(_DWORD *)(a2 + 1308);
  *(_BYTE *)(a1 + 1312) = *(_BYTE *)(a2 + 1312);
  *(_BYTE *)(a1 + 1313) = *(_BYTE *)(a2 + 1313);
  *(_BYTE *)(a1 + 1314) = *(_BYTE *)(a2 + 1314);
  *(_BYTE *)(a1 + 1315) = *(_BYTE *)(a2 + 1315);
  *(_QWORD *)(a1 + 1320) = *(_QWORD *)(a2 + 1320);
  *(_QWORD *)(a1 + 1328) = *(_QWORD *)(a2 + 1328);
  *(_QWORD *)(a1 + 1336) = *(_QWORD *)(a2 + 1336);
  *(_BYTE *)(a1 + 1344) = *(_BYTE *)(a2 + 1344);
  *(_WORD *)(a1 + 1346) = *(_WORD *)(a2 + 1346);
  *(_OWORD *)(a1 + 1052) = *(_OWORD *)(a2 + 1052);
  *(_OWORD *)(a1 + 1068) = *(_OWORD *)(a2 + 1068);
  *(_OWORD *)(a1 + 1084) = *(_OWORD *)(a2 + 1084);
  *(_OWORD *)(a1 + 1100) = *(_OWORD *)(a2 + 1100);
  *(_OWORD *)(a1 + 1116) = *(_OWORD *)(a2 + 1116);
  *(_OWORD *)(a1 + 1132) = *(_OWORD *)(a2 + 1132);
  *(_OWORD *)(a1 + 1148) = *(_OWORD *)(a2 + 1148);
  *(_OWORD *)(a1 + 1164) = *(_OWORD *)(a2 + 1164);
  *(_OWORD *)(a1 + 1180) = *(_OWORD *)(a2 + 1180);
  *(_OWORD *)(a1 + 1196) = *(_OWORD *)(a2 + 1196);
  *(_OWORD *)(a1 + 1212) = *(_OWORD *)(a2 + 1212);
  *(_OWORD *)(a1 + 1228) = *(_OWORD *)(a2 + 1228);
  *(_OWORD *)(a1 + 1244) = *(_OWORD *)(a2 + 1244);
  *(_OWORD *)(a1 + 1260) = *(_OWORD *)(a2 + 1260);
  *(_OWORD *)(a1 + 1276) = *(_OWORD *)(a2 + 1276);
  *(_QWORD *)(a1 + 1292) = *(_QWORD *)(a2 + 1292);
  *(_DWORD *)(a1 + 1300) = *(_DWORD *)(a2 + 1300);
  *(_WORD *)(a1 + 1304) = *(_WORD *)(a2 + 1304);
  *(_BYTE *)(a1 + 1306) = *(_BYTE *)(a2 + 1306);
  *(_OWORD *)(a1 + 982) = *(_OWORD *)(a2 + 982);
  *(_OWORD *)(a1 + 998) = *(_OWORD *)(a2 + 998);
  *(_OWORD *)(a1 + 1348) = *(_OWORD *)(a2 + 1348);
  *(_QWORD *)(a2 + 1320) = 0i64;
  *(_QWORD *)(a2 + 1328) = 0i64;
  *(_QWORD *)(a2 + 1016) = 0i64;
  *(_QWORD *)(a2 + 1024) = 0i64;
  *(_QWORD *)(a2 + 1336) = 0i64;
  *(_QWORD *)(a2 + 928) = 0i64;
  *(_QWORD *)(a2 + 936) = 0i64;
  *(_DWORD *)(a2 + 944) = 0;
  *(_QWORD *)(a2 + 952) = 0i64;
  *(_DWORD *)(a2 + 960) = 0;
  *(_QWORD *)(a2 + 968) = 0i64;
  *(_DWORD *)(a2 + 976) = 0;
  *(_QWORD *)(a2 + 1040) = 0i64;
  return a1;
}
// 18007C000: using guessed type void *CSsl3TlsClientContext::`vftable';

//----- (00000001800603D0) ----------------------------------------------------
CTlsExtClient *__fastcall CTlsExtClient::`scalar deleting destructor'(CTlsExtClient *this, char a2)
{
  CTlsExtClient::~CTlsExtClient(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0000000180060408) ----------------------------------------------------
__int64 __fastcall CbLenOfEncode(unsigned int a1, unsigned __int8 *a2)
{
  __int64 v2; // r9
  int v3; // ebx
  __int64 v4; // rax
  __int64 v6; // [rsp+20h] [rbp-18h] BYREF

  v6 = 0i64;
  LODWORD(v2) = 7;
  if ( a1 >= 0x80 )
  {
    do
    {
      v4 = (unsigned int)v2;
      v2 = (unsigned int)(v2 - 1);
      *((_BYTE *)&v6 + v4) = a1;
      a1 >>= 8;
    }
    while ( a1 );
    v3 = 8 - v2;
    *((_BYTE *)&v6 + v2) = (8 - v2 - 1) | 0x80;
  }
  else
  {
    HIBYTE(v6) = a1;
    v3 = 1;
  }
  if ( a2 )
  {
    *a2 = 48;
    memcpy_0(a2 + 1, (char *)&v6 + (unsigned int)v2, v3);
  }
  return (unsigned int)(v3 + 1);
}

//----- (000000018006049C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::CheckForClientCred(CSsl3TlsClientContext *this)
{
  __int64 v1; // rax
  unsigned int v3; // esi
  unsigned int v4; // r15d
  int *v5; // r14
  CCipherMill *v7; // rcx
  __int64 v8; // rdx
  unsigned int v9; // esi
  CCipherMill *v10; // rcx
  __int64 v11; // rdx
  unsigned int v12; // r11d
  void *v13; // rcx
  __int64 v14; // rdx
  __int64 v15; // r8
  int v16; // [rsp+20h] [rbp-20h]
  void *v17[2]; // [rsp+30h] [rbp-10h] BYREF
  struct CSslCredential *v18; // [rsp+80h] [rbp+40h] BYREF
  __int64 v19; // [rsp+88h] [rbp+48h] BYREF
  __int64 v20; // [rsp+90h] [rbp+50h] BYREF

  v1 = *((_QWORD *)this + 10);
  *((_BYTE *)this + 923) = 0;
  *((_BYTE *)this + 1314) = 0;
  if ( !*(_DWORD *)(v1 + 28) )
  {
    if ( (unsigned int)AcquireDefaultClientCredential(this, (*(_DWORD *)(v1 + 156) >> 3) & 1) || !*((_BYTE *)this + 266) )
      goto LABEL_8;
    *(_OWORD *)v17 = 0i64;
    LODWORD(v18) = 0;
    v19 = 0i64;
    v20 = 0i64;
    v9 = (*(__int64 (__fastcall **)(struct CSslCredential **, __int64 *, __int64 *, void **, _QWORD))(LsaTable + 488))(
           &v18,
           &v20,
           &v19,
           v17,
           0i64);
    if ( v9 )
    {
      v10 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return v9;
      v11 = 56i64;
    }
    else
    {
      v12 = (unsigned int)v18;
      if ( (_DWORD)v18 != 4 )
      {
        v7 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          v8 = 59i64;
LABEL_37:
          WPP_SF_(*((_QWORD *)v7 + 2), v8, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        }
        return 0i64;
      }
      if ( *((_DWORD *)this + 17) != 91 && *((_DWORD *)this + 17) != 101 )
      {
        CSsl3TlsClientContext::SetActiveClientCred(this, 0i64, 0);
        CSsl3TlsClientContext::SetDefCredSearched((__int64)this, 0);
        v13 = v17[1];
        *((_BYTE *)this + 1314) = 1;
        CleanupAppModeInfo(v13);
        goto LABEL_8;
      }
      v14 = 1i64;
      *((_BYTE *)this + 923) = 1;
      v20 = 1i64;
      v15 = 0i64;
      v19 = 0i64;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 57i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        v12 = (unsigned int)v18;
        v15 = v19;
        v14 = v20;
      }
      LOBYTE(v16) = 1;
      v9 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, void **, int))(LsaTable + 496))(v12, v14, v15, v17, v16);
      if ( !v9 )
        goto LABEL_8;
      v10 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return v9;
      v11 = 58i64;
    }
    WPP_SF_D(*((_QWORD *)v10 + 2), v11, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids, v9);
    return v9;
  }
  v3 = 0;
  if ( *((_WORD *)this + 673) )
  {
LABEL_3:
    v4 = 0;
    v5 = (int *)&unk_18007D758;
    while ( *((_DWORD *)this + v3 + 337) != v5[1]
         || (unsigned int)CCredentialGroup::PickClientCredential(
                            *((CCredentialGroup **)this + 10),
                            *v5,
                            *((_DWORD *)this + 16),
                            (struct CTlsSignatureSuiteList *)(((unsigned __int64)this + 510) & -(__int64)((*((_DWORD *)this + 16) & 0x82800) != 0)),
                            &v18) )
    {
      ++v4;
      v5 += 4;
      if ( v4 >= 8 )
      {
        if ( ++v3 < *((unsigned __int16 *)this + 673) )
          goto LABEL_3;
        goto LABEL_8;
      }
    }
    CSsl3TlsClientContext::SetActiveClientCred(this, v18, 0);
    v7 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      v8 = 55i64;
      goto LABEL_37;
    }
    return 0i64;
  }
LABEL_8:
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 60i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
  return ~(*((_DWORD *)this + 34) << 21) & 0x80000000 | 0x90320;
}
// 180060744: variable 'v16' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (00000001800607B4) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::DigestCertificateRequest(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        int a3)
{
  CSsl3TlsClientContext *v3; // rdi
  __int64 v4; // rbx
  unsigned __int8 *v5; // r14
  int v6; // esi
  unsigned __int8 v7; // r15
  unsigned __int8 v8; // bp
  unsigned __int16 v9; // dx
  int v10; // r8d
  __int64 v11; // rcx
  unsigned int v12; // eax
  unsigned __int8 *v13; // r14
  unsigned int v14; // esi
  unsigned int v15; // ebx
  unsigned __int8 v16; // r9
  int v17; // edx
  unsigned int v19; // [rsp+30h] [rbp-78h] BYREF
  __int16 v20; // [rsp+38h] [rbp-70h] BYREF
  __int128 v21; // [rsp+3Ah] [rbp-6Eh]
  __int128 v22; // [rsp+4Ah] [rbp-5Eh]
  __int16 v23; // [rsp+5Ah] [rbp-4Eh]

  v3 = this;
  if ( !a3 || (v4 = *a2, v5 = a2 + 1, v6 = a3 - 1, (unsigned int)v4 > a3 - 1) )
  {
    v16 = 50;
    v15 = -2146893018;
    v17 = 400;
    goto LABEL_27;
  }
  *((_WORD *)this + 673) = 0;
  v7 = 0;
  if ( !(_BYTE)v4 )
    goto LABEL_23;
  do
  {
    v8 = 0;
    while ( 1 )
    {
      v9 = *((_WORD *)v3 + 673);
      if ( v9 >= 4u )
        break;
      v10 = g_Ssl3CertTypes[v8];
      if ( v10 == v5[v7] )
      {
        v11 = *((_QWORD *)v3 + 10);
        v12 = *(_DWORD *)(v11 + 196);
        if ( !v12 )
          goto LABEL_10;
        if ( !IsSignatureTypeBlacklisted(*(_QWORD *)(v11 + 200), v12, v10, 0i64) )
        {
          v9 = *((_WORD *)v3 + 673);
          v10 = g_Ssl3CertTypes[v8];
LABEL_10:
          *((_DWORD *)v3 + v9 + 337) = v10;
          ++*((_WORD *)v3 + 673);
        }
      }
      if ( ++v8 >= 3u )
      {
        v9 = *((_WORD *)v3 + 673);
        break;
      }
    }
    ++v7;
  }
  while ( v7 < (unsigned __int8)v4 );
  if ( !v9 )
  {
LABEL_23:
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 41i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
    goto LABEL_19;
  }
  v13 = &v5[v4];
  v14 = v6 - v4;
  if ( (*((_DWORD *)v3 + 16) & 0x80800) == 0 )
    return CSsl3TlsClientContext::ParseDistinguishedNameList(v3, v13, v14);
  v20 = 0;
  v23 = 0;
  v19 = 0;
  v21 = 0i64;
  v22 = 0i64;
  v15 = CTlsSignatureSuiteList::ParseSupportedSignatureAlgorithmsAndSet((CTlsSignatureSuiteList *)&v20, v13, v14, &v19);
  if ( v15 )
  {
    v16 = 47;
    goto LABEL_20;
  }
  CTlsSignatureSuiteList::SetSignatureSuiteList(
    (CSsl3TlsClientContext *)((char *)v3 + 510),
    (CSsl3TlsClientContext *)((char *)v3 + 474));
  if ( CTlsSignatureSuiteList::Restrict(
         (CSsl3TlsClientContext *)((char *)v3 + 510),
         (const struct CTlsSignatureSuiteList *)&v20,
         *((_DWORD *)v3 + 16)) )
  {
    v13 += v19;
    v14 -= v19;
    return CSsl3TlsClientContext::ParseDistinguishedNameList(v3, v13, v14);
  }
LABEL_19:
  v16 = 40;
  v15 = -2146893007;
LABEL_20:
  v17 = 402;
  this = v3;
LABEL_27:
  CSslContext::SetErrorAndFatalAlert((__int64)this, v17, v15, v16);
  return v15;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800858E8: using guessed type _DWORD g_Ssl3CertTypes[4];

//----- (00000001800609DC) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::DigestServerHelloVerifyRequest(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  unsigned __int8 v4; // r9
  unsigned int v5; // ecx

  if ( (*(_DWORD *)(*((_QWORD *)this + 10) + 152i64) & 0xA0000) == 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 50i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
    v4 = 10;
    goto LABEL_14;
  }
  if ( a3 < 3 || *a2 != 0xFE || (a2[1] | (*a2 << 8)) > 0xFEFFu || (v5 = a2[2], a3 < v5 + 3) )
  {
    v4 = 50;
LABEL_14:
    CSslContext::SetErrorAndFatalAlert((__int64)this, 90, -2146893018, v4);
    return 2148074278i64;
  }
  *((_BYTE *)this + 1312) = v5;
  *((_DWORD *)this + 327) = 1;
  if ( (_BYTE)v5 )
    memcpy_0((char *)this + 1052, a2 + 3, v5);
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180060AAC) ----------------------------------------------------
__int64 __fastcall FormatIssuerList(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, unsigned int *a4)
{
  unsigned int v4; // ebp
  unsigned int v7; // r15d
  int v9; // esi
  unsigned int v10; // r15d
  int v11; // eax
  unsigned __int8 *v12; // r14
  unsigned int v13; // esi
  unsigned int v14; // ebp
  unsigned int v15; // eax

  v4 = 0;
  v7 = a2;
  if ( a2 )
  {
    while ( v7 >= 2 )
    {
      v9 = *a1;
      v10 = v7 - 2;
      v11 = a1[1];
      v12 = a1 + 2;
      v13 = v11 | (v9 << 8);
      if ( v10 < v13 )
        break;
      if ( a3 )
      {
        a3[1] = v13;
        *a3 = BYTE1(v13);
        a3 += 2;
      }
      v14 = v4 + 2;
      if ( *v12 != 48 )
      {
        v15 = CbLenOfEncode(v13, a3);
        if ( a3 )
          a3 += v15;
        v14 += v15;
      }
      if ( a3 )
      {
        memcpy_0(a3, v12, v13);
        a3 += v13;
      }
      v4 = v13 + v14;
      a1 = &v12[v13];
      v7 = v10 - v13;
      if ( !v7 )
        goto LABEL_13;
    }
    return 2148074278i64;
  }
  else
  {
LABEL_13:
    *a4 = v4;
    return 0i64;
  }
}

//----- (0000000180060B8C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::GenerateCertVerify(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int *a3)
{
  __int64 v3; // rax
  wchar_t *v7; // rdi
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // r8
  int v11; // r12d
  __int64 v12; // r15
  __int64 v13; // rax
  __int64 v14; // rdx
  unsigned int v15; // ecx
  __int64 v16; // rax
  unsigned int v17; // r14d
  __int64 result; // rax
  unsigned int v19; // ecx
  int v20; // edx
  enum _eTlsHashAlgorithm v21; // eax
  char *v22; // rdi
  __int16 v23; // r12
  unsigned __int8 v24; // r9
  unsigned int v25; // edi
  int v26; // edx
  CSsl3TlsClientContext *v27; // rcx
  unsigned __int64 TlsClientAuthHandshakeHash; // rdi
  __int64 *v29; // rax
  __int64 v30; // rcx
  char v31; // cl
  unsigned int v32; // r14d
  unsigned int v33; // r14d
  unsigned int v34; // eax
  unsigned int *v35; // rcx
  unsigned int v36; // eax
  unsigned int *v37; // rcx
  size_t Size; // [rsp+70h] [rbp-69h] BYREF
  unsigned int v39; // [rsp+78h] [rbp-61h] BYREF
  unsigned int v40; // [rsp+7Ch] [rbp-5Dh] BYREF
  enum _eTlsHashAlgorithm v41; // [rsp+80h] [rbp-59h] BYREF
  wchar_t *String1; // [rsp+88h] [rbp-51h]
  LPCWSTR v43; // [rsp+90h] [rbp-49h] BYREF
  unsigned int *v44; // [rsp+98h] [rbp-41h]
  void *v45; // [rsp+A0h] [rbp-39h]
  BYTE Src[64]; // [rsp+B0h] [rbp-29h] BYREF

  v3 = *((_QWORD *)this + 10);
  Size = 0i64;
  v44 = a3;
  v7 = 0i64;
  v45 = *(void **)(v3 + 752);
  v8 = *(_QWORD *)this;
  v40 = 32772;
  String1 = 0i64;
  v43 = 0i64;
  v9 = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *))(v8 + 248))(this);
  v11 = 0;
  v39 = 0;
  v12 = v9;
  v13 = *(_QWORD *)(v9 + 432);
  if ( v13 )
  {
    v14 = 118i64;
    v15 = *(_DWORD *)(v13 + 8) + 2;
    if ( v15 > 0x76 )
      v14 = v15;
  }
  else
  {
    v16 = *(_QWORD *)(v12 + 32);
    if ( v16 )
      v14 = (unsigned int)(*(_DWORD *)(*(_QWORD *)(v16 + 24) + 120i64) + 52);
    else
      v14 = 68i64;
  }
  v17 = v14 + 2;
  if ( (*((_DWORD *)this + 16) & 0x80800) == 0 )
    v17 = v14;
  result = 0i64;
  if ( !a2 )
  {
    *a3 = v17;
    return result;
  }
  if ( *((_QWORD *)this + 117) && !*((_BYTE *)this + 1032) )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 46i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
    v19 = *((_DWORD *)this + 236);
    HIDWORD(Size) = v17 - 2;
    if ( v19 <= v17 - 2 )
    {
      memcpy_0(a2 + 2, *((const void **)this + 117), v19);
      v20 = *((_DWORD *)this + 236);
LABEL_70:
      a2[v11] = BYTE1(v20);
      v35 = v44;
      a2[v11 + 1] = v20;
      *v35 = v11 + v20 + 2;
      return 0i64;
    }
    goto LABEL_57;
  }
  switch ( *(_DWORD *)(v12 + 132) )
  {
    case 0x2200:
      v7 = (wchar_t *)L"DSA";
      goto LABEL_26;
    case 0x2203:
      v7 = (wchar_t *)L"ECDSA";
LABEL_26:
      LODWORD(Size) = 20;
      goto LABEL_27;
    case 0x2400:
    case 0xA400:
      v7 = (wchar_t *)L"RSA";
      v40 = 32776;
      LODWORD(Size) = 36;
      v39 = 2;
LABEL_27:
      String1 = v7;
      break;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x2Fu, (__int64)&WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids, v7);
  if ( (*((_DWORD *)this + 16) & 0x80800) != 0 )
  {
    v21 = (unsigned int)ConvertCertificateAlgToTlsSignatureAlgorithm(*(_DWORD *)(v12 + 132), v14, v10);
    v41 = v21;
    v22 = (char *)this + 510;
    if ( *(_QWORD *)(v12 + 112) )
    {
      v22 = (char *)operator new(0x24ui64);
      if ( v22 )
      {
        *(_OWORD *)(v22 + 2) = 0i64;
        *(_OWORD *)(v22 + 18) = 0i64;
        *(_WORD *)v22 = 0;
        *((_WORD *)v22 + 17) = 0;
      }
      else
      {
        v22 = 0i64;
      }
      CTlsSignatureSuiteList::SetDefaultClientHello((CTlsSignatureSuiteList *)v22);
      CTlsSignatureSuiteList::Restrict(
        (CTlsSignatureSuiteList *)v22,
        (CSsl3TlsClientContext *)((char *)this + 510),
        *((_DWORD *)this + 16));
      v21 = v41;
    }
    v23 = __ROR2__(
            CTlsSignatureSuiteList::GetMinimumCodePointToSign(
              (CTlsSignatureSuiteList *)v22,
              (enum _eTlsSignatureAlgorithm)v21,
              *(_DWORD *)(v12 + 428),
              *((_DWORD *)this + 16),
              0),
            8);
    if ( *(_QWORD *)(v12 + 112) && v22 )
      operator delete(v22);
    if ( !v23 )
    {
      v24 = 40;
      v25 = -2146893007;
      v26 = 304;
LABEL_42:
      v27 = this;
LABEL_43:
      CSslContext::SetErrorAndFatalAlert((__int64)v27, v26, v25, v24);
      return v25;
    }
    GetSignatureSuiteInfoByCodePoint(v23, 0i64, &v41, &v40, &v43, (unsigned int *)&Size, &v39);
    TlsClientAuthHandshakeHash = CSsl3TlsContext::FindTlsClientAuthHandshakeHash(this, v41);
    if ( !TlsClientAuthHandshakeHash || v17 < 2 )
    {
      v24 = 80;
      v25 = 1359;
      v26 = 304;
      goto LABEL_43;
    }
    *(_WORD *)a2 = v23;
    v11 = 2;
  }
  else
  {
    TlsClientAuthHandshakeHash = *((_QWORD *)this + 74);
  }
  RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64), 1u);
  v29 = (__int64 *)*((_QWORD *)this + 1);
  if ( v29 )
    v30 = *v29;
  else
    v30 = 0i64;
  v25 = SslComputeClientAuthHash(
          v30,
          *(_QWORD *)(*((_QWORD *)this + 165) + 16i64),
          TlsClientAuthHandshakeHash,
          String1,
          Src,
          Size,
          &Size,
          0);
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
  if ( v25 )
  {
    v24 = 80;
    v26 = 300;
    goto LABEL_42;
  }
  v31 = *((_BYTE *)this + 1032);
  v32 = v17 - v11 - 2;
  HIDWORD(Size) = v32;
  if ( v31 )
  {
    if ( *((_DWORD *)this + 236) > v32 )
    {
LABEL_57:
      v24 = 80;
      v25 = -2146893018;
      v26 = 302;
      goto LABEL_42;
    }
    memcpy_0(&a2[v11 + 2], *((const void **)this + 117), *((unsigned int *)this + 236));
    v31 = *((_BYTE *)this + 1032);
  }
  v33 = v40;
  v34 = SignHashUsingCred(
          this,
          (struct CSslCredential *)v12,
          v45,
          v40,
          v39,
          String1,
          v43,
          Src,
          Size,
          &a2[v11 + 2],
          (DWORD *)&Size + 1,
          v31,
          *((_DWORD *)this + 236));
  v25 = v34;
  if ( v34 != -1073741168 && v34 != -2146893790 )
  {
    if ( v34 == 590610 )
    {
      if ( *((_BYTE *)this + 266) )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 49i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        *((_DWORD *)this + 17) = 77;
        return 590610i64;
      }
    }
    else if ( !v34 )
    {
      v20 = HIDWORD(Size);
      goto LABEL_70;
    }
    v24 = 80;
    v26 = 301;
    goto LABEL_42;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 48i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
  if ( (*((_DWORD *)this + 16) & 0x80800) != 0 )
  {
    v25 = -2146893043;
    CSslContext::SetError((__int64)this, 303, -2146893043);
    return v25;
  }
  v36 = Size;
  *((_DWORD *)a2 + 1) = v33;
  *(_DWORD *)a2 = 68;
  *((_DWORD *)a2 + 2) = v36;
  memcpy_0(a2 + 12, Src, v36);
  v37 = v44;
  *((_OWORD *)a2 + 3) = *(_OWORD *)(v12 + 40);
  *((_DWORD *)a2 + 16) = *(_DWORD *)(v12 + 56);
  result = 590684i64;
  *v37 = 68;
  return result;
}
// 180060D7D: variable 'v14' is possibly undefined
// 180060D7D: variable 'v10' is possibly undefined
// 180060E2C: variable 'v27' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180098588: using guessed type __int64 __fastcall SslComputeClientAuthHash(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);

//----- (0000000180061134) ----------------------------------------------------
unsigned __int8 __fastcall CSsl3TlsClientContext::IsMaliciousDowngrade(CSsl3TlsClientContext *this, int a2)
{
  const unsigned __int8 near *const *v4; // rdx
  int v6; // [rsp+20h] [rbp-18h]

  if ( (*((_DWORD *)this + 16) & 0x2000) != 0 )
    return 0;
  v4 = &CSsl3TlsContext::m_rgbTls12Downgrade;
  if ( (*((_DWORD *)this + 16) & 0x80800) == 0 )
    v4 = &CSsl3TlsContext::m_rgbTls11OrBelowDowngrade;
  if ( RtlCompareMemory((char *)this + 328, v4, 8ui64) != 8 )
    return 0;
  CSslContext::SetErrorAndFatalAlert((__int64)this, 105, -2146893048, 0x2Fu);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    v6 = a2;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x4Du,
      (__int64)&WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
      *((_DWORD *)this + 9),
      v6);
  }
  return 1;
}
// 180082BB8: using guessed type const unsigned __int8 near *const CSsl3TlsContext::m_rgbTls11OrBelowDowngrade;
// 180082BC0: using guessed type const unsigned __int8 near *const CSsl3TlsContext::m_rgbTls12Downgrade;

//----- (00000001800611F0) ----------------------------------------------------
bool __fastcall CSsl3TlsClientContext::IsWaitingForCCS(CSsl3TlsClientContext *this)
{
  int v1; // edx
  char v2; // cl

  v1 = *((_DWORD *)this + 17);
  v2 = 1;
  if ( (unsigned int)(v1 - 46) > 1 )
    return (unsigned int)(v1 - 50) <= 2;
  return v2;
}

//----- (0000000180061214) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::ParseDistinguishedNameList(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  unsigned int v6; // ebp
  int v7; // eax
  unsigned int v8; // esi
  __int16 v9; // r14
  unsigned __int8 *v10; // rax
  unsigned __int8 *v11; // rsi
  unsigned int v12; // ebx
  void *v13; // rcx
  unsigned int v14; // eax
  unsigned int v15; // [rsp+50h] [rbp+18h] BYREF

  if ( a3 < 2 )
    return 2148074278i64;
  if ( !a2 )
    return 2148074244i64;
  v6 = a3 - 2;
  if ( a3 - 2 < (a2[1] | (*a2 << 8)) )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 400, -2146893018, 0x32u);
    return 2148074278i64;
  }
  v15 = 0;
  v7 = FormatIssuerList(a2 + 2, v6, 0i64, &v15);
  v8 = v7;
  if ( v7 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 401, v7, 0x2Fu);
    return v8;
  }
  else
  {
    v9 = v15;
    v10 = (unsigned __int8 *)SPExternalAlloc(v15 + 2);
    v11 = v10;
    if ( v10 )
    {
      v10[1] = v9;
      *v10 = HIBYTE(v9);
      v12 = FormatIssuerList(a2 + 2, v6, v10 + 2, &v15);
      if ( v12 )
      {
        SPExternalFree(v11);
        return v12;
      }
      else
      {
        v13 = (void *)*((_QWORD *)this + 112);
        if ( v13 )
          SPExternalFree(v13);
        v14 = v15 + 2;
        *((_QWORD *)this + 112) = v11;
        *((_DWORD *)this + 222) = v14;
        return 0i64;
      }
    }
    else
    {
      return 2148074240i64;
    }
  }
}

//----- (0000000180061340) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::SetActiveClientCred(
        CSsl3TlsClientContext *this,
        struct CSslCredential *a2,
        char a3)
{
  unsigned __int64 v3; // rax
  __int64 v7; // rcx

  v3 = *((_QWORD *)this + 17);
  if ( (v3 & 0x80000) != 0 )
  {
    v7 = *((_QWORD *)this + 116);
    if ( v7 )
    {
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v7 + 8i64))(v7, 1i64);
      v3 = *((_QWORD *)this + 17) & 0xFFFFFFFFFFF7FFFFui64;
      *((_QWORD *)this + 17) = v3;
    }
  }
  *((_QWORD *)this + 116) = a2;
  if ( a3 )
    *((_QWORD *)this + 17) = v3 | 0x80000;
}

//----- (00000001800613D0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::SetNegotiatedSrtpParameters(
        CSsl3TlsClientContext *this,
        unsigned __int16 *const a2,
        unsigned __int16 a3,
        unsigned __int8 *const a4,
        unsigned __int8 a5)
{
  unsigned __int8 *v9; // rsi
  __int64 v10; // rbp
  __int64 result; // rax
  unsigned __int16 *v12; // rax
  __int16 MatchingProtectionProfile; // r12
  CCipherMill *v14; // rcx
  __int64 v15; // rdx
  unsigned __int8 *v16; // rax
  const void *v17; // r14
  unsigned __int8 *v18; // rax
  unsigned int v19; // ebx

  v9 = 0i64;
  LOBYTE(v10) = 0;
  result = CSsl3TlsContext::ValidateProtectionProfiles(a2, a3, 0);
  if ( !(_DWORD)result )
  {
    v12 = (unsigned __int16 *)*((_QWORD *)this + 100);
    if ( !v12 )
      return 87i64;
    if ( a4 )
    {
      if ( !a5 )
        return 87i64;
    }
    else if ( a5 )
    {
      return 87i64;
    }
    MatchingProtectionProfile = CSsl3TlsContext::FindMatchingProtectionProfile(v12 + 1, *v12, a2, a3);
    if ( !MatchingProtectionProfile )
    {
      v14 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074278i64;
      v15 = 70i64;
LABEL_29:
      WPP_SF_(*((_QWORD *)v14 + 2), v15, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      return 2148074278i64;
    }
    if ( a5 )
    {
      v16 = (unsigned __int8 *)*((_QWORD *)this + 167);
      if ( !v16 )
      {
        v14 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v15 = 71i64;
        goto LABEL_29;
      }
      v10 = *v16;
      v17 = v16 + 1;
      if ( a5 != (_BYTE)v10 || RtlCompareMemory(a4, v16 + 1, *v16) != v10 )
      {
        v14 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v15 = 72i64;
        goto LABEL_29;
      }
      v18 = (unsigned __int8 *)(*(__int64 (__fastcall **)(CSsl3TlsClientContext *, _QWORD))(*(_QWORD *)this + 8i64))(
                                 this,
                                 (unsigned int)v10);
      v9 = v18;
      if ( !v18 )
        return 14i64;
      memcpy_0(v18, v17, (unsigned int)v10);
    }
    v19 = CSsl3TlsContext::SetSelectedSrtpParameters(this, MatchingProtectionProfile, v9, v10);
    if ( v19 )
    {
      if ( v9 )
        (*(void (__fastcall **)(CSsl3TlsClientContext *, unsigned __int8 *))(*(_QWORD *)this + 16i64))(this, v9);
      return v19;
    }
    else
    {
      return 0i64;
    }
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (00000001800615C8) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::SetNegotiatedTBParameters(
        CSsl3TlsClientContext *this,
        unsigned __int8 a2,
        unsigned __int8 a3,
        unsigned __int8 *const a4,
        unsigned __int16 a5)
{
  unsigned __int8 *v5; // rdi
  __int16 v6; // r15
  unsigned __int8 *v9; // r10
  unsigned __int16 *v10; // r8
  CCipherMill *v11; // rcx
  __int64 v12; // rdx
  unsigned __int16 v13; // cx
  unsigned __int16 v14; // dx
  unsigned __int64 v16; // rcx
  unsigned __int16 *v17; // r8
  unsigned __int16 *v18; // rax
  unsigned __int8 *v19; // rax
  unsigned __int8 *v20; // rsi
  unsigned int v21; // edi

  v5 = a4;
  v6 = a3;
  v9 = &a4[a5];
  if ( !a5 || !a4 )
    return 87i64;
  v10 = (unsigned __int16 *)*((_QWORD *)this + 102);
  if ( !v10 )
  {
    v11 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      v12 = 73i64;
      goto LABEL_28;
    }
    return 2148074278i64;
  }
  v13 = _byteswap_ushort(*v10);
  v14 = v6 | (a2 << 8);
  if ( v14 > v13 )
  {
    v11 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      v12 = 74i64;
      goto LABEL_28;
    }
    return 2148074278i64;
  }
  if ( v14 < v13 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 75i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
    return 0i64;
  }
  v16 = (unsigned __int64)v10 + v10[1] + 4;
  if ( a4 >= v9 )
  {
LABEL_23:
    v19 = (unsigned __int8 *)(*(__int64 (__fastcall **)(CSsl3TlsClientContext *, _QWORD))(*(_QWORD *)this + 8i64))(
                               this,
                               a5);
    v20 = v19;
    if ( !v19 )
      return 14i64;
    memcpy_0(v19, v5, a5);
    v21 = CSsl3TlsContext::SetSelectedTBParameters(this, a2, v6, v20, a5);
    if ( v21 )
      (*(void (__fastcall **)(CSsl3TlsClientContext *, unsigned __int8 *))(*(_QWORD *)this + 16i64))(this, v20);
    return v21;
  }
  v17 = v10 + 2;
  while ( 1 )
  {
    v18 = v17;
    if ( (unsigned __int64)v17 < v16 )
    {
      while ( *a4 != *(_BYTE *)v18 )
      {
        v18 = (unsigned __int16 *)((char *)v18 + 1);
        if ( (unsigned __int64)v18 >= v16 )
          goto LABEL_21;
      }
      goto LABEL_22;
    }
LABEL_21:
    if ( v18 == (unsigned __int16 *)v16 )
      break;
LABEL_22:
    if ( ++a4 >= v9 )
      goto LABEL_23;
  }
  v11 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    v12 = 76i64;
LABEL_28:
    WPP_SF_(*((_QWORD *)v11 + 2), v12, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
  }
  return 2148074278i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (00000001800617E0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::SetSrtpMasterKeyIdentifier(
        CSsl3TlsClientContext *this,
        struct _SEC_SRTP_MASTER_KEY_IDENTIFIER *const a2)
{
  void *v2; // rdi
  __int64 MasterKeyIdentifierSize; // rbp
  void *v6; // rax

  v2 = 0i64;
  if ( a2 )
  {
    MasterKeyIdentifierSize = a2->MasterKeyIdentifierSize;
    v6 = (void *)(*(__int64 (__fastcall **)(CSsl3TlsClientContext *, __int64))(*(_QWORD *)this + 8i64))(
                   this,
                   MasterKeyIdentifierSize + 1);
    v2 = v6;
    if ( !v6 )
      return 14i64;
    memcpy_0(v6, a2, MasterKeyIdentifierSize + 1);
  }
  if ( *((_QWORD *)this + 167) )
    (*(void (__fastcall **)(CSsl3TlsClientContext *))(*(_QWORD *)this + 16i64))(this);
  *((_QWORD *)this + 167) = v2;
  return 0i64;
}

//----- (0000000180061888) ----------------------------------------------------
__int64 __fastcall SignHashUsingCred(
        struct CSslContext *a1,
        struct CSslCredential *a2,
        void *a3,
        unsigned int a4,
        unsigned int a5,
        wchar_t *String1,
        LPCWSTR a7,
        PBYTE pbHashValue,
        DWORD cbHashValue,
        PBYTE pbEncoded,
        DWORD *pcbEncoded,
        char a12,
        unsigned int a13)
{
  DWORD *v13; // rsi
  const wchar_t *v14; // r14
  DWORD LastError; // ebx
  unsigned __int8 *v16; // rdi
  int v17; // r15d
  __int64 v18; // rdx
  BYTE *pbSignature; // r13
  LPCWSTR *v20; // r14
  unsigned int v21; // ebx
  __int64 result; // rax
  struct CSslCredential *v23; // r14
  CCipherMill *v24; // rcx
  size_t v25; // r14
  unsigned __int8 *v26; // rax
  size_t v27; // r15
  int v28; // r14d
  size_t v29; // r15
  unsigned int v30; // edx
  __int128 *v31; // r8
  __int64 v32; // rdx
  DWORD *pcbResult; // [rsp+38h] [rbp-61h]
  size_t v34; // [rsp+50h] [rbp-49h]
  BOOL v35; // [rsp+68h] [rbp-31h]
  LPCWSTR v36; // [rsp+70h] [rbp-29h] BYREF
  __int128 v37; // [rsp+78h] [rbp-21h] BYREF
  int v38; // [rsp+88h] [rbp-11h]
  unsigned __int8 *v39; // [rsp+90h] [rbp-9h]
  struct CSslContext *v40; // [rsp+E8h] [rbp+4Fh] BYREF
  struct CSslCredential *v41; // [rsp+F0h] [rbp+57h]
  void *v42; // [rsp+F8h] [rbp+5Fh]
  unsigned int v43; // [rsp+100h] [rbp+67h]

  v43 = a4;
  v42 = a3;
  v41 = a2;
  v40 = a1;
  v13 = pcbEncoded;
  v14 = String1;
  LastError = 0;
  v16 = 0i64;
  v35 = 0;
  v17 = 0;
  LODWORD(pcbEncoded) = *pcbEncoded;
  if ( !wcsncmp(String1, L"RSA", 3ui64) )
    v17 = 1;
  else
    v35 = wcsncmp(v14, L"DSA", 3ui64) == 0;
  v18 = (__int64)v40;
  pbSignature = pbEncoded;
  if ( !*((_BYTE *)v40 + 266) )
  {
    v36 = 0i64;
    v20 = 0i64;
    LODWORD(v40) = 0;
    v21 = a5;
    v37 = 0i64;
    if ( v17 )
    {
      if ( a5 == 8 )
      {
        v20 = (LPCWSTR *)&v37;
        *(_QWORD *)&v37 = a7;
        DWORD2(v37) = cbHashValue;
      }
      else
      {
        if ( a5 != 2 )
          return 1359i64;
        v20 = &v36;
        v36 = a7;
      }
    }
    if ( SslImpersonateClient((__int64)v42, (int *)&v40) )
      return 1359i64;
    LastError = NCryptSignHash(*((_QWORD *)v41 + 13), v20, pbHashValue, cbHashValue, pbSignature, *v13, v13, v21 | 0x40);
    if ( (_DWORD)v40 )
      RevertToSelf();
    if ( LastError )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          42i64,
          &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
          LastError);
      return LastError;
    }
LABEL_28:
    v24 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 44i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids, *v13);
      v24 = WPP_GLOBAL_Control;
    }
    if ( !v17 )
    {
      v25 = *v13;
      v26 = (unsigned __int8 *)SPExternalAlloc(*v13);
      v16 = v26;
      if ( !v26 )
        return 14;
      v27 = v25;
      memcpy_0(v26, pbSignature, v25);
      v28 = (unsigned int)v25 >> 1;
      v29 = v27 >> 1;
      if ( !*((_QWORD *)v41 + 14) )
      {
        ReverseInPlace(v16, v28);
        ReverseInPlace(&v16[v29], v30);
      }
      *v13 = (unsigned int)pcbEncoded;
      if ( v35 )
      {
        v31 = (__int128 *)v16;
        v32 = 40i64;
      }
      else
      {
        *((_QWORD *)&v37 + 1) = v16;
        v39 = &v16[v29];
        v31 = &v37;
        LODWORD(v37) = v28;
        v32 = 47i64;
        v38 = v28;
      }
      if ( !CryptEncodeObject(1u, (LPCSTR)v32, v31, pbSignature, v13) )
      {
        LastError = GetLastError();
LABEL_46:
        SPExternalFree(v16);
        return LastError;
      }
      v24 = WPP_GLOBAL_Control;
    }
    if ( v24 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v24 + 28) & 4) != 0 )
      WPP_SF_D(*((_QWORD *)v24 + 2), 45i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids, *v13);
    if ( !v16 )
      return LastError;
    goto LABEL_46;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 43i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
    v18 = (__int64)v40;
  }
  if ( a12 )
  {
    v23 = v41;
    *v13 = a13;
    goto LABEL_25;
  }
  LODWORD(v34) = cbHashValue;
  pcbResult = (DWORD *)v14;
  v23 = v41;
  result = RemotelySignHash(
             *((_QWORD *)v41 + 14),
             *(_QWORD *)(v18 + 104),
             *((_QWORD *)v41 + 13),
             *((_DWORD *)v41 + 32),
             v43,
             a5,
             (LPCWSTR)pcbResult,
             a7,
             pbHashValue,
             v34);
  LastError = result;
  if ( !(_DWORD)result )
  {
LABEL_25:
    if ( v17 && *((_QWORD *)v23 + 14) )
      ReverseInPlace(pbSignature, *v13);
    goto LABEL_28;
  }
  return result;
}
// 180061AB2: variable 'v34' is possibly undefined
// 180061B69: variable 'v30' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180061C24) ----------------------------------------------------
__int64 __fastcall CCipherMill::EnumEccCurvesFromCipherToProvTable(
        CCipherMill *this,
        struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *a2,
        unsigned int a3,
        unsigned int *a4,
        struct _NCRYPT_SSL_ECC_CURVE **a5)
{
  unsigned int v5; // ebx
  unsigned int v9; // edi
  struct _NCRYPT_SSL_ECC_CURVE *v10; // r8
  unsigned int v11; // r10d
  unsigned int v12; // r9d
  _DWORD *v13; // rax
  unsigned int v14; // edx
  __int64 v15; // rdx
  __int64 v16; // rax
  char *v17; // r9
  char *v18; // rcx
  __int128 v19; // xmm0

  v5 = 0;
  v9 = 0;
  if ( !a4 || !a5 )
    return 3221225485i64;
  *a5 = 0i64;
  *a4 = 0;
  v10 = (struct _NCRYPT_SSL_ECC_CURVE *)SPExternalAlloc(0x924u);
  if ( v10 )
  {
    v11 = 0;
    if ( a3 )
    {
      while ( 1 )
      {
        v12 = 0;
        v13 = &unk_18008018C;
        while ( *(_DWORD *)(*(_QWORD *)a2 + 676i64) != *v13 )
        {
          ++v12;
          v13 += 198;
          if ( v12 >= 3 )
            goto LABEL_16;
        }
        v14 = 0;
        if ( v9 )
        {
          while ( *((_DWORD *)&off_18007FE80 + 198 * v12 + 195) != *((_DWORD *)v10 + 195 * v14 + 193) )
          {
            if ( ++v14 >= v9 )
              goto LABEL_13;
          }
        }
        else
        {
LABEL_13:
          v15 = 792i64 * v12;
          v16 = 6i64;
          v17 = (char *)v10 + 780 * v9;
          v18 = (char *)&off_18007FE80 + v15 + 8;
          do
          {
            v19 = *(_OWORD *)v18;
            v18 += 128;
            *(_OWORD *)v17 = v19;
            v17 += 128;
            *((_OWORD *)v17 - 7) = *((_OWORD *)v18 - 7);
            *((_OWORD *)v17 - 6) = *((_OWORD *)v18 - 6);
            *((_OWORD *)v17 - 5) = *((_OWORD *)v18 - 5);
            *((_OWORD *)v17 - 4) = *((_OWORD *)v18 - 4);
            *((_OWORD *)v17 - 3) = *((_OWORD *)v18 - 3);
            *((_OWORD *)v17 - 2) = *((_OWORD *)v18 - 2);
            *((_OWORD *)v17 - 1) = *((_OWORD *)v18 - 1);
            --v16;
          }
          while ( v16 );
          ++v9;
          *(_QWORD *)v17 = *(_QWORD *)v18;
          *((_DWORD *)v17 + 2) = *((_DWORD *)v18 + 2);
        }
LABEL_16:
        if ( v9 == 3 )
          break;
        ++v11;
        a2 = (struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *)((char *)a2 + 16);
        if ( v11 >= a3 )
        {
          if ( !v9 )
            goto LABEL_20;
          break;
        }
      }
      *a5 = v10;
      *a4 = v9;
    }
    else
    {
LABEL_20:
      SPExternalFree(v10);
    }
  }
  else
  {
    return 14;
  }
  return v5;
}
// 18007FE80: using guessed type wchar_t *off_18007FE80;

//----- (0000000180061DDC) ----------------------------------------------------
__int64 __fastcall CCipherMill::GetEccCurveFlags(CCipherMill *this, int a2, unsigned int *a3)
{
  unsigned int EccCurveFlags; // ebx

  if ( !a2 || !a3 )
    return 87i64;
  if ( !qword_1800925C8 )
    return 1359i64;
  RtlAcquireResourceShared(&Resource, 1u);
  EccCurveFlags = CMasterEccCurveInfo::GetEccCurveFlags(qword_1800925C8, a2, a3);
  RtlReleaseResource(&Resource);
  return EccCurveFlags;
}

//----- (0000000180061E5C) ----------------------------------------------------
__int64 __fastcall CMasterEccCurveInfo::GetEccCurveFlags(CMasterEccCurveInfo *this, int a2, unsigned int *a3)
{
  unsigned __int64 v3; // r9
  unsigned __int64 v4; // r10
  unsigned __int64 i; // rcx

  v3 = *(_QWORD *)this;
  v4 = *(_QWORD *)this + 32i64 * *((unsigned int *)this + 2);
LABEL_7:
  if ( v3 >= v4 )
    return 1168i64;
  for ( i = *(_QWORD *)v3; ; i += 780i64 )
  {
    if ( i >= *(_QWORD *)v3 + 780 * (unsigned __int64)*(unsigned int *)(v3 + 8) )
    {
      v3 += 32i64;
      goto LABEL_7;
    }
    if ( *(_DWORD *)(i + 772) == a2 )
      break;
  }
  *a3 = *(_DWORD *)(i + 776);
  return 0i64;
}

//----- (0000000180061EBC) ----------------------------------------------------
__int64 __fastcall FilterFipsEccCurves(__int64 a1, unsigned int *a2)
{
  unsigned int v2; // r8d
  unsigned int v3; // r9d
  unsigned int i; // r10d
  unsigned int v5; // r11d
  int v6; // ebx
  _DWORD *v7; // rax
  __int64 v8; // rax

  v2 = 0;
  v3 = 0;
  if ( a1 && a2 )
  {
    for ( i = 0; i < *a2; ++i )
    {
      v5 = 0;
      v6 = *(_DWORD *)(a1 + 4i64 * i);
      v7 = &unk_180085820;
      while ( v6 != *v7 )
      {
        ++v5;
        ++v7;
        if ( v5 >= 3 )
          goto LABEL_9;
      }
      v8 = v3++;
      *(_DWORD *)(a1 + 4 * v8) = v6;
LABEL_9:
      if ( v3 == 3 )
        break;
    }
    *a2 = v3;
  }
  else
  {
    return (unsigned int)-1073741811;
  }
  return v2;
}

//----- (0000000180061F30) ----------------------------------------------------
__int64 __fastcall GetSslEccCurveTypeOrderFromCipherSuiteList(__int64 a1, _QWORD *a2, unsigned int *a3)
{
  unsigned int v3; // ebx
  unsigned int v6; // edi
  _DWORD *v7; // r15
  unsigned int i; // ebp
  __int64 v9; // rdx
  __int64 v10; // rax
  unsigned int v11; // esi
  const wchar_t **v12; // r14
  const wchar_t *v13; // rax
  int v14; // edx
  __int64 v15; // rcx
  const wchar_t *v18; // [rsp+78h] [rbp+20h]

  v3 = 0;
  v6 = 0;
  if ( a2 && a3 )
  {
    v7 = SPExternalAlloc(0xCu);
    if ( v7 )
    {
      for ( i = 0; i < *(_DWORD *)a1; ++i )
      {
        v9 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64 * i);
        v10 = -1i64;
        do
          ++v10;
        while ( *(_WORD *)(v9 + 2 * v10) );
        if ( (unsigned int)v10 >= 5 )
        {
          v11 = 0;
          v12 = (const wchar_t **)&off_18007FE80;
          v13 = (const wchar_t *)(v9 + 2 * ((unsigned int)v10 - 5i64));
          v18 = v13;
          while ( wcsicmp(v13, *v12) )
          {
            v13 = v18;
            ++v11;
            v12 += 99;
            if ( v11 >= 3 )
              goto LABEL_12;
          }
          v14 = 0;
          if ( v6 )
          {
            while ( v7[v14] != *((_DWORD *)&off_18007FE80 + 198 * v11 + 195) )
            {
              if ( ++v14 >= v6 )
                goto LABEL_18;
            }
          }
          else
          {
LABEL_18:
            v15 = v6++;
            v7[v15] = *((_DWORD *)&off_18007FE80 + 198 * v11 + 195);
          }
LABEL_12:
          if ( v6 == 3 )
            break;
        }
      }
      *a3 = v6;
      *a2 = v7;
    }
    else
    {
      return (unsigned int)-1073741670;
    }
  }
  else
  {
    return (unsigned int)-1073741811;
  }
  return v3;
}
// 18007FE80: using guessed type wchar_t *off_18007FE80;

//----- (0000000180062074) ----------------------------------------------------
__int64 IsEccCurveGroupPolicyEnabled()
{
  unsigned int v0; // ebx
  DWORD Type; // [rsp+40h] [rbp+8h] BYREF
  DWORD cbData; // [rsp+48h] [rbp+10h] BYREF
  HKEY hKey; // [rsp+50h] [rbp+18h] BYREF

  hKey = 0i64;
  v0 = 0;
  if ( RegOpenKeyExW(
         HKEY_LOCAL_MACHINE,
         L"Software\\Policies\\Microsoft\\Cryptography\\Configuration\\SSL\\00010002",
         0,
         0x20119u,
         &hKey)
    || !RegQueryValueExW(hKey, L"EccCurves", 0i64, &Type, 0i64, &cbData) && Type == 7 )
  {
    v0 = 1;
  }
  if ( hKey )
    RegCloseKey(hKey);
  return v0;
}

//----- (0000000180062118) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::DigestCertVerify(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  unsigned __int16 *v4; // r13
  unsigned int v5; // ecx
  unsigned int v6; // r14d
  __int64 v8; // rax
  unsigned int v9; // edx
  int v11; // esi
  __int64 v12; // rax
  int v13; // edi
  unsigned __int8 v14; // r9
  int v15; // edx
  unsigned __int16 *v16; // rax
  int v17; // r8d
  int v18; // edx
  __int64 result; // rax
  __int16 v20; // r14
  unsigned int *v21; // r9
  unsigned __int8 v22; // r9
  int v23; // r8d
  int v24; // eax
  int v25; // esi
  unsigned __int8 *v26; // r15
  DWORD v27; // esi
  DWORD PublicKeyLength; // edi
  const unsigned __int16 *v29; // rdx
  enum _eTlsHashAlgorithm v30; // [rsp+40h] [rbp-20h] BYREF
  enum _eTlsSignatureAlgorithm v31; // [rsp+44h] [rbp-1Ch] BYREF
  unsigned __int16 *v32; // [rsp+48h] [rbp-18h]
  unsigned __int16 *v33; // [rsp+50h] [rbp-10h] BYREF
  unsigned int v34; // [rsp+A0h] [rbp+40h] BYREF
  unsigned int v35; // [rsp+B8h] [rbp+58h] BYREF

  v4 = 0i64;
  v5 = 0;
  v33 = 0i64;
  v6 = 0;
  v30 = TlsHashAlgorithm_None;
  v34 = 0;
  v8 = *((_QWORD *)this + 11);
  v9 = 0;
  v35 = 0;
  if ( !v8 || !*(_QWORD *)(v8 + 48) )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 30i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
    v14 = 40;
    v15 = 1300;
    goto LABEL_40;
  }
  v11 = 3;
  v12 = *(_QWORD *)(*((_QWORD *)this + 124) + 40i64);
  if ( !v12 )
  {
    v13 = 8707;
LABEL_12:
    v16 = L"ECDSA";
    goto LABEL_13;
  }
  v13 = *(_DWORD *)(*(_QWORD *)v12 + 4i64);
  if ( v13 == 8704 )
  {
    v11 = 2;
    v16 = L"DSA";
    goto LABEL_13;
  }
  if ( v13 == 8707 )
    goto LABEL_12;
  if ( v13 != 9216 && v13 != 41984 )
  {
    v14 = 43;
    v15 = 1302;
LABEL_40:
    CSslContext::SetErrorAndFatalAlert((__int64)this, v15, -2146893018, v14);
    return 1359i64;
  }
  v11 = 1;
  v16 = L"RSA";
  v6 = 2;
  v34 = 2;
LABEL_13:
  v17 = *((_DWORD *)this + 16);
  v32 = v16;
  if ( (v17 & 0x40400) != 0 )
  {
    if ( a3 < 2 )
    {
      v18 = 1307;
LABEL_16:
      CSslContext::SetErrorAndFatalAlert((__int64)this, v18, -2146893018, 0x32u);
      return 2148074278i64;
    }
    v20 = *(_WORD *)a2;
    if ( !CTlsSignatureSuiteList::IsSupportedCodePoint((CSsl3TlsServerContext *)((char *)this + 474), *(_WORD *)a2) )
    {
      v22 = 47;
      v23 = -2146893048;
LABEL_19:
      CSslContext::SetErrorAndFatalAlert((__int64)this, 1307, v23, v22);
      return 2148074289i64;
    }
    v31 &= (unsigned int)v21;
    GetSignatureSuiteInfoByCodePoint(v20, &v31, &v30, v21, (const unsigned __int16 **)&v33, &v35, &v34);
    a2 += 2;
    a3 -= 2;
    if ( v31 != v11 )
    {
      v22 = 40;
      v23 = -2146893007;
      goto LABEL_19;
    }
    v4 = v33;
    v6 = v34;
    v5 = v30;
    v9 = v35;
  }
  if ( a3 < 2 || (v24 = a2[1], v25 = *a2, v26 = a2 + 2, v27 = v24 + (v25 << 8), v27 + 2 > a3) )
  {
    v18 = 1300;
    goto LABEL_16;
  }
  result = CheckClientVerifyMessage(this, v32, v4, v5, v9, v6, v26, v27);
  if ( (_DWORD)result && v13 == 8707 )
  {
    RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
    PublicKeyLength = CertGetPublicKeyLength(
                        **(_DWORD **)(*((_QWORD *)this + 11) + 48i64),
                        (PCERT_PUBLIC_KEY_INFO)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 11) + 48i64) + 24i64) + 96i64));
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
    switch ( PublicKeyLength )
    {
      case 0x100u:
        v29 = L"ECDSA_P256";
        break;
      case 0x180u:
        v29 = L"ECDSA_P384";
        break;
      case 0x209u:
        v29 = L"ECDSA_P521";
        break;
      default:
        v14 = 43;
        v15 = 1301;
        goto LABEL_40;
    }
    return CheckClientVerifyMessage(this, v29, v4, v30, v35, v6, v26, v27);
  }
  return result;
}
// 18006225C: variable 'v21' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800821D8: using guessed type wchar_t aEcdsaP384[11];
// 180082E10: using guessed type wchar_t aEcdsaP521[11];

//----- (0000000180062430) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::DigestUnifiedHello(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        __int64 a3)
{
  ULONG RandomBits; // ebx
  int v5; // eax
  unsigned int *v6; // rsi
  unsigned __int8 v7; // r9
  int v8; // edx
  unsigned int v9; // edx
  HLOCAL Memory; // rax
  __int64 v11; // rcx
  int NewServerItem; // ebx
  __int64 v13; // rcx
  int v15; // [rsp+30h] [rbp-50h] BYREF
  struct _Ssl2_Client_Hello *v16; // [rsp+38h] [rbp-48h] BYREF
  int v17; // [rsp+40h] [rbp-40h] BYREF
  int v18; // [rsp+44h] [rbp-3Ch]
  unsigned __int8 *v19; // [rsp+48h] [rbp-38h]
  UCHAR pbBuffer[16]; // [rsp+50h] [rbp-30h] BYREF
  __int128 v21; // [rsp+60h] [rbp-20h]

  v16 = 0i64;
  v15 = 0;
  *(_OWORD *)pbBuffer = 0i64;
  v21 = 0i64;
  if ( (unsigned int)a3 < 2 )
  {
    RandomBits = -2146893018;
    CSslContext::SetErrorAndFatalAlert((__int64)this, 1203, -2146893018, 0x32u);
    return RandomBits;
  }
  v19 = a2;
  v18 = a3;
  v17 = a3;
  v5 = Ssl2UnpackClientHello((struct SPBuffer *)&v17, &v16, a3, &v15);
  v6 = (unsigned int *)v16;
  RandomBits = v5;
  if ( v5 )
  {
    v7 = 10;
    v8 = 1203;
    goto LABEL_20;
  }
  if ( v15 )
  {
    *((_BYTE *)this + 553) = 1;
    goto LABEL_7;
  }
  if ( g_fAllowInsecureRenegoClients )
  {
LABEL_7:
    if ( *((_QWORD *)this + 110) )
    {
      (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 16i64))(this);
      *((_QWORD *)this + 110) = 0i64;
    }
    v9 = v18 - 2;
    *((_DWORD *)this + 218) = v18 - 2;
    Memory = CSslContext::GetMemory(this, v9);
    *((_QWORD *)this + 110) = Memory;
    if ( !Memory )
      goto LABEL_10;
    memcpy_0(Memory, v19 + 2, *((unsigned int *)this + 218));
    memset_0((char *)this + 272, 0, 32 - v6[3]);
    memcpy_0((char *)this - v6[3] + 304, v6 + 12, v6[3]);
    RandomBits = GenerateRandomBits(pbBuffer, 0x20u);
    if ( RandomBits )
      goto LABEL_21;
    CSessionCacheManager::AcquireCacheTableLock(v11, 0i64, pbBuffer);
    NewServerItem = CSessionCacheManager::CacheRetrieveNewServerItem(
                      CSessionCacheManager::m_pSessionCacheManager,
                      *((_DWORD *)this + 16),
                      pbBuffer,
                      (struct CSessionCacheServerItem **)this + 124);
    CSessionCacheManager::ReleaseCacheTableLock(v13, 0i64, pbBuffer);
    if ( NewServerItem )
    {
LABEL_10:
      RandomBits = -2146893056;
      goto LABEL_21;
    }
    *((_QWORD *)this + 11) = *((_QWORD *)this + 124);
    v5 = CCipherMill::ChooseServerCipher((CCipherMill *)g_cCipherMill, this, v6 + 20, v6[1], *((_DWORD *)this + 16), 0);
    RandomBits = v5;
    if ( !v5 )
    {
LABEL_21:
      if ( v6 )
        SPExternalFree(v6);
      return RandomBits;
    }
    v7 = 40;
    v8 = 1204;
LABEL_20:
    CSslContext::SetErrorAndFatalAlert((__int64)this, v8, v5, v7);
    goto LABEL_21;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 49i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
  RandomBits = -2146892986;
  CSslContext::SetErrorAndFatalAlert((__int64)this, 1207, -2146892986, 0x28u);
  *((_DWORD *)this + 17) = 96;
  *((_WORD *)this + 48) = 10242;
  return RandomBits;
}
// 1800625E7: variable 'v11' is possibly undefined
// 180062611: variable 'v13' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800919AC: using guessed type int g_fAllowInsecureRenegoClients;

//----- (0000000180062690) ----------------------------------------------------
__int64 __fastcall GenerateCertificateRequest(
        unsigned __int8 *Src,
        size_t Size,
        struct CTlsSignatureSuiteList *this,
        enum eTlsCertificateType *a4,
        unsigned __int8 a5,
        unsigned __int8 *a6,
        unsigned int *a7)
{
  size_t v7; // rdi
  unsigned int v8; // esi
  unsigned int v10; // r10d
  int v11; // eax
  unsigned __int8 *v13; // rbx
  __int64 v14; // rcx
  unsigned __int8 v15; // al

  v7 = (unsigned int)Size;
  v8 = 0;
  v10 = Size + a5 + 3;
  if ( this )
  {
    v11 = *(unsigned __int16 *)this;
    v10 += 2 * v11 + 2;
    v8 = 2 * v11 + 2;
  }
  if ( a6 )
  {
    if ( *a7 < v10 )
      return 1359i64;
    *a6 = a5;
    v13 = a6 + 1;
    if ( a5 )
    {
      v14 = a5;
      do
      {
        v15 = *(_BYTE *)a4;
        a4 = (enum eTlsCertificateType *)((char *)a4 + 4);
        *v13++ = v15;
        --v14;
      }
      while ( v14 );
    }
    if ( this )
    {
      CTlsSignatureSuiteList::BuildSupportedSignatureAlgorithms(this, v13, v8);
      v13 += v8;
    }
    v13[1] = v7;
    *v13 = BYTE1(v7);
    if ( Src )
      memcpy_0(v13 + 2, Src, v7);
  }
  else
  {
    *a7 = v10;
  }
  return 0i64;
}

//----- (0000000180062768) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::GenerateHelloRequest(CSsl3TlsServerContext *this, struct SPBuffer *a2)
{
  char v2; // r14
  unsigned int v5; // edi
  unsigned int v6; // r8d
  unsigned int v7; // esi
  unsigned int v8; // r8d
  unsigned int v9; // ecx
  __int64 result; // rax
  int v11; // eax
  unsigned int v12; // edi
  __int16 v13; // [rsp+20h] [rbp-18h]
  int v14; // [rsp+28h] [rbp-10h]

  v2 = *((_BYTE *)this + 233);
  v5 = v2 != 0 ? 12 : 4;
  v6 = v5;
  if ( (*((_BYTE *)this + 32) & 4) != 0 )
  {
    v7 = *((_DWORD *)this + 11);
    v8 = v5 + *((_DWORD *)this + 12);
    v9 = *((_DWORD *)this + 13);
    if ( v9 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v9 -= v8 % v9;
      v8 += v9;
    }
    v6 = v7 + v8;
  }
  else
  {
    v7 = 0;
  }
  result = CSsl3TlsContext::AllocateOutputBuffer(this, a2, *((_DWORD *)this + 15) + v6);
  if ( !(_DWORD)result )
  {
    v14 = *((unsigned __int8 *)this + 233);
    v13 = *((_WORD *)this + 110);
    *((_WORD *)this + 110) = v13 + 1;
    SetHandshakeHeader(v7 + *((_QWORD *)a2 + 1) + (v2 != 0 ? 13i64 : 5i64), 0, 0i64, 0, v13, v14);
    v11 = CSsl3TlsContext::WrapMessage((__int64)this, (__int64)a2, 22, v5);
    v12 = v11;
    if ( v11 )
      CSslContext::SetErrorAndFatalAlert((__int64)this, 953, v11, 0x50u);
    else
      *((_BYTE *)this + 555) = 1;
    return v12;
  }
  return result;
}

//----- (0000000180062884) ----------------------------------------------------
void __fastcall CSsl3TlsServerContext::GenerateNewSessionTicket(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int8 *a4,
        unsigned int *a5)
{
  unsigned __int8 v5; // r10
  size_t v7; // rsi
  int v10; // r14d
  unsigned int v11; // ebp
  unsigned __int8 *v12; // rcx
  __int16 v13; // [rsp+20h] [rbp-28h]

  v5 = *((_BYTE *)this + 233);
  v7 = a3;
  v10 = a3 + 10 + (v5 != 0 ? 8 : 0);
  v13 = *((_WORD *)this + 110);
  v11 = CSslGlobals::m_dwSessionTicketLifespan / 0x3E8;
  *((_WORD *)this + 110) = v13 + 1;
  SetHandshakeHeader((__int64)a4, 4, 0i64, v10 - (v5 != 0 ? 12 : 4), v13, v5);
  if ( *((_BYTE *)this + 233) )
  {
    a4[13] = BYTE2(v11);
    v12 = a4 + 18;
    a4[12] = HIBYTE(v11);
    a4[14] = BYTE1(v11);
    a4[15] = v11;
    a4[16] = BYTE1(v7);
    a4[17] = v7;
  }
  else
  {
    a4[5] = BYTE2(v11);
    v12 = a4 + 10;
    a4[4] = HIBYTE(v11);
    a4[6] = BYTE1(v11);
    a4[7] = v11;
    a4[8] = BYTE1(v7);
    a4[9] = v7;
  }
  memcpy_0(v12, a2, v7);
  *a5 = v10;
}

//----- (0000000180062998) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::InitUpdateClientHash(CSsl3TlsServerContext *this)
{
  __int64 result; // rax
  unsigned int v3; // edi

  result = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 496i64))(this);
  if ( !(_DWORD)result )
  {
    *((_BYTE *)this + 340) = 0;
    v3 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 504i64))(
           this,
           *((_QWORD *)this + 110),
           *((unsigned int *)this + 218),
           0i64);
    if ( *((_QWORD *)this + 110) )
    {
      (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 16i64))(this);
      *((_QWORD *)this + 110) = 0i64;
    }
    *((_DWORD *)this + 218) = 0;
    if ( v3 )
      CSslContext::SetErrorAndFatalAlert((__int64)this, 1007, v3, 0x50u);
    return v3;
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180062A60) ----------------------------------------------------
bool __fastcall CSsl3TlsServerContext::IsWaitingForCCS(CSsl3TlsServerContext *this)
{
  int v1; // eax

  v1 = *((_DWORD *)this + 17);
  if ( v1 == 61 )
    return (*((_DWORD *)this + 34) & 0x100i64) == 0 || *((_BYTE *)this + 552) != 0;
  else
    return ((v1 - 62) & 0xFFFFFFFD) == 0;
}

//----- (0000000180062AA8) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::SelectSrtpParameters(
        CSsl3TlsServerContext *this,
        unsigned __int16 *const a2,
        unsigned __int16 a3,
        unsigned __int8 *const a4,
        unsigned __int8 a5)
{
  unsigned __int8 *v9; // rsi
  char v10; // bp
  __int64 result; // rax
  unsigned __int16 *v12; // rax
  __int16 MatchingProtectionProfile; // r15
  unsigned __int8 *v14; // rax
  unsigned int v15; // edi

  v9 = 0i64;
  v10 = 0;
  result = CSsl3TlsContext::ValidateProtectionProfiles(a2, a3, 1);
  if ( !(_DWORD)result )
  {
    v12 = (unsigned __int16 *)*((_QWORD *)this + 100);
    if ( !v12 )
      return 87i64;
    if ( a4 )
    {
      if ( !a5 )
        return 87i64;
    }
    else if ( a5 )
    {
      return 87i64;
    }
    MatchingProtectionProfile = CSsl3TlsContext::FindMatchingProtectionProfile(v12 + 1, *v12, a2, a3);
    if ( !MatchingProtectionProfile )
    {
      CSsl3TlsContext::FreeSelectedSrtpParameters(this);
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 62i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      return 0i64;
    }
    if ( a5 && *((_BYTE *)this + 988) )
    {
      v14 = (unsigned __int8 *)(*(__int64 (__fastcall **)(CSsl3TlsServerContext *, _QWORD))(*(_QWORD *)this + 8i64))(
                                 this,
                                 a5);
      v9 = v14;
      if ( !v14 )
        return 14i64;
      memcpy_0(v14, a4, a5);
      v10 = a5;
    }
    v15 = CSsl3TlsContext::SetSelectedSrtpParameters(this, MatchingProtectionProfile, v9, v10);
    if ( !v15 )
      return 0i64;
    if ( v9 )
      (*(void (__fastcall **)(CSsl3TlsServerContext *, unsigned __int8 *))(*(_QWORD *)this + 16i64))(this, v9);
    return v15;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180062C20) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::SelectTBParameters(
        CSsl3TlsServerContext *this,
        char a2,
        char a3,
        unsigned __int8 *const a4,
        unsigned __int16 a5)
{
  unsigned __int8 *v8; // rbx
  unsigned __int8 *v9; // r10
  __int64 v10; // rdx
  _BYTE *v11; // rax
  unsigned __int64 v12; // rcx
  CCipherMill *v13; // rcx
  __int64 v14; // rdx
  unsigned __int8 *v15; // rsi
  unsigned int v17; // ebx

  v8 = a4;
  v9 = &a4[a5];
  if ( !a5 || !a4 )
    return 87i64;
  v10 = *((_QWORD *)this + 102);
  if ( !v10 || *(_BYTE *)v10 != a2 || *(_BYTE *)(v10 + 1) != a3 )
  {
    v13 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) == 0 )
      return 0i64;
    v14 = 63i64;
    goto LABEL_24;
  }
  v11 = (_BYTE *)(v10 + 4);
  v12 = v10 + 4 + *(unsigned __int16 *)(v10 + 2);
  while ( (unsigned __int64)v11 < v12 )
  {
    v8 = a4;
    if ( a4 < v9 )
    {
      while ( *v11 != *v8 )
      {
        if ( ++v8 >= v9 )
          goto LABEL_10;
      }
      break;
    }
LABEL_10:
    ++v11;
  }
  if ( v11 == (_BYTE *)v12 )
  {
    v13 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) == 0 )
      return 0i64;
    v14 = 64i64;
LABEL_24:
    WPP_SF_(*((_QWORD *)v13 + 2), v14, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
    return 0i64;
  }
  v15 = (unsigned __int8 *)(*(__int64 (__fastcall **)(CSsl3TlsServerContext *, __int64))(*(_QWORD *)this + 8i64))(
                             this,
                             1i64);
  if ( !v15 )
    return 14i64;
  *v15 = *v8;
  v17 = CSsl3TlsContext::SetSelectedTBParameters(this, a2, a3, v15, 1u);
  if ( v17 )
    (*(void (__fastcall **)(CSsl3TlsServerContext *, unsigned __int8 *))(*(_QWORD *)this + 16i64))(this, v15);
  return v17;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180062DB4) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::SerializeAndProtectSessionState(
        CSsl3TlsServerContext *this,
        HLOCAL *a2,
        unsigned __int16 *a3)
{
  __int64 v6; // rcx
  __int64 result; // rax
  unsigned __int8 *v8; // r13
  __int64 v9; // rcx
  unsigned int KeyFilePath; // esi
  CCredentialGroup *v11; // rcx
  __int64 v12; // rax
  CCipherMill *v13; // rcx
  __int64 v14; // rax
  __int64 v15; // rbx
  __int64 v16; // rdi
  int v17; // [rsp+30h] [rbp-20h] BYREF
  HLOCAL hMem; // [rsp+38h] [rbp-18h] BYREF
  unsigned __int16 *v19; // [rsp+40h] [rbp-10h] BYREF
  unsigned int v20; // [rsp+98h] [rbp+48h] BYREF
  unsigned int v21; // [rsp+A8h] [rbp+58h] BYREF

  if ( !a2 || *a2 || !a3 || *a3 )
    return 87i64;
  v6 = *((_QWORD *)this + 124);
  v20 = 0;
  result = (*(__int64 (__fastcall **)(__int64, CSsl3TlsServerContext *, unsigned int *))(*(_QWORD *)v6 + 40i64))(
             v6,
             this,
             &v20);
  if ( (_DWORD)result )
    return result;
  v8 = (unsigned __int8 *)(*(__int64 (__fastcall **)(CSsl3TlsServerContext *, _QWORD))(*(_QWORD *)this + 8i64))(
                            this,
                            v20);
  if ( !v8 )
    return 14i64;
  v9 = *((_QWORD *)this + 124);
  hMem = 0i64;
  KeyFilePath = (*(__int64 (__fastcall **)(__int64, CSsl3TlsServerContext *, unsigned __int8 *, _QWORD, unsigned int *))(*(_QWORD *)v9 + 48i64))(
                  v9,
                  this,
                  v8,
                  v20,
                  &v20);
  if ( !KeyFilePath )
  {
    v11 = (CCredentialGroup *)*((_QWORD *)this + 10);
    v21 = 0;
    v19 = 0i64;
    KeyFilePath = CCredentialGroup::GetKeyFilePath(v11, &v19);
    if ( KeyFilePath )
    {
LABEL_25:
      if ( KeyFilePath - 2 <= 1 )
      {
        v14 = *((_QWORD *)this + 10);
        if ( !*(_DWORD *)(v14 + 896) )
        {
          LogSessionTicketMisconfiguration(*(_DWORD *)(v14 + 212), (const unsigned __int16 *)(v14 + 216), v19);
          v15 = *((_QWORD *)this + 10);
          RtlAcquireResourceExclusive((PRTL_RESOURCE)(v15 + 48), 1u);
          *(_DWORD *)(v15 + 896) = 1;
          RtlReleaseResource((PRTL_RESOURCE)(v15 + 48));
        }
      }
      if ( !KeyFilePath )
      {
        v16 = *((_QWORD *)this + 10);
        if ( *(_DWORD *)(v16 + 896) )
        {
          RtlAcquireResourceExclusive((PRTL_RESOURCE)(v16 + 48), 1u);
          *(_DWORD *)(v16 + 896) = 0;
          RtlReleaseResource((PRTL_RESOURCE)(v16 + 48));
        }
        *a2 = hMem;
        *a3 = v21;
        hMem = 0i64;
      }
      goto LABEL_32;
    }
    v12 = *((_QWORD *)this + 10);
    v17 = 0;
    KeyFilePath = SslImpersonateClient(*(_QWORD *)(v12 + 752), &v17);
    if ( KeyFilePath )
    {
LABEL_23:
      if ( v17 )
        RevertToSelf();
      goto LABEL_25;
    }
    if ( g_pKeyFileProtectSessionTicket )
    {
      KeyFilePath = g_pKeyFileProtectSessionTicket(v8, v20, v19, (unsigned __int8 **)&hMem, &v21);
      if ( !KeyFilePath )
        goto LABEL_18;
    }
    else
    {
      KeyFilePath = 1157;
    }
    v13 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
    {
LABEL_19:
      if ( v21 > 0xFFFF )
      {
        KeyFilePath = 1359;
        if ( v13 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v13 + 28) & 1) != 0 )
          WPP_SF_D(*((_QWORD *)v13 + 2), 52i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids, v21);
      }
      goto LABEL_23;
    }
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 51i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids, KeyFilePath);
LABEL_18:
    v13 = WPP_GLOBAL_Control;
    goto LABEL_19;
  }
LABEL_32:
  (*(void (__fastcall **)(CSsl3TlsServerContext *, unsigned __int8 *))(*(_QWORD *)this + 16i64))(this, v8);
  if ( hMem )
    LocalFree(hMem);
  return KeyFilePath;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092188: using guessed type unsigned int (__stdcall *g_pKeyFileProtectSessionTicket)(unsigned __int8 *, unsigned int, const unsigned __int16 *, unsigned __int8 **, unsigned int *);

//----- (0000000180063098) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::SetServerNameIndication(
        CSsl3TlsServerContext *this,
        const unsigned __int8 *Src,
        unsigned __int16 a3)
{
  size_t v3; // rbx
  const void *v6; // rcx
  HLOCAL Memory; // rax

  v3 = a3;
  if ( !Src || !a3 )
    return 87i64;
  v6 = (const void *)*((_QWORD *)this + 118);
  if ( v6 )
  {
    if ( *((_WORD *)this + 476) != a3 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_dd(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x3Au,
          (__int64)&WPP_095c39149c3f336b5b94efe855075ae2_Traceguids,
          a3,
          *((unsigned __int16 *)this + 476));
      return 2148074278i64;
    }
    if ( RtlCompareMemory(v6, Src, a3) != a3 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 59i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      return 2148074278i64;
    }
  }
  else
  {
    Memory = CSslContext::GetMemory(this, a3);
    *((_QWORD *)this + 118) = Memory;
    if ( !Memory )
      return 2148074240i64;
    memcpy_0(Memory, Src, v3);
    *((_WORD *)this + 476) = v3;
  }
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (00000001800631D0) ----------------------------------------------------
bool __fastcall CSsl3TlsServerContext::UnprotectAndDeserializeSessionState(
        CSsl3TlsServerContext *this,
        unsigned __int8 *const a2,
        unsigned int a3,
        unsigned __int8 *const a4,
        size_t Size)
{
  CCredentialGroup *v9; // rcx
  unsigned int KeyFilePath; // ebx
  CCipherMill *v11; // rcx
  CSessionCacheManager *v12; // rbx
  _QWORD *v13; // r14
  __int64 v14; // rcx
  unsigned int v15; // eax
  __int64 v16; // rcx
  unsigned int v17; // eax
  bool v18; // zf
  unsigned int v20; // [rsp+30h] [rbp-20h] BYREF
  HLOCAL hMem; // [rsp+38h] [rbp-18h] BYREF
  unsigned __int16 *v22; // [rsp+40h] [rbp-10h] BYREF
  int v23; // [rsp+88h] [rbp+38h] BYREF

  if ( !a2 || !a3 || !a4 || (*((_DWORD *)this + 34) & 0x800i64) == 0 )
    return 0;
  v9 = (CCredentialGroup *)*((_QWORD *)this + 10);
  hMem = 0i64;
  v20 = 0;
  v22 = 0i64;
  KeyFilePath = CCredentialGroup::GetKeyFilePath(v9, &v22);
  if ( !KeyFilePath )
  {
    v23 = 0;
    KeyFilePath = SslImpersonateClient(*(_QWORD *)(*((_QWORD *)this + 10) + 752i64), &v23);
    if ( !KeyFilePath )
    {
      if ( !g_pKeyFileUnprotectSessionTicket )
      {
        KeyFilePath = 1157;
LABEL_11:
        v11 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            46i64,
            &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids,
            KeyFilePath);
        goto LABEL_14;
      }
      KeyFilePath = g_pKeyFileUnprotectSessionTicket(a2, a3, v22, (unsigned __int8 **)&hMem, &v20);
      if ( KeyFilePath )
        goto LABEL_11;
    }
LABEL_14:
    if ( v23 )
      RevertToSelf();
    if ( !KeyFilePath )
    {
      v12 = CSessionCacheManager::m_pSessionCacheManager;
      CSessionCacheManager::AcquireCacheTableLock((__int64)v11, 0i64, a4);
      v13 = (_QWORD *)((char *)this + 992);
      KeyFilePath = CSessionCacheManager::CacheRetrieveNewServerItem(
                      v12,
                      *((_DWORD *)this + 16),
                      a4,
                      (struct CSessionCacheServerItem **)this + 124);
      CSessionCacheManager::ReleaseCacheTableLock(v14, 0i64, a4);
      if ( !KeyFilePath )
      {
        v15 = (*(__int64 (__fastcall **)(_QWORD, CSsl3TlsServerContext *, HLOCAL, _QWORD))(*(_QWORD *)*v13 + 56i64))(
                *v13,
                this,
                hMem,
                v20);
        v16 = *v13;
        KeyFilePath = v15;
        if ( v15 )
        {
          *(_BYTE *)(v16 + 236) = 0;
          (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 240i64))(this);
        }
        else
        {
          v17 = Size;
          *(_WORD *)(v16 + 238) = Size;
          memcpy_0((void *)(v16 + 240), a4, v17);
        }
      }
    }
  }
  if ( hMem )
    LocalFree(hMem);
  v18 = KeyFilePath == 0;
  if ( KeyFilePath )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        47i64,
        &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids,
        KeyFilePath);
    return KeyFilePath == 0;
  }
  return v18;
}
// 1800632FA: variable 'v11' is possibly undefined
// 18006331E: variable 'v14' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092180: using guessed type unsigned int (__stdcall *g_pKeyFileUnprotectSessionTicket)(unsigned __int8 *, unsigned int, const unsigned __int16 *, unsigned __int8 **, unsigned int *);

//----- (0000000180063404) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::UpdateHashAndWrapMessage(
        _BYTE *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        int a5,
        int a6)
{
  __int64 v6; // rbp
  unsigned int v7; // esi
  int v9; // eax
  unsigned int v10; // ebx
  int v12; // r8d
  int v13; // eax

  v6 = a4;
  v7 = a3;
  LOBYTE(a4) = 1;
  v9 = (*(__int64 (__fastcall **)(_BYTE *, __int64, __int64, __int64))(*(_QWORD *)a1 + 504i64))(a1, a2, a3, a4);
  v10 = v9;
  if ( v9 )
  {
    v12 = v9;
LABEL_6:
    CSslContext::SetErrorAndFatalAlert((__int64)a1, a5, v12, 0x50u);
    return v10;
  }
  if ( !a1[233] )
  {
    v13 = CSsl3TlsContext::WrapMessage((__int64)a1, v6, 22, v7);
    v10 = v13;
    if ( v13 )
    {
      a5 = a6;
      v12 = v13;
      goto LABEL_6;
    }
  }
  return v10;
}

//----- (00000001800634B0) ----------------------------------------------------
CTlsRecord *__fastcall CTlsRecord::`scalar deleting destructor'(CTlsRecord *this, char a2)
{
  *(_QWORD *)this = &CTlsRecord::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 18007D3F0: using guessed type void *CTlsRecord::`vftable';

//----- (00000001800634E0) ----------------------------------------------------
__int64 __fastcall CTlsRecord::HashPskBinderTranscript(CTlsRecord *this, __int64 a2)
{
  __int64 v4; // r9
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rdx
  unsigned __int16 v8; // cx
  _BYTE *v9; // rdx
  __int64 v10; // rax
  __int64 *v12; // rax
  __int64 v13; // r10

  if ( !a2 )
    return 87i64;
  if ( !*((_WORD *)this + 8) )
    return 87i64;
  v4 = *((_QWORD *)this + 3);
  if ( !v4 )
    return 87i64;
  v5 = *((_QWORD *)this + 4);
  if ( !v5 )
    return 87i64;
  if ( v5 >= v4 + 12 * (unsigned __int64)*((unsigned __int16 *)this + 8) )
    return 87i64;
  if ( (*(_BYTE *)(v5 + 8) & 1) == 0 )
    return 87i64;
  v6 = *((_QWORD *)this + 7);
  if ( !v6 )
    return 87i64;
  v7 = *((_QWORD *)this + 8);
  if ( v7 < v6 || !*((_DWORD *)this + 18) )
    return 87i64;
  v8 = (__int64)(v7 - v6) >= *((unsigned int *)this + 18) ? *((_WORD *)this + 36) : v7 - *((_WORD *)this + 28);
  v9 = (_BYTE *)(v7 - v8);
  if ( *v9 != 1 )
    return 87i64;
  v10 = *(_QWORD *)(*((_QWORD *)this + 1) + 88i64);
  if ( !v10 )
    return 2148074244i64;
  v12 = *(__int64 **)(v10 + 176);
  if ( v12 )
    v13 = *v12;
  else
    v13 = 0i64;
  return SslHashHandshake(v13, a2, v9, v8, 0);
}
// 180098420: using guessed type __int64 __fastcall SslHashHandshake(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);

//----- (00000001800635D4) ----------------------------------------------------
struct CTlsRecord *__fastcall CTlsRecord::MakeRecord(__int64 a1, unsigned __int8 *a2, struct CSsl3TlsContext *a3)
{
  if ( !a2 || !a3 )
    return 0i64;
  *((_QWORD *)a2 + 4) = 0i64;
  *((_DWORD *)a2 + 18) = 0;
  *((_QWORD *)a2 + 1) = a3;
  *((_WORD *)a2 + 8) = 0;
  *((_QWORD *)a2 + 3) = 0i64;
  *((_DWORD *)a2 + 10) = 0;
  *((_QWORD *)a2 + 6) = 0i64;
  *((_QWORD *)a2 + 7) = 0i64;
  *((_QWORD *)a2 + 8) = 0i64;
  if ( (a1 & 0x100000000i64) != 0 )
  {
    *(_QWORD *)a2 = &CNulRecord::`vftable';
  }
  else
  {
    *((_DWORD *)a2 + 21) = 20;
    *(_QWORD *)a2 = &CTls13Record::`vftable';
    *((_WORD *)a2 + 40) = 0x4000;
    *((_WORD *)a2 + 45) = 0x4000;
    a2[88] = 0;
  }
  return (struct CTlsRecord *)a2;
}
// 18007CF80: using guessed type void *CTls13Record::`vftable';
// 18007D590: using guessed type void *CNulRecord::`vftable';

//----- (0000000180063660) ----------------------------------------------------
__int64 __fastcall CTls13Record::SetMaxFragment(CTls13Record *this, __int16 a2)
{
  if ( *((_QWORD *)this + 6) || (unsigned __int16)(a2 - 1) > 0x3FFFu )
    return 87i64;
  *((_WORD *)this + 40) = a2;
  return 0i64;
}

//----- (000000018006368C) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::CTls13Handshake<CTls13ClientContext,CTls13ExtClient>(
        __int64 a1,
        __int64 a2,
        __int64 a3)
{
  _QWORD *v6; // rax
  _QWORD *v7; // r9
  __int64 result; // rax

  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)a1 = &CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::`vftable';
  v6 = operator new(0x48ui64);
  v7 = v6;
  if ( v6 )
  {
    v6[1] = a2;
    v6[2] = 0i64;
    *((_DWORD *)v6 + 6) = 0;
    *v6 = &CTlsExtClient::`vftable';
    *((_BYTE *)v6 + 32) = 0;
    v6[5] = 0i64;
    *((_DWORD *)v6 + 12) = 0;
    v6[7] = a2;
    *((_BYTE *)v6 + 52) = *(_BYTE *)(a2 + 922);
    *v6 = &CTls13ExtClient::`vftable';
    v6[8] = a2;
  }
  else
  {
    v7 = 0i64;
  }
  *(_QWORD *)(a1 + 32) = a3;
  result = a1;
  *(_QWORD *)(a1 + 16) = v7;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_DWORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 44) = 0;
  *(_BYTE *)(a1 + 46) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 54) = 0;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_WORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  *(_DWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0i64;
  *(_QWORD *)(a1 + 120) = 0i64;
  *(_QWORD *)(a1 + 128) = 0i64;
  *(_QWORD *)(a1 + 136) = 0i64;
  *(_QWORD *)(a1 + 144) = 0i64;
  *(_DWORD *)(a1 + 152) = 0;
  *(_WORD *)(a1 + 156) = 0;
  return result;
}
// 18007D048: using guessed type void *CTlsExtClient::`vftable';
// 18007D5C8: using guessed type void *CTls13ExtClient::`vftable';
// 18007FD48: using guessed type void *CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::`vftable';

//----- (0000000180063788) ----------------------------------------------------
void __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::~CTls13Handshake<CTls13ClientContext,CTls13ExtClient>(
        _QWORD *a1)
{
  void (__fastcall ***v2)(_QWORD, __int64); // rcx
  void *v3; // rcx
  void *v4; // rcx

  *a1 = &CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::`vftable';
  v2 = (void (__fastcall ***)(_QWORD, __int64))a1[2];
  if ( v2 )
    (**v2)(v2, 1i64);
  v3 = (void *)a1[7];
  if ( v3 )
    SPExternalFree(v3);
  v4 = (void *)a1[18];
  if ( v4 )
    SPExternalFree(v4);
}
// 18007FD48: using guessed type void *CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::`vftable';
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (00000001800637EC) ----------------------------------------------------
void __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::~CTls13Handshake<CTls13ServerContext,CTls13ExtServer>(
        _QWORD *a1)
{
  void (__fastcall ***v2)(_QWORD, __int64); // rcx
  void *v3; // rcx
  void *v4; // rcx

  *a1 = &CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::`vftable';
  v2 = (void (__fastcall ***)(_QWORD, __int64))a1[2];
  if ( v2 )
    (**v2)(v2, 1i64);
  v3 = (void *)a1[7];
  if ( v3 )
    SPExternalFree(v3);
  v4 = (void *)a1[18];
  if ( v4 )
    SPExternalFree(v4);
}
// 18007CB68: using guessed type void *CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::`vftable';
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180063860) ----------------------------------------------------
_QWORD *__fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::`scalar deleting destructor'(
        _QWORD *Block,
        char a2)
{
  CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::~CTls13Handshake<CTls13ClientContext,CTls13ExtClient>(Block);
  if ( (a2 & 1) != 0 )
    operator delete(Block);
  return Block;
}

//----- (00000001800638A0) ----------------------------------------------------
_QWORD *__fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::`vector deleting destructor'(
        _QWORD *Block,
        char a2)
{
  CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::~CTls13Handshake<CTls13ServerContext,CTls13ExtServer>(Block);
  if ( (a2 & 1) != 0 )
    operator delete(Block);
  return Block;
}

//----- (00000001800638E0) ----------------------------------------------------
CTls13ExtClient *__fastcall CTls13ExtClient::`scalar deleting destructor'(CTls13ExtClient *this, char a2)
{
  *(_QWORD *)this = &CTls13ExtClient::`vftable';
  CTlsExtClient::~CTlsExtClient(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 18007D5C8: using guessed type void *CTls13ExtClient::`vftable';

//----- (0000000180063920) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::ComputeALPNExtensionSize(CTls13ClientHandshake *this)
{
  __int64 v1; // rax
  __int64 v2; // rax
  unsigned __int16 v3; // dx

  v1 = *((_QWORD *)this + 1);
  *((_WORD *)this + 82) = 0;
  v2 = *(_QWORD *)(v1 + 784);
  if ( v2 )
  {
    v3 = *(_WORD *)(v2 + 4);
    if ( v3 > 0xFFFDu )
      return 87i64;
    if ( v2 != -6 )
    {
      if ( v3 )
        *((_WORD *)this + 82) = v3 + 2;
    }
  }
  return 0i64;
}

//----- (0000000180063974) ----------------------------------------------------
DWORD __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeCertVerifySignatureSize(__int64 a1)
{
  __int64 v1; // rax
  DWORD v3; // ecx
  DWORD result; // eax
  int v5; // edx
  int v6; // edx
  HLOCAL v7; // rax
  void *v8; // rsi
  unsigned __int16 v9; // cx
  BOOL v10; // ebx
  int pvStructInfo; // [rsp+30h] [rbp-20h] BYREF
  void *v12; // [rsp+38h] [rbp-18h]
  int v13; // [rsp+40h] [rbp-10h]
  __int64 v14; // [rsp+48h] [rbp-8h]
  DWORD pcbResult; // [rsp+70h] [rbp+20h] BYREF
  DWORD pcbEncoded; // [rsp+78h] [rbp+28h] BYREF

  v1 = *(_QWORD *)(a1 + 72);
  pcbResult = 0;
  if ( *(_BYTE *)(v1 + 78) && !*(_BYTE *)(v1 + 79) )
  {
    v3 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 944i64);
    pcbResult = v3;
    if ( !v3 )
      return 1359;
    goto LABEL_8;
  }
  result = ComputeSignatureLength(
             *(__int64 ***)(a1 + 8),
             *(enum _eTlsSignatureAlgorithm *)(a1 + 104),
             *(enum _eTlsHashAlgorithm *)(a1 + 100),
             &pcbResult);
  if ( !result )
  {
    v3 = pcbResult;
LABEL_8:
    if ( v3 <= 0xFFFF )
    {
      v5 = *(_DWORD *)(a1 + 104);
      *(_WORD *)(a1 + 140) = v3;
      v6 = v5 - 1;
      if ( v6 )
      {
        if ( v6 != 2 )
          return 1359;
        v7 = SPExternalAlloc((unsigned __int16)v3);
        v8 = v7;
        if ( !v7 )
          return 14;
        memset_0(v7, 255, *(unsigned __int16 *)(a1 + 140));
        v9 = *(_WORD *)(a1 + 140);
        pcbEncoded = 0;
        pvStructInfo = v9 >> 1;
        v13 = pvStructInfo;
        v12 = v8;
        v14 = (__int64)v8 + (v9 >> 1);
        v10 = CryptEncodeObject(1u, (LPCSTR)0x2F, &pvStructInfo, 0i64, &pcbEncoded);
        SPExternalFree(v8);
        if ( !v10 )
          return GetLastError();
        if ( pcbEncoded > 0xFFFF )
          return 1359;
        *(_WORD *)(a1 + 142) = pcbEncoded;
      }
      else
      {
        *(_WORD *)(a1 + 142) = v3;
      }
      return 0;
    }
    return 1359;
  }
  return result;
}

//----- (0000000180063AB8) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::ComputeCertificateAuthoritiesExtensionSize(CTls13ServerHandshake *this)
{
  __int16 v1; // ax

  if ( *((_QWORD *)this + 22) && (v1 = *((_WORD *)this + 92)) != 0 )
  {
    *((_WORD *)this + 93) = v1 + 2;
    return 0i64;
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 21i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
    return 87i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (0000000180063B24) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeCertificateEntryExtensionsSize(
        __int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rcx
  unsigned int v4; // edi
  int v5; // eax

  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeGenericExtensionsSize(a1, 11);
  if ( !(_DWORD)result )
  {
    v4 = *(unsigned __int16 *)(v3 + 122);
    if ( (*(_DWORD *)(*(_QWORD *)(v3 + 8) + 64i64) & 0x40051555) != 0 )
    {
      result = (**(__int64 (__fastcall ***)(__int64))v3)(v3);
      if ( (_DWORD)result )
        return result;
      v5 = *(unsigned __int16 *)(a1 + 152);
      if ( (_WORD)v5 )
        v4 += v5 + 4;
    }
    if ( v4 <= 0xFFFF )
    {
      *(_WORD *)(a1 + 154) = v4;
      return 0i64;
    }
    else
    {
      return 1359i64;
    }
  }
  return result;
}
// 180063B48: variable 'v3' is possibly undefined
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180063BB0) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeCertificateEntryExtensionsSize(
        __int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rcx
  unsigned int v4; // edi
  int v5; // eax

  result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeGenericExtensionsSize(a1, 11);
  if ( !(_DWORD)result )
  {
    v4 = *(unsigned __int16 *)(v3 + 122);
    if ( (*(_DWORD *)(*(_QWORD *)(v3 + 8) + 64i64) & 0x40051555) != 0 )
    {
      result = (**(__int64 (__fastcall ***)(__int64))v3)(v3);
      if ( (_DWORD)result )
        return result;
      v5 = *(unsigned __int16 *)(a1 + 152);
      if ( (_WORD)v5 )
        v4 += v5 + 4;
    }
    if ( v4 <= 0xFFFF )
    {
      *(_WORD *)(a1 + 154) = v4;
      return 0i64;
    }
    else
    {
      return 1359i64;
    }
  }
  return result;
}
// 180063BD4: variable 'v3' is possibly undefined
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180063C3C) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeCertificateEntrySize(
        __int64 a1,
        __int64 a2,
        char a3,
        _WORD *a4)
{
  __int16 v4; // bx
  unsigned __int16 v7; // si
  __int64 result; // rax

  v4 = 0;
  if ( !a4 )
    return 87i64;
  v7 = 0;
  if ( a2 )
  {
    if ( *(_DWORD *)(a2 + 16) > 0xFFFAu )
      return 87i64;
    v7 = *(_WORD *)(a2 + 16);
  }
  if ( !a3 )
  {
LABEL_9:
    *a4 = v7 + v4 + 5;
    return 0i64;
  }
  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeCertificateEntryExtensionsSize(a1);
  if ( (_DWORD)result )
    return result;
  if ( 65530 - v7 >= *(unsigned __int16 *)(a1 + 154) )
  {
    v4 = *(_WORD *)(a1 + 154);
    goto LABEL_9;
  }
  return 87i64;
}

//----- (0000000180063CD0) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeCertificateEntrySize(
        __int64 a1,
        __int64 a2,
        char a3,
        _WORD *a4)
{
  __int16 v4; // bx
  unsigned __int16 v7; // si
  __int64 result; // rax

  v4 = 0;
  if ( !a4 )
    return 87i64;
  v7 = 0;
  if ( a2 )
  {
    if ( *(_DWORD *)(a2 + 16) > 0xFFFAu )
      return 87i64;
    v7 = *(_WORD *)(a2 + 16);
  }
  if ( !a3 )
  {
LABEL_9:
    *a4 = v7 + v4 + 5;
    return 0i64;
  }
  result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeCertificateEntryExtensionsSize(a1);
  if ( (_DWORD)result )
    return result;
  if ( 65530 - v7 >= *(unsigned __int16 *)(a1 + 154) )
  {
    v4 = *(_WORD *)(a1 + 154);
    goto LABEL_9;
  }
  return 87i64;
}

//----- (0000000180063D64) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeCertificateListSize(__int64 a1)
{
  unsigned __int16 *v1; // r14
  __int64 v3; // rcx
  __int64 result; // rax
  __int64 v5; // rax
  __int64 *v6; // rbx
  __int64 v7; // rbx
  unsigned int v8; // esi
  __int64 v9; // r15
  struct _CRYPTOAPI_BLOB *v10; // rdx
  int v11; // edx
  __int64 v12; // rdx
  unsigned __int16 v13; // [rsp+40h] [rbp+8h] BYREF

  v1 = (unsigned __int16 *)(a1 + 64);
  *(_WORD *)(a1 + 64) = 0;
  v3 = *(_QWORD *)(a1 + 72);
  if ( !v3 )
    return (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 64i64) & 0x40051555) != 0 ? 0x54F : 0;
  v5 = *(_QWORD *)(v3 + 64);
  if ( v5 )
  {
    v6 = *(__int64 **)(v5 + 16);
    if ( v6 )
    {
      if ( *(_DWORD *)(v5 + 12) )
      {
        v7 = *v6;
        if ( v7 && *(_QWORD *)(v7 + 16) && *(_DWORD *)(v7 + 12) )
        {
          v8 = 0;
          while ( 1 )
          {
            v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 16) + 8i64 * v8) + 8i64);
            if ( !v9 )
              break;
            v10 = *(struct _CRYPTOAPI_BLOB **)(v9 + 24);
            if ( !v10 )
              break;
            if ( !*(_BYTE *)(a1 + 80) && v8 && CertCompareCertificateName(*(_DWORD *)v9, v10 + 3, v10 + 5) )
              return 0i64;
            v13 = 0;
            result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeCertificateEntrySize(
                       a1,
                       v9,
                       v8 == 0,
                       &v13);
            if ( (_DWORD)result )
              return result;
            v11 = *v1;
            if ( 0xFFFF - v11 < v13 )
              break;
            ++v8;
            *v1 = v13 + v11;
            if ( v8 >= *(_DWORD *)(v7 + 12) )
              return 0i64;
          }
        }
        return 87i64;
      }
    }
  }
  v12 = *(_QWORD *)(v3 + 32);
  if ( !v12 )
    return 87i64;
  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeCertificateEntrySize(a1, v12, 1, v1);
  if ( !(_DWORD)result )
    return 0i64;
  return result;
}

//----- (0000000180063EC8) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeCertificateListSize(__int64 a1)
{
  unsigned __int16 *v1; // r14
  __int64 v3; // rcx
  __int64 result; // rax
  __int64 v5; // rax
  __int64 *v6; // rbx
  __int64 v7; // rbx
  unsigned int v8; // esi
  __int64 v9; // r15
  struct _CRYPTOAPI_BLOB *v10; // rdx
  int v11; // edx
  __int64 v12; // rdx
  unsigned __int16 v13; // [rsp+40h] [rbp+8h] BYREF

  v1 = (unsigned __int16 *)(a1 + 64);
  *(_WORD *)(a1 + 64) = 0;
  v3 = *(_QWORD *)(a1 + 72);
  if ( !v3 )
    return (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 64i64) & 0x40051555) != 0 ? 0x54F : 0;
  v5 = *(_QWORD *)(v3 + 64);
  if ( v5 )
  {
    v6 = *(__int64 **)(v5 + 16);
    if ( v6 )
    {
      if ( *(_DWORD *)(v5 + 12) )
      {
        v7 = *v6;
        if ( v7 && *(_QWORD *)(v7 + 16) && *(_DWORD *)(v7 + 12) )
        {
          v8 = 0;
          while ( 1 )
          {
            v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 16) + 8i64 * v8) + 8i64);
            if ( !v9 )
              break;
            v10 = *(struct _CRYPTOAPI_BLOB **)(v9 + 24);
            if ( !v10 )
              break;
            if ( !*(_BYTE *)(a1 + 80) && v8 && CertCompareCertificateName(*(_DWORD *)v9, v10 + 3, v10 + 5) )
              return 0i64;
            v13 = 0;
            result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeCertificateEntrySize(
                       a1,
                       v9,
                       v8 == 0,
                       &v13);
            if ( (_DWORD)result )
              return result;
            v11 = *v1;
            if ( 0xFFFF - v11 < v13 )
              break;
            ++v8;
            *v1 = v13 + v11;
            if ( v8 >= *(_DWORD *)(v7 + 12) )
              return 0i64;
          }
        }
        return 87i64;
      }
    }
  }
  v12 = *(_QWORD *)(v3 + 32);
  if ( !v12 )
    return 87i64;
  result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeCertificateEntrySize(a1, v12, 1, v1);
  if ( !(_DWORD)result )
    return 0i64;
  return result;
}

//----- (000000018006402C) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeCertificateMsgSize(
        __int64 a1,
        __int64 a2,
        char a3,
        _WORD *a4)
{
  int v4; // edi
  __int64 result; // rax
  __int64 v8; // rax
  unsigned int v9; // ecx

  v4 = 0;
  if ( (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 64i64) & 0x40051555) != 0 && !a2 || !a4 )
    return 87i64;
  *(_QWORD *)(a1 + 72) = a2;
  *(_BYTE *)(a1 + 80) = a3;
  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeCertificateListSize(a1);
  if ( !(_DWORD)result )
  {
    v8 = *(_QWORD *)(a1 + 8);
    if ( (*(_DWORD *)(v8 + 64) & 0x40051555) == 0 )
      v4 = *(unsigned __int8 *)(v8 + 1600);
    v9 = v4 + *(unsigned __int16 *)(a1 + 64) + 8;
    if ( v9 <= 0xFFFF )
    {
      *(_WORD *)(a1 + 136) = v9;
      result = 0i64;
      *a4 = v9;
    }
    else
    {
      return 1359i64;
    }
  }
  return result;
}

//----- (00000001800640C4) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeCertificateMsgSize(
        __int64 a1,
        __int64 a2,
        char a3,
        _WORD *a4)
{
  int v4; // edi
  __int64 result; // rax
  __int64 v8; // rax
  unsigned int v9; // ecx

  v4 = 0;
  if ( (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 64i64) & 0x40051555) != 0 && !a2 || !a4 )
    return 87i64;
  *(_QWORD *)(a1 + 72) = a2;
  *(_BYTE *)(a1 + 80) = a3;
  result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeCertificateListSize(a1);
  if ( !(_DWORD)result )
  {
    v8 = *(_QWORD *)(a1 + 8);
    if ( (*(_DWORD *)(v8 + 64) & 0x40051555) == 0 )
      v4 = *(unsigned __int8 *)(v8 + 1232);
    v9 = v4 + *(unsigned __int16 *)(a1 + 64) + 8;
    if ( v9 <= 0xFFFF )
    {
      *(_WORD *)(a1 + 136) = v9;
      result = 0i64;
      *a4 = v9;
    }
    else
    {
      return 1359i64;
    }
  }
  return result;
}

//----- (000000018006415C) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::ComputeCertificateRequestExtensionsSize(CTls13ServerHandshake *this)
{
  __int16 v2; // cx
  unsigned __int16 v3; // cx
  unsigned int v4; // edi
  __int64 result; // rax
  int v6; // eax
  int v7; // ecx

  *((_WORD *)this + 84) = 0;
  v2 = *((_WORD *)this + 63);
  if ( (unsigned __int16)(v2 - 1) > 0xFu )
    return 1359i64;
  v3 = 2 * (v2 + 1);
  *((_WORD *)this + 62) = v3;
  v4 = v3 + 4;
  if ( !g_fSendIssuerList
    || !*((_QWORD *)this + 22)
    || !*((_WORD *)this + 92)
    || (result = CTls13ServerHandshake::ComputeCertificateAuthoritiesExtensionSize(this), !(_DWORD)result) )
  {
    v6 = *((unsigned __int16 *)this + 93);
    if ( (_WORD)v6 )
      v4 += v6 + 4;
    result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeGenericExtensionsSize((__int64)this, 13);
    if ( !(_DWORD)result )
    {
      v7 = *((unsigned __int16 *)this + 61);
      if ( 0xFFFF - v7 >= v4 )
      {
        *((_WORD *)this + 84) = v4 + v7;
        return 0i64;
      }
      return 1359i64;
    }
  }
  return result;
}
// 180092F08: using guessed type int g_fSendIssuerList;

//----- (0000000180064218) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::ComputeCertificateRequestSize(
        CTls13ServerHandshake *this,
        unsigned __int16 *a2)
{
  __int64 v2; // rsi
  CCredentialGroup *v5; // rsi
  unsigned int updated; // eax
  unsigned int v7; // edi
  __int64 result; // rax
  void *v9; // rcx
  unsigned int v10; // edx
  unsigned int v11; // [rsp+40h] [rbp+8h] BYREF

  v2 = *((_QWORD *)this + 1);
  if ( v2 == -474 )
    return 1359i64;
  *((_QWORD *)this + 16) = v2 + 476;
  *((_WORD *)this + 63) = *(_WORD *)(v2 + 474);
  v5 = *(CCredentialGroup **)(v2 + 80);
  if ( !v5 )
    return 1359i64;
  updated = CCredentialGroup::UpdateIssuerList(v5);
  v7 = updated;
  if ( updated )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 34i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids, updated);
    CSslContext::SetError(*((_QWORD *)this + 1), 1251, v7);
    return v7;
  }
  if ( !g_fSendIssuerList )
  {
LABEL_18:
    result = CTls13ServerHandshake::ComputeCertificateRequestExtensionsSize(this);
    if ( (_DWORD)result )
      return result;
    v10 = *(unsigned __int8 *)(*((_QWORD *)this + 1) + 1232i64) + *((unsigned __int16 *)this + 84) + 7;
    if ( v10 <= 0xFFFF )
    {
      *((_WORD *)this + 85) = v10;
      result = 0i64;
      *a2 = v10;
      return result;
    }
    return 1359i64;
  }
  v9 = (void *)*((_QWORD *)this + 22);
  if ( v9 )
  {
    SPExternalFree(v9);
    *((_QWORD *)this + 22) = 0i64;
  }
  v11 = 0;
  *((_WORD *)this + 92) = 0;
  result = CCredentialGroup::DuplicateIssuerList(v5, (unsigned __int8 **)this + 22, &v11);
  if ( !(_DWORD)result )
  {
    if ( v11 > 0xFFFD )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 35i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
      return 87i64;
    }
    *((_WORD *)this + 92) = v11;
    goto LABEL_18;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];
// 180092F08: using guessed type int g_fSendIssuerList;

//----- (00000001800643A0) ----------------------------------------------------
int __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeCertificateVerifySize(
        __int64 a1,
        _WORD *a2)
{
  int result; // eax
  __int64 v5; // rax
  unsigned int v6; // eax

  if ( !a2 )
    return 87;
  v5 = *(_QWORD *)(a1 + 72);
  if ( *(_BYTE *)(v5 + 78) && !*(_BYTE *)(v5 + 79)
    || (result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::DetermineCertVerifyCodePoint(a1)) == 0 )
  {
    if ( *(_DWORD *)(a1 + 104) && *(_WORD *)(a1 + 120) && *(_DWORD *)(a1 + 100) && *(_QWORD *)(a1 + 112) )
    {
      result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeCertVerifySignatureSize(a1);
      if ( !result )
      {
        v6 = *(unsigned __int16 *)(a1 + 142) + 8;
        if ( v6 <= 0xFFFF )
        {
          *(_WORD *)(a1 + 138) = v6;
          *a2 = v6;
          return 0;
        }
        else
        {
          return 1359;
        }
      }
    }
    else
    {
      return -2146893052;
    }
  }
  return result;
}

//----- (0000000180064440) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::ComputeClientHelloExtensionsSize(CTls13ClientHandshake *this)
{
  int v2; // edi
  __int64 result; // rax
  int v4; // eax
  __int64 v5; // rcx
  int v6; // eax
  __int16 v7; // cx
  int v8; // edx
  int v9; // eax
  int v10; // r8d
  __int16 v11; // cx
  int v12; // eax
  int v13; // edi
  CTls13ClientHandshake *v14; // rcx
  int v15; // eax
  int v16; // edi
  unsigned __int16 v17; // ax
  int v18; // edi
  CTls13ClientHandshake *v19; // rcx
  int v20; // eax
  unsigned int v21; // edi
  int v22; // eax

  v2 = 0;
  result = CTls13ClientHandshake::ComputeServerNameExtensionSize(this);
  if ( !(_DWORD)result )
  {
    v4 = *((unsigned __int16 *)this + 81);
    if ( (_WORD)v4 )
      v2 = v4 + 4;
    v5 = *(_QWORD *)(*((_QWORD *)this + 1) + 80i64);
    if ( !v5 )
      return 2148074244i64;
    if ( (*(_DWORD *)(v5 + 160) & 0x700) != 0 )
    {
      result = (**(__int64 (__fastcall ***)(CTls13ClientHandshake *))this)(this);
      if ( (_DWORD)result )
        return result;
      v6 = *((unsigned __int16 *)this + 76);
      if ( (_WORD)v6 )
        v2 += v6 + 4;
    }
    result = CTls13ClientHandshake::ComputeSupportedVersionsExtensionSize(this);
    if ( !(_DWORD)result )
    {
      v7 = *((_WORD *)this + 63);
      v8 = v2 + *((unsigned __int8 *)this + 54);
      if ( (unsigned __int16)(v7 - 1) > 0xFu )
        return 1359i64;
      v9 = (unsigned __int16)(2 * (v7 + 1));
      *((_WORD *)this + 62) = v9;
      v10 = v9 + v8;
      v11 = *(_WORD *)(*((_QWORD *)this + 1) + 920i64);
      if ( (unsigned __int16)(v11 - 1) > 0x7FFDu )
        return 1359i64;
      v12 = (unsigned __int16)(2 * (v11 + 1));
      *((_WORD *)this + 21) = v12;
      v13 = v10 + v12 + 16;
      result = CTls13ClientHandshake::ComputeALPNExtensionSize(this);
      if ( !(_DWORD)result )
      {
        v15 = *((unsigned __int16 *)this + 82);
        if ( (_WORD)v15 )
          v13 += v15 + 4;
        result = CTls13ClientHandshake::ComputeKeyShareExtensionSize(v14);
        if ( !(_DWORD)result )
        {
          v16 = *((unsigned __int16 *)this + 26) + 8 + v13;
          if ( !CSslGlobals::m_fDisableClientExtendedMS )
          {
            v16 += 4;
            *(_BYTE *)(*((_QWORD *)this + 1) + 1344i64) = 1;
          }
          v17 = *((_WORD *)this + 48);
          v18 = v16 + 5;
          if ( v17 )
          {
            if ( v17 > 0xFFFDu )
              return 87i64;
            *((_WORD *)this + 49) = v17 + 2;
          }
          if ( *((_WORD *)this + 49) )
            v18 += *((unsigned __int16 *)this + 49) + 4;
          result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeGenericExtensionsSize((__int64)this, 1);
          if ( !(_DWORD)result )
          {
            v20 = *((unsigned __int16 *)this + 61) + 6;
            *((_WORD *)this + 83) = 2;
            v21 = v20 + v18;
            result = CTls13ClientHandshake::ComputePskExtensionSize(v19);
            if ( !(_DWORD)result )
            {
              v22 = *((unsigned __int16 *)this + 78);
              if ( (_WORD)v22 )
                v21 += v22 + 4;
              if ( v21 <= 0xFFFF )
              {
                *((_WORD *)this + 20) = v21;
                return 0i64;
              }
              return 1359i64;
            }
          }
        }
      }
    }
  }
  return result;
}
// 180064564: variable 'v14' is possibly undefined
// 1800645E2: variable 'v19' is possibly undefined
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 1800927B8: using guessed type int CSslGlobals::m_fDisableClientExtendedMS;

//----- (000000018006463C) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::ComputeClientHelloSize(
        CTls13ClientHandshake *this,
        __int64 a2,
        int a3,
        __int16 a4,
        unsigned __int16 *a5)
{
  __int64 v5; // r11
  __int16 v7; // cx
  unsigned __int16 *v8; // r10
  __int16 v9; // si
  unsigned __int16 v10; // ax
  unsigned __int16 v11; // cx
  __int64 result; // rax
  unsigned int v13; // ecx

  v5 = *((_QWORD *)this + 1);
  v7 = *(_WORD *)(v5 + 920);
  v8 = *(unsigned __int16 **)(v5 + 912);
  v9 = *(_WORD *)(v5 + 1836);
  *((_WORD *)this + 22) = 0;
  if ( !a2
    || (unsigned int)(a3 - 1) > 0x7FFE
    || (unsigned __int16)(a4 - 1) > 0xFu
    || (unsigned __int16)(v7 - 1) > 0x7FFDu
    || !v8
    || !a5 )
  {
    return 87i64;
  }
  *((_QWORD *)this + 3) = a2;
  *((_WORD *)this + 80) = a3;
  *((_WORD *)this + 63) = a4;
  v10 = *v8;
  if ( *(_DWORD *)(v5 + 68) == 100 )
  {
    v11 = 0;
    if ( v10 )
    {
      while ( v9 != v10 )
      {
        v10 = v8[++v11];
        if ( v11 >= v10 )
          goto LABEL_13;
      }
      *((_WORD *)this + 22) = v10;
    }
LABEL_13:
    v10 = *((_WORD *)this + 22);
  }
  else
  {
    *((_WORD *)this + 22) = v10;
  }
  if ( v10 )
  {
    result = CTls13ClientHandshake::ComputeClientHelloExtensionsSize(this);
    if ( !(_DWORD)result )
    {
      v13 = *(unsigned __int8 *)(*((_QWORD *)this + 1) + 1649i64)
          + 2 * *((unsigned __int16 *)this + 80)
          + *((unsigned __int16 *)this + 20)
          + 45;
      if ( v13 <= 0xFFFF )
      {
        *((_WORD *)this + 84) = v13;
        result = 0i64;
        *a5 = v13;
      }
      else
      {
        return 1359i64;
      }
    }
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 28i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
    return 2148074289i64;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (00000001800647B0) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::ComputeEncryptedExtensionsMsgSize(
        CTls13ServerHandshake *this,
        unsigned __int16 *a2)
{
  __int64 result; // rax
  unsigned int v5; // eax

  if ( !a2 )
    return 87i64;
  result = CTls13ServerHandshake::ComputeEncryptedExtensionsSize(this);
  if ( !(_DWORD)result )
  {
    v5 = *((unsigned __int16 *)this + 82) + 6;
    if ( v5 <= 0xFFFF )
    {
      *((_WORD *)this + 81) = v5;
      *a2 = v5;
      return 0i64;
    }
    else
    {
      return 1359i64;
    }
  }
  return result;
}

//----- (000000018006480C) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::ComputeEncryptedExtensionsSize(CTls13ServerHandshake *this)
{
  unsigned int *v2; // rcx
  unsigned __int64 v3; // rbx
  int v4; // ebx
  __int64 v5; // rax
  int v6; // eax
  __int64 result; // rax
  unsigned int v8; // ebx

  v2 = (unsigned int *)*((_QWORD *)this + 1);
  v3 = (unsigned __int64)v2[34] >> 19;
  *((_WORD *)this + 83) = 0;
  v4 = v3 & 4;
  v5 = (*(__int64 (__fastcall **)(unsigned int *))(*(_QWORD *)v2 + 88i64))(v2);
  if ( v5 && *(_DWORD *)v5 == 1 && *(_DWORD *)(v5 + 4) == 2 )
    *((_WORD *)this + 83) = *(unsigned __int8 *)(v5 + 8) + 3;
  v6 = *((unsigned __int16 *)this + 83);
  if ( (_WORD)v6 )
    v4 += v6 + 4;
  result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeGenericExtensionsSize((__int64)this, 8);
  if ( !(_DWORD)result )
  {
    v8 = *((unsigned __int16 *)this + 61) + v4;
    if ( v8 <= 0xFFFF )
    {
      *((_WORD *)this + 82) = v8;
      return 0i64;
    }
    else
    {
      return 1359i64;
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (00000001800648C8) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeFinishedSize(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  struct hsel *HashInfo; // rax
  __int64 v5; // r8
  _WORD *v6; // r9
  __int16 v7; // ax

  if ( !a2 )
    return 87i64;
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64);
  if ( !v3 )
    return 1359i64;
  HashInfo = GetHashInfo(*(_DWORD *)(v3 + 44));
  if ( !HashInfo || *((_DWORD *)HashInfo + 7) > 0x40u )
    return 1359i64;
  v7 = *((unsigned __int8 *)HashInfo + 28);
  *(_BYTE *)(v5 + 81) = v7;
  v7 += 4;
  *(_WORD *)(v5 + 82) = v7;
  *v6 = v7;
  return 0i64;
}
// 180064900: variable 'v5' is possibly undefined
// 18006490D: variable 'v6' is possibly undefined

//----- (0000000180064928) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeGenericExtensionsSize(
        __int64 a1,
        int a2)
{
  __int64 v2; // rax
  __int64 *v4; // r8
  __int64 v5; // rax
  __int64 *v6; // r10
  __int64 v7; // r9
  unsigned __int16 v8; // ax
  int v9; // edx
  int v10; // r11d

  v2 = *(_QWORD *)(a1 + 8);
  *(_WORD *)(a1 + 122) = 0;
  v4 = (__int64 *)(v2 + 1480);
  if ( v2 != -1480 )
  {
    v5 = *(unsigned __int8 *)(v2 + 1488);
    if ( (_BYTE)v5 )
    {
      v6 = &v4[v5];
      while ( v4 < v6 )
      {
        v7 = *v4;
        if ( !*v4 )
          return 2148074244i64;
        if ( *(unsigned __int16 *)(v7 + 2) == a2 )
        {
          v8 = *(_WORD *)(a1 + 122);
          if ( v8 > 0xFFFBu )
            return 2148074333i64;
          v9 = (unsigned __int16)(v8 + 4);
          *(_WORD *)(a1 + 122) = v9;
          v10 = *(unsigned __int16 *)(v7 + 8);
          if ( v9 > 0xFFFF - v10 )
            return 2148074333i64;
          *(_WORD *)(a1 + 122) = v10 + v9;
        }
        ++v4;
      }
    }
  }
  return 0i64;
}

//----- (00000001800649CC) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeGenericExtensionsSize(
        __int64 a1,
        int a2)
{
  __int64 v2; // rax
  __int64 *v4; // r8
  __int64 v5; // rax
  __int64 *v6; // r10
  __int64 v7; // r9
  unsigned __int16 v8; // ax
  int v9; // edx
  int v10; // r11d

  v2 = *(_QWORD *)(a1 + 8);
  *(_WORD *)(a1 + 122) = 0;
  v4 = (__int64 *)(v2 + 1112);
  if ( v2 != -1112 )
  {
    v5 = *(unsigned __int8 *)(v2 + 1120);
    if ( (_BYTE)v5 )
    {
      v6 = &v4[v5];
      while ( v4 < v6 )
      {
        v7 = *v4;
        if ( !*v4 )
          return 2148074244i64;
        if ( *(unsigned __int16 *)(v7 + 2) == a2 )
        {
          v8 = *(_WORD *)(a1 + 122);
          if ( v8 > 0xFFFBu )
            return 2148074333i64;
          v9 = (unsigned __int16)(v8 + 4);
          *(_WORD *)(a1 + 122) = v9;
          v10 = *(unsigned __int16 *)(v7 + 8);
          if ( v9 > 0xFFFF - v10 )
            return 2148074333i64;
          *(_WORD *)(a1 + 122) = v10 + v9;
        }
        ++v4;
      }
    }
  }
  return 0i64;
}

//----- (0000000180064A70) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeKeyShareEntrySize(
        __int64 a1,
        _WORD *a2)
{
  __int64 v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned int EphemBlobFromKey; // edi
  CCipherMill *v8; // rcx
  __int64 v9; // rdx
  __int64 *v10; // rsi
  __int64 v11; // rcx
  int v12; // edx
  __int64 v13; // rax
  unsigned __int64 v14; // rdx
  __int16 v15; // r8
  unsigned int v16; // ecx
  unsigned int v17; // [rsp+78h] [rbp+10h] BYREF
  unsigned __int64 v18; // [rsp+80h] [rbp+18h] BYREF

  if ( !a2 )
    return 87i64;
  v5 = *(_QWORD *)(a1 + 8);
  if ( *(_DWORD *)(v5 + 68) == 40 && g_fEnableHelloRetryRequest )
  {
    *a2 = 0;
    return 0i64;
  }
  v6 = *(_QWORD *)(v5 + 112);
  v18 = v6;
  if ( !v6 )
  {
    EphemBlobFromKey = SslCreateEphemeralKey(
                         *(_QWORD *)(a1 + 24),
                         &v18,
                         *(unsigned __int16 *)(v5 + 34),
                         4866i64,
                         *(unsigned __int16 *)(a1 + 44),
                         0,
                         0i64,
                         0,
                         0);
    if ( EphemBlobFromKey )
    {
      v8 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return EphemBlobFromKey;
      v9 = 10i64;
LABEL_12:
      WPP_SF_D(*((_QWORD *)v8 + 2), v9, WPP_922678f99ae534148d3bb024010f1556_Traceguids, EphemBlobFromKey);
      return EphemBlobFromKey;
    }
    CSslContext::SetEphemeralKey(*(CSslContext **)(a1 + 8), v18);
    v6 = v18;
  }
  v10 = (__int64 *)(a1 + 56);
  if ( !*(_QWORD *)(a1 + 56) )
  {
    v11 = *(_QWORD *)(a1 + 24);
    v17 = 0;
    EphemBlobFromKey = GetEphemBlobFromKey(v11, v6, L"ECCPUBLICBLOB", &v17, (unsigned __int8 **)(a1 + 56));
    if ( EphemBlobFromKey )
    {
      v8 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return EphemBlobFromKey;
      v9 = 11i64;
      goto LABEL_12;
    }
  }
  v12 = *(unsigned __int16 *)(a1 + 44);
  v17 = 0;
  EphemBlobFromKey = CCipherMill::GetEccCurveFlags((CCipherMill *)v5, v12, &v17);
  if ( EphemBlobFromKey )
  {
    v8 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return EphemBlobFromKey;
    v9 = 12i64;
    goto LABEL_12;
  }
  v13 = *v10;
  if ( *v10 )
  {
    if ( (v17 & 8) != 0 )
    {
      *(_BYTE *)(a1 + 46) = 0;
      v14 = 65531i64;
      v16 = *(_DWORD *)(v13 + 4);
      v15 = 4;
    }
    else
    {
      *(_BYTE *)(a1 + 46) = 1;
      v14 = 65530i64;
      v15 = 5;
      v16 = 2 * *(_DWORD *)(v13 + 4);
    }
    if ( v16 <= v14 )
    {
      *(_DWORD *)(a1 + 48) = (unsigned __int16)v16;
      *a2 = v15 + v16;
      return 0i64;
    }
  }
  return 1359i64;
}
// 180064BB5: variable 'v5' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];
// 1800927A0: using guessed type int g_fEnableHelloRetryRequest;
// 180098548: using guessed type __int64 __fastcall SslCreateEphemeralKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180064C60) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::ComputeKeyShareExtensionSize(CTls13ClientHandshake *this)
{
  unsigned int v2; // ebx
  unsigned __int16 v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = 0;
  v2 = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeKeyShareEntrySize((__int64)this, &v4);
  if ( v2 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 23i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids, v2);
    return v2;
  }
  else if ( v4 <= 0xFFFDu )
  {
    *((_WORD *)this + 26) = v4 + 2;
    return 0i64;
  }
  else
  {
    return 1359i64;
  }
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (0000000180064CF4) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::ComputeNewSessionTicketSize(
        CTls13ServerHandshake *this,
        unsigned __int16 *a2)
{
  HLOCAL *v2; // r14
  unsigned __int16 *v5; // rbp
  UCHAR *v6; // rax
  UCHAR *v7; // rsi
  ULONG RandomBits; // edi
  __int64 v10; // rcx
  __int64 v11; // rdi
  void *v12; // rcx
  CSsl3TlsServerContext *v13; // rcx
  unsigned int v14; // eax
  unsigned int v15; // eax
  __int64 v16; // [rsp+50h] [rbp+8h] BYREF

  v2 = (HLOCAL *)((char *)this + 192);
  if ( *((_QWORD *)this + 24) )
    return 1359i64;
  v5 = (unsigned __int16 *)((char *)this + 200);
  if ( *((_WORD *)this + 100) )
    return 1359i64;
  v6 = (UCHAR *)SPExternalAlloc(0x20u);
  v7 = v6;
  if ( !v6 )
    return 14i64;
  RandomBits = GenerateRandomBits(v6, 0x20u);
  if ( RandomBits )
    goto LABEL_8;
  v10 = *((_QWORD *)this + 1);
  v16 = 0i64;
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v10 + 232i64))(v10, &v16);
  if ( !v16 )
  {
    RandomBits = 1359;
LABEL_8:
    SPExternalFree(v7);
    return RandomBits;
  }
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(v16 + 72), 1u);
  v11 = v16;
  v12 = *(void **)(v16 + 200);
  if ( v12 )
    SPExternalFree(v12);
  *(_BYTE *)(v11 + 208) = 32;
  *(_QWORD *)(v11 + 200) = v7;
  *(_WORD *)(v16 + 238) = 32;
  RtlReleaseResource((PRTL_RESOURCE)(v16 + 72));
  v13 = (CSsl3TlsServerContext *)*((_QWORD *)this + 1);
  if ( (*((_DWORD *)v13 + 34) & 0x800i64) != 0 )
  {
    v14 = CSsl3TlsServerContext::SerializeAndProtectSessionState(v13, v2, v5);
    if ( v14 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 36i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids, v14);
    }
    else
    {
      *(_QWORD *)(*((_QWORD *)this + 1) + 136i64) |= 0x400000ui64;
    }
  }
  if ( *v5 )
  {
    v15 = *v5 + 49;
    if ( v15 > 0xFFFF )
      return 1359i64;
  }
  else
  {
    LOWORD(v15) = 81;
  }
  *((_WORD *)this + 86) = v15;
  *a2 = v15;
  return 0i64;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (0000000180064EBC) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::ComputePskExtensionSize(CTls13ClientHandshake *this)
{
  __int64 v2; // rcx
  unsigned int v4; // ebx
  int PrfHashDetails; // esi
  unsigned int v6; // ecx
  unsigned __int8 v7; // [rsp+40h] [rbp+8h] BYREF
  CSessionCacheItem *v8; // [rsp+48h] [rbp+10h] BYREF

  *((_WORD *)this + 78) = 0;
  v2 = *((_QWORD *)this + 1);
  v8 = 0i64;
  v7 = 0;
  (*(void (__fastcall **)(__int64, CSessionCacheItem **))(*(_QWORD *)v2 + 224i64))(v2, &v8);
  if ( !v8 )
    return 2148074244i64;
  RtlAcquireResourceShared((PRTL_RESOURCE)((char *)v8 + 72), 1u);
  v4 = *((_DWORD *)v8 + 108);
  PrfHashDetails = CSessionCacheItem::GetPrfHashDetails(v8, &v7, 0i64);
  RtlReleaseResource((PRTL_RESOURCE)((char *)v8 + 72));
  if ( !v4 )
    return 0i64;
  if ( !PrfHashDetails && (unsigned __int8)(v7 - 1) <= 0x3Fu )
  {
    if ( v4 > 0xFFFF )
      return 2148074248i64;
    v6 = v4 + v7 + 11;
    if ( v6 <= 0xFFFB )
    {
      *((_WORD *)this + 78) = v6;
      return 0i64;
    }
  }
  return 1359i64;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180064FB0) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::ComputeServerHelloExtensionsSize(CTls13ServerHandshake *this)
{
  unsigned int v2; // ebx
  __int64 result; // rax
  int v4; // eax
  int v5; // ebx
  __int64 v6; // rcx
  unsigned __int16 v7; // r8
  unsigned int v8; // ebx
  unsigned __int16 v9; // [rsp+38h] [rbp+10h] BYREF

  v9 = 0;
  v2 = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeKeyShareEntrySize((__int64)this, &v9);
  if ( v2 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 32i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids, v2);
    return v2;
  }
  else
  {
    v4 = v9;
    *((_WORD *)this + 26) = v9;
    *((_BYTE *)this + 54) = 2;
    v5 = v4 + 10;
    v6 = *(_QWORD *)(*((_QWORD *)this + 1) + 136i64) & 0x8000i64;
    v7 = (*(_DWORD *)(*((_QWORD *)this + 1) + 136i64) & 0x8000) == 0i64 ? 2 : 0;
    *((_WORD *)this + 78) = v7;
    if ( !v6 )
      v5 = v7 + v4 + 14;
    result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeGenericExtensionsSize((__int64)this, 2);
    if ( !(_DWORD)result )
    {
      v8 = *((unsigned __int16 *)this + 61) + v5;
      if ( v8 <= 0xFFFF )
      {
        *((_WORD *)this + 20) = v8;
        return 0i64;
      }
      else
      {
        return 1359i64;
      }
    }
  }
  return result;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (0000000180065098) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::ComputeServerHelloOrHRRSize(
        CTls13ServerHandshake *this,
        __int64 a2,
        char a3,
        unsigned __int16 *a4)
{
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // rcx
  unsigned int v9; // eax
  unsigned int v10; // edx

  if ( !a2 || !a4 )
    return 87i64;
  v6 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 3) = a2;
  *((_WORD *)this + 22) = *(_WORD *)(v6 + 16);
  if ( !a3 )
  {
    *((_WORD *)this + 26) = 2;
    *((_BYTE *)this + 54) = 2;
    result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeGenericExtensionsSize((__int64)this, 2);
    if ( (_DWORD)result )
      return result;
    v9 = *(unsigned __int16 *)(v8 + 122) + 12;
    if ( v9 > 0xFFFF )
      return 1359i64;
    *(_WORD *)(v8 + 40) = v9;
LABEL_10:
    v10 = *(unsigned __int8 *)(*((_QWORD *)this + 1) + 1281i64) + *((unsigned __int16 *)this + 20) + 44;
    if ( v10 <= 0xFFFF )
    {
      *((_WORD *)this + 80) = v10;
      result = 0i64;
      *a4 = v10;
      return result;
    }
    return 1359i64;
  }
  result = CTls13ServerHandshake::ComputeServerHelloExtensionsSize(this);
  if ( !(_DWORD)result )
    goto LABEL_10;
  return result;
}
// 1800650E7: variable 'v8' is possibly undefined

//----- (0000000180065144) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::ComputeServerNameExtensionSize(CTls13ClientHandshake *this)
{
  CTlsExtClient *v1; // rbx
  const unsigned __int16 *v3; // rax
  unsigned int v4; // ebx
  __int64 v6; // rcx
  __int64 v7; // rax

  v1 = (CTlsExtClient *)*((_QWORD *)this + 2);
  *((_WORD *)this + 81) = 0;
  v3 = (const unsigned __int16 *)(*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 1) + 320i64))(*((_QWORD *)this + 1));
  v4 = CTlsExtClient::BuildServerNameString(v1, v3);
  if ( v4 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 24i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
    return v4;
  }
  else
  {
    v6 = *(_QWORD *)(*((_QWORD *)this + 2) + 40i64);
    if ( v6 )
    {
      v7 = -1i64;
      do
        ++v7;
      while ( *(_BYTE *)(v6 + v7) );
      if ( (_WORD)v7 )
        *((_WORD *)this + 81) = v7 + 5;
    }
    return 0i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (0000000180065210) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::ComputeStatusRequestExtensionSize(CTls13ServerHandshake *this)
{
  __int64 v1; // rax
  __int64 v2; // rdx

  v1 = *((_QWORD *)this + 1);
  *((_WORD *)this + 76) = 0;
  v2 = *(_QWORD *)(v1 + 1512);
  if ( v2 )
  {
    if ( *(_DWORD *)(v2 + 16) > 0xFFF7u )
      return 87i64;
    *((_WORD *)this + 76) = *(_WORD *)(v2 + 16) + 4;
  }
  return 0i64;
}

//----- (0000000180065254) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::ComputeSupportedVersionsExtensionSize(CTls13ClientHandshake *this)
{
  __int64 v1; // r9
  _DWORD *v2; // r8
  unsigned __int8 v3; // dl
  __int64 result; // rax

  v1 = *((_QWORD *)this + 1);
  v2 = &TlsVersions;
  *((_BYTE *)this + 54) = 0;
  do
  {
    v3 = *((_BYTE *)this + 54);
    if ( (*(_DWORD *)(v1 + 64) & *v2) != 0 )
    {
      v3 += 2;
      *((_BYTE *)this + 54) = v3;
    }
    v2 += 2;
  }
  while ( v2 < WPP_922678f99ae534148d3bb024010f1556_Traceguids );
  if ( v3 < 2u )
    return 87i64;
  result = 0i64;
  *((_BYTE *)this + 54) = v3 + 1;
  return result;
}
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (00000001800652A0) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::DetermineCertVerifyCodePoint(__int64 a1)
{
  __int64 v1; // rdx
  __int64 result; // rax
  CTlsSignatureSuiteList *v4; // rdi
  __int16 v5; // cx

  v1 = *(_QWORD *)(a1 + 72);
  if ( !v1 )
    return 87i64;
  v4 = (CTlsSignatureSuiteList *)(*(_QWORD *)(a1 + 8) + 510i64);
  if ( *(_QWORD *)(a1 + 8) == -510i64 )
    return 1359i64;
  result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::DetermineCertVerifySignatureAlgorithm(
             a1,
             *(const struct _CERT_CONTEXT **)(v1 + 32));
  if ( !(_DWORD)result )
  {
    v5 = __ROR2__(
           CTlsSignatureSuiteList::GetMinimumCodePointToSign(
             v4,
             (enum _eTlsSignatureAlgorithm)*(_DWORD *)(a1 + 104),
             *(_DWORD *)(*(_QWORD *)(a1 + 72) + 428i64),
             *(_DWORD *)(*(_QWORD *)(a1 + 8) + 64i64),
             *(_DWORD *)(*(_QWORD *)(a1 + 72) + 140i64)),
           8);
    *(_WORD *)(a1 + 120) = v5;
    if ( v5 )
    {
      GetSignatureSuiteInfoByCodePoint(
        v5,
        0i64,
        (enum _eTlsHashAlgorithm *)(a1 + 100),
        0i64,
        (const unsigned __int16 **)(a1 + 112),
        0i64,
        0i64);
      return 0i64;
    }
    else
    {
      return 2148074289i64;
    }
  }
  return result;
}

//----- (0000000180065360) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::DetermineCertVerifySignatureAlgorithm(
        __int64 a1,
        const struct _CERT_CONTEXT *a2)
{
  __int64 result; // rax
  int v4; // eax
  unsigned int v5; // [rsp+38h] [rbp+10h] BYREF

  if ( !a2 )
    return 87i64;
  v5 = 0;
  result = GetPublicKeyAlgIdFromCert(a2, &v5);
  if ( !(_DWORD)result )
  {
    if ( v5 == 8707 )
    {
      v4 = 3;
    }
    else
    {
      if ( v5 != 41984 )
        return 1359i64;
      v4 = 1;
    }
    *(_DWORD *)(a1 + 104) = v4;
    return 0i64;
  }
  return result;
}

//----- (00000001800653C8) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::GenerateALPNExtension(CTls13ClientHandshake *this)
{
  __int16 v1; // r8
  __int64 v3; // rsi
  __int64 result; // rax
  unsigned __int16 v5; // di
  __int64 v6; // rcx
  unsigned __int16 v7; // [rsp+40h] [rbp+8h] BYREF

  v1 = *((_WORD *)this + 82);
  if ( !v1 )
    return 0i64;
  v3 = *(_QWORD *)(*((_QWORD *)this + 1) + 784i64);
  if ( !v3 || v3 == -6 )
    return 0i64;
  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader((__int64)this, 16, v1);
  if ( (_DWORD)result )
    return result;
  v5 = *((_WORD *)this + 82) - 2;
  if ( v5 != *(_WORD *)(v3 + 4) )
    return 87i64;
  v6 = *((_QWORD *)this + 4);
  v7 = __ROR2__(v5, 8);
  result = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int16 *))(*(_QWORD *)v6 + 32i64))(v6, 2i64, &v7);
  if ( !(_DWORD)result )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 25i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids, v7);
    result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(**((_QWORD **)this + 4) + 32i64))(
               *((_QWORD *)this + 4),
               v5,
               v3 + 6);
    if ( !(_DWORD)result )
    {
      *(_QWORD *)(*((_QWORD *)this + 1) + 136i64) |= 0x4000000ui64;
      CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 16);
      return 0i64;
    }
  }
  return result;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (0000000180065504) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::GenerateBinderEntry(CTls13ClientHandshake *this)
{
  __int64 v2; // rdi
  unsigned int PrfHashDetails; // ebx
  unsigned int v4; // r14d
  __int64 v6; // rcx
  __int64 v7; // rax
  unsigned __int16 v8; // r13
  unsigned int v9; // r12d
  __int64 v10; // r15
  __int64 v11; // rax
  unsigned int HandshakeHash; // eax
  __int64 v13; // rcx
  char v14[4]; // [rsp+58h] [rbp-39h] BYREF
  __int16 v15; // [rsp+5Ch] [rbp-35h] BYREF
  unsigned __int8 v16[4]; // [rsp+60h] [rbp-31h] BYREF
  unsigned __int64 v17[2]; // [rsp+68h] [rbp-29h] BYREF
  unsigned __int8 v18[64]; // [rsp+78h] [rbp-19h] BYREF

  v17[0] = 0i64;
  v2 = *(_QWORD *)(*((_QWORD *)this + 1) + 88i64);
  if ( !v2 )
    return 1359;
  RtlAcquireResourceShared((PRTL_RESOURCE)(v2 + 72), 1u);
  memset_0(v18, 0, sizeof(v18));
  *(_DWORD *)v16 = 0;
  PrfHashDetails = CSessionCacheItem::GetPrfHashDetails((CSessionCacheItem *)v2, v16, 0i64);
  if ( !PrfHashDetails )
  {
    v4 = *(_DWORD *)v16;
    if ( *(_DWORD *)v16 <= 0x40u )
    {
      v6 = *((_QWORD *)this + 1);
      v7 = *(_QWORD *)(v2 + 176);
      v8 = *(_WORD *)(v6 + 34);
      if ( v7 )
      {
        v9 = *(_DWORD *)(v7 + 28);
        v10 = *(_QWORD *)v7;
      }
      else
      {
        v9 = 0;
        v10 = 0i64;
      }
      if ( *(_DWORD *)(v6 + 68) == 100 )
      {
        v11 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v6 + 512i64))(v6, 0i64);
        HandshakeHash = SslDuplicateTranscriptHash(v10, v11, v17, 0i64);
      }
      else
      {
        HandshakeHash = SslCreateHandshakeHash(v10, v17, *(unsigned __int16 *)(v6 + 34), v9, 0);
      }
      PrfHashDetails = HandshakeHash;
      if ( !HandshakeHash )
      {
        PrfHashDetails = CTlsRecord::HashPskBinderTranscript(*((CTlsRecord **)this + 4), v17[0]);
        if ( !PrfHashDetails )
        {
          PrfHashDetails = CTls13Context::GenerateBinderData(
                             (CTls13Context *)(*((_QWORD *)this + 1) + 1368i64),
                             v10,
                             *(_QWORD *)(v2 + 16),
                             v17[0],
                             v8,
                             v9,
                             *(const unsigned __int8 **)(v2 + 200),
                             *(unsigned __int8 *)(v2 + 208),
                             v18,
                             v4);
          RtlReleaseResource((PRTL_RESOURCE)(v2 + 72));
          if ( PrfHashDetails )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              WPP_SF_D(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                27i64,
                WPP_922678f99ae534148d3bb024010f1556_Traceguids,
                PrfHashDetails);
            }
          }
          else
          {
            v13 = *((_QWORD *)this + 4);
            v14[0] = v4;
            v15 = __ROR2__((unsigned __int8)v4 + 1, 8);
            PrfHashDetails = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v13 + 32i64))(
                               v13,
                               2i64,
                               &v15);
            if ( !PrfHashDetails )
            {
              PrfHashDetails = (*(__int64 (__fastcall **)(_QWORD, __int64, char *))(**((_QWORD **)this + 4) + 32i64))(
                                 *((_QWORD *)this + 4),
                                 1i64,
                                 v14);
              if ( !PrfHashDetails )
                PrfHashDetails = (*(__int64 (__fastcall **)(_QWORD, _QWORD, unsigned __int8 *))(**((_QWORD **)this + 4)
                                                                                              + 32i64))(
                                   *((_QWORD *)this + 4),
                                   (unsigned __int16)v4,
                                   v18);
            }
          }
          goto LABEL_7;
        }
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            26i64,
            WPP_922678f99ae534148d3bb024010f1556_Traceguids,
            PrfHashDetails);
      }
    }
    else
    {
      PrfHashDetails = 1359;
    }
  }
  RtlReleaseResource((PRTL_RESOURCE)(v2 + 72));
LABEL_7:
  if ( v17[0] )
    SslFreeObject(v17[0], 0i64);
  return PrfHashDetails;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];
// 180098440: using guessed type __int64 __fastcall SslCreateHandshakeHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098558: using guessed type __int64 __fastcall SslDuplicateTranscriptHash(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);
// 180065504: using guessed type char var_90[4];

//----- (000000018006581C) ----------------------------------------------------
int __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCertVerifyContentHash(
        __int64 a1,
        char a2,
        enum _eTlsHashAlgorithm a3,
        const wchar_t *a4,
        PUCHAR pbInput,
        ULONG cbOutput,
        ULONG *a7)
{
  unsigned __int8 v10; // al
  ULONG *v11; // rdi
  PUCHAR v12; // rsi
  ULONG v13; // r15d
  ULONG v14; // ecx
  __int64 v15; // rbx
  unsigned __int16 *v16; // rcx
  unsigned int v17; // ebx
  __int64 v18; // rax
  __int64 *v19; // rcx
  __int64 v20; // rcx
  int result; // eax
  ULONG v22; // r14d
  UCHAR *v23; // rax
  UCHAR *v24; // r15
  NTSTATUS v25; // ebx
  UCHAR *v26; // rdx
  ULONG cbInput; // [rsp+40h] [rbp-20h] BYREF
  ULONG pcbResult; // [rsp+44h] [rbp-1Ch] BYREF
  BCRYPT_HASH_HANDLE phHash; // [rsp+48h] [rbp-18h] BYREF
  BCRYPT_HANDLE hObject; // [rsp+50h] [rbp-10h] BYREF
  unsigned int pbOutput; // [rsp+B8h] [rbp+58h] BYREF

  if ( a4 )
  {
    v10 = wcsnlen(a4, 0x40ui64);
    if ( v10 >= 0x40u )
      return 87;
  }
  else
  {
    v10 = 0;
  }
  v11 = a7;
  if ( !a7 )
    return 87;
  if ( v10 )
    v10 = 2 * (v10 + 1);
  v12 = pbInput;
  v13 = v10;
  v14 = v10 + 64;
  *a7 = v14;
  if ( !v12 || cbOutput < v14 )
    return 122;
  *v11 = 0;
  if ( a4 )
  {
    v15 = v10;
    memcpy_0(v12, a4, v10);
    v12 += v15;
    *v11 = v13;
  }
  v16 = *(unsigned __int16 **)(a1 + 8);
  cbInput = 0;
  v17 = v16[17];
  v18 = (*(__int64 (__fastcall **)(unsigned __int16 *, _QWORD))(*(_QWORD *)v16 + 512i64))(v16, 0i64);
  v19 = *(__int64 **)(*(_QWORD *)(a1 + 8) + 8i64);
  if ( v19 )
    v20 = *v19;
  else
    v20 = 0i64;
  result = SslComputeSessionHash(v20, v18, v17, v12, 64, &cbInput, 0);
  if ( !result )
  {
    hObject = 0i64;
    result = TlsGetBCryptHashProvider(a3, &hObject, &cbOutput);
    if ( !result )
    {
      v22 = cbOutput;
      if ( cbOutput <= 0x40 )
      {
        pbOutput = 0;
        pcbResult = 0;
        result = BCryptGetProperty(hObject, L"ObjectLength", (PUCHAR)&pbOutput, 4u, &pcbResult, 0);
        if ( !result )
        {
          v23 = (UCHAR *)SPExternalAlloc(pbOutput);
          v24 = v23;
          if ( v23 )
          {
            phHash = 0i64;
            v25 = BCryptCreateHash(hObject, &phHash, v23, pbOutput, 0i64, 0, 0);
            if ( !v25 )
            {
              v25 = BCryptHashData(
                      phHash,
                      (PUCHAR)"                                                                TLS 1.3, ",
                      0x49u,
                      0);
              if ( !v25 )
              {
                v26 = (UCHAR *)"server";
                if ( !a2 )
                  v26 = (UCHAR *)"client";
                v25 = BCryptHashData(phHash, v26, 6u, 0);
                if ( !v25 )
                {
                  v25 = BCryptHashData(phHash, (PUCHAR)" CertificateVerify", 0x13u, 0);
                  if ( !v25 )
                  {
                    v25 = BCryptHashData(phHash, v12, cbInput, 0);
                    if ( !v25 )
                    {
                      v25 = BCryptFinishHash(phHash, v12, v22, 0);
                      if ( !v25 )
                        *v11 += v22;
                    }
                  }
                }
              }
            }
            if ( phHash )
              BCryptDestroyHash(phHash);
            SPExternalFree(v24);
            return v25;
          }
          else
          {
            return 14;
          }
        }
      }
      else
      {
        return 1359;
      }
    }
  }
  return result;
}
// 180098530: using guessed type __int64 __fastcall SslComputeSessionHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);

//----- (0000000180065AF8) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateCertVerifySignature(__int64 a1)
{
  BYTE *pbSignature; // r14
  BYTE *v3; // rbx
  ULONG LastError; // edi
  __int64 v5; // r15
  __int64 v6; // rax
  unsigned int v7; // eax
  const void *v8; // r15
  BYTE *v9; // rax
  DWORD v10; // r15d
  bool v11; // zf
  int v12; // eax
  const wchar_t *v13; // r9
  __int64 v14; // rax
  __int64 v15; // rcx
  int v16; // edx
  __int64 v17; // r10
  _QWORD *v18; // rcx
  __int64 v19; // rcx
  SECURITY_STATUS v20; // eax
  int v21; // ecx
  __int128 *p_pPaddingInfo; // rdx
  BYTE *v23; // rdx
  unsigned int v24; // r15d
  unsigned int v25; // edx
  unsigned int v26; // ecx
  DWORD v27; // edx
  __int16 v28; // cx
  __int64 v29; // rax
  __int64 v30; // rbx
  void *v31; // rcx
  DWORD cbHashValue; // [rsp+40h] [rbp-C0h] BYREF
  DWORD pcbResult; // [rsp+44h] [rbp-BCh] BYREF
  int v35; // [rsp+48h] [rbp-B8h] BYREF
  __int128 pPaddingInfo; // [rsp+50h] [rbp-B0h] BYREF
  unsigned int v37; // [rsp+60h] [rbp-A0h]
  BYTE *v38; // [rsp+68h] [rbp-98h]
  BYTE pbHashValue[192]; // [rsp+70h] [rbp-90h] BYREF

  pbSignature = 0i64;
  v35 = 0;
  v3 = 0i64;
  LastError = 0;
  if ( !*(_WORD *)(a1 + 140) )
    goto LABEL_44;
  if ( !*(_WORD *)(a1 + 142) )
    goto LABEL_44;
  v5 = *(_QWORD *)(a1 + 8);
  if ( !v5 )
    goto LABEL_44;
  v6 = *(_QWORD *)(a1 + 72);
  if ( !v6 )
    goto LABEL_44;
  pcbResult = 0;
  if ( *(_BYTE *)(v6 + 78) && !*(_BYTE *)(v6 + 79) )
  {
    v7 = *(unsigned __int16 *)(v5 + 944);
    *(_WORD *)(a1 + 140) = v7;
    if ( !(_WORD)v7 || (v8 = *(const void **)(v5 + 936)) == 0i64 )
    {
      LastError = 1359;
      goto LABEL_51;
    }
    v9 = (BYTE *)SPExternalAlloc(v7);
    pbSignature = v9;
    if ( v9 )
    {
      memcpy_0(v9, v8, *(unsigned __int16 *)(a1 + 140));
      v10 = *(unsigned __int16 *)(a1 + 140);
      pcbResult = v10;
      goto LABEL_33;
    }
LABEL_18:
    LastError = 14;
    goto LABEL_51;
  }
  memset_0(pbHashValue, 0, sizeof(pbHashValue));
  v11 = *(_DWORD *)(a1 + 104) == 1;
  cbHashValue = 0;
  if ( v11 && (v12 = *(_DWORD *)(v5 + 64), (v12 & 0x40051555) != 0) )
  {
    v13 = *(const wchar_t **)(a1 + 112);
  }
  else
  {
    v12 = *(_DWORD *)(v5 + 64);
    v13 = 0i64;
  }
  LastError = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCertVerifyContentHash(
                a1,
                (v12 & 0x40051555) != 0,
                *(enum _eTlsHashAlgorithm *)(a1 + 100),
                v13,
                pbHashValue,
                0xC0u,
                &cbHashValue);
  if ( LastError )
    goto LABEL_51;
  pbSignature = (BYTE *)SPExternalAlloc(*(unsigned __int16 *)(a1 + 140));
  if ( !pbSignature )
    goto LABEL_18;
  LastError = SslImpersonateClient(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 80i64) + 752i64), &v35);
  if ( !LastError )
  {
    v14 = *(_QWORD *)(a1 + 8);
    if ( (*(_DWORD *)(v14 + 64) & 0x40051555) != 0 )
    {
      v15 = *(_QWORD *)(v14 + 24);
      if ( !v15 )
        goto LABEL_44;
      v16 = 2;
      v17 = *(_QWORD *)(v15 + 8);
      v18 = *(_QWORD **)(v14 + 8);
      if ( *(_DWORD *)(a1 + 104) != 1 )
        v16 = 0;
      v19 = v18 ? *v18 : 0i64;
      v20 = SslSignHash(
              v19,
              v17,
              pbHashValue,
              cbHashValue,
              pbSignature,
              *(unsigned __int16 *)(a1 + 140),
              &pcbResult,
              v16);
    }
    else
    {
      v11 = *(_DWORD *)(a1 + 104) == 1;
      v21 = 0;
      pPaddingInfo = 0i64;
      p_pPaddingInfo = 0i64;
      if ( v11 )
      {
        p_pPaddingInfo = &pPaddingInfo;
        *(_QWORD *)&pPaddingInfo = *(_QWORD *)(a1 + 112);
        v21 = 8;
        DWORD2(pPaddingInfo) = cbHashValue;
      }
      v20 = NCryptSignHash(
              *(_QWORD *)(*(_QWORD *)(a1 + 72) + 104i64),
              p_pPaddingInfo,
              pbHashValue,
              cbHashValue,
              pbSignature,
              *(unsigned __int16 *)(a1 + 140),
              &pcbResult,
              v21 | 0x40);
    }
    LastError = v20;
    if ( !v20 )
    {
      v10 = pcbResult;
LABEL_33:
      v23 = pbSignature;
      if ( *(_DWORD *)(a1 + 104) == 1 )
      {
        if ( v10 <= 0xFFFF )
        {
          *(_WORD *)(a1 + 142) = v10;
          pbSignature = 0i64;
          v3 = v23;
          goto LABEL_43;
        }
      }
      else if ( *(_DWORD *)(a1 + 104) == 3 )
      {
        v24 = v10 >> 1;
        ReverseInPlace(pbSignature, v24);
        ReverseInPlace(&pbSignature[v24], v25);
        v26 = *(unsigned __int16 *)(a1 + 142);
        LODWORD(pPaddingInfo) = v24;
        *((_QWORD *)&pPaddingInfo + 1) = pbSignature;
        v37 = v24;
        v38 = &pbSignature[v24];
        v3 = (BYTE *)SPExternalAlloc(v26);
        if ( !v3 )
        {
          LastError = 14;
          goto LABEL_45;
        }
        cbHashValue = *(unsigned __int16 *)(a1 + 142);
        if ( !CryptEncodeObject(1u, (LPCSTR)0x2F, &pPaddingInfo, v3, &cbHashValue) )
        {
          LastError = GetLastError();
          goto LABEL_45;
        }
        v27 = *(unsigned __int16 *)(a1 + 142);
        v28 = cbHashValue;
        if ( cbHashValue <= v27 )
        {
          *(_WORD *)(a1 + 142) = cbHashValue;
          *(_WORD *)(a1 + 138) += v28 - v27;
LABEL_43:
          *(_QWORD *)(a1 + 144) = v3;
          v3 = 0i64;
          goto LABEL_45;
        }
      }
LABEL_44:
      LastError = 1359;
    }
  }
LABEL_45:
  if ( v35 )
    RevertToSelf();
  if ( v3 )
    SPExternalFree(v3);
  if ( pbSignature )
    SPExternalFree(pbSignature);
LABEL_51:
  v29 = *(_QWORD *)(a1 + 72);
  if ( *(_BYTE *)(v29 + 78) && !*(_BYTE *)(v29 + 79) )
  {
    v30 = *(_QWORD *)(a1 + 8);
    v31 = *(void **)(v30 + 936);
    if ( v31 )
    {
      SPExternalFree(v31);
      *(_QWORD *)(v30 + 936) = 0i64;
    }
    *(_DWORD *)(v30 + 944) = 0;
  }
  return LastError;
}
// 180065DAF: variable 'v25' is possibly undefined
// 180098540: using guessed type __int64 __fastcall SslSignHash(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);

//----- (0000000180065F08) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::GenerateCertificateAuthoritiesExtension(CTls13ServerHandshake *this)
{
  __int64 result; // rax
  __int64 v3; // rcx
  __int16 v4; // [rsp+30h] [rbp+8h] BYREF

  if ( *((_QWORD *)this + 22) && *((_WORD *)this + 92) )
  {
    result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
               (__int64)this,
               47,
               *((_WORD *)this + 93));
    if ( !(_DWORD)result )
    {
      v3 = *((_QWORD *)this + 4);
      v4 = __ROR2__(*((_WORD *)this + 92), 8);
      result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v3 + 32i64))(v3, 2i64, &v4);
      if ( !(_DWORD)result )
        return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 4) + 32i64))(
                 *((_QWORD *)this + 4),
                 *((unsigned __int16 *)this + 92),
                 *((_QWORD *)this + 22));
    }
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
    return 87i64;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (0000000180065FEC) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCertificateEntry(
        __int64 a1,
        __int64 a2,
        char a3)
{
  unsigned __int16 v5; // di
  __int64 v6; // rsi
  __int64 v7; // r9
  __int64 result; // rax
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int16 v12[20]; // [rsp+20h] [rbp-28h] BYREF
  char v13; // [rsp+58h] [rbp+10h] BYREF
  __int16 v14; // [rsp+68h] [rbp+20h] BYREF

  v5 = 0;
  v6 = 0i64;
  v7 = 65530i64;
  if ( a2 )
  {
    if ( *(_DWORD *)(a2 + 16) > 0xFFFAu )
      return 87i64;
    v5 = *(_WORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 8);
  }
  if ( a3 )
  {
    v7 = 65530 - (unsigned int)v5;
    if ( (int)v7 < *(unsigned __int16 *)(a1 + 154) )
      return 87i64;
  }
  v9 = *(_QWORD *)(a1 + 32);
  v13 = 0;
  result = (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64))(*(_QWORD *)v9 + 32i64))(v9, 1i64, &v13, v7);
  if ( !(_DWORD)result )
  {
    v10 = *(_QWORD *)(a1 + 32);
    v14 = __ROR2__(v5, 8);
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v10 + 32i64))(v10, 2i64, &v14);
    if ( !(_DWORD)result )
    {
      if ( !v6
        || (result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(**(_QWORD **)(a1 + 32) + 32i64))(
                       *(_QWORD *)(a1 + 32),
                       v5,
                       v6),
            !(_DWORD)result) )
      {
        if ( a3 )
        {
          return CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCertificateEntryExtensions(a1);
        }
        else
        {
          v11 = *(_QWORD *)(a1 + 32);
          v12[0] = 0;
          return (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v11 + 32i64))(v11, 2i64, v12);
        }
      }
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180065FEC: using guessed type __int16 var_28[20];

//----- (0000000180066130) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateCertificateEntry(
        __int64 a1,
        __int64 a2,
        char a3)
{
  unsigned __int16 v5; // di
  __int64 v6; // rsi
  __int64 v7; // r9
  __int64 result; // rax
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int16 v12[20]; // [rsp+20h] [rbp-28h] BYREF
  char v13; // [rsp+58h] [rbp+10h] BYREF
  __int16 v14; // [rsp+68h] [rbp+20h] BYREF

  v5 = 0;
  v6 = 0i64;
  v7 = 65530i64;
  if ( a2 )
  {
    if ( *(_DWORD *)(a2 + 16) > 0xFFFAu )
      return 87i64;
    v5 = *(_WORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 8);
  }
  if ( a3 )
  {
    v7 = 65530 - (unsigned int)v5;
    if ( (int)v7 < *(unsigned __int16 *)(a1 + 154) )
      return 87i64;
  }
  v9 = *(_QWORD *)(a1 + 32);
  v13 = 0;
  result = (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64))(*(_QWORD *)v9 + 32i64))(v9, 1i64, &v13, v7);
  if ( !(_DWORD)result )
  {
    v10 = *(_QWORD *)(a1 + 32);
    v14 = __ROR2__(v5, 8);
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v10 + 32i64))(v10, 2i64, &v14);
    if ( !(_DWORD)result )
    {
      if ( !v6
        || (result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(**(_QWORD **)(a1 + 32) + 32i64))(
                       *(_QWORD *)(a1 + 32),
                       v5,
                       v6),
            !(_DWORD)result) )
      {
        if ( a3 )
        {
          return CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateCertificateEntryExtensions(a1);
        }
        else
        {
          v11 = *(_QWORD *)(a1 + 32);
          v12[0] = 0;
          return (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v11 + 32i64))(v11, 2i64, v12);
        }
      }
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180066130: using guessed type __int16 var_28[20];

//----- (0000000180066274) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCertificateEntryExtensions(__int64 a1)
{
  __int16 v1; // ax
  __int64 v3; // rcx
  __int64 result; // rax
  __int16 v5; // [rsp+30h] [rbp+8h] BYREF

  v1 = *(_WORD *)(a1 + 154);
  v3 = *(_QWORD *)(a1 + 32);
  v5 = __ROR2__(v1, 8);
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v3 + 32i64))(v3, 2i64, &v5);
  if ( !(_DWORD)result )
  {
    if ( *(_WORD *)(a1 + 154) )
    {
      if ( (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 64i64) & 0x40051555) == 0 )
        return CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateGenericExtensions(a1, 11);
      if ( !*(_WORD *)(a1 + 152) )
        return CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateGenericExtensions(a1, 11);
      result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8i64))(a1);
      if ( !(_DWORD)result )
        return CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateGenericExtensions(a1, 11);
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180066318) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateCertificateEntryExtensions(__int64 a1)
{
  __int16 v1; // ax
  __int64 v3; // rcx
  __int64 result; // rax
  __int16 v5; // [rsp+30h] [rbp+8h] BYREF

  v1 = *(_WORD *)(a1 + 154);
  v3 = *(_QWORD *)(a1 + 32);
  v5 = __ROR2__(v1, 8);
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v3 + 32i64))(v3, 2i64, &v5);
  if ( !(_DWORD)result )
  {
    if ( *(_WORD *)(a1 + 154) )
    {
      if ( (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 64i64) & 0x40051555) == 0 )
        return CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateGenericExtensions(a1, 11);
      if ( !*(_WORD *)(a1 + 152) )
        return CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateGenericExtensions(a1, 11);
      result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8i64))(a1);
      if ( !(_DWORD)result )
        return CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateGenericExtensions(a1, 11);
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (00000001800663BC) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCertificateList(__int64 a1)
{
  __int64 v2; // rcx
  __int64 result; // rax
  __int64 v4; // rcx
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 *v7; // rdi
  __int64 v8; // rdi
  unsigned int v9; // ebx
  __int64 v10; // r14
  struct _CRYPTOAPI_BLOB *v11; // rdx
  bool v12; // zf
  __int64 v13; // rdx
  char v14; // [rsp+40h] [rbp+8h] BYREF
  __int16 v15; // [rsp+48h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(a1 + 32);
  v14 = 0;
  result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v2 + 32i64))(v2, 1i64, &v14);
  if ( !(_DWORD)result )
  {
    v4 = *(_QWORD *)(a1 + 32);
    v15 = __ROR2__(*(_WORD *)(a1 + 64), 8);
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v4 + 32i64))(v4, 2i64, &v15);
    if ( !(_DWORD)result )
    {
      v5 = *(_QWORD *)(a1 + 72);
      if ( !v5 )
        return (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 64i64) & 0x40051555) != 0 ? 0x54F : 0;
      v6 = *(_QWORD *)(v5 + 64);
      if ( v6 )
      {
        v7 = *(__int64 **)(v6 + 16);
        if ( v7 )
        {
          if ( *(_DWORD *)(v6 + 12) )
          {
            v8 = *v7;
            if ( v8 && *(_QWORD *)(v8 + 16) && *(_DWORD *)(v8 + 12) )
            {
              v9 = 0;
              while ( 1 )
              {
                v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 16) + 8i64 * v9) + 8i64);
                if ( !v10 )
                  return 87i64;
                v11 = *(struct _CRYPTOAPI_BLOB **)(v10 + 24);
                if ( !v11 )
                  return 87i64;
                if ( *(_BYTE *)(a1 + 80) )
                  goto LABEL_17;
                v12 = v9 == 0;
                if ( v9 )
                  break;
LABEL_18:
                result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCertificateEntry(a1, v10, v12);
                if ( (_DWORD)result )
                  return result;
                if ( ++v9 >= *(_DWORD *)(v8 + 12) )
                  return 0i64;
              }
              if ( CertCompareCertificateName(*(_DWORD *)v10, v11 + 3, v11 + 5) )
                return 0i64;
LABEL_17:
              v12 = v9 == 0;
              goto LABEL_18;
            }
            return 87i64;
          }
        }
      }
      v13 = *(_QWORD *)(v5 + 32);
      if ( !v13 )
        return 87i64;
      result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCertificateEntry(a1, v13, 1);
      if ( !(_DWORD)result )
        return 0i64;
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (000000018006652C) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateCertificateList(__int64 a1)
{
  __int64 v2; // rcx
  __int64 result; // rax
  __int64 v4; // rcx
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 *v7; // rdi
  __int64 v8; // rdi
  unsigned int v9; // ebx
  __int64 v10; // r14
  struct _CRYPTOAPI_BLOB *v11; // rdx
  bool v12; // zf
  __int64 v13; // rdx
  char v14; // [rsp+40h] [rbp+8h] BYREF
  __int16 v15; // [rsp+48h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(a1 + 32);
  v14 = 0;
  result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v2 + 32i64))(v2, 1i64, &v14);
  if ( !(_DWORD)result )
  {
    v4 = *(_QWORD *)(a1 + 32);
    v15 = __ROR2__(*(_WORD *)(a1 + 64), 8);
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v4 + 32i64))(v4, 2i64, &v15);
    if ( !(_DWORD)result )
    {
      v5 = *(_QWORD *)(a1 + 72);
      if ( !v5 )
        return (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 64i64) & 0x40051555) != 0 ? 0x54F : 0;
      v6 = *(_QWORD *)(v5 + 64);
      if ( v6 )
      {
        v7 = *(__int64 **)(v6 + 16);
        if ( v7 )
        {
          if ( *(_DWORD *)(v6 + 12) )
          {
            v8 = *v7;
            if ( v8 && *(_QWORD *)(v8 + 16) && *(_DWORD *)(v8 + 12) )
            {
              v9 = 0;
              while ( 1 )
              {
                v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 16) + 8i64 * v9) + 8i64);
                if ( !v10 )
                  return 87i64;
                v11 = *(struct _CRYPTOAPI_BLOB **)(v10 + 24);
                if ( !v11 )
                  return 87i64;
                if ( *(_BYTE *)(a1 + 80) )
                  goto LABEL_17;
                v12 = v9 == 0;
                if ( v9 )
                  break;
LABEL_18:
                result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateCertificateEntry(a1, v10, v12);
                if ( (_DWORD)result )
                  return result;
                if ( ++v9 >= *(_DWORD *)(v8 + 12) )
                  return 0i64;
              }
              if ( CertCompareCertificateName(*(_DWORD *)v10, v11 + 3, v11 + 5) )
                return 0i64;
LABEL_17:
              v12 = v9 == 0;
              goto LABEL_18;
            }
            return 87i64;
          }
        }
      }
      v13 = *(_QWORD *)(v5 + 32);
      if ( !v13 )
        return 87i64;
      result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateCertificateEntry(a1, v13, 1);
      if ( !(_DWORD)result )
        return 0i64;
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (000000018006669C) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCertificateMsg(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rax
  char v4; // al
  __int64 v5; // rcx
  char v6; // [rsp+30h] [rbp+8h] BYREF

  result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateHandshakeHeader(a1, 11, *(_WORD *)(a1 + 136));
  if ( !(_DWORD)result )
  {
    v3 = *(_QWORD *)(a1 + 8);
    v4 = (*(_DWORD *)(v3 + 64) & 0x40051555) != 0 ? 0 : *(_BYTE *)(v3 + 1600);
    v5 = *(_QWORD *)(a1 + 32);
    v6 = v4;
    result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v5 + 32i64))(v5, 1i64, &v6);
    if ( !(_DWORD)result )
    {
      if ( !v6 )
        goto LABEL_10;
      if ( !*(_QWORD *)(*(_QWORD *)(a1 + 8) + 1592i64) )
        return 2148074244i64;
      result = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 32) + 32i64))(*(_QWORD *)(a1 + 32));
      if ( !(_DWORD)result )
      {
LABEL_10:
        result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCertificateList(a1);
        if ( !(_DWORD)result )
          return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 32) + 40i64))(*(_QWORD *)(a1 + 32));
      }
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180066778) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateCertificateMsg(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rax
  char v4; // al
  __int64 v5; // rcx
  char v6; // [rsp+30h] [rbp+8h] BYREF

  result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateHandshakeHeader(a1, 11, *(_WORD *)(a1 + 136));
  if ( !(_DWORD)result )
  {
    v3 = *(_QWORD *)(a1 + 8);
    v4 = (*(_DWORD *)(v3 + 64) & 0x40051555) != 0 ? 0 : *(_BYTE *)(v3 + 1232);
    v5 = *(_QWORD *)(a1 + 32);
    v6 = v4;
    result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v5 + 32i64))(v5, 1i64, &v6);
    if ( !(_DWORD)result )
    {
      if ( !v6 )
        goto LABEL_10;
      if ( !*(_QWORD *)(*(_QWORD *)(a1 + 8) + 1224i64) )
        return 2148074244i64;
      result = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 32) + 32i64))(*(_QWORD *)(a1 + 32));
      if ( !(_DWORD)result )
      {
LABEL_10:
        result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateCertificateList(a1);
        if ( !(_DWORD)result )
          return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 32) + 40i64))(*(_QWORD *)(a1 + 32));
      }
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180066854) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::GenerateCertificateRequest(CTls13ServerHandshake *this)
{
  __int64 result; // rax
  unsigned __int8 v3; // [rsp+30h] [rbp+8h] BYREF

  result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateHandshakeHeader(
             (__int64)this,
             13,
             *((_WORD *)this + 85));
  if ( !(_DWORD)result )
  {
    v3 = *(_BYTE *)(*((_QWORD *)this + 1) + 1232i64);
    result = (*(__int64 (__fastcall **)(_QWORD, __int64, unsigned __int8 *))(**((_QWORD **)this + 4) + 32i64))(
               *((_QWORD *)this + 4),
               1i64,
               &v3);
    if ( !(_DWORD)result )
    {
      if ( !v3
        || (result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 4) + 32i64))(
                       *((_QWORD *)this + 4),
                       v3,
                       *(_QWORD *)(*((_QWORD *)this + 1) + 1224i64)),
            !(_DWORD)result) )
      {
        result = CTls13ServerHandshake::GenerateCertificateRequestExtensions(this);
        if ( !(_DWORD)result )
          return (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 4) + 40i64))(*((_QWORD *)this + 4));
      }
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180066920) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::GenerateCertificateRequestExtensions(CTls13ServerHandshake *this)
{
  __int16 v1; // ax
  __int64 v3; // rcx
  __int64 result; // rax
  __int16 v5; // [rsp+30h] [rbp+8h] BYREF

  v1 = *((_WORD *)this + 84);
  v3 = *((_QWORD *)this + 4);
  v5 = __ROR2__(v1, 8);
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v3 + 32i64))(v3, 2i64, &v5);
  if ( !(_DWORD)result )
  {
    result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateSignatureAlgorithmsExtension((__int64)this);
    if ( !(_DWORD)result )
    {
      if ( !g_fSendIssuerList )
        return CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateGenericExtensions((__int64)this, 13);
      if ( !*((_QWORD *)this + 22) )
        return CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateGenericExtensions((__int64)this, 13);
      if ( !*((_WORD *)this + 92) )
        return CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateGenericExtensions((__int64)this, 13);
      result = CTls13ServerHandshake::GenerateCertificateAuthoritiesExtension(this);
      if ( !(_DWORD)result )
        return CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateGenericExtensions((__int64)this, 13);
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180092F08: using guessed type int g_fSendIssuerList;

//----- (00000001800669BC) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateCertificateVerify(__int64 a1)
{
  unsigned int CertVerifySignature; // edi
  __int64 v3; // rcx
  void *v4; // rcx
  __int16 v6; // [rsp+30h] [rbp+8h] BYREF

  CertVerifySignature = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateCertVerifySignature(a1);
  if ( !CertVerifySignature )
  {
    CertVerifySignature = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateHandshakeHeader(
                            a1,
                            15,
                            *(_WORD *)(a1 + 138));
    if ( !CertVerifySignature )
    {
      if ( *(_WORD *)(a1 + 120) )
      {
        CertVerifySignature = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 32) + 32i64))(
                                *(_QWORD *)(a1 + 32),
                                2i64);
        if ( !CertVerifySignature )
        {
          v3 = *(_QWORD *)(a1 + 32);
          v6 = __ROR2__(*(_WORD *)(a1 + 142), 8);
          CertVerifySignature = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v3 + 32i64))(
                                  v3,
                                  2i64,
                                  &v6);
          if ( !CertVerifySignature )
          {
            CertVerifySignature = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 32) + 32i64))(
                                    *(_QWORD *)(a1 + 32),
                                    *(unsigned __int16 *)(a1 + 142),
                                    *(_QWORD *)(a1 + 144));
            if ( !CertVerifySignature )
              CertVerifySignature = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 32) + 40i64))(*(_QWORD *)(a1 + 32));
          }
        }
      }
      else
      {
        CertVerifySignature = 1359;
      }
    }
  }
  v4 = *(void **)(a1 + 144);
  if ( v4 )
  {
    SPExternalFree(v4);
    *(_QWORD *)(a1 + 144) = 0i64;
  }
  return CertVerifySignature;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180066AF0) ----------------------------------------------------
unsigned int __fastcall CTls13ClientHandshake::GenerateClientHello(
        CTls13ClientHandshake *this,
        int a2,
        unsigned int *a3,
        __int16 a4,
        const unsigned __int16 *a5,
        PUCHAR pbBuffer)
{
  UCHAR *v8; // rsi
  __int64 v9; // rax
  unsigned __int16 v10; // r8
  unsigned int result; // eax
  __int64 v12; // rcx
  __int64 v13; // rcx
  unsigned int *v14; // rsi
  __int64 v15; // rcx
  __int64 v16; // rcx
  __int64 v17; // rcx
  char v18[4]; // [rsp+20h] [rbp-10h] BYREF
  __int16 v19; // [rsp+24h] [rbp-Ch] BYREF
  __int16 v20[2]; // [rsp+28h] [rbp-8h] BYREF
  __int16 v21; // [rsp+2Ch] [rbp-4h] BYREF
  char v22; // [rsp+50h] [rbp+20h] BYREF
  unsigned __int8 v23; // [rsp+58h] [rbp+28h] BYREF

  if ( a2 != *((unsigned __int16 *)this + 80) )
    return 87;
  if ( !a3 )
    return 87;
  if ( a4 != *((_WORD *)this + 63) )
    return 87;
  if ( !a5 )
    return 87;
  v8 = pbBuffer;
  if ( !pbBuffer )
    return 87;
  v9 = *((_QWORD *)this + 1);
  if ( !*(_WORD *)(v9 + 920) || !*(_QWORD *)(v9 + 912) )
    return 87;
  v10 = *((_WORD *)this + 84);
  *((_QWORD *)this + 16) = a5;
  result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateHandshakeHeader((__int64)this, 1, v10);
  if ( !result )
  {
    v12 = *((_QWORD *)this + 4);
    v19 = 771;
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v12 + 32i64))(v12, 2i64, &v19);
    if ( !result && (*(_DWORD *)(*((_QWORD *)this + 1) + 68i64) == 100 || (result = GenerateRandomBits(v8, 0x20u)) == 0) )
    {
      result = (*(__int64 (__fastcall **)(_QWORD, __int64, UCHAR *))(**((_QWORD **)this + 4) + 32i64))(
                 *((_QWORD *)this + 4),
                 32i64,
                 v8);
      if ( !result )
      {
        v23 = *(_BYTE *)(*((_QWORD *)this + 1) + 1649i64);
        result = (*(__int64 (__fastcall **)(_QWORD, __int64, unsigned __int8 *))(**((_QWORD **)this + 4) + 32i64))(
                   *((_QWORD *)this + 4),
                   1i64,
                   &v23);
        if ( !result
          && (!v23
           || (result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(**((_QWORD **)this + 4) + 32i64))(
                          *((_QWORD *)this + 4),
                          v23,
                          *((_QWORD *)this + 1) + 1617i64)) == 0) )
        {
          v13 = *((_QWORD *)this + 4);
          v20[0] = __ROR2__(2 * *((_WORD *)this + 80), 8);
          result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v13 + 32i64))(v13, 2i64, v20);
          if ( !result )
          {
            v14 = a3;
            if ( a3 >= &a3[*((unsigned __int16 *)this + 80)] )
            {
LABEL_20:
              v16 = *((_QWORD *)this + 4);
              v22 = 1;
              result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v16 + 32i64))(v16, 1i64, &v22);
              if ( !result )
              {
                v17 = *((_QWORD *)this + 4);
                v18[0] = 0;
                result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v17 + 32i64))(v17, 1i64, v18);
                if ( !result )
                {
                  result = CTls13ClientHandshake::GenerateClientHelloExtensions(this);
                  if ( !result )
                    return (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 4) + 40i64))(*((_QWORD *)this + 4));
                }
              }
            }
            else
            {
              while ( 1 )
              {
                v15 = *((_QWORD *)this + 4);
                v21 = __ROR2__(*(_WORD *)v14, 8);
                result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v15 + 32i64))(
                           v15,
                           2i64,
                           &v21);
                if ( result )
                  break;
                if ( ++v14 >= &a3[*((unsigned __int16 *)this + 80)] )
                  goto LABEL_20;
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180066AF0: using guessed type __int16 var_8[2];
// 180066AF0: using guessed type char var_10[4];

//----- (0000000180066DB8) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::GenerateClientHelloExtensions(CTls13ClientHandshake *this)
{
  __int16 v1; // ax
  __int64 v3; // rcx
  __int64 result; // rax
  __int16 v5; // [rsp+30h] [rbp+8h] BYREF

  v1 = *((_WORD *)this + 20);
  v3 = *((_QWORD *)this + 4);
  v5 = __ROR2__(v1, 8);
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v3 + 32i64))(v3, 2i64, &v5);
  if ( !(_DWORD)result )
  {
    result = CTls13ClientHandshake::GenerateServerNameExtension(this);
    if ( !(_DWORD)result )
    {
      result = (*(__int64 (__fastcall **)(CTls13ClientHandshake *))(*(_QWORD *)this + 8i64))(this);
      if ( !(_DWORD)result )
      {
        result = CTls13ClientHandshake::GenerateSupportedVersionsExtension(this);
        if ( !(_DWORD)result )
        {
          result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateSignatureAlgorithmsExtension((__int64)this);
          if ( !(_DWORD)result )
          {
            result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader((__int64)this, 35, 0);
            if ( !(_DWORD)result )
            {
              result = CTls13ClientHandshake::GenerateSupportedGroupsExtension(this);
              if ( !(_DWORD)result )
              {
                result = CTls13ClientHandshake::GenerateALPNExtension(this);
                if ( !(_DWORD)result )
                {
                  result = CTls13ClientHandshake::GenerateKeyShareExtension(this);
                  if ( !(_DWORD)result )
                  {
                    result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
                               (__int64)this,
                               49,
                               0);
                    if ( !(_DWORD)result )
                    {
                      if ( !*(_BYTE *)(*((_QWORD *)this + 1) + 1344i64)
                        || (result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
                                       (__int64)this,
                                       23,
                                       0),
                            !(_DWORD)result) )
                      {
                        result = CTls13ClientHandshake::GenerateRenegotiationInfoExtension(this);
                        if ( !(_DWORD)result )
                        {
                          result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCookieExtension((__int64)this);
                          if ( !(_DWORD)result )
                          {
                            result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateGenericExtensions(
                                       (__int64)this,
                                       1);
                            if ( !(_DWORD)result )
                            {
                              result = CTls13ClientHandshake::GeneratePskKeyExchangeModesExtension(this);
                              if ( !(_DWORD)result )
                                return CTls13ClientHandshake::GeneratePskExtension(this);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180066F08) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCookieExtension(__int64 a1)
{
  __int16 v2; // r8
  __int64 result; // rax
  __int64 v4; // rcx
  __int16 v5; // [rsp+30h] [rbp+8h] BYREF

  if ( !*(_QWORD *)(a1 + 88) )
    return 0i64;
  if ( !*(_WORD *)(a1 + 96) )
    return 0i64;
  v2 = *(_WORD *)(a1 + 98);
  if ( !v2 )
    return 0i64;
  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(a1, 44, v2);
  if ( !(_DWORD)result )
  {
    v4 = *(_QWORD *)(a1 + 32);
    v5 = __ROR2__(*(_WORD *)(a1 + 96), 8);
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v4 + 32i64))(v4, 2i64, &v5);
    if ( !(_DWORD)result )
    {
      if ( v5 )
        return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 32) + 32i64))(
                 *(_QWORD *)(a1 + 32),
                 *(unsigned __int16 *)(a1 + 96),
                 *(_QWORD *)(a1 + 88));
      else
        return 315i64;
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180066FBC) ----------------------------------------------------
unsigned int __fastcall CTls13ServerHandshake::GenerateEncryptedExtensions(CTls13ServerHandshake *this)
{
  __int16 v1; // ax
  __int64 v3; // rcx
  unsigned int result; // eax
  __int16 v5; // [rsp+30h] [rbp+8h] BYREF

  v1 = *((_WORD *)this + 82);
  v3 = *((_QWORD *)this + 4);
  v5 = __ROR2__(v1, 8);
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v3 + 32i64))(v3, 2i64, &v5);
  if ( !result
    && ((*(_DWORD *)(*((_QWORD *)this + 1) + 136i64) & 0x200000) == 0
     || (result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(this, 0i64, 0i64)) == 0) )
  {
    result = CTls13ServerHandshake::GenerateSelectedALPNExtension(this);
    if ( !result )
      return CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateGenericExtensions(this, 8i64);
  }
  return result;
}
// 180067098: using guessed type __int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(_QWORD, _QWORD, _QWORD);
// 1800674C0: using guessed type __int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateGenericExtensions(_QWORD, _QWORD);

//----- (0000000180067044) ----------------------------------------------------
unsigned int __fastcall CTls13ServerHandshake::GenerateEncryptedExtensionsMsg(CTls13ServerHandshake *this)
{
  unsigned int result; // eax

  result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateHandshakeHeader(
             (__int64)this,
             8,
             *((_WORD *)this + 81));
  if ( !result )
  {
    result = CTls13ServerHandshake::GenerateEncryptedExtensions(this);
    if ( !result )
      return (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 4) + 40i64))(*((_QWORD *)this + 4));
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180067098) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
        __int64 a1,
        __int16 a2,
        __int16 a3)
{
  __int64 v4; // rcx
  __int64 result; // rax
  __int64 v7; // rcx
  __int16 v8; // [rsp+30h] [rbp+8h] BYREF
  __int16 v9; // [rsp+48h] [rbp+20h] BYREF

  v4 = *(_QWORD *)(a1 + 32);
  v8 = __ROR2__(a2, 8);
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v4 + 32i64))(v4, 2i64, &v8);
  if ( !(_DWORD)result )
  {
    v7 = *(_QWORD *)(a1 + 32);
    v9 = __ROR2__(a3, 8);
    return (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v7 + 32i64))(v7, 2i64, &v9);
  }
  return result;
}

//----- (000000018006711C) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateFinished(__int64 a1)
{
  __int64 result; // rax
  unsigned __int64 FinishedMessageKey; // rdi
  __int64 v4; // r8
  int v5; // esi
  __int64 v6; // rax
  _QWORD *v7; // rcx
  int v8; // eax
  unsigned int v9; // edi
  char v10[64]; // [rsp+30h] [rbp-58h] BYREF

  result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateHandshakeHeader(a1, 20, *(_WORD *)(a1 + 82));
  if ( !(_DWORD)result )
  {
    FinishedMessageKey = CTls13Context::GetFinishedMessageKey(
                           (CTls13Context *)(*(_QWORD *)(a1 + 8) + 1368i64),
                           (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 64i64) & 0x800A2AAA) != 0);
    if ( FinishedMessageKey )
    {
      v5 = *(unsigned __int8 *)(a1 + 81);
      v6 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 512i64))(v4, 0i64);
      v7 = *(_QWORD **)(*(_QWORD *)(a1 + 8) + 8i64);
      if ( v7 )
        v7 = (_QWORD *)*v7;
      v8 = SslComputeFinishedHash(v7, FinishedMessageKey, v6, v10, v5, 0);
      v9 = v8;
      if ( v8 )
      {
        CSslContext::SetError(*(_QWORD *)(a1 + 8), 901, v8);
        return v9;
      }
      else
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
        result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, char *))(**(_QWORD **)(a1 + 32) + 32i64))(
                   *(_QWORD *)(a1 + 32),
                   *(unsigned __int8 *)(a1 + 81),
                   v10);
        if ( !(_DWORD)result )
          return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 32) + 40i64))(*(_QWORD *)(a1 + 32));
      }
    }
    else
    {
      return 1359i64;
    }
  }
  return result;
}
// 180067188: variable 'v4' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];
// 180098538: using guessed type __int64 __fastcall SslComputeFinishedHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (000000018006728C) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateFinished(__int64 a1)
{
  __int64 result; // rax
  unsigned __int64 FinishedMessageKey; // rdi
  __int64 v4; // r8
  int v5; // esi
  __int64 v6; // rax
  _QWORD *v7; // rcx
  int v8; // eax
  unsigned int v9; // edi
  char v10[64]; // [rsp+30h] [rbp-58h] BYREF

  result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateHandshakeHeader(a1, 20, *(_WORD *)(a1 + 82));
  if ( !(_DWORD)result )
  {
    FinishedMessageKey = CTls13Context::GetFinishedMessageKey(
                           (CTls13Context *)(*(_QWORD *)(a1 + 8) + 1000i64),
                           (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 64i64) & 0x800A2AAA) != 0);
    if ( FinishedMessageKey )
    {
      v5 = *(unsigned __int8 *)(a1 + 81);
      v6 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 512i64))(v4, 0i64);
      v7 = *(_QWORD **)(*(_QWORD *)(a1 + 8) + 8i64);
      if ( v7 )
        v7 = (_QWORD *)*v7;
      v8 = SslComputeFinishedHash(v7, FinishedMessageKey, v6, v10, v5, 0);
      v9 = v8;
      if ( v8 )
      {
        CSslContext::SetError(*(_QWORD *)(a1 + 8), 901, v8);
        return v9;
      }
      else
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
        result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, char *))(**(_QWORD **)(a1 + 32) + 32i64))(
                   *(_QWORD *)(a1 + 32),
                   *(unsigned __int8 *)(a1 + 81),
                   v10);
        if ( !(_DWORD)result )
          return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 32) + 40i64))(*(_QWORD *)(a1 + 32));
      }
    }
    else
    {
      return 1359i64;
    }
  }
  return result;
}
// 1800672F8: variable 'v4' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];
// 180098538: using guessed type __int64 __fastcall SslComputeFinishedHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (00000001800673FC) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateGenericExtensions(__int64 a1, int a2)
{
  __int64 v2; // rax
  __int64 *v5; // rbx
  __int64 v6; // r8
  __int64 *v7; // rbp
  __int64 v8; // rdi
  __int64 result; // rax
  __int64 v10; // rdx

  v2 = *(_QWORD *)(a1 + 8);
  v5 = (__int64 *)(v2 + 1480);
  if ( v2 != -1480 )
  {
    v6 = *(unsigned __int8 *)(v2 + 1488);
    if ( (_BYTE)v6 )
    {
      v7 = &v5[v6];
      while ( v5 < v7 )
      {
        v8 = *v5;
        if ( !*v5 )
          return 2148074244i64;
        if ( *(unsigned __int16 *)(v8 + 2) == a2 )
        {
          result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
                     a1,
                     *(_WORD *)v8,
                     *(_WORD *)(v8 + 8));
          if ( (_DWORD)result )
            return result;
          v10 = *(unsigned __int16 *)(v8 + 8);
          if ( (_WORD)v10 )
          {
            result = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(**(_QWORD **)(a1 + 32) + 32i64))(
                       *(_QWORD *)(a1 + 32),
                       v10,
                       v8 + 10);
            if ( (_DWORD)result )
              return result;
          }
        }
        ++v5;
      }
    }
  }
  return 0i64;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (00000001800674C0) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateGenericExtensions(__int64 a1, int a2)
{
  __int64 v2; // rax
  __int64 *v5; // rbx
  __int64 v6; // r8
  __int64 *v7; // rbp
  __int64 v8; // rdi
  __int64 result; // rax
  __int64 v10; // rdx

  v2 = *(_QWORD *)(a1 + 8);
  v5 = (__int64 *)(v2 + 1112);
  if ( v2 != -1112 )
  {
    v6 = *(unsigned __int8 *)(v2 + 1120);
    if ( (_BYTE)v6 )
    {
      v7 = &v5[v6];
      while ( v5 < v7 )
      {
        v8 = *v5;
        if ( !*v5 )
          return 2148074244i64;
        if ( *(unsigned __int16 *)(v8 + 2) == a2 )
        {
          result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
                     a1,
                     *(_WORD *)v8,
                     *(_WORD *)(v8 + 8));
          if ( (_DWORD)result )
            return result;
          v10 = *(unsigned __int16 *)(v8 + 8);
          if ( (_WORD)v10 )
          {
            result = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(**(_QWORD **)(a1 + 32) + 32i64))(
                       *(_QWORD *)(a1 + 32),
                       v10,
                       v8 + 10);
            if ( (_DWORD)result )
              return result;
          }
        }
        ++v5;
      }
    }
  }
  return 0i64;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180067584) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::GenerateHRRExtensions(CTls13ServerHandshake *this)
{
  __int16 v1; // ax
  __int64 v3; // rcx
  __int64 result; // rax
  __int16 v5; // [rsp+30h] [rbp+8h] BYREF

  v1 = *((_WORD *)this + 20);
  v3 = *((_QWORD *)this + 4);
  v5 = __ROR2__(v1, 8);
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v3 + 32i64))(v3, 2i64, &v5);
  if ( !(_DWORD)result )
  {
    result = CTls13ServerHandshake::GenerateSupportedVersionsExtension(this);
    if ( !(_DWORD)result )
    {
      result = CTls13ServerHandshake::GenerateNamedGroupExtension(this);
      if ( !(_DWORD)result )
        return CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateGenericExtensions((__int64)this, 2);
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (00000001800675F4) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateHandshakeHeader(
        __int64 a1,
        char a2,
        unsigned __int16 a3)
{
  __int64 result; // rax
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int16 v9[12]; // [rsp+20h] [rbp-18h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF
  char v11; // [rsp+58h] [rbp+20h] BYREF

  if ( a3 < 4u )
    return 87i64;
  v6 = *(_QWORD *)(a1 + 32);
  v10 = a2;
  result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v6 + 32i64))(v6, 1i64, &v10);
  if ( !(_DWORD)result )
  {
    v7 = *(_QWORD *)(a1 + 32);
    v11 = 0;
    result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v7 + 32i64))(v7, 1i64, &v11);
    if ( !(_DWORD)result )
    {
      v8 = *(_QWORD *)(a1 + 32);
      v9[0] = __ROR2__(a3 - 4, 8);
      return (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v8 + 32i64))(v8, 2i64, v9);
    }
  }
  return result;
}
// 1800675F4: using guessed type __int16 var_18[12];

//----- (00000001800676B4) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateKeyShareEntry(__int64 a1)
{
  __int64 result; // rax
  __int16 v3; // ax
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int16 v6; // [rsp+30h] [rbp+8h] BYREF
  __int16 v7; // [rsp+38h] [rbp+10h] BYREF

  if ( *(_DWORD *)(*(_QWORD *)(a1 + 8) + 68i64) == 40 && g_fEnableHelloRetryRequest )
  {
    *(_WORD *)(a1 + 44) = 0;
    return 0i64;
  }
  else
  {
    v3 = *(_WORD *)(a1 + 44);
    v4 = *(_QWORD *)(a1 + 32);
    v6 = __ROR2__(v3, 8);
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v4 + 32i64))(v4, 2i64, &v6);
    if ( !(_DWORD)result )
    {
      v5 = *(_QWORD *)(a1 + 32);
      v7 = __ROR2__(*(_WORD *)(a1 + 48) + *(unsigned __int8 *)(a1 + 46), 8);
      result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v5 + 32i64))(v5, 2i64, &v7);
      if ( !(_DWORD)result )
      {
        if ( !*(_BYTE *)(a1 + 46) )
          return (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(**(_QWORD **)(a1 + 32) + 32i64))(
                   *(_QWORD *)(a1 + 32),
                   *(unsigned __int16 *)(a1 + 48),
                   *(_QWORD *)(a1 + 56) + 8i64);
        result = (*(__int64 (__fastcall **)(_QWORD, __int64, void *))(**(_QWORD **)(a1 + 32) + 32i64))(
                   *(_QWORD *)(a1 + 32),
                   1i64,
                   &unk_1800858AA);
        if ( !(_DWORD)result )
          return (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(**(_QWORD **)(a1 + 32) + 32i64))(
                   *(_QWORD *)(a1 + 32),
                   *(unsigned __int16 *)(a1 + 48),
                   *(_QWORD *)(a1 + 56) + 8i64);
      }
    }
  }
  return result;
}
// 1800927A0: using guessed type int g_fEnableHelloRetryRequest;

//----- (00000001800677C0) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::GenerateKeyShareExtension(CTls13ClientHandshake *this)
{
  __int64 result; // rax
  __int64 v3; // rcx
  __int16 v4; // [rsp+30h] [rbp+8h] BYREF

  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
             (__int64)this,
             51,
             *((_WORD *)this + 26));
  if ( !(_DWORD)result )
  {
    v3 = *((_QWORD *)this + 4);
    v4 = __ROR2__(*((_WORD *)this + 26) - 2, 8);
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v3 + 32i64))(v3, 2i64, &v4);
    if ( !(_DWORD)result )
      return CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateKeyShareEntry((__int64)this);
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (000000018006782C) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::GenerateNamedGroupExtension(CTls13ServerHandshake *this)
{
  __int64 result; // rax
  __int64 v3; // rcx
  __int16 v4; // [rsp+30h] [rbp+8h] BYREF

  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
             (__int64)this,
             51,
             *((_WORD *)this + 26));
  if ( !(_DWORD)result )
  {
    v3 = *((_QWORD *)this + 4);
    v4 = __ROR2__(*((_WORD *)this + 22), 8);
    return (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v3 + 32i64))(v3, 2i64, &v4);
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180067888) ----------------------------------------------------
unsigned int __fastcall CTls13ServerHandshake::GenerateNewSessionTicket(CTls13ServerHandshake *this)
{
  unsigned int result; // eax
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rdi
  __int128 *v6; // rsi
  unsigned __int16 v7; // di
  __int64 v8; // rsi
  __int64 v9; // rcx
  void *v10; // rcx
  __int64 v11; // rcx
  char v12[4]; // [rsp+20h] [rbp-50h] BYREF
  __int16 v13; // [rsp+24h] [rbp-4Ch] BYREF
  __int16 v14[2]; // [rsp+28h] [rbp-48h] BYREF
  UCHAR pbBuffer[4]; // [rsp+2Ch] [rbp-44h] BYREF
  __int64 v16; // [rsp+30h] [rbp-40h] BYREF
  unsigned __int32 v17; // [rsp+38h] [rbp-38h] BYREF
  __int128 v18[2]; // [rsp+40h] [rbp-30h] BYREF

  result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateHandshakeHeader(
             (__int64)this,
             4,
             *((_WORD *)this + 86));
  if ( !result )
  {
    v3 = *((_QWORD *)this + 4);
    v17 = _byteswap_ulong(CSslGlobals::m_dwServerLifespan / 0x3E8);
    result = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int32 *))(*(_QWORD *)v3 + 32i64))(v3, 4i64, &v17);
    if ( !result )
    {
      *(_DWORD *)pbBuffer = 0;
      result = GenerateRandomBits(pbBuffer, 4u);
      if ( !result )
      {
        result = (*(__int64 (__fastcall **)(_QWORD, __int64, UCHAR *))(**((_QWORD **)this + 4) + 32i64))(
                   *((_QWORD *)this + 4),
                   4i64,
                   pbBuffer);
        if ( !result )
        {
          v4 = *((_QWORD *)this + 1);
          v16 = 0i64;
          (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v4 + 232i64))(v4, &v16);
          if ( v16 )
          {
            RtlAcquireResourceShared((PRTL_RESOURCE)(v16 + 72), 1u);
            v5 = *(_QWORD *)(v16 + 200);
            v12[0] = *(_BYTE *)(v16 + 208);
            RtlReleaseResource((PRTL_RESOURCE)(v16 + 72));
            result = (*(__int64 (__fastcall **)(_QWORD, __int64, char *))(**((_QWORD **)this + 4) + 32i64))(
                       *((_QWORD *)this + 4),
                       1i64,
                       v12);
            if ( !result )
            {
              result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(**((_QWORD **)this + 4) + 32i64))(
                         *((_QWORD *)this + 4),
                         (unsigned __int8)v12[0],
                         v5);
              if ( !result )
              {
                v6 = (__int128 *)*((_QWORD *)this + 24);
                v7 = *((_WORD *)this + 100);
                memset(v18, 0, sizeof(v18));
                if ( !v6 )
                {
                  v7 = 32;
                  RtlAcquireResourceShared((PRTL_RESOURCE)(v16 + 72), 1u);
                  v8 = v16;
                  if ( *(unsigned __int16 *)(v16 + 238) <= 0x20u )
                  {
                    v7 = *(_WORD *)(v16 + 238);
                    memcpy_0(v18, (const void *)(v16 + 240), v7);
                  }
                  RtlReleaseResource((PRTL_RESOURCE)(v8 + 72));
                  v6 = v18;
                }
                v9 = *((_QWORD *)this + 4);
                v13 = __ROR2__(v7, 8);
                result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v9 + 32i64))(
                           v9,
                           2i64,
                           &v13);
                if ( !result )
                {
                  result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int128 *))(**((_QWORD **)this + 4) + 32i64))(
                             *((_QWORD *)this + 4),
                             v7,
                             v6);
                  if ( !result )
                  {
                    v10 = (void *)*((_QWORD *)this + 24);
                    if ( v10 )
                    {
                      LocalFree(v10);
                      *((_QWORD *)this + 24) = 0i64;
                      *((_WORD *)this + 100) = 0;
                    }
                    v11 = *((_QWORD *)this + 4);
                    v14[0] = 0;
                    result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v11 + 32i64))(
                               v11,
                               2i64,
                               v14);
                    if ( !result )
                      return (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 4) + 40i64))(*((_QWORD *)this + 4));
                  }
                }
              }
            }
          }
          else
          {
            return 1359;
          }
        }
      }
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180067888: using guessed type char var_50[4];
// 180067888: using guessed type __int16 var_48[2];

//----- (0000000180067B70) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::GeneratePskExtension(CTls13ClientHandshake *this)
{
  __int16 v1; // r8
  unsigned int ExtensionHeader; // ebx
  __int64 v5; // rcx
  int v6; // esi
  __int64 v7; // r14
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v10; // rbx
  int ElapsedTime; // eax
  __int64 v12; // rcx
  __int16 v13; // [rsp+50h] [rbp+30h] BYREF
  unsigned __int32 v14; // [rsp+58h] [rbp+38h] BYREF
  __int64 v15; // [rsp+60h] [rbp+40h] BYREF

  v1 = *((_WORD *)this + 78);
  if ( !v1 )
    return 0i64;
  v15 = 0i64;
  ExtensionHeader = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader((__int64)this, 41, v1);
  if ( ExtensionHeader )
    goto LABEL_13;
  (*(void (__fastcall **)(_QWORD, __int64 *))(**((_QWORD **)this + 1) + 224i64))(*((_QWORD *)this + 1), &v15);
  if ( v15 )
  {
    RtlAcquireResourceShared((PRTL_RESOURCE)(v15 + 72), 1u);
    v5 = v15;
    v6 = *(_DWORD *)(v15 + 432);
    v7 = *(_QWORD *)(v15 + 424);
    if ( (unsigned int)(v6 - 1) > 0xFFF8 || !v7 )
    {
      ExtensionHeader = -2146893052;
LABEL_14:
      if ( v5 )
        RtlReleaseResource((PRTL_RESOURCE)(v5 + 72));
      return ExtensionHeader;
    }
    v8 = *((_QWORD *)this + 4);
    v13 = __ROR2__(v6 + 6, 8);
    ExtensionHeader = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v8 + 32i64))(v8, 2i64, &v13);
    if ( !ExtensionHeader )
    {
      v9 = *((_QWORD *)this + 4);
      v13 = __ROR2__(v6, 8);
      ExtensionHeader = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v9 + 32i64))(v9, 2i64, &v13);
      if ( !ExtensionHeader )
      {
        ExtensionHeader = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(**((_QWORD **)this + 4) + 32i64))(
                            *((_QWORD *)this + 4),
                            (unsigned __int16)v6,
                            v7);
        if ( !ExtensionHeader )
        {
          v10 = v15;
          ElapsedTime = GetElapsedTime(*(_DWORD *)(v15 + 416));
          v12 = *((_QWORD *)this + 4);
          v14 = _byteswap_ulong(ElapsedTime + *(_DWORD *)(v10 + 212));
          ExtensionHeader = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int32 *))(*(_QWORD *)v12 + 32i64))(
                              v12,
                              4i64,
                              &v14);
          if ( !ExtensionHeader )
          {
            RtlReleaseResource((PRTL_RESOURCE)(v15 + 72));
            v15 = 0i64;
            ExtensionHeader = CTls13ClientHandshake::GenerateBinderEntry(this);
          }
        }
      }
    }
LABEL_13:
    v5 = v15;
    goto LABEL_14;
  }
  return (unsigned int)-2146893052;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180067D60) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::GeneratePskExtension(CTls13ServerHandshake *this)
{
  __int16 v1; // r8
  __int64 result; // rax
  __int64 v4; // rcx
  __int16 v5; // [rsp+30h] [rbp+8h] BYREF

  v1 = *((_WORD *)this + 78);
  if ( !v1 )
    return 0i64;
  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader((__int64)this, 41, v1);
  if ( !(_DWORD)result )
  {
    v4 = *((_QWORD *)this + 4);
    v5 = __ROR2__(*((_WORD *)this + 94), 8);
    return (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v4 + 32i64))(v4, 2i64, &v5);
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180067DD4) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::GeneratePskKeyExchangeModesExtension(CTls13ClientHandshake *this)
{
  __int64 result; // rax
  __int64 v3; // rcx
  __int64 v4; // rcx
  char v5; // [rsp+30h] [rbp+8h] BYREF
  char v6; // [rsp+38h] [rbp+10h] BYREF

  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
             (__int64)this,
             45,
             *((_WORD *)this + 83));
  if ( !(_DWORD)result )
  {
    v3 = *((_QWORD *)this + 4);
    v5 = 1;
    result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v3 + 32i64))(v3, 1i64, &v5);
    if ( !(_DWORD)result )
    {
      v4 = *((_QWORD *)this + 4);
      v6 = 1;
      result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v4 + 32i64))(v4, 1i64, &v6);
      if ( !(_DWORD)result )
      {
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 45);
        return 0i64;
      }
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180067E74) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::GenerateRenegotiationInfoExtension(CTls13ClientHandshake *this)
{
  __int64 result; // rax
  __int64 v3; // rcx
  char v4; // [rsp+38h] [rbp+10h] BYREF

  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader((__int64)this, 65281, 1);
  if ( !(_DWORD)result )
  {
    v3 = *((_QWORD *)this + 4);
    v4 = 0;
    return (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v3 + 32i64))(v3, 1i64, &v4);
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180067EC8) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::GenerateSelectedALPNExtension(CTls13ServerHandshake *this)
{
  _DWORD *v2; // rax
  _DWORD *v3; // rdi
  __int64 result; // rax
  __int64 v5; // rcx
  unsigned __int16 v6; // si
  unsigned __int8 v7; // [rsp+40h] [rbp+8h] BYREF
  __int16 v8; // [rsp+48h] [rbp+10h] BYREF

  if ( !*((_WORD *)this + 83) )
    return 0i64;
  v2 = (_DWORD *)(*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 1) + 88i64))(*((_QWORD *)this + 1));
  v3 = v2;
  if ( !v2 || *v2 != 1 || v2[1] != 2 )
    return 0i64;
  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
             (__int64)this,
             16,
             *((_WORD *)this + 83));
  if ( !(_DWORD)result )
  {
    v5 = *((_QWORD *)this + 4);
    v6 = *((_WORD *)this + 83) - 2;
    v8 = __ROR2__(v6, 8);
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v5 + 32i64))(v5, 2i64, &v8);
    if ( !(_DWORD)result )
    {
      v7 = *((_BYTE *)v3 + 8);
      if ( v6 != v7 + 1i64 )
        return 87i64;
      result = (*(__int64 (__fastcall **)(_QWORD, __int64, unsigned __int8 *))(**((_QWORD **)this + 4) + 32i64))(
                 *((_QWORD *)this + 4),
                 1i64,
                 &v7);
      if ( !(_DWORD)result )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 33i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids, v6);
        result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(**((_QWORD **)this + 4) + 32i64))(
                   *((_QWORD *)this + 4),
                   v7,
                   (__int64)v3 + 9);
        if ( !(_DWORD)result )
        {
          CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 16);
          return 0i64;
        }
      }
    }
  }
  return result;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (0000000180068058) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::GenerateServerHelloExtensions(CTls13ServerHandshake *this)
{
  __int16 v1; // ax
  __int64 v3; // rcx
  __int64 result; // rax
  __int16 v5; // [rsp+30h] [rbp+8h] BYREF

  v1 = *((_WORD *)this + 20);
  v3 = *((_QWORD *)this + 4);
  v5 = __ROR2__(v1, 8);
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v3 + 32i64))(v3, 2i64, &v5);
  if ( !(_DWORD)result )
  {
    result = CTls13ServerHandshake::GenerateSupportedVersionsExtension(this);
    if ( !(_DWORD)result )
    {
      result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
                 (__int64)this,
                 51,
                 *((_WORD *)this + 26));
      if ( !(_DWORD)result )
      {
        result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateKeyShareEntry((__int64)this);
        if ( !(_DWORD)result )
        {
          result = CTls13ServerHandshake::GeneratePskExtension(this);
          if ( !(_DWORD)result )
            return CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateGenericExtensions((__int64)this, 2);
        }
      }
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (00000001800680E8) ----------------------------------------------------
unsigned int __fastcall CTls13ServerHandshake::GenerateServerHelloOrHRR(
        CTls13ServerHandshake *this,
        char a2,
        unsigned __int8 *a3)
{
  UCHAR *v3; // rsi
  unsigned int result; // eax
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 v9; // rax
  int v10; // eax
  __int64 v11; // rcx
  __int64 v12; // rcx
  __int16 v13[2]; // [rsp+20h] [rbp-18h] BYREF
  __int16 v14[10]; // [rsp+24h] [rbp-14h] BYREF
  unsigned __int8 v15; // [rsp+50h] [rbp+18h] BYREF
  char v16; // [rsp+58h] [rbp+20h] BYREF

  v3 = a3;
  if ( !a3 && a2 )
    return 87;
  result = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateHandshakeHeader(
             (__int64)this,
             2,
             *((_WORD *)this + 80));
  if ( !result )
  {
    v7 = *((_QWORD *)this + 4);
    v13[0] = 771;
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v7 + 32i64))(v7, 2i64, v13);
    if ( !result && (!a2 || (result = GenerateRandomBits(v3, 0x20u)) == 0) )
    {
      if ( !a2 )
        v3 = (UCHAR *)&unk_1800858B0;
      result = (*(__int64 (__fastcall **)(_QWORD, __int64, UCHAR *))(**((_QWORD **)this + 4) + 32i64))(
                 *((_QWORD *)this + 4),
                 32i64,
                 v3);
      if ( !result )
      {
        v15 = *(_BYTE *)(*((_QWORD *)this + 1) + 1281i64);
        result = (*(__int64 (__fastcall **)(_QWORD, __int64, unsigned __int8 *))(**((_QWORD **)this + 4) + 32i64))(
                   *((_QWORD *)this + 4),
                   1i64,
                   &v15);
        if ( !result
          && (!v15
           || (result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(**((_QWORD **)this + 4) + 32i64))(
                          *((_QWORD *)this + 4),
                          v15,
                          *((_QWORD *)this + 1) + 1249i64)) == 0) )
        {
          v8 = *((_QWORD *)this + 1);
          if ( (*(_BYTE *)(v8 + 32) & 1) != 0 && (v9 = *(_QWORD *)(v8 + 8)) != 0 )
            v10 = *(_DWORD *)(v9 + 28);
          else
            LOWORD(v10) = 0;
          v11 = *((_QWORD *)this + 4);
          v14[0] = __ROR2__(v10, 8);
          result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v11 + 32i64))(v11, 2i64, v14);
          if ( !result )
          {
            v12 = *((_QWORD *)this + 4);
            v16 = 0;
            result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v12 + 32i64))(v12, 1i64, &v16);
            if ( !result )
            {
              if ( a2 )
                result = CTls13ServerHandshake::GenerateServerHelloExtensions(this);
              else
                result = CTls13ServerHandshake::GenerateHRRExtensions(this);
              if ( !result )
                return (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 4) + 40i64))(*((_QWORD *)this + 4));
            }
          }
        }
      }
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 1800680E8: using guessed type __int16 var_18[2];
// 1800680E8: using guessed type __int16 var_14[10];

//----- (00000001800682E8) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::GenerateServerNameExtension(CTls13ClientHandshake *this)
{
  __int64 v2; // rdi
  __int64 result; // rax
  __int64 v4; // rcx
  __int16 v5; // si
  __int64 v6; // rcx
  __int64 v7; // rcx
  unsigned __int16 v8; // si
  char v9; // [rsp+40h] [rbp+8h] BYREF
  __int16 v10; // [rsp+48h] [rbp+10h] BYREF
  __int16 v11; // [rsp+50h] [rbp+18h] BYREF

  v2 = *(_QWORD *)(*((_QWORD *)this + 2) + 40i64);
  if ( !v2 )
    return 0i64;
  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
             (__int64)this,
             0,
             *((_WORD *)this + 81));
  if ( !(_DWORD)result )
  {
    v4 = *((_QWORD *)this + 4);
    v5 = *((_WORD *)this + 81) - 2;
    v10 = __ROR2__(v5, 8);
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v4 + 32i64))(v4, 2i64, &v10);
    if ( !(_DWORD)result )
    {
      v6 = *((_QWORD *)this + 4);
      v9 = 0;
      result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v6 + 32i64))(v6, 1i64, &v9);
      if ( !(_DWORD)result )
      {
        v7 = *((_QWORD *)this + 4);
        v8 = v5 - 3;
        v11 = __ROR2__(v8, 8);
        result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v7 + 32i64))(v7, 2i64, &v11);
        if ( !(_DWORD)result )
        {
          result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(**((_QWORD **)this + 4) + 32i64))(
                     *((_QWORD *)this + 4),
                     v8,
                     v2);
          if ( !(_DWORD)result )
          {
            CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 0);
            return 0i64;
          }
        }
      }
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180068414) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateSignatureAlgorithmsExtension(
        __int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rcx
  unsigned __int16 v4; // di
  __int16 v5; // [rsp+30h] [rbp+8h] BYREF

  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(a1, 13, *(_WORD *)(a1 + 124));
  if ( !(_DWORD)result )
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = *(_WORD *)(a1 + 124) - 2;
    v5 = __ROR2__(v4, 8);
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v3 + 32i64))(v3, 2i64, &v5);
    if ( !(_DWORD)result )
      return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 32) + 32i64))(
               *(_QWORD *)(a1 + 32),
               v4,
               *(_QWORD *)(a1 + 128));
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (00000001800684B0) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::GenerateStatusRequestExtension(CTls13ClientHandshake *this)
{
  __int16 v1; // r8
  __int64 result; // rax
  __int64 v4; // rcx
  __int64 v5; // rcx
  char v6; // [rsp+30h] [rbp+8h] BYREF
  int v7; // [rsp+38h] [rbp+10h] BYREF

  v1 = *((_WORD *)this + 76);
  if ( !v1 )
    return 0i64;
  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader((__int64)this, 5, v1);
  if ( !(_DWORD)result )
  {
    v4 = *((_QWORD *)this + 4);
    v6 = 1;
    result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v4 + 32i64))(v4, 1i64, &v6);
    if ( !(_DWORD)result )
    {
      v5 = *((_QWORD *)this + 4);
      v7 = 0;
      return (*(__int64 (__fastcall **)(__int64, __int64, int *))(*(_QWORD *)v5 + 32i64))(v5, 4i64, &v7);
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180068550) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::GenerateStatusRequestExtension(CTls13ServerHandshake *this)
{
  __int64 v2; // rdi
  __int64 result; // rax
  int v4; // esi
  __int64 v5; // rcx
  char v6; // [rsp+30h] [rbp+8h] BYREF
  char v7; // [rsp+31h] [rbp+9h]
  char v8; // [rsp+32h] [rbp+Ah]
  char v9; // [rsp+33h] [rbp+Bh]

  v2 = *(_QWORD *)(*((_QWORD *)this + 1) + 1512i64);
  if ( !v2 )
    return 0i64;
  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
             (__int64)this,
             5,
             *((_WORD *)this + 76));
  if ( !(_DWORD)result )
  {
    v4 = *(_DWORD *)(v2 + 16);
    v5 = *((_QWORD *)this + 4);
    v7 = BYTE2(v4);
    v8 = BYTE1(v4);
    v6 = 1;
    v9 = v4;
    result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v5 + 32i64))(v5, 4i64, &v6);
    if ( !(_DWORD)result )
      return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 4) + 32i64))(
               *((_QWORD *)this + 4),
               (unsigned __int16)v4,
               *(_QWORD *)(v2 + 8));
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180068610) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::GenerateSupportedGroupsExtension(CTls13ClientHandshake *this)
{
  __int64 result; // rax
  __int64 v3; // rcx
  __int64 v4; // rax
  _WORD *v5; // rdi
  _WORD *v6; // rsi
  __int64 v7; // rcx
  __int16 v8; // [rsp+40h] [rbp+8h] BYREF
  __int16 v9; // [rsp+48h] [rbp+10h] BYREF

  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
             (__int64)this,
             10,
             *((_WORD *)this + 21));
  if ( !(_DWORD)result )
  {
    v3 = *((_QWORD *)this + 4);
    v8 = __ROR2__(*((_WORD *)this + 21) - 2, 8);
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v3 + 32i64))(v3, 2i64, &v8);
    if ( !(_DWORD)result )
    {
      v4 = *((_QWORD *)this + 1);
      v5 = *(_WORD **)(v4 + 912);
      v6 = v5;
      if ( v5 >= &v5[*(unsigned __int16 *)(v4 + 920)] )
      {
        return 0i64;
      }
      else
      {
        while ( 1 )
        {
          v7 = *((_QWORD *)this + 4);
          v9 = __ROR2__(*v6, 8);
          result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v7 + 32i64))(v7, 2i64, &v9);
          if ( (_DWORD)result )
            break;
          if ( ++v6 >= &v5[*(unsigned __int16 *)(*((_QWORD *)this + 1) + 920i64)] )
            return 0i64;
        }
      }
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (00000001800686F0) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::GenerateSupportedVersionsExtension(CTls13ClientHandshake *this)
{
  __int64 result; // rax
  __int64 v3; // rcx
  _WORD *v4; // rbx
  __int64 v5; // rcx
  char v6; // [rsp+30h] [rbp+8h] BYREF
  __int16 v7; // [rsp+38h] [rbp+10h] BYREF

  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
             (__int64)this,
             43,
             *((unsigned __int8 *)this + 54));
  if ( !(_DWORD)result )
  {
    v3 = *((_QWORD *)this + 4);
    v6 = *((_BYTE *)this + 54) - 1;
    result = (*(__int64 (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)v3 + 32i64))(v3, 1i64, &v6);
    if ( !(_DWORD)result )
    {
      v4 = &TlsVersions;
      while ( 1 )
      {
        if ( (*(_DWORD *)(*((_QWORD *)this + 1) + 64i64) & *(_DWORD *)v4) != 0 )
        {
          v5 = *((_QWORD *)this + 4);
          v7 = __ROR2__(v4[2], 8);
          result = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v5 + 32i64))(v5, 2i64, &v7);
          if ( (_DWORD)result )
            break;
        }
        v4 += 4;
        if ( v4 >= (_WORD *)WPP_922678f99ae534148d3bb024010f1556_Traceguids )
          return 0i64;
      }
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (00000001800687B4) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::GenerateSupportedVersionsExtension(CTls13ServerHandshake *this)
{
  __int64 result; // rax
  __int64 v3; // rcx
  __int16 v4; // [rsp+30h] [rbp+8h] BYREF

  result = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateExtensionHeader(
             (__int64)this,
             43,
             *((unsigned __int8 *)this + 54));
  if ( !(_DWORD)result )
  {
    v3 = *((_QWORD *)this + 4);
    v4 = 1027;
    return (*(__int64 (__fastcall **)(__int64, __int64, __int16 *))(*(_QWORD *)v3 + 32i64))(v3, 2i64, &v4);
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (000000018006880C) ----------------------------------------------------
unsigned __int64 __fastcall CTls13Context::GetFinishedMessageKey(CTls13Context *this, char a2)
{
  if ( *((_BYTE *)this + 233) )
    return *((_QWORD *)this + 10);
  if ( a2 )
    return *((_QWORD *)this + 7);
  return *((_QWORD *)this + 8);
}

//----- (0000000180068834) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ParseCertData(
        __int64 a1,
        const BYTE *a2,
        DWORD a3,
        int a4,
        CTlsSignatureSuiteList *a5,
        __int64 a6)
{
  PCCERT_CONTEXT CertificateContext; // rax
  const CERT_CONTEXT *v9; // rdi
  __int64 v10; // rcx
  struct _CRYPTOAPI_BLOB *pCertInfo; // rdx
  unsigned int v12; // esi
  unsigned __int8 v13; // r9
  int v14; // edx
  int PublicKeyFromCert; // eax
  __int64 v16; // rcx
  struct _PUBLICKEY *v17; // rbx
  __int64 v18; // r14
  unsigned int v19; // edx
  bool v20; // r12
  struct CCipherSuiteInfo *v21; // r15
  struct _SecPkgContext_ApplicationProtocol *v22; // rax
  unsigned int v23; // eax
  unsigned int v24; // r14d
  __int64 v25; // rax
  struct _PUBLICKEY *v27; // [rsp+78h] [rbp+10h] BYREF

  if ( !a2 || !a3 )
  {
    v10 = *(_QWORD *)(a1 + 8);
    goto LABEL_35;
  }
  CertificateContext = CertCreateCertificateContext(1u, a2, a3);
  v9 = CertificateContext;
  if ( CertificateContext )
  {
    pCertInfo = (struct _CRYPTOAPI_BLOB *)CertificateContext->pCertInfo;
    v12 = 0;
    v27 = 0i64;
    if ( pCertInfo )
    {
      if ( a4 && CertCompareCertificateName(CertificateContext->dwCertEncodingType, pCertInfo + 3, pCertInfo + 5) )
        goto LABEL_32;
      if ( CTlsSignatureSuiteList::AddCertificateSignatureSuite(a5, v9) )
      {
        if ( !a4 )
        {
          PublicKeyFromCert = GetPublicKeyFromCert(v9, &v27, 0i64);
          v16 = *(_QWORD *)(a1 + 8);
          v12 = PublicKeyFromCert;
          if ( PublicKeyFromCert )
          {
            CSslContext::SetErrorAndFatalAlert(v16, 251, PublicKeyFromCert, 0x2Bu);
            v17 = v27;
          }
          else
          {
            v18 = *(_QWORD *)(v16 + 80);
            v17 = v27;
            if ( v18 )
            {
              v19 = *(_DWORD *)(v18 + 196);
              v20 = (*(_DWORD *)(v16 + 64) & 0x40051555) != 0;
              if ( v19
                && ((v21 = *(struct CCipherSuiteInfo **)(v16 + 8), (*(_DWORD *)(v16 + 64) & 0x40051555) == 0)
                  ? (v22 = 0i64)
                  : (struct _SecPkgContext_ApplicationProtocol *)(v22 = (struct _SecPkgContext_ApplicationProtocol *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v16 + 88i64))(v16),
                                                                  v19 = *(_DWORD *)(v18 + 196)),
                    v23 = IsRemoteCertificateBlacklisted(
                            *(struct _TLS_PARAMETERS **)(v18 + 200),
                            v19,
                            v9,
                            v17,
                            v22,
                            v21,
                            v20),
                    (v24 = v23) != 0) )
              {
                if ( v23 == -2146893007 )
                {
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                  {
                    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
                  }
                  CSslContext::SetErrorAndFatalAlert(*(_QWORD *)(a1 + 8), 251, -2146893007, 0x2Bu);
                }
                v12 = v24;
              }
              else
              {
                v25 = a6;
                *(_QWORD *)(a6 + 40) = v17;
                v17 = 0i64;
                *(_QWORD *)(v25 + 48) = v9;
                v9 = 0i64;
              }
            }
            else
            {
              v12 = -2146893052;
            }
          }
          if ( v17 )
            SPExternalFree(v17);
          if ( !v9 )
            return v12;
        }
        goto LABEL_32;
      }
      v13 = 43;
      v14 = 252;
    }
    else
    {
      v13 = 42;
      v14 = 250;
    }
    v12 = -2146893048;
    CSslContext::SetErrorAndFatalAlert(*(_QWORD *)(a1 + 8), v14, -2146893048, v13);
LABEL_32:
    CertFreeCertificateContext(v9);
    return v12;
  }
  v10 = *(_QWORD *)(a1 + 8);
LABEL_35:
  CSslContext::SetErrorAndFatalAlert(v10, 250, -2146893048, 0x2Au);
  return 2148074248i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (0000000180068A7C) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ParseCertificateMsg(
        __int64 a1,
        unsigned __int8 *a2,
        int a3)
{
  __int64 v6; // r15
  void *v8; // rcx
  void *v9; // rcx
  const CERT_CONTEXT *v10; // rcx
  __int64 v11; // r12
  unsigned int v12; // esi
  int v13; // r8d
  unsigned __int8 v14; // r9
  int v15; // edx
  __int64 v16; // rcx
  unsigned __int8 *v17; // r14
  unsigned int v18; // ebp
  __int64 v19; // rax
  const void *v20; // rdx
  unsigned int v21; // ebp
  int v22; // ecx
  unsigned __int8 *v23; // r14
  __int64 v24; // rax
  int v25; // edx
  unsigned int v26; // r12d
  unsigned __int8 *v27; // rbx
  int v28; // r9d
  DWORD v29; // r12d
  DWORD v30; // r13d
  const BYTE *v31; // rbx
  unsigned int v32; // r12d
  const BYTE *v33; // rbx
  __int16 v34; // ax
  unsigned int v35; // r12d
  __int16 v36; // r13
  unsigned __int8 *v37; // rbx
  unsigned __int16 v38; // r13
  unsigned int v39; // eax
  __int64 v40; // r10
  unsigned int v41; // r9d
  __int64 v42; // r10
  _DWORD *v43; // rax
  _DWORD *v44; // r12
  unsigned int *i; // r13
  unsigned int v46; // edi
  char *v47; // r14
  char *v48; // r13
  unsigned __int16 *v49; // r14
  __int64 v50; // rax
  int v51; // [rsp+30h] [rbp-78h]
  int v52; // [rsp+34h] [rbp-74h]
  __int16 v53; // [rsp+40h] [rbp-68h] BYREF
  __int128 v54; // [rsp+42h] [rbp-66h]
  __int128 v55; // [rsp+52h] [rbp-56h]
  __int16 v56; // [rsp+62h] [rbp-46h]

  if ( a2 && a3 )
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 88i64);
    if ( !v6 )
      return 1359i64;
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(v6 + 72), 1u);
    v8 = *(void **)(v6 + 24);
    if ( v8 )
    {
      SPExternalFree(v8);
      *(_DWORD *)(v6 + 32) = 0;
      *(_QWORD *)(v6 + 24) = 0i64;
    }
    v9 = *(void **)(v6 + 40);
    if ( v9 )
    {
      SPExternalFree(v9);
      *(_QWORD *)(v6 + 40) = 0i64;
    }
    v10 = *(const CERT_CONTEXT **)(v6 + 48);
    if ( v10 )
    {
      CertFreeCertificateContext(v10);
      *(_QWORD *)(v6 + 48) = 0i64;
    }
    v11 = *a2;
    v53 = 0;
    v12 = 0;
    v56 = 0;
    v54 = 0i64;
    v55 = 0i64;
    if ( !a3 )
      goto LABEL_12;
    v17 = a2 + 1;
    v18 = a3 - 1;
    if ( (_BYTE)v11 )
    {
      v16 = *(_QWORD *)(a1 + 8);
      if ( v18 < (unsigned int)v11
        || (*(_DWORD *)(v16 + 64) & 0x40051555) == 0
        || *(_DWORD *)(v16 + 68) != 78
        || (v19 = *(unsigned __int8 *)(v16 + 1600), (_BYTE)v11 != (_BYTE)v19) )
      {
        v13 = -2146893048;
        v14 = 50;
        v12 = -2146893048;
        v15 = 250;
LABEL_14:
        CSslContext::SetErrorAndFatalAlert(v16, v15, v13, v14);
LABEL_55:
        RtlReleaseResource((PRTL_RESOURCE)(v6 + 72));
        return v12;
      }
      v20 = *(const void **)(v16 + 1592);
      if ( !v20 )
      {
        v12 = -2146893052;
        goto LABEL_55;
      }
      if ( RtlCompareMemory(v17, v20, *(unsigned __int8 *)(v16 + 1600)) != v19 )
      {
LABEL_12:
        v13 = -2146893048;
        v14 = 50;
        v12 = -2146893048;
        v15 = 250;
LABEL_13:
        v16 = *(_QWORD *)(a1 + 8);
        goto LABEL_14;
      }
      v17 += v11;
      v18 -= v11;
    }
    if ( v18 >= 3 )
    {
      v21 = v18 - 3;
      v22 = v17[2] + (*v17 << 16) + (v17[1] << 8);
      v23 = v17 + 3;
      if ( v21 == v22 )
      {
        if ( v22 )
        {
          v51 = 0;
          v25 = 0;
          v52 = 0;
          v26 = v21;
          v27 = v23;
          v28 = 0;
          if ( v21 )
          {
            while ( 1 )
            {
              if ( v26 < 3 )
                goto LABEL_12;
              v29 = v26 - 3;
              v30 = v27[2] + (*v27 << 16) + (v27[1] << 8);
              v31 = v27 + 3;
              if ( v29 < v30 || (unsigned int)~v28 < (unsigned __int64)v30 + 4 )
                goto LABEL_12;
              v12 = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ParseCertData(
                      a1,
                      v31,
                      v30,
                      v25,
                      (CTlsSignatureSuiteList *)&v53,
                      v6);
              if ( v12 )
                goto LABEL_55;
              ++v52;
              v32 = v29 - v30;
              v33 = &v31[v30];
              v51 += v30 + 4;
              if ( v32 < 2 )
                goto LABEL_12;
              v34 = v33[1];
              v35 = v32 - 2;
              v36 = *v33;
              v37 = (unsigned __int8 *)(v33 + 2);
              v38 = v34 | (v36 << 8);
              if ( v35 < v38 )
                break;
              v39 = CTlsExt::ParseTlsExtensions(*(_QWORD *)(a1 + 16), v37, v38, 11);
              v12 = v39;
              if ( v39 )
              {
                v14 = 110;
                v13 = v39;
LABEL_47:
                v15 = 253;
                goto LABEL_13;
              }
              v28 = v51;
              v25 = v52;
              v27 = &v37[v38];
              v26 = v35 - v38;
              if ( !v26 )
                goto LABEL_43;
            }
            v13 = -2146893048;
            v14 = 50;
            v12 = -2146893048;
            goto LABEL_47;
          }
LABEL_43:
          v40 = *(_QWORD *)(a1 + 8);
          if ( v40 == -474 )
          {
            v12 = 1359;
            goto LABEL_55;
          }
          if ( CTlsSignatureSuiteList::IsSupportedSignatureSuiteList(
                 (CTlsSignatureSuiteList *)(v40 + 474),
                 (struct CTlsSignatureSuiteList *)&v53) )
          {
            v43 = SPExternalAlloc(v41);
            v44 = v43;
            if ( v43 )
            {
              for ( i = v43; v21; v21 += -5 - v50 - v46 )
              {
                v46 = v23[2] + (*v23 << 16) + (v23[1] << 8);
                v47 = (char *)(v23 + 3);
                *i = v46;
                v48 = (char *)(i + 1);
                memcpy_0(v48, v47, v46);
                v49 = (unsigned __int16 *)&v47[v46];
                i = (unsigned int *)&v48[v46];
                v50 = _byteswap_ushort(*v49);
                v23 = (unsigned __int8 *)v49 + v50 + 2;
              }
              *(_DWORD *)(v6 + 32) = v51;
              *(_QWORD *)(v6 + 24) = v44;
            }
            else
            {
              v12 = 14;
            }
            goto LABEL_55;
          }
          v13 = -2146893048;
          v14 = 40;
          v12 = -2146893048;
          v15 = 252;
          v16 = v42;
        }
        else
        {
          v24 = *(_QWORD *)(a1 + 8);
          if ( (*(_DWORD *)(v24 + 64) & 0x800A2AAA) == 0 )
          {
            *(_BYTE *)(v24 + 552) = 1;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 17i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
            }
            v12 = 0;
            goto LABEL_55;
          }
          v13 = -2146893048;
          v14 = 42;
          v12 = -2146893048;
          v15 = 250;
          v16 = *(_QWORD *)(a1 + 8);
        }
        goto LABEL_14;
      }
    }
    goto LABEL_12;
  }
  return 87i64;
}
// 180068DE9: variable 'v42' is possibly undefined
// 180068DF4: variable 'v41' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (0000000180068EC4) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ParseCertificateMsg(
        __int64 a1,
        unsigned __int8 *a2,
        int a3)
{
  __int64 v6; // r15
  void *v8; // rcx
  void *v9; // rcx
  const CERT_CONTEXT *v10; // rcx
  __int64 v11; // r12
  unsigned int v12; // esi
  int v13; // r8d
  unsigned __int8 v14; // r9
  int v15; // edx
  __int64 v16; // rcx
  unsigned __int8 *v17; // r14
  unsigned int v18; // ebp
  __int64 v19; // rax
  const void *v20; // rdx
  unsigned int v21; // ebp
  int v22; // ecx
  unsigned __int8 *v23; // r14
  __int64 v24; // rax
  int v25; // edx
  unsigned int v26; // r12d
  unsigned __int8 *v27; // rbx
  int v28; // r9d
  DWORD v29; // r12d
  DWORD v30; // r13d
  const BYTE *v31; // rbx
  unsigned int v32; // r12d
  const BYTE *v33; // rbx
  __int16 v34; // ax
  unsigned int v35; // r12d
  __int16 v36; // r13
  unsigned __int8 *v37; // rbx
  unsigned __int16 v38; // r13
  unsigned int v39; // eax
  __int64 v40; // r10
  unsigned int v41; // r9d
  __int64 v42; // r10
  _DWORD *v43; // rax
  _DWORD *v44; // r12
  unsigned int *i; // r13
  unsigned int v46; // edi
  char *v47; // r14
  char *v48; // r13
  unsigned __int16 *v49; // r14
  __int64 v50; // rax
  int v51; // [rsp+30h] [rbp-78h]
  int v52; // [rsp+34h] [rbp-74h]
  __int16 v53; // [rsp+40h] [rbp-68h] BYREF
  __int128 v54; // [rsp+42h] [rbp-66h]
  __int128 v55; // [rsp+52h] [rbp-56h]
  __int16 v56; // [rsp+62h] [rbp-46h]

  if ( a2 && a3 )
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 88i64);
    if ( !v6 )
      return 1359i64;
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(v6 + 72), 1u);
    v8 = *(void **)(v6 + 24);
    if ( v8 )
    {
      SPExternalFree(v8);
      *(_DWORD *)(v6 + 32) = 0;
      *(_QWORD *)(v6 + 24) = 0i64;
    }
    v9 = *(void **)(v6 + 40);
    if ( v9 )
    {
      SPExternalFree(v9);
      *(_QWORD *)(v6 + 40) = 0i64;
    }
    v10 = *(const CERT_CONTEXT **)(v6 + 48);
    if ( v10 )
    {
      CertFreeCertificateContext(v10);
      *(_QWORD *)(v6 + 48) = 0i64;
    }
    v11 = *a2;
    v53 = 0;
    v12 = 0;
    v56 = 0;
    v54 = 0i64;
    v55 = 0i64;
    if ( !a3 )
      goto LABEL_12;
    v17 = a2 + 1;
    v18 = a3 - 1;
    if ( (_BYTE)v11 )
    {
      v16 = *(_QWORD *)(a1 + 8);
      if ( v18 < (unsigned int)v11
        || (*(_DWORD *)(v16 + 64) & 0x40051555) == 0
        || *(_DWORD *)(v16 + 68) != 78
        || (v19 = *(unsigned __int8 *)(v16 + 1232), (_BYTE)v11 != (_BYTE)v19) )
      {
        v13 = -2146893048;
        v14 = 50;
        v12 = -2146893048;
        v15 = 250;
LABEL_14:
        CSslContext::SetErrorAndFatalAlert(v16, v15, v13, v14);
LABEL_55:
        RtlReleaseResource((PRTL_RESOURCE)(v6 + 72));
        return v12;
      }
      v20 = *(const void **)(v16 + 1224);
      if ( !v20 )
      {
        v12 = -2146893052;
        goto LABEL_55;
      }
      if ( RtlCompareMemory(v17, v20, *(unsigned __int8 *)(v16 + 1232)) != v19 )
      {
LABEL_12:
        v13 = -2146893048;
        v14 = 50;
        v12 = -2146893048;
        v15 = 250;
LABEL_13:
        v16 = *(_QWORD *)(a1 + 8);
        goto LABEL_14;
      }
      v17 += v11;
      v18 -= v11;
    }
    if ( v18 >= 3 )
    {
      v21 = v18 - 3;
      v22 = v17[2] + (*v17 << 16) + (v17[1] << 8);
      v23 = v17 + 3;
      if ( v21 == v22 )
      {
        if ( v22 )
        {
          v51 = 0;
          v25 = 0;
          v52 = 0;
          v26 = v21;
          v27 = v23;
          v28 = 0;
          if ( v21 )
          {
            while ( 1 )
            {
              if ( v26 < 3 )
                goto LABEL_12;
              v29 = v26 - 3;
              v30 = v27[2] + (*v27 << 16) + (v27[1] << 8);
              v31 = v27 + 3;
              if ( v29 < v30 || (unsigned int)~v28 < (unsigned __int64)v30 + 4 )
                goto LABEL_12;
              v12 = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ParseCertData(
                      a1,
                      v31,
                      v30,
                      v25,
                      (CTlsSignatureSuiteList *)&v53,
                      v6);
              if ( v12 )
                goto LABEL_55;
              ++v52;
              v32 = v29 - v30;
              v33 = &v31[v30];
              v51 += v30 + 4;
              if ( v32 < 2 )
                goto LABEL_12;
              v34 = v33[1];
              v35 = v32 - 2;
              v36 = *v33;
              v37 = (unsigned __int8 *)(v33 + 2);
              v38 = v34 | (v36 << 8);
              if ( v35 < v38 )
                break;
              v39 = CTlsExt::ParseTlsExtensions(*(_QWORD *)(a1 + 16), v37, v38, 11);
              v12 = v39;
              if ( v39 )
              {
                v14 = 110;
                v13 = v39;
LABEL_47:
                v15 = 253;
                goto LABEL_13;
              }
              v28 = v51;
              v25 = v52;
              v27 = &v37[v38];
              v26 = v35 - v38;
              if ( !v26 )
                goto LABEL_43;
            }
            v13 = -2146893048;
            v14 = 50;
            v12 = -2146893048;
            goto LABEL_47;
          }
LABEL_43:
          v40 = *(_QWORD *)(a1 + 8);
          if ( v40 == -474 )
          {
            v12 = 1359;
            goto LABEL_55;
          }
          if ( CTlsSignatureSuiteList::IsSupportedSignatureSuiteList(
                 (CTlsSignatureSuiteList *)(v40 + 474),
                 (struct CTlsSignatureSuiteList *)&v53) )
          {
            v43 = SPExternalAlloc(v41);
            v44 = v43;
            if ( v43 )
            {
              for ( i = v43; v21; v21 += -5 - v50 - v46 )
              {
                v46 = v23[2] + (*v23 << 16) + (v23[1] << 8);
                v47 = (char *)(v23 + 3);
                *i = v46;
                v48 = (char *)(i + 1);
                memcpy_0(v48, v47, v46);
                v49 = (unsigned __int16 *)&v47[v46];
                i = (unsigned int *)&v48[v46];
                v50 = _byteswap_ushort(*v49);
                v23 = (unsigned __int8 *)v49 + v50 + 2;
              }
              *(_DWORD *)(v6 + 32) = v51;
              *(_QWORD *)(v6 + 24) = v44;
            }
            else
            {
              v12 = 14;
            }
            goto LABEL_55;
          }
          v13 = -2146893048;
          v14 = 40;
          v12 = -2146893048;
          v15 = 252;
          v16 = v42;
        }
        else
        {
          v24 = *(_QWORD *)(a1 + 8);
          if ( (*(_DWORD *)(v24 + 64) & 0x800A2AAA) == 0 )
          {
            *(_BYTE *)(v24 + 552) = 1;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 17i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
            }
            v12 = 0;
            goto LABEL_55;
          }
          v13 = -2146893048;
          v14 = 42;
          v12 = -2146893048;
          v15 = 250;
          v16 = *(_QWORD *)(a1 + 8);
        }
        goto LABEL_14;
      }
    }
    goto LABEL_12;
  }
  return 87i64;
}
// 180069231: variable 'v42' is possibly undefined
// 18006923C: variable 'v41' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (000000018006930C) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::ParseCertificateRequest(
        CTls13ClientHandshake *this,
        unsigned __int8 *a2,
        int a3)
{
  __int64 v4; // rcx
  unsigned int v5; // ebx
  int v6; // edx
  unsigned __int8 v7; // r9
  __int64 result; // rax
  __int64 v9; // rbp
  unsigned __int8 *v10; // rdi
  unsigned int v11; // ebx
  unsigned int v12; // ebx
  unsigned __int16 v13; // cx
  unsigned int v14; // eax

  if ( !a2 || !a3 )
    return 87i64;
  v4 = *((_QWORD *)this + 1);
  v9 = *a2;
  v10 = a2 + 1;
  v11 = a3 - 1;
  if ( (_BYTE)v9 )
  {
    if ( *(_DWORD *)(v4 + 68) != 78 || v11 < (unsigned int)v9 )
      goto LABEL_4;
    result = CTls13ClientContext::SetCertificateRequestContext((CTls13ClientContext *)v4, v10, *a2);
    if ( (_DWORD)result )
      return result;
    v10 += v9;
    v11 -= v9;
LABEL_13:
    if ( v11 >= 2 && (v12 = v11 - 2, (v13 = _byteswap_ushort(*(_WORD *)v10)) != 0) && v12 >= v13 )
    {
      v14 = CTlsExt::ParseTlsExtensions(*((_QWORD *)this + 2), v10 + 2, v12, 13);
      v4 = *((_QWORD *)this + 1);
      v5 = v14;
      if ( v14 )
      {
        v7 = 110;
        v6 = 403;
        goto LABEL_5;
      }
      if ( v4 == -510 )
        return 2148074244i64;
      if ( *(_WORD *)(v4 + 510) )
        return 0i64;
    }
    else
    {
      v4 = *((_QWORD *)this + 1);
    }
LABEL_4:
    v5 = -2146893048;
    v6 = 400;
    v7 = 40;
LABEL_5:
    CSslContext::SetErrorAndFatalAlert(v4, v6, v5, v7);
    return v5;
  }
  if ( *(_DWORD *)(v4 + 68) != 78 )
    goto LABEL_13;
  result = CTls13ClientContext::SetCertificateRequestContext((CTls13ClientContext *)v4, 0i64, 0);
  if ( !(_DWORD)result )
    goto LABEL_13;
  return result;
}

//----- (0000000180069444) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ParseCertificateVerify(
        __int64 a1,
        __int64 a2,
        unsigned int a3)
{
  __int64 v5; // rcx
  unsigned __int8 v6; // r9
  int v7; // edx
  unsigned int EccCurveType; // ebx
  __int64 v10; // rbx
  unsigned int v11; // esi
  CTlsSignatureSuiteList *v12; // r13
  __int16 v13; // r14
  __int64 v14; // rbx
  struct _RTL_RESOURCE *v15; // r15
  __int64 v16; // r12
  bool v17; // zf
  __int64 v18; // r15
  enum _eTlsSignatureAlgorithm v19; // [rsp+78h] [rbp+10h] BYREF

  if ( !a2 || !a3 )
    return 87i64;
  if ( a3 < 2 )
  {
    v5 = *(_QWORD *)(a1 + 8);
    v6 = 50;
    v7 = 1305;
LABEL_5:
    EccCurveType = -2146893048;
    CSslContext::SetErrorAndFatalAlert(v5, v7, -2146893048, v6);
    return EccCurveType;
  }
  v10 = *(_QWORD *)(a1 + 8);
  v11 = a3 - 2;
  v12 = (CTlsSignatureSuiteList *)(v10 + 474);
  v13 = *(_WORD *)a2;
  if ( v10 == -474 )
    return 1359i64;
  v14 = *(_QWORD *)(v10 + 88);
  if ( !v14 )
    return 1359i64;
  v15 = (struct _RTL_RESOURCE *)(v14 + 72);
  RtlAcquireResourceShared((PRTL_RESOURCE)(v14 + 72), 1u);
  v16 = *(_QWORD *)(v14 + 48);
  if ( !v16 )
  {
    EccCurveType = 1359;
LABEL_14:
    RtlReleaseResource(v15);
    return EccCurveType;
  }
  EccCurveType = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::DetermineCertVerifySignatureAlgorithm(
                   a1,
                   *(const struct _CERT_CONTEXT **)(v14 + 48));
  if ( EccCurveType )
    goto LABEL_14;
  v17 = *(_DWORD *)(a1 + 104) == 3;
  v19 = TlsSignatureAlgorithm_Anonymous;
  if ( v17 )
  {
    EccCurveType = CertGetEccCurveType(v16, (unsigned int *)&v19);
    if ( EccCurveType )
      goto LABEL_14;
  }
  RtlReleaseResource(v15);
  v18 = *(_QWORD *)(a1 + 8);
  if ( !CTlsSignatureSuiteList::IsSupportedCodePoint(v12, v13) )
  {
    v6 = 47;
    v7 = 1307;
    v5 = v18;
    goto LABEL_5;
  }
  v19 = TlsSignatureAlgorithm_Anonymous;
  GetSignatureSuiteInfoByCodePoint(
    v13,
    &v19,
    (enum _eTlsHashAlgorithm *)(a1 + 100),
    0i64,
    (const unsigned __int16 **)(a1 + 112),
    0i64,
    0i64);
  if ( v19 == TlsSignatureAlgorithm_Anonymous
    || v19 != *(_DWORD *)(a1 + 104)
    || !*(_DWORD *)(a1 + 100)
    || !*(_QWORD *)(a1 + 112) )
  {
    v5 = *(_QWORD *)(a1 + 8);
    v6 = 40;
    v7 = 1307;
    goto LABEL_5;
  }
  return CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::VerifySignature(a1, (unsigned __int8 *)(a2 + 2), v11);
}

//----- (000000018006961C) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::ParseEncryptedExtensionsMsg(
        CTls13ClientHandshake *this,
        unsigned __int8 *a2,
        unsigned int a3,
        __int64 a4)
{
  __int64 v5; // rcx
  unsigned int v6; // ebx
  __int64 v8; // r8

  if ( a2 && a3 )
  {
    if ( a3 >= 2 )
    {
      v8 = a3 - 2;
      if ( (_DWORD)v8 == (a2[1] | (*a2 << 8)) )
      {
        v6 = CTlsExt::ParseTlsExtensions(*((_QWORD *)this + 2), a2 + 2, v8, 8i64);
        if ( !v6 )
          return v6;
      }
      else
      {
        v6 = -2146893048;
      }
      v5 = *((_QWORD *)this + 1);
    }
    else
    {
      v5 = *((_QWORD *)this + 1);
      v6 = -2146893048;
    }
    LOBYTE(a4) = 50;
    CSslContext::SetErrorAndFatalAlert(v5, 120i64, v6, a4);
    return v6;
  }
  return 87i64;
}
// 18006964D: variable 'a4' is possibly undefined
// 180006430: using guessed type __int64 __fastcall CTlsExt::ParseTlsExtensions(_QWORD, _QWORD, _QWORD, _QWORD);
// 18005B470: using guessed type __int64 __fastcall CSslContext::SetErrorAndFatalAlert(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800696A8) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ParseFinished(
        __int64 a1,
        const void *a2,
        int a3)
{
  __int64 v5; // rax
  struct hsel *HashInfo; // rax
  int v7; // r8d
  __int64 v8; // r11
  size_t v9; // rdi
  unsigned __int8 v10; // r9
  int v11; // edx
  __int64 v12; // rcx
  unsigned int v13; // ebx
  unsigned __int64 FinishedMessageKey; // rbx
  __int64 v16; // r11
  __int64 v17; // rax
  _QWORD *v18; // rcx
  int v19; // eax
  CCipherMill *v20; // rbx
  char Buf1[64]; // [rsp+30h] [rbp-68h] BYREF

  if ( !a2 || !a3 )
    return 87i64;
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64);
  if ( !v5 )
    return 1359i64;
  HashInfo = GetHashInfo(*(_DWORD *)(v5 + 44));
  if ( !HashInfo )
    return 1359i64;
  v9 = *((unsigned int *)HashInfo + 7);
  if ( (unsigned int)v9 > 0x40 )
    return 1359i64;
  if ( v7 != (_DWORD)v9 )
  {
    v10 = 50;
    v11 = 903;
    v12 = v8;
LABEL_8:
    v13 = -2146893048;
    CSslContext::SetErrorAndFatalAlert(v12, v11, -2146893048, v10);
    return v13;
  }
  FinishedMessageKey = CTls13Context::GetFinishedMessageKey(
                         (CTls13Context *)(v8 + 1368),
                         (*(_DWORD *)(v8 + 64) & 0x800A2AAA) == 0);
  if ( !FinishedMessageKey )
    return 1359i64;
  v17 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v16 + 512i64))(v16, 0i64);
  v18 = *(_QWORD **)(*(_QWORD *)(a1 + 8) + 8i64);
  if ( v18 )
    v18 = (_QWORD *)*v18;
  v19 = SslComputeFinishedHash(v18, FinishedMessageKey, v17, Buf1, v9, 0);
  v13 = v19;
  if ( v19 )
  {
    CSslContext::SetError(*(_QWORD *)(a1 + 8), 902, v19);
    return v13;
  }
  v20 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 19i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
    v20 = WPP_GLOBAL_Control;
  }
  if ( memcmp_0(Buf1, a2, v9) )
  {
    if ( v20 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v20 + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)v20 + 2), 20i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
    v12 = *(_QWORD *)(a1 + 8);
    v10 = 51;
    v11 = 900;
    goto LABEL_8;
  }
  return 0i64;
}
// 180069715: variable 'v7' is possibly undefined
// 18006971F: variable 'v8' is possibly undefined
// 180069759: variable 'v16' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];
// 180098538: using guessed type __int64 __fastcall SslComputeFinishedHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (000000018006987C) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ParseFinished(
        __int64 a1,
        const void *a2,
        int a3)
{
  __int64 v5; // rax
  struct hsel *HashInfo; // rax
  int v7; // r8d
  __int64 v8; // r11
  size_t v9; // rdi
  unsigned __int8 v10; // r9
  int v11; // edx
  __int64 v12; // rcx
  unsigned int v13; // ebx
  unsigned __int64 FinishedMessageKey; // rbx
  __int64 v16; // r11
  __int64 v17; // rax
  _QWORD *v18; // rcx
  int v19; // eax
  CCipherMill *v20; // rbx
  char Buf1[64]; // [rsp+30h] [rbp-68h] BYREF

  if ( !a2 || !a3 )
    return 87i64;
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64);
  if ( !v5 )
    return 1359i64;
  HashInfo = GetHashInfo(*(_DWORD *)(v5 + 44));
  if ( !HashInfo )
    return 1359i64;
  v9 = *((unsigned int *)HashInfo + 7);
  if ( (unsigned int)v9 > 0x40 )
    return 1359i64;
  if ( v7 != (_DWORD)v9 )
  {
    v10 = 50;
    v11 = 903;
    v12 = v8;
LABEL_8:
    v13 = -2146893048;
    CSslContext::SetErrorAndFatalAlert(v12, v11, -2146893048, v10);
    return v13;
  }
  FinishedMessageKey = CTls13Context::GetFinishedMessageKey(
                         (CTls13Context *)(v8 + 1000),
                         (*(_DWORD *)(v8 + 64) & 0x800A2AAA) == 0);
  if ( !FinishedMessageKey )
    return 1359i64;
  v17 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v16 + 512i64))(v16, 0i64);
  v18 = *(_QWORD **)(*(_QWORD *)(a1 + 8) + 8i64);
  if ( v18 )
    v18 = (_QWORD *)*v18;
  v19 = SslComputeFinishedHash(v18, FinishedMessageKey, v17, Buf1, v9, 0);
  v13 = v19;
  if ( v19 )
  {
    CSslContext::SetError(*(_QWORD *)(a1 + 8), 902, v19);
    return v13;
  }
  v20 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 19i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
    v20 = WPP_GLOBAL_Control;
  }
  if ( memcmp_0(Buf1, a2, v9) )
  {
    if ( v20 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v20 + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)v20 + 2), 20i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
    v12 = *(_QWORD *)(a1 + 8);
    v10 = 51;
    v11 = 900;
    goto LABEL_8;
  }
  return 0i64;
}
// 1800698E9: variable 'v7' is possibly undefined
// 1800698F3: variable 'v8' is possibly undefined
// 18006992D: variable 'v16' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];
// 180098538: using guessed type __int64 __fastcall SslComputeFinishedHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180069A50) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ParseKeyUpdate(__int64 a1, _BYTE *a2, int a3)
{
  _DWORD *v4; // rcx
  unsigned __int8 v5; // r9
  int v6; // edx

  if ( !a2 || !a3 )
    return 87i64;
  if ( a3 != 1 )
  {
    v4 = *(_DWORD **)(a1 + 8);
    v5 = 50;
    v6 = 1602;
LABEL_5:
    CSslContext::SetErrorAndFatalAlert((__int64)v4, v6, -2146893048, v5);
    return 2148074248i64;
  }
  if ( *a2 )
  {
    v4 = *(_DWORD **)(a1 + 8);
    if ( *a2 != 1 )
    {
      v5 = 47;
      v6 = 1603;
      goto LABEL_5;
    }
    if ( (v4[34] & 0x1000i64) != 0 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 16i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
    }
    else
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
        v4 = *(_DWORD **)(a1 + 8);
      }
      LOBYTE(a2) = 1;
      (*(void (__fastcall **)(_DWORD *, _BYTE *))(*(_QWORD *)v4 + 408i64))(v4, a2);
    }
  }
  return 0i64;
}
// 180069B04: variable 'a2' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (0000000180069B50) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::ParseNewSessionTicket(
        CTls13ClientHandshake *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  void *v4; // r14
  void *v5; // r15
  int v6; // edx
  __int64 v7; // rcx
  unsigned int v8; // ebx
  size_t v9; // r12
  unsigned __int8 *v10; // rsi
  unsigned int v11; // edi
  int v12; // ebx
  HLOCAL v13; // rax
  unsigned __int16 *v14; // rsi
  unsigned int v15; // edi
  unsigned int v16; // edi
  unsigned __int16 v17; // bx
  unsigned int v18; // r13d
  HLOCAL v19; // rax
  unsigned int v20; // edi
  unsigned int v21; // edi
  unsigned int v22; // eax
  _QWORD *v23; // rcx
  int v24; // r8d
  int v25; // edx
  __int64 v26; // rdi
  CSessionCacheClientItem *v28; // [rsp+50h] [rbp-48h] BYREF
  unsigned __int32 v29; // [rsp+A8h] [rbp+10h]
  unsigned int v30; // [rsp+B8h] [rbp+20h]

  v4 = 0i64;
  v5 = 0i64;
  if ( a2 && a3 )
  {
    if ( a3 < 4 )
    {
      v6 = 1400;
LABEL_5:
      v7 = *((_QWORD *)this + 1);
LABEL_6:
      v8 = -2146893048;
      CSslContext::SetErrorAndFatalAlert(v7, v6, -2146893048, 0x32u);
      return v8;
    }
    v29 = _byteswap_ulong(*(_DWORD *)a2);
    if ( v29 > 0x93A80 )
    {
      v6 = 1403;
      goto LABEL_5;
    }
    if ( a3 - 4 < 4
      || (v30 = *((_DWORD *)a2 + 1), a3 == 8)
      || (v9 = a2[8], v10 = a2 + 9, v11 = a3 - 9, v12 = a2[8], a3 - 9 < (unsigned int)v9) )
    {
      v7 = *((_QWORD *)this + 1);
      v6 = 1400;
      goto LABEL_6;
    }
    if ( (_BYTE)v9 )
    {
      v13 = SPExternalAlloc(a2[8]);
      v4 = v13;
      if ( !v13 )
        return 14;
      memcpy_0(v13, v10, v9);
    }
    v14 = (unsigned __int16 *)&v10[v9];
    v15 = v11 - v12;
    if ( v15 < 2 )
      goto LABEL_32;
    v16 = v15 - 2;
    v17 = _byteswap_ushort(*v14);
    if ( !v17 )
      goto LABEL_32;
    v18 = v17;
    if ( v16 < v17 )
      goto LABEL_32;
    v19 = SPExternalAlloc(v17);
    v5 = v19;
    if ( !v19 )
    {
      v8 = 14;
LABEL_34:
      if ( v4 )
        SPExternalFree(v4);
      if ( v5 )
        SPExternalFree(v5);
      return v8;
    }
    memcpy_0(v19, v14 + 1, v17);
    v20 = v16 - v17;
    if ( v20 >= 2
      && (v21 = v20 - 2, v21 == (*((unsigned __int8 *)v14 + v17 + 3) | (*((unsigned __int8 *)v14 + v17 + 2) << 8))) )
    {
      v22 = CTlsExt::ParseTlsExtensions(*((_QWORD *)this + 2), (unsigned __int8 *)v14 + v17 + 4, v21, 4);
      v23 = (_QWORD *)*((_QWORD *)this + 1);
      v8 = v22;
      if ( !v22 )
      {
        v26 = v23[10];
        if ( v26 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 30i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids, v18);
            v23 = (_QWORD *)*((_QWORD *)this + 1);
          }
          v28 = 0i64;
          (*(void (__fastcall **)(_QWORD *, CSessionCacheClientItem **))(*v23 + 224i64))(v23, &v28);
          RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)v28 + 72), 1u);
          CSessionCacheClientItem::SetSessionTicket(
            v28,
            (unsigned __int8 *)v5,
            v18,
            (unsigned __int8 *)v4,
            v9,
            v30,
            v29,
            *(_DWORD *)(v26 + 208),
            *(_DWORD *)(*((_QWORD *)this + 1) + 64i64));
          RtlReleaseResource((PRTL_RESOURCE)((char *)v28 + 72));
          return v8;
        }
        v8 = -2146893052;
        goto LABEL_34;
      }
      v24 = v22;
      v25 = 1403;
    }
    else
    {
LABEL_32:
      v23 = (_QWORD *)*((_QWORD *)this + 1);
      v8 = -2146893048;
      v24 = -2146893048;
      v25 = 1400;
    }
    CSslContext::SetErrorAndFatalAlert((__int64)v23, v25, v24, 0x32u);
    goto LABEL_34;
  }
  return 87i64;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (0000000180069E18) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::ParseServerHello(
        CTls13ClientHandshake *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  __int64 v4; // rax
  __int64 v5; // rcx
  unsigned int v6; // r15d
  unsigned __int8 v7; // r9
  int v8; // edx
  unsigned int v9; // ebx
  int v10; // r8d
  __int64 result; // rax
  unsigned int v12; // esi
  unsigned __int8 *v13; // r14
  bool v14; // zf
  __int64 v15; // rax
  void *v16; // rcx
  __int64 v17; // r12
  unsigned int v18; // esi
  char *v19; // r14
  __int64 v20; // rcx
  SIZE_T v21; // rax
  unsigned __int8 *v22; // r14
  unsigned int v23; // esi
  int v24; // r12d
  unsigned int v25; // esi
  unsigned __int8 v26; // r8
  unsigned int v27; // esi
  unsigned int v28; // esi
  char v29; // r13
  unsigned int v30; // eax
  int v31; // eax
  __int64 v32; // r10
  __int64 v33; // rdx
  int v34; // eax
  __int16 v35; // ax
  __int64 v36; // r10
  __int64 v37; // rax
  int v38; // eax
  char v39; // r14
  unsigned int v40; // eax
  __int64 v41; // r11
  __int64 v42; // rsi
  unsigned int PrfHashDetails; // eax
  struct _RTL_RESOURCE *v44; // rcx
  unsigned int v45; // esi
  __int64 v46; // rax
  struct hsel *HashInfo; // rax
  int v48; // r8d
  __int64 v49; // rcx
  __int64 v50; // rcx
  __int64 v51; // rdx
  __int64 v52; // rcx
  __int64 v53; // rax
  unsigned int v54; // r8d
  __int64 v55; // rdx
  unsigned int v56; // eax
  unsigned __int8 v57; // [rsp+30h] [rbp-48h]
  int v58; // [rsp+34h] [rbp-44h]
  enum _eTlsHashAlgorithm v59; // [rsp+88h] [rbp+10h] BYREF
  __int64 v60; // [rsp+98h] [rbp+20h] BYREF

  if ( !a2 || !a3 )
    return 87i64;
  v4 = *((_QWORD *)this + 1);
  *(_WORD *)(v4 + 1838) = 0;
  *(_QWORD *)(v4 + 1840) = 0i64;
  *(_WORD *)(v4 + 1848) = 0;
  v5 = *((_QWORD *)this + 1);
  v58 = *(_DWORD *)(v5 + 68);
  if ( a3 < 2 )
    goto LABEL_92;
  v6 = a2[1] | (*a2 << 8);
  if ( v6 < 0x300 )
  {
LABEL_7:
    v7 = 70;
LABEL_8:
    v8 = 100;
LABEL_9:
    v9 = -2146893048;
LABEL_10:
    v10 = v9;
LABEL_11:
    CSslContext::SetErrorAndFatalAlert(v5, v8, v10, v7);
    return v9;
  }
  if ( *(_BYTE *)(v5 + 233) )
  {
    if ( v6 < 0xFEFD )
      goto LABEL_7;
  }
  else if ( v6 > 0x303 )
  {
    goto LABEL_7;
  }
  if ( a3 - 2 < 0x20 )
  {
LABEL_92:
    v7 = 50;
    goto LABEL_8;
  }
  v12 = a3 - 34;
  *(_OWORD *)(v5 + 304) = *(_OWORD *)(a2 + 2);
  v13 = a2 + 34;
  *(_OWORD *)(v5 + 320) = *(_OWORD *)(a2 + 18);
  v14 = RtlCompareMemory((const void *)(*((_QWORD *)this + 1) + 304i64), &unk_1800858B0, 0x20ui64) == 32;
  v15 = *((_QWORD *)this + 1);
  LOBYTE(v60) = v14;
  if ( v14 )
  {
    *(_DWORD *)(v15 + 68) = 100;
    CSslContext::SetEphemeralKey(*((CSslContext **)this + 1), 0i64);
    v16 = (void *)*((_QWORD *)this + 7);
    if ( v16 )
    {
      SPExternalFree(v16);
      *((_QWORD *)this + 7) = 0i64;
    }
  }
  else
  {
    *(_DWORD *)(v15 + 68) = 70;
  }
  if ( !v12 )
    goto LABEL_20;
  v17 = *v13;
  v18 = v12 - 1;
  v19 = (char *)(v13 + 1);
  if ( v18 < (unsigned int)v17 || (unsigned __int8)v17 > 0x20u )
    goto LABEL_20;
  v20 = *((_QWORD *)this + 1);
  if ( (_BYTE)v17 != *(_BYTE *)(v20 + 1649)
    || (v21 = RtlCompareMemory((const void *)(v20 + 1617), v19, (unsigned int)v17), LOBYTE(v59) = 1, v21 != v17) )
  {
    LOBYTE(v59) = 0;
  }
  v22 = (unsigned __int8 *)&v19[v17];
  v23 = v18 - v17;
  if ( v23 < 2 || (v24 = v22[1] | (*v22 << 8), (v25 = v23 - 2) == 0) )
  {
LABEL_20:
    v8 = 100;
LABEL_21:
    v5 = *((_QWORD *)this + 1);
    v7 = 50;
    goto LABEL_9;
  }
  v26 = v22[2];
  v27 = v25 - 1;
  v57 = v26;
  if ( v27 < 2 )
  {
    v29 = 0;
  }
  else
  {
    v28 = v27 - 2;
    v29 = 1;
    if ( v28 != (v22[4] | (v22[3] << 8)) )
    {
      v8 = 106;
      goto LABEL_21;
    }
    v30 = CTlsExt::ParseTlsExtensions(*((_QWORD *)this + 2), v22 + 5, v28, 2);
    v9 = v30;
    if ( v30 )
    {
      if ( v30 == -2146893007 )
        return v9;
      v5 = *((_QWORD *)this + 1);
      v7 = 50;
      v8 = 106;
      goto LABEL_10;
    }
    v26 = v57;
  }
  if ( !*(_BYTE *)(*((_QWORD *)this + 2) + 27i64) )
  {
    if ( !*(_QWORD *)(*((_QWORD *)this + 1) + 80i64) )
      return 2148074244i64;
    v31 = ConvertSslVersionToSchannelProtocol(v6);
    v34 = *(_DWORD *)(v33 + 152) & v31 & 0xA2AA0;
    if ( !v34 )
    {
      CSslContext::SetErrorAndFatalAlert(v32, 105, -2146893007, 0x46u);
      return 2148074289i64;
    }
    *(_DWORD *)(v32 + 64) = v34;
    v35 = ConvertSchannelProtocolToSsl(v34);
    *(_WORD *)(v36 + 34) = v35;
  }
  v5 = *((_QWORD *)this + 1);
  if ( *(_DWORD *)(v5 + 64) == 0x2000 )
  {
    if ( !v29 )
    {
      v7 = 50;
      v8 = 106;
      goto LABEL_9;
    }
    if ( v26 )
    {
      v7 = 30;
      v9 = -2146893018;
      v8 = 104;
      goto LABEL_10;
    }
    if ( !(_BYTE)v59 )
    {
      v7 = 47;
      v9 = -2146893018;
      v8 = 103;
      goto LABEL_10;
    }
    if ( v58 == 71 )
    {
      if ( (_BYTE)v60 )
      {
        v7 = 10;
        v9 = -2146893018;
        v8 = 109;
        goto LABEL_10;
      }
      if ( (*(_BYTE *)(v5 + 32) & 1) != 0 && (v37 = *(_QWORD *)(v5 + 8)) != 0 )
        v38 = *(_DWORD *)(v37 + 28);
      else
        v38 = 0;
      if ( v38 != v24 )
      {
LABEL_61:
        v7 = 47;
        v9 = -2146893018;
        v8 = 100;
        goto LABEL_10;
      }
LABEL_90:
      v56 = CTls13ClientContext::SetServerKeyShare(*((CTls13ClientContext **)this + 1));
      v9 = v56;
      if ( !v56 )
        return v9;
      v5 = *((_QWORD *)this + 1);
      v7 = 50;
      v10 = v56;
      v8 = 106;
      goto LABEL_11;
    }
    v39 = v60;
    if ( (_BYTE)v60 && *(_WORD *)(v5 + 1836) == *((_WORD *)this + 22) )
      goto LABEL_61;
    v40 = CCipherMill::SetServerHelloCipher((CCipherMill *)v5, *((struct CSsl3TlsClientContext **)this + 1), v24);
    v41 = *((_QWORD *)this + 1);
    v9 = v40;
    if ( v40 )
    {
      v7 = 40;
      v8 = 107;
LABEL_66:
      v5 = v41;
      goto LABEL_10;
    }
    if ( (*(_DWORD *)(v41 + 136) & 0x8000i64) == 0 )
    {
      v42 = *(_QWORD *)(v41 + 88);
      if ( !v42 )
        return 2148074244i64;
      RtlAcquireResourceShared((PRTL_RESOURCE)(v42 + 72), 1u);
      v59 = TlsHashAlgorithm_None;
      PrfHashDetails = CSessionCacheItem::GetPrfHashDetails((CSessionCacheItem *)v42, 0i64, &v59);
      v44 = (struct _RTL_RESOURCE *)(v42 + 72);
      v45 = PrfHashDetails;
      RtlReleaseResource(v44);
      if ( v45 )
        return v45;
      if ( v59 == TlsHashAlgorithm_None )
        return 2148074244i64;
      v46 = *(_QWORD *)(*((_QWORD *)this + 1) + 8i64);
      if ( !v46 )
        return 2148074244i64;
      HashInfo = GetHashInfo(*(_DWORD *)(v46 + 44));
      if ( !HashInfo )
        return 2148074244i64;
      if ( v48 != *((_DWORD *)HashInfo + 8) )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 29i64, WPP_922678f99ae534148d3bb024010f1556_Traceguids);
          v41 = *((_QWORD *)this + 1);
        }
        v7 = 47;
        v9 = -2146893018;
        v8 = 100;
        goto LABEL_66;
      }
    }
    v60 = 0i64;
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v41 + 224i64))(v41, &v60);
    CSessionCacheManager::AcquireCacheTableLock(v49, *(const unsigned __int16 **)(v60 + 368), 0i64);
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(v60 + 72), 1u);
    *(_DWORD *)(v60 + 168) = *(_DWORD *)(*((_QWORD *)this + 1) + 64i64);
    RtlReleaseResource((PRTL_RESOURCE)(v60 + 72));
    CSessionCacheManager::ReleaseCacheTableLock(v50, *(const unsigned __int16 **)(v60 + 368), 0i64);
    *(_BYTE *)(*((_QWORD *)this + 1) + 340i64) = 0;
    if ( !v39 )
    {
LABEL_88:
      LOBYTE(v51) = 1;
      result = (*(__int64 (__fastcall **)(_QWORD, __int64))(**((_QWORD **)this + 1) + 496i64))(
                 *((_QWORD *)this + 1),
                 v51);
      v9 = result;
      if ( (_DWORD)result )
        return result;
      if ( v39 )
        return v9;
      goto LABEL_90;
    }
    v52 = *((_QWORD *)this + 1);
    if ( (*(_BYTE *)(v52 + 32) & 1) != 0 && (v53 = *(_QWORD *)(v52 + 8)) != 0 )
    {
      v54 = *(_DWORD *)(v53 + 28);
    }
    else
    {
      v53 = *(_QWORD *)(v52 + 8);
      v54 = 0;
      if ( !v53 )
      {
        v55 = 0i64;
LABEL_87:
        result = CTls13Context::GenerateClientHelloHash(
                   (CTls13Context *)v52,
                   v55,
                   v54,
                   *(unsigned __int8 **)(v52 + 880),
                   (unsigned int *)(v52 + 872));
        if ( (_DWORD)result )
          return result;
        goto LABEL_88;
      }
    }
    v55 = *(_QWORD *)v53;
    goto LABEL_87;
  }
  if ( v58 != 71 )
    return 0i64;
  CSslContext::SetErrorAndFatalAlert(v5, 11, -2146893007, 0x46u);
  return 2148074289i64;
}
// 18006A084: variable 'v33' is possibly undefined
// 18006A0A0: variable 'v32' is possibly undefined
// 18006A0BA: variable 'v36' is possibly undefined
// 18006A10E: variable 'v26' is possibly undefined
// 18006A1C7: variable 'v41' is possibly undefined
// 18006A264: variable 'v48' is possibly undefined
// 18006A2F0: variable 'v49' is possibly undefined
// 18006A34E: variable 'v50' is possibly undefined
// 18006A3C6: variable 'v51' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (000000018006A430) ----------------------------------------------------
void __fastcall CSslContext::SetEphemeralKey(CSslContext *this, __int64 a2)
{
  __int64 v4; // rcx

  v4 = *((_QWORD *)this + 14);
  if ( v4 )
    SslFreeObject(v4, 0i64);
  *((_QWORD *)this + 14) = a2;
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018006A470) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::SetServerKeyShare(CTls13ClientContext *this)
{
  unsigned __int64 *v1; // rax
  unsigned __int64 v3; // rcx
  unsigned int v4; // edi

  v1 = (unsigned __int64 *)*((_QWORD *)this + 1);
  if ( v1 )
    v3 = *v1;
  else
    v3 = 0i64;
  v4 = CTls13Context::SetPeerPublicKey(
         (CTls13ClientContext *)((char *)this + 1368),
         *((_WORD *)this + 919),
         *((const unsigned __int8 **)this + 230),
         *((_WORD *)this + 924),
         v3);
  if ( !v4 )
    CSslContext::SetEccCurveInfo(this, *((unsigned __int16 *)this + 919));
  return v4;
}

//----- (000000018006A4E0) ----------------------------------------------------
__int64 __fastcall CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::VerifySignature(
        __int64 a1,
        unsigned __int8 *a2,
        unsigned int a3)
{
  const void **v3; // rsi
  __int64 v5; // rcx
  int v6; // r8d
  unsigned int LastError; // ebx
  unsigned __int8 v8; // r9
  int v9; // edx
  UCHAR *v10; // r15
  ULONG v11; // r14d
  __int64 v12; // rax
  __int64 v13; // r13
  __int64 v14; // rax
  struct _CERT_PUBLIC_KEY_INFO *v15; // rcx
  NTSTATUS Property; // eax
  unsigned int v17; // r14d
  unsigned __int8 *v18; // rax
  unsigned __int8 *v19; // r15
  unsigned int v20; // edx
  NTSTATUS v21; // eax
  BCRYPT_KEY_HANDLE *phKey; // [rsp+20h] [rbp-79h]
  void *pvStructInfo; // [rsp+28h] [rbp-71h]
  DWORD pcbStructInfo; // [rsp+40h] [rbp-59h] BYREF
  ULONG cbHash; // [rsp+44h] [rbp-55h] BYREF
  UCHAR pbOutput[4]; // [rsp+48h] [rbp-51h] BYREF
  BCRYPT_KEY_HANDLE hObject; // [rsp+50h] [rbp-49h] BYREF
  ULONG pcbResult; // [rsp+58h] [rbp-41h] BYREF
  __int64 pPaddingInfo; // [rsp+60h] [rbp-39h] BYREF
  ULONG v31; // [rsp+68h] [rbp-31h]
  UCHAR pbHash[64]; // [rsp+70h] [rbp-29h] BYREF

  hObject = 0i64;
  v3 = 0i64;
  if ( a2 && a3 )
  {
    if ( a3 < 2 )
    {
      v5 = *(_QWORD *)(a1 + 8);
      v6 = -2146893048;
      LastError = -2146893048;
      v8 = 50;
      v9 = 1305;
LABEL_5:
      CSslContext::SetErrorAndFatalAlert(v5, v9, v6, v8);
      goto LABEL_42;
    }
    v10 = a2 + 2;
    v11 = a3 - 2;
    if ( a3 - 2 != (a2[1] | (*a2 << 8)) )
    {
      v6 = -2146893048;
      v9 = 1305;
      LastError = -2146893048;
LABEL_8:
      v8 = 50;
LABEL_9:
      v5 = *(_QWORD *)(a1 + 8);
      goto LABEL_5;
    }
    memset_0(pbHash, 0, sizeof(pbHash));
    v12 = *(_QWORD *)(a1 + 8);
    cbHash = 0;
    LastError = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCertVerifyContentHash(
                  a1,
                  (*(_DWORD *)(v12 + 64) & 0x40051555) == 0,
                  *(enum _eTlsHashAlgorithm *)(a1 + 100),
                  0i64,
                  pbHash,
                  0x40u,
                  &cbHash);
    if ( !LastError )
    {
      v13 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 88i64);
      if ( !v13 )
      {
LABEL_12:
        LastError = 1359;
        goto LABEL_42;
      }
      RtlAcquireResourceShared((PRTL_RESOURCE)(v13 + 72), 1u);
      v14 = *(_QWORD *)(v13 + 48);
      if ( !v14
        || (v15 = *(struct _CERT_PUBLIC_KEY_INFO **)(v14 + 24)) == 0i64
        || v15 == (struct _CERT_PUBLIC_KEY_INFO *)-96i64 )
      {
        LastError = 1359;
        goto LABEL_40;
      }
      if ( !CryptImportPublicKeyInfoEx2(*(_DWORD *)v14, v15 + 2, 0x80000000, 0i64, &hObject) )
      {
        LastError = GetLastError();
        CSslContext::SetErrorAndFatalAlert(*(_QWORD *)(a1 + 8), 1306, LastError, 0x2Bu);
LABEL_40:
        RtlReleaseResource((PRTL_RESOURCE)(v13 + 72));
        goto LABEL_42;
      }
      RtlReleaseResource((PRTL_RESOURCE)(v13 + 72));
      if ( *(_DWORD *)(a1 + 104) == 1 )
      {
        pPaddingInfo = *(_QWORD *)(a1 + 112);
        v31 = cbHash;
        v21 = BCryptVerifySignature(hObject, &pPaddingInfo, pbHash, cbHash, v10, v11, 8u);
      }
      else
      {
        if ( *(_DWORD *)(a1 + 104) != 3 )
          goto LABEL_12;
        pcbStructInfo = 0;
        if ( !CryptDecodeObject(1u, (LPCSTR)0x2F, v10, v11, 0, 0i64, &pcbStructInfo) )
          goto LABEL_21;
        v3 = (const void **)SPExternalAlloc(pcbStructInfo);
        if ( !v3 )
          goto LABEL_24;
        if ( !CryptDecodeObject(1u, (LPCSTR)0x2F, v10, v11, 0, v3, &pcbStructInfo) )
        {
LABEL_21:
          LastError = GetLastError();
          v6 = LastError;
LABEL_22:
          v9 = 1108;
          goto LABEL_8;
        }
        *(_DWORD *)pbOutput = 0;
        pcbResult = 0;
        Property = BCryptGetProperty(hObject, L"KeyLength", pbOutput, 4u, &pcbResult, 0);
        LastError = Property;
        if ( Property )
        {
          v6 = Property;
          v9 = 1107;
          goto LABEL_8;
        }
        v17 = (*(_DWORD *)pbOutput >> 3) + ((pbOutput[0] & 7) != 0);
        pcbStructInfo = 2 * v17;
        v18 = (unsigned __int8 *)SPExternalAlloc(2 * v17);
        v19 = v18;
        if ( !v18 )
        {
LABEL_24:
          LastError = 14;
          goto LABEL_42;
        }
        if ( *(_DWORD *)v3 > v17 || *((_DWORD *)v3 + 4) > v17 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            LODWORD(pvStructInfo) = v17;
            LODWORD(phKey) = *((_DWORD *)v3 + 4);
            WPP_SF_DDD(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xEu,
              (__int64)WPP_922678f99ae534148d3bb024010f1556_Traceguids,
              *(_DWORD *)v3,
              phKey,
              pvStructInfo);
          }
          LastError = 13;
          v6 = 13;
          goto LABEL_22;
        }
        memcpy_0(v18, v3[1], *(unsigned int *)v3);
        memcpy_0(&v19[v17], v3[3], *((unsigned int *)v3 + 4));
        ReverseInPlace(v19, v17);
        ReverseInPlace(&v19[v17], v20);
        v21 = BCryptVerifySignature(hObject, 0i64, pbHash, cbHash, v19, pcbStructInfo, 0);
      }
      LastError = v21;
      if ( v21 )
      {
        v8 = 51;
        v6 = v21;
        v9 = 1306;
        goto LABEL_9;
      }
    }
  }
  else
  {
    LastError = 87;
  }
LABEL_42:
  if ( hObject )
    BCryptDestroyKey(hObject);
  if ( v3 )
    SPExternalFree(v3);
  return LastError;
}
// 18006A7DF: variable 'v20' is possibly undefined
// 18006A830: variable 'phKey' is possibly undefined
// 18006A830: variable 'pvStructInfo' is possibly undefined
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];

//----- (000000018006A8F8) ----------------------------------------------------
__int64 WPP_SF_DDD(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, ...)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF
  __int64 v6; // [rsp+90h] [rbp+28h] BYREF
  va_list va; // [rsp+90h] [rbp+28h]
  va_list va1; // [rsp+98h] [rbp+30h] BYREF

  va_start(va1, a4);
  va_start(va, a4);
  v6 = va_arg(va1, _QWORD);
  v5 = a4;
  return EtwTraceMessage(a1, 43i64, a3, a2, &v5, 4i64, (__int64 *)va, 4i64, va1, 4i64, 0i64);
}
// 180080F10: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018006A960) ----------------------------------------------------
void __fastcall CTls13ClientContext::CleanupConnectedState(CTls13ClientContext *this)
{
  CTls13Context::CleanupTls13SharedConnectedState((CTls13ClientContext *)((char *)this + 1368));
  CSsl3TlsClientContext::CleanupConnectedState(this);
}

//----- (000000018006A988) ----------------------------------------------------
void __fastcall CTls13Context::CleanupTls13SharedConnectedState(CTls13Context *this)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx

  CTls13Context::FreeEarlyKey(this);
  CTls13Context::FreeCertificateRequestContext(this);
  v2 = *((_QWORD *)this + 5);
  if ( v2 )
  {
    SslFreeObject(v2, 0i64);
    *((_QWORD *)this + 5) = 0i64;
  }
  v3 = *((_QWORD *)this + 6);
  if ( v3 )
  {
    SslFreeObject(v3, 0i64);
    *((_QWORD *)this + 6) = 0i64;
  }
  v4 = *((_QWORD *)this + 7);
  if ( v4 )
  {
    SslFreeObject(v4, 0i64);
    *((_QWORD *)this + 7) = 0i64;
  }
  v5 = *((_QWORD *)this + 8);
  if ( v5 )
  {
    SslFreeObject(v5, 0i64);
    *((_QWORD *)this + 8) = 0i64;
  }
  v6 = *((_QWORD *)this + 30);
  if ( v6 )
  {
    SslFreeObject(v6, 0i64);
    *((_QWORD *)this + 30) = 0i64;
  }
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018006AA40) ----------------------------------------------------
unsigned int __fastcall CTls13ClientContext::DetermineClientCredentialStatus(CTls13ClientContext *this)
{
  unsigned int result; // eax

  result = 0;
  *((_BYTE *)this + 924) = 0;
  if ( *((_BYTE *)this + 1314) )
  {
    result = CSsl3TlsClientContext::CheckForClientCred(this);
    *((_BYTE *)this + 1314) = 0;
  }
  if ( *((_BYTE *)this + 1313) )
    return 590624;
  return result;
}

//----- (000000018006AA84) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::DowngradeClientToSsl3Tls(CTls13ClientContext *this)
{
  void *v2; // rax
  __int64 result; // rax
  __int64 v4; // rax
  __int64 v5; // rcx

  v2 = SPExternalAlloc(0x558u);
  if ( !v2 )
    return 14i64;
  v4 = CSsl3TlsClientContext::CSsl3TlsClientContext(v2, this);
  v5 = *(_QWORD *)(v4 + 128);
  *((_QWORD *)this + 16) = v5;
  *(_QWORD *)(v5 + 16) = v4;
  result = 1359i64;
  *((_QWORD *)this + 17) |= 0x40000ui64;
  return result;
}
// 180060138: using guessed type __int64 __fastcall CSsl3TlsClientContext::CSsl3TlsClientContext(_QWORD, _QWORD);

//----- (000000018006AADC) ----------------------------------------------------
__int64 __fastcall CTls13Context::ExpandTrafficAndWriteKeys(
        CTls13Context *this,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        unsigned __int64 *a5,
        unsigned __int64 *a6,
        unsigned __int64 *a7,
        unsigned __int64 *a8,
        enum eSslErrorState *a9)
{
  __int64 result; // rax

  if ( !a2 || !a3 || !a4 || !a5 || !a6 || *a5 || *a6 || !a7 || !a8 || *a7 || *a8 || !a9 )
    return 87i64;
  result = SslExpandTrafficKeys(a2, a3, a4, a5, a6, 0i64, 0);
  if ( (_DWORD)result )
  {
    *(_DWORD *)a9 = 605;
    return result;
  }
  if ( !*((_BYTE *)this + 201) )
    return 0i64;
  result = SslExpandWriteKey(a2, *a5, a7, 0i64, 0);
  if ( (_DWORD)result )
  {
    *(_DWORD *)a9 = 606;
  }
  else
  {
    result = SslExpandWriteKey(a2, *a6, a8, 0i64, 0);
    if ( !(_DWORD)result )
      return 0i64;
    *(_DWORD *)a9 = 607;
  }
  return result;
}
// 1800984C0: using guessed type __int64 __fastcall SslExpandTrafficKeys(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098520: using guessed type __int64 __fastcall SslExpandWriteKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);

//----- (000000018006AC5C) ----------------------------------------------------
__int64 __fastcall CTls13Context::ExportRawSecretBytes(
        CTls13Context *this,
        __int64 a2,
        __int64 a3,
        unsigned __int8 *a4,
        unsigned int Size)
{
  __int64 result; // rax
  char v9[512]; // [rsp+50h] [rbp-228h] BYREF

  if ( !a2 || !a3 || !a4 || Size - 32 > 0x10 )
    return 2148074333i64;
  memset_0(v9, 0, sizeof(v9));
  result = SslExportKey(a2, a3, L"OpaqueKeyBlob");
  if ( !(_DWORD)result )
  {
    if ( Size )
    {
      return 2148074244i64;
    }
    else
    {
      memcpy_0(a4, v9, 0i64);
      return 0i64;
    }
  }
  return result;
}
// 180082320: using guessed type wchar_t aOpaquekeyblob[14];
// 180098528: using guessed type __int64 __fastcall SslExportKey(_QWORD, _QWORD, _QWORD);

//----- (000000018006AD5C) ----------------------------------------------------
__int64 __fastcall CTls13Context::ExportTrafficSecret(
        _QWORD *a1,
        __int64 a2,
        int a3,
        char a4,
        unsigned __int8 a5,
        __int64 a6,
        ULONG a7)
{
  __int64 v10; // rsi
  unsigned int Property; // ebx
  __int64 v12; // r8
  BCRYPT_HANDLE hObject; // [rsp+30h] [rbp-28h] BYREF
  ULONG pcbResult; // [rsp+68h] [rbp+10h] BYREF

  if ( !a2 )
    return 2148074333i64;
  if ( !a3 )
    return 2148074333i64;
  if ( !a7 )
    return 2148074333i64;
  if ( !a5 )
    return 2148074333i64;
  v10 = a6;
  if ( !a6 )
    return 2148074333i64;
  pcbResult = 0;
  hObject = 0i64;
  Property = BCryptOpenAlgorithmProvider(&hObject, (LPCWSTR)(a6 + 256), 0i64, 0);
  if ( !Property )
  {
    Property = BCryptGetProperty(hObject, L"HashDigestLength", (PUCHAR)&pcbResult, 4u, &pcbResult, 0);
    if ( !Property )
    {
      if ( pcbResult <= a7 )
      {
        v12 = 0i64;
        if ( a5 == 2 )
        {
          if ( a4 )
            v12 = a1[8];
          else
            v12 = a1[7];
        }
        else if ( a5 == 3 )
        {
          if ( a4 )
            v12 = a1[11];
          else
            v12 = a1[10];
        }
        Property = CTls13Context::ExportRawSecretBytes(
                     (CTls13Context *)((unsigned int)a5 - 2),
                     a2,
                     v12,
                     (unsigned __int8 *)(v10 + 398),
                     pcbResult);
        if ( !Property )
          *(_WORD *)(v10 + 396) = pcbResult;
      }
      else
      {
        Property = -2146893052;
      }
    }
  }
  if ( hObject )
    BCryptCloseAlgorithmProvider(hObject, 0);
  return Property;
}

//----- (000000018006AEC8) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::FindClientShare(
        CTls13ServerContext *this,
        __int16 a2,
        const unsigned __int8 **a3,
        unsigned __int16 *a4)
{
  unsigned __int16 v7; // cx
  const unsigned __int8 *v8; // r10
  __int16 v9; // dx
  unsigned __int16 v10; // bx
  __int16 v11; // ax
  const unsigned __int8 *v12; // r10
  unsigned __int16 v13; // dx
  unsigned __int16 v14; // cx

  if ( a3 )
    *a3 = 0i64;
  if ( a4 )
    *a4 = 0;
  if ( (a3 == 0i64) != (a4 == 0i64) )
    return 87i64;
  v7 = *((_WORD *)this + 752);
  v8 = (const unsigned __int8 *)*((_QWORD *)this + 187);
  if ( !v7 )
    return 1168i64;
  while ( 1 )
  {
    if ( v7 < 4u
      || (v9 = v8[2],
          v10 = _byteswap_ushort(*(_WORD *)v8),
          v11 = v8[3],
          v12 = v8 + 4,
          v13 = v11 | (v9 << 8),
          v14 = v7 - 4,
          !v13)
      || v13 > v14 )
    {
      CSslContext::SetErrorAndFatalAlert((__int64)this, 1202, -2146893048, 0x32u);
      return 2148074248i64;
    }
    if ( a2 == v10 )
      break;
    v8 = &v12[v13];
    v7 = v14 - v13;
    if ( !v7 )
      return 1168i64;
  }
  if ( a3 )
  {
    if ( a4 )
    {
      *a3 = v12;
      *a4 = v13;
    }
  }
  return 0i64;
}

//----- (000000018006AFC8) ----------------------------------------------------
void __fastcall CTls13Context::FreeCertificateRequestContext(CTls13Context *this)
{
  void *v2; // rcx

  v2 = (void *)*((_QWORD *)this + 28);
  if ( v2 )
  {
    SPExternalFree(v2);
    *((_QWORD *)this + 28) = 0i64;
  }
  *((_BYTE *)this + 232) = 0;
}

//----- (000000018006B000) ----------------------------------------------------
void __fastcall CTls13Context::FreeEarlyKey(CTls13Context *this)
{
  __int64 v2; // rcx

  v2 = *((_QWORD *)this + 13);
  if ( v2 )
  {
    SslFreeObject(v2, 0i64);
    *((_QWORD *)this + 13) = 0i64;
  }
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018006B034) ----------------------------------------------------
__int64 __fastcall CTls13Context::GenerateApplicationWriteKeys(
        CTls13Context *this,
        __int64 a2,
        __int64 a3,
        unsigned __int64 *a4,
        unsigned __int64 *a5,
        enum eSslErrorState *a6)
{
  __int64 v10; // rdx
  __int64 *v11; // r14
  __int64 result; // rax
  unsigned int MasterKey; // [rsp+88h] [rbp+10h]

  if ( !a2 )
    return 87i64;
  if ( !a3 )
    return 87i64;
  if ( !a4 )
    return 87i64;
  if ( !a5 )
    return 87i64;
  if ( *a4 )
    return 87i64;
  if ( *a5 )
    return 87i64;
  if ( !a6 )
    return 87i64;
  v10 = *((_QWORD *)this + 6);
  if ( !v10 )
    return 87i64;
  v11 = (__int64 *)((char *)this + 72);
  if ( *((_QWORD *)this + 9) || *((_QWORD *)this + 12) )
    return 87i64;
  MasterKey = SslExtractMasterKey(a2, v10, (char *)this + 72, 0i64, 0);
  SslFreeObject(*((_QWORD *)this + 6), 0i64);
  result = MasterKey;
  *((_QWORD *)this + 6) = 0i64;
  if ( MasterKey )
  {
    *(_DWORD *)a6 = 711;
  }
  else
  {
    result = SslExpandExporterMasterKey(a2, *v11, a3, (char *)this + 96, 0i64, 0);
    if ( (_DWORD)result )
      *(_DWORD *)a6 = 608;
    else
      return CTls13Context::ExpandTrafficAndWriteKeys(
               this,
               a2,
               *v11,
               a3,
               (unsigned __int64 *)this + 10,
               (unsigned __int64 *)this + 11,
               a4,
               a5,
               a6);
  }
  return result;
}
// 180098488: using guessed type __int64 __fastcall SslExpandExporterMasterKey(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098498: using guessed type __int64 __fastcall SslExtractMasterKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018006B1A8) ----------------------------------------------------
__int64 __fastcall CTls13Context::GenerateBinderData(
        CTls13Context *this,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        unsigned __int16 a5,
        unsigned int a6,
        const unsigned __int8 *a7,
        unsigned int a8,
        unsigned __int8 *a9,
        unsigned int a10)
{
  unsigned int v13; // ebx
  unsigned int v14; // r15d
  _QWORD *v15; // rsi
  unsigned int EarlyKey; // ebx
  CCipherMill *v17; // rcx
  __int64 v18; // rdx
  __int64 v20; // [rsp+40h] [rbp-28h] BYREF
  __int64 v21; // [rsp+78h] [rbp+10h] BYREF

  v20 = 0i64;
  v21 = 0i64;
  if ( a2 && a3 && a4 && a5 >= 0x304u && (v13 = a6) != 0 && a9 && (v14 = a10, a10 - 1 <= 0x3F) )
  {
    v15 = (_QWORD *)((char *)this + 104);
    if ( *((_QWORD *)this + 13)
      || (SslExpandPreSharedKey(a2, a3, a7, a8, &v21, 0i64, 0),
          (EarlyKey = SslExtractEarlyKey(a2, v21, v15, a5, v13, 0i64, 0)) == 0) )
    {
      EarlyKey = SslExpandBinderKey(a2, *v15, &v20, 0i64, 2);
      if ( EarlyKey )
      {
        v17 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          v18 = 16i64;
          goto LABEL_13;
        }
      }
      else
      {
        EarlyKey = SslComputeFinishedHash(a2, v20, a4, a9, v14, 0);
        if ( EarlyKey )
        {
          v17 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            v18 = 17i64;
            goto LABEL_13;
          }
        }
      }
    }
    else
    {
      v17 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        v18 = 15i64;
LABEL_13:
        WPP_SF_D(*((_QWORD *)v17 + 2), v18, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids, EarlyKey);
      }
    }
  }
  else
  {
    EarlyKey = 87;
  }
  if ( v21 )
    SslFreeObject(v21, 0i64);
  if ( v20 )
    SslFreeObject(v20, 0i64);
  if ( EarlyKey )
    CTls13Context::FreeEarlyKey(this);
  return EarlyKey;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098460: using guessed type __int64 __fastcall SslExpandBinderKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098470: using guessed type __int64 __fastcall SslExpandPreSharedKey(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 1800984B8: using guessed type __int64 __fastcall SslExtractEarlyKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 180098538: using guessed type __int64 __fastcall SslComputeFinishedHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018006B3EC) ----------------------------------------------------
__int64 __fastcall CTls13Context::GenerateCcsRecord(CTls13Context *this)
{
  __int64 result; // rax

  if ( !*((_BYTE *)this + 32) && *((_BYTE *)this + 201) )
  {
    result = CTls13ChangeCipherSpec::GenerateMessage((CTls13Context *)((char *)this + 16));
    if ( (_DWORD)result )
      return result;
    *((_BYTE *)this + 32) = 1;
  }
  return 0i64;
}

//----- (000000018006B424) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::GenerateCertVerifyHashForRemoteSigning(CTls13ClientContext *this)
{
  __int64 v1; // rsi
  __int64 v2; // rax
  char *v4; // r14
  unsigned int CertificateMsg; // eax
  unsigned int v6; // ebx
  int v7; // r8d
  __int64 v8; // rcx
  __int16 v9; // cx
  const WCHAR *lpString; // r15
  size_t Size; // [rsp+48h] [rbp-71h]
  ULONG v13; // [rsp+60h] [rbp-59h] BYREF
  unsigned int v14; // [rsp+64h] [rbp-55h] BYREF
  enum _eTlsHashAlgorithm v15; // [rsp+68h] [rbp-51h] BYREF
  unsigned int v16; // [rsp+6Ch] [rbp-4Dh] BYREF
  unsigned int v17; // [rsp+70h] [rbp-49h] BYREF
  LPCWSTR v18; // [rsp+78h] [rbp-41h] BYREF
  void *v19[2]; // [rsp+80h] [rbp-39h] BYREF
  __int16 v20[2]; // [rsp+90h] [rbp-29h] BYREF
  int v21; // [rsp+94h] [rbp-25h]
  int v22; // [rsp+98h] [rbp-21h]
  unsigned __int8 Src[64]; // [rsp+A0h] [rbp-19h] BYREF

  v1 = *((_QWORD *)this + 116);
  v2 = *((_QWORD *)this + 10);
  v20[0] = 0;
  v21 = 22;
  v22 = 1;
  *(_OWORD *)v19 = 0i64;
  if ( !v1 || !v2 || !*(_BYTE *)(v1 + 78) || *(_BYTE *)(v1 + 79) )
    goto LABEL_20;
  v4 = (char *)this + 1656;
  CertificateMsg = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeCertificateMsgSize(
                     (__int64)this + 1656,
                     v1,
                     *(_BYTE *)(v2 + 156) & 0x80,
                     v20);
  v6 = CertificateMsg;
  if ( CertificateMsg )
    goto LABEL_6;
  v8 = *((_QWORD *)this + 197);
  v14 = 0;
  CertificateMsg = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *, unsigned int *))(*(_QWORD *)v8 + 16i64))(
                     v8,
                     1i64,
                     v20,
                     &v14);
  v6 = CertificateMsg;
  if ( CertificateMsg )
    goto LABEL_6;
  LODWORD(v19[0]) = v14;
  v19[1] = SPExternalAlloc(v14);
  if ( !v19[1] )
  {
    v6 = -2146893056;
    v7 = -2146893056;
    goto LABEL_7;
  }
  CertificateMsg = (*(__int64 (__fastcall **)(_QWORD, void **))(**((_QWORD **)this + 197) + 24i64))(
                     *((_QWORD *)this + 197),
                     v19);
  v6 = CertificateMsg;
  if ( CertificateMsg
    || (CertificateMsg = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCertificateMsg((__int64)v4),
        (v6 = CertificateMsg) != 0)
    || (CertificateMsg = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::DetermineCertVerifyCodePoint((__int64)v4),
        (v6 = CertificateMsg) != 0) )
  {
LABEL_6:
    v7 = CertificateMsg;
LABEL_7:
    CSslContext::SetError((__int64)this, 155, v7);
    goto LABEL_21;
  }
  v9 = *((_WORD *)this + 888);
  v15 = TlsHashAlgorithm_None;
  v13 = 0;
  v17 = 0;
  v18 = 0i64;
  v16 = 0;
  GetSignatureSuiteInfoByCodePoint(v9, (enum _eTlsSignatureAlgorithm *)&v13, &v15, &v17, &v18, 0i64, &v16);
  if ( v13 == 1 )
  {
    lpString = L"RSA";
    goto LABEL_18;
  }
  if ( v13 != 3 )
  {
LABEL_20:
    v6 = -2146893052;
    goto LABEL_21;
  }
  lpString = L"ECDSA";
LABEL_18:
  memset_0(Src, 0, sizeof(Src));
  v13 = 0;
  v6 = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCertVerifyContentHash(
         (__int64)v4,
         0,
         v15,
         0i64,
         Src,
         0x40u,
         &v13);
  if ( !v6 )
  {
    LODWORD(Size) = v13;
    v6 = RemotelySignHash(
           0i64,
           *((_QWORD *)this + 13),
           *(_QWORD *)(v1 + 104),
           *(_DWORD *)(v1 + 128),
           v17,
           v16,
           lpString,
           v18,
           Src,
           Size);
  }
LABEL_21:
  if ( v19[1] )
    SPExternalFree(v19[1]);
  return v6;
}
// 18006B667: variable 'Size' is possibly undefined
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (000000018006B6B4) ----------------------------------------------------
ULONG __fastcall CTls13ServerContext::GenerateCertificateRequestContext(CTls13ServerContext *this)
{
  UCHAR *v2; // rax

  CTls13Context::FreeCertificateRequestContext((CTls13ServerContext *)((char *)this + 1000));
  v2 = (UCHAR *)SPExternalAlloc(0x20u);
  *((_QWORD *)this + 153) = v2;
  if ( !v2 )
    return -2146893056;
  *((_BYTE *)this + 1232) = 32;
  return GenerateRandomBits(v2, 0x20u);
}

//----- (000000018006B70C) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::GenerateClientFinished(CTls13ClientContext *this, struct SPBuffer *a2)
{
  __int64 v2; // rsi
  CTls13Context *v5; // r12
  unsigned int OutputBuffer; // edi
  char v7; // r10
  int v8; // edx
  CTls13ClientContext *v9; // rcx
  __int64 v11; // rdx
  __int64 v12; // rdi
  __int16 *v13; // r9
  unsigned __int8 v14; // di
  unsigned int v15; // r14d
  int v16; // edx
  __int64 v17; // rax
  __int64 v18; // rax
  unsigned __int8 v19; // di
  __int64 v20; // rcx
  __int64 *v21; // rax
  __int64 v22; // rdx
  __int64 *v23; // rax
  __int64 v24; // rdx
  __int64 *v25; // rax
  __int64 v26; // rdx
  char v27[4]; // [rsp+40h] [rbp-40h] BYREF
  unsigned int v28; // [rsp+44h] [rbp-3Ch] BYREF
  __int16 v29[2]; // [rsp+48h] [rbp-38h] BYREF
  int v30; // [rsp+4Ch] [rbp-34h]
  int v31; // [rsp+50h] [rbp-30h]
  __int16 v32; // [rsp+54h] [rbp-2Ch]
  int v33; // [rsp+58h] [rbp-28h]
  int v34; // [rsp+5Ch] [rbp-24h]
  __int16 v35; // [rsp+60h] [rbp-20h]
  int v36; // [rsp+64h] [rbp-1Ch]
  int v37; // [rsp+68h] [rbp-18h]
  __int16 v38; // [rsp+6Ch] [rbp-14h]
  int v39; // [rsp+70h] [rbp-10h]
  int v40; // [rsp+74h] [rbp-Ch]

  v2 = *((_QWORD *)this + 116);
  v27[0] = 0;
  v29[0] = 0;
  v32 = 0;
  v35 = 0;
  v30 = 22;
  v31 = 3;
  v5 = (CTls13ClientContext *)((char *)this + 1368);
  v34 = 3;
  v37 = 3;
  v40 = 3;
  v33 = 22;
  v36 = 22;
  v38 = 0;
  v39 = 22;
  OutputBuffer = CTls13Context::SetCcsRecordInfo(
                   (CTls13ClientContext *)((char *)this + 1368),
                   (struct CTlsRecord::CMessageInfo *)v29,
                   v27);
  if ( OutputBuffer )
  {
    v8 = 153;
LABEL_3:
    v9 = this;
LABEL_4:
    CSslContext::SetError((__int64)v9, v8, OutputBuffer);
    return OutputBuffer;
  }
  if ( *((_BYTE *)this + 1315) == v7 )
  {
    v14 = v27[0];
  }
  else
  {
    v11 = *((_QWORD *)this + 10);
    if ( !v11 )
      return 1359i64;
    v12 = (unsigned __int8)v27[0];
    if ( v2 && *(_BYTE *)(v2 + 78) != v7 && *(_BYTE *)(v2 + 79) == v7 )
      *(&v31 + 3 * (unsigned __int8)v27[0]) = 2;
    v13 = &v29[6 * v12];
    v14 = v12 + 1;
    v15 = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeCertificateMsgSize(
            (__int64)this + 1656,
            v2,
            *(_BYTE *)(v11 + 156) & 0x80,
            v13);
    if ( v15
      || v2
      && (v17 = v14,
          ++v14,
          (v15 = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeCertificateVerifySize(
                   (__int64)this + 1656,
                   &v29[6 * v17])) != 0) )
    {
      v16 = 153;
LABEL_14:
      CSslContext::SetError((__int64)this, v16, v15);
      return v15;
    }
  }
  v18 = v14;
  v19 = v14 + 1;
  v15 = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeFinishedSize(
          (__int64)this + 1656,
          (__int64)&v29[6 * v18]);
  if ( v15 )
  {
    v16 = 905;
    goto LABEL_14;
  }
  v20 = *((_QWORD *)this + 197);
  v28 = 0;
  OutputBuffer = (*(__int64 (__fastcall **)(__int64, _QWORD, __int16 *, unsigned int *))(*(_QWORD *)v20 + 16i64))(
                   v20,
                   v19,
                   v29,
                   &v28);
  v9 = this;
  if ( OutputBuffer )
  {
    v8 = 906;
    goto LABEL_4;
  }
  OutputBuffer = CSsl3TlsContext::AllocateOutputBuffer(this, a2, v28);
  if ( OutputBuffer )
    goto LABEL_24;
  OutputBuffer = (*(__int64 (__fastcall **)(_QWORD, struct SPBuffer *))(**((_QWORD **)this + 197) + 24i64))(
                   *((_QWORD *)this + 197),
                   a2);
  if ( OutputBuffer )
    goto LABEL_24;
  OutputBuffer = CTls13Context::GenerateCcsRecord(v5);
  if ( OutputBuffer
    || *((_BYTE *)this + 1315)
    && ((OutputBuffer = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateCertificateMsg((__int64)this + 1656)) != 0
     || v2
     && (OutputBuffer = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateCertificateVerify((__int64)this + 1656)) != 0) )
  {
    v8 = 154;
    goto LABEL_3;
  }
  OutputBuffer = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::GenerateFinished((__int64)this + 1656);
  if ( OutputBuffer )
  {
LABEL_24:
    v8 = 907;
    goto LABEL_3;
  }
  if ( !(*(unsigned __int8 (__fastcall **)(CTls13ClientContext *))(*(_QWORD *)this + 384i64))(this) )
  {
    v21 = (__int64 *)*((_QWORD *)this + 1);
    if ( v21 )
      v22 = *v21;
    else
      v22 = 0i64;
    OutputBuffer = CTls13Context::PopulateSecTrafficSecret((__int64)v5, v22, 0, 2u, (__int64)v21, 0, *((_WORD *)a2 + 2));
    if ( OutputBuffer )
    {
      v8 = 609;
      goto LABEL_3;
    }
    v23 = (__int64 *)*((_QWORD *)this + 1);
    if ( v23 )
      v24 = *v23;
    else
      v24 = 0i64;
    OutputBuffer = CTls13Context::PopulateSecTrafficSecret((__int64)v5, v24, 1, 3u, (__int64)v23, 0, 0);
    if ( OutputBuffer )
    {
      v8 = 612;
      goto LABEL_3;
    }
    v25 = (__int64 *)*((_QWORD *)this + 1);
    if ( v25 )
      v26 = *v25;
    else
      v26 = 0i64;
    OutputBuffer = CTls13Context::PopulateSecTrafficSecret((__int64)v5, v26, 0, 3u, (__int64)v25, 0, 0);
    if ( OutputBuffer )
    {
      v8 = 611;
      goto LABEL_3;
    }
  }
  return 0i64;
}
// 18006B7B6: variable 'v7' is possibly undefined
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 18006B70C: using guessed type char var_40[4];

//----- (000000018006BA8C) ----------------------------------------------------
__int64 __fastcall CTls13Context::GenerateClientHelloHash(
        CTls13Context *this,
        __int64 a2,
        unsigned int a3,
        unsigned __int8 *a4,
        unsigned int *a5)
{
  __int64 result; // rax
  __int64 HashInfoFromAlgorithmName; // rax
  unsigned int v10; // ebx
  unsigned int v11; // ebx
  int v12; // [rsp+20h] [rbp-E0h]
  unsigned int v13; // [rsp+40h] [rbp-C0h] BYREF
  void *v14; // [rsp+48h] [rbp-B8h] BYREF
  __int16 Src; // [rsp+50h] [rbp-B0h] BYREF
  char v16; // [rsp+52h] [rbp-AEh]
  char v17; // [rsp+53h] [rbp-ADh]
  char v18[60]; // [rsp+54h] [rbp-ACh] BYREF
  wchar_t String1[64]; // [rsp+90h] [rbp-70h] BYREF

  if ( !a2 || !a3 || !a4 || !a5 || !*a5 )
    return 87i64;
  memset_0(String1, 0, sizeof(String1));
  memset_0(&Src, 0, 0x40ui64);
  v13 = 0;
  v14 = 0i64;
  result = SslGetCipherSuitePRFHashAlgorithm(a2, 772i64, a3, 0i64, String1, 0);
  if ( !(_DWORD)result )
  {
    HashInfoFromAlgorithmName = I_GetHashInfoFromAlgorithmName(String1);
    if ( HashInfoFromAlgorithmName )
    {
      result = TlsGetBCryptHashProvider(
                 (enum _eTlsHashAlgorithm)*(_DWORD *)(HashInfoFromAlgorithmName + 20),
                 &v14,
                 &v13);
      if ( !(_DWORD)result )
      {
        v10 = v13;
        v16 = 0;
        v12 = *a5;
        Src = 254;
        v17 = v13;
        result = BCryptHash(v14, 0i64, 0i64, a4, v12, v18, v13);
        if ( !(_DWORD)result )
        {
          v11 = v10 + 4;
          if ( v11 <= *a5 )
          {
            *a5 = v11;
            memcpy_0(a4, &Src, v11);
            return 0i64;
          }
          else
          {
            return 1359i64;
          }
        }
      }
    }
    else
    {
      return 2148074244i64;
    }
  }
  return result;
}
// 180098360: using guessed type __int64 __fastcall BCryptHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 180098438: using guessed type __int64 __fastcall SslGetCipherSuitePRFHashAlgorithm(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 18006BA8C: using guessed type char var_EC[60];

//----- (000000018006BC00) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::GenerateClientHelloResponse(CTls13ServerContext *this, struct SPBuffer *a2)
{
  __int64 *v2; // rax
  struct SPBuffer *v3; // r14
  __int64 v5; // r13
  unsigned int inited; // edi
  int v7; // edx
  CTls13ServerContext *v8; // rcx
  int v10; // edi
  unsigned int OutputBuffer; // esi
  int v12; // edx
  __int64 v13; // rcx
  __int64 v14; // rax
  int v15; // r14d
  __int64 v16; // rax
  __int64 v17; // r13
  __int64 v18; // rax
  __int64 v19; // rsi
  void *v20; // rcx
  PCCERT_SERVER_OCSP_RESPONSE_CONTEXT ServerOcspResponseContext; // rax
  DWORD LastError; // eax
  __int64 v23; // rax
  unsigned __int8 v24; // di
  int v25; // eax
  __int64 v26; // rcx
  bool v27; // zf
  __int64 v28; // rax
  unsigned int v29; // ecx
  __int64 *v30; // r14
  _QWORD *v31; // r12
  char v32; // cl
  __int64 v33; // rax
  __int64 v34; // rcx
  char v35; // cl
  char v36[8]; // [rsp+50h] [rbp-79h] BYREF
  __int64 v37; // [rsp+58h] [rbp-71h] BYREF
  unsigned int v38; // [rsp+60h] [rbp-69h] BYREF
  __int64 v39; // [rsp+68h] [rbp-61h]
  struct SPBuffer *v40; // [rsp+70h] [rbp-59h]
  unsigned __int16 v41[2]; // [rsp+80h] [rbp-49h] BYREF
  int v42; // [rsp+84h] [rbp-45h]
  int v43; // [rsp+88h] [rbp-41h]
  __int16 v44; // [rsp+8Ch] [rbp-3Dh] BYREF
  int v45; // [rsp+90h] [rbp-39h]
  int v46; // [rsp+94h] [rbp-35h]
  __int16 v47; // [rsp+98h] [rbp-31h]
  int v48; // [rsp+9Ch] [rbp-2Dh]
  int v49; // [rsp+A0h] [rbp-29h]
  __int16 v50; // [rsp+A4h] [rbp-25h]
  int v51; // [rsp+A8h] [rbp-21h]
  int v52; // [rsp+ACh] [rbp-1Dh]
  __int16 v53; // [rsp+B0h] [rbp-19h]
  int v54; // [rsp+B4h] [rbp-15h]
  int v55; // [rsp+B8h] [rbp-11h]
  __int16 v56; // [rsp+BCh] [rbp-Dh]
  int v57; // [rsp+C0h] [rbp-9h]
  int v58; // [rsp+C4h] [rbp-5h]
  __int16 v59; // [rsp+C8h] [rbp-1h]
  int v60; // [rsp+CCh] [rbp+3h]
  int v61; // [rsp+D0h] [rbp+7h]

  v2 = (__int64 *)*((_QWORD *)this + 1);
  v40 = a2;
  v3 = a2;
  if ( v2 )
    v5 = *v2;
  else
    v5 = 0i64;
  v39 = v5;
  v41[0] = 0;
  v42 = 22;
  v43 = 1;
  v44 = 0;
  v46 = 3;
  v49 = 3;
  v52 = 3;
  v55 = 3;
  v58 = 3;
  v61 = 3;
  v45 = 22;
  v47 = 0;
  v48 = 22;
  v50 = 0;
  v51 = 22;
  v53 = 0;
  v54 = 22;
  v56 = 0;
  v57 = 22;
  v59 = 0;
  v60 = 22;
  v36[0] = 1;
  inited = CTls13ServerHandshake::ComputeServerHelloOrHRRSize((CTls13ServerContext *)((char *)this + 1288), v5, 1, v41);
  if ( inited
    || (inited = CTls13Context::SetCcsRecordInfo(
                   (CTls13ServerContext *)((char *)this + 1000),
                   (struct CTlsRecord::CMessageInfo *)&v44,
                   v36)) != 0 )
  {
    v7 = 1253;
LABEL_6:
    v8 = this;
LABEL_7:
    CSslContext::SetError((__int64)v8, v7, inited);
    return inited;
  }
  v10 = (unsigned __int8)(v36[0] + 1);
  OutputBuffer = CTls13ServerHandshake::ComputeEncryptedExtensionsMsgSize(
                   (CTls13ServerContext *)((char *)this + 1288),
                   &v41[6 * (unsigned __int8)v36[0]]);
  if ( OutputBuffer )
  {
LABEL_10:
    v12 = 1253;
LABEL_11:
    CSslContext::SetError((__int64)this, v12, OutputBuffer);
    return OutputBuffer;
  }
  v13 = *((_QWORD *)this + 17);
  if ( (v13 & 0x8000) != 0 )
  {
    v14 = *((_QWORD *)this + 1);
    v36[0] = 0;
    if ( !v14 )
      return 1359i64;
    v15 = *(_DWORD *)(v14 + 48);
    if ( (v13 & 0x100) != 0 && v15 != 4 )
    {
      v16 = (unsigned __int8)v10;
      LOBYTE(v10) = v10 + 1;
      OutputBuffer = CTls13ServerHandshake::ComputeCertificateRequestSize(
                       (CTls13ServerContext *)((char *)this + 1288),
                       &v41[6 * v16]);
      if ( OutputBuffer )
        goto LABEL_10;
    }
    v17 = *((_QWORD *)this + 10);
    if ( !v17 )
      return 1359i64;
    v18 = *(_QWORD *)this;
    v37 = 0i64;
    (*(void (__fastcall **)(CTls13ServerContext *, __int64 *))(v18 + 232))(this, &v37);
    if ( !v37 )
      return 1359i64;
    RtlAcquireResourceShared((PRTL_RESOURCE)(v37 + 72), 1u);
    v19 = *(_QWORD *)(v37 + 336);
    if ( !v19 )
    {
      RtlReleaseResource((PRTL_RESOURCE)(v37 + 72));
      return 1359i64;
    }
    if ( (*((_DWORD *)this + 34) & 0x20000) != 0 )
    {
      v20 = *(void **)(v19 + 456);
      if ( v20 )
      {
        if ( v15 != 4 )
        {
          ServerOcspResponseContext = CertGetServerOcspResponseContext(v20, 0, 0i64);
          *((_QWORD *)this + 189) = ServerOcspResponseContext;
          if ( !ServerOcspResponseContext
            && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            LastError = GetLastError();
            WPP_SF_D(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              59i64,
              &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids,
              LastError);
          }
        }
      }
    }
    v23 = (unsigned __int8)v10;
    v24 = v10 + 1;
    OutputBuffer = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeCertificateMsgSize(
                     (__int64)this + 1288,
                     v19,
                     *(_BYTE *)(v17 + 156) & 0x80,
                     &v41[6 * v23]);
    RtlReleaseResource((PRTL_RESOURCE)(v37 + 72));
    if ( OutputBuffer )
      goto LABEL_10;
    v25 = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ComputeCertificateVerifySize(
            (__int64)this + 1288,
            &v41[6 * v24]);
    LOBYTE(v10) = v24 + 1;
    OutputBuffer = v25;
    if ( v25 )
      goto LABEL_10;
    v5 = v39;
    v3 = v40;
  }
  else
  {
    v36[0] = 1;
  }
  OutputBuffer = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ComputeFinishedSize(
                   (__int64)this + 1288,
                   (__int64)&v41[6 * (unsigned __int8)v10]);
  if ( OutputBuffer )
    goto LABEL_10;
  v26 = *((_QWORD *)this + 151);
  v38 = 0;
  inited = (*(__int64 (__fastcall **)(__int64, _QWORD, unsigned __int16 *, unsigned int *))(*(_QWORD *)v26 + 16i64))(
             v26,
             (unsigned __int8)(v10 + 1),
             v41,
             &v38);
  v8 = this;
  if ( inited )
  {
    v7 = 1254;
    goto LABEL_7;
  }
  OutputBuffer = CSsl3TlsContext::AllocateOutputBuffer(this, v3, v38);
  if ( OutputBuffer )
    goto LABEL_37;
  OutputBuffer = (*(__int64 (__fastcall **)(_QWORD, struct SPBuffer *))(**((_QWORD **)this + 151) + 24i64))(
                   *((_QWORD *)this + 151),
                   v3);
  if ( OutputBuffer )
    goto LABEL_37;
  if ( *((_DWORD *)this + 17) == 93 )
  {
    inited = CSsl3TlsServerContext::InitUpdateClientHash(this);
  }
  else
  {
    inited = (*(__int64 (__fastcall **)(CTls13ServerContext *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 504i64))(
               this,
               *((_QWORD *)this + 110),
               *((unsigned int *)this + 218),
               0i64);
    if ( *((_QWORD *)this + 110) )
    {
      (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 16i64))(this);
      *((_QWORD *)this + 110) = 0i64;
    }
    *((_DWORD *)this + 218) = 0;
  }
  if ( inited )
  {
    v7 = 1007;
    goto LABEL_6;
  }
  if ( this == (CTls13ServerContext *)-304i64 )
  {
    CSslContext::SetError(-304i64, 1255, 1359);
    return 1359i64;
  }
  OutputBuffer = CTls13ServerHandshake::GenerateServerHelloOrHRR(
                   (CTls13ServerContext *)((char *)this + 1288),
                   1,
                   (unsigned __int8 *)this + 304);
  if ( OutputBuffer )
  {
LABEL_37:
    v12 = 1255;
    goto LABEL_11;
  }
  v27 = (*((_BYTE *)this + 32) & 1) == 0;
  LODWORD(v37) = 1255;
  if ( v27 || (v28 = *((_QWORD *)this + 1)) == 0 )
    v29 = 0;
  else
    v29 = *(_DWORD *)(v28 + 28);
  v30 = (__int64 *)((char *)this + 168);
  v31 = (_QWORD *)((char *)this + 160);
  OutputBuffer = CTls13Context::GenerateHandshakeWriteKeys(
                   (CTls13ServerContext *)((char *)this + 1000),
                   v5,
                   *((_QWORD *)this + 14),
                   *((_QWORD *)this + 74),
                   *((_WORD *)this + 17),
                   v29,
                   v36[0],
                   (unsigned __int64 *)this + 20,
                   (unsigned __int64 *)this + 21,
                   (enum eSslErrorState *)&v37);
  if ( OutputBuffer )
  {
    v12 = v37;
    goto LABEL_11;
  }
  v32 = *((_BYTE *)this + 233);
  *((_WORD *)this + 16) |= 0xCu;
  if ( !v32 && *((_QWORD *)this + 19) )
  {
    SslFreeObject(*((_QWORD *)this + 19), 0i64);
    v32 = *((_BYTE *)this + 233);
  }
  v33 = *v30;
  *v30 = 0i64;
  *((_QWORD *)this + 19) = v33;
  if ( !v32 )
    *((_QWORD *)this + 23) = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 59i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
  *((_BYTE *)this + 1216) = 2;
  OutputBuffer = CTls13Context::GenerateCcsRecord((CTls13ServerContext *)((char *)this + 1000));
  if ( OutputBuffer
    || (OutputBuffer = CTls13ServerHandshake::GenerateEncryptedExtensionsMsg((CTls13ServerContext *)((char *)this + 1288))) != 0
    || !v36[0]
    && ((*((_DWORD *)this + 34) & 0x100i64) != 0
     && *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) != 4
     && (OutputBuffer = CTls13ServerHandshake::GenerateCertificateRequest((CTls13ServerContext *)((char *)this + 1288))) != 0
     || (OutputBuffer = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateCertificateMsg((__int64)this + 1288)) != 0
     || (OutputBuffer = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateCertificateVerify((__int64)this + 1288)) != 0)
    || (OutputBuffer = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::GenerateFinished((__int64)this + 1288)) != 0 )
  {
    v12 = 1255;
    goto LABEL_11;
  }
  *((_WORD *)this + 16) |= 0xAu;
  v34 = *((_QWORD *)this + 18);
  if ( v34 )
    SslFreeObject(v34, 0i64);
  *((_QWORD *)this + 18) = *v31;
  *v31 = 0i64;
  if ( !*((_BYTE *)this + 233) )
    *((_QWORD *)this + 22) = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 60i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
  inited = CTls13Context::GenerateApplicationWriteKeys(
             (CTls13ServerContext *)((char *)this + 1000),
             v5,
             *((_QWORD *)this + 74),
             (unsigned __int64 *)this + 20,
             (unsigned __int64 *)this + 21,
             (enum eSslErrorState *)&v37);
  if ( inited )
  {
    v7 = v37;
    goto LABEL_6;
  }
  if ( !(*(unsigned __int8 (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 384i64))(this) )
  {
    inited = CTls13Context::PopulateSecTrafficSecret(
               (__int64)this + 1000,
               v5,
               1,
               2u,
               *((_QWORD *)this + 1),
               v41[0],
               *((_WORD *)v40 + 2));
    if ( inited )
    {
      v7 = 610;
      goto LABEL_6;
    }
    inited = CTls13Context::PopulateSecTrafficSecret((__int64)this + 1000, v5, 0, 2u, *((_QWORD *)this + 1), 0, 0);
    if ( inited )
    {
      v7 = 609;
      goto LABEL_6;
    }
    inited = CTls13Context::PopulateSecTrafficSecret((__int64)this + 1000, v5, 1, 3u, *((_QWORD *)this + 1), 0, 0);
    if ( inited )
    {
      v7 = 612;
      goto LABEL_6;
    }
  }
  v35 = *((_BYTE *)this + 233);
  *((_WORD *)this + 16) |= 0xCu;
  if ( !v35 )
  {
    v35 = 0;
    if ( *((_QWORD *)this + 19) )
    {
      SslFreeObject(*((_QWORD *)this + 19), 0i64);
      v35 = *((_BYTE *)this + 233);
    }
  }
  *((_QWORD *)this + 19) = *v30;
  *v30 = 0i64;
  if ( !v35 )
    *((_QWORD *)this + 23) = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 59i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
  *((_BYTE *)this + 1216) = 3;
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);
// 18006BC00: using guessed type char var_D0[8];

//----- (000000018006C430) ----------------------------------------------------
__int64 __fastcall CTls13Context::GenerateHandshakeWriteKeys(
        CTls13Context *this,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        unsigned __int16 a5,
        unsigned int a6,
        char a7,
        unsigned __int64 *a8,
        unsigned __int64 *a9,
        enum eSslErrorState *a10)
{
  __int64 *v14; // r15
  __int64 result; // rax
  unsigned int HandshakeKey; // r12d

  if ( !a2 )
    return 87i64;
  if ( !a3 )
    return 87i64;
  if ( !a4 )
    return 87i64;
  if ( !a8 )
    return 87i64;
  if ( !a9 )
    return 87i64;
  if ( *a8 )
    return 87i64;
  if ( *a9 )
    return 87i64;
  if ( !a10 )
    return 87i64;
  if ( !*((_QWORD *)this + 5) )
    return 87i64;
  v14 = (__int64 *)((char *)this + 48);
  if ( *((_QWORD *)this + 6) )
    return 87i64;
  if ( a7
    || (CTls13Context::FreeEarlyKey(this),
        result = SslExtractEarlyKey(a2, 0i64, (char *)this + 104, a5, a6, 0i64, 0),
        !(_DWORD)result) )
  {
    HandshakeKey = SslExtractHandshakeKey(a2, a3, *((_QWORD *)this + 5), *((_QWORD *)this + 13), v14, 0i64, 0);
    CTls13Context::FreeEarlyKey(this);
    SslFreeObject(*((_QWORD *)this + 5), 0i64);
    *((_QWORD *)this + 5) = 0i64;
    if ( HandshakeKey )
    {
      *(_DWORD *)a10 = 710;
      return HandshakeKey;
    }
    else
    {
      return CTls13Context::ExpandTrafficAndWriteKeys(
               this,
               a2,
               *v14,
               a4,
               (unsigned __int64 *)this + 7,
               (unsigned __int64 *)this + 8,
               a8,
               a9,
               a10);
    }
  }
  else
  {
    *(_DWORD *)a10 = 709;
  }
  return result;
}
// 1800984B0: using guessed type __int64 __fastcall SslExtractHandshakeKey(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 1800984B8: using guessed type __int64 __fastcall SslExtractEarlyKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018006C5E0) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::GenerateHello(CTls13ClientContext *this, struct SPBuffer *a2)
{
  __int64 v4; // r15
  CCipherMill *v5; // rcx
  __int64 v6; // r10
  unsigned int OutputBuffer; // ebx
  __int16 *v8; // rsi
  __int64 v9; // rdx
  unsigned int v10; // r8d
  __int16 v11; // r14
  char v12; // al
  bool v13; // zf
  unsigned __int8 v14; // si
  unsigned int v15; // eax
  int v16; // r8d
  int v17; // edx
  CTls13ClientContext *v18; // rcx
  __int64 v19; // rax
  unsigned __int8 v20; // si
  unsigned __int16 *v21; // r13
  __int64 v22; // rcx
  unsigned int v23; // eax
  unsigned int v24; // edx
  HLOCAL Memory; // rax
  unsigned int ClientHello; // eax
  char v28[4]; // [rsp+50h] [rbp-B0h] BYREF
  unsigned int v29; // [rsp+54h] [rbp-ACh] BYREF
  unsigned int v30; // [rsp+58h] [rbp-A8h] BYREF
  unsigned __int16 *v31; // [rsp+60h] [rbp-A0h]
  unsigned __int64 AProvider; // [rsp+68h] [rbp-98h] BYREF
  __int16 v33[2]; // [rsp+70h] [rbp-90h] BYREF
  int v34; // [rsp+74h] [rbp-8Ch]
  int v35; // [rsp+78h] [rbp-88h]
  __int16 v36; // [rsp+7Ch] [rbp-84h]
  int v37; // [rsp+80h] [rbp-80h]
  int v38; // [rsp+84h] [rbp-7Ch]
  unsigned int v39[68]; // [rsp+90h] [rbp-70h] BYREF

  AProvider = CCipherMill::GetAProvider(this);
  v4 = AProvider;
  memset_0(v39, 0, sizeof(v39));
  v6 = *((_QWORD *)this + 10);
  v29 = 68;
  if ( !v6 )
  {
    OutputBuffer = 1359;
    goto LABEL_40;
  }
  OutputBuffer = CCipherMill::BuildCipherSuiteList(
                   (__int64)this + 912,
                   *(unsigned int **)(v6 + 184),
                   *(_DWORD *)(v6 + 176),
                   *(_DWORD *)(v6 + 192),
                   v6,
                   *((_DWORD *)this + 16),
                   (__int64)v39,
                   &v29,
                   (_QWORD *)this + 114,
                   (_WORD *)this + 460);
  if ( OutputBuffer )
    goto LABEL_40;
  v8 = (__int16 *)((char *)this + 474);
  CCipherMill::GetSignatureSuiteList(v5, (CTls13ClientContext *)((char *)this + 474));
  v9 = *((_QWORD *)this + 10);
  v10 = *(_DWORD *)(v9 + 196);
  if ( v10 )
  {
    OutputBuffer = CTlsSignatureSuiteList::Blacklist(
                     (CTls13ClientContext *)((char *)this + 474),
                     *(struct _TLS_PARAMETERS **)(v9 + 200),
                     v10);
    if ( OutputBuffer )
      goto LABEL_40;
    v11 = *v8;
    if ( !*v8 )
    {
      v5 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 26i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
      OutputBuffer = -2146893007;
      goto LABEL_40;
    }
  }
  else
  {
    v11 = *v8;
  }
  v31 = (unsigned __int16 *)((char *)this + 476);
  v12 = (*(__int64 (__fastcall **)(CTls13ClientContext *))(*(_QWORD *)this + 384i64))(this);
  v35 = 1;
  v38 = 1;
  v28[0] = 0;
  v13 = *((_DWORD *)this + 17) == 100;
  v14 = 0;
  *((_BYTE *)this + 1649) = v12 != 0 ? 0x20 : 0;
  v33[0] = 0;
  v34 = 22;
  v37 = 22;
  v36 = 0;
  if ( v13 )
  {
    v15 = CTls13Context::SetCcsRecordInfo(
            (CTls13ClientContext *)((char *)this + 1368),
            (struct CTlsRecord::CMessageInfo *)v33,
            v28);
    OutputBuffer = v15;
    if ( v15 )
    {
      v16 = v15;
LABEL_11:
      v17 = 50;
LABEL_12:
      v18 = this;
LABEL_13:
      CSslContext::SetError((__int64)v18, v17, v16);
      goto LABEL_40;
    }
    v14 = v28[0];
  }
  v19 = v14;
  v20 = v14 + 1;
  v21 = (unsigned __int16 *)&v33[6 * v19];
  OutputBuffer = CTls13ClientHandshake::ComputeClientHelloSize(
                   (CTls13ClientContext *)((char *)this + 1656),
                   v4,
                   v29,
                   v11,
                   v21);
  if ( OutputBuffer )
  {
    v16 = OutputBuffer;
    goto LABEL_11;
  }
  v22 = *((_QWORD *)this + 197);
  v30 = 0;
  v23 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int16 *, unsigned int *))(*(_QWORD *)v22 + 16i64))(
          v22,
          v20,
          v33,
          &v30);
  OutputBuffer = v23;
  v18 = this;
  if ( v23 )
  {
    v16 = v23;
    v17 = 51;
    goto LABEL_13;
  }
  OutputBuffer = CSsl3TlsContext::AllocateOutputBuffer(this, a2, v30);
  if ( OutputBuffer )
    goto LABEL_20;
  OutputBuffer = (*(__int64 (__fastcall **)(_QWORD, struct SPBuffer *))(**((_QWORD **)this + 197) + 24i64))(
                   *((_QWORD *)this + 197),
                   a2);
  if ( OutputBuffer )
    goto LABEL_20;
  if ( *((_QWORD *)this + 110) )
  {
    (*(void (__fastcall **)(CTls13ClientContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 110) = 0i64;
  }
  v13 = *((_DWORD *)this + 17) == 40;
  *((_DWORD *)this + 218) = 0;
  if ( !v13 )
  {
    OutputBuffer = CTls13Context::GenerateCcsRecord((CTls13ClientContext *)((char *)this + 1368));
    if ( OutputBuffer )
      goto LABEL_20;
LABEL_32:
    if ( this == (CTls13ClientContext *)-272i64 )
    {
      OutputBuffer = 1359;
      goto LABEL_20;
    }
    ClientHello = CTls13ClientHandshake::GenerateClientHello(
                    (CTls13ClientContext *)((char *)this + 1656),
                    v29,
                    v39,
                    v11,
                    v31,
                    (PUCHAR)this + 272);
    OutputBuffer = ClientHello;
    if ( ClientHello )
    {
      v16 = ClientHello;
      goto LABEL_21;
    }
    goto LABEL_40;
  }
  v24 = *v21;
  *((_DWORD *)this + 218) = v24;
  Memory = CSslContext::GetMemory(this, v24);
  *((_QWORD *)this + 110) = Memory;
  if ( !Memory )
  {
    OutputBuffer = 14;
LABEL_20:
    v16 = OutputBuffer;
LABEL_21:
    v17 = 52;
    goto LABEL_12;
  }
  if ( !*((_BYTE *)this + 1649) )
    goto LABEL_32;
  OutputBuffer = GenerateRandomBits((PUCHAR)this + 1617, *((unsigned __int8 *)this + 1649));
  if ( !OutputBuffer )
    goto LABEL_32;
LABEL_40:
  if ( v4 )
    CCipherMill::DeferenceProvider(v5, &AProvider);
  return OutputBuffer;
}
// 18006C6B4: variable 'v5' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 18006C5E0: using guessed type char var_190[4];

//----- (000000018006C9C4) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::GenerateHelloRetryRequest(CTls13ServerContext *this, struct SPBuffer *a2)
{
  __int64 *v2; // rax
  __int64 v5; // rdx
  CTls13ServerHandshake *v6; // r15
  unsigned int OutputBuffer; // edi
  int v8; // edx
  CTls13ServerContext *v9; // rcx
  __int64 result; // rax
  __int64 v11; // rcx
  CTls13Context *v12; // rcx
  __int64 v13; // rax
  unsigned int v14; // r8d
  __int64 v15; // rdx
  char v16[4]; // [rsp+30h] [rbp-30h] BYREF
  unsigned int v17; // [rsp+34h] [rbp-2Ch] BYREF
  unsigned __int16 v18[2]; // [rsp+38h] [rbp-28h] BYREF
  int v19; // [rsp+3Ch] [rbp-24h]
  int v20; // [rsp+40h] [rbp-20h]
  __int16 v21; // [rsp+44h] [rbp-1Ch] BYREF
  int v22; // [rsp+48h] [rbp-18h]
  int v23; // [rsp+4Ch] [rbp-14h]

  v2 = (__int64 *)*((_QWORD *)this + 1);
  if ( v2 )
    v5 = *v2;
  else
    v5 = 0i64;
  v18[0] = 0;
  v6 = (CTls13ServerContext *)((char *)this + 1288);
  v19 = 22;
  v20 = 1;
  v21 = 0;
  v22 = 22;
  v23 = 1;
  v16[0] = 1;
  OutputBuffer = CTls13ServerHandshake::ComputeServerHelloOrHRRSize(
                   (CTls13ServerContext *)((char *)this + 1288),
                   v5,
                   0,
                   v18);
  if ( OutputBuffer
    || (OutputBuffer = CTls13Context::SetCcsRecordInfo(
                         (CTls13ServerContext *)((char *)this + 1000),
                         (struct CTlsRecord::CMessageInfo *)&v21,
                         v16)) != 0 )
  {
    v8 = 1256;
LABEL_6:
    v9 = this;
LABEL_7:
    CSslContext::SetError((__int64)v9, v8, OutputBuffer);
    return OutputBuffer;
  }
  v11 = *((_QWORD *)this + 151);
  v17 = 0;
  OutputBuffer = (*(__int64 (__fastcall **)(__int64, _QWORD, unsigned __int16 *, unsigned int *))(*(_QWORD *)v11 + 16i64))(
                   v11,
                   (unsigned __int8)v16[0],
                   v18,
                   &v17);
  v9 = this;
  if ( OutputBuffer )
  {
    v8 = 1257;
    goto LABEL_7;
  }
  OutputBuffer = CSsl3TlsContext::AllocateOutputBuffer(this, a2, v17);
  if ( OutputBuffer
    || (OutputBuffer = (*(__int64 (__fastcall **)(_QWORD, struct SPBuffer *))(**((_QWORD **)this + 151) + 24i64))(
                         *((_QWORD *)this + 151),
                         a2)) != 0 )
  {
LABEL_12:
    v8 = 1258;
    goto LABEL_6;
  }
  if ( (*((_BYTE *)this + 32) & 1) != 0 )
  {
    v13 = *((_QWORD *)this + 1);
    if ( v13 )
    {
      v14 = *(_DWORD *)(v13 + 28);
LABEL_18:
      v15 = *(_QWORD *)v13;
      goto LABEL_20;
    }
  }
  v13 = *((_QWORD *)this + 1);
  v14 = 0;
  if ( v13 )
    goto LABEL_18;
  v15 = 0i64;
LABEL_20:
  OutputBuffer = CTls13Context::GenerateClientHelloHash(
                   v12,
                   v15,
                   v14,
                   *((unsigned __int8 **)this + 110),
                   (unsigned int *)this + 218);
  v9 = this;
  if ( OutputBuffer )
  {
    v8 = 1012;
    goto LABEL_7;
  }
  OutputBuffer = CSsl3TlsServerContext::InitUpdateClientHash(this);
  if ( OutputBuffer )
  {
    v8 = 1012;
    goto LABEL_6;
  }
  OutputBuffer = CTls13ServerHandshake::GenerateServerHelloOrHRR(v6, 0, 0i64);
  if ( OutputBuffer )
    goto LABEL_12;
  result = CTls13Context::GenerateCcsRecord((CTls13ServerContext *)((char *)this + 1000));
  OutputBuffer = result;
  if ( (_DWORD)result )
    goto LABEL_12;
  return result;
}
// 18006CB39: variable 'v12' is possibly undefined
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 18006C9C4: using guessed type char var_30[4];

//----- (000000018006CBC0) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::GenerateNewSessionTicket(CTls13ServerContext *this, struct SPBuffer *a2)
{
  CTls13ServerHandshake *v2; // rbp
  unsigned int OutputBuffer; // edi
  int v6; // edx
  CTls13ServerContext *v7; // rcx
  __int64 v9; // rcx
  _QWORD *v10; // rax
  __int64 v11; // rdx
  unsigned int v12; // [rsp+40h] [rbp-38h] BYREF
  unsigned __int16 v13[2]; // [rsp+48h] [rbp-30h] BYREF
  int v14; // [rsp+4Ch] [rbp-2Ch]
  int v15; // [rsp+50h] [rbp-28h]

  v2 = (CTls13ServerContext *)((char *)this + 1288);
  v13[0] = 0;
  v14 = 22;
  v15 = 2;
  OutputBuffer = CTls13ServerHandshake::ComputeNewSessionTicketSize((CTls13ServerContext *)((char *)this + 1288), v13);
  if ( OutputBuffer )
  {
    v6 = 1500;
LABEL_3:
    v7 = this;
LABEL_4:
    CSslContext::SetError((__int64)v7, v6, OutputBuffer);
    return OutputBuffer;
  }
  v9 = *((_QWORD *)this + 151);
  v12 = 0;
  OutputBuffer = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int16 *, unsigned int *))(*(_QWORD *)v9 + 16i64))(
                   v9,
                   1i64,
                   v13,
                   &v12);
  v7 = this;
  if ( OutputBuffer )
  {
    v6 = 1501;
    goto LABEL_4;
  }
  OutputBuffer = CSsl3TlsContext::AllocateOutputBuffer(this, a2, v12);
  if ( OutputBuffer
    || (OutputBuffer = (*(__int64 (__fastcall **)(_QWORD, struct SPBuffer *))(**((_QWORD **)this + 151) + 24i64))(
                         *((_QWORD *)this + 151),
                         a2)) != 0
    || (OutputBuffer = CTls13ServerHandshake::GenerateNewSessionTicket(v2)) != 0 )
  {
    v6 = 1502;
    goto LABEL_3;
  }
  if ( !(*(unsigned __int8 (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 384i64))(this) )
  {
    v10 = (_QWORD *)*((_QWORD *)this + 1);
    v11 = v10 ? *v10 : 0i64;
    OutputBuffer = CTls13Context::PopulateSecTrafficSecret(
                     (__int64)this + 1000,
                     v11,
                     1,
                     3u,
                     (__int64)v10,
                     0,
                     *((_WORD *)a2 + 2));
    if ( OutputBuffer )
    {
      v6 = 612;
      goto LABEL_3;
    }
  }
  return 0i64;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 18006CBC0: using guessed type unsigned __int16 var_30[2];

//----- (000000018006CD58) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::GeneratePostHandshakeCertificateRequest(
        CTls13ServerContext *this,
        struct SPBuffer *a2)
{
  unsigned int CertificateRequestContext; // edi
  int v5; // edx
  CTls13ServerContext *v6; // rcx
  __int64 result; // rax
  __int64 v8; // rcx
  unsigned int v9; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int16 v10[2]; // [rsp+38h] [rbp-30h] BYREF
  int v11; // [rsp+3Ch] [rbp-2Ch]
  int v12; // [rsp+40h] [rbp-28h]

  v11 = 22;
  v10[0] = 0;
  v12 = 3;
  if ( !*((_BYTE *)this + 1506)
    || !*((_BYTE *)this + 1233)
    || *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) == 4
    || (*((_DWORD *)this + 34) & 0x100i64) == 0 )
  {
    return 2148074333i64;
  }
  CertificateRequestContext = CTls13ServerContext::GenerateCertificateRequestContext(this);
  if ( CertificateRequestContext )
  {
    v5 = 1259;
LABEL_7:
    v6 = this;
LABEL_8:
    CSslContext::SetError((__int64)v6, v5, CertificateRequestContext);
    return CertificateRequestContext;
  }
  CertificateRequestContext = CTls13ServerHandshake::ComputeCertificateRequestSize(
                                (CTls13ServerContext *)((char *)this + 1288),
                                v10);
  if ( CertificateRequestContext )
  {
    v5 = 1260;
    goto LABEL_7;
  }
  v8 = *((_QWORD *)this + 151);
  v9 = 0;
  CertificateRequestContext = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int16 *, unsigned int *))(*(_QWORD *)v8 + 16i64))(
                                v8,
                                1i64,
                                v10,
                                &v9);
  v6 = this;
  if ( CertificateRequestContext )
  {
    v5 = 1261;
    goto LABEL_8;
  }
  CertificateRequestContext = CSsl3TlsContext::AllocateOutputBuffer(this, a2, v9);
  if ( CertificateRequestContext
    || (CertificateRequestContext = (*(__int64 (__fastcall **)(_QWORD, struct SPBuffer *))(**((_QWORD **)this + 151)
                                                                                         + 24i64))(
                                      *((_QWORD *)this + 151),
                                      a2)) != 0
    || (result = CTls13ServerHandshake::GenerateCertificateRequest((CTls13ServerContext *)((char *)this + 1288)),
        (CertificateRequestContext = result) != 0) )
  {
    v5 = 1262;
    goto LABEL_7;
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (000000018006CEE0) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::GenerateResponse(CTls13ClientContext *this, struct SPBuffer *a2)
{
  unsigned int CertVerifyHashForRemoteSigning; // edi
  int v5; // ecx
  char v6; // cl
  __int64 v7; // rax
  __int64 v8; // rax
  unsigned __int8 v10; // [rsp+30h] [rbp+8h] BYREF

  CertVerifyHashForRemoteSigning = 0;
  v5 = *((_DWORD *)this + 17) - 100;
  if ( v5 )
  {
    if ( v5 == 1 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 23i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
      v10 = 0;
      CertVerifyHashForRemoteSigning = CSsl3TlsClientContext::CheckForClientCertificatePrivateKeys(this, &v10);
      if ( !v10 )
      {
        if ( *((_BYTE *)this + 1315)
          && *((_BYTE *)this + 266)
          && *((_QWORD *)this + 116)
          && !*((_QWORD *)this + 117)
          && !*((_DWORD *)this + 236) )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 24i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
          }
          CertVerifyHashForRemoteSigning = CTls13ClientContext::GenerateCertVerifyHashForRemoteSigning(this);
          if ( CertVerifyHashForRemoteSigning == 590610 )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 25i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
            }
            *((_DWORD *)this + 17) = 77;
          }
        }
        else
        {
          CertVerifyHashForRemoteSigning = CTls13ClientContext::GenerateClientFinished(this, a2);
          if ( !CertVerifyHashForRemoteSigning )
          {
            if ( !*((_BYTE *)this + 1601) )
            {
              *((_WORD *)this + 16) |= 0xCu;
              v6 = *((_BYTE *)this + 233);
              if ( !v6 && *((_QWORD *)this + 19) )
              {
                SslFreeObject(*((_QWORD *)this + 19), 0i64);
                v6 = *((_BYTE *)this + 233);
              }
              v7 = *((_QWORD *)this + 21);
              *((_QWORD *)this + 21) = 0i64;
              *((_QWORD *)this + 19) = v7;
              if ( !v6 )
                *((_QWORD *)this + 23) = 0i64;
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
              {
                WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 59i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
              }
            }
            v8 = *(_QWORD *)this;
            *((_BYTE *)this + 1584) = 3;
            (*(void (__fastcall **)(CTls13ClientContext *))(v8 + 448))(this);
            CertVerifyHashForRemoteSigning = 0;
            *((_BYTE *)this + 1601) = 1;
          }
        }
      }
    }
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
    *((_DWORD *)this + 16) = *((_DWORD *)this + 463);
    CertVerifyHashForRemoteSigning = (*(__int64 (__fastcall **)(CTls13ClientContext *, struct SPBuffer *))(*(_QWORD *)this + 216i64))(
                                       this,
                                       a2);
    if ( !CertVerifyHashForRemoteSigning )
      *((_DWORD *)this + 17) = 71;
  }
  return CertVerifyHashForRemoteSigning;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018006D160) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::GenerateResponse(CTls13ServerContext *this, struct SPBuffer *a2)
{
  unsigned int ClientHelloResponse; // edi
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  __int64 v9; // rcx

  ClientHelloResponse = 0;
  v5 = *((_DWORD *)this + 17) - 4;
  if ( v5 )
  {
    v6 = v5 - 89;
    if ( !v6 )
    {
LABEL_17:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 60i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
      ClientHelloResponse = CTls13ServerContext::GenerateClientHelloResponse(this, a2);
      if ( !ClientHelloResponse )
        *((_DWORD *)this + 17) = 70;
      return ClientHelloResponse;
    }
    v7 = v6 - 5;
    if ( v7 )
    {
      v8 = v7 - 1;
      if ( v8 )
      {
        if ( v8 == 3 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 62i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
          }
          ClientHelloResponse = CTls13ServerContext::GenerateNewSessionTicket(this, a2);
          if ( !ClientHelloResponse )
          {
            v9 = *(_QWORD *)this;
            *((_BYTE *)this + 1216) = 3;
            (*(void (__fastcall **)(CTls13ServerContext *))(v9 + 448))(this);
            if ( (*((_DWORD *)this + 34) & 0x400000) == 0 )
              CSessionCacheManager::FinishCacheAddItem(CSessionCacheManager::m_pSessionCacheManager, this);
          }
        }
        return ClientHelloResponse;
      }
      goto LABEL_17;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 61i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
    ClientHelloResponse = CTls13ServerContext::GenerateHelloRetryRequest(this, a2);
    if ( !ClientHelloResponse )
      *((_DWORD *)this + 17) = 71;
  }
  else if ( *((_BYTE *)this + 1506) && (*((_DWORD *)this + 34) & 0x100i64) != 0 )
  {
    if ( *((_BYTE *)this + 1233) && !*((_BYTE *)this + 1232) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 63i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
      return (unsigned int)CTls13ServerContext::GeneratePostHandshakeCertificateRequest(this, a2);
    }
  }
  else
  {
    return 590688;
  }
  return ClientHelloResponse;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (000000018006D350) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::GenerateTlsAlertMessage(
        CTls13ClientContext *this,
        struct SPBuffer *a2,
        char a3,
        char a4)
{
  bool v4; // al
  __int64 v5; // r10

  v4 = 0;
  if ( (*((_BYTE *)this + 32) & 4) != 0 )
  {
    v5 = *((_QWORD *)this + 1);
    if ( v5 )
      v4 = *(_DWORD *)(v5 + 28) != 0;
  }
  return CTls13Context::GenerateTlsAlertMessage(
           (CTls13ClientContext *)((char *)this + 1368),
           a3,
           a4,
           0,
           v4,
           (__int64 **)this,
           a2);
}

//----- (000000018006D3B0) ----------------------------------------------------
__int64 __fastcall CTls13Context::GenerateTlsAlertMessage(
        CTls13Context *this,
        char a2,
        char a3,
        char a4,
        char a5,
        __int64 **a6,
        struct SPBuffer *a7)
{
  __int64 result; // rax
  __int64 *v10; // rax
  __int64 v11; // rdx
  int v12; // eax
  unsigned int v13; // edi
  char v14[8]; // [rsp+40h] [rbp-30h] BYREF
  char v15[8]; // [rsp+48h] [rbp-28h] BYREF
  unsigned int v16; // [rsp+50h] [rbp-20h] BYREF
  __int16 v17[2]; // [rsp+58h] [rbp-18h] BYREF
  int v18; // [rsp+5Ch] [rbp-14h]
  int v19; // [rsp+60h] [rbp-10h]

  v14[0] = a2;
  v15[0] = a3;
  if ( !a6 || !a7 )
    return 2148074333i64;
  v17[0] = 2;
  v18 = 21;
  v16 = 0;
  v19 = a5 != 0 ? 2 : 0;
  result = (*(__int64 (__fastcall **)(_QWORD, __int64, __int16 *, unsigned int *))(**((_QWORD **)this + 26) + 16i64))(
             *((_QWORD *)this + 26),
             1i64,
             v17,
             &v16);
  if ( !(_DWORD)result )
  {
    result = CSsl3TlsContext::AllocateOutputBuffer((CSsl3TlsContext *)a6, a7, v16);
    if ( !(_DWORD)result )
    {
      result = (*(__int64 (__fastcall **)(_QWORD, struct SPBuffer *))(**((_QWORD **)this + 26) + 24i64))(
                 *((_QWORD *)this + 26),
                 a7);
      if ( !(_DWORD)result )
      {
        result = (*(__int64 (__fastcall **)(_QWORD, __int64, char *))(**((_QWORD **)this + 26) + 32i64))(
                   *((_QWORD *)this + 26),
                   1i64,
                   v14);
        if ( !(_DWORD)result )
        {
          result = (*(__int64 (__fastcall **)(_QWORD, __int64, char *))(**((_QWORD **)this + 26) + 32i64))(
                     *((_QWORD *)this + 26),
                     1i64,
                     v15);
          if ( !(_DWORD)result )
          {
            if ( !*((_BYTE *)this + 201)
              && a5
              && ((v10 = a6[1]) == 0i64 ? (v11 = 0i64) : (v11 = *v10),
                  v12 = CTls13Context::PopulateSecTrafficSecret(
                          (__int64)this,
                          v11,
                          a4,
                          *((_BYTE *)this + 216),
                          (__int64)v10,
                          0,
                          *((_WORD *)a7 + 2)),
                  (v13 = v12) != 0) )
            {
              CSslContext::SetError((__int64)a6, 609, v12);
              return v13;
            }
            else
            {
              return (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 26) + 40i64))(*((_QWORD *)this + 26));
            }
          }
        }
      }
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 18006D3B0: using guessed type char var_30[8];
// 18006D3B0: using guessed type char var_28[8];
// 18006D3B0: using guessed type __int16 var_18[2];

//----- (000000018006D5A0) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::GenerateTlsAlertMessage(
        CTls13ServerContext *this,
        struct SPBuffer *a2,
        char a3,
        char a4)
{
  bool v4; // al
  __int64 v5; // r10

  v4 = 0;
  if ( (*((_BYTE *)this + 32) & 4) != 0 )
  {
    v5 = *((_QWORD *)this + 1);
    if ( v5 )
      v4 = *(_DWORD *)(v5 + 28) != 0;
  }
  return CTls13Context::GenerateTlsAlertMessage(
           (CTls13ServerContext *)((char *)this + 1000),
           a3,
           a4,
           1,
           v4,
           (__int64 **)this,
           a2);
}

//----- (000000018006D600) ----------------------------------------------------
__int64 __fastcall CTls13Context::HashPostHandshakeMessage(
        CTls13Context *this,
        __int64 a2,
        __int64 a3,
        unsigned __int8 *a4,
        unsigned int a5)
{
  _QWORD *v7; // rbx
  __int64 result; // rax

  if ( !*((_BYTE *)this + 233) || !a2 || !a5 || !a4 || !a3 )
    return 1359i64;
  if ( ((*a4 - 11) & 0xF9) != 0 || *a4 == 17 )
    return 0i64;
  v7 = (_QWORD *)((char *)this + 240);
  if ( *((_QWORD *)this + 30) )
    return SslHashHandshake(a2, *v7, a4, a5, 0);
  result = SslDuplicateTranscriptHash(a2, a3, (char *)this + 240, 0i64);
  if ( !(_DWORD)result )
    return SslHashHandshake(a2, *v7, a4, a5, 0);
  return result;
}
// 180098420: using guessed type __int64 __fastcall SslHashHandshake(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098558: using guessed type __int64 __fastcall SslDuplicateTranscriptHash(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018006D6B0) ----------------------------------------------------
__int64 __fastcall CTls13Context::ImportApplicationTrafficSecret(
        CTls13Context *this,
        __int64 a2,
        unsigned __int64 *a3,
        unsigned __int8 *a4,
        unsigned int a5)
{
  if ( a2 && a3 && a4 && a5 )
    return SslImportKey(a2, a3, L"OpaqueKeyBlob", a4, a5, 0);
  else
    return 87i64;
}
// 180082320: using guessed type wchar_t aOpaquekeyblob[14];
// 1800985A0: using guessed type __int64 __fastcall SslImportKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (000000018006D710) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::InitHandshakeHash(CTls13ClientContext *this, char a2)
{
  __int64 result; // rax
  __int64 v4; // r9
  unsigned int v5; // edi
  __int64 v6; // rdx
  __int64 v7; // r8

  result = CSsl3TlsContext::InitHandshakeHash(this, a2);
  v5 = result;
  if ( !(_DWORD)result )
  {
    v6 = *((_QWORD *)this + 110);
    if ( v6 )
    {
      v7 = *((unsigned int *)this + 218);
      if ( (_DWORD)v7 )
      {
        LOBYTE(v4) = 1;
        v5 = (*(__int64 (__fastcall **)(CTls13ClientContext *, __int64, __int64, __int64))(*(_QWORD *)this + 504i64))(
               this,
               v6,
               v7,
               v4);
        if ( *((_QWORD *)this + 110) )
        {
          (*(void (__fastcall **)(CTls13ClientContext *))(*(_QWORD *)this + 16i64))(this);
          *((_QWORD *)this + 110) = 0i64;
        }
        *((_DWORD *)this + 218) = 0;
      }
    }
    return v5;
  }
  return result;
}
// 18006D75A: variable 'v4' is possibly undefined
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (000000018006D7AC) ----------------------------------------------------
bool __fastcall CTls13Context::IsValidGenericExtensionType(__int16 a1)
{
  return a1 == 57 || a1 == -91;
}

//----- (000000018006D7D0) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::LookupEccCurveType(CTls13ServerContext *this, unsigned int a2)
{
  __int16 v2; // di
  __int64 result; // rax

  v2 = a2;
  if ( a2 > 0xFFFF )
    return 87i64;
  result = CSsl3TlsServerContext::LookupEccCurveType(this, a2);
  if ( !(_DWORD)result && *((_DWORD *)this + 16) == 4096 )
    return CTls13ServerContext::FindClientShare(this, v2, 0i64, 0i64);
  return result;
}

//----- (000000018006D824) ----------------------------------------------------
__int64 __fastcall CTls13Context::ParseCcsRecord(__int64 a1, __int64 a2, unsigned int a3, int a4, int a5)
{
  int v5; // r10d
  _BYTE *v6; // rax

  if ( !a2 )
    return 2148074333i64;
  if ( !a3 )
    return 2148074333i64;
  v5 = *(unsigned __int8 *)(a1 + 282);
  if ( (_BYTE)v5 == 0xFF )
    return 2148074333i64;
  v6 = (_BYTE *)(a2 + a3);
  if ( v6 && a4 == 1 && *v6 == 1 )
  {
    if ( (a5 & 0xFFFFFFFB) == 0 || *(_BYTE *)(a1 + 233) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
      return 2148074278i64;
    }
    else
    {
      *(_BYTE *)(a1 + 282) = v5 + 1;
      if ( (unsigned __int8)(v5 + 1) <= 5u )
      {
        return 0i64;
      }
      else
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          *(_BYTE *)(a1 + 282) = v5;
          WPP_SF_d(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x15u,
            (__int64)&WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids,
            v5);
        }
        return 2148074263i64;
      }
    }
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 19i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
    return 2148074248i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018006D958) ----------------------------------------------------
__int64 __fastcall CTls13Context::PopulateSecTrafficSecret(
        __int64 a1,
        __int64 a2,
        char a3,
        unsigned __int8 a4,
        __int64 a5,
        __int16 a6,
        __int16 a7)
{
  char v7; // r12
  __int64 v11; // rax
  __int64 v12; // rbx
  void *v13; // rdi
  __int64 v14; // rsi
  HLOCAL v15; // rax
  unsigned int CipherSuitePRFHashAlgorithm; // edi
  void *v17; // rcx
  unsigned int v19; // [rsp+88h] [rbp+10h]

  v7 = 0;
  if ( !a2 )
    return (unsigned int)-2146892963;
  if ( !a4 )
    return (unsigned int)-2146892963;
  if ( !a5 )
    return (unsigned int)-2146892963;
  v11 = *(unsigned __int8 *)(a1 + 200);
  if ( (unsigned __int8)v11 >= 4u )
    return (unsigned int)-2146892963;
  v12 = *(_QWORD *)(a1 + 8 * v11 + 168);
  if ( !v12 )
    return (unsigned int)-2146893052;
  v13 = *(void **)(v12 + 8);
  if ( v13 )
  {
    if ( *(_DWORD *)v12 >= 0x1C0u )
    {
      memset(v13, 0, 0x1C0ui64);
      v14 = *(_QWORD *)(v12 + 8);
      goto LABEL_12;
    }
    return (unsigned int)-2146893052;
  }
  v7 = 1;
  v15 = SPExternalAlloc(0x1C0u);
  *(_QWORD *)(v12 + 8) = v15;
  v14 = (__int64)v15;
  if ( !v15 )
  {
    CipherSuitePRFHashAlgorithm = -2146893056;
LABEL_15:
    v17 = *(void **)(v12 + 8);
    if ( v17 )
    {
      SPExternalFree(v17);
      *(_QWORD *)(v12 + 8) = 0i64;
    }
    *(_DWORD *)v12 = 0;
    return CipherSuitePRFHashAlgorithm;
  }
  *(_DWORD *)v12 = 448;
LABEL_12:
  if ( (unsigned int)StringCchCopyW((char *)v14, 64i64, (char *)(a5 + 202))
    || (unsigned int)StringCchCopyW((char *)(v14 + 128), 64i64, (char *)(a5 + 714)) )
  {
    CipherSuitePRFHashAlgorithm = -2146893052;
  }
  else
  {
    v19 = *(_DWORD *)(a5 + 28);
    CipherSuitePRFHashAlgorithm = SslGetCipherSuitePRFHashAlgorithm(a2, 772i64, v19, 0i64, v14 + 256, 0);
    if ( !CipherSuitePRFHashAlgorithm )
    {
      *(_WORD *)(v14 + 384) = *(_DWORD *)(a5 + 20) >> 3;
      *(_WORD *)(v14 + 386) = 12;
      *(_WORD *)(v14 + 388) = a6;
      *(_WORD *)(v14 + 390) = a7;
      *(_DWORD *)(v14 + 392) = (a3 != 0) + 1;
      CipherSuitePRFHashAlgorithm = CTls13Context::ExportTrafficSecret(
                                      (_QWORD *)a1,
                                      a2,
                                      v19,
                                      a3,
                                      a4,
                                      v14,
                                      *(_DWORD *)v12 - 400);
      if ( !CipherSuitePRFHashAlgorithm )
      {
        ++*(_BYTE *)(a1 + 200);
        return CipherSuitePRFHashAlgorithm;
      }
    }
  }
  if ( v7 )
    goto LABEL_15;
  return CipherSuitePRFHashAlgorithm;
}
// 180098438: using guessed type __int64 __fastcall SslGetCipherSuitePRFHashAlgorithm(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);

//----- (000000018006DB5C) ----------------------------------------------------
__int64 __fastcall CTls13Context::PreparseMessage(
        CTls13Context *this,
        struct SPBuffer *a2,
        struct CSsl3TlsContext *a3,
        char a4)
{
  const char *v6; // r9

  if ( !a2 || !a3 )
    return 2148074333i64;
  if ( *((_DWORD *)a3 + 17) == 4 && *((_DWORD *)a2 + 1) )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      v6 = "server";
      if ( !a4 )
        v6 = "client";
      WPP_SF_s(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x12u,
        (__int64)&WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids,
        v6);
    }
    *((_DWORD *)a3 + 17) = 78;
  }
  return 0i64;
}

//----- (000000018006DBE0) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::ProcessHandshake(
        CTls13ClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        struct CSessionCacheClientItem *a4)
{
  unsigned __int8 *v5; // r12
  unsigned int v6; // r13d
  __int64 v7; // r9
  unsigned int updated; // ebx
  unsigned int v9; // eax
  __int64 *v10; // rax
  __int64 v11; // rcx
  unsigned int v12; // eax
  int v13; // r8d
  int v14; // edx
  __int64 v15; // rdx
  __int64 v16; // rcx
  CCipherMill *v17; // rcx
  __int64 v18; // rdx
  int v19; // r15d
  __int64 v21; // rcx
  char v22; // bl
  __int64 v23; // rax
  __int64 v24; // rax
  const unsigned __int16 *v25; // r12
  struct CSessionCacheManager *v26; // rdx
  __int64 v27; // rcx
  struct CSessionCacheClientItem *v28; // r13
  __int64 v29; // rcx
  __int64 **v30; // r12
  __int64 *v31; // rax
  unsigned int v32; // ecx
  __int64 v33; // rdx
  _QWORD *v34; // r13
  unsigned int v35; // eax
  __int64 v36; // rcx
  char v37; // dl
  __int64 v38; // rcx
  __int64 v39; // rax
  __int64 *v40; // rax
  __int64 v41; // rdx
  __int64 *v43; // rax
  __int64 v44; // rdx
  _QWORD *v45; // rax
  __int64 v46; // rcx
  const char *v47; // r9
  __int64 *v48; // rax
  __int64 v49; // rdx
  _QWORD *v50; // r15
  unsigned int v51; // eax
  __int64 v52; // rcx
  CCipherMill *v53; // rcx
  CCipherMill *v54; // rcx
  unsigned __int8 v55; // r9
  int v56; // edx
  unsigned __int8 v57; // bl
  unsigned __int16 v58; // ax
  int v59; // ecx
  __int64 v60; // r10
  unsigned int v61; // edx
  unsigned int v62; // eax
  unsigned int v64; // [rsp+A0h] [rbp+50h] BYREF
  struct CSessionCacheClientItem *v65; // [rsp+A8h] [rbp+58h] BYREF

  v65 = a4;
  v64 = a3;
  *(_DWORD *)a4 = 0;
  *((_BYTE *)this + 1650) = 0;
  if ( !a3 || !a2 )
    return 87i64;
  v5 = a2 + 4;
  v6 = a3 - 4;
  v7 = *a2 << 8;
  updated = 0;
  v9 = v7 | *((unsigned __int8 *)this + 68);
  if ( v9 > 0xD35 )
  {
    if ( v9 != 3406 )
    {
      if ( v9 == 3407 )
      {
        v53 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 31i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
            v53 = WPP_GLOBAL_Control;
          }
          if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
            WPP_SF_(*((_QWORD *)v53 + 2), 32i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
        }
        return updated;
      }
      if ( v9 == 3881 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 37i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
        updated = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ParseCertificateVerify(
                    (__int64)this + 1656,
                    (__int64)v5,
                    v6);
        if ( !updated )
          *((_DWORD *)this + 17) = 54;
        return updated;
      }
      if ( v9 <= 0x1435 )
      {
LABEL_151:
        *((_WORD *)this + 48) = 2562;
        *((_DWORD *)this + 17) = 96;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_DD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x2Au,
            (__int64)&WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids,
            v7,
            96);
        return (unsigned int)-2146893018;
      }
      if ( v9 > 0x1437 )
      {
        if ( v9 != 6148 && v9 - 6222 > 1 )
          goto LABEL_151;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 40i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
        updated = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ParseKeyUpdate((__int64)this + 1656, v5, v6);
        if ( updated )
          return updated;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 41i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
        v45 = (_QWORD *)*((_QWORD *)this + 1);
        v46 = v45 ? *v45 : 0i64;
        updated = UpdateTrafficSecretAndDeriveNewKey(
                    v46,
                    (unsigned __int64 *)this + 182,
                    (unsigned __int64 *)this + 18,
                    (unsigned __int64 *)this + 22);
        if ( updated )
          return updated;
        goto LABEL_43;
      }
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        v47 = "full";
        if ( *((_DWORD *)this + 17) != 54 )
          v47 = "resumption";
        WPP_SF_s(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x26u,
          (__int64)&WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids,
          v47);
      }
      updated = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ParseFinished((__int64)this + 1656, v5, v6);
      if ( updated )
        return updated;
      updated = (*(__int64 (__fastcall **)(CTls13ClientContext *, unsigned __int8 *, _QWORD, _QWORD))(*(_QWORD *)this + 504i64))(
                  this,
                  a2,
                  v64,
                  0i64);
      if ( updated )
        return updated;
      v64 = 903;
      *(_DWORD *)v65 = 1;
      v48 = (__int64 *)*((_QWORD *)this + 1);
      if ( v48 )
        v49 = *v48;
      else
        v49 = 0i64;
      v50 = (_QWORD *)((char *)this + 160);
      v51 = CTls13Context::GenerateApplicationWriteKeys(
              (CTls13ClientContext *)((char *)this + 1368),
              v49,
              *((_QWORD *)this + 74),
              (unsigned __int64 *)this + 21,
              (unsigned __int64 *)this + 20,
              (enum eSslErrorState *)&v64);
      updated = v51;
      if ( !v51 )
      {
        *((_WORD *)this + 16) |= 0xAu;
        v52 = *((_QWORD *)this + 18);
        if ( v52 )
          SslFreeObject(v52, 0i64);
        *((_QWORD *)this + 18) = *v50;
        *v50 = 0i64;
        if ( !*((_BYTE *)this + 233) )
          *((_QWORD *)this + 22) = 0i64;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 60i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        goto LABEL_196;
      }
      v13 = v51;
LABEL_82:
      v14 = v64;
      goto LABEL_105;
    }
  }
  else if ( v9 != 3381 )
  {
    if ( v9 != 552 && v9 != 583 )
    {
      if ( v9 != 1028 )
      {
        if ( v9 <= 0x44D )
          goto LABEL_151;
        if ( v9 > 0x44F )
        {
          if ( v9 == 2118 )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 30i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
            }
            updated = CTls13ClientHandshake::ParseEncryptedExtensionsMsg(
                        (CTls13ClientContext *)((char *)this + 1656),
                        v5,
                        v6,
                        v7);
            if ( !updated )
              *((_DWORD *)this + 17) = ~(unsigned __int8)((unsigned __int64)*((unsigned int *)this + 34) >> 14) & 2 | 0x35;
            return updated;
          }
          if ( v9 == 2860 || v9 == 2869 )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 36i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
            }
            updated = CTls13Handshake<CTls13ClientContext,CTls13ExtClient>::ParseCertificateMsg(
                        (__int64)this + 1656,
                        v5,
                        v6);
            if ( !updated )
            {
              if ( (*((_DWORD *)this + 34) & 0x20000000) == 0
                || (RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64), 1u),
                    updated = CSessionCacheClientItem::UpdateRemoteEndpointBindings(*((CSessionCacheClientItem **)this
                                                                                    + 165)),
                    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64)),
                    !updated) )
              {
                CreateServerCertificateSerialChainProperty(this);
                updated = AutoVerifyServerCertificate(this);
                if ( !updated )
                  *((_DWORD *)this + 17) = 41;
              }
            }
            return updated;
          }
          goto LABEL_151;
        }
      }
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 39i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
      updated = CTls13ClientHandshake::ParseNewSessionTicket((CTls13ClientContext *)((char *)this + 1656), v5, v6);
      if ( updated )
        return updated;
      if ( *((_BYTE *)this + 1850) )
      {
        if ( !*((_QWORD *)this + 11) )
          return 1359;
        v10 = (__int64 *)*((_QWORD *)this + 1);
        v65 = 0i64;
        if ( v10 )
          v11 = *v10;
        else
          v11 = 0i64;
        v12 = SslExpandResumptionMasterKey(v11, *((_QWORD *)this + 180), *((_QWORD *)this + 74), &v65, 0i64, 0);
        updated = v12;
        if ( v12 )
        {
          v13 = v12;
          v14 = 613;
LABEL_105:
          CSslContext::SetError((__int64)this, v14, v13);
          return updated;
        }
        RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
        v15 = *((_QWORD *)this + 11);
        v16 = *(_QWORD *)(v15 + 16);
        if ( v16 )
        {
          SslFreeObject(v16, 0i64);
          v15 = *((_QWORD *)this + 11);
        }
        *(_QWORD *)(v15 + 16) = v65;
        RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
        if ( (*((_DWORD *)this + 34) & 0x8000i64) != 0 )
          CSessionCacheManager::FinishCacheAddItem(CSessionCacheManager::m_pSessionCacheManager, this);
        *((_BYTE *)this + 1850) = 0;
      }
LABEL_43:
      if ( *((_DWORD *)this + 17) != 79 )
        *((_DWORD *)this + 17) = 4;
      return updated;
    }
    if ( *((_DWORD *)this + 17) == 40 )
    {
      v17 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
        goto LABEL_53;
      v18 = 27i64;
    }
    else
    {
      v17 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
        goto LABEL_53;
      v18 = 28i64;
    }
    WPP_SF_(*((_QWORD *)v17 + 2), v18, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
LABEL_53:
    *((_QWORD *)this + 17) |= 0x8000ui64;
    v19 = *((_DWORD *)this + 17);
    updated = CTls13ClientHandshake::ParseServerHello((CTls13ClientContext *)((char *)this + 1656), v5, v6);
    if ( updated )
    {
      *((_DWORD *)this + 17) = v19;
      return updated;
    }
    if ( (*((_DWORD *)this + 16) & 0x2000) == 0 )
    {
      *((_QWORD *)this + 17) &= ~0x8000ui64;
      *((_DWORD *)this + 17) = v19;
      return (unsigned int)CTls13ClientContext::DowngradeClientToSsl3Tls(this);
    }
    if ( *((_DWORD *)this + 17) == 70 )
    {
      updated = (*(__int64 (__fastcall **)(CTls13ClientContext *, unsigned __int8 *, _QWORD, _QWORD))(*(_QWORD *)this + 504i64))(
                  this,
                  a2,
                  v64,
                  0i64);
      if ( updated )
        return updated;
      *(_DWORD *)v65 = 1;
      if ( (*((_DWORD *)this + 34) & 0x8000i64) != 0 )
      {
        v24 = *((_QWORD *)this + 165);
        v22 = 0;
        LOBYTE(v64) = 0;
        if ( v24 && *(_DWORD *)(v24 + 432) )
        {
          v25 = *(const unsigned __int16 **)(v24 + 368);
          v65 = 0i64;
          CSessionCacheManager::AcquireCacheTableLock(v21, v25, 0i64);
          RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64), 1u);
          v26 = CSessionCacheManager::m_pSessionCacheManager;
          *(_BYTE *)(*((_QWORD *)this + 165) + 236i64) = 0;
          updated = CSessionCacheClientItem::CloneCacheElement(*((CSessionCacheClientItem **)this + 165), v26, &v65);
          RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
          if ( updated )
          {
            CSessionCacheManager::ReleaseCacheTableLock(v27, v25, 0i64);
            return updated;
          }
          v28 = v65;
          if ( !v65 )
            return (unsigned int)-2146893052;
          RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)v65 + 72), 1u);
          *((_QWORD *)this + 165) = v28;
          *((_QWORD *)this + 11) = v28;
          RtlReleaseResource((PRTL_RESOURCE)((char *)v28 + 72));
          CSessionCacheManager::ReleaseCacheTableLock(v29, v25, 0i64);
          v22 = v64;
        }
      }
      else
      {
        v22 = 1;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 29i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
        v23 = *((_QWORD *)this + 15);
        if ( v23 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
        {
          *(_WORD *)(v23 + 64) |= 4u;
          *(_DWORD *)(v23 + 24) = 1;
        }
      }
      v30 = (__int64 **)((char *)this + 8);
      v64 = 100;
      if ( (*((_BYTE *)this + 32) & 1) != 0 && (v31 = *v30) != 0i64 )
      {
        v32 = *((_DWORD *)v31 + 7);
      }
      else
      {
        v31 = *v30;
        v32 = 0;
      }
      if ( v31 )
        v33 = *v31;
      else
        v33 = 0i64;
      v34 = (_QWORD *)((char *)this + 160);
      v35 = CTls13Context::GenerateHandshakeWriteKeys(
              (CTls13ClientContext *)((char *)this + 1368),
              v33,
              *((_QWORD *)this + 14),
              *((_QWORD *)this + 74),
              *((_WORD *)this + 17),
              v32,
              v22,
              (unsigned __int64 *)this + 21,
              (unsigned __int64 *)this + 20,
              (enum eSslErrorState *)&v64);
      updated = v35;
      if ( v35 )
      {
        v13 = v35;
        goto LABEL_82;
      }
      *((_WORD *)this + 16) |= 0xAu;
      v36 = *((_QWORD *)this + 18);
      if ( v36 )
        SslFreeObject(v36, 0i64);
      v37 = *((_BYTE *)this + 233);
      *((_QWORD *)this + 18) = *v34;
      *v34 = 0i64;
      if ( !v37 )
        *((_QWORD *)this + 22) = 0i64;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 60i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        v37 = *((_BYTE *)this + 233);
      }
      *((_WORD *)this + 16) |= 0xCu;
      if ( !v37 )
      {
        v38 = *((_QWORD *)this + 19);
        v37 = 0;
        if ( v38 )
        {
          SslFreeObject(v38, 0i64);
          v37 = *((_BYTE *)this + 233);
        }
      }
      *((_QWORD *)this + 19) = *((_QWORD *)this + 21);
      *((_QWORD *)this + 21) = 0i64;
      if ( !v37 )
        *((_QWORD *)this + 23) = 0i64;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 59i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
      v39 = *(_QWORD *)this;
      updated = 0;
      *((_BYTE *)this + 1584) = 2;
      if ( !(*(unsigned __int8 (__fastcall **)(CTls13ClientContext *))(v39 + 384))(this) )
      {
        v40 = *v30;
        if ( *v30 )
          v41 = *v40;
        else
          v41 = 0i64;
        updated = CTls13Context::PopulateSecTrafficSecret((__int64)this + 1368, v41, 1, 2u, (__int64)v40, 0, 0);
        if ( updated )
        {
          v14 = 610;
LABEL_104:
          v13 = updated;
          goto LABEL_105;
        }
        v43 = *v30;
        if ( *v30 )
          v44 = *v43;
        else
          v44 = 0i64;
        updated = CTls13Context::PopulateSecTrafficSecret((__int64)this + 1368, v44, 0, 2u, (__int64)v43, 0, 0);
        if ( updated )
        {
          v14 = 609;
          goto LABEL_104;
        }
      }
    }
    *((_BYTE *)this + 1315) = 0;
    return updated;
  }
  v54 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 33i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
    v54 = WPP_GLOBAL_Control;
  }
  if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) == 4 )
  {
    if ( v54 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v54 + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)v54 + 2), 34i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
    v55 = 10;
    updated = -2146893018;
    v56 = 400;
    goto LABEL_189;
  }
  updated = CTls13ClientHandshake::ParseCertificateRequest((CTls13ClientContext *)((char *)this + 1656), v5, v6);
  if ( !updated )
  {
    *((_WORD *)this + 673) = 0;
    v57 = 0;
    while ( 1 )
    {
      v58 = *((_WORD *)this + 673);
      if ( v58 >= 4u )
      {
LABEL_184:
        if ( !v58 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 35i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
          }
          v55 = 40;
          updated = -2146893007;
          v56 = 402;
LABEL_189:
          CSslContext::SetErrorAndFatalAlert((__int64)this, v56, updated, v55);
          return updated;
        }
        v62 = CSsl3TlsClientContext::CheckForClientCred(this);
        updated = v62;
        if ( v62 == -2146893024 )
        {
          *((_BYTE *)this + 1313) = 1;
          goto LABEL_193;
        }
        if ( v62 == 590624 )
        {
LABEL_193:
          updated = 0;
        }
        else if ( v62 )
        {
          return updated;
        }
        *((_BYTE *)this + 1315) = 1;
        if ( !*((_BYTE *)this + 1601) )
        {
          *((_DWORD *)this + 17) = 44;
          return updated;
        }
LABEL_196:
        *((_DWORD *)this + 17) = 101;
        return CTls13ClientContext::DetermineClientCredentialStatus(this);
      }
      v59 = g_Ssl3CertTypes[v57];
      if ( v59 != 2 )
      {
        v60 = *((_QWORD *)this + 10);
        v61 = *(_DWORD *)(v60 + 196);
        if ( !v61 )
          goto LABEL_181;
        if ( !IsSignatureTypeBlacklisted(*(_QWORD *)(v60 + 200), v61, v59, 0i64) )
          break;
      }
LABEL_182:
      if ( ++v57 >= 3u )
      {
        v58 = *((_WORD *)this + 673);
        goto LABEL_184;
      }
    }
    v58 = *((_WORD *)this + 673);
    v59 = g_Ssl3CertTypes[v57];
LABEL_181:
    *((_DWORD *)this + v58 + 337) = v59;
    ++*((_WORD *)this + 673);
    goto LABEL_182;
  }
  return updated;
}
// 18006DDB3: variable 'v7' is possibly undefined
// 18006E0A3: variable 'v21' is possibly undefined
// 18006E10A: variable 'v27' is possibly undefined
// 18006E15B: variable 'v29' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 1800858E8: using guessed type _DWORD g_Ssl3CertTypes[4];
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 180098450: using guessed type __int64 __fastcall SslExpandResumptionMasterKey(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018006E900) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::QueryKeyingMaterial(CTls13ClientContext *this, void *a2)
{
  __int64 *v2; // rax
  __int64 v4; // rdx

  v2 = (__int64 *)*((_QWORD *)this + 1);
  if ( v2 )
    v4 = *v2;
  else
    v4 = 0i64;
  return CSsl3TlsContext::QueryKeyingMaterialCommon(this, v4, *((_QWORD *)this + 183), 0i64, 0, a2);
}

//----- (000000018006E940) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::QueryKeyingMaterial(CTls13ServerContext *this, void *a2)
{
  __int64 *v2; // rax
  __int64 v4; // rdx

  v2 = (__int64 *)*((_QWORD *)this + 1);
  if ( v2 )
    v4 = *v2;
  else
    v4 = 0i64;
  return CSsl3TlsContext::QueryKeyingMaterialCommon(this, v4, *((_QWORD *)this + 137), 0i64, 0, a2);
}

//----- (000000018006E97C) ----------------------------------------------------
__int64 __fastcall CTls13Context::RetrieveGenericExtension(
        __int64 a1,
        __int16 a2,
        int a3,
        __int64 a4,
        unsigned __int16 a5)
{
  __int64 v5; // r10
  unsigned int v6; // ebp
  _WORD *v10; // rcx
  unsigned __int64 v11; // rdx
  char *v12; // rsi
  unsigned __int16 v13; // r14
  const void *v14; // r12
  char *v15; // rax
  __m128i v16; // xmm0
  unsigned int v17; // r15d
  unsigned int v18; // ebx
  char *v19; // rax
  __int128 Src; // [rsp+20h] [rbp-28h]

  v5 = *(_QWORD *)(a1 + 128);
  v6 = 0;
  Src = 0i64;
  if ( !v5 )
    goto LABEL_25;
  if ( *(_BYTE *)(a1 + 136) == 2 )
    goto LABEL_25;
  v10 = (_WORD *)(v5 + 8);
  v11 = v5 + 4 * (*(unsigned int *)(v5 + 4) + 2i64);
  if ( v5 + 8 >= v11 )
    goto LABEL_25;
  while ( (unsigned __int16)v10[1] != a3 || *v10 != a2 )
  {
    v10 += 2;
    if ( (unsigned __int64)v10 >= v11 )
      goto LABEL_25;
  }
  if ( 0xFFFF - a5 < 4 )
  {
    v12 = *(char **)(a1 + 160);
LABEL_21:
    v6 = -2146893052;
    goto LABEL_22;
  }
  v13 = a5 + 4;
  v14 = (const void *)(a4 - 4);
  if ( (unsigned __int16)(a5 + 4) > (unsigned int)~*(_DWORD *)(a1 + 152) )
    goto LABEL_25;
  if ( !*(_QWORD *)(a1 + 160) )
  {
    v15 = (char *)SPExternalAlloc(v13);
    *(_QWORD *)(a1 + 160) = v15;
    v12 = v15;
    if ( !v15 )
      goto LABEL_13;
    *(_DWORD *)(a1 + 152) = v13;
LABEL_19:
    memcpy_0(v12, v14, v13);
    ++*(_BYTE *)(a1 + 136);
    *(_BYTE *)(a1 + 8) = 0;
    goto LABEL_25;
  }
  v16 = *(__m128i *)(a1 + 152);
  *(_QWORD *)(a1 + 160) = 0i64;
  *(_DWORD *)(a1 + 152) = 0;
  v17 = _mm_cvtsi128_si32(v16);
  *((_QWORD *)&Src + 1) = v16.m128i_i64[1];
  if ( !v17 || !v16.m128i_i64[1] )
  {
    v12 = 0i64;
    goto LABEL_21;
  }
  v18 = v17 + v13;
  v19 = (char *)SPExternalAlloc(v18);
  *(_QWORD *)(a1 + 160) = v19;
  v12 = v19;
  if ( v19 )
  {
    *(_DWORD *)(a1 + 152) = v18;
    memcpy_0(v19, (const void *)v16.m128i_i64[1], v17);
    v12 += v17;
    goto LABEL_19;
  }
LABEL_13:
  v6 = -2146893056;
LABEL_22:
  if ( v12 )
  {
    SPExternalFree(v12);
    *(_QWORD *)(a1 + 160) = 0i64;
  }
  *(_DWORD *)(a1 + 152) = 0;
LABEL_25:
  if ( *((_QWORD *)&Src + 1) )
    SPExternalFree(*((void **)&Src + 1));
  return v6;
}

//----- (000000018006EB44) ----------------------------------------------------
__int64 __fastcall CTls13Context::ReturnGenericExtensions(CTls13Context *this)
{
  const void *v1; // rdx
  size_t v3; // rdi
  __int64 v4; // rcx
  bool v5; // zf
  unsigned int v6; // edx

  v1 = (const void *)*((_QWORD *)this + 20);
  if ( v1 )
  {
    v3 = *((unsigned int *)this + 38);
    if ( (_DWORD)v3 )
    {
      v4 = *((_QWORD *)this + 18);
      if ( v4 )
      {
        v5 = *(_DWORD *)v4 == 0;
        if ( *(_DWORD *)v4 )
        {
          if ( *(_DWORD *)v4 < (unsigned int)v3 )
          {
            *(_DWORD *)v4 = v3;
            v6 = -2146892950;
            *((_BYTE *)this + 8) = 1;
LABEL_12:
            *((_QWORD *)this + 18) = 0i64;
            *((_QWORD *)this + 16) = 0i64;
            memset((char *)this + 112, 0, 8ui64);
            *((_BYTE *)this + 120) = 0;
            return v6;
          }
          v5 = *(_DWORD *)v4 == 0;
        }
        if ( v5 )
        {
          *(_QWORD *)(v4 + 8) = v1;
          **((_DWORD **)this + 18) = v3;
        }
        else
        {
          memcpy_0(*(void **)(v4 + 8), v1, v3);
          **((_DWORD **)this + 18) = v3;
          SPExternalFree(*((void **)this + 20));
        }
        *((_QWORD *)this + 20) = 0i64;
        v6 = 590614;
        *((_DWORD *)this + 38) = 0;
        *((_BYTE *)this + 136) = 0;
        goto LABEL_12;
      }
    }
  }
  return 0i64;
}

//----- (000000018006EC1C) ----------------------------------------------------
__int64 __fastcall CTls13Context::SetCcsRecordInfo(CTls13Context *this, struct CTlsRecord::CMessageInfo *a2, char *a3)
{
  char v3; // al

  if ( *((_BYTE *)this + 32) || !*((_BYTE *)this + 201) )
    return 0i64;
  if ( a2 )
  {
    if ( a3 )
    {
      v3 = *a3;
      if ( *a3 != -1 )
      {
        *(_WORD *)a2 = 1;
        *a3 = v3 + 1;
        *(_QWORD *)((char *)a2 + 4) = 20i64;
        return 0i64;
      }
    }
  }
  return 87i64;
}

//----- (000000018006EC64) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::SetCertificateRequestContext(
        CTls13ClientContext *this,
        unsigned __int8 *a2,
        unsigned __int8 a3)
{
  size_t v4; // rbx
  HLOCAL v6; // rax

  v4 = a3;
  CTls13Context::FreeCertificateRequestContext((CTls13ClientContext *)((char *)this + 1368));
  if ( a2 && (_BYTE)v4 )
  {
    v6 = SPExternalAlloc(v4);
    *((_QWORD *)this + 199) = v6;
    if ( !v6 )
      return 2148074240i64;
    *((_BYTE *)this + 1600) = v4;
    memcpy_0(v6, a2, v4);
  }
  return 0i64;
}

//----- (000000018006ECE0) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::SetClientShare(CTls13ServerContext *this, unsigned int a2, unsigned __int64 a3)
{
  int ClientShare; // eax
  unsigned int v8; // edi
  unsigned __int16 v9; // [rsp+68h] [rbp+10h] BYREF
  unsigned __int8 *v10; // [rsp+78h] [rbp+20h] BYREF

  if ( a2 > 0xFFFF )
    return 87i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 66i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids, a2);
  v10 = 0i64;
  v9 = 0;
  ClientShare = CTls13ServerContext::FindClientShare(this, a2, (const unsigned __int8 **)&v10, &v9);
  v8 = ClientShare;
  if ( ClientShare )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x43u,
        (__int64)&WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids,
        a2,
        ClientShare);
    return v8;
  }
  else if ( (unsigned int)CTls13Context::SetPeerPublicKey((CTls13ServerContext *)((char *)this + 1000), a2, v10, v9, a3) )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 1202, -2146893048, 0x32u);
    return 2148074248i64;
  }
  else
  {
    return 0i64;
  }
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018006EDF0) ----------------------------------------------------
__int64 __fastcall CTls13Context::SetPeerPublicKey(
        CTls13Context *this,
        unsigned __int16 a2,
        const unsigned __int8 *a3,
        unsigned __int16 a4,
        unsigned __int64 a5)
{
  int v5; // esi
  const unsigned __int8 *v6; // r15
  unsigned int EccCurveFlags; // eax
  unsigned int v8; // ebx
  CCipherMill *v10; // rcx
  __int64 v11; // rdx
  int v12; // r14d
  unsigned int *v13; // rbx
  unsigned __int64 v14; // r12
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // rax
  void *v17; // rsp
  _DWORD *v18; // rax
  unsigned int v19; // esi
  CTls13Context *v20; // rbx
  __int64 v21; // rcx
  __int64 v22; // [rsp+0h] [rbp-30h] BYREF
  unsigned int v23; // [rsp+30h] [rbp+0h] BYREF
  unsigned int v24; // [rsp+34h] [rbp+4h]
  __int64 v25; // [rsp+38h] [rbp+8h] BYREF
  CTls13Context *v26; // [rsp+40h] [rbp+10h]

  v5 = a4;
  v26 = this;
  v6 = a3;
  if ( !a3 || !a4 )
    return 2148074248i64;
  v23 = 0;
  v24 = a2;
  EccCurveFlags = CCipherMill::GetEccCurveFlags(this, a2, &v23);
  v8 = EccCurveFlags;
  if ( EccCurveFlags )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        10i64,
        &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids,
        EccCurveFlags);
    return v8;
  }
  if ( (v23 & 8) != 0 )
  {
    v12 = v5;
  }
  else
  {
    if ( *v6 != 4 )
    {
      v10 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074248i64;
      v11 = 11i64;
      goto LABEL_18;
    }
    ++v6;
    LOWORD(v5) = v5 - 1;
    if ( (v5 & 1) != 0 )
    {
      v10 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074248i64;
      v11 = 12i64;
LABEL_18:
      WPP_SF_(*((_QWORD *)v10 + 2), v11, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
      return 2148074248i64;
    }
    v12 = (unsigned __int16)v5 >> 1;
  }
  v13 = 0i64;
  v14 = (unsigned int)(2 * v12 + 8);
  if ( v14 > g_ulMaxStackAllocSize )
    goto LABEL_28;
  v15 = v14 + g_ulAdditionalProbeSize + 8;
  if ( v15 < v14 || !(unsigned int)VerifyStackAvailable(v15) )
    goto LABEL_28;
  v16 = (unsigned int)(2 * v12 + 16) + 15i64;
  if ( v16 <= (unsigned int)(2 * v12 + 16) )
    v16 = 0xFFFFFFFFFFFFFF0i64;
  v17 = alloca(v16 & 0xFFFFFFFFFFFFFFF0ui64);
  v13 = &v23;
  if ( &v22 == (__int64 *)-48i64 || (v23 = 1801679955, (v13 = (unsigned int *)&v25) == 0i64) )
  {
LABEL_28:
    if ( 2 * v12 + 16 >= (unsigned int)(2 * v12 + 8) )
    {
      v18 = (_DWORD *)((__int64 (__fastcall *)(_QWORD))g_pfnAllocate)((unsigned int)(2 * v12 + 16));
      if ( !v18 )
        return 14i64;
      *v18 = 1885431112;
      v13 = v18 + 2;
    }
    if ( !v13 )
      return 14i64;
  }
  memset_0(v13, 0, (unsigned int)(2 * v12 + 8));
  *v13 = v24;
  v13[1] = v12;
  memcpy_0(v13 + 2, v6, (unsigned __int16)v5);
  v25 = 0i64;
  v19 = SslImportKey(a5, &v25, L"SSLECCPUBLICBLOB", v13, 2 * v12 + 8, 0);
  if ( *(v13 - 2) == 1885431112 )
    ((void (*)(void))g_pfnFree)();
  if ( v19 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids, v19);
    return v19;
  }
  else
  {
    v20 = v26;
    v21 = *((_QWORD *)v26 + 5);
    if ( v21 )
      SslFreeObject(v21, 0i64);
    *((_QWORD *)v20 + 5) = v25;
    return 0i64;
  }
}
// 18006EEA5: conditional instruction was optimized away because si.2!=0
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180082258: using guessed type wchar_t aSsleccpublicbl[17];
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);
// 1800985A0: using guessed type __int64 __fastcall SslImportKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (000000018006F0D8) ----------------------------------------------------
__int64 __fastcall CTls13Context::SetTrafficSecretsBuffers(
        CTls13Context *this,
        struct _SecBufferDesc *const a2,
        char a3,
        char a4)
{
  char *v7; // r8
  unsigned int v8; // edx
  unsigned __int8 v9; // di
  PSecBuffer pBuffers; // rcx
  __int64 v11; // rax

  if ( a3 )
    return 0i64;
  if ( !a2 )
    return 2148074333i64;
  v7 = (char *)this + 168;
  v8 = 0;
  memset((char *)this + 168, 0, 0x20ui64);
  *((_BYTE *)this + 200) = 0;
  v9 = 0;
  pBuffers = a2->pBuffers;
  if ( pBuffers >= &pBuffers[a2->cBuffers] )
  {
LABEL_18:
    v8 = -2146892949;
    goto LABEL_19;
  }
  while ( 1 )
  {
    if ( v9 >= 4u )
      goto LABEL_13;
    if ( (pBuffers->BufferType & 0xFFFFFFF) != 28 )
      goto LABEL_11;
    if ( a4 )
    {
      pBuffers->pvBuffer = 0i64;
      pBuffers->cbBuffer = 0;
      goto LABEL_10;
    }
    if ( !pBuffers->pvBuffer )
      break;
    if ( pBuffers->cbBuffer < 0x1C0 )
    {
      pBuffers->cbBuffer = 448;
      goto LABEL_11;
    }
LABEL_10:
    v11 = v9++;
    *((_QWORD *)this + v11 + 21) = pBuffers;
LABEL_11:
    if ( ++pBuffers >= &a2->pBuffers[(unsigned __int64)a2->cBuffers] )
    {
      if ( v9 < 4u )
        goto LABEL_18;
LABEL_13:
      *((_BYTE *)this + 201) = 0;
      return v8;
    }
  }
  v8 = 14;
LABEL_19:
  memset(v7, 0, 0x20ui64);
  *((_BYTE *)this + 200) = 0;
  return v8;
}

//----- (000000018006F1C4) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::StoreClientShares(
        CTls13ServerContext *this,
        const unsigned __int8 *a2,
        unsigned __int16 a3)
{
  size_t v3; // rdi
  void *v7; // rcx
  HLOCAL v8; // rax

  v3 = a3;
  if ( a3 && !a2 )
    return 87i64;
  v7 = (void *)*((_QWORD *)this + 187);
  if ( v7 )
  {
    SPExternalFree(v7);
    *((_QWORD *)this + 187) = 0i64;
    *((_WORD *)this + 752) = 0;
  }
  if ( (_WORD)v3 )
  {
    if ( *((_DWORD *)this + 17) == 71 && ((unsigned int)v3 < 4 || *((_DWORD *)this + 4) != (a2[1] | (*a2 << 8))) )
      return 2148074278i64;
    v8 = SPExternalAlloc(v3);
    *((_QWORD *)this + 187) = v8;
    if ( !v8 )
      return 14i64;
    memcpy_0(v8, a2, v3);
    *((_WORD *)this + 752) = v3;
  }
  return 0i64;
}

//----- (000000018006F290) ----------------------------------------------------
__int64 __fastcall CTls13ClientContext::UpdateHandshakeHash(
        CTls13ClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  __int64 v3; // rax
  __int64 *v6; // rcx
  __int64 v8; // r9
  int v9; // ecx
  __int64 v10; // rax

  v3 = 0i64;
  if ( !*((_BYTE *)this + 1601) )
  {
    if ( *((_DWORD *)this + 137) )
      return CSsl3TlsContext::UpdateHandshakeHash(this, a2, a3);
    v8 = *((_QWORD *)this + 110);
    if ( !v8 )
      return 1359i64;
    v9 = *((_DWORD *)this + 218);
    if ( !v9 )
      return 1359i64;
    if ( a2 )
    {
      if ( !a3 )
        return 87i64;
    }
    else if ( a3 )
    {
      return 87i64;
    }
    v10 = *((unsigned int *)this + 458);
    if ( a3 <= v9 - (int)v10 )
    {
      memcpy_0((void *)(v8 + v10), a2, a3);
      *((_DWORD *)this + 458) += a3;
      return 0i64;
    }
    return 87i64;
  }
  v6 = (__int64 *)*((_QWORD *)this + 1);
  if ( v6 )
    v3 = *v6;
  return CTls13Context::HashPostHandshakeMessage(
           (CTls13ClientContext *)((char *)this + 1368),
           v3,
           *((_QWORD *)this + 74),
           a2,
           a3);
}

//----- (000000018006F350) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::UpdateHandshakeHash(
        CTls13ServerContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  __int64 v4; // rdx
  __int64 *v5; // rax

  v4 = 0i64;
  if ( !*((_BYTE *)this + 1233) )
    return CSsl3TlsContext::UpdateHandshakeHash(this, a2, a3);
  v5 = (__int64 *)*((_QWORD *)this + 1);
  if ( v5 )
    v4 = *v5;
  return CTls13Context::HashPostHandshakeMessage(
           (CTls13ServerContext *)((char *)this + 1000),
           v4,
           *((_QWORD *)this + 74),
           a2,
           a3);
}

//----- (000000018006F3A0) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::VerifyBinder(
        CTls13ServerContext *this,
        unsigned __int8 *a2,
        unsigned __int16 a3,
        unsigned __int16 a4,
        unsigned __int16 a5)
{
  int v5; // r14d
  __int64 v8; // rbx
  int v9; // r12d
  unsigned int PrfHashDetails; // esi
  SIZE_T v11; // rbx
  __int64 v12; // rcx
  unsigned int v13; // r15d
  __int64 v14; // r14
  __int64 v15; // rax
  unsigned int HandshakeHash; // eax
  unsigned __int16 v18; // [rsp+50h] [rbp-51h]
  _DWORD Length[3]; // [rsp+54h] [rbp-4Dh] BYREF
  unsigned __int8 Source1[64]; // [rsp+60h] [rbp-41h] BYREF

  v5 = a3;
  if ( !a2 )
    return 87i64;
  if ( !a3 )
    return 87i64;
  if ( !a4 )
    return 87i64;
  v8 = *((_QWORD *)this + 124);
  if ( !v8 )
    return 87i64;
  if ( !*((_QWORD *)this + 110) )
    return 87i64;
  v9 = a4;
  if ( *((_DWORD *)this + 218) < (unsigned int)a4 )
    return 87i64;
  v18 = *((_WORD *)this + 17);
  memset_0(Source1, 0, sizeof(Source1));
  memset(Length, 0, sizeof(Length));
  RtlAcquireResourceShared((PRTL_RESOURCE)(v8 + 72), 1u);
  PrfHashDetails = CSessionCacheItem::GetPrfHashDetails(
                     *((CSessionCacheItem **)this + 124),
                     (unsigned __int8 *)Length,
                     0i64);
  if ( !PrfHashDetails )
  {
    v11 = Length[0];
    if ( Length[0] <= 0x40u )
    {
      if ( Length[0] == v5 )
      {
        v12 = *(_QWORD *)(*((_QWORD *)this + 124) + 176i64);
        if ( v12 )
        {
          v13 = *(_DWORD *)(v12 + 28);
          v14 = *(_QWORD *)v12;
        }
        else
        {
          v13 = 0;
          v14 = 0i64;
        }
        v15 = (*(__int64 (__fastcall **)(CTls13ServerContext *, _QWORD))(*(_QWORD *)this + 512i64))(this, 0i64);
        if ( v15 )
          HandshakeHash = SslDuplicateTranscriptHash(v14, v15, &Length[1], 0i64);
        else
          HandshakeHash = SslCreateHandshakeHash(v14, &Length[1], v18, v13, 0);
        PrfHashDetails = HandshakeHash;
        if ( !HandshakeHash )
        {
          PrfHashDetails = SslHashHandshake(
                             v14,
                             *(_QWORD *)&Length[1],
                             *((_QWORD *)this + 110),
                             (unsigned int)(*((_DWORD *)this + 218) - v9),
                             0);
          if ( !PrfHashDetails )
          {
            PrfHashDetails = CTls13Context::GenerateBinderData(
                               (CTls13ServerContext *)((char *)this + 1000),
                               v14,
                               *(_QWORD *)(*((_QWORD *)this + 124) + 16i64),
                               *(__int64 *)&Length[1],
                               v18,
                               v13,
                               *(const unsigned __int8 **)(*((_QWORD *)this + 124) + 200i64),
                               *(unsigned __int8 *)(*((_QWORD *)this + 124) + 208i64),
                               Source1,
                               v11);
            if ( PrfHashDetails )
            {
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                WPP_SF_D(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  69i64,
                  &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids,
                  PrfHashDetails);
              }
            }
            else if ( RtlCompareMemory(Source1, a2, v11) == v11 )
            {
              *((_WORD *)this + 738) = a5;
              *((_QWORD *)this + 17) &= ~0x8000ui64;
            }
            else
            {
              PrfHashDetails = -2146893048;
              CSslContext::SetErrorAndFatalAlert((__int64)this, 1210, -2146893048, 0x2Fu);
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 70i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
              }
            }
          }
        }
      }
      else
      {
        PrfHashDetails = -2146893048;
        CSslContext::SetErrorAndFatalAlert((__int64)this, 1210, -2146893048, 0x2Fu);
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_dd(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x44u,
            (__int64)&WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids,
            v5,
            v11);
      }
    }
    else
    {
      PrfHashDetails = 1359;
    }
  }
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 124) + 72i64));
  if ( *(_QWORD *)&Length[1] )
    SslFreeObject(*(_QWORD *)&Length[1], 0i64);
  return PrfHashDetails;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098420: using guessed type __int64 __fastcall SslHashHandshake(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098440: using guessed type __int64 __fastcall SslCreateHandshakeHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098558: using guessed type __int64 __fastcall SslDuplicateTranscriptHash(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018006F700) ----------------------------------------------------
void __fastcall DTlsMessage::~DTlsMessage(DTlsMessage *this)
{
  void *v2; // rcx
  void *v3; // rcx

  v2 = (void *)*((_QWORD *)this + 5);
  if ( v2 )
    operator delete(v2);
  v3 = (void *)*((_QWORD *)this + 7);
  if ( v3 )
    operator delete(v3);
}

//----- (000000018006F734) ----------------------------------------------------
DTlsMessage *__fastcall DTlsMessage::`scalar deleting destructor'(DTlsMessage *this)
{
  DTlsMessage::~DTlsMessage(this);
  if ( this )
    SPExternalFree(this);
  return this;
}

//----- (000000018006F760) ----------------------------------------------------
bool __fastcall CSsl3TlsContext::CanParseInput(CSsl3TlsContext *this)
{
  int v1; // eax

  v1 = *((_DWORD *)this + 17);
  return v1 != 2 && (v1 <= 3 || v1 > 5 && v1 != 91 && v1 != 93 && (v1 <= 94 || v1 > 96 && (v1 <= 97 || v1 > 102)));
}

//----- (000000018006F7A0) ----------------------------------------------------
char __fastcall CSsl3TlsContext::CheckRecordValidity(CSsl3TlsContext *this, unsigned __int64 a2)
{
  unsigned __int64 v3; // r9
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rax
  char v6; // cl
  char v7; // al
  __int64 v8; // rax
  unsigned __int64 v9; // rcx
  __int64 v10; // rax

  v3 = a2 & 0xFFFFFFFFFFFFi64;
  v4 = *((_QWORD *)this + 26) + 63i64;
  v5 = *((int *)this + 48);
  if ( (_DWORD)v5 == -1 )
    return 1;
  if ( HIWORD(a2) < v5 )
    return 0;
  if ( v3 <= v4 )
  {
    v9 = v4 - v3;
    if ( v9 >= 0x40 )
      return 0;
    v10 = *((_QWORD *)this + 25);
    if ( _bittest64(&v10, v9) )
    {
      if ( !*((_BYTE *)this + 232) )
        return 0;
      --**((_DWORD **)this + 72);
      v10 = *((_QWORD *)this + 25);
      *((_BYTE *)this + 232) = 0;
    }
    *((_QWORD *)this + 25) = v10 | (1i64 << v9);
    return 1;
  }
  v7 = a2 - v4;
  if ( v3 - v4 >= 0x40 )
  {
    v6 = 1;
    v8 = 1i64;
  }
  else
  {
    v6 = 1;
    v8 = (*((_QWORD *)this + 25) << v7) | 1i64;
  }
  *((_QWORD *)this + 25) = v8;
  *((_QWORD *)this + 26) = v3 - 63;
  return v6;
}

//----- (000000018006F874) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::DtlsGetOutgoingRecord(
        CSsl3TlsContext *this,
        struct SPBuffer *a2,
        struct SPBuffer *a3)
{
  unsigned int v6; // esi

  if ( !*((_BYTE *)this + 233) || !a2 || !*((_QWORD *)a2 + 1) || !a3 )
    return 87i64;
  v6 = CSsl3TlsContext::FragmentOutgoingBuffer(this, a2);
  (*(void (__fastcall **)(CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 16i64))(this, *((_QWORD *)a2 + 1));
  *((_QWORD *)a2 + 1) = 0i64;
  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  if ( !v6 )
    return (unsigned int)CSsl3TlsContext::PrepareNextOutgoingRecord(this, a3);
  return v6;
}

//----- (000000018006F914) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::DtlsProcessRecord(__int64 a1, int a2, unsigned __int8 *a3, unsigned int a4)
{
  int v7; // edx
  unsigned int v8; // edi
  unsigned int v9; // r8d
  int v11; // eax
  unsigned __int8 v12; // [rsp+38h] [rbp+10h] BYREF

  v7 = a2 - 21;
  if ( v7 )
  {
    if ( v7 == 1 )
    {
      if ( a4 < 0xC )
        return 2148074248i64;
      v9 = a3[3] + (a3[1] << 16) + (a3[2] << 8);
      if ( (unsigned __int64)v9 + 12 > a4 )
        return 2148074248i64;
      return (unsigned int)CSsl3TlsContext::ProcessHandshakeCommon((CSsl3TlsContext *)a1, a3, v9 + 12);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 56i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    v11 = TlsParseAlertMessage(a3, a4, (unsigned __int8 *)(a1 + 473), &v12);
    v8 = v11;
    if ( v11 )
    {
      if ( *(_DWORD *)(a1 + 36) >= 0x302u && (*(_DWORD *)(a1 + 64) & 0x800A00AA) != 0 )
      {
        CSslContext::SetError(a1, 14, v11);
        return (unsigned int)-2146893018;
      }
      else if ( a4 == 2 )
      {
        LogReceiveAlertEvent(
          *(_DWORD *)(*(_QWORD *)(a1 + 80) + 212i64),
          (const unsigned __int16 *)(*(_QWORD *)(a1 + 80) + 216i64),
          *a3,
          a3[1]);
      }
    }
    else if ( v12 )
    {
      *(_BYTE *)(a1 + 552) = 1;
      *(_DWORD *)(a1 + 68) = 75;
    }
  }
  return v8;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018006FA58) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::FindMatchingProtectionProfile(
        unsigned __int16 *const a1,
        unsigned __int16 a2,
        unsigned __int16 *const a3,
        unsigned __int16 a4)
{
  unsigned __int16 *v4; // r10
  unsigned __int16 *v5; // r9
  unsigned __int16 *v6; // rax
  unsigned __int16 v7; // dx

  if ( !a1 )
    return 0i64;
  if ( !a2 )
    return 0i64;
  if ( !a3 )
    return 0i64;
  if ( !a4 )
    return 0i64;
  v4 = (unsigned __int16 *const)((char *)a1 + (a2 & 0xFFFE));
  if ( a1 >= v4 )
    return 0i64;
  v5 = (unsigned __int16 *const)((char *)a3 + (a4 & 0xFFFE));
  while ( 1 )
  {
    v6 = a3;
    if ( a3 < v5 )
      break;
LABEL_11:
    if ( ++a1 >= v4 )
      return 0i64;
  }
  v7 = *a1;
  while ( v7 != *v6 )
  {
    if ( ++v6 >= v5 )
      goto LABEL_11;
  }
  return v7;
}

//----- (000000018006FAC0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::FragmentMessage(__int64 a1, char *a2, char a3)
{
  unsigned int v3; // r12d
  int v4; // edi
  bool v5; // cf
  __int64 v7; // rcx
  unsigned int v8; // esi
  unsigned int v9; // ebx
  unsigned int v10; // edi
  int v11; // r9d
  unsigned int v12; // edx
  unsigned int v13; // r8d
  __int64 v14; // r14
  unsigned int v15; // r15d
  struct DTlsRec *v16; // r13
  __int64 v17; // rax
  unsigned int v19; // [rsp+20h] [rbp-68h]
  __int16 v20; // [rsp+24h] [rbp-64h]
  unsigned int v21; // [rsp+2Ch] [rbp-5Ch]
  int v22; // [rsp+30h] [rbp-58h]
  char v23; // [rsp+90h] [rbp+8h]
  unsigned int v26; // [rsp+A8h] [rbp+20h]

  v3 = 0;
  v4 = *(unsigned __int16 *)(a1 + 218);
  v5 = *(_BYTE *)(a1 + 233) != 0;
  v7 = *(unsigned int *)(a1 + 60);
  v8 = 8;
  v9 = v5 ? 12 : 4;
  v10 = v4 - v9;
  if ( a2 )
  {
    v19 = (unsigned __int8)a2[3] + (((unsigned __int8)a2[2] + ((unsigned __int8)a2[1] << 8)) << 8);
    v23 = *a2;
    v20 = (unsigned __int8)a2[5] + ((unsigned __int8)a2[4] << 8);
    v11 = v19 % v10;
    v22 = v19 % v10;
    v12 = (v10 + v19 - 1) / v10;
    if ( v12 <= 1 )
    {
      v12 = 1;
      v10 = v19 % v10;
    }
    v13 = 0;
    v21 = v12;
    v26 = 0;
    if ( v12 )
    {
      v14 = v7;
      v15 = v10;
      while ( 1 )
      {
        if ( v12 > 1 && v13 == v12 - 1 )
        {
          v15 = v11;
          v10 = v11;
        }
        v10 += v7 + v9;
        v16 = DTlsMsgMgr::AddOutgoingRec(*(DTlsMsgMgr **)(a1 + 576), v10);
        if ( !v16 )
          break;
        if ( v15 )
          memcpy_0((void *)(v9 + v14 + *((_QWORD *)v16 + 1)), &a2[v9 + (unsigned __int64)v3], v15);
        **((_BYTE **)v16 + 1) = a3;
        v13 = v26 + 1;
        v17 = *((_QWORD *)v16 + 1);
        v11 = v22;
        v26 = v13;
        *(_BYTE *)(v17 + 12) = v15 + v9;
        *(_BYTE *)(v17 + 11) = (unsigned __int16)(v15 + v9) >> 8;
        v7 = *((_QWORD *)v16 + 1);
        *(_BYTE *)(v14 + v7 + 2) = BYTE1(v19);
        *(_BYTE *)(v14 + v7 + 1) = BYTE2(v19);
        *(_BYTE *)(v14 + v7 + 7) = BYTE1(v3);
        *(_BYTE *)(v14 + v7 + 6) = BYTE2(v3);
        *(_BYTE *)(v14 + v7 + 10) = BYTE1(v15);
        *(_BYTE *)(v14 + v7 + 9) = BYTE2(v15);
        *(_BYTE *)(v14 + v7 + 5) = v20;
        *(_BYTE *)(v14 + v7 + 4) = HIBYTE(v20);
        *(_BYTE *)(v14 + v7) = v23;
        *(_BYTE *)(v14 + v7 + 8) = v3;
        *(_BYTE *)(v14 + v7 + 3) = v19;
        v3 += v15;
        v12 = v21;
        *(_BYTE *)(v14 + v7 + 11) = v15;
        LODWORD(v7) = v14;
        *((_DWORD *)v16 + 1) = v9 + v15 + v14;
        if ( v13 >= v21 )
          return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 87;
  }
  return v8;
}

//----- (000000018006FCD4) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::FragmentOutgoingBuffer(CSsl3TlsContext *this, struct SPBuffer *a2)
{
  char *v2; // rsi
  __int64 v4; // r15
  __int64 v6; // rcx
  unsigned int v7; // r12d
  __int64 v8; // rdi
  int v9; // ecx
  char v10; // r10
  unsigned int v11; // r8d
  unsigned int v12; // ecx
  char *v13; // r9
  char *v14; // rdx
  unsigned __int64 v15; // r13
  __int64 result; // rax
  unsigned int v17; // edi
  struct DTlsRec *v18; // rax
  struct DTlsRec *v19; // rbp
  char v20; // [rsp+60h] [rbp+8h]

  v2 = (char *)*((_QWORD *)a2 + 1);
  v4 = *((unsigned int *)this + 15);
  if ( !v2 )
    return 0i64;
  LODWORD(v6) = *((_DWORD *)a2 + 1);
  v7 = 0;
  while ( 1 )
  {
    v8 = (unsigned __int8)v2[12] + ((unsigned __int8)v2[11] << 8);
    v7 += v4 + v8;
    if ( v7 > (unsigned int)v6 )
      return 87i64;
    v9 = (unsigned __int8)v2[12] + ((unsigned __int8)v2[11] << 8);
    v10 = *v2;
    v20 = *v2;
    if ( (*((_BYTE *)this + 32) & 4) != 0 )
    {
      v11 = *((_DWORD *)this + 13);
      v12 = v8 + *((_DWORD *)this + 12);
      if ( v11 )
      {
        if ( (*((_BYTE *)this + 56) & 1) != 0 )
          v11 -= v12 % v11;
        v12 += v11;
      }
      v9 = *((_DWORD *)this + 11) + v12;
    }
    if ( *((_DWORD *)this + 15) + v9 > (unsigned int)*((unsigned __int16 *)this + 108) )
    {
      v13 = &v2[v8 + v4];
      v14 = &v2[v4];
      while ( 1 )
      {
        v15 = (unsigned __int64)&v14[0x10000 * (unsigned __int64)(unsigned __int8)v14[1]
                                   + 12
                                   + 256 * (unsigned __int8)v14[2]
                                   + (unsigned __int8)v14[3]];
        if ( v15 > (unsigned __int64)v13 )
          return 87i64;
        result = CSsl3TlsContext::FragmentMessage((__int64)this, v14, v10);
        if ( (_DWORD)result )
          return result;
        v13 = &v2[v8 + v4];
        v10 = v20;
        v14 = (char *)v15;
        if ( (__int64)(v15 - (_QWORD)&v2[v4]) >= (unsigned int)v8 )
        {
          v17 = v4 + v8;
          goto LABEL_18;
        }
      }
    }
    v17 = v4 + v8;
    v18 = DTlsMsgMgr::AddOutgoingRec(*((DTlsMsgMgr **)this + 72), v17);
    v19 = v18;
    if ( !v18 )
      return 8i64;
    memcpy_0(*((void **)v18 + 1), v2, v17);
    *((_DWORD *)v19 + 1) = v17;
LABEL_18:
    v6 = *((unsigned int *)a2 + 1);
    v2 += v17;
    if ( (__int64)&v2[-*((_QWORD *)a2 + 1)] >= v6 )
      return 0i64;
  }
}

//----- (000000018006FE4C) ----------------------------------------------------
void __fastcall CSsl3TlsContext::FreeSavedWriteCipherState(CSsl3TlsContext *this)
{
  if ( *((_BYTE *)this + 233) && *((_BYTE *)this + 264) )
  {
    if ( !*((_QWORD *)this + 30) )
      SslFreeObject(0i64, 0i64);
    *((_WORD *)this + 117) = 0;
    *((_QWORD *)this + 30) = 0i64;
    *((_QWORD *)this + 31) = 0i64;
    *((_QWORD *)this + 32) = 0i64;
    *((_BYTE *)this + 264) = 0;
  }
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018006FEBC) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::GetHashAlgorithmSize(
        CSsl3TlsContext *this,
        enum _eTlsSignatureAlgorithm a2,
        enum _eTlsHashAlgorithm a3,
        unsigned int *a4)
{
  unsigned int v4; // r10d
  unsigned int v6; // edx
  int v7; // eax
  __int64 *i; // rcx
  __int64 v9; // r11

  v4 = 0;
  if ( !a4 )
    return 87i64;
  if ( (*((_DWORD *)this + 16) & 0x43C00) != 0 )
  {
    v6 = g_dwHashInfoTotalCount;
    v7 = 0;
    *a4 = 0;
    if ( v6 )
    {
      for ( i = g_pHashInfo; ; ++i )
      {
        v9 = *i;
        if ( *i )
        {
          if ( *(_DWORD *)(v9 + 20) == a3 )
            break;
        }
        if ( ++v7 >= v6 )
          return 1168;
      }
      return (unsigned int)I_GetHashDetailsFromHashInfo(v9, 0i64, a4, (__int64)a4, 0i64, 0i64);
    }
    else
    {
      return 1168;
    }
  }
  else if ( a2 == TlsSignatureAlgorithm_Rsa )
  {
    *a4 = 36;
  }
  else if ( (unsigned int)(a2 - 2) <= 1 )
  {
    *a4 = 20;
  }
  else
  {
    *a4 = 0;
    return 87;
  }
  return v4;
}
// 180092324: using guessed type int g_dwHashInfoTotalCount;
// 180092330: using guessed type _QWORD g_pHashInfo[16];

//----- (000000018006FF64) ----------------------------------------------------
void __fastcall CTlsMessageFragment::Initialize(CTlsMessageFragment *this, struct CSsl3TlsContext *a2)
{
  int v2; // eax
  int v3; // edx
  unsigned int v4; // edx
  unsigned int v5; // eax

  *(_QWORD *)this = a2;
  if ( (*((_DWORD *)a2 + 16) & 0x40051555) != 0 )
  {
    v2 = *((_DWORD *)a2 + 34);
    v3 = 256;
    if ( (v2 & 0x100) == 0 )
    {
      *((_DWORD *)this + 2) = CSslGlobals::m_dwTlsMessageLimitSrv;
      goto LABEL_9;
    }
    v4 = CSslGlobals::m_dwTlsMessageLimitSrvClientAuth;
    if ( CSslGlobals::m_dwTlsMessageLimitSrv > CSslGlobals::m_dwTlsMessageLimitSrvClientAuth )
      v4 = CSslGlobals::m_dwTlsMessageLimitSrv;
    *((_DWORD *)this + 2) = v4;
  }
  else
  {
    *((_DWORD *)this + 2) = CSslGlobals::m_dwTlsMessageLimitClient;
  }
  v3 = 1536;
LABEL_9:
  *((_DWORD *)this + 3) = v3;
  v5 = *((_DWORD *)this + 2);
  if ( v5 > 0xFFFFFF )
    v5 = 0xFFFFFF;
  *((_DWORD *)this + 2) = v5;
}

//----- (000000018006FFCC) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::PrepareNextOutgoingRecord(CSsl3TlsContext *this, struct SPBuffer *a2)
{
  unsigned int v4; // ebp
  __int64 v5; // r15
  _QWORD **v6; // rcx
  _QWORD *v7; // rax
  _QWORD *v8; // rdx
  _QWORD *v9; // rdi
  int v10; // r8d
  int v11; // r14d
  unsigned int v12; // r8d
  unsigned int v13; // ecx
  __int64 result; // rax
  char v15; // cl
  __int64 v16; // rax
  unsigned __int64 v17; // r9
  __int64 *v18; // rcx
  __int64 v19; // rax
  __int64 **v20; // rdx

  if ( (*((_BYTE *)this + 32) & 4) != 0 )
    v4 = *((_DWORD *)this + 11);
  else
    v4 = 0;
  v5 = *((unsigned int *)this + 15);
  v6 = (_QWORD **)(*((_QWORD *)this + 72) + 56i64);
  v7 = *v6;
  if ( *v6 == v6 )
    goto LABEL_34;
  if ( (_QWORD **)v7[1] != v6 )
    goto LABEL_33;
  v8 = (_QWORD *)*v7;
  if ( *(_QWORD **)(*v7 + 8i64) != v7 )
    goto LABEL_33;
  *v6 = v8;
  v9 = v7 - 5;
  v8[1] = v6;
  if ( v7 == (_QWORD *)40 )
  {
LABEL_34:
    *(_DWORD *)a2 = 0;
    *((_DWORD *)a2 + 1) = 0;
    return 0i64;
  }
  v10 = *((_DWORD *)v9 + 1) - v5;
  v11 = *(unsigned __int8 *)v9[1];
  if ( (*((_BYTE *)this + 32) & 4) != 0 )
  {
    v12 = *((_DWORD *)this + 12) + v10;
    v13 = *((_DWORD *)this + 13);
    if ( v13 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v13 -= v12 % v13;
      v12 += v13;
    }
    v10 = *((_DWORD *)this + 11) + v12;
  }
  result = CSsl3TlsContext::AllocateOutputBuffer(this, a2, *((_DWORD *)this + 15) + v10);
  if ( !(_DWORD)result )
  {
    memcpy_0(
      (void *)(v5 + v4 + *((_QWORD *)a2 + 1)),
      (const void *)(v5 + v9[1]),
      (unsigned int)(*((_DWORD *)v9 + 1) - v5));
    *((_DWORD *)a2 + 1) = 0;
    result = CSsl3TlsContext::WrapMessage((__int64)this, (__int64)a2, v11, *((_DWORD *)v9 + 1) - (int)v5);
    if ( !(_DWORD)result )
    {
      if ( v11 == 20 )
      {
        result = CSsl3TlsContext::SaveWriteCipherState(this);
        if ( (_DWORD)result )
          return result;
        *((_WORD *)this + 16) |= 0xCu;
        v15 = *((_BYTE *)this + 233);
        if ( !v15 && *((_QWORD *)this + 19) )
        {
          SslFreeObject(*((_QWORD *)this + 19), 0i64);
          v15 = *((_BYTE *)this + 233);
        }
        v16 = *((_QWORD *)this + 21);
        *((_QWORD *)this + 21) = 0i64;
        *((_QWORD *)this + 19) = v16;
        if ( !v15 )
          *((_QWORD *)this + 23) = 0i64;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 59i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        v17 = (*((_QWORD *)this + 23) + 0x1000000000000i64) & 0xFFFF000000000000ui64;
        *((_QWORD *)this + 23) = v17;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_i(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x49u,
            (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
            HIWORD(v17));
      }
      *((_DWORD *)v9 + 8) = 1;
      v18 = v9 + 5;
      v19 = *((_QWORD *)this + 72) + 72i64;
      v20 = *(__int64 ***)(*((_QWORD *)this + 72) + 80i64);
      if ( *v20 == (__int64 *)v19 )
      {
        *v18 = v19;
        v9[6] = v20;
        *v20 = v18;
        *(_QWORD *)(v19 + 8) = v18;
        if ( *(_QWORD *)(*((_QWORD *)this + 72) + 56i64) != *((_QWORD *)this + 72) + 56i64 )
          return 590692i64;
        *((_QWORD *)this + 113) = GetTickCount64();
        return 0i64;
      }
LABEL_33:
      __fastfail(3u);
    }
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180070244) ----------------------------------------------------
__int64 __fastcall CTlsMessageFragment::Reallocate(CTlsMessageFragment *this, unsigned int a2)
{
  unsigned int v2; // edi
  HLOCAL Memory; // rax
  HLOCAL v5; // rsi
  __int64 result; // rax

  v2 = a2;
  if ( a2 <= *((_DWORD *)this + 3) )
    v2 = *((_DWORD *)this + 3);
  Memory = CSslContext::GetMemory(*(CSslContext **)this, v2);
  v5 = Memory;
  if ( Memory )
  {
    if ( *((_DWORD *)this + 9) )
      memcpy_0(Memory, *((const void **)this + 3), *((unsigned int *)this + 9));
    if ( *((_QWORD *)this + 3) )
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)this + 16i64))(*(_QWORD *)this);
    *((_DWORD *)this + 4) = v2;
    result = 0i64;
    *((_QWORD *)this + 3) = v5;
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_d(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x46u,
        (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
        v2);
    return 14i64;
  }
  return result;
}

//----- (0000000180070304) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::RestoreWriteCipherState(CSsl3TlsContext *this)
{
  __int16 v1; // ax

  if ( *((_BYTE *)this + 233) && *((_BYTE *)this + 264) )
  {
    v1 = *((_WORD *)this + 117);
    *((_WORD *)this + 16) &= 2u;
    *((_WORD *)this + 16) |= v1;
    *((_QWORD *)this + 19) = *((_QWORD *)this + 30);
    *((_QWORD *)this + 21) = *((_QWORD *)this + 31);
    *((_QWORD *)this + 23) = *((_QWORD *)this + 32);
    *((_WORD *)this + 117) = 0;
    *((_QWORD *)this + 30) = 0i64;
    *((_QWORD *)this + 31) = 0i64;
    *((_QWORD *)this + 32) = 0i64;
    *((_BYTE *)this + 264) = 0;
  }
  return 0i64;
}

//----- (000000018007037C) ----------------------------------------------------
__int64 __fastcall CTlsMessageFragment::SaveFragment(
        CTlsMessageFragment *this,
        unsigned __int8 *Src,
        size_t Size,
        int a4,
        unsigned int *a5)
{
  unsigned int v5; // ebp
  int v8; // esi
  unsigned int v9; // esi
  CCipherMill *v10; // r10
  __int64 result; // rax
  __int64 v12; // rcx
  unsigned int v13; // eax
  void *v14; // rcx
  __int64 v15; // rbx
  unsigned int v16; // edx
  unsigned int v17; // ecx
  unsigned int v18; // edx
  unsigned int v19; // r9d
  unsigned int v20; // edx
  unsigned int v21; // ebx
  int v22; // [rsp+20h] [rbp-28h]

  v5 = Size;
  v8 = *((_DWORD *)this + 10) != 0 ? 8 : 0;
  *a5 = 0;
  v9 = v8 + 4;
  if ( !a4 )
    goto LABEL_5;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 8) = v9;
  v10 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 71i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
LABEL_5:
    v10 = WPP_GLOBAL_Control;
  }
  if ( *((_DWORD *)this + 9) < v9 )
  {
    if ( v9 > *((_DWORD *)this + 4) )
    {
      result = CTlsMessageFragment::Reallocate(this, v9);
      if ( (_DWORD)result )
        return result;
    }
    v12 = *((unsigned int *)this + 9);
    v13 = v9 - v12;
    if ( v5 < v9 - (unsigned int)v12 )
      v13 = v5;
    v14 = (void *)(*((_QWORD *)this + 3) + v12);
    v15 = v13;
    *a5 = v13;
    memcpy_0(v14, Src, v13);
    Src += v15;
    v16 = v15 + *((_DWORD *)this + 9);
    *((_DWORD *)this + 9) = v16;
    v5 -= v15;
    if ( !v5 )
      return 0i64;
    v17 = *((_DWORD *)this + 10) != 0 ? 12 : 4;
    if ( *((_DWORD *)this + 8) > v17 && v16 >= *((_DWORD *)this + 8) )
      return 0i64;
    if ( v16 >= v17
      && !(*(unsigned __int8 *)(*((_QWORD *)this + 3) + 3i64)
         + (*(unsigned __int8 *)(*((_QWORD *)this + 3) + 1i64) << 16)
         + (*(unsigned __int8 *)(*((_QWORD *)this + 3) + 2i64) << 8)) )
    {
      return 0i64;
    }
    v10 = WPP_GLOBAL_Control;
  }
  v18 = *((_DWORD *)this + 8);
  if ( v18 > v9 )
  {
LABEL_25:
    v21 = *((_DWORD *)this + 8) - *((_DWORD *)this + 9);
    if ( v21 >= v5 )
      v21 = v5;
    if ( v21 )
    {
      memcpy_0((void *)(*((_QWORD *)this + 3) + *((unsigned int *)this + 9)), Src, v21);
      *((_DWORD *)this + 9) += v21;
      *a5 += v21;
    }
    return 0i64;
  }
  v19 = *(unsigned __int8 *)(*((_QWORD *)this + 3) + 3i64)
      + (*(unsigned __int8 *)(*((_QWORD *)this + 3) + 1i64) << 16)
      + (*(unsigned __int8 *)(*((_QWORD *)this + 3) + 2i64) << 8);
  if ( v19 <= *((_DWORD *)this + 2) )
  {
    v20 = v19 + v18;
    *((_DWORD *)this + 8) = v20;
    if ( v20 > *((_DWORD *)this + 4) )
    {
      result = CTlsMessageFragment::Reallocate(this, v20);
      if ( (_DWORD)result )
        return result;
    }
    goto LABEL_25;
  }
  if ( v10 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v10 + 28) & 1) != 0 )
  {
    v22 = *((_DWORD *)this + 2);
    WPP_SF_dd(*((_QWORD *)v10 + 2), 0x48u, (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids, v19, v22);
  }
  CSslContext::SetErrorAndFatalAlert(*(_QWORD *)this, 12, -2146893018, 0xAu);
  return 2148074278i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180070568) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SaveWriteCipherState(CSsl3TlsContext *this)
{
  if ( *((_BYTE *)this + 233) )
  {
    if ( *((_BYTE *)this + 264) )
      CSsl3TlsContext::FreeSavedWriteCipherState(this);
    *((_WORD *)this + 117) = *((_WORD *)this + 16);
    *((_QWORD *)this + 30) = *((_QWORD *)this + 19);
    *((_QWORD *)this + 31) = *((_QWORD *)this + 21);
    *((_QWORD *)this + 32) = *((_QWORD *)this + 23);
    *((_BYTE *)this + 264) = 1;
  }
  return 0i64;
}

//----- (00000001800705D4) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetSelectedSrtpParameters(
        CSsl3TlsContext *this,
        __int16 a2,
        unsigned __int8 *const a3,
        char a4)
{
  __int64 v4; // rax

  v4 = *((_QWORD *)this + 101);
  if ( v4 )
  {
    if ( *(_QWORD *)(v4 + 8) )
    {
      (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
      v4 = *((_QWORD *)this + 101);
    }
  }
  else
  {
    v4 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 8i64))(this, 16i64);
    *((_QWORD *)this + 101) = v4;
    if ( !v4 )
      return 14i64;
  }
  *(_WORD *)v4 = a2;
  *(_BYTE *)(*((_QWORD *)this + 101) + 2i64) = a4;
  *(_QWORD *)(*((_QWORD *)this + 101) + 8i64) = a3;
  return 0i64;
}

//----- (0000000180070690) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetSelectedTBParameters(
        CSsl3TlsContext *this,
        char a2,
        char a3,
        unsigned __int8 *const a4,
        unsigned __int16 a5)
{
  __int64 v5; // rax

  v5 = *((_QWORD *)this + 103);
  if ( v5 )
  {
    if ( *(_QWORD *)(v5 + 8) )
    {
      (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
      v5 = *((_QWORD *)this + 103);
    }
  }
  else
  {
    v5 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 8i64))(this, 16i64);
    *((_QWORD *)this + 103) = v5;
    if ( !v5 )
      return 14i64;
  }
  *(_BYTE *)v5 = a2;
  *(_BYTE *)(*((_QWORD *)this + 103) + 1i64) = a3;
  *(_WORD *)(*((_QWORD *)this + 103) + 2i64) = a5;
  *(_QWORD *)(*((_QWORD *)this + 103) + 8i64) = a4;
  return 0i64;
}

//----- (000000018007075C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetSrtpProtectionProfiles(
        CSsl3TlsContext *this,
        struct _SEC_SRTP_PROTECTION_PROFILES *const a2)
{
  void *v2; // rdi
  __int64 ProfilesSize; // rbp
  void *v6; // rax

  v2 = 0i64;
  if ( a2 )
  {
    ProfilesSize = a2->ProfilesSize;
    v6 = (void *)(*(__int64 (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 8i64))(
                   this,
                   ProfilesSize + 2);
    v2 = v6;
    if ( !v6 )
      return 14i64;
    memcpy_0(v6, a2, ProfilesSize + 2);
  }
  if ( *((_QWORD *)this + 100) )
    (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
  *((_QWORD *)this + 100) = v2;
  return 0i64;
}

//----- (0000000180070804) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::TlsNulRecordHandlerWorker(
        CSsl3TlsContext *this,
        struct SPBuffer *a2,
        struct SPBuffer *a3)
{
  __int64 result; // rax
  unsigned __int8 *v7; // r14
  unsigned int v8; // esi
  __int64 v9; // rax
  char v10; // r13
  CTlsMessageFragment *v11; // rcx
  unsigned int v12; // eax
  __int64 v13; // r9
  __int64 v14; // r15
  unsigned int v15; // r8d
  unsigned int v16; // ecx
  __int64 v17; // rcx
  unsigned int v18; // edx
  unsigned int v19; // ebp
  int v20; // ecx
  __int64 v21; // rax
  CTlsMessageFragment *v22; // rcx
  unsigned int v23; // eax
  bool v24; // zf
  CCipherMill *v25; // rcx
  bool v26; // zf
  _QWORD *Memory; // rax
  CCipherMill *v28; // rcx
  bool v29; // zf
  unsigned int v30; // eax
  bool v31; // zf
  unsigned int v32; // edi
  unsigned int v33; // [rsp+60h] [rbp+8h] BYREF

  if ( (*(unsigned __int8 (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 384i64))(this) || !a2 || !a3 )
    return 2148074333i64;
  result = (*(__int64 (__fastcall **)(CSsl3TlsContext *, struct SPBuffer *))(*(_QWORD *)this + 432i64))(this, a2);
  if ( (_DWORD)result )
    return result;
  if ( !CSsl3TlsContext::CanParseInput(this) )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 44i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    return CSsl3TlsContext::GenerateResponseCommon(this, a3);
  }
  v7 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
  if ( !v7 )
    return 2148074248i64;
  v8 = *((_DWORD *)a2 + 1);
  if ( !v8 )
    return 2148074248i64;
  *((_DWORD *)a2 + 1) = 0;
  if ( (*((_BYTE *)this + 32) & 2) == 0 || (v9 = *((_QWORD *)this + 1)) == 0 || (v10 = 1, !*(_DWORD *)(v9 + 28)) )
    v10 = 0;
  while ( 1 )
  {
    v11 = (CTlsMessageFragment *)*((_QWORD *)this + 58);
    if ( !v11 || !*((_DWORD *)v11 + 9) )
      break;
    v33 = 0;
    result = CTlsMessageFragment::SaveFragment(v11, v7, v8, 0, &v33);
    if ( (_DWORD)result )
      return result;
    v12 = v33;
    if ( v33 > v8 )
      return 2148074244i64;
    *((_DWORD *)a2 + 1) += v33;
    v8 -= v12;
    v13 = *((_QWORD *)this + 58);
    v14 = v12;
    v15 = *(_DWORD *)(v13 + 32);
    v16 = *(_DWORD *)(v13 + 40) != 0 ? 12 : 4;
    if ( (v15 <= v16 || *(_DWORD *)(v13 + 36) < v15)
      && (*(_DWORD *)(v13 + 36) < v16
       || *(unsigned __int8 *)(*(_QWORD *)(v13 + 24) + 3i64)
        + (*(unsigned __int8 *)(*(_QWORD *)(v13 + 24) + 1i64) << 16)
        + (*(unsigned __int8 *)(*(_QWORD *)(v13 + 24) + 2i64) << 8)) )
    {
      return 0i64;
    }
    result = CSsl3TlsContext::ProcessHandshakeCommon(this, *(unsigned __int8 **)(v13 + 24), v15);
    v17 = *((_QWORD *)this + 58);
    v18 = result;
    *(_DWORD *)(v17 + 36) = 0;
    *(_DWORD *)(v17 + 32) = 0;
    if ( (_DWORD)result )
      return result;
LABEL_30:
    v20 = *((_DWORD *)this + 17);
    v7 += v14;
    if ( (unsigned int)(v20 - 91) <= 0xB )
      return CSsl3TlsContext::GenerateResponseCommon(this, a3);
    if ( v20 == 4 )
      return v18;
    if ( !v10 && (*((_BYTE *)this + 32) & 2) != 0 )
    {
      v21 = *((_QWORD *)this + 1);
      if ( v21 )
      {
        if ( *(_DWORD *)(v21 + 28) )
          return v18;
      }
    }
    if ( !v8 )
      return v18;
  }
  if ( v8 < 4 )
  {
    *((_DWORD *)a2 + 1) += v8;
    v22 = (CTlsMessageFragment *)*((_QWORD *)this + 58);
    if ( v22 )
      goto LABEL_73;
    if ( (*((_DWORD *)this + 16) & 0x40051555) != 0 )
    {
      if ( (*((_DWORD *)this + 34) & 0x100i64) != 0 )
      {
        v30 = CSslGlobals::m_dwTlsMessageLimitSrvClientAuth;
        if ( CSslGlobals::m_dwTlsMessageLimitSrv > CSslGlobals::m_dwTlsMessageLimitSrvClientAuth )
          v30 = CSslGlobals::m_dwTlsMessageLimitSrv;
        if ( !v30 )
          goto LABEL_61;
      }
      v31 = CSslGlobals::m_dwTlsMessageLimitSrv == 0;
    }
    else
    {
      v31 = CSslGlobals::m_dwTlsMessageLimitClient == 0;
    }
    if ( !v31 )
    {
      Memory = CSslContext::GetMemory(this, 0x30u);
      if ( !Memory )
      {
        v28 = WPP_GLOBAL_Control;
        v29 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
LABEL_68:
        if ( !v29 && (*((_BYTE *)v28 + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)v28 + 2), 68i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        return 14;
      }
      goto LABEL_72;
    }
LABEL_61:
    v25 = WPP_GLOBAL_Control;
    v26 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
    goto LABEL_62;
  }
  if ( (unsigned __int64)(v7[3] + (v7[1] << 16) + (v7[2] << 8)) + 4 <= v8 )
  {
    v19 = v7[3] + (v7[1] << 16) + (v7[2] << 8) + 4;
    v18 = CSsl3TlsContext::ProcessHandshakeCommon(this, v7, v19);
    if ( v18 )
      return v18;
    v8 -= v19;
    v14 = v19;
    *((_DWORD *)a2 + 1) += v19;
    goto LABEL_30;
  }
  *((_DWORD *)a2 + 1) += v8;
  v22 = (CTlsMessageFragment *)*((_QWORD *)this + 58);
  if ( v22 )
  {
LABEL_73:
    v33 = 0;
    return (unsigned int)CTlsMessageFragment::SaveFragment(v22, v7, v8, 1, &v33);
  }
  if ( (*((_DWORD *)this + 16) & 0x40051555) != 0 )
  {
    if ( (*((_DWORD *)this + 34) & 0x100i64) == 0 )
      goto LABEL_46;
    v23 = CSslGlobals::m_dwTlsMessageLimitSrvClientAuth;
    if ( CSslGlobals::m_dwTlsMessageLimitSrv > CSslGlobals::m_dwTlsMessageLimitSrvClientAuth )
      v23 = CSslGlobals::m_dwTlsMessageLimitSrv;
    if ( v23 )
    {
LABEL_46:
      v24 = CSslGlobals::m_dwTlsMessageLimitSrv == 0;
      goto LABEL_48;
    }
    goto LABEL_49;
  }
  v24 = CSslGlobals::m_dwTlsMessageLimitClient == 0;
LABEL_48:
  if ( !v24 )
  {
    Memory = CSslContext::GetMemory(this, 0x30u);
    if ( !Memory )
    {
      v28 = WPP_GLOBAL_Control;
      v29 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
      goto LABEL_68;
    }
LABEL_72:
    *Memory = 0i64;
    *(_QWORD *)((char *)Memory + 12) = 256i64;
    Memory[3] = 0i64;
    Memory[4] = 0i64;
    *((_QWORD *)this + 58) = Memory;
    CTlsMessageFragment::Initialize((CTlsMessageFragment *)Memory, this);
    v22 = (CTlsMessageFragment *)*((_QWORD *)this + 58);
    goto LABEL_73;
  }
LABEL_49:
  v25 = WPP_GLOBAL_Control;
  v26 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
LABEL_62:
  if ( !v26 && (*((_BYTE *)v25 + 28) & 1) != 0 )
    WPP_SF_(*((_QWORD *)v25 + 2), 67i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
  v32 = -2146893018;
  CSslContext::SetErrorAndFatalAlert((__int64)this, 12, -2146893018, 0xAu);
  return v32;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180070C68) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::ValidateProtectionProfiles(unsigned __int16 *const a1, unsigned __int16 a2, int a3)
{
  CCipherMill *v4; // rcx
  __int64 v5; // rdx
  unsigned __int16 *v6; // rdx

  if ( !a1 )
    return 87i64;
  if ( a2 < 2u || (a2 & 1) != 0 || a2 > 0xFFFDu )
  {
    v4 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v5 = 81i64;
  }
  else if ( a3 || a2 == 2 )
  {
    v6 = (unsigned __int16 *const)((char *)a1 + (a2 & 0xFFFE));
    while ( 1 )
    {
      if ( a1 >= v6 )
        return 0i64;
      if ( !*a1 )
        break;
      ++a1;
    }
    v4 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v5 = 83i64;
  }
  else
  {
    v4 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v5 = 82i64;
  }
  WPP_SF_(*((_QWORD *)v4 + 2), v5, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
  return 2148074278i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180070D50) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::GenerateRsaCkeParameterList(
        CSsl3TlsClientContext *this,
        struct _BCryptBufferDesc *a2,
        unsigned __int8 *a3,
        unsigned int *a4,
        unsigned int *a5,
        unsigned __int64 *a6)
{
  unsigned int v6; // ebp
  unsigned int *v7; // rsi
  NCRYPT_HANDLE *v10; // r14
  unsigned int v11; // r8d
  PBCryptBuffer pBuffers; // rbx
  ULONG cBuffers; // r12d
  unsigned __int8 *v14; // rdx
  unsigned int v15; // r15d
  __int64 result; // rax
  char v17; // al
  __int64 v18; // rax
  NCRYPT_HANDLE v19; // [rsp+68h] [rbp+10h] BYREF

  v19 = 0i64;
  v6 = 0;
  v7 = a5;
  if ( !a2 )
    return 87i64;
  if ( !a5 )
    return 87i64;
  v10 = a6;
  if ( !a6 )
    return 87i64;
  v11 = *((_DWORD *)this + 244);
  pBuffers = a2->pBuffers;
  cBuffers = a2->cBuffers;
  if ( !v11 || (v14 = (unsigned __int8 *)*((_QWORD *)this + 121)) == 0i64 )
  {
LABEL_12:
    if ( (*((_DWORD *)this + 34) & 0x8000000) == 0 )
    {
      v6 = 2;
      if ( cBuffers < 2 )
        return 87i64;
      pBuffers->BufferType = 20;
      pBuffers->pvBuffer = (char *)this + 272;
      pBuffers->cbBuffer = 32;
      pBuffers[1].pvBuffer = (char *)this + 304;
      pBuffers[1].BufferType = 21;
      pBuffers[1].cbBuffer = 32;
    }
    if ( cBuffers >= v6 + 1 )
    {
      v17 = *((_BYTE *)this + 233);
      if ( v17 )
      {
        if ( *v7 >= 0xFEFD )
          goto LABEL_21;
      }
      else if ( *v7 <= 0x303 )
      {
LABEL_21:
        v18 = v6;
        pBuffers[v18].BufferType = 22;
        pBuffers[v18].cbBuffer = 4;
        pBuffers[v18].pvBuffer = v7;
        result = 0i64;
        a2->cBuffers = v6 + 1;
        return result;
      }
      *v7 = v17 != 0 ? 65277 : 771;
      goto LABEL_21;
    }
    return 87i64;
  }
  v15 = CSsl3TlsClientContext::ParseRsaServerKeyExchange(this, v14, v11, *a6, &v19);
  if ( !v15 )
  {
    NCryptFreeObject(*v10);
    *v10 = v19;
    goto LABEL_12;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_ef2bc8f963c43ddcdfece7ee9e95f200_Traceguids, v15);
  return v15;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180070EE8) ----------------------------------------------------
__int64 __fastcall GetRsaKeyModulus(__int64 a1, unsigned int *a2)
{
  __int64 result; // rax
  __int64 v4; // [rsp+50h] [rbp+18h] BYREF
  unsigned int *v5; // [rsp+58h] [rbp+20h] BYREF

  v5 = 0i64;
  result = SslGetKeyProperty(a1, L"Block Length", &v5, &v4, 0);
  if ( !(_DWORD)result )
  {
    *a2 = *v5;
    SslFreeBuffer();
    return 0i64;
  }
  return result;
}
// 1800858F8: using guessed type wchar_t aBlockLength[13];
// 180098480: using guessed type __int64 SslFreeBuffer(void);
// 180098550: using guessed type __int64 __fastcall SslGetKeyProperty(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);

//----- (0000000180070F40) ----------------------------------------------------
__int64 __fastcall CSslContext::I_RsaGenerateClientExchangeValue(
        CSslContext *this,
        unsigned __int8 *a2,
        unsigned int *a3,
        unsigned __int8 *a4)
{
  unsigned int SessionKeys; // ebx
  int v8; // r15d
  __int64 *v9; // rax
  __int64 pbData; // rsi
  DWORD cbData; // r9d
  unsigned int v12; // edx
  int v13; // r14d
  bool v14; // zf
  struct kexch *KeyExchangeInfo; // rax
  unsigned int v16; // ecx
  int v17; // edx
  unsigned int v18; // eax
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rcx
  unsigned __int8 v22; // r9
  __int64 *v23; // rax
  int v24; // edx
  __int64 v25; // r10
  unsigned int v26; // eax
  int v27; // r8d
  unsigned int v28; // eax
  __int64 *v29; // rax
  int v30; // edx
  __int64 v31; // r10
  __int64 v32; // rcx
  __int64 v33; // r8
  __int64 v34; // r9
  unsigned int v35; // ecx
  unsigned int v37; // [rsp+60h] [rbp-81h] BYREF
  int v38[2]; // [rsp+68h] [rbp-79h] BYREF
  NCRYPT_KEY_HANDLE hObject; // [rsp+70h] [rbp-71h] BYREF
  __int64 v40; // [rsp+78h] [rbp-69h] BYREF
  int v41; // [rsp+80h] [rbp-61h] BYREF
  unsigned __int64 v42; // [rsp+88h] [rbp-59h] BYREF
  __int128 v43; // [rsp+90h] [rbp-51h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v44; // [rsp+A0h] [rbp-41h] BYREF
  char v45[64]; // [rsp+B0h] [rbp-31h] BYREF

  SessionKeys = 0;
  v41 = *((_DWORD *)this + 9);
  hObject = 0i64;
  v42 = 0i64;
  v40 = 0i64;
  *(_QWORD *)v38 = 0i64;
  v37 = 0;
  v43 = 0i64;
  memset_0(v45, 0, sizeof(v45));
  v8 = *((_DWORD *)this + 16) & 0xA2A80;
  (*(void (__fastcall **)(CSslContext *, int *))(*(_QWORD *)this + 224i64))(this, v38);
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(*(_QWORD *)v38 + 72i64), 1u);
  v9 = *(__int64 **)(*(_QWORD *)v38 + 40i64);
  if ( !v9 || (pbData = *v9) == 0 )
  {
    RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)v38 + 72i64));
    v17 = 812;
    SessionKeys = 1359;
    goto LABEL_55;
  }
  cbData = *((_DWORD *)v9 + 2);
  v12 = cbData;
  v37 = cbData;
  if ( v8 )
  {
    v12 = cbData + 2;
    v37 = cbData + 2;
  }
  v13 = v8 != 0 ? 2 : 0;
  if ( !a2 )
  {
    RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)v38 + 72i64));
    *a3 = v37;
    goto LABEL_58;
  }
  if ( *a3 < v12 )
  {
    RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)v38 + 72i64));
    SessionKeys = -2146893023;
    *a3 = v37;
    goto LABEL_58;
  }
  if ( *(_DWORD *)(pbData + 16) == 1 )
  {
    v14 = g_fIgnoreExponentOfOne == 0;
    *(_DWORD *)(*(_QWORD *)v38 + 8i64) = 0;
    if ( v14 )
    {
      RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)v38 + 72i64));
      SessionKeys = -2146893015;
      goto LABEL_58;
    }
  }
  else
  {
    *(_DWORD *)(*(_QWORD *)v38 + 8i64) = *(_DWORD *)(pbData + 12);
    KeyExchangeInfo = GetKeyExchangeInfo(41984);
    v16 = *(_DWORD *)(pbData + 12);
    if ( v16 < *((_DWORD *)KeyExchangeInfo + 8) || v16 > *((_DWORD *)KeyExchangeInfo + 10) )
    {
      RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)v38 + 72i64));
      SessionKeys = 87;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_d(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xBu,
          (__int64)&WPP_ef2bc8f963c43ddcdfece7ee9e95f200_Traceguids,
          *(_DWORD *)(pbData + 12));
      v22 = 40;
      v17 = 813;
      goto LABEL_56;
    }
  }
  SessionKeys = NCryptImportKey(hProvider, 0i64, L"CAPIPUBLICBLOB", 0i64, &hObject, (PBYTE)pbData, cbData, 0);
  if ( SessionKeys )
  {
    RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)v38 + 72i64));
    v17 = 813;
LABEL_55:
    v22 = 80;
    goto LABEL_56;
  }
  DWORD1(v43) = 4;
  *((_QWORD *)&v43 + 1) = v45;
  v18 = (*(__int64 (__fastcall **)(CSslContext *, __int128 *, _QWORD, _QWORD, int *, NCRYPT_KEY_HANDLE *))(*(_QWORD *)this + 136i64))(
          this,
          &v43,
          0i64,
          0i64,
          &v41,
          &hObject);
  v21 = *(_QWORD *)v38;
  SessionKeys = v18;
  if ( v18 )
  {
    RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)v38 + 72i64));
    v22 = 51;
    v17 = 814;
LABEL_56:
    v27 = SessionKeys;
    goto LABEL_57;
  }
  if ( *(_QWORD *)(*(_QWORD *)v38 + 16i64) )
  {
    SslFreeObject(*(_QWORD *)(*(_QWORD *)v38 + 16i64), 0i64);
    *(_QWORD *)(*(_QWORD *)v38 + 16i64) = 0i64;
    v21 = *(_QWORD *)v38;
  }
  if ( !v8 || (*((_DWORD *)this + 34) & 0x8000000) == 0 )
  {
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McGenEventWrite_EventWriteTransfer(v21, &GenerateMasterKeyStart, v19, v20, &v44);
    if ( (*((_BYTE *)this + 32) & 1) != 0 && (v29 = (__int64 *)*((_QWORD *)this + 1)) != 0i64 )
    {
      v30 = *((_DWORD *)v29 + 7);
    }
    else
    {
      v29 = (__int64 *)*((_QWORD *)this + 1);
      v30 = 0;
    }
    if ( v29 )
      v31 = *v29;
    else
      v31 = 0i64;
    SessionKeys = SslGenerateMasterKey(
                    v31,
                    0i64,
                    hObject,
                    &v42,
                    *((unsigned __int16 *)this + 17),
                    v30,
                    &v43,
                    &a2[v13],
                    v37 - v13,
                    &v37,
                    1);
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McGenEventWrite_EventWriteTransfer(v32, &GenerateMasterKeyStop, v33, v34, &v44);
    if ( SessionKeys )
    {
      RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)v38 + 72i64));
      v22 = 51;
      v17 = 706;
      goto LABEL_56;
    }
    *(_QWORD *)(*(_QWORD *)v38 + 16i64) = v42;
    SessionKeys = CSslContext::MakeSessionKeys(this, v42);
    RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)v38 + 72i64));
    if ( SessionKeys )
      goto LABEL_58;
    if ( !v8 )
    {
      v35 = v37;
      goto LABEL_49;
    }
LABEL_47:
    v35 = v37;
    *a2 = BYTE1(v37);
    a2[1] = v35;
LABEL_49:
    *a3 = v13 + v35;
    LsaIModifyPerformanceCounter(6i64);
    goto LABEL_58;
  }
  RtlReleaseResource((PRTL_RESOURCE)(v21 + 72));
  if ( (*((_BYTE *)this + 32) & 1) != 0 && (v23 = (__int64 *)*((_QWORD *)this + 1)) != 0i64 )
  {
    v24 = *((_DWORD *)v23 + 7);
  }
  else
  {
    v23 = (__int64 *)*((_QWORD *)this + 1);
    v24 = 0;
  }
  if ( v23 )
    v25 = *v23;
  else
    v25 = 0i64;
  v26 = SslGeneratePreMasterKey(
          v25,
          hObject,
          &v40,
          *((unsigned __int16 *)this + 17),
          v24,
          &v43,
          &a2[v13],
          v37 - v13,
          &v37,
          1);
  SessionKeys = v26;
  if ( !v26 )
  {
    v28 = (*(__int64 (__fastcall **)(CSslContext *, __int64))(*(_QWORD *)this + 168i64))(this, v40);
    v40 = 0i64;
    SessionKeys = v28;
    goto LABEL_47;
  }
  v22 = 51;
  v27 = v26;
  v17 = 708;
LABEL_57:
  CSslContext::SetErrorAndFatalAlert((__int64)this, v17, v27, v22);
LABEL_58:
  if ( hObject )
    NCryptFreeObject(hObject);
  if ( v40 )
    SslFreeObject(v40, 0i64);
  return SessionKeys;
}
// 1800710F2: variable 'cbData' is possibly undefined
// 1800712BB: variable 'v19' is possibly undefined
// 1800712BB: variable 'v20' is possibly undefined
// 180071356: variable 'v32' is possibly undefined
// 180071356: variable 'v33' is possibly undefined
// 180071356: variable 'v34' is possibly undefined
// 180084BE0: using guessed type EVENT_DESCRIPTOR GenerateMasterKeyStop;
// 180084BF0: using guessed type EVENT_DESCRIPTOR GenerateMasterKeyStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 180092F1C: using guessed type int g_fIgnoreExponentOfOne;
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);
// 1800984A0: using guessed type __int64 __fastcall SslGenerateMasterKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 1800984A8: using guessed type __int64 __fastcall SslGeneratePreMasterKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (00000001800714C4) ----------------------------------------------------
__int64 __fastcall CSslContext::I_RsaGenerateEcdsaSignClientExchangeValue(
        CSslContext *this,
        unsigned __int8 *a2,
        unsigned int *a3)
{
  int v3; // eax
  int v7; // r15d
  _DWORD *v8; // rax
  unsigned int SessionKeys; // ebx
  int v10; // edx
  unsigned int v11; // eax
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rcx
  unsigned __int8 v15; // r9
  int v16; // ebx
  unsigned int v17; // edx
  unsigned __int8 *v18; // rcx
  __int64 *v19; // rax
  int v20; // r8d
  __int64 v21; // r10
  unsigned int v22; // eax
  int v23; // r8d
  unsigned int v24; // eax
  unsigned int v25; // edx
  unsigned __int8 *v26; // rcx
  __int64 *v27; // rax
  int v28; // r8d
  __int64 v29; // r10
  __int64 v30; // rcx
  __int64 v31; // r8
  __int64 v32; // r9
  unsigned int v33; // ecx
  unsigned int v35; // [rsp+60h] [rbp-69h] BYREF
  int v36[2]; // [rsp+68h] [rbp-61h] BYREF
  NCRYPT_KEY_HANDLE hObject; // [rsp+70h] [rbp-59h] BYREF
  __int64 v38; // [rsp+78h] [rbp-51h] BYREF
  int v39; // [rsp+80h] [rbp-49h] BYREF
  unsigned __int64 v40; // [rsp+88h] [rbp-41h] BYREF
  __int128 v41; // [rsp+90h] [rbp-39h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v42; // [rsp+A0h] [rbp-29h] BYREF
  char v43[64]; // [rsp+B0h] [rbp-19h] BYREF

  v3 = *((_DWORD *)this + 9);
  hObject = 0i64;
  v40 = 0i64;
  v38 = 0i64;
  *(_QWORD *)v36 = 0i64;
  v35 = 0;
  v39 = v3;
  v41 = 0i64;
  memset_0(v43, 0, sizeof(v43));
  v7 = *((_DWORD *)this + 16) & 0xA2A80;
  (*(void (__fastcall **)(CSslContext *, int *))(*(_QWORD *)this + 224i64))(this, v36);
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(*(_QWORD *)v36 + 72i64), 1u);
  v8 = *(_DWORD **)(*(_QWORD *)v36 + 40i64);
  if ( !v8 || !*(_QWORD *)v8 )
  {
    RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)v36 + 72i64));
    v10 = 825;
    SessionKeys = 1359;
    goto LABEL_52;
  }
  SessionKeys = NCryptImportKey(
                  *(_QWORD *)(*((_QWORD *)this + 1) + 64i64),
                  0i64,
                  L"ECCPUBLICBLOB",
                  0i64,
                  &hObject,
                  (PBYTE)(*(_QWORD *)v8 + 8i64),
                  v8[2] - 8,
                  0);
  if ( SessionKeys )
  {
    RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)v36 + 72i64));
    v10 = 813;
LABEL_52:
    v15 = 80;
    goto LABEL_53;
  }
  DWORD1(v41) = 4;
  *((_QWORD *)&v41 + 1) = v43;
  v11 = (*(__int64 (__fastcall **)(CSslContext *, __int128 *, _QWORD, _QWORD, int *, NCRYPT_KEY_HANDLE *))(*(_QWORD *)this + 136i64))(
          this,
          &v41,
          0i64,
          0i64,
          &v39,
          &hObject);
  v14 = *(_QWORD *)v36;
  SessionKeys = v11;
  if ( v11 )
  {
    RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)v36 + 72i64));
    v15 = 51;
    v10 = 826;
LABEL_53:
    v23 = SessionKeys;
    goto LABEL_54;
  }
  if ( *(_QWORD *)(*(_QWORD *)v36 + 16i64) )
  {
    SslFreeObject(*(_QWORD *)(*(_QWORD *)v36 + 16i64), 0i64);
    *(_QWORD *)(*(_QWORD *)v36 + 16i64) = 0i64;
    v14 = *(_QWORD *)v36;
  }
  v16 = v7 != 0 ? 2 : 0;
  if ( v7 && (*((_DWORD *)this + 34) & 0x8000000) != 0 )
  {
    RtlReleaseResource((PRTL_RESOURCE)(v14 + 72));
    if ( a2 )
    {
      v17 = *a3 - v16;
      v18 = &a2[v16];
    }
    else
    {
      v17 = 0;
      v18 = 0i64;
    }
    if ( (*((_BYTE *)this + 32) & 1) != 0 && (v19 = (__int64 *)*((_QWORD *)this + 1)) != 0i64 )
    {
      v20 = *((_DWORD *)v19 + 7);
    }
    else
    {
      v19 = (__int64 *)*((_QWORD *)this + 1);
      v20 = 0;
    }
    if ( v19 )
      v21 = *v19;
    else
      v21 = 0i64;
    v22 = SslGeneratePreMasterKey(v21, hObject, &v38, *((unsigned __int16 *)this + 17), v20, &v41, v18, v17, &v35, 1);
    SessionKeys = v22;
    if ( v22 )
    {
      v15 = 51;
      v23 = v22;
      v10 = 708;
LABEL_54:
      CSslContext::SetErrorAndFatalAlert((__int64)this, v10, v23, v15);
      goto LABEL_55;
    }
    v24 = (*(__int64 (__fastcall **)(CSslContext *, __int64))(*(_QWORD *)this + 168i64))(this, v38);
    v38 = 0i64;
    SessionKeys = v24;
LABEL_42:
    v33 = v35 + 2;
    v35 += 2;
    goto LABEL_44;
  }
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EventWriteTransfer(v14, &GenerateMasterKeyStart, v12, v13, &v42);
  if ( a2 )
  {
    v25 = *a3 - v16;
    v26 = &a2[v16];
  }
  else
  {
    v25 = 0;
    v26 = 0i64;
  }
  if ( (*((_BYTE *)this + 32) & 1) != 0 && (v27 = (__int64 *)*((_QWORD *)this + 1)) != 0i64 )
  {
    v28 = *((_DWORD *)v27 + 7);
  }
  else
  {
    v27 = (__int64 *)*((_QWORD *)this + 1);
    v28 = 0;
  }
  if ( v27 )
    v29 = *v27;
  else
    v29 = 0i64;
  SessionKeys = SslGenerateMasterKey(
                  v29,
                  0i64,
                  hObject,
                  &v40,
                  *((unsigned __int16 *)this + 17),
                  v28,
                  &v41,
                  v26,
                  v25,
                  &v35,
                  1);
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EventWriteTransfer(v30, &GenerateMasterKeyStop, v31, v32, &v42);
  if ( SessionKeys )
  {
    RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)v36 + 72i64));
    v15 = 51;
    v10 = 706;
    goto LABEL_53;
  }
  *(_QWORD *)(*(_QWORD *)v36 + 16i64) = v40;
  SessionKeys = CSslContext::MakeSessionKeys(this, v40);
  RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)v36 + 72i64));
  if ( SessionKeys )
    goto LABEL_55;
  if ( v7 )
    goto LABEL_42;
  v33 = v35;
LABEL_44:
  if ( a2 )
  {
    if ( *a3 >= v33 )
    {
      if ( v7 )
      {
        *a2 = (unsigned __int16)(v33 - 2) >> 8;
        a2[1] = v33 - 2;
      }
      *a3 = v33;
      LsaIModifyPerformanceCounter(6i64);
    }
    else
    {
      *a3 = v33;
      SessionKeys = -2146893023;
    }
  }
  else
  {
    *a3 = v33;
    SessionKeys = 0;
  }
LABEL_55:
  if ( hObject )
    NCryptFreeObject(hObject);
  if ( v38 )
    SslFreeObject(v38, 0i64);
  return SessionKeys;
}
// 180071795: variable 'v12' is possibly undefined
// 180071795: variable 'v13' is possibly undefined
// 18007183E: variable 'v30' is possibly undefined
// 18007183E: variable 'v31' is possibly undefined
// 18007183E: variable 'v32' is possibly undefined
// 180084BE0: using guessed type EVENT_DESCRIPTOR GenerateMasterKeyStop;
// 180084BF0: using guessed type EVENT_DESCRIPTOR GenerateMasterKeyStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);
// 1800984A0: using guessed type __int64 __fastcall SslGenerateMasterKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 1800984A8: using guessed type __int64 __fastcall SslGeneratePreMasterKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180071978) ----------------------------------------------------
__int64 __fastcall CSslContext::I_RsaGenerateEcdsaSignServerMasterKey(
        CSslContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  __int64 v6; // rax
  __int64 v7; // r15
  unsigned int SessionKeys; // ebx
  __int64 v9; // rax
  __int64 v10; // rax
  int v11; // eax
  int v12; // edx
  __int64 *v13; // rax
  int v14; // edx
  __int64 v15; // rcx
  __int64 v16; // rcx
  int v18; // [rsp+50h] [rbp-B0h] BYREF
  int v19; // [rsp+54h] [rbp-ACh] BYREF
  int v20; // [rsp+58h] [rbp-A8h] BYREF
  unsigned __int64 v21; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v22; // [rsp+68h] [rbp-98h] BYREF
  int v23[2]; // [rsp+70h] [rbp-90h] BYREF
  char *v24; // [rsp+78h] [rbp-88h]
  char v25; // [rsp+80h] [rbp-80h] BYREF
  char v26[64]; // [rsp+D0h] [rbp-30h] BYREF

  v21 = 0i64;
  v18 = 0;
  memset_0(v26, 0, sizeof(v26));
  v6 = *(_QWORD *)this;
  v20 = 0;
  v19 = 64;
  (*(void (__fastcall **)(CSslContext *, __int64 *))(v6 + 232))(this, &v22);
  v7 = *((_QWORD *)this + 14);
  if ( !v7 )
  {
    SessionKeys = CSslContext::ImpersonateNonLsNs(this, &v18);
    if ( SessionKeys )
      goto LABEL_33;
    v9 = *((_QWORD *)this + 3);
    if ( !v9 )
    {
      SessionKeys = -2146893043;
      goto LABEL_33;
    }
    v7 = *(_QWORD *)(v9 + 8);
  }
  if ( a3 < 2 )
  {
    SessionKeys = -2146893048;
    goto LABEL_33;
  }
  if ( (*((_DWORD *)this + 16) & 0x51550) != 0 && ((*a2 << 8) | a2[1]) + 2 == a3 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_ef2bc8f963c43ddcdfece7ee9e95f200_Traceguids);
    a2 += 2;
    a3 -= 2;
  }
  v23[0] = 0;
  v24 = &v25;
  v10 = *(_QWORD *)this;
  v23[1] = 5;
  v11 = (*(__int64 (__fastcall **)(CSslContext *, __int64, int *, int *, char *, int *))(v10 + 128))(
          this,
          1i64,
          &v20,
          v23,
          v26,
          &v19);
  SessionKeys = v11;
  if ( v11 )
  {
    v12 = 707;
LABEL_16:
    CSslContext::SetErrorAndFatalAlert((__int64)this, v12, v11, 0x33u);
    goto LABEL_33;
  }
  if ( (*((_BYTE *)this + 32) & 1) != 0 && (v13 = (__int64 *)*((_QWORD *)this + 1)) != 0i64 )
  {
    v14 = *((_DWORD *)v13 + 7);
  }
  else
  {
    v13 = (__int64 *)*((_QWORD *)this + 1);
    v14 = 0;
  }
  if ( v13 )
    v15 = *v13;
  else
    v15 = 0i64;
  v11 = SslImportMasterKey(v15, v7, &v21, *((unsigned __int16 *)this + 17), v14, v23, a2, a3, 2);
  SessionKeys = v11;
  if ( v11 )
  {
    v12 = 701;
    goto LABEL_16;
  }
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(v22 + 72), 1u);
  *(_QWORD *)(v22 + 16) = v21;
  v16 = *((_QWORD *)this + 14);
  if ( v16 )
  {
    SslFreeObject(v16, 0i64);
    *((_QWORD *)this + 14) = 0i64;
  }
  SessionKeys = CSslContext::MakeSessionKeys(this, v21);
  RtlReleaseResource((PRTL_RESOURCE)(v22 + 72));
  if ( SessionKeys )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        13i64,
        &WPP_ef2bc8f963c43ddcdfece7ee9e95f200_Traceguids,
        SessionKeys);
  }
  else
  {
    LsaIModifyPerformanceCounter(8i64);
  }
LABEL_33:
  if ( v18 )
    RevertToSelf();
  return SessionKeys;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);
// 180098410: using guessed type __int64 __fastcall SslImportMasterKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, _DWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180071C4C) ----------------------------------------------------
__int64 __fastcall CSslContext::I_RsaGenerateServerMasterKey(CSslContext *this, unsigned __int8 *a2, unsigned int a3)
{
  __int64 v6; // rax
  __int64 v7; // r15
  unsigned int RsaKeyModulus; // ebx
  __int64 v9; // rax
  unsigned int v10; // ebx
  unsigned int v11; // ebx
  int v12; // ecx
  unsigned __int8 v13; // r9
  int v14; // edx
  __int64 v15; // rax
  __int64 *v16; // rax
  int v17; // edx
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v21; // [rsp+50h] [rbp-B0h] BYREF
  int v22; // [rsp+58h] [rbp-A8h] BYREF
  unsigned int v23; // [rsp+5Ch] [rbp-A4h] BYREF
  int v24; // [rsp+60h] [rbp-A0h] BYREF
  int v25; // [rsp+64h] [rbp-9Ch] BYREF
  unsigned __int64 v26; // [rsp+68h] [rbp-98h] BYREF
  int v27[2]; // [rsp+70h] [rbp-90h] BYREF
  char *v28; // [rsp+78h] [rbp-88h]
  char v29; // [rsp+80h] [rbp-80h] BYREF
  char v30[64]; // [rsp+D0h] [rbp-30h] BYREF

  v26 = 0i64;
  v22 = 0;
  memset_0(v30, 0, sizeof(v30));
  v6 = *(_QWORD *)this;
  v25 = 0;
  v24 = 64;
  (*(void (__fastcall **)(CSslContext *, __int64 *))(v6 + 232))(this, &v21);
  v7 = *((_QWORD *)this + 14);
  if ( !v7 )
  {
    RsaKeyModulus = CSslContext::ImpersonateNonLsNs(this, &v22);
    if ( RsaKeyModulus )
      goto LABEL_37;
    v9 = *((_QWORD *)this + 3);
    if ( !v9 )
    {
      RsaKeyModulus = -2146893043;
      goto LABEL_37;
    }
    v7 = *(_QWORD *)(v9 + 8);
  }
  RsaKeyModulus = GetRsaKeyModulus(v7, &v23);
  if ( !RsaKeyModulus )
  {
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(v21 + 72), 1u);
    v10 = 8 * v23;
    *(_DWORD *)(v21 + 8) = 8 * v23;
    v11 = (v10 + 7) >> 3;
    if ( a3 < 2 )
    {
      RtlReleaseResource((PRTL_RESOURCE)(v21 + 72));
      RsaKeyModulus = -2146893048;
      goto LABEL_37;
    }
    if ( (*((_DWORD *)this + 16) & 0x51550) != 0 )
    {
      v12 = a2[1] | (*a2 << 8);
      if ( v12 == v11 && v12 + 2 == a3 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &WPP_ef2bc8f963c43ddcdfece7ee9e95f200_Traceguids);
        a2 += 2;
        a3 -= 2;
      }
    }
    if ( a3 < v11 )
    {
      RtlReleaseResource((PRTL_RESOURCE)(v21 + 72));
      v13 = 50;
      v14 = 700;
      RsaKeyModulus = -2146893048;
LABEL_18:
      CSslContext::SetErrorAndFatalAlert((__int64)this, v14, RsaKeyModulus, v13);
      goto LABEL_37;
    }
    v27[0] = 0;
    v28 = &v29;
    v15 = *(_QWORD *)this;
    v27[1] = 5;
    RsaKeyModulus = (*(__int64 (__fastcall **)(CSslContext *, __int64, int *, int *, char *, int *))(v15 + 128))(
                      this,
                      1i64,
                      &v25,
                      v27,
                      v30,
                      &v24);
    if ( RsaKeyModulus )
    {
      RtlReleaseResource((PRTL_RESOURCE)(v21 + 72));
      v13 = 51;
      v14 = 707;
      goto LABEL_18;
    }
    if ( (*((_BYTE *)this + 32) & 1) != 0 && (v16 = (__int64 *)*((_QWORD *)this + 1)) != 0i64 )
    {
      v17 = *((_DWORD *)v16 + 7);
    }
    else
    {
      v16 = (__int64 *)*((_QWORD *)this + 1);
      v17 = 0;
    }
    if ( v16 )
      v18 = *v16;
    else
      v18 = 0i64;
    RsaKeyModulus = SslImportMasterKey(v18, v7, &v26, *((unsigned __int16 *)this + 17), v17, v27, a2, a3, 2);
    if ( RsaKeyModulus )
    {
      RtlReleaseResource((PRTL_RESOURCE)(v21 + 72));
      v13 = 51;
      v14 = 701;
      goto LABEL_18;
    }
    *(_QWORD *)(v21 + 16) = v26;
    v19 = *((_QWORD *)this + 14);
    if ( v19 )
    {
      SslFreeObject(v19, 0i64);
      *((_QWORD *)this + 14) = 0i64;
    }
    RsaKeyModulus = CSslContext::MakeSessionKeys(this, v26);
    RtlReleaseResource((PRTL_RESOURCE)(v21 + 72));
    if ( RsaKeyModulus )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          15i64,
          &WPP_ef2bc8f963c43ddcdfece7ee9e95f200_Traceguids,
          RsaKeyModulus);
    }
    else
    {
      LsaIModifyPerformanceCounter(8i64);
    }
  }
LABEL_37:
  if ( v22 )
    RevertToSelf();
  return RsaKeyModulus;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);
// 180098410: using guessed type __int64 __fastcall SslImportMasterKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, _DWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180071FC4) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::ParseRsaServerKeyExchange(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        NCRYPT_KEY_HANDLE a4,
        unsigned __int64 *a5)
{
  CSsl3TlsClientContext *v7; // rsi
  unsigned __int8 v9; // r9
  int v10; // ecx
  unsigned __int8 *v11; // rax
  unsigned __int8 v12; // dl
  unsigned int v13; // r9d
  unsigned __int8 *v14; // rcx
  unsigned int v15; // ebx
  unsigned int v16; // ebx
  unsigned __int8 *v17; // rdx
  __int64 v18; // rcx
  unsigned int v19; // ebx
  __int64 v20; // r8
  unsigned __int8 *v21; // r15
  int v22; // r12d
  __int64 v23; // rcx
  int v24; // eax
  int v25; // eax
  unsigned int v26; // eax
  __int64 v27; // rcx
  unsigned int v28; // ebx
  DWORD cbSignature; // r14d
  int v30; // eax
  unsigned int v31; // edi
  unsigned __int8 v32; // r9
  int v33; // edx
  int v34; // r14d
  unsigned int *p_pPaddingInfo; // rbx
  DWORD v36; // edi
  unsigned __int64 v37; // rcx
  unsigned __int64 v38; // rax
  void *v39; // rsp
  _DWORD *v40; // rax
  unsigned __int8 *v41; // rdx
  int v42; // eax
  __int64 v43; // [rsp+0h] [rbp-40h] BYREF
  unsigned int v44; // [rsp+40h] [rbp+0h] BYREF
  __int64 pPaddingInfo; // [rsp+48h] [rbp+8h] BYREF
  NCRYPT_KEY_HANDLE hKey; // [rsp+50h] [rbp+10h]
  unsigned __int8 *v47; // [rsp+58h] [rbp+18h]
  NCRYPT_KEY_HANDLE *phKey; // [rsp+60h] [rbp+20h]
  BYTE pbHashValue[40]; // [rsp+68h] [rbp+28h] BYREF

  hKey = a4;
  phKey = a5;
  pPaddingInfo = 0i64;
  v7 = this;
  if ( !a2 )
  {
    *a5 = 0i64;
    return 0i64;
  }
  if ( a3 >= 3 )
  {
    v10 = a2[1] | (*a2 << 8);
    v11 = a2 + 2;
    v12 = a2[2];
    v13 = v10 - 1;
    if ( v12 )
      v13 = v10;
    v14 = v11 + 1;
    if ( v12 )
      v14 = v11;
    v44 = v13;
    v47 = v14;
    v15 = v13 + 3 - (v12 != 0);
    if ( v13 - 64 > 0x40 )
      goto LABEL_51;
    if ( a3 < v15 )
      goto LABEL_51;
    v16 = v15 + 2;
    v17 = &v14[v13];
    if ( a3 < v16 )
      goto LABEL_51;
    v18 = v17[1] | (*v17 << 8);
    v19 = v18 + v16;
    if ( (unsigned int)(v18 - 1) > 3 || a3 < v19 )
      goto LABEL_51;
    v20 = (unsigned int)v18;
    v21 = &v17[v18];
    v22 = 0;
    if ( !(_DWORD)v18 )
      goto LABEL_23;
    v23 = 0i64;
    do
    {
      v24 = v17[v23++ + 2];
      v25 = (v22 << 8) | v24;
      v22 = v25;
      --v20;
    }
    while ( v20 );
    if ( v25 == 1 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && ((unsigned __int8)v25 & *((_BYTE *)WPP_GLOBAL_Control + 28)) != 0 )
      {
        WPP_SF_(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          (unsigned int)(v25 + 15),
          &WPP_ef2bc8f963c43ddcdfece7ee9e95f200_Traceguids);
      }
      v26 = 0;
      if ( !g_fIgnoreExponentOfOne )
        return 2148074281i64;
    }
    else
    {
LABEL_23:
      v26 = 8 * v13;
    }
    v27 = *((_QWORD *)v7 + 165);
    if ( v26 < *(_DWORD *)(v27 + 8) )
      *(_DWORD *)(v27 + 8) = v26;
    v28 = v19 + 2;
    if ( a3 < v28 || (cbSignature = v21[3] + (v21[2] << 8), a3 < cbSignature + v28) )
    {
LABEL_51:
      v9 = 47;
      this = v7;
      goto LABEL_52;
    }
    v30 = CSsl3TlsContext::ComputeRsaServerExchangeHashes((UCHAR *)v7, a2, (_DWORD)v21 + 2 - (_DWORD)a2, pbHashValue);
    v31 = v30;
    if ( v30 )
    {
      v32 = 80;
      v33 = 815;
LABEL_30:
      CSslContext::SetErrorAndFatalAlert((__int64)v7, v33, v30, v32);
      return v31;
    }
    v30 = NCryptVerifySignature(hKey, &pPaddingInfo, pbHashValue, 0x24u, v21 + 4, cbSignature, 2u);
    v31 = v30;
    if ( v30 )
    {
      v32 = 51;
      v33 = 816;
      goto LABEL_30;
    }
    v34 = v44;
    p_pPaddingInfo = 0i64;
    v36 = v44 + 20;
    if ( v44 == -20 )
      goto LABEL_41;
    if ( v36 > (unsigned __int64)g_ulMaxStackAllocSize )
      goto LABEL_41;
    v37 = v36 + g_ulAdditionalProbeSize + 8;
    if ( v37 < v36 || !(unsigned int)VerifyStackAvailable(v37) )
      goto LABEL_41;
    v38 = v44 + 28 + 15i64;
    if ( v38 <= v44 + 28 )
      v38 = 0xFFFFFFFFFFFFFF0i64;
    v39 = alloca(v38 & 0xFFFFFFFFFFFFFFF0ui64);
    p_pPaddingInfo = &v44;
    if ( &v43 == (__int64 *)-64i64 || (v44 = 1801679955, (p_pPaddingInfo = (unsigned int *)&pPaddingInfo) == 0i64) )
    {
LABEL_41:
      if ( v36 + 8 >= v36 )
      {
        v40 = (_DWORD *)((__int64 (__fastcall *)(_QWORD))g_pfnAllocate)(v36 + 8);
        if ( !v40 )
          return 14i64;
        *v40 = 1885431112;
        p_pPaddingInfo = v40 + 2;
      }
      if ( !p_pPaddingInfo )
        return 14i64;
    }
    v41 = v47;
    p_pPaddingInfo[3] = 8 * v34;
    *p_pPaddingInfo = 518;
    p_pPaddingInfo[1] = 41984;
    p_pPaddingInfo[2] = 826364754;
    p_pPaddingInfo[4] = v22;
    ReverseMemCopy((unsigned __int8 *)p_pPaddingInfo + 20, v41, v34);
    v42 = NCryptImportKey(hProvider, 0i64, L"CAPIPUBLICBLOB", 0i64, phKey, (PBYTE)p_pPaddingInfo, v36, 0);
    v31 = v42;
    if ( v42 )
      CSslContext::SetErrorAndFatalAlert((__int64)v7, 817, v42, 0x33u);
    if ( *(p_pPaddingInfo - 2) == 1885431112 )
      ((void (__fastcall *)(unsigned int *))g_pfnFree)(p_pPaddingInfo - 2);
    return v31;
  }
  v9 = 50;
LABEL_52:
  CSslContext::SetErrorAndFatalAlert((__int64)this, 811, -2146893048, v9);
  return 2148074248i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180092F1C: using guessed type int g_fIgnoreExponentOfOne;

//----- (0000000180072378) ----------------------------------------------------
__int64 __fastcall CSslContext::RsaGenerateClientExchangeValue(
        CSslContext *this,
        unsigned __int8 *a2,
        unsigned int *a3,
        unsigned __int8 *a4)
{
  unsigned __int8 *v4; // r9

  v4 = (unsigned __int8 *)*(unsigned int *)(*((_QWORD *)this + 1) + 52i64);
  if ( (_DWORD)v4 == 2 )
    return CSslContext::I_RsaGenerateClientExchangeValue(this, a2, a3, v4);
  if ( (_DWORD)v4 == 4 )
    return CSslContext::I_RsaGenerateEcdsaSignClientExchangeValue(this, a2, a3);
  return 2148074248i64;
}

//----- (00000001800723A4) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::RsaGenerateServerExchangeValue(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned int *a3)
{
  int v3; // eax
  __int64 v5; // rcx
  __int64 result; // rax
  __int64 v9; // rax
  unsigned int v10; // eax
  unsigned int v11; // ebx
  __int64 *v12; // rax
  __int64 v13; // r9
  __int64 v14; // rcx
  int EphemeralKey; // eax
  ULONG v16; // ebx
  __int64 *v17; // rax
  __int64 v18; // rcx
  int EphemBlobFromKey; // eax
  unsigned __int8 *v20; // r15
  __int64 v21; // rsi
  unsigned __int8 *v22; // rbx
  __int64 v23; // rcx
  int v24; // eax
  unsigned __int8 *v25; // rdi
  int v26; // esi
  int v27; // eax
  int v28; // edx
  __int64 *v29; // rax
  __int64 v30; // rcx
  int v31; // [rsp+50h] [rbp-29h] BYREF
  int v32; // [rsp+54h] [rbp-25h]
  int v33; // [rsp+58h] [rbp-21h] BYREF
  unsigned int v34; // [rsp+5Ch] [rbp-1Dh] BYREF
  unsigned int v35; // [rsp+60h] [rbp-19h] BYREF
  unsigned __int8 *v36; // [rsp+68h] [rbp-11h] BYREF
  unsigned __int8 v37[40]; // [rsp+70h] [rbp-9h] BYREF

  v3 = *a3;
  v33 = 0;
  v5 = *((_QWORD *)this + 3);
  v35 = 0;
  v36 = 0i64;
  v32 = v3;
  v31 = 0;
  if ( !v5 )
    return 2148074253i64;
  if ( (*((_BYTE *)this + 32) & 1) == 0 )
    goto LABEL_9;
  v9 = *((_QWORD *)this + 1);
  if ( !v9 )
    goto LABEL_9;
  v10 = *(_DWORD *)(v9 + 28);
  if ( v10 != 3 )
  {
    if ( v10 <= 0x61 )
    {
LABEL_9:
      *a3 = 0;
      return 0i64;
    }
    if ( v10 <= 0x64 )
    {
      v11 = 128;
      goto LABEL_14;
    }
    if ( v10 != 131200 )
      goto LABEL_9;
  }
  v11 = 64;
LABEL_14:
  result = GetRsaKeyModulus(*(_QWORD *)(v5 + 8), &v34);
  if ( !(_DWORD)result )
  {
    if ( v34 <= v11 )
      goto LABEL_9;
    if ( !a2 )
    {
      *a3 = v11 + v34 + 10;
      return 0i64;
    }
    if ( (*((_BYTE *)this + 32) & 1) != 0 && (v12 = (__int64 *)*((_QWORD *)this + 1)) != 0i64 )
    {
      v13 = *((unsigned int *)v12 + 7);
    }
    else
    {
      v12 = (__int64 *)*((_QWORD *)this + 1);
      v13 = 0i64;
    }
    if ( v12 )
      v14 = *v12;
    else
      v14 = 0i64;
    EphemeralKey = SslCreateEphemeralKey(
                     v14,
                     (char *)this + 112,
                     *((unsigned __int16 *)this + 17),
                     v13,
                     0,
                     8 * v11,
                     0i64,
                     0,
                     0);
    v16 = EphemeralKey;
    if ( EphemeralKey )
    {
      CSslContext::SetErrorAndFatalAlert((__int64)this, 818, EphemeralKey, 0x33u);
      return v16;
    }
    v17 = (__int64 *)*((_QWORD *)this + 1);
    if ( v17 )
      v18 = *v17;
    else
      v18 = 0i64;
    EphemBlobFromKey = GetEphemBlobFromKey(v18, *((_QWORD *)this + 14), L"RSAPUBLICBLOB", &v35, &v36);
    v20 = v36;
    v16 = EphemBlobFromKey;
    if ( EphemBlobFromKey )
    {
      CSslContext::SetErrorAndFatalAlert((__int64)this, 819, EphemBlobFromKey, 0x33u);
LABEL_44:
      if ( v20 )
        SPExternalFree(v20);
      return v16;
    }
    *a2 = BYTE1(*((_DWORD *)v36 + 3));
    a2[1] = v20[12];
    memcpy_0(a2 + 2, &v20[*((unsigned int *)v20 + 2) + 24], *((unsigned int *)v20 + 3));
    v21 = *((unsigned int *)v20 + 3);
    v22 = &a2[v21 + 2];
    *v22 = BYTE1(*((_DWORD *)v20 + 2));
    v22[1] = v20[8];
    memcpy_0(v22 + 2, v20 + 24, *((unsigned int *)v20 + 2));
    v23 = *((unsigned int *)v20 + 2);
    v24 = v32 - v23 - v21;
    LODWORD(v21) = *((_DWORD *)v20 + 3);
    v32 = v24;
    v25 = &v22[v23 + 2];
    v26 = v23 + v21;
    v16 = SslImpersonateClient(*(_QWORD *)(*((_QWORD *)this + 10) + 752i64), &v33);
    if ( !v16 )
    {
      v27 = CSsl3TlsContext::ComputeRsaServerExchangeHashes((UCHAR *)this, a2, v26 + 4, v37);
      v16 = v27;
      if ( v27 )
      {
        v28 = 815;
LABEL_35:
        CSslContext::SetErrorAndFatalAlert((__int64)this, v28, v27, 0x50u);
        goto LABEL_42;
      }
      v29 = (__int64 *)*((_QWORD *)this + 1);
      if ( v29 )
        v30 = *v29;
      else
        v30 = 0i64;
      v27 = SslSignHash(v30, *(_QWORD *)(*((_QWORD *)this + 3) + 8i64), v37, 36i64, v25 + 2, v32 - 6, &v31, 0);
      v16 = v27;
      if ( v27 )
      {
        v28 = 820;
        goto LABEL_35;
      }
      *v25 = BYTE1(v31);
      v25[1] = v31;
      *a3 = (_DWORD)v25 - (_DWORD)a2 + v31 + 2;
    }
LABEL_42:
    if ( v33 )
      RevertToSelf();
    goto LABEL_44;
  }
  return result;
}
// 180098540: using guessed type __int64 __fastcall SslSignHash(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 180098548: using guessed type __int64 __fastcall SslCreateEphemeralKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _DWORD, _DWORD);

//----- (00000001800726B8) ----------------------------------------------------
void __fastcall DTlsHandshakeQueue::~DTlsHandshakeQueue(DTlsHandshakeQueue *this)
{
  DTlsMessage *v2; // rcx
  DTlsMessage *v3; // rcx

  v2 = (DTlsMessage *)*((_QWORD *)this + 2);
  if ( v2 )
  {
    DTlsMessage::`scalar deleting destructor'(v2);
    *((_QWORD *)this + 2) = 0i64;
  }
  v3 = (DTlsMessage *)*((_QWORD *)this + 3);
  if ( v3 )
  {
    DTlsMessage::`scalar deleting destructor'(v3);
    *((_QWORD *)this + 3) = 0i64;
  }
}

//----- (00000001800726F4) ----------------------------------------------------
void __fastcall DTlsMsgMgr::~DTlsMsgMgr(DTlsMsgMgr *this)
{
  DTlsMessage *v1; // rsi
  DTlsMessage *v3; // rbx
  DTlsMessage *v4; // rcx
  DTlsMsgMgr *v5; // rbx
  DTlsMessage *v6; // rcx
  DTlsMsgMgr *v7; // rbx
  DTlsRec *v8; // rcx
  _QWORD **v9; // rdi
  _QWORD *v10; // rbx
  DTlsRec *v11; // rcx

  v1 = (DTlsMsgMgr *)((char *)this + 24);
  v3 = (DTlsMessage *)*((_QWORD *)this + 3);
  while ( v3 != v1 )
  {
    v4 = v3;
    v3 = *(DTlsMessage **)v3;
    DTlsMessage::`scalar deleting destructor'(v4);
  }
  v5 = (DTlsMsgMgr *)*((_QWORD *)this + 5);
  while ( v5 != (DTlsMsgMgr *)((char *)this + 40) )
  {
    v6 = v5;
    v5 = *(DTlsMsgMgr **)v5;
    DTlsMessage::`scalar deleting destructor'(v6);
  }
  v7 = (DTlsMsgMgr *)*((_QWORD *)this + 7);
  while ( v7 != (DTlsMsgMgr *)((char *)this + 56) )
  {
    v8 = (DTlsMsgMgr *)((char *)v7 - 40);
    v7 = *(DTlsMsgMgr **)v7;
    if ( v8 )
      DTlsRec::`scalar deleting destructor'(v8);
  }
  v9 = (_QWORD **)((char *)this + 72);
  v10 = *v9;
  while ( v10 != v9 )
  {
    v11 = (DTlsRec *)(v10 - 5);
    v10 = (_QWORD *)*v10;
    if ( v11 )
      DTlsRec::`scalar deleting destructor'(v11);
  }
}

//----- (0000000180072790) ----------------------------------------------------
void __fastcall DTlsRec::~DTlsRec(DTlsRec *this)
{
  if ( *((_QWORD *)this + 1) )
    (*(void (__fastcall **)(_QWORD, _QWORD))(**((_QWORD **)this + 2) + 16i64))(
      *((_QWORD *)this + 2),
      *((_QWORD *)this + 3));
}

//----- (00000001800727CC) ----------------------------------------------------
DTlsRec *__fastcall DTlsRec::`scalar deleting destructor'(DTlsRec *this)
{
  DTlsRec::~DTlsRec(this);
  if ( this )
    SPExternalFree(this);
  return this;
}

//----- (00000001800727F8) ----------------------------------------------------
struct DTlsMessage *__fastcall DTlsMsgMgr::AddMsg(DTlsMsgMgr *this, __int64 a2, __int64 a3, int a4)
{
  unsigned int v5; // ebp
  int v6; // r15d
  DTlsMessage *v8; // rbx
  CCipherMill *v9; // r10
  char *v10; // rax
  __int64 v11; // r8
  DTlsMessage *v12; // rdi
  CCipherMill *v13; // rcx
  __int64 v14; // rcx
  const unsigned __int16 *v15; // rdx
  unsigned int v16; // ecx

  v5 = a3;
  v6 = a2;
  v8 = 0i64;
  v9 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_DDDD(*((_QWORD *)WPP_GLOBAL_Control + 2), a2, a3, a2, a3, a4);
    v9 = WPP_GLOBAL_Control;
  }
  if ( v5 < *(_DWORD *)this || v5 >= *((_DWORD *)this + 2) + *(_DWORD *)this )
  {
    if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
      WPP_SF_D(*((_QWORD *)v9 + 2), 12i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids, v5);
    v14 = *(_QWORD *)(*((_QWORD *)this + 11) + 80i64);
    if ( v14 )
    {
      v15 = (const unsigned __int16 *)(v14 + 216);
      v16 = *(_DWORD *)(v14 + 212);
    }
    else
    {
      v15 = &Class;
      v16 = 0;
    }
    LogDtlsRecordOutOfRecvWindow(v16, v15);
    goto LABEL_23;
  }
  v10 = (char *)SPExternalAlloc(0x48u);
  v12 = (DTlsMessage *)v10;
  if ( v10 )
  {
    *((_DWORD *)v10 + 4) = 0;
    *(_QWORD *)(v10 + 28) = 0i64;
    *((_QWORD *)v10 + 5) = 0i64;
    *((_QWORD *)v10 + 6) = 0i64;
    *((_QWORD *)v10 + 7) = 0i64;
    *((_DWORD *)v10 + 17) = 0;
    if ( (unsigned int)DTlsMessage::initMsg((DTlsMessage *)v10, v5, v6, a4, 0xCu) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
      DTlsMessage::`scalar deleting destructor'(v12);
    }
    else
    {
      DTlsMsgMgr::insertMsg(this, v12);
      ++*((_DWORD *)this + 1);
      v8 = v12;
    }
    goto LABEL_23;
  }
  v13 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control )
    return v8;
  if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
LABEL_23:
    v13 = WPP_GLOBAL_Control;
  }
  if ( v13 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v13 + 28) & 4) != 0 )
    WPP_SF_P(*((_QWORD *)v13 + 2), 0xFu, v11, v8);
  return v8;
}
// 180072991: variable 'v11' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800729C0) ----------------------------------------------------
struct DTlsRec *__fastcall DTlsMsgMgr::AddOutgoingRec(DTlsMsgMgr *this, unsigned int a2)
{
  _QWORD *v2; // rsi
  _QWORD *v3; // rbx
  DTlsMsgMgr *v6; // rdi
  DTlsMsgMgr *v7; // r14
  DTlsRec *v8; // rcx
  _QWORD *v9; // rax
  _QWORD *v10; // rdi
  _QWORD *v11; // rcx
  _QWORD *v12; // rax

  v2 = (_QWORD *)((char *)this + 56);
  v3 = 0i64;
  if ( (_QWORD *)*v2 == v2 )
  {
    v6 = (DTlsMsgMgr *)((char *)this + 72);
    v7 = (DTlsMsgMgr *)*((_QWORD *)this + 9);
    if ( v7 != (DTlsMsgMgr *)((char *)this + 72) )
    {
      do
      {
        v8 = (DTlsMsgMgr *)((char *)v7 - 40);
        v7 = *(DTlsMsgMgr **)v7;
        if ( v8 )
          DTlsRec::`scalar deleting destructor'(v8);
      }
      while ( v7 != v6 );
      *((_QWORD *)v6 + 1) = v6;
      *(_QWORD *)v6 = v6;
    }
  }
  v9 = SPExternalAlloc(0x38u);
  v10 = v9;
  if ( v9 )
  {
    v9[1] = 0i64;
    *v9 = 0i64;
    if ( (unsigned int)DTlsRec::initRec((DTlsRec *)v9, a2, *((struct CSsl3TlsContext **)this + 11)) )
    {
      DTlsRec::`scalar deleting destructor'((DTlsRec *)v10);
    }
    else
    {
      v11 = (_QWORD *)v2[1];
      v12 = v10 + 5;
      if ( (_QWORD *)*v11 != v2 )
        __fastfail(3u);
      *v12 = v2;
      v3 = v10;
      v10[6] = v11;
      *v11 = v12;
      v2[1] = v12;
    }
  }
  return (struct DTlsRec *)v3;
}

//----- (0000000180072A90) ----------------------------------------------------
void __fastcall DTlsHandshakeQueue::DtlsHandshakeDone(DTlsHandshakeQueue *this)
{
  DTlsMessage *v2; // rcx
  DTlsMessage *v3; // rcx

  *((_DWORD *)this + 2) = 0;
  v2 = (DTlsMessage *)*((_QWORD *)this + 2);
  if ( v2 )
  {
    DTlsMessage::`scalar deleting destructor'(v2);
    *((_QWORD *)this + 2) = 0i64;
  }
  *((_DWORD *)this + 3) = 0;
  v3 = (DTlsMessage *)*((_QWORD *)this + 3);
  if ( v3 )
  {
    DTlsMessage::`scalar deleting destructor'(v3);
    *((_QWORD *)this + 3) = 0i64;
  }
  *((_DWORD *)this + 8) = 4;
}

//----- (0000000180072ADC) ----------------------------------------------------
__int64 __fastcall DTlsHandshakeQueue::DtlsReorderHandshake(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int a4,
        unsigned __int64 a5)
{
  unsigned int v5; // ebp
  unsigned __int8 *v6; // rdi
  int v7; // r15d
  unsigned int v9; // ebx
  CCipherMill *v10; // r10
  CSsl3TlsContext *v11; // r8
  __int64 v12; // rax
  unsigned int v13; // r13d
  const unsigned __int16 *v14; // r12
  unsigned int v15; // eax
  CCipherMill *v16; // r11
  int v17; // r15d
  unsigned int v18; // r12d
  unsigned int v19; // esi
  CCipherMill *v20; // r10
  DTlsMsgMgr *v21; // r11
  struct DTlsMessage *Msg; // r13
  __int64 v23; // rdx
  unsigned int v24; // eax
  __int64 v25; // rdx
  unsigned __int16 *v27; // [rsp+70h] [rbp+8h]
  unsigned int v28; // [rsp+78h] [rbp+10h]
  int v29; // [rsp+90h] [rbp+28h]

  v5 = a4;
  v6 = (unsigned __int8 *)a3;
  v7 = a2;
  v9 = 590610;
  v10 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_DDi(*((_QWORD *)WPP_GLOBAL_Control + 2), a2, a3, a2, a4, a5);
    v10 = WPP_GLOBAL_Control;
  }
  v11 = *(CSsl3TlsContext **)(a1 + 40);
  v12 = *((_QWORD *)v11 + 10);
  if ( v12 )
  {
    v13 = *(_DWORD *)(v12 + 212);
    v14 = (const unsigned __int16 *)(v12 + 216);
  }
  else
  {
    v14 = &Class;
    v13 = 0;
  }
  v28 = v13;
  v27 = (unsigned __int16 *)v14;
  if ( v7 == 20 )
  {
    v15 = DTlsHandshakeQueue::SetCcs((DTlsHandshakeQueue *)a1, v6, v5, a5);
LABEL_9:
    v9 = v15;
    goto LABEL_55;
  }
  if ( v7 != 22 )
  {
    if ( v10 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v10 + 28) & 1) == 0 )
      goto LABEL_56;
    WPP_SF_(*((_QWORD *)v10 + 2), 34i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
LABEL_55:
    v10 = WPP_GLOBAL_Control;
    goto LABEL_56;
  }
  if ( *(_DWORD *)(a1 + 36) == -1 || *(_DWORD *)(a1 + 36) < HIWORD(a5) )
  {
    v15 = DTlsHandshakeQueue::SetFinish((DTlsHandshakeQueue *)a1, v6, v5, a5);
    goto LABEL_9;
  }
  if ( !CSsl3TlsContext::CheckRecordValidity(v11, a5) )
  {
    if ( WPP_GLOBAL_Control != v16 && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 35i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
    LogDtlsRecordOutOfRecvWindow(v13, v14);
    goto LABEL_55;
  }
  while ( 1 )
  {
    v10 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != v16 && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 36i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
      v10 = WPP_GLOBAL_Control;
      v16 = (CCipherMill *)&WPP_GLOBAL_Control;
    }
    if ( v5 < 0xC )
    {
      if ( v10 == v16 || (*((_BYTE *)v10 + 28) & 1) == 0 )
        goto LABEL_50;
      v25 = 37i64;
LABEL_48:
      WPP_SF_(*((_QWORD *)v10 + 2), v25, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
      goto LABEL_49;
    }
    v17 = v6[3] + ((v6[2] + (v6[1] << 8)) << 8);
    v29 = v6[8] + ((v6[7] + (v6[6] << 8)) << 8);
    v18 = v6[11] + ((v6[10] + (v6[9] << 8)) << 8);
    if ( (unsigned __int64)v18 + 12 > v5 )
    {
      if ( v10 == v16 || (*((_BYTE *)v10 + 28) & 1) == 0 )
        goto LABEL_50;
      v25 = 38i64;
      goto LABEL_48;
    }
    v19 = v6[5] + (v6[4] << 8);
    Msg = DTlsMsgMgr::FindMsg(*(DTlsMsgMgr **)a1, v19);
    if ( Msg )
      goto LABEL_33;
    if ( v20 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v20 + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)v20 + 2), 39i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
      v21 = *(DTlsMsgMgr **)a1;
    }
    Msg = DTlsMsgMgr::AddMsg(v21, 22i64, v19, v17);
    if ( Msg )
      break;
LABEL_37:
    v6 += v18 + 12;
    v5 += -12 - v18;
    if ( !v5 )
      goto LABEL_55;
    v16 = (CCipherMill *)&WPP_GLOBAL_Control;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 40i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
  v23 = *((_QWORD *)Msg + 5);
  *(_BYTE *)v23 = *v6;
  *(_BYTE *)(v23 + 5) = v19;
  *(_WORD *)(v23 + 7) = 0;
  *(_BYTE *)(v23 + 1) = BYTE2(v17);
  *(_BYTE *)(v23 + 9) = BYTE2(v17);
  *(_BYTE *)(v23 + 4) = BYTE1(v19);
  *(_BYTE *)(v23 + 3) = v17;
  *(_BYTE *)(v23 + 2) = BYTE1(v17);
  *(_BYTE *)(v23 + 11) = v17;
  *(_BYTE *)(v23 + 10) = BYTE1(v17);
  *(_BYTE *)(v23 + 6) = 0;
  v20 = WPP_GLOBAL_Control;
LABEL_33:
  if ( v20 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v20 + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)v20 + 2), 41i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
  v24 = DTlsMessage::addFragment(Msg, v28, v27, v6 + 12, v29, v18);
  v9 = v24;
  if ( !v24 )
    goto LABEL_37;
  v10 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 42i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids, v24);
LABEL_49:
    v10 = WPP_GLOBAL_Control;
  }
LABEL_50:
  v9 = -2146893018;
LABEL_56:
  if ( v10 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v10 + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)v10 + 2), 43i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids, v9);
  return v9;
}
// 180072BD5: variable 'v16' is possibly undefined
// 180072CDC: variable 'v20' is possibly undefined
// 180072D0A: variable 'v21' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180072EF8) ----------------------------------------------------
struct DTlsMessage *__fastcall DTlsMsgMgr::FindMsg(DTlsMsgMgr *this, int a2)
{
  __int64 v2; // r8
  __int64 **v3; // rcx
  __int64 *i; // rax

  v2 = 0i64;
  v3 = (__int64 **)((char *)this + 24);
  for ( i = *v3; i != (__int64 *)v3 && i; i = (__int64 *)*i )
  {
    if ( *((_DWORD *)i + 6) == a2 )
      return (struct DTlsMessage *)i;
  }
  return (struct DTlsMessage *)v2;
}

//----- (0000000180072F28) ----------------------------------------------------
struct DTlsMessage *__fastcall DTlsHandshakeQueue::GetNextReadyHandshakeMsg(DTlsMsgMgr **this, __int64 a2, __int64 a3)
{
  struct DTlsMessage *NextReadyMsg; // rdi
  CCipherMill *v5; // rcx
  __int64 v6; // rdx

  NextReadyMsg = DTlsMsgMgr::GetNextReadyMsg(*this, a2, a3);
  if ( NextReadyMsg )
  {
    *((_DWORD *)this + 8) = 1;
    return NextReadyMsg;
  }
  if ( *((_DWORD *)this + 8) == 1 || *((_DWORD *)this + 8) == 4 )
  {
    if ( *((_DWORD *)this + 2) )
    {
      if ( (*(unsigned __int8 (__fastcall **)(DTlsMsgMgr *))(*(_QWORD *)this[5] + 520i64))(this[5]) )
      {
        NextReadyMsg = this[2];
        this[2] = 0i64;
        *((_DWORD *)this + 2) = 0;
        *((_DWORD *)this + 8) = 2;
        v5 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          v6 = 44i64;
          goto LABEL_14;
        }
      }
    }
  }
  else if ( *((_DWORD *)this + 8) == 2 )
  {
    if ( *((_DWORD *)this + 3) )
    {
      NextReadyMsg = this[3];
      this[3] = 0i64;
      *((_DWORD *)this + 3) = 0;
      *((_DWORD *)this + 8) = 3;
      v5 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        v6 = 45i64;
LABEL_14:
        WPP_SF_(*((_QWORD *)v5 + 2), v6, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
      }
    }
  }
  return NextReadyMsg;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180073028) ----------------------------------------------------
struct DTlsMessage *__fastcall DTlsMsgMgr::GetNextReadyMsg(DTlsMsgMgr *this, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rsi
  __int64 v5; // rbp
  __int64 v6; // rdi
  CCipherMill *v7; // r10
  __int64 v8; // rdx
  int v9; // r9d
  struct DTlsMessage *Msg; // rax

  v3 = (_QWORD *)((char *)this + 24);
  v5 = *((_QWORD *)this + 3);
  v6 = 0i64;
  v7 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 16i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
    v7 = WPP_GLOBAL_Control;
  }
  if ( (_QWORD *)*v3 != v3 )
  {
    v9 = *(_DWORD *)(v5 + 24);
    if ( v9 != *(_DWORD *)this )
    {
      if ( v7 == (CCipherMill *)&WPP_GLOBAL_Control )
        return (struct DTlsMessage *)v6;
      if ( (*((_BYTE *)v7 + 28) & 4) == 0 )
        goto LABEL_23;
      WPP_SF_dd(
        *((_QWORD *)v7 + 2),
        0x12u,
        (__int64)&WPP_7c40084571853895c7781ddf48bb701c_Traceguids,
        v9,
        *(_DWORD *)this);
      goto LABEL_22;
    }
    if ( *(_DWORD *)(v5 + 28) )
    {
      Msg = DTlsMsgMgr::FindMsg(this, *(_DWORD *)this);
      if ( Msg )
      {
        **((_QWORD **)Msg + 1) = *(_QWORD *)Msg;
        *(_QWORD *)(*(_QWORD *)Msg + 8i64) = *((_QWORD *)Msg + 1);
        --*((_DWORD *)this + 1);
        ++*(_DWORD *)this;
        v6 = v5;
LABEL_22:
        v7 = WPP_GLOBAL_Control;
        goto LABEL_23;
      }
      if ( v7 == (CCipherMill *)&WPP_GLOBAL_Control )
        return (struct DTlsMessage *)v6;
      if ( (*((_BYTE *)v7 + 28) & 1) == 0 )
        goto LABEL_23;
      v8 = 20i64;
    }
    else
    {
      if ( v7 == (CCipherMill *)&WPP_GLOBAL_Control )
        return (struct DTlsMessage *)v6;
      if ( (*((_BYTE *)v7 + 28) & 4) == 0 )
        goto LABEL_23;
      v8 = 19i64;
    }
LABEL_21:
    WPP_SF_(*((_QWORD *)v7 + 2), v8, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
    goto LABEL_22;
  }
  if ( v7 == (CCipherMill *)&WPP_GLOBAL_Control )
    return (struct DTlsMessage *)v6;
  if ( (*((_BYTE *)v7 + 28) & 4) != 0 )
  {
    v8 = 17i64;
    goto LABEL_21;
  }
LABEL_23:
  if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v7 + 28) & 4) != 0 )
    WPP_SF_P(*((_QWORD *)v7 + 2), 0x15u, a3, v6);
  return (struct DTlsMessage *)v6;
}
// 18007312C: variable 'v7' is possibly undefined
// 180073165: variable 'a3' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180073190) ----------------------------------------------------
__int64 __fastcall DTlsHandshakeQueue::SetCcs(
        DTlsHandshakeQueue *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int64 a4)
{
  size_t v5; // r15
  unsigned int v8; // edi
  CCipherMill *v9; // rcx
  __int64 v10; // rdx
  CCipherMill *v12; // r10
  DTlsMessage *v13; // rax
  DTlsMessage *v14; // rbx
  unsigned int inited; // r14d
  _BYTE *v16; // rdx
  __int16 v17; // ax
  unsigned __int64 v18; // rsi

  v5 = a3;
  v8 = 590610;
  v9 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_i(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x16u, (__int64)&WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
    v9 = WPP_GLOBAL_Control;
  }
  if ( *((_DWORD *)this + 2) )
  {
    if ( v9 == (CCipherMill *)&WPP_GLOBAL_Control )
      return v8;
    if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
    {
      v10 = 23i64;
LABEL_8:
      WPP_SF_(*((_QWORD *)v9 + 2), v10, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
LABEL_9:
      v9 = WPP_GLOBAL_Control;
    }
  }
  else
  {
    if ( CSsl3TlsContext::CheckRecordValidity(*((CSsl3TlsContext **)this + 5), a4) )
    {
      v13 = (DTlsMessage *)SPExternalAlloc(0x48u);
      v14 = v13;
      if ( !v13 )
      {
        v9 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 25i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
          v9 = WPP_GLOBAL_Control;
        }
        v8 = 14;
        goto LABEL_10;
      }
      *((_DWORD *)v13 + 4) = 0;
      *((_DWORD *)v13 + 7) = 0;
      *((_DWORD *)v13 + 8) = 0;
      *((_QWORD *)v13 + 5) = 0i64;
      *((_QWORD *)v13 + 6) = 0i64;
      *((_QWORD *)v13 + 7) = 0i64;
      *((_DWORD *)v13 + 17) = 0;
      inited = DTlsMessage::initMsg(v13, 0, 20, v5, 0xDu);
      if ( inited )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 26i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
        v8 = inited;
        DTlsMessage::`scalar deleting destructor'(v14);
        v9 = WPP_GLOBAL_Control;
        goto LABEL_10;
      }
      v16 = (_BYTE *)*((_QWORD *)v14 + 5);
      *v16 = 20;
      v17 = *(_WORD *)(*((_QWORD *)this + 5) + 34i64);
      v16[2] = v17;
      v16[1] = HIBYTE(v17);
      v16[4] = BYTE6(a4);
      v16[3] = HIBYTE(a4);
      v18 = a4 & 0xFFFFFFFFFFFFi64;
      v16[12] = v5;
      v16[10] = v18;
      v18 >>= 8;
      v16[9] = v18;
      v18 >>= 8;
      v16[8] = v18;
      v18 >>= 8;
      v16[7] = v18;
      v18 >>= 8;
      v16[6] = v18;
      v16[5] = BYTE1(v18);
      v16[11] = BYTE1(v5);
      memcpy_0(v16 + 13, a2, v5);
      *((_QWORD *)this + 2) = v14;
      *((_DWORD *)this + 2) = 1;
      goto LABEL_9;
    }
    v9 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != v12 && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      v10 = 24i64;
      goto LABEL_8;
    }
  }
LABEL_10:
  if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)v9 + 2), 27i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids, v8);
  return v8;
}
// 18007328D: variable 'v12' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180073410) ----------------------------------------------------
__int64 __fastcall DTlsHandshakeQueue::SetFinish(
        DTlsHandshakeQueue *this,
        unsigned __int8 *a2,
        unsigned int a3,
        __int64 a4)
{
  size_t v5; // r15
  unsigned int v8; // edi
  CCipherMill *v9; // rcx
  DTlsMessage *v10; // rax
  DTlsMessage *v11; // rbx
  unsigned int inited; // ebp
  _BYTE *v13; // rdx
  __int16 v14; // ax
  unsigned __int64 v15; // rsi

  v5 = a3;
  v8 = 590610;
  v9 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_i(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x1Cu, (__int64)&WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
    v9 = WPP_GLOBAL_Control;
  }
  if ( *((_DWORD *)this + 3) )
  {
    if ( v9 == (CCipherMill *)&WPP_GLOBAL_Control )
      return v8;
    if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)v9 + 2), 29i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
      v9 = WPP_GLOBAL_Control;
    }
  }
  else
  {
    v10 = (DTlsMessage *)SPExternalAlloc(0x48u);
    v11 = v10;
    if ( v10 )
    {
      *((_DWORD *)v10 + 4) = 0;
      *((_DWORD *)v10 + 7) = 0;
      *((_DWORD *)v10 + 8) = 0;
      *((_QWORD *)v10 + 5) = 0i64;
      *((_QWORD *)v10 + 6) = 0i64;
      *((_QWORD *)v10 + 7) = 0i64;
      *((_DWORD *)v10 + 17) = 0;
      inited = DTlsMessage::initMsg(v10, 0, 22, v5, 0xDu);
      if ( inited )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 31i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
        v8 = inited;
        DTlsMessage::`scalar deleting destructor'(v11);
      }
      else
      {
        v13 = (_BYTE *)*((_QWORD *)v11 + 5);
        *v13 = 22;
        v14 = *(_WORD *)(*((_QWORD *)this + 5) + 34i64);
        v13[2] = v14;
        v13[1] = HIBYTE(v14);
        v13[4] = BYTE6(a4);
        v13[3] = HIBYTE(a4);
        v15 = a4 & 0xFFFFFFFFFFFFi64;
        v13[12] = v5;
        v13[10] = v15;
        v15 >>= 8;
        v13[9] = v15;
        v15 >>= 8;
        v13[8] = v15;
        v15 >>= 8;
        v13[7] = v15;
        v15 >>= 8;
        v13[6] = v15;
        v13[5] = BYTE1(v15);
        v13[11] = BYTE1(v5);
        memcpy_0(v13 + 13, a2, v5);
        *((_DWORD *)v11 + 17) = 1;
        *((_QWORD *)this + 3) = v11;
        *((_DWORD *)this + 3) = 1;
      }
      v9 = WPP_GLOBAL_Control;
    }
    else
    {
      v9 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 30i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids);
        v9 = WPP_GLOBAL_Control;
      }
      v8 = 14;
    }
  }
  if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)v9 + 2), 32i64, &WPP_7c40084571853895c7781ddf48bb701c_Traceguids, v8);
  return v8;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180073660) ----------------------------------------------------
__int64 __fastcall DTlsMessage::addFragment(
        DTlsMessage *this,
        unsigned int a2,
        const unsigned __int16 *a3,
        void *const a4,
        unsigned int a5,
        unsigned int Size)
{
  unsigned int v6; // ebx
  unsigned int v11; // esi
  __int64 v12; // r15
  char v13; // cl
  unsigned __int64 v14; // r9
  struct _UNICODE_STRING DestinationString; // [rsp+30h] [rbp-28h] BYREF

  v6 = 0;
  if ( a4 && (v11 = a5, a5 + Size <= *((_DWORD *)this + 4)) )
  {
    if ( Size && !*((_DWORD *)this + 7) )
    {
      if ( DTlsMessage::checkOverlapp(this, a5, a5 + Size - 1) )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_DD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0xAu,
            (__int64)&WPP_7c40084571853895c7781ddf48bb701c_Traceguids,
            a5,
            Size);
        if ( (g_dwEventLogging & 4) != 0 )
        {
          RtlInitUnicodeString(&DestinationString, a3);
          SchEventWrite(&SSLEVENT_DTLS_DUPLICATE_RECORD, L"du", a2, &DestinationString);
        }
      }
      else
      {
        v12 = Size;
        memcpy_0((void *)(*((_QWORD *)this + 6) + a5), a4, Size);
        do
        {
          v13 = v11 & 7;
          v14 = (unsigned __int64)v11++ >> 3;
          *(_BYTE *)(v14 + *((_QWORD *)this + 7)) |= 1 << (7 - v13);
          --v12;
        }
        while ( v12 );
        *((_DWORD *)this + 7) = DTlsMessage::checkComplete(this);
      }
    }
  }
  else
  {
    return 87;
  }
  return v6;
}
// 18007375B: conditional instruction was optimized away because ebp.4!=0

//----- (00000001800737BC) ----------------------------------------------------
__int64 __fastcall DTlsMessage::checkComplete(DTlsMessage *this)
{
  unsigned int v1; // r8d
  _DWORD *v2; // r11
  int v3; // eax
  unsigned int v4; // ecx
  unsigned int v5; // r10d
  unsigned int v6; // ecx
  unsigned int v7; // r9d

  v1 = 0;
  v2 = (_DWORD *)*((_QWORD *)this + 7);
  v3 = 0;
  v4 = *((_DWORD *)this + 4);
  v5 = v4 & 0x1F;
  v6 = v4 >> 5;
  if ( v6 )
  {
    while ( *v2 == -1 )
    {
      ++v2;
      if ( ++v3 >= v6 )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    v7 = 0;
    if ( v5 )
    {
      while ( ((*((_BYTE *)v2 + ((unsigned __int64)v7 >> 3)) >> (7 - (v7 & 7))) & 1) != 0 )
      {
        if ( ++v7 >= v5 )
          return 1;
      }
    }
    else
    {
      return 1;
    }
  }
  return v1;
}

//----- (0000000180073828) ----------------------------------------------------
_BOOL8 __fastcall DTlsMessage::checkOverlapp(DTlsMessage *this, unsigned int a2, unsigned int a3)
{
  BOOL v3; // r9d
  unsigned int i; // r10d

  v3 = 0;
  for ( i = a2; i <= a3; ++i )
  {
    if ( v3 )
      break;
    v3 = ((*(_BYTE *)(((unsigned __int64)i >> 3) + *((_QWORD *)this + 7)) >> (7 - (i & 7))) & 1) != 0;
  }
  return v3;
}

//----- (0000000180073880) ----------------------------------------------------
__int64 __fastcall DTlsMessage::initMsg(DTlsMessage *this, int a2, int a3, int a4, unsigned int a5)
{
  unsigned int v5; // ebx
  unsigned int v10; // ebp
  void *v11; // rax
  void *v12; // rax
  __int64 v13; // rax

  v5 = 0;
  v10 = a4 + a5;
  if ( !(a4 + a5) )
    return 87;
  v11 = operator new(v10);
  *((_QWORD *)this + 5) = v11;
  if ( !v11 )
    return 8;
  v12 = operator new((unsigned __int64)(unsigned int)(a4 + 7) >> 3);
  *((_QWORD *)this + 7) = v12;
  if ( !v12 )
  {
    operator delete(*((void **)this + 5));
    *((_QWORD *)this + 5) = 0i64;
    return 8;
  }
  *((_DWORD *)this + 5) = v10;
  *((_DWORD *)this + 4) = a4;
  *((_DWORD *)this + 7) = a4 == 0;
  memset_0(v12, 0, (unsigned __int64)(unsigned int)(a4 + 7) >> 3);
  if ( a4 )
    v13 = *((_QWORD *)this + 5) + a5;
  else
    v13 = 0i64;
  *((_QWORD *)this + 6) = v13;
  *((_DWORD *)this + 6) = a2;
  *((_DWORD *)this + 16) = a3;
  return v5;
}

//----- (000000018007395C) ----------------------------------------------------
__int64 __fastcall DTlsRec::initRec(DTlsRec *this, unsigned int a2, struct CSsl3TlsContext *a3)
{
  unsigned int v3; // ebx
  __int64 v6; // rax

  v3 = 0;
  if ( a3 )
  {
    *((_QWORD *)this + 2) = a3;
    v6 = (*(__int64 (__fastcall **)(struct CSsl3TlsContext *, _QWORD))(*(_QWORD *)a3 + 8i64))(a3, a2);
    *((_QWORD *)this + 3) = v6;
    if ( v6 )
    {
      *((_QWORD *)this + 1) = v6;
      *(_DWORD *)this = a2;
      *((_DWORD *)this + 1) = 0;
      *((_DWORD *)this + 8) = 0;
    }
    else
    {
      return 8;
    }
  }
  else
  {
    return 87;
  }
  return v3;
}

//----- (00000001800739D4) ----------------------------------------------------
__int64 __fastcall DTlsMsgMgr::insertMsg(DTlsMsgMgr *this, struct DTlsMessage *a2)
{
  char *v2; // r9
  unsigned int v3; // r8d
  char *i; // rcx
  char **v5; // rax

  v2 = (char *)this + 24;
  v3 = 0;
  for ( i = (char *)*((_QWORD *)this + 3); i != v2; i = *(char **)i )
  {
    if ( !i )
      return 1359;
    if ( *((_DWORD *)i + 6) > *((_DWORD *)a2 + 6) )
    {
      **((_QWORD **)i + 1) = a2;
      *(_QWORD *)a2 = i;
      *((_QWORD *)a2 + 1) = *((_QWORD *)i + 1);
      *((_QWORD *)i + 1) = a2;
      return v3;
    }
  }
  v5 = (char **)*((_QWORD *)v2 + 1);
  if ( *v5 != v2 )
    __fastfail(3u);
  *(_QWORD *)a2 = v2;
  *((_QWORD *)a2 + 1) = v5;
  *v5 = (char *)a2;
  *((_QWORD *)v2 + 1) = a2;
  return v3;
}

//----- (0000000180073A40) ----------------------------------------------------
__int64 __fastcall DTlsMsgMgr::swapSaveAndOutgoing(DTlsMsgMgr *this)
{
  _QWORD *v1; // rdx
  _QWORD *v2; // rax
  _QWORD *v3; // rax
  __int64 result; // rax

  v1 = (_QWORD *)((char *)this + 56);
  if ( (_QWORD *)*v1 != v1 )
    return 2148074244i64;
  v2 = (_QWORD *)*((_QWORD *)this + 9);
  if ( v2 == (_QWORD *)((char *)this + 72) )
    return 2148074244i64;
  *v1 = v2;
  v2[1] = v1;
  v3 = (_QWORD *)*((_QWORD *)this + 10);
  *((_QWORD *)this + 8) = v3;
  *v3 = v1;
  result = 0i64;
  *((_QWORD *)this + 10) = (char *)this + 72;
  *((_QWORD *)this + 9) = (char *)this + 72;
  return result;
}

//----- (0000000180073A80) ----------------------------------------------------
__int64 WPP_SF_DDDD(__int64 a1, __int64 a2, __int64 a3, int a4, ...)
{
  int v5; // [rsp+A8h] [rbp+20h] BYREF
  __int64 v6; // [rsp+B0h] [rbp+28h] BYREF
  va_list va; // [rsp+B0h] [rbp+28h]
  va_list va1; // [rsp+B8h] [rbp+30h] BYREF

  va_start(va1, a4);
  va_start(va, a4);
  v6 = va_arg(va1, _QWORD);
  v5 = a4;
  return EtwTraceMessage(
           a1,
           43i64,
           &WPP_7c40084571853895c7781ddf48bb701c_Traceguids,
           11i64,
           &v5,
           4i64,
           (__int64 *)va,
           4i64,
           va1);
}

//----- (0000000180073B00) ----------------------------------------------------
__int64 WPP_SF_DDi(__int64 a1, __int64 a2, __int64 a3, int a4, ...)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF
  __int64 v6; // [rsp+90h] [rbp+28h] BYREF
  va_list va; // [rsp+90h] [rbp+28h]
  va_list va1; // [rsp+98h] [rbp+30h] BYREF

  va_start(va1, a4);
  va_start(va, a4);
  v6 = va_arg(va1, _QWORD);
  v5 = a4;
  return EtwTraceMessage(
           a1,
           43i64,
           &WPP_7c40084571853895c7781ddf48bb701c_Traceguids,
           33i64,
           &v5,
           4i64,
           (__int64 *)va,
           4i64,
           va1);
}

//----- (0000000180073B6C) ----------------------------------------------------
__int64 WPP_SF_P(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  __int64 v4; // [rsp+38h] [rbp-10h]
  __int64 v5; // [rsp+40h] [rbp-8h]
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  return EtwTraceMessage(
           a1,
           43i64,
           &WPP_7c40084571853895c7781ddf48bb701c_Traceguids,
           a2,
           (__int64 *)va,
           8i64,
           0i64,
           v4,
           v5);
}
// 180073B9C: variable 'v4' is possibly undefined
// 180073B9C: variable 'v5' is possibly undefined

//----- (0000000180073BB4) ----------------------------------------------------
__int64 __fastcall CreateChainEngine(struct CCredentialGroup *a1)
{
  DWORD LastError; // eax
  struct _CERT_CHAIN_ENGINE_CONFIG pConfig; // [rsp+20h] [rbp-68h] BYREF
  int v5; // [rsp+70h] [rbp-18h]
  HCERTCHAINENGINE phChainEngine; // [rsp+98h] [rbp+10h] BYREF

  memset_0(&pConfig, 0, 0x58ui64);
  phChainEngine = 0i64;
  pConfig.cbSize = 88;
  pConfig.dwFlags = 56;
  if ( !g_eClientAuthMode )
    return 1i64;
  if ( g_eClientAuthMode != 1 )
  {
    if ( g_eClientAuthMode != 2 )
      goto LABEL_6;
    v5 |= 1u;
  }
  pConfig.hExclusiveRoot = (HCERTSTORE)*((_QWORD *)a1 + 102);
LABEL_6:
  if ( !CertCreateCertificateChainEngine(&pConfig, &phChainEngine) )
  {
    LastError = GetLastError();
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_ee3ada077a243a8835f858b78da5bb63_Traceguids, LastError);
    return 1i64;
  }
  return (__int64)phChainEngine;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180073C88) ----------------------------------------------------
__int64 __fastcall DoCertificateMapping(struct CSsl3TlsServerContext *a1)
{
  __int64 v1; // rax
  __int64 v3; // r12
  __int64 v4; // rsi
  CCipherMill *v5; // rcx
  CERT_CONTEXT *v6; // r14
  int v7; // r8d
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // r15d
  __int64 v14; // r8
  int v15; // eax
  int v16; // edi
  __int64 v18; // [rsp+20h] [rbp-30h]
  const struct _CERT_CONTEXT *v19; // [rsp+30h] [rbp-20h]
  unsigned __int64 v20; // [rsp+80h] [rbp+30h] BYREF
  __int64 v21; // [rsp+88h] [rbp+38h] BYREF
  PCCERT_CONTEXT pCertContext; // [rsp+90h] [rbp+40h] BYREF

  v1 = *((_QWORD *)a1 + 10);
  pCertContext = 0i64;
  LODWORD(v20) = -2146893019;
  v3 = *(_QWORD *)(v1 + 752);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 17i64, &WPP_ee3ada077a243a8835f858b78da5bb63_Traceguids);
  (*(void (__fastcall **)(struct CSsl3TlsServerContext *, __int64 *))(*(_QWORD *)a1 + 232i64))(a1, &v21);
  v4 = *((_QWORD *)a1 + 10);
  if ( (*((_DWORD *)a1 + 34) & 0x10000i64) == 0 || v4 && *(_QWORD *)(v4 + 848) )
  {
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(v21 + 72), 1u);
    if ( !SPLoadCertificate(*(unsigned __int8 **)(v21 + 24), *(_DWORD *)(v21 + 32), &pCertContext) )
    {
      v6 = (CERT_CONTEXT *)pCertContext;
      if ( v4 && *(_QWORD *)(v4 + 848) )
      {
        RunClientCertPolicy((struct CCredentialGroup *)v4, pCertContext, &v20);
        *(_QWORD *)(v21 + 216) = (unsigned int)v20;
      }
      if ( (*((_DWORD *)a1 + 34) & 0x10000) != 0 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 19i64, &WPP_ee3ada077a243a8835f858b78da5bb63_Traceguids);
      }
      else
      {
        v7 = *(_DWORD *)(v4 + 160);
        v8 = ((v7 & 0x100) << 16) | 0x2000000;
        if ( (v7 & 0x200) == 0 )
          v8 = (*(_DWORD *)(v4 + 160) & 0x100) << 16;
        v9 = v8 | 0x4000000;
        if ( (v7 & 0x400) == 0 )
          v9 = v8;
        v10 = v9 | 0x8000000;
        if ( (v7 & 0x800) == 0 )
          v10 = v9;
        v11 = v10 | 0x10000000;
        if ( (v7 & 0x1000) == 0 )
          v11 = v10;
        v12 = v11 | 0x200000;
        if ( (v7 & 0x2000) == 0 )
          v12 = v11;
        v13 = v12 | 0x400000;
        v14 = v7 & 0x4000;
        if ( !(_DWORD)v14 )
          v13 = v12;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_ee3ada077a243a8835f858b78da5bb63_Traceguids);
        v15 = SslMapCredential(
                (struct CCredentialGroup *)v4,
                *((void **)a1 + 116),
                v14,
                v3,
                v13,
                v6,
                v19,
                *((unsigned __int16 **)a1 + 116),
                *((unsigned __int16 **)a1 + 117),
                &v20);
        v16 = v15;
        if ( v15 < 0 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_D(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              22i64,
              &WPP_ee3ada077a243a8835f858b78da5bb63_Traceguids,
              (unsigned int)v15);
          }
          *(_DWORD *)(v21 + 352) = v16;
        }
        else
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_q(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x15u,
              (__int64)&WPP_ee3ada077a243a8835f858b78da5bb63_Traceguids,
              *(_QWORD *)(v21 + 344));
          }
          *(_QWORD *)(v21 + 344) = v20;
          *(_DWORD *)(v21 + 352) = 0;
        }
      }
      CertFreeCertificateContext(v6);
    }
    RtlReleaseResource((PRTL_RESOURCE)(v21 + 72));
    goto LABEL_44;
  }
  v5 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control )
    return 0i64;
  if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, &WPP_ee3ada077a243a8835f858b78da5bb63_Traceguids);
LABEL_44:
    v5 = WPP_GLOBAL_Control;
  }
  if ( v5 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v5 + 28) & 4) != 0 )
  {
    LODWORD(v18) = 0;
    WPP_SF_DD(*((_QWORD *)v5 + 2), 0x17u, (__int64)&WPP_ee3ada077a243a8835f858b78da5bb63_Traceguids, 0, v18);
  }
  return 0i64;
}
// 180073EDC: variable 'v14' is possibly undefined
// 180073EDC: variable 'v19' is possibly undefined
// 180073FC4: variable 'v18' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180073FE8) ----------------------------------------------------
void __fastcall RunClientCertPolicy(struct CCredentialGroup *a1, PCCERT_CONTEXT pCertContext, _DWORD *a3)
{
  _DWORD *v3; // rdi
  bool v7; // zf
  DWORD v8; // ebx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  void *ChainEngine; // r15
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  DWORD LastError; // eax
  char v17; // al
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 dwError; // rdx
  const char *v22; // r9
  __int64 dwFlags; // [rsp+28h] [rbp-120h]
  PCCERT_CHAIN_CONTEXT pChainContext; // [rsp+40h] [rbp-108h] BYREF
  struct _CERT_CHAIN_POLICY_STATUS pPolicyStatus; // [rsp+48h] [rbp-100h] BYREF
  const char *v26; // [rsp+60h] [rbp-E8h] BYREF
  struct _CERT_CHAIN_POLICY_PARA pPolicyPara; // [rsp+68h] [rbp-E0h] BYREF
  int v28[2]; // [rsp+78h] [rbp-D0h] BYREF
  __int64 v29; // [rsp+80h] [rbp-C8h]
  __int64 v30; // [rsp+88h] [rbp-C0h]
  struct _CERT_CHAIN_PARA pChainPara; // [rsp+90h] [rbp-B8h] BYREF
  int v32; // [rsp+C8h] [rbp-80h]
  int v33; // [rsp+CCh] [rbp-7Ch]
  int v34; // [rsp+D0h] [rbp-78h]
  struct _EVENT_DATA_DESCRIPTOR v35; // [rsp+F0h] [rbp-58h] BYREF

  v3 = (_DWORD *)*((_QWORD *)a1 + 106);
  v26 = "1.3.6.1.5.5.7.3.2";
  pChainContext = 0i64;
  if ( !v3 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_ee3ada077a243a8835f858b78da5bb63_Traceguids);
    return;
  }
  memset_0(&pChainPara, 0, 0x60ui64);
  pChainPara.cbSize = 96;
  v32 = v3[5];
  v33 = v3[6];
  v34 = v3[7];
  v7 = v3[8] == 1;
  pChainPara.RequestedUsage.dwType = 0;
  if ( v7 )
  {
    pChainPara.RequestedUsage.Usage.cUsageIdentifier = 0;
    pChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = 0i64;
  }
  else
  {
    pChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
    pChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = (LPSTR *)&v26;
  }
  v8 = v3[4];
  ChainEngine = (void *)CreateChainEngine(a1);
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EventWriteTransfer(v9, &ChainBuildStart, v10, v11, &v35);
  if ( CertGetCertificateChain(
         ChainEngine,
         pCertContext,
         0i64,
         pCertContext->hCertStore,
         &pChainPara,
         v8,
         0i64,
         &pChainContext) )
  {
    v17 = Microsoft_Windows_Schannel_EventsEnableBits;
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    {
      McGenEventWrite_EventWriteTransfer(v13, &ChainBuildStop, v14, v15, &v35);
      v17 = Microsoft_Windows_Schannel_EventsEnableBits;
    }
    v29 = 0i64;
    pPolicyPara.pvExtraPolicyPara = v28;
    v28[0] = 24;
    v28[1] = 1;
    v30 = 0i64;
    *(_QWORD *)&pPolicyPara.cbSize = 16i64;
    memset(&pPolicyStatus, 0, sizeof(pPolicyStatus));
    pPolicyStatus.cbSize = 24;
    if ( (v17 & 1) != 0 )
      McGenEventWrite_EventWriteTransfer(0i64, &ChainVerifyStart, v14, v15, &v35);
    if ( !CertVerifyCertificateChainPolicy((LPCSTR)4, pChainContext, &pPolicyPara, &pPolicyStatus) )
    {
      if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
        McGenEventWrite_EventWriteTransfer(v18, &ChainVerifyStop, v19, v20, &v35);
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          13i64,
          &WPP_ee3ada077a243a8835f858b78da5bb63_Traceguids,
          pPolicyStatus.dwError);
      goto LABEL_46;
    }
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McGenEventWrite_EventWriteTransfer(v18, &ChainVerifyStop, v19, v20, &v35);
    dwError = pPolicyStatus.dwError;
    if ( pPolicyStatus.dwError == -2146885614 )
      dwError = 0i64;
    pPolicyStatus.dwError = dwError;
    if ( (_DWORD)dwError )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        LODWORD(dwFlags) = v3[8];
        WPP_SF_Dqd(*((_QWORD *)WPP_GLOBAL_Control + 2), dwError, v19, dwError, a1, dwFlags);
        LODWORD(dwError) = pPolicyStatus.dwError;
      }
      *a3 = dwError;
      goto LABEL_46;
    }
    if ( !pChainContext->cChain )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_ee3ada077a243a8835f858b78da5bb63_Traceguids);
      goto LABEL_46;
    }
    if ( g_eClientAuthMode >= 0 )
    {
      if ( g_eClientAuthMode <= 1 )
      {
        if ( !CCredentialGroup::CheckForValidIssuer(a1, pChainContext) )
          goto LABEL_46;
      }
      else if ( g_eClientAuthMode != 2 )
      {
        goto LABEL_46;
      }
      *a3 = 0;
    }
LABEL_46:
    if ( pChainContext )
      CertFreeCertificateChain(pChainContext);
    goto LABEL_48;
  }
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EventWriteTransfer(v13, &ChainBuildStop, v14, v15, &v35);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    LastError = GetLastError();
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_ee3ada077a243a8835f858b78da5bb63_Traceguids, LastError);
  }
  pChainContext = 0i64;
LABEL_48:
  if ( ChainEngine != (void *)1 )
    CertFreeCertificateChainEngine(ChainEngine);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    v22 = "FOUND";
    if ( *a3 )
      v22 = "DID NOT FIND";
    WPP_SF_s(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x10u, (__int64)&WPP_ee3ada077a243a8835f858b78da5bb63_Traceguids, v22);
  }
}
// 18007410E: variable 'v9' is possibly undefined
// 18007410E: variable 'v10' is possibly undefined
// 18007410E: variable 'v11' is possibly undefined
// 180074173: variable 'v13' is possibly undefined
// 180074173: variable 'v14' is possibly undefined
// 180074173: variable 'v15' is possibly undefined
// 180074297: variable 'v18' is possibly undefined
// 180074297: variable 'v19' is possibly undefined
// 180074297: variable 'v20' is possibly undefined
// 180074332: variable 'dwFlags' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180084C60: using guessed type EVENT_DESCRIPTOR ChainVerifyStop;
// 180084C70: using guessed type EVENT_DESCRIPTOR ChainVerifyStart;
// 180084C80: using guessed type EVENT_DESCRIPTOR ChainBuildStop;
// 180084C90: using guessed type EVENT_DESCRIPTOR ChainBuildStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;

//----- (0000000180074430) ----------------------------------------------------
__int64 __fastcall SslMapCredential(
        struct CCredentialGroup *a1,
        void *a2,
        __int64 a3,
        __int64 a4,
        unsigned int a5,
        struct _CERT_CONTEXT *a6,
        const struct _CERT_CONTEXT *a7,
        unsigned __int16 *a8,
        unsigned __int16 *a9,
        unsigned __int64 *a10)
{
  int v10; // eax
  void *v12; // [rsp+30h] [rbp-28h]

  if ( fUseLocalMapping )
    v10 = SslLocalMapCredential(a1, 0i64, 1, a4, a5, a6, 0i64, a8, a9, a10);
  else
    v10 = SslRemoteMapCredential(a1, a2, 1, a4, a5, a6, v12, a8, a9, a10);
  return I_MapWinTrustErrorAndAlert(v10, -2146893045, 0, 0i64);
}
// 18007449F: variable 'v12' is possibly undefined
// 1800919A0: using guessed type int fUseLocalMapping;

//----- (00000001800744C0) ----------------------------------------------------
__int64 WPP_SF_Dqd(__int64 a1, __int64 a2, __int64 a3, int a4, ...)
{
  int v5; // [rsp+88h] [rbp+20h] BYREF
  __int64 v6; // [rsp+90h] [rbp+28h] BYREF
  va_list va; // [rsp+90h] [rbp+28h]
  va_list va1; // [rsp+98h] [rbp+30h] BYREF

  va_start(va1, a4);
  va_start(va, a4);
  v6 = va_arg(va1, _QWORD);
  v5 = a4;
  return EtwTraceMessage(
           a1,
           43i64,
           &WPP_ee3ada077a243a8835f858b78da5bb63_Traceguids,
           14i64,
           &v5,
           4i64,
           (__int64 *)va,
           8i64,
           va1);
}

//----- (000000018007452C) ----------------------------------------------------
__int64 __fastcall DhDssPublicKeyFromCert(const struct _CERT_CONTEXT *a1, unsigned __int64 *a2)
{
  __int64 result; // rax
  PBYTE v4; // rbx
  unsigned int v5; // edi
  DWORD cbData; // [rsp+60h] [rbp+18h] BYREF
  PBYTE pbData; // [rsp+68h] [rbp+20h] BYREF

  pbData = 0i64;
  result = DssGetCertPublicKeyBlob(a1, (HLOCAL *)&pbData, &cbData);
  if ( !(_DWORD)result )
  {
    v4 = pbData;
    v5 = NCryptImportKey(hProvider, 0i64, L"CAPIDSAPUBLICBLOB", 0i64, a2, pbData, cbData, 8u);
    if ( v4 )
      SPExternalFree(v4);
    return v5;
  }
  return result;
}

//----- (00000001800745B4) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::DhGenerateClientExchangeValue(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        int a3,
        unsigned __int8 *a4,
        unsigned int *a5)
{
  char *v7; // rsi
  __int64 v8; // rax
  enum _eTlsHashAlgorithm v9; // r10d
  bool v10; // zf
  int v11; // r14d
  unsigned __int8 *v12; // r15
  int v13; // r12d
  unsigned int v14; // edx
  unsigned __int8 *v15; // r8
  unsigned __int8 *v16; // r9
  unsigned int v17; // r8d
  unsigned __int8 *v18; // r13
  unsigned int v20; // r8d
  int v21; // edx
  __int16 v22; // dx
  __int16 v23; // ax
  unsigned int *v24; // r9
  unsigned __int8 v25; // r9
  unsigned int cbEncoded; // edx
  int v27; // r14d
  unsigned int EphemKey; // edi
  __int64 v29; // rax
  unsigned int v30; // edx
  __int64 v31; // rcx
  unsigned __int8 v32; // r9
  __int64 v33; // r14
  __int64 v34; // rcx
  unsigned int v35; // edi
  unsigned int v36; // edx
  __int64 *v37; // rax
  __int64 v38; // rcx
  int EphemBlobFromKey; // eax
  unsigned int *v40; // r15
  int v41; // edx
  unsigned int v42; // edx
  unsigned __int64 v43; // rcx
  unsigned __int64 v44; // rax
  void *v45; // rsp
  size_t v46; // r13
  unsigned int v47; // ecx
  char *v48; // rax
  __int64 v49; // rdi
  unsigned int v50; // r12d
  _QWORD *v51; // rcx
  size_t v52; // rdx
  unsigned int v53; // eax
  unsigned __int8 *v54; // rcx
  unsigned int EccDhPskSessionKeysHelper; // eax
  __int64 v56; // [rsp+0h] [rbp-50h] BYREF
  unsigned int v57; // [rsp+50h] [rbp+0h] BYREF
  __int16 v58; // [rsp+54h] [rbp+4h]
  enum _eTlsSignatureAlgorithm v59; // [rsp+58h] [rbp+8h] BYREF
  enum _eTlsHashAlgorithm v60; // [rsp+5Ch] [rbp+Ch] BYREF
  unsigned int v61; // [rsp+60h] [rbp+10h]
  ULONG v62; // [rsp+64h] [rbp+14h] BYREF
  unsigned int v63; // [rsp+68h] [rbp+18h] BYREF
  unsigned __int64 v64; // [rsp+70h] [rbp+20h] BYREF
  unsigned __int64 v65; // [rsp+78h] [rbp+28h] BYREF
  unsigned int v66; // [rsp+80h] [rbp+30h]
  _DWORD Size[3]; // [rsp+84h] [rbp+34h] BYREF
  void *Src; // [rsp+90h] [rbp+40h] BYREF
  unsigned __int8 *v69; // [rsp+98h] [rbp+48h]
  unsigned __int8 *v70; // [rsp+A0h] [rbp+50h]
  unsigned __int8 *v71; // [rsp+A8h] [rbp+58h]
  void *v72; // [rsp+B0h] [rbp+60h]

  v69 = a4;
  v64 = 0i64;
  v63 = 0;
  v7 = 0i64;
  v8 = *((_QWORD *)this + 1);
  v9 = TlsHashAlgorithm_None;
  v65 = 0i64;
  Src = 0i64;
  *(_QWORD *)&Size[1] = 0i64;
  v10 = *(_DWORD *)(v8 + 52) == 2;
  v60 = TlsHashAlgorithm_None;
  v62 = 0;
  if ( v10 )
  {
    v11 = 1;
  }
  else
  {
    if ( *(_DWORD *)(v8 + 52) != 3 )
      return 2148074248i64;
    v11 = 2;
  }
  if ( a2 )
  {
    v12 = &a2[a3];
    v71 = a2 + 2;
    if ( a2 + 2 > v12 )
      goto LABEL_91;
    v13 = a2[1] | (*a2 << 8);
    v14 = v13 + 2;
    v15 = &a2[v13 + 2];
    v70 = v15 + 2;
    if ( v15 + 2 > v12 )
      goto LABEL_91;
    v66 = v15[1] | (*v15 << 8);
    v16 = &v15[v66 + 2];
    if ( v16 + 2 > v12 )
      goto LABEL_91;
    v17 = v16[1] | (*v16 << 8);
    Size[0] = v17;
    v72 = v16 + 2;
    v18 = &v16[v17 + 2];
    if ( v18 + 2 > v12 || v17 + 2 < v17 )
      goto LABEL_91;
    if ( !v69 )
    {
      *a5 = v14;
      return 0i64;
    }
    if ( *a5 < v14 )
      return 122i64;
    v20 = (_DWORD)v18 - (_DWORD)a2;
    v10 = (*((_DWORD *)this + 16) & 0x80800) == 0;
    v61 = (_DWORD)v18 - (_DWORD)a2;
    if ( !v10 )
    {
      if ( v18 + 4 > v12 )
      {
        v21 = 822;
LABEL_92:
        v25 = 50;
        goto LABEL_93;
      }
      v22 = v18[1];
      v23 = *v18;
      v18 += 2;
      v58 = v23 | (v22 << 8);
      if ( !CTlsSignatureSuiteList::IsSupportedCodePoint((CSsl3TlsClientContext *)((char *)this + 474), v58) )
      {
        v25 = 47;
LABEL_20:
        v21 = 822;
LABEL_93:
        EphemKey = -2146893048;
        goto LABEL_94;
      }
      v59 = TlsSignatureAlgorithm_Anonymous;
      GetSignatureSuiteInfoByCodePoint(v58, &v59, &v60, v24, (const unsigned __int16 **)&Size[1], 0i64, &v62);
      if ( v59 != v11 || (v9 = v60, v59 == TlsSignatureAlgorithm_Dsa) && v60 != TlsHashAlgorithm_Sha1 )
      {
        v25 = 40;
        goto LABEL_20;
      }
      v20 = v61;
    }
    cbEncoded = v18[1] | (*v18 << 8);
    if ( &v18[cbEncoded + 2] != v12 )
    {
LABEL_91:
      v21 = 807;
      goto LABEL_92;
    }
    v27 = v11 - 1;
    if ( !v27 )
    {
      EphemKey = VerifyRsaParams(
                   (UCHAR *)this,
                   a2,
                   v20,
                   *(const unsigned __int16 **)&Size[1],
                   v9,
                   v62,
                   v18 + 2,
                   cbEncoded);
      if ( EphemKey )
      {
        v25 = 51;
        v21 = 802;
        goto LABEL_94;
      }
LABEL_33:
      if ( (*((_BYTE *)this + 32) & 1) != 0 && (v29 = *((_QWORD *)this + 1)) != 0 )
      {
        v30 = *(_DWORD *)(v29 + 28);
      }
      else
      {
        v29 = *((_QWORD *)this + 1);
        v30 = 0;
        if ( !v29 )
        {
          v31 = 0i64;
LABEL_39:
          EphemKey = DhGetEphemKey(v31, v30, *((unsigned __int16 *)this + 17), v13, v71, v66, v70, &v65, &v63);
          if ( EphemKey )
          {
            v32 = 51;
            if ( EphemKey == 87 )
              v32 = 40;
            CSslContext::SetErrorAndFatalAlert((__int64)this, 808, EphemKey, v32);
            goto LABEL_43;
          }
          v34 = *((_QWORD *)this + 10);
          v35 = v63;
          v36 = *(_DWORD *)(v34 + 196);
          if ( v36 && IsDheAlgorithmBlacklisted(*(struct _TLS_PARAMETERS **)(v34 + 200), v36, v63, 0i64, 1u) )
          {
            CSslContext::SetErrorAndFatalAlert((__int64)this, 808, 0, 0x28u);
            EphemKey = 87;
LABEL_43:
            v33 = v65;
LABEL_87:
            if ( v33 )
              SslFreeObject(v33, 0i64);
            if ( v64 )
              SslFreeObject(v64, 0i64);
            return EphemKey;
          }
          *(_DWORD *)(*((_QWORD *)this + 165) + 8i64) = v35;
          v37 = (__int64 *)*((_QWORD *)this + 1);
          if ( v37 )
            v38 = *v37;
          else
            v38 = 0i64;
          v33 = v65;
          EphemBlobFromKey = GetEphemBlobFromKey(v38, v65, L"DHPUBLICBLOB", &v57, (unsigned __int8 **)&Src);
          v40 = (unsigned int *)Src;
          EphemKey = EphemBlobFromKey;
          if ( EphemBlobFromKey )
          {
            v41 = 809;
            goto LABEL_52;
          }
          v42 = v57;
          if ( v57 )
          {
            if ( v57 <= (unsigned __int64)g_ulMaxStackAllocSize )
            {
              v43 = v57 + g_ulAdditionalProbeSize + 8;
              if ( v43 >= v57 )
              {
                if ( !(unsigned int)VerifyStackAvailable(v43) )
                {
LABEL_64:
                  v42 = v57;
                  goto LABEL_65;
                }
                v42 = v57;
                v44 = v57 + 8 + 15i64;
                if ( v44 <= v57 + 8 )
                  v44 = 0xFFFFFFFFFFFFFF0i64;
                v45 = alloca(v44 & 0xFFFFFFFFFFFFFFF0ui64);
                v7 = (char *)&v57;
                if ( &v56 != (__int64 *)-80i64 )
                {
                  v57 = 1801679955;
                  v7 = (char *)&v59;
                  if ( &v59 )
                  {
                    v42 = v57;
LABEL_62:
                    v46 = Size[0];
                    v47 = 2 * v13 + 8;
                    if ( v47 + Size[0] > v42 )
                    {
                      EphemKey = 1359;
                      goto LABEL_82;
                    }
                    v49 = v47;
                    memcpy_0(v7, v40, v47);
                    v50 = v13 - v46;
                    if ( v50 )
                      memset_0(&v7[v49], 0, v50);
                    memcpy_0(&v7[v49 + v50], v72, v46);
                    v51 = (_QWORD *)*((_QWORD *)this + 1);
                    if ( v51 )
                      v51 = (_QWORD *)*v51;
                    EphemBlobFromKey = SslImportKey(v51, &v64, L"DHPUBLICBLOB", v7, v57, 0);
                    EphemKey = EphemBlobFromKey;
                    if ( !EphemBlobFromKey )
                    {
                      v52 = v40[1];
                      v53 = *a5;
                      *a5 = v52 + 2;
                      if ( v53 >= (int)v52 + 2 )
                      {
                        v54 = v69;
                        v69[1] = v52;
                        *v54 = BYTE1(v52);
                        memcpy_0(v54 + 2, (char *)v40 + 2 * v52 + 8, v52);
                        if ( (*((_DWORD *)this + 34) & 0x8000000) != 0 )
                        {
                          (*(void (__fastcall **)(CSsl3TlsClientContext *, unsigned __int64))(*(_QWORD *)this + 152i64))(
                            this,
                            v64);
                          EccDhPskSessionKeysHelper = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, __int64))(*(_QWORD *)this + 168i64))(
                                                        this,
                                                        v33);
                          v64 = 0i64;
                          v33 = 0i64;
                        }
                        else
                        {
                          EccDhPskSessionKeysHelper = MakeEccDhPskSessionKeysHelper(this, v33, v64, 0);
                        }
                        EphemKey = EccDhPskSessionKeysHelper;
                      }
                      else
                      {
                        EphemKey = -2146893023;
                      }
                      goto LABEL_82;
                    }
                    v41 = 810;
LABEL_52:
                    CSslContext::SetErrorAndFatalAlert((__int64)this, v41, EphemBlobFromKey, 0x33u);
LABEL_82:
                    if ( v40 )
                      SPExternalFree(v40);
                    if ( v7 && *((_DWORD *)v7 - 2) == 1885431112 )
                      ((void (*)(void))g_pfnFree)();
                    goto LABEL_87;
                  }
                  goto LABEL_64;
                }
              }
            }
          }
LABEL_65:
          if ( v42 + 8 >= v42 )
          {
            v48 = (char *)((__int64 (__fastcall *)(_QWORD))g_pfnAllocate)(v42 + 8);
            v7 = v48;
            if ( !v48 )
              goto LABEL_69;
            *(_DWORD *)v48 = 1885431112;
            v7 = v48 + 8;
            v42 = v57;
          }
          if ( v7 )
            goto LABEL_62;
LABEL_69:
          EphemKey = 14;
          goto LABEL_82;
        }
      }
      v31 = *(_QWORD *)v29;
      goto LABEL_39;
    }
    if ( v27 == 1 )
    {
      EphemKey = VerifyDssParams((UCHAR *)this, a2, v20, v18 + 2, cbEncoded);
      if ( EphemKey )
      {
        v25 = 51;
        v21 = 823;
LABEL_94:
        CSslContext::SetErrorAndFatalAlert((__int64)this, v21, EphemKey, v25);
        return EphemKey;
      }
      goto LABEL_33;
    }
  }
  return 2148074248i64;
}
// 180074795: variable 'v24' is possibly undefined
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);
// 1800985A0: using guessed type __int64 __fastcall SslImportKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180074C40) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::DhGenerateServerExchangeValue(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned int *a3)
{
  __int64 v3; // rax
  unsigned int *v4; // rsi
  bool v6; // zf
  enum _eTlsSignatureAlgorithm v7; // edi
  char *v8; // r14
  unsigned int ServerEphemKey; // ebx
  __int64 v10; // r15
  unsigned int v11; // r14d
  int v12; // r13d
  __int64 v13; // rax
  __int16 v14; // si
  int v16; // eax
  DWORD v17; // eax
  unsigned int v18; // r13d
  unsigned int v19; // edi
  char *v20; // r15
  unsigned int v21; // r14d
  size_t v22; // r8
  __int64 v23; // rsi
  unsigned __int8 v24; // al
  __int64 v25; // rdi
  unsigned __int8 *v26; // rbx
  char *v27; // r15
  unsigned __int8 v28; // al
  unsigned __int8 *v29; // rbx
  unsigned __int8 *v30; // rdi
  enum _eTlsSignatureAlgorithm v31; // esi
  unsigned int v32; // r15d
  unsigned int v33; // r13d
  __int32 v34; // esi
  unsigned int v35; // eax
  enum _eTlsHashAlgorithm v36; // [rsp+40h] [rbp-28h] BYREF
  unsigned int Size; // [rsp+44h] [rbp-24h]
  enum _eTlsSignatureAlgorithm Size_4; // [rsp+48h] [rbp-20h]
  unsigned int v39; // [rsp+4Ch] [rbp-1Ch] BYREF
  int v40; // [rsp+50h] [rbp-18h] BYREF
  unsigned int v41; // [rsp+54h] [rbp-14h]
  unsigned __int16 *v42; // [rsp+58h] [rbp-10h] BYREF
  __int16 v43; // [rsp+B0h] [rbp+48h]
  DWORD pcbResult; // [rsp+C8h] [rbp+60h] BYREF

  v3 = *((_QWORD *)this + 1);
  pcbResult = 0;
  v4 = a3;
  v40 = 0;
  v42 = 0i64;
  v6 = *(_DWORD *)(v3 + 52) == 2;
  v36 = TlsHashAlgorithm_None;
  v43 = 0;
  v39 = 0;
  if ( v6 )
  {
    v7 = TlsSignatureAlgorithm_Rsa;
  }
  else
  {
    if ( *(_DWORD *)(v3 + 52) != 3 )
      goto LABEL_34;
    v7 = TlsSignatureAlgorithm_Dsa;
  }
  v8 = (char *)this + 960;
  Size_4 = v7;
  if ( !*((_QWORD *)this + 120) )
  {
    ServerEphemKey = GetServerEphemKey(this, (struct CEphemKeyData **)this + 120);
    if ( ServerEphemKey )
      return ServerEphemKey;
  }
  v6 = (*((_DWORD *)this + 16) & 0x40400) == 0;
  v10 = *(_QWORD *)(*(_QWORD *)v8 + 16i64);
  v11 = *(_DWORD *)(v10 + 4);
  Size = v11;
  v41 = 3 * v11;
  v12 = 3 * v11 + 12;
  if ( v6 )
  {
LABEL_13:
    v16 = ComputeSignatureLength((__int64 **)this, v7, v36, &pcbResult);
    ServerEphemKey = v16;
    if ( v16 < 0 )
    {
      CSslContext::SetErrorAndFatalAlert((__int64)this, 1051, v16, 0x50u);
      return ServerEphemKey;
    }
    v17 = 140;
    if ( pcbResult > 0x8C )
      v17 = pcbResult;
    v18 = v17 + v12;
    if ( !a2 )
    {
      *v4 = v18;
      return 0;
    }
    if ( *v4 < v18 )
    {
      *v4 = v18;
      return (unsigned int)-2146893023;
    }
    v19 = Size;
    v20 = (char *)(v10 + 8);
    v21 = v11 >> 8;
    v22 = Size;
    *a2 = v21;
    a2[1] = v19;
    v23 = v19;
    memcpy_0(a2 + 2, v20, v22);
    v24 = Size;
    v25 = v19 + 2;
    v26 = &a2[v25];
    v27 = &v20[v23];
    *v26 = v21;
    v26[1] = v24;
    memcpy_0(&a2[v25 + 2], v27, (unsigned int)v23);
    v28 = Size;
    v29 = &a2[v25 + v25];
    *v29 = v21;
    v29[1] = v28;
    memcpy_0(v29 + 2, &v27[v23], (unsigned int)v23);
    v30 = &v29[v25];
    v31 = Size_4;
    v32 = (_DWORD)v30 - (_DWORD)a2;
    v33 = v18 - v41 - 6;
    if ( (*((_DWORD *)this + 16) & 0x40400) != 0 )
    {
      if ( Size_4 == TlsSignatureAlgorithm_Dsa && v36 != TlsHashAlgorithm_Sha1 || v33 < 2 )
        return 1359;
      *(_WORD *)v30 = v43;
      v30 += 2;
      v33 -= 2;
    }
    pcbResult = v33 - 2;
    ServerEphemKey = SslImpersonateClient(*(_QWORD *)(*((_QWORD *)this + 10) + 752i64), &v40);
    if ( ServerEphemKey )
    {
LABEL_35:
      if ( v40 )
        RevertToSelf();
      return ServerEphemKey;
    }
    v34 = v31 - 1;
    if ( !v34 )
    {
      v35 = SignRsaParams(this, a2, v32, v42, v36, v39, v30 + 2, &pcbResult);
LABEL_32:
      ServerEphemKey = v35;
      if ( !v35 )
      {
        *v30 = BYTE1(pcbResult);
        v30[1] = pcbResult;
        *a3 = (_DWORD)v30 - (_DWORD)a2 + pcbResult + 2;
      }
      goto LABEL_35;
    }
    if ( v34 == 1 )
    {
      v35 = SignDssParams(this, a2, v32, v30 + 2, &pcbResult);
      goto LABEL_32;
    }
LABEL_34:
    ServerEphemKey = -2146893048;
    goto LABEL_35;
  }
  v12 = 3 * v11 + 14;
  v13 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 248i64))(this);
  if ( v13 )
  {
    v14 = __ROR2__(
            CTlsSignatureSuiteList::GetMinimumCodePointToSign(
              (CSsl3TlsServerContext *)((char *)this + 510),
              v7,
              *(_DWORD *)(v13 + 428),
              *((_DWORD *)this + 16),
              0),
            8);
    v43 = v14;
    if ( !v14 )
      return 2148074289i64;
    GetSignatureSuiteInfoByCodePoint(v14, 0i64, &v36, 0i64, (const unsigned __int16 **)&v42, 0i64, &v39);
    v4 = a3;
    goto LABEL_13;
  }
  return (unsigned int)-2146893052;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180074F68) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::DhGenerateServerMasterKey(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  unsigned __int64 *v3; // rbx
  unsigned __int64 v7; // rdi
  size_t v8; // r14
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rax
  void *v11; // rsp
  _DWORD *v12; // rax
  unsigned int EccDhPskSessionKeysHelper; // edi
  unsigned int v14; // edx
  _QWORD *v15; // rcx
  unsigned int v16; // eax
  CSsl3TlsServerContext *v17; // rcx
  unsigned __int8 v18; // r9
  int v19; // r8d
  int v20; // edx
  __int64 v22; // [rsp+0h] [rbp-30h] BYREF
  unsigned __int64 v23; // [rsp+30h] [rbp+0h] BYREF
  __int64 v24[3]; // [rsp+38h] [rbp+8h] BYREF

  v23 = 0i64;
  v3 = 0i64;
  v7 = *(unsigned int *)(*((_QWORD *)this + 120) + 24i64);
  if ( !(_DWORD)v7 )
    goto LABEL_9;
  v8 = (unsigned int)v7;
  if ( v7 > g_ulMaxStackAllocSize )
    goto LABEL_9;
  v9 = v7 + g_ulAdditionalProbeSize + 8;
  if ( v9 < v7 || !(unsigned int)VerifyStackAvailable(v9) )
    goto LABEL_9;
  v10 = (unsigned int)(v7 + 8) + 15i64;
  if ( v10 <= (unsigned int)(v7 + 8) )
    v10 = 0xFFFFFFFFFFFFFF0i64;
  v11 = alloca(v10 & 0xFFFFFFFFFFFFFFF0ui64);
  v3 = &v23;
  if ( &v22 == (__int64 *)-48i64 || (LODWORD(v23) = 1801679955, (v3 = (unsigned __int64 *)v24) == 0i64) )
  {
LABEL_9:
    if ( (int)v7 + 8 >= (unsigned int)v7 )
    {
      v12 = (_DWORD *)((__int64 (__fastcall *)(_QWORD))g_pfnAllocate)((unsigned int)(v7 + 8));
      if ( !v12 )
      {
LABEL_13:
        EccDhPskSessionKeysHelper = 14;
        goto LABEL_31;
      }
      *v12 = 1885431112;
      v3 = (unsigned __int64 *)(v12 + 2);
    }
    if ( !v3 )
      goto LABEL_13;
    v8 = v7;
  }
  memcpy_0(v3, *(const void **)(*((_QWORD *)this + 120) + 16i64), v8);
  if ( !a2 || a3 <= 2 || (v14 = a2[1] | (*a2 << 8), v14 + 2 != a3) || !v14 )
  {
    v19 = -2146893048;
    v17 = this;
    EccDhPskSessionKeysHelper = -2146893048;
    v20 = 704;
    v18 = 50;
    goto LABEL_27;
  }
  if ( (unsigned __int64)(3 * v14) + 8 <= v8 )
  {
    memcpy_0((char *)v3 + 2 * v14 + 8, a2 + 2, v14);
    v15 = (_QWORD *)*((_QWORD *)this + 1);
    if ( v15 )
      v15 = (_QWORD *)*v15;
    v16 = SslImportKey(v15, &v23, L"DHPUBLICBLOB", v3, v7, 0);
    EccDhPskSessionKeysHelper = v16;
    v17 = this;
    if ( !v16 )
    {
      EccDhPskSessionKeysHelper = MakeEccDhPskSessionKeysHelper(
                                    this,
                                    *(_QWORD *)(*((_QWORD *)this + 120) + 8i64),
                                    v23,
                                    1);
      goto LABEL_28;
    }
    v18 = 51;
    v19 = v16;
    v20 = 705;
LABEL_27:
    CSslContext::SetErrorAndFatalAlert((__int64)v17, v20, v19, v18);
    goto LABEL_28;
  }
  EccDhPskSessionKeysHelper = 1359;
LABEL_28:
  if ( v3 && *((_DWORD *)v3 - 2) == 1885431112 )
    ((void (*)(void))g_pfnFree)();
LABEL_31:
  if ( v23 )
    SslFreeObject(v23, 0i64);
  return EccDhPskSessionKeysHelper;
}
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);
// 1800985A0: using guessed type __int64 __fastcall SslImportKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (00000001800751B8) ----------------------------------------------------
__int64 __fastcall DhGetEphemKey(
        __int64 a1,
        unsigned int a2,
        unsigned int a3,
        unsigned int a4,
        const unsigned __int8 *Src,
        unsigned int Size,
        const unsigned __int8 *a7,
        unsigned __int64 *a8,
        unsigned int *a9)
{
  struct kexch *KeyExchangeInfo; // rax
  unsigned int v11; // r9d
  const unsigned __int8 *v12; // rbx
  unsigned int v13; // r13d
  const unsigned __int8 *v14; // r15
  unsigned int v15; // esi
  unsigned int *v17; // rdi
  unsigned int v18; // r14d
  unsigned __int64 v19; // rdx
  unsigned __int64 v20; // rcx
  int v21; // edx
  unsigned __int64 v22; // rax
  void *v23; // rsp
  unsigned int v24; // eax
  _DWORD *v25; // rax
  unsigned int v26; // ebx
  char *v27; // r14
  __int64 v28; // [rsp+0h] [rbp-50h] BYREF
  unsigned int v29; // [rsp+50h] [rbp+0h] BYREF
  unsigned int v30; // [rsp+54h] [rbp+4h]
  unsigned int v31; // [rsp+58h] [rbp+8h] BYREF
  __int64 v32; // [rsp+60h] [rbp+10h]
  unsigned __int64 v33; // [rsp+68h] [rbp+18h] BYREF

  v32 = a1;
  v31 = a3;
  v30 = a2;
  KeyExchangeInfo = GetKeyExchangeInfo(43522);
  v12 = Src;
  v13 = Size;
  v14 = a7;
  if ( Src && a7 )
  {
    v15 = 8 * v11;
    if ( Size > v11 )
      return 87i64;
    if ( v15 < *((_DWORD *)KeyExchangeInfo + 8) || v15 > *((_DWORD *)KeyExchangeInfo + 10) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_d(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xAu,
          (__int64)&WPP_83c3a6cdaad8366ccbbf1e25ed54fc6f_Traceguids,
          v15);
      return 87i64;
    }
  }
  else
  {
    v15 = *((_DWORD *)KeyExchangeInfo + 12);
  }
  v17 = 0i64;
  v18 = v15 >> 3;
  v19 = 2 * (v15 >> 3) + 12;
  v29 = 2 * (v15 >> 3) + 12;
  if ( v19 <= g_ulMaxStackAllocSize )
  {
    v20 = v19 + g_ulAdditionalProbeSize + 8;
    if ( v20 >= v19 )
    {
      if ( (unsigned int)VerifyStackAvailable(v20) )
      {
        v21 = 2 * v18 + 12;
        v22 = 2 * v18 + 20 + 15i64;
        if ( v22 <= 2 * v18 + 20 )
          v22 = 0xFFFFFFFFFFFFFF0i64;
        v23 = alloca(v22 & 0xFFFFFFFFFFFFFFF0ui64);
        v17 = &v29;
        if ( &v28 != (__int64 *)-80i64 )
        {
          v29 = 1801679955;
          v17 = &v31;
          if ( &v31 )
            goto LABEL_24;
        }
      }
    }
  }
  v24 = 2 * v18 + 20;
  if ( v24 < 2 * v18 + 12 )
  {
LABEL_21:
    if ( !v17 )
      return 14;
    v21 = 2 * v18 + 12;
LABEL_24:
    if ( !Src )
    {
      switch ( v15 )
      {
        case 0x400u:
          v12 = (const unsigned __int8 *)&unk_1800862E0;
          break;
        case 0x800u:
          v12 = (const unsigned __int8 *)&unk_180086160;
          break;
        case 0xC00u:
          v12 = (const unsigned __int8 *)&unk_180085EE0;
          break;
        default:
          v12 = (const unsigned __int8 *)&unk_180085B60;
          break;
      }
      a4 = v15 >> 3;
    }
    if ( !a7 )
    {
      switch ( v15 )
      {
        case 0x400u:
          v14 = (const unsigned __int8 *)&unk_180086260;
          break;
        case 0x800u:
          v14 = (const unsigned __int8 *)&unk_180086060;
          break;
        case 0xC00u:
          v14 = (const unsigned __int8 *)&unk_180085D60;
          break;
        default:
          v14 = (const unsigned __int8 *)&unk_180085960;
          break;
      }
      v13 = v15 >> 3;
    }
    *v17 = v21;
    v17[2] = a4;
    v17[1] = 1297107012;
    memcpy_0(v17 + 3, v12, a4);
    v27 = (char *)v17 + v17[2] + 12;
    if ( v13 < a4 )
    {
      memset_0(v27, 0, a4 - v13);
      v27 += a4 - v13;
    }
    memcpy_0(v27, v14, v13);
    v26 = SslCreateEphemeralKey(v32, &v33, v31, v30, 0, 8 * a4, v17, v29, 0);
    if ( v26 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_83c3a6cdaad8366ccbbf1e25ed54fc6f_Traceguids, v26);
    }
    else
    {
      *a8 = v33;
      if ( a9 )
        *a9 = v15;
    }
    if ( v17 && *(v17 - 2) == 1885431112 )
      ((void (*)(void))g_pfnFree)();
    return v26;
  }
  v25 = (_DWORD *)((__int64 (__fastcall *)(_QWORD))g_pfnAllocate)(v24);
  if ( v25 )
  {
    *v25 = 1885431112;
    v17 = v25 + 2;
    goto LABEL_21;
  }
  return 14;
}
// 18007521F: variable 'v11' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180098548: using guessed type __int64 __fastcall SslCreateEphemeralKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _DWORD, _DWORD);

//----- (00000001800754F8) ----------------------------------------------------
__int64 __fastcall SignDssParams(
        struct CSsl3TlsServerContext *a1,
        unsigned __int8 *a2,
        ULONG a3,
        BYTE *pbEncoded,
        DWORD *pcbEncoded)
{
  bool v5; // zf
  DWORD Hash; // ebx
  int v10; // edx
  int v11; // r8d
  __int64 *v12; // rax
  __int64 v13; // rcx
  unsigned int v14; // edx
  int v15; // [rsp+40h] [rbp-78h] BYREF
  unsigned __int8 v16[24]; // [rsp+48h] [rbp-70h] BYREF
  unsigned __int8 pvStructInfo[20]; // [rsp+60h] [rbp-58h] BYREF
  unsigned __int8 v18[20]; // [rsp+74h] [rbp-44h] BYREF

  v5 = *((_QWORD *)a1 + 3) == 0i64;
  v15 = 40;
  if ( v5 )
    return 2148074253i64;
  Hash = GenerateHash(g_hSHAProvider, (UCHAR *)a1, a2, a3, v16, 0x14u);
  if ( Hash )
  {
    v10 = 1111;
LABEL_5:
    v11 = Hash;
LABEL_6:
    CSslContext::SetErrorAndFatalAlert((__int64)a1, v10, v11, 0x50u);
    return Hash;
  }
  v12 = (__int64 *)*((_QWORD *)a1 + 1);
  if ( v12 )
    v13 = *v12;
  else
    v13 = 0i64;
  Hash = SslSignHash(v13, *(_QWORD *)(*((_QWORD *)a1 + 3) + 8i64), v16, 20i64, pvStructInfo, v15, &v15, 0);
  if ( Hash )
  {
    v10 = 1112;
    goto LABEL_5;
  }
  ReverseInPlace(pvStructInfo, 0x14u);
  ReverseInPlace(v18, v14);
  if ( !CryptEncodeObject(1u, (LPCSTR)0x28, pvStructInfo, pbEncoded, pcbEncoded) )
  {
    Hash = GetLastError();
    v11 = Hash;
    v10 = 1113;
    goto LABEL_6;
  }
  return 0i64;
}
// 1800755F5: variable 'v14' is possibly undefined
// 180098540: using guessed type __int64 __fastcall SslSignHash(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 1800754F8: using guessed type unsigned __int8 var_44[20];

//----- (0000000180075660) ----------------------------------------------------
__int64 __fastcall VerifyDssParams(UCHAR *a1, unsigned __int8 *a2, ULONG a3, BYTE *pbEncoded, DWORD cbEncoded)
{
  DWORD LastError; // eax
  unsigned __int8 v9; // r9
  int v10; // edx
  unsigned int v11; // ebx
  unsigned int v12; // edx
  ULONG v13; // edx
  int v14; // r8d
  DWORD cbSignature; // [rsp+40h] [rbp-31h] BYREF
  NCRYPT_KEY_HANDLE hKey; // [rsp+48h] [rbp-29h] BYREF
  BYTE pbHashValue[24]; // [rsp+50h] [rbp-21h] BYREF
  BYTE pvStructInfo[20]; // [rsp+68h] [rbp-9h] BYREF
  unsigned __int8 v20[20]; // [rsp+7Ch] [rbp+Bh] BYREF

  hKey = 0i64;
  cbSignature = 40;
  if ( !CryptDecodeObject(1u, (LPCSTR)0x28, pbEncoded, cbEncoded, 0, pvStructInfo, &cbSignature) )
  {
    LastError = GetLastError();
    v9 = 50;
    v10 = 1114;
    v11 = LastError;
LABEL_9:
    v14 = LastError;
    goto LABEL_10;
  }
  ReverseInPlace(pvStructInfo, 0x14u);
  ReverseInPlace(v20, v12);
  LastError = GenerateHash(g_hSHAProvider, a1, a2, a3, pbHashValue, v13);
  v11 = LastError;
  if ( LastError )
  {
    v9 = 80;
    v10 = 1115;
    goto LABEL_9;
  }
  RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)a1 + 11) + 72i64), 1u);
  v11 = DhDssPublicKeyFromCert(*(const struct _CERT_CONTEXT **)(*((_QWORD *)a1 + 11) + 48i64), &hKey);
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)a1 + 11) + 72i64));
  if ( !v11 )
  {
    LastError = NCryptVerifySignature(hKey, 0i64, pbHashValue, 0x14u, pvStructInfo, cbSignature, 0);
    v11 = LastError;
    if ( !LastError )
      goto LABEL_11;
    v9 = 51;
    v10 = 1116;
    goto LABEL_9;
  }
  v9 = 43;
  v14 = v11;
  v10 = 1117;
LABEL_10:
  CSslContext::SetErrorAndFatalAlert((__int64)a1, v10, v14, v9);
LABEL_11:
  if ( hKey )
    NCryptFreeObject(hKey);
  return v11;
}
// 1800756F6: variable 'v12' is possibly undefined
// 180075718: variable 'v13' is possibly undefined
// 180075660: using guessed type unsigned __int8 var_44[20];

//----- (0000000180075800) ----------------------------------------------------
__int64 __fastcall GetServerEphemKey(struct CSsl3TlsServerContext *a1, struct CEphemKeyData **a2)
{
  unsigned int v2; // ebx
  struct CEphemKeyData **v5; // rax
  int v6; // edi
  unsigned int EccEphemeralKeyInfo; // ebx

  v2 = *((_DWORD *)a1 + 4);
  v5 = (struct CEphemKeyData **)(*(__int64 (__fastcall **)(struct CSsl3TlsServerContext *))(*(_QWORD *)a1 + 248i64))(a1);
  v6 = 0;
  if ( v2 )
  {
    EccEphemeralKeyInfo = CSslCredential::GetEccEphemeralKeyInfo((CSslCredential *)v5, v2, a2);
  }
  else
  {
    EccEphemeralKeyInfo = CSslCredential::GetEphemeralKeyInfo((CSslCredential *)v5, 0, v5 + 62, a2);
    if ( EccEphemeralKeyInfo == 87 )
    {
      v6 = 1;
      goto LABEL_4;
    }
  }
  if ( EccEphemeralKeyInfo )
  {
LABEL_4:
    CSslContext::SetErrorAndFatalAlert((__int64)a1, 603, EccEphemeralKeyInfo, v6 != 0 ? 40 : 80);
    return EccEphemeralKeyInfo;
  }
  *(_DWORD *)(*((_QWORD *)a1 + 11) + 8i64) = *((_DWORD *)*a2 + 10);
  return 0i64;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (00000001800758BC) ----------------------------------------------------
__int64 __fastcall MakeRsaSessionKeysHelper(struct CSsl3TlsContext *this, __int64 a2)
{
  unsigned int v5; // edi
  __int64 v6; // rax
  _QWORD *v7; // rcx
  __int64 v8; // rcx
  unsigned int SessionKeys; // edi
  __int64 v10; // r8
  __int64 v11; // r9
  int v12; // edx
  __int64 *v13; // rax
  int v14; // edx
  __int64 v15; // rcx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  unsigned int v19; // [rsp+60h] [rbp-49h] BYREF
  unsigned __int64 v20; // [rsp+68h] [rbp-41h] BYREF
  __int128 v21; // [rsp+70h] [rbp-39h] BYREF
  int v22[2]; // [rsp+80h] [rbp-29h] BYREF
  __int128 *v23; // [rsp+88h] [rbp-21h]
  struct _EVENT_DATA_DESCRIPTOR v24; // [rsp+90h] [rbp-19h] BYREF
  char v25[64]; // [rsp+A0h] [rbp-9h] BYREF

  v20 = 0i64;
  memset((char *)&v21 + 4, 0, 12);
  memset_0(v25, 0, sizeof(v25));
  v19 = 0;
  if ( !this )
    return 87i64;
  if ( (*((_DWORD *)this + 16) & 0xA2A80) == 0 || (*((_DWORD *)this + 34) & 0x8000000) == 0 )
    return 1359i64;
  v5 = *((unsigned __int16 *)this + 17);
  v6 = (*(__int64 (__fastcall **)(struct CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 512i64))(this, 0i64);
  v7 = (_QWORD *)*((_QWORD *)this + 1);
  if ( v7 )
    v7 = (_QWORD *)*v7;
  SessionKeys = SslComputeSessionHash(v7, v6, v5, v25, 64, &v19, 0);
  if ( SessionKeys )
  {
    v12 = 604;
LABEL_9:
    CSslContext::SetErrorAndFatalAlert((__int64)this, v12, SessionKeys, 0x33u);
    return SessionKeys;
  }
  v22[0] = 0;
  v23 = &v21;
  *(_QWORD *)&v21 = v19 | 0x1900000000i64;
  *((_QWORD *)&v21 + 1) = v25;
  v22[1] = 1;
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EventWriteTransfer(v8, &GenerateMasterKeyStart, v10, v11, &v24);
  if ( (*((_BYTE *)this + 32) & 1) != 0 && (v13 = (__int64 *)*((_QWORD *)this + 1)) != 0i64 )
  {
    v14 = *((_DWORD *)v13 + 7);
  }
  else
  {
    v13 = (__int64 *)*((_QWORD *)this + 1);
    v14 = 0;
  }
  if ( v13 )
    v15 = *v13;
  else
    v15 = 0i64;
  SessionKeys = SslGenerateMasterKey(v15, a2, 0i64, &v20, *((unsigned __int16 *)this + 17), v14, v22, 0i64, 0, &v19, 1);
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EventWriteTransfer(v16, &GenerateMasterKeyStop, v17, v18, &v24);
  if ( SessionKeys )
  {
    v12 = 706;
    goto LABEL_9;
  }
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
  *(_QWORD *)(*((_QWORD *)this + 11) + 16i64) = v20;
  SessionKeys = CSslContext::MakeSessionKeys(this, v20);
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
  if ( SessionKeys )
    return SessionKeys;
  LsaIModifyPerformanceCounter(6i64);
  return 0i64;
}
// 1800759EC: variable 'v8' is possibly undefined
// 1800759EC: variable 'v10' is possibly undefined
// 1800759EC: variable 'v11' is possibly undefined
// 180075A7B: variable 'v16' is possibly undefined
// 180075A7B: variable 'v17' is possibly undefined
// 180075A7B: variable 'v18' is possibly undefined
// 180084BE0: using guessed type EVENT_DESCRIPTOR GenerateMasterKeyStop;
// 180084BF0: using guessed type EVENT_DESCRIPTOR GenerateMasterKeyStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);
// 1800984A0: using guessed type __int64 __fastcall SslGenerateMasterKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 180098530: using guessed type __int64 __fastcall SslComputeSessionHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);

//----- (0000000180075B20) ----------------------------------------------------
SECURITY_STATUS __fastcall ComputeSignatureLength(
        __int64 **this,
        enum _eTlsSignatureAlgorithm a2,
        enum _eTlsHashAlgorithm a3,
        DWORD *pcbResult)
{
  SECURITY_STATUS result; // eax
  DWORD v9; // esi
  __int64 *v10; // rax
  __int64 v11; // r10
  __int64 *v12; // rax
  __int64 v13; // rcx
  __int64 v14; // rcx
  DWORD cbHashValue[4]; // [rsp+40h] [rbp-78h] BYREF
  BYTE pbHashValue[64]; // [rsp+50h] [rbp-68h] BYREF

  memset_0(pbHashValue, 0, sizeof(pbHashValue));
  cbHashValue[0] = 0;
  if ( !this || !pcbResult )
    return 87;
  *pcbResult = 0;
  result = CSsl3TlsContext::GetHashAlgorithmSize((CSsl3TlsContext *)this, a2, a3, cbHashValue);
  if ( result )
    return result;
  v9 = cbHashValue[0];
  if ( cbHashValue[0] > 0x40 )
    return -2146893052;
  if ( ((_DWORD)this[8] & 0x40051555) == 0 )
  {
    v14 = ((__int64 (__fastcall *)(__int64 **))(*this)[31])(this);
    if ( v14 )
      return NCryptSignHash(*(_QWORD *)(v14 + 104), 0i64, pbHashValue, v9, 0i64, *pcbResult, pcbResult, 0x40u);
    return -2146893052;
  }
  v10 = this[3];
  if ( !v10 )
    return -2146893052;
  v11 = v10[1];
  v12 = this[1];
  if ( v12 )
    v13 = *v12;
  else
    v13 = 0i64;
  return SslSignHash(v13, v11, pbHashValue, cbHashValue[0], 0i64, *pcbResult, pcbResult, 0);
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180098540: using guessed type __int64 __fastcall SslSignHash(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 180075B20: using guessed type DWORD cbHashValue[4];

//----- (0000000180075C88) ----------------------------------------------------
__int64 __fastcall SignEcdsaParams(
        struct CSsl3TlsServerContext *a1,
        unsigned __int8 *a2,
        ULONG a3,
        enum _eTlsHashAlgorithm a4,
        BYTE *pbEncoded,
        DWORD *pcbEncoded)
{
  enum _eTlsHashAlgorithm v8; // ecx
  int TlsHash; // eax
  unsigned int v10; // edi
  unsigned int *p_pvStructInfo; // rbx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rax
  void *v15; // rsp
  _DWORD *v16; // rax
  __int64 v17; // rax
  DWORD v18; // edx
  __int64 v19; // r10
  __int64 *v20; // rax
  __int64 v21; // rcx
  int LastError; // eax
  int v23; // edx
  __int64 v24; // [rsp+0h] [rbp-40h] BYREF
  unsigned int *v25; // [rsp+28h] [rbp-18h]
  unsigned int v26; // [rsp+40h] [rbp+0h] BYREF
  unsigned int v27; // [rsp+44h] [rbp+4h] BYREF
  unsigned int pvStructInfo; // [rsp+48h] [rbp+8h] BYREF
  unsigned int *v29; // [rsp+50h] [rbp+10h]
  unsigned int v30; // [rsp+58h] [rbp+18h]
  __int64 v31; // [rsp+60h] [rbp+20h]
  unsigned __int8 v32[64]; // [rsp+70h] [rbp+30h] BYREF

  v27 = 0;
  if ( !*((_QWORD *)a1 + 3) )
    return 2148074253i64;
  v25 = &v27;
  v8 = TlsHashAlgorithm_Sha1;
  if ( a4 )
    v8 = a4;
  TlsHash = GenerateTlsHash(v8, (UCHAR *)a1, a2, a3, v32, v25);
  v10 = TlsHash;
  if ( !TlsHash )
  {
    p_pvStructInfo = 0i64;
    if ( !*pcbEncoded )
      goto LABEL_15;
    v12 = *pcbEncoded;
    if ( v12 > g_ulMaxStackAllocSize )
      goto LABEL_15;
    v13 = v12 + g_ulAdditionalProbeSize + 8;
    if ( v13 < v12 || !(unsigned int)VerifyStackAvailable(v13) )
      goto LABEL_15;
    v14 = *pcbEncoded + 8 + 15i64;
    if ( v14 <= *pcbEncoded + 8 )
      v14 = 0xFFFFFFFFFFFFFF0i64;
    v15 = alloca(v14 & 0xFFFFFFFFFFFFFFF0ui64);
    p_pvStructInfo = &v26;
    if ( &v24 == (__int64 *)-64i64 || (v26 = 1801679955, (p_pvStructInfo = &pvStructInfo) == 0i64) )
    {
LABEL_15:
      if ( *pcbEncoded + 8 >= *pcbEncoded )
      {
        v16 = (_DWORD *)((__int64 (*)(void))g_pfnAllocate)();
        if ( !v16 )
          return 14;
        *v16 = 1885431112;
        p_pvStructInfo = v16 + 2;
      }
      if ( !p_pvStructInfo )
        return 14;
    }
    v17 = *((_QWORD *)a1 + 3);
    v18 = *pcbEncoded;
    v26 = *pcbEncoded;
    v19 = *(_QWORD *)(v17 + 8);
    v20 = (__int64 *)*((_QWORD *)a1 + 1);
    if ( v20 )
      v21 = *v20;
    else
      v21 = 0i64;
    LastError = SslSignHash(v21, v19, v32, v27, p_pvStructInfo, v18, &v26, 0);
    v10 = LastError;
    if ( LastError )
    {
      v23 = 1103;
    }
    else
    {
      ReverseInPlace((unsigned __int8 *)p_pvStructInfo, v26 >> 1);
      ReverseInPlace((unsigned __int8 *)p_pvStructInfo + ((unsigned __int64)v26 >> 1), v26 >> 1);
      pvStructInfo = v26 >> 1;
      v30 = v26 >> 1;
      v31 = (__int64)p_pvStructInfo + ((unsigned __int64)v26 >> 1);
      v29 = p_pvStructInfo;
      if ( CryptEncodeObject(1u, (LPCSTR)0x2F, &pvStructInfo, pbEncoded, pcbEncoded) )
        goto LABEL_28;
      LastError = GetLastError();
      v10 = LastError;
      v23 = 1104;
    }
    CSslContext::SetErrorAndFatalAlert((__int64)a1, v23, LastError, 0x50u);
LABEL_28:
    if ( *(p_pvStructInfo - 2) == 1885431112 )
      ((void (*)(void))g_pfnFree)();
    return v10;
  }
  CSslContext::SetErrorAndFatalAlert((__int64)a1, 1102, TlsHash, 0x50u);
  return v10;
}
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180098540: using guessed type __int64 __fastcall SslSignHash(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);

//----- (0000000180075EF8) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::GenerateRenegotiateClientHello(
        CSsl3TlsClientContext *this,
        struct SPBuffer *a2)
{
  CSessionCacheClientItem **v3; // rdi
  unsigned int v5; // esi
  __int64 v6; // rcx
  bool v8; // zf

  v3 = (CSessionCacheClientItem **)((char *)this + 1320);
  CSessionCacheManager::AcquireCacheTableLock(
    (__int64)this,
    *(const unsigned __int16 **)(*((_QWORD *)this + 165) + 368i64),
    0i64);
  v5 = CSessionCacheClientItem::CloneCacheElement(*v3, CSessionCacheManager::m_pSessionCacheManager, v3);
  CSessionCacheManager::ReleaseCacheTableLock(v6, *((const unsigned __int16 **)*v3 + 46), 0i64);
  if ( v5 )
    return v5;
  v8 = *((_BYTE *)this + 233) == 0;
  *((_QWORD *)this + 11) = *v3;
  if ( !v8 )
    *((_DWORD *)this + 327) = 0;
  return (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, struct SPBuffer *))(*(_QWORD *)this + 216i64))(this, a2);
}
// 180075F4C: variable 'v6' is possibly undefined

//----- (0000000180075FAC) ----------------------------------------------------
__int64 __fastcall CTlsExtServer::ParseServerNameExtension(
        CSsl3TlsServerContext **this,
        const unsigned __int8 *a2,
        unsigned int a3)
{
  const unsigned __int8 *v4; // rbx
  unsigned int v5; // edi
  unsigned __int8 v6; // cl
  unsigned int v7; // edi
  unsigned __int16 *v8; // rbx
  unsigned __int16 v9; // si
  const unsigned __int8 *v10; // rbx
  unsigned int v11; // edi
  __int64 result; // rax

  if ( a3 >= 2 && _byteswap_ushort(*(_WORD *)a2) >= 3u )
  {
    v4 = a2 + 2;
    v5 = a3 - 2;
    if ( a3 == 2 )
      return 0i64;
    while ( 1 )
    {
      v6 = *v4;
      v7 = v5 - 1;
      v8 = (unsigned __int16 *)(v4 + 1);
      if ( v7 < 2 )
        break;
      v9 = _byteswap_ushort(*v8);
      if ( !v9 )
        break;
      v10 = (const unsigned __int8 *)(v8 + 1);
      v11 = v7 - 2;
      if ( v11 < v9 )
        break;
      if ( !v6 )
      {
        result = CSsl3TlsServerContext::SetServerNameIndication(this[4], v10, v9);
        if ( (_DWORD)result )
          return result;
      }
      v4 = &v10[v9];
      v5 = v11 - v9;
      if ( !v5 )
        return 0i64;
    }
  }
  return 2148074278i64;
}

//----- (0000000180076074) ----------------------------------------------------
__int64 __fastcall CreateUserMappingDataMsg(
        unsigned __int8 *a1,
        unsigned int a2,
        unsigned __int16 *a3,
        unsigned __int16 *a4)
{
  __int64 v4; // rdi
  __int64 cbMultiByte; // rsi
  unsigned int v8; // eax
  __int16 v9; // r9
  __int16 v10; // r10
  __int16 v11; // r11
  int v12; // edx
  unsigned int v13; // r14d
  CCipherMill *v15; // rcx
  unsigned __int16 v16; // dx
  int v17; // ebp
  CHAR *v18; // rbx
  DWORD LastError; // eax
  __int64 v20; // rdx
  LPSTR lpMultiByteStr; // [rsp+20h] [rbp-38h]

  v4 = -1i64;
  if ( a3 )
  {
    cbMultiByte = -1i64;
    do
      ++cbMultiByte;
    while ( a3[cbMultiByte] );
  }
  else
  {
    LODWORD(cbMultiByte) = 0;
  }
  if ( a4 )
  {
    do
      ++v4;
    while ( a4[v4] );
  }
  else
  {
    LODWORD(v4) = 0;
  }
  v8 = v4 + cbMultiByte;
  v9 = v4 + cbMultiByte + 4;
  v10 = v4 + cbMultiByte + 7;
  v11 = v4 + cbMultiByte + 9;
  v12 = v4 + cbMultiByte + 13;
  v13 = v4 + cbMultiByte + 16;
  if ( (int)v4 + (int)cbMultiByte < (unsigned int)cbMultiByte || v8 + 13 < v8 || v8 + 13 > 0xFFFF )
    return 0i64;
  if ( a1 )
  {
    if ( a2 < v13 )
    {
      v15 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 0i64;
      v16 = 11;
      goto LABEL_22;
    }
    a1[2] = v12;
    v17 = 14;
    *a1 = BYTE2(v12);
    a1[1] = BYTE1(v12);
    a1[5] = HIBYTE(v11);
    a1[7] = HIBYTE(v10);
    a1[10] = HIBYTE(v9);
    a1[12] = BYTE1(cbMultiByte);
    *(_WORD *)(a1 + 3) = 0;
    a1[6] = v11;
    a1[8] = v10;
    a1[9] = 64;
    a1[11] = v9;
    a1[13] = cbMultiByte;
    v18 = (CHAR *)(a1 + 14);
    if ( (_DWORD)cbMultiByte )
    {
      if ( !WideCharToMultiByte(0xFDE9u, 0, a3, cbMultiByte, v18, cbMultiByte, 0i64, 0i64) )
      {
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 0i64;
        LastError = GetLastError();
        v20 = 12i64;
        goto LABEL_35;
      }
      v17 = cbMultiByte + 14;
      v18 += (unsigned int)cbMultiByte;
    }
    v18[1] = v4;
    a2 = v17 + 2;
    *v18 = BYTE1(v4);
    if ( (_DWORD)v4 )
    {
      if ( !WideCharToMultiByte(0xFDE9u, 0, a4, v4, v18 + 2, v4, 0i64, 0i64) )
      {
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 0i64;
        LastError = GetLastError();
        v20 = 13i64;
LABEL_35:
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), v20, &WPP_2a9f95ae24df3f59458f3cae84384e77_Traceguids, LastError);
        return 0i64;
      }
      a2 += v4;
    }
    if ( a2 == v13 )
      return a2;
    v15 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 0i64;
    v16 = 14;
LABEL_22:
    LODWORD(lpMultiByteStr) = v4 + cbMultiByte + 16;
    WPP_SF_dd(*((_QWORD *)v15 + 2), v16, (__int64)&WPP_2a9f95ae24df3f59458f3cae84384e77_Traceguids, a2, lpMultiByteStr);
    return 0i64;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_d(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_2a9f95ae24df3f59458f3cae84384e77_Traceguids, v13);
  return v13;
}
// 180076168: variable 'lpMultiByteStr' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180076330) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::DigestSupplementalDataMsg(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  CCipherMill *v6; // rcx
  unsigned __int16 v7; // dx
  unsigned int v8; // ebp
  unsigned __int8 *v9; // r15
  unsigned int v10; // ebp
  int v11; // edx
  int v12; // r9d
  int v13; // eax
  unsigned __int8 *v14; // r15
  unsigned int v15; // r9d
  unsigned __int8 *v16; // rbx
  int v17; // r8d
  unsigned int v18; // r14d
  int v19; // eax
  unsigned __int8 *v20; // rbx
  unsigned int v21; // r8d
  int v22; // esi
  unsigned int v23; // r14d
  int v24; // eax
  __int64 v25; // r9
  unsigned __int8 *v26; // rbx
  unsigned int v27; // esi
  int v28; // r14d
  unsigned int v29; // esi
  int v30; // eax
  const CHAR *v31; // rbx
  unsigned int v32; // r14d
  unsigned int v33; // eax
  __int64 cchWideChar; // r12
  void *v35; // rcx
  WCHAR *v36; // rax
  unsigned int v37; // r14d
  unsigned int v38; // eax
  __int64 v39; // rsi
  void *v40; // rcx
  WCHAR *v41; // rax
  unsigned __int16 v42; // dx
  CCipherMill *v43; // rcx
  unsigned __int16 v44; // dx
  LPWSTR lpWideCharStr; // [rsp+20h] [rbp-38h]

  v6 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_d(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xFu, (__int64)&WPP_2a9f95ae24df3f59458f3cae84384e77_Traceguids, a3);
    v6 = WPP_GLOBAL_Control;
  }
  if ( (*((_DWORD *)this + 34) & 0x100i64) == 0 || !*((_BYTE *)this + 922) )
  {
    if ( v6 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v6 + 28) & 5) == 0 )
      return 2148074278i64;
    v7 = 16;
    goto LABEL_129;
  }
  if ( *((_QWORD *)this + 116) )
  {
    SPExternalFree(*((void **)this + 116));
    *((_QWORD *)this + 116) = 0i64;
    v6 = WPP_GLOBAL_Control;
  }
  if ( *((_QWORD *)this + 117) )
  {
    SPExternalFree(*((void **)this + 117));
    *((_QWORD *)this + 117) = 0i64;
    v6 = WPP_GLOBAL_Control;
  }
  if ( a3 < 3 )
  {
    if ( v6 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v6 + 28) & 5) == 0 )
      return 2148074278i64;
    v7 = 17;
LABEL_129:
    LODWORD(lpWideCharStr) = -2146893018;
    WPP_SF_DD(
      *((_QWORD *)v6 + 2),
      v7,
      (__int64)&WPP_2a9f95ae24df3f59458f3cae84384e77_Traceguids,
      -2146893018,
      lpWideCharStr);
    return 2148074278i64;
  }
  v8 = a2[2] + (*a2 << 16) + (a2[1] << 8);
  v9 = a2 + 3;
  if ( v8 > a3 - 3 )
  {
    if ( v6 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v6 + 28) & 5) == 0 )
      return 2148074278i64;
    v7 = 18;
    goto LABEL_129;
  }
  if ( v8 )
  {
    while ( v8 >= 4 )
    {
      v10 = v8 - 4;
      v11 = v9[1] + (*v9 << 8);
      v12 = v9[2] << 8;
      v13 = v9[3];
      v14 = v9 + 4;
      v15 = v13 + v12;
      if ( v10 < v15 )
      {
        if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 5) != 0 )
        {
          v7 = 21;
          goto LABEL_129;
        }
        return 2148074278i64;
      }
      v16 = v14;
      v9 = &v14[v15];
      v8 = v10 - v15;
      if ( !v11 )
      {
        if ( v15 < 2 )
        {
          if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control )
          {
            if ( (*((_BYTE *)v6 + 28) & 1) != 0 )
            {
              WPP_SF_d(*((_QWORD *)v6 + 2), 0x16u, (__int64)&WPP_2a9f95ae24df3f59458f3cae84384e77_Traceguids, v15);
              v6 = WPP_GLOBAL_Control;
            }
            if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 5) != 0 )
            {
              v7 = 23;
              goto LABEL_129;
            }
          }
        }
        else
        {
          v17 = *v16;
          v18 = v15 - 2;
          v19 = v16[1];
          v20 = v16 + 2;
          v21 = v19 + (v17 << 8);
          if ( v21 > v15 - 2 )
          {
            if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_BYTE *)v6 + 28) & 1) != 0 )
              {
                LODWORD(lpWideCharStr) = v15 - 2;
                WPP_SF_dd(
                  *((_QWORD *)v6 + 2),
                  0x18u,
                  (__int64)&WPP_2a9f95ae24df3f59458f3cae84384e77_Traceguids,
                  v21,
                  lpWideCharStr);
                v6 = WPP_GLOBAL_Control;
              }
              if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 5) != 0 )
              {
                v7 = 25;
                goto LABEL_129;
              }
            }
          }
          else
          {
            while ( v18 >= 3 )
            {
              v22 = v20[1];
              v23 = v18 - 3;
              v24 = v20[2];
              v25 = *v20;
              v26 = v20 + 3;
              v27 = v24 + (v22 << 8);
              if ( v27 > v23 )
              {
                if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 5) != 0 )
                {
                  v7 = 28;
                  goto LABEL_129;
                }
                return 2148074278i64;
              }
              if ( (_DWORD)v25 == 64 )
              {
                if ( v27 < 4 )
                {
                  if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 5) != 0 )
                  {
                    v7 = 30;
                    goto LABEL_129;
                  }
                }
                else
                {
                  v28 = *v26;
                  v29 = v27 - 2;
                  v30 = v26[1];
                  v31 = (const CHAR *)(v26 + 2);
                  v32 = v30 + (v28 << 8);
                  if ( v32 > v29 )
                  {
                    if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 5) != 0 )
                    {
                      v7 = 31;
                      goto LABEL_129;
                    }
                  }
                  else
                  {
                    if ( !v32 )
                      goto LABEL_42;
                    v33 = MultiByteToWideChar(0xFDE9u, 0, v31, v32, 0i64, 0);
                    cchWideChar = v33;
                    if ( !v33 )
                    {
                      v43 = WPP_GLOBAL_Control;
                      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
                      {
                        v44 = 32;
                        goto LABEL_80;
                      }
                      return 2148074244i64;
                    }
                    if ( v33 == v32 )
                    {
                      v35 = (void *)*((_QWORD *)this + 116);
                      if ( v35 )
                      {
                        SPExternalFree(v35);
                        *((_QWORD *)this + 116) = 0i64;
                      }
                      v36 = (WCHAR *)SPExternalAlloc(2 * (int)cchWideChar + 2);
                      *((_QWORD *)this + 116) = v36;
                      if ( !v36 )
                      {
                        v43 = WPP_GLOBAL_Control;
                        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                          && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
                        {
                          v44 = 34;
                          goto LABEL_80;
                        }
                        return 2148074244i64;
                      }
                      if ( !MultiByteToWideChar(0xFDE9u, 0, v31, cchWideChar, v36, cchWideChar) )
                      {
                        v43 = WPP_GLOBAL_Control;
                        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                          && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
                        {
                          v44 = 35;
                          goto LABEL_80;
                        }
                        return 2148074244i64;
                      }
                      v31 += cchWideChar;
                      v29 -= cchWideChar;
                      *(_WORD *)(*((_QWORD *)this + 116) + 2 * cchWideChar) = 0;
                      v6 = WPP_GLOBAL_Control;
LABEL_42:
                      if ( v29 < 2 )
                      {
                        if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 5) != 0 )
                        {
                          v7 = 36;
                          goto LABEL_129;
                        }
                      }
                      else
                      {
                        v37 = *((unsigned __int8 *)v31 + 1) + (*(unsigned __int8 *)v31 << 8);
                        if ( v37 > v29 - 2 )
                        {
                          if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 5) != 0 )
                          {
                            v7 = 37;
                            goto LABEL_129;
                          }
                        }
                        else
                        {
                          if ( !v37 )
                            goto LABEL_52;
                          v38 = MultiByteToWideChar(0xFDE9u, 0, v31 + 2, v37, 0i64, 0);
                          v39 = v38;
                          if ( !v38 )
                          {
                            v43 = WPP_GLOBAL_Control;
                            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
                              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
                            {
                              return 2148074244i64;
                            }
                            v44 = 38;
                            goto LABEL_80;
                          }
                          if ( v38 == v37 )
                          {
                            v40 = (void *)*((_QWORD *)this + 117);
                            if ( v40 )
                            {
                              SPExternalFree(v40);
                              *((_QWORD *)this + 117) = 0i64;
                            }
                            v41 = (WCHAR *)SPExternalAlloc(2 * (int)v39 + 2);
                            *((_QWORD *)this + 117) = v41;
                            if ( v41 )
                            {
                              if ( MultiByteToWideChar(0xFDE9u, 0, v31 + 2, v39, v41, v39) )
                              {
                                *(_WORD *)(*((_QWORD *)this + 117) + 2 * v39) = 0;
                                v6 = WPP_GLOBAL_Control;
                                goto LABEL_52;
                              }
                              v43 = WPP_GLOBAL_Control;
                              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
                              {
                                v44 = 41;
                                goto LABEL_80;
                              }
                              return 2148074244i64;
                            }
                            v43 = WPP_GLOBAL_Control;
                            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
                              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
                            {
                              return 2148074244i64;
                            }
                            v44 = 40;
LABEL_80:
                            LODWORD(lpWideCharStr) = -2146893052;
                            WPP_SF_DD(
                              *((_QWORD *)v43 + 2),
                              v44,
                              (__int64)&WPP_2a9f95ae24df3f59458f3cae84384e77_Traceguids,
                              -2146893052,
                              lpWideCharStr);
                            return 2148074244i64;
                          }
                          v6 = WPP_GLOBAL_Control;
                          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
                          {
                            v7 = 39;
                            goto LABEL_129;
                          }
                        }
                      }
                    }
                    else
                    {
                      v6 = WPP_GLOBAL_Control;
                      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
                      {
                        v7 = 33;
                        goto LABEL_129;
                      }
                    }
                  }
                }
                return 2148074278i64;
              }
              if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 4) != 0 )
              {
                WPP_SF_D(*((_QWORD *)v6 + 2), 29i64, &WPP_2a9f95ae24df3f59458f3cae84384e77_Traceguids, v25);
                v6 = WPP_GLOBAL_Control;
              }
              v20 = &v26[v27];
              v18 = v23 - v27;
              if ( !v18 )
                goto LABEL_52;
            }
            if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_BYTE *)v6 + 28) & 1) != 0 )
              {
                WPP_SF_(*((_QWORD *)v6 + 2), 26i64, &WPP_2a9f95ae24df3f59458f3cae84384e77_Traceguids);
                v6 = WPP_GLOBAL_Control;
              }
              if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 5) != 0 )
              {
                v7 = 27;
                goto LABEL_129;
              }
            }
          }
        }
        return 2148074278i64;
      }
LABEL_52:
      if ( !v8 )
      {
        if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 4) != 0 )
        {
          v42 = 42;
          goto LABEL_124;
        }
        return 0i64;
      }
    }
    if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 5) != 0 )
    {
      v7 = 20;
      goto LABEL_129;
    }
    return 2148074278i64;
  }
  if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 4) != 0 )
  {
    v42 = 19;
LABEL_124:
    LODWORD(lpWideCharStr) = 0;
    WPP_SF_DD(*((_QWORD *)v6 + 2), v42, (__int64)&WPP_2a9f95ae24df3f59458f3cae84384e77_Traceguids, 0, lpWideCharStr);
  }
  return 0i64;
}
// 18007686C: variable 'lpWideCharStr' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180076A84) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::PskGenerateClientExchangeValue(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int8 *a4,
        unsigned int *a5)
{
  __int64 result; // rax

  result = CSsl3TlsContext::SetPSKExchangeValue(this, a2, a3, 1);
  if ( !(_DWORD)result )
    return PskGenerateExchangeValue(this, 1, a4, a5);
  return result;
}

//----- (0000000180076AC8) ----------------------------------------------------
__int64 __fastcall PskGenerateExchangeValue(struct CSsl3TlsContext *a1, int a2, unsigned __int8 *a3, unsigned int *a4)
{
  unsigned int v4; // edi
  unsigned __int8 *v6; // r14
  int v7; // esi
  unsigned __int16 *v9; // rdx
  unsigned int v10; // eax
  int v11; // ebx

  v4 = 0;
  v6 = a3;
  v7 = (int)a3;
  LOWORD(a3) = 0;
  if ( *(_DWORD *)(*((_QWORD *)a1 + 1) + 48i64) == 4 )
  {
    v9 = (unsigned __int16 *)*((_QWORD *)a1 + 107);
    if ( v9 )
    {
      LODWORD(a3) = *v9;
      v10 = (_DWORD)a3 + 2;
    }
    else
    {
      v10 = 0;
      if ( a2 )
        v10 = 2;
    }
    if ( v6 )
    {
      if ( *a4 >= v10 )
      {
        if ( v10 )
        {
          v6[1] = (unsigned __int8)a3;
          v7 = (_DWORD)v6 + 2;
          *v6 = BYTE1(a3);
          if ( (_WORD)a3 )
          {
            v11 = (unsigned __int16)a3;
            memcpy_0(v6 + 2, v9 + 1, (unsigned __int16)a3);
            v7 += v11;
          }
        }
        *a4 = v7 - (_DWORD)v6;
      }
      else
      {
        *a4 = v10;
        return (unsigned int)-2146893023;
      }
    }
    else
    {
      *a4 = v10;
    }
  }
  else
  {
    return 1359;
  }
  return v4;
}

//----- (0000000180076BA0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetPSKExchangeValue(
        CSsl3TlsContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        int a4)
{
  unsigned int v4; // ebx
  unsigned __int8 *v6; // r14
  unsigned __int16 v7; // di
  unsigned __int16 *v8; // rax

  v4 = 0;
  if ( !a4 && a3 < 2 || a3 == 1 )
    goto LABEL_4;
  if ( a3 < 2 )
    return v4;
  v6 = a2 + 2;
  v7 = _byteswap_ushort(*(_WORD *)a2);
  if ( v7 == a3 - 2 )
  {
    if ( v7 )
    {
      if ( *((_QWORD *)this + 108) )
        (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
      v8 = (unsigned __int16 *)(*(__int64 (__fastcall **)(CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 8i64))(
                                 this,
                                 (unsigned int)v7 + 2);
      *((_QWORD *)this + 108) = v8;
      if ( v8 )
      {
        *v8 = v7;
        memcpy_0((void *)(*((_QWORD *)this + 108) + 2i64), v6, v7);
      }
      else
      {
        return 14;
      }
    }
  }
  else
  {
LABEL_4:
    v4 = -2146893048;
    CSslContext::SetErrorAndFatalAlert((__int64)this, 827, -2146893048, 0x32u);
  }
  return v4;
}

//----- (0000000180076CA8) ----------------------------------------------------
__int64 __fastcall Ssl2UnpackClientHello(struct SPBuffer *a1, struct _Ssl2_Client_Hello **a2, __int64 a3, int *a4)
{
  unsigned __int8 *v4; // rdi
  unsigned __int64 v5; // r8
  unsigned int v10; // edx
  unsigned int v11; // r14d
  __int64 v12; // r15
  __int64 v13; // r13
  unsigned __int64 v14; // r9
  unsigned __int64 v15; // rsi
  _DWORD *v16; // rbx
  int v17; // ecx
  int v18; // eax
  unsigned __int8 *v19; // rdi
  int *v20; // rdx
  __int64 v21; // r8
  int v22; // eax
  int v23; // ecx
  int v24; // ecx
  unsigned __int8 *v25; // rdi

  v4 = (unsigned __int8 *)*((_QWORD *)a1 + 1);
  LODWORD(v5) = 0;
  if ( *((_DWORD *)a1 + 1) < 2u )
  {
    *((_DWORD *)a1 + 1) = 2;
    return 2148074264i64;
  }
  v10 = ((((char)*v4 >> 31) & 0x4000) + 0x3FFF) & (v4[1] | (*v4 << 8));
  v11 = v10 + 2;
  if ( v10 + 2 > *((_DWORD *)a1 + 1) )
  {
    *((_DWORD *)a1 + 1) = v11;
    return 2148074264i64;
  }
  if ( v10 >= 0xB && v4[2] == 1 && (v4[4] | (v4[3] << 8)) >= 2u )
  {
    *a2 = 0i64;
    v12 = v4[8] | (v4[7] << 8);
    v13 = v4[10] | (v4[9] << 8);
    v14 = v4[6] | ((unsigned __int64)v4[5] << 8);
    if ( v12 + v13 + v14 + 9 <= v10 )
    {
      v15 = v14 / 3;
      if ( (unsigned int)(v14 / 3) > 0x44 )
      {
        v5 = 4i64 * (unsigned int)(v15 - 68);
        if ( v5 > 0xFFFFFFFF )
          return 534i64;
      }
      v16 = SPExternalAlloc((int)v5 + 352);
      if ( !v16 )
        return 2148074244i64;
      v17 = v4[3];
      v18 = v4[4];
      v19 = v4 + 11;
      v16[1] = v15;
      *v16 = v18 | (v17 << 8);
      if ( (_DWORD)v15 )
      {
        v20 = v16 + 20;
        v21 = (unsigned int)v15;
        do
        {
          v22 = v19[2];
          v23 = (v19[1] | (*v19 << 8)) << 8;
          v19 += 3;
          v24 = v22 | v23;
          *v20 = v24;
          if ( v24 == 255 && a4 )
            *a4 = 1;
          ++v20;
          --v21;
        }
        while ( v21 );
      }
      if ( (unsigned int)v12 <= 0x10 )
      {
        memcpy_0(v16 + 4, v19, (unsigned int)v12);
        v16[2] = v12;
        v25 = &v19[(unsigned int)v12];
        if ( (unsigned int)(v13 - 1) <= 0x1F )
        {
          memcpy_0(v16 + 12, v25, (unsigned int)v13);
          v16[3] = v13;
          *((_DWORD *)a1 + 1) = v11;
          *a2 = (struct _Ssl2_Client_Hello *)v16;
          return 0i64;
        }
      }
      SPExternalFree(v16);
    }
  }
  return 2148074278i64;
}

//----- (0000000180076EBC) ----------------------------------------------------
__int64 __fastcall CTls13Record::EncryptRecord(CTls13Record *this)
{
  __int64 v2; // rcx
  unsigned __int64 v3; // rax
  _BYTE *v4; // r8
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r10
  unsigned __int16 v9; // di
  unsigned __int16 v10; // si
  unsigned __int16 v11; // bp
  __int64 v12; // rax
  _QWORD *v13; // rcx
  unsigned int v14; // eax
  __int64 v15; // rcx
  unsigned __int16 v16; // dx
  unsigned int v17; // [rsp+80h] [rbp+8h] BYREF
  __int64 v18; // [rsp+88h] [rbp+10h] BYREF
  __int64 v19; // [rsp+90h] [rbp+18h] BYREF

  if ( !*((_BYTE *)this + 88) )
    return 87i64;
  v2 = *((_QWORD *)this + 6);
  if ( !v2 )
    return 87i64;
  if ( !*(_QWORD *)(v2 + 8) )
    return 87i64;
  v3 = *((_QWORD *)this + 7);
  if ( !v3 )
    return 87i64;
  v4 = (_BYTE *)*((_QWORD *)this + 8);
  if ( (unsigned __int64)v4 < v3
    || *((unsigned __int16 *)this + 45) + 5i64 < (__int64)&v4[-v3]
    || (__int64)&v4[-v3] <= 5
    || (unsigned int)(*(_DWORD *)(v2 + 4) + 16) > *(_DWORD *)v2 )
  {
    return 87i64;
  }
  *v4 = *((_BYTE *)this + 84);
  v5 = *((_QWORD *)this + 6);
  ++*((_QWORD *)this + 8);
  ++*(_DWORD *)(v5 + 4);
  v6 = *((_QWORD *)this + 1);
  v19 = 0i64;
  v18 = 0i64;
  (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v6 + 40i64))(v6, &v19, &v18);
  v7 = v18;
  if ( !v18 )
    return 1359i64;
  v9 = *((_WORD *)this + 32) - *((_WORD *)this + 28);
  v10 = v9 - 5;
  v17 = 0;
  v11 = v9 + 16;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_Di(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xAu,
      (__int64)&WPP_d7eb59dbd27e3a6dc714b07612d3a39e_Traceguids,
      v10,
      *(_QWORD *)(*((_QWORD *)this + 1) + 184i64));
    v7 = v18;
  }
  v12 = *((_QWORD *)this + 1);
  v13 = *(_QWORD **)(v12 + 8);
  if ( v13 )
    v13 = (_QWORD *)*v13;
  v14 = SslEncryptPacket(
          v13,
          v7,
          *((_QWORD *)this + 7) + 5i64,
          v10,
          *((_QWORD *)this + 7),
          v11,
          &v17,
          *(_QWORD *)(v12 + 184),
          23,
          0);
  if ( v14 || v17 > v11 || v17 < v9 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_d7eb59dbd27e3a6dc714b07612d3a39e_Traceguids, v14);
    return 2148074281i64;
  }
  else
  {
    v15 = *((_QWORD *)this + 6);
    v16 = v17 - v9;
    *((_QWORD *)this + 8) += (unsigned __int16)(v17 - v9);
    *((_QWORD *)this + 7) = *((_QWORD *)this + 8);
    *(_DWORD *)(v15 + 4) += v16;
    ++*(_QWORD *)(*((_QWORD *)this + 1) + 184i64);
    return 0i64;
  }
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180098508: using guessed type __int64 __fastcall SslEncryptPacket(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (00000001800770E0) ----------------------------------------------------
__int64 __fastcall CTls13Record::EndOfMessage(CTls13Record *this)
{
  __int64 v2; // r8
  unsigned __int64 v3; // rdx
  unsigned __int64 v4; // r9
  __int64 v5; // rax
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 result; // rax

  if ( !*((_WORD *)this + 8) )
    return 87i64;
  v2 = *((_QWORD *)this + 3);
  if ( !v2 )
    return 87i64;
  v3 = *((_QWORD *)this + 4);
  if ( !v3 )
    return 87i64;
  v4 = v2 + 12i64 * *((unsigned __int16 *)this + 8);
  if ( v3 >= v4 )
    return 87i64;
  v5 = *((_QWORD *)this + 6);
  if ( !v5 )
    return 87i64;
  if ( !*(_QWORD *)(v5 + 8) )
    return 87i64;
  v6 = *((_QWORD *)this + 7);
  if ( !v6 )
    return 87i64;
  v7 = *((_QWORD *)this + 8);
  if ( v7 < v6 )
    return 87i64;
  v8 = v7 - v6;
  if ( *((unsigned __int16 *)this + 45) + 5i64 < v8 || v8 <= 5 || !*((_DWORD *)this + 18) )
    return 87i64;
  if ( v3 >= v4 - 12 )
  {
    result = CTls13Record::FinalizeRecord(this);
    if ( (_DWORD)result )
      return result;
    *((_WORD *)this + 45) = *((_WORD *)this + 40);
    *((_WORD *)this + 8) = 0;
    *((_QWORD *)this + 3) = 0i64;
    *((_QWORD *)this + 4) = 0i64;
    *((_DWORD *)this + 10) = 0;
    *((_QWORD *)this + 6) = 0i64;
    *((_QWORD *)this + 7) = 0i64;
    *((_QWORD *)this + 8) = 0i64;
    *((_DWORD *)this + 21) = 20;
    *((_BYTE *)this + 88) = 0;
    goto LABEL_18;
  }
  if ( (*(_BYTE *)(v3 + 8) & 1) == 0
    || (result = (*(__int64 (__fastcall **)(CTls13Record *))(*(_QWORD *)this + 48i64))(this), !(_DWORD)result) )
  {
    *((_QWORD *)this + 4) += 12i64;
LABEL_18:
    *((_DWORD *)this + 18) = 0;
    return 0i64;
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180077204) ----------------------------------------------------
__int64 __fastcall CTls13Record::FinalizeRecord(CTls13Record *this)
{
  __int64 v2; // r8
  unsigned __int64 v3; // rdx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 result; // rax
  _BYTE *v8; // rdx
  char v9; // cl
  __int16 v10; // cx

  if ( !*((_WORD *)this + 8) )
    return 87i64;
  v2 = *((_QWORD *)this + 3);
  if ( !v2 )
    return 87i64;
  v3 = *((_QWORD *)this + 4);
  if ( !v3 )
    return 87i64;
  if ( v3 >= v2 + 12 * (unsigned __int64)*((unsigned __int16 *)this + 8) )
    return 87i64;
  v4 = *((_QWORD *)this + 7);
  if ( !v4 )
    return 87i64;
  v5 = *((_QWORD *)this + 8);
  if ( v5 < v4 )
    return 87i64;
  v6 = v5 - v4;
  if ( *((unsigned __int16 *)this + 45) + 5i64 < v6 || v6 <= 5 )
    return 87i64;
  if ( !*((_DWORD *)this + 18)
    || (*(_BYTE *)(v3 + 8) & 1) == 0
    || (result = (*(__int64 (__fastcall **)(CTls13Record *))(*(_QWORD *)this + 48i64))(this), !(_DWORD)result) )
  {
    if ( *((_BYTE *)this + 88) )
    {
      return CTls13Record::EncryptRecord(this);
    }
    else
    {
      v8 = (_BYTE *)*((_QWORD *)this + 7);
      *v8 = *((_BYTE *)this + 84);
      v9 = 1;
      v8[1] = 3;
      if ( *(_DWORD *)(*((_QWORD *)this + 1) + 68i64) != 40 )
        v9 = 3;
      v8[2] = v9;
      v10 = *((_WORD *)this + 32) - *((_WORD *)this + 28) - 5;
      v8[4] = v10;
      v8[3] = HIBYTE(v10);
      *((_QWORD *)this + 7) = *((_QWORD *)this + 8);
      return 0i64;
    }
  }
  return result;
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180077330) ----------------------------------------------------
__int64 __fastcall CTls13Record::HashFragment(CTls13Record *this)
{
  __int64 v2; // r9
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // r11
  __int64 v6; // rcx
  __int64 v7; // r9
  __int64 v8; // r8
  unsigned __int64 v9; // r11

  if ( !*((_WORD *)this + 8) )
    return 87i64;
  v2 = *((_QWORD *)this + 3);
  if ( !v2 )
    return 87i64;
  v3 = *((_QWORD *)this + 4);
  if ( !v3 )
    return 87i64;
  if ( v3 >= v2 + 12 * (unsigned __int64)*((unsigned __int16 *)this + 8) )
    return 87i64;
  if ( (*(_BYTE *)(v3 + 8) & 1) == 0 )
    return 87i64;
  v4 = *((_QWORD *)this + 7);
  if ( !v4 )
    return 87i64;
  v5 = *((_QWORD *)this + 8);
  if ( v5 < v4 )
    return 87i64;
  v6 = v5 - v4;
  if ( *((unsigned __int16 *)this + 45) + 5i64 < (__int64)(v5 - v4) || v6 <= 5 || !*((_DWORD *)this + 18) )
    return 87i64;
  if ( v6 - 5 >= *((unsigned int *)this + 18) )
  {
    v7 = *((unsigned __int16 *)this + 36);
  }
  else
  {
    v7 = (unsigned __int16)v5;
    LOWORD(v7) = v5 - *((_WORD *)this + 28) - 5;
  }
  v8 = (unsigned __int16)v7;
  v9 = v5 - (unsigned __int16)v7;
  LOBYTE(v7) = 1;
  return (*(__int64 (__fastcall **)(_QWORD, unsigned __int64, __int64, __int64))(**((_QWORD **)this + 1) + 504i64))(
           *((_QWORD *)this + 1),
           v9,
           v8,
           v7);
}

//----- (0000000180077414) ----------------------------------------------------
__int64 __fastcall CTls13Record::InitializeRecord(CTls13Record *this)
{
  __int64 v2; // rcx
  unsigned __int64 v3; // rdx
  __int64 v4; // rcx
  int v5; // edx
  __int16 v6; // ax

  if ( !*((_QWORD *)this + 4) )
    return 87i64;
  if ( *((_QWORD *)this + 4) >= *((_QWORD *)this + 3) + 12 * (unsigned __int64)*((unsigned __int16 *)this + 8) )
    return 87i64;
  v2 = *((_QWORD *)this + 6);
  if ( !v2 )
    return 87i64;
  if ( !*(_QWORD *)(v2 + 8) )
    return 87i64;
  v3 = *((_QWORD *)this + 7);
  if ( !v3 || *((_QWORD *)this + 8) < v3 || (unsigned int)(*(_DWORD *)(v2 + 4) + 5) >= *(_DWORD *)v2 )
    return 87i64;
  *((_QWORD *)this + 8) = v3 + 5;
  *(_DWORD *)(v2 + 4) += 5;
  v4 = *((_QWORD *)this + 4);
  *((_DWORD *)this + 21) = *(_DWORD *)(v4 + 4);
  v5 = *(_DWORD *)(v4 + 8) & 2;
  *((_BYTE *)this + 88) = v5 != 0;
  v6 = *((_WORD *)this + 40) - 1;
  if ( !v5 )
    v6 = *((_WORD *)this + 40);
  *((_WORD *)this + 45) = v6;
  return 0i64;
}

//----- (00000001800774B0) ----------------------------------------------------
__int64 __fastcall CTls13Record::SetFlightInfo(
        CTls13Record *this,
        unsigned __int16 a2,
        struct CTlsRecord::CMessageInfo *a3,
        unsigned int *a4)
{
  unsigned int v6; // esi
  int v7; // ebp
  unsigned __int16 v8; // di
  bool v9; // r14
  unsigned __int16 v10; // r9
  unsigned __int16 v11; // bx
  struct CTlsRecord::CMessageInfo *v12; // r12
  unsigned __int16 v13; // dx
  int v14; // ebp
  int v15; // eax
  bool v16; // cf
  unsigned __int16 v17; // dx
  unsigned int v18; // eax
  int v19; // ecx
  int v21; // [rsp+0h] [rbp-38h]
  struct CTlsRecord::CMessageInfo *v22; // [rsp+8h] [rbp-30h]

  if ( *((_QWORD *)this + 6) || !a2 || !a3 || !a4 )
    return 87i64;
  v6 = 0;
  v7 = *((_DWORD *)a3 + 1);
  v8 = *((_WORD *)this + 40);
  v21 = v7;
  if ( (*((_BYTE *)a3 + 8) & 2) != 0 )
  {
    v9 = 1;
    v10 = v8 - 1;
  }
  else
  {
    v9 = 0;
    v10 = *((_WORD *)this + 40);
  }
  v11 = v10;
  v12 = a3;
  v22 = (struct CTlsRecord::CMessageInfo *)((char *)a3 + 12 * a2);
  if ( a3 < v22 )
  {
    while ( 1 )
    {
      v13 = *(_WORD *)v12;
      if ( *(_WORD *)v12 )
      {
        if ( *((_DWORD *)v12 + 1) == 21 && v13 > v8 )
          return 87i64;
        if ( *((_DWORD *)v12 + 1) == v7
          && (*((_DWORD *)v12 + 1) != 21 || v11 >= v13)
          && ((*((_DWORD *)v12 + 2) & 2) != 0) == v9 )
        {
          v14 = v8;
        }
        else
        {
          v15 = v11;
          v16 = v9;
          v9 = (*((_DWORD *)v12 + 2) & 2) != 0;
          v11 = v8 - 1;
          v14 = v8;
          v21 = *((_DWORD *)v12 + 1);
          v6 += v8 + (v16 ? 21 : 5) - v15;
          if ( (*((_DWORD *)v12 + 2) & 2) == 0 )
            v11 = v8;
          v10 = v11;
        }
        if ( v13 >= v11 )
        {
          v17 = v13 - v11;
          v11 = 0;
          v18 = v17;
          v13 = v17 % v10;
          v19 = v14 + (v9 ? 21 : 5);
          v6 += v19 * (unsigned __int16)(v18 / v10);
          if ( !v13 )
            goto LABEL_30;
          v10 = v8 - 1;
          v9 = (*((_DWORD *)v12 + 2) & 2) != 0;
          v6 += v19;
          v21 = *((_DWORD *)v12 + 1);
          if ( (*((_DWORD *)v12 + 2) & 2) == 0 )
            v10 = v8;
          v11 = v10;
        }
        v11 -= v13;
      }
      else
      {
        if ( *((_DWORD *)v12 + 1) != 23 )
          return 87i64;
        v14 = v8;
      }
LABEL_30:
      v12 = (struct CTlsRecord::CMessageInfo *)((char *)v12 + 12);
      if ( v12 >= v22 )
      {
        if ( v11 < v10 )
          v6 += v14 + (v9 ? 21 : 5) - v11;
        break;
      }
      v7 = v21;
    }
  }
  *((_WORD *)this + 8) = a2;
  *((_QWORD *)this + 3) = a3;
  *((_QWORD *)this + 4) = a3;
  *((_DWORD *)this + 10) = v6;
  *a4 = v6;
  return 0i64;
}

//----- (00000001800776B0) ----------------------------------------------------
__int64 __fastcall CTls13Record::SetOutputBuffer(CTls13Record *this, struct SPBuffer *a2)
{
  _WORD *v2; // r9
  __int64 v3; // rax
  __int64 v4; // rax
  _WORD *v5; // rax

  if ( !*((_WORD *)this + 8) )
    return 87i64;
  v2 = (_WORD *)*((_QWORD *)this + 3);
  if ( !v2
    || *((_QWORD *)this + 6)
    || !a2
    || *(_DWORD *)a2 < *((_DWORD *)this + 10)
    || *((_DWORD *)a2 + 1)
    || !*((_QWORD *)a2 + 1) )
  {
    return 87i64;
  }
  *((_QWORD *)this + 6) = a2;
  v3 = *((_QWORD *)a2 + 1);
  *((_QWORD *)this + 7) = v3;
  *((_QWORD *)this + 8) = v3;
  v4 = *((unsigned __int16 *)this + 8);
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 4) = v2;
  v5 = &v2[6 * v4];
  while ( v2 < v5 && !*v2 )
  {
    v2 += 6;
    *((_QWORD *)this + 4) = v2;
  }
  return CTls13Record::InitializeRecord(this);
}

//----- (0000000180077740) ----------------------------------------------------
__int64 __fastcall CTls13Record::WritePlaintext(CTls13Record *this, unsigned __int16 a2, const unsigned __int8 *a3)
{
  int v3; // edi
  __int64 v6; // rdx
  unsigned __int16 *v7; // r8
  __int64 v8; // rdx
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rcx
  __int64 v11; // rsi
  __int64 v12; // rcx
  __int64 result; // rax
  unsigned __int16 v14; // si
  int v15; // ecx
  const unsigned __int8 *v16; // r8
  CTls13Record *v17; // rcx

  v3 = a2;
  if ( !*((_WORD *)this + 8) )
    return 87i64;
  v6 = *((_QWORD *)this + 3);
  if ( !v6 )
    return 87i64;
  v7 = (unsigned __int16 *)*((_QWORD *)this + 4);
  if ( !v7 )
    return 87i64;
  if ( (unsigned __int64)v7 >= v6 + 12 * (unsigned __int64)*((unsigned __int16 *)this + 8) )
    return 87i64;
  v8 = *((_QWORD *)this + 6);
  if ( !v8 )
    return 87i64;
  if ( !*(_QWORD *)(v8 + 8) )
    return 87i64;
  v9 = *((_QWORD *)this + 7);
  if ( !v9 )
    return 87i64;
  v10 = *((_QWORD *)this + 8);
  if ( v10 < v9 )
    return 87i64;
  v11 = *((unsigned __int16 *)this + 45);
  v12 = v10 - v9;
  if ( v11 + 5 < v12 || v12 < 5 )
    return 87i64;
  if ( (_WORD)v3 )
  {
    if ( !a3 )
      return 87i64;
  }
  else if ( a3 )
  {
    return 87i64;
  }
  if ( v3 + *((_DWORD *)this + 18) > (unsigned int)*v7 || (unsigned int)(v3 + *(_DWORD *)(v8 + 4)) > *(_DWORD *)v8 )
    return 87i64;
  if ( !(_WORD)v3 )
    return 0i64;
  v14 = *((_WORD *)this + 28) + v11 - *((_WORD *)this + 32) + 5;
  v15 = *((_DWORD *)v7 + 1);
  if ( v15 != *((_DWORD *)this + 21)
    || v15 == 21 && v14 < (unsigned __int16)v3
    || ((*((_DWORD *)v7 + 2) & 2) != 0) != *((_BYTE *)this + 88) )
  {
    result = CTls13Record::FinalizeRecord(this);
    if ( (_DWORD)result )
      return result;
    result = CTls13Record::InitializeRecord(this);
    if ( (_DWORD)result )
      return result;
    v14 = *((_WORD *)this + 45);
  }
  v16 = a3;
  v17 = this;
  if ( (unsigned __int16)v3 < v14 )
    return CTls13Record::WriteRecord(this, v3, a3);
  while ( 1 )
  {
    result = CTls13Record::WriteRecord(v17, v14, v16);
    if ( (_DWORD)result )
      break;
    a3 += v14;
    LOWORD(v3) = v3 - v14;
    if ( !(_WORD)v3 )
      return 0i64;
    result = CTls13Record::FinalizeRecord(this);
    if ( (_DWORD)result )
      break;
    result = CTls13Record::InitializeRecord(this);
    if ( (_DWORD)result )
      break;
    v14 = *((_WORD *)this + 45);
    v16 = a3;
    v17 = this;
    if ( (unsigned __int16)v3 <= v14 )
      v14 = v3;
  }
  return result;
}

//----- (00000001800778D4) ----------------------------------------------------
__int64 __fastcall CTls13Record::WriteRecord(CTls13Record *this, unsigned __int16 a2, const unsigned __int8 *a3)
{
  __int64 v3; // r11
  __int64 v6; // r9
  unsigned __int16 *v7; // r10
  __int64 v8; // rdx
  unsigned __int64 v9; // rax
  __int64 v10; // rbp
  __int64 v11; // r8
  int v13; // edi
  __int64 v14; // rax

  v3 = a2;
  if ( !*((_WORD *)this + 8) )
    return 87i64;
  v6 = *((_QWORD *)this + 3);
  if ( !v6 )
    return 87i64;
  v7 = (unsigned __int16 *)*((_QWORD *)this + 4);
  if ( !v7 )
    return 87i64;
  if ( (unsigned __int64)v7 >= v6 + 12 * (unsigned __int64)*((unsigned __int16 *)this + 8) )
    return 87i64;
  v8 = *((_QWORD *)this + 6);
  if ( !v8 )
    return 87i64;
  if ( !*(_QWORD *)(v8 + 8) )
    return 87i64;
  v9 = *((_QWORD *)this + 7);
  if ( !v9 )
    return 87i64;
  if ( *((_QWORD *)this + 8) < v9 )
    return 87i64;
  v10 = (unsigned int)v3;
  v11 = *((_QWORD *)this + 8) - v9;
  if ( *((unsigned __int16 *)this + 45) + 5i64 < v11 + v3 || v11 < 5 )
    return 87i64;
  if ( (_WORD)v3 )
  {
    if ( !a3 )
      return 87i64;
  }
  else if ( a3 )
  {
    return 87i64;
  }
  v13 = v3;
  if ( (int)v3 + *((_DWORD *)this + 18) > (unsigned int)*v7 || (unsigned int)(v3 + *(_DWORD *)(v8 + 4)) > *(_DWORD *)v8 )
    return 87i64;
  if ( (_WORD)v3 )
  {
    memcpy_0(*((void **)this + 8), a3, (unsigned int)v3);
    v14 = *((_QWORD *)this + 6);
    *((_QWORD *)this + 8) += v10;
    *((_DWORD *)this + 18) += v13;
    *(_DWORD *)(v14 + 4) += v13;
  }
  return 0i64;
}

//----- (00000001800779E0) ----------------------------------------------------
__int64 __fastcall CNulRecord::EndOfMessage(CNulRecord *this)
{
  __int64 v2; // rdx
  unsigned __int64 v3; // r8
  __int64 v4; // rax
  unsigned __int64 v5; // rax
  __int64 result; // rax
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rax

  if ( !*((_WORD *)this + 8) )
    return 87i64;
  v2 = *((_QWORD *)this + 3);
  if ( !v2 )
    return 87i64;
  v3 = *((_QWORD *)this + 4);
  if ( !v3 )
    return 87i64;
  if ( v3 >= v2 + 12 * (unsigned __int64)*((unsigned __int16 *)this + 8) )
    return 87i64;
  v4 = *((_QWORD *)this + 6);
  if ( !v4 )
    return 87i64;
  if ( !*(_QWORD *)(v4 + 8) )
    return 87i64;
  v5 = *((_QWORD *)this + 7);
  if ( !v5 || *((_QWORD *)this + 8) < v5 || !*((_DWORD *)this + 18) )
    return 87i64;
  if ( (*(_BYTE *)(v3 + 8) & 1) == 0
    || (result = (*(__int64 (__fastcall **)(CNulRecord *))(*(_QWORD *)this + 48i64))(this), !(_DWORD)result) )
  {
    v7 = *((_QWORD *)this + 4);
    if ( v7 < *((_QWORD *)this + 3) + 4 * (3 * (unsigned __int64)*((unsigned __int16 *)this + 8) - 3) )
    {
      v8 = v7 + 12;
    }
    else
    {
      *((_WORD *)this + 8) = 0;
      v8 = 0i64;
      *((_QWORD *)this + 3) = 0i64;
      *((_DWORD *)this + 10) = 0;
      *((_QWORD *)this + 6) = 0i64;
      *((_QWORD *)this + 7) = 0i64;
      *((_QWORD *)this + 8) = 0i64;
    }
    *((_QWORD *)this + 4) = v8;
    result = 0i64;
    *((_DWORD *)this + 18) = 0;
  }
  return result;
}

//----- (0000000180077AE0) ----------------------------------------------------
__int64 __fastcall CNulRecord::HashFragment(CNulRecord *this)
{
  __int64 v1; // r9
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // r11
  __int64 v5; // r9
  __int64 v6; // r8
  unsigned __int64 v7; // r11

  if ( !*((_WORD *)this + 8) )
    return 87i64;
  v1 = *((_QWORD *)this + 3);
  if ( !v1 )
    return 87i64;
  v2 = *((_QWORD *)this + 4);
  if ( !v2 )
    return 87i64;
  if ( v2 >= v1 + 12 * (unsigned __int64)*((unsigned __int16 *)this + 8) )
    return 87i64;
  if ( (*(_BYTE *)(v2 + 8) & 1) == 0 )
    return 87i64;
  v3 = *((_QWORD *)this + 7);
  if ( !v3 )
    return 87i64;
  v4 = *((_QWORD *)this + 8);
  if ( v4 < v3 || !*((_DWORD *)this + 18) )
    return 87i64;
  if ( (__int64)(v4 - v3) >= *((unsigned int *)this + 18) )
  {
    v5 = *((unsigned __int16 *)this + 36);
  }
  else
  {
    v5 = (unsigned __int16)v4;
    LOWORD(v5) = v4 - *((_WORD *)this + 28);
  }
  v6 = (unsigned __int16)v5;
  v7 = v4 - (unsigned __int16)v5;
  LOBYTE(v5) = 1;
  return (*(__int64 (__fastcall **)(_QWORD, unsigned __int64, __int64, __int64))(**((_QWORD **)this + 1) + 504i64))(
           *((_QWORD *)this + 1),
           v7,
           v6,
           v5);
}

//----- (0000000180077BA0) ----------------------------------------------------
__int64 __fastcall CNulRecord::SetFlightInfo(
        CNulRecord *this,
        unsigned __int16 a2,
        struct CTlsRecord::CMessageInfo *a3,
        unsigned int *a4)
{
  unsigned int v4; // r10d
  __int64 v5; // rbx
  struct CTlsRecord::CMessageInfo *v7; // rdx
  struct CTlsRecord::CMessageInfo *v8; // rcx
  int v9; // eax
  __int64 result; // rax

  v4 = 0;
  v5 = a2;
  if ( *((_QWORD *)this + 6) || !a2 || !a3 || !a4 )
    return 87i64;
  v7 = a3;
  v8 = (struct CTlsRecord::CMessageInfo *)((char *)a3 + 12 * v5);
  if ( a3 < v8 )
  {
    do
    {
      v9 = *(unsigned __int16 *)v7;
      v7 = (struct CTlsRecord::CMessageInfo *)((char *)v7 + 12);
      v4 += v9;
    }
    while ( v7 < v8 );
  }
  *((_WORD *)this + 8) = v5;
  result = 0i64;
  *((_QWORD *)this + 3) = a3;
  *((_QWORD *)this + 4) = a3;
  *((_DWORD *)this + 10) = v4;
  *a4 = v4;
  return result;
}

//----- (0000000180077C10) ----------------------------------------------------
__int64 __fastcall CNulRecord::SetOutputBuffer(CNulRecord *this, struct SPBuffer *a2)
{
  _WORD *v2; // r8
  __int64 v3; // rax
  __int64 v4; // rax
  _WORD *v5; // rax

  if ( !*((_WORD *)this + 8) )
    return 87i64;
  v2 = (_WORD *)*((_QWORD *)this + 3);
  if ( !v2
    || *((_QWORD *)this + 6)
    || !a2
    || *(_DWORD *)a2 < *((_DWORD *)this + 10)
    || *((_DWORD *)a2 + 1)
    || !*((_QWORD *)a2 + 1) )
  {
    return 87i64;
  }
  *((_QWORD *)this + 6) = a2;
  v3 = *((_QWORD *)a2 + 1);
  *((_QWORD *)this + 7) = v3;
  *((_QWORD *)this + 8) = v3;
  v4 = *((unsigned __int16 *)this + 8);
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 4) = v2;
  v5 = &v2[6 * v4];
  while ( v2 < v5 && !*v2 )
  {
    v2 += 6;
    *((_QWORD *)this + 4) = v2;
  }
  return 0i64;
}

//----- (0000000180077C90) ----------------------------------------------------
__int64 __fastcall CNulRecord::WritePlaintext(void **this, unsigned __int16 a2, const unsigned __int8 *a3)
{
  __int64 v3; // rsi
  _DWORD *v6; // rax

  v3 = a2;
  if ( a2 )
  {
    if ( !a3 )
      return 87i64;
    memcpy_0(this[8], a3, a2);
    v6 = this[6];
    this[8] = (char *)this[8] + v3;
    *((_DWORD *)this + 18) += v3;
    v6[1] += v3;
  }
  return 0i64;
}

//----- (0000000180077CF0) ----------------------------------------------------
__int64 __fastcall CTls13ExtClient::ParseCertRequestSigAlgExtension(
        CTls13ExtClient *this,
        unsigned __int8 *a2,
        unsigned __int16 a3)
{
  unsigned int v4; // eax
  __int64 v5; // rcx
  unsigned int v6; // ebx
  unsigned __int8 v7; // r9
  int v8; // r8d
  unsigned int v10; // [rsp+20h] [rbp-58h] BYREF
  __int16 v11; // [rsp+28h] [rbp-50h] BYREF
  __int128 v12; // [rsp+2Ah] [rbp-4Eh]
  __int128 v13; // [rsp+3Ah] [rbp-3Eh]
  __int16 v14; // [rsp+4Ah] [rbp-2Eh]

  v11 = 0;
  v14 = 0;
  v10 = 0;
  v12 = 0i64;
  v13 = 0i64;
  v4 = CTlsSignatureSuiteList::ParseSupportedSignatureAlgorithmsAndSet((CTlsSignatureSuiteList *)&v11, a2, a3, &v10);
  v5 = *((_QWORD *)this + 1);
  v6 = v4;
  if ( v4 )
  {
    v7 = 47;
    v8 = v4;
LABEL_7:
    CSslContext::SetErrorAndFatalAlert(v5, 402, v8, v7);
    return v6;
  }
  if ( v5 != -474 )
  {
    CTlsSignatureSuiteList::SetSignatureSuiteList(
      (CTlsSignatureSuiteList *)(v5 + 510),
      (const struct CTlsSignatureSuiteList *)(v5 + 474));
    if ( CTlsSignatureSuiteList::Restrict(
           (CTlsSignatureSuiteList *)(*((_QWORD *)this + 1) + 510i64),
           (const struct CTlsSignatureSuiteList *)&v11,
           *(_DWORD *)(*((_QWORD *)this + 1) + 64i64)) )
    {
      return 0;
    }
    v5 = *((_QWORD *)this + 1);
    v6 = -2146893007;
    v8 = -2146893007;
    v7 = 40;
    goto LABEL_7;
  }
  return (unsigned int)-2146893052;
}

//----- (0000000180077DC4) ----------------------------------------------------
__int64 __fastcall CTls13ExtClient::ParseCookieExtension(
        CTls13ExtClient *this,
        unsigned __int8 *a2,
        unsigned __int16 a3)
{
  unsigned int v3; // r9d
  __int16 v4; // r8
  __int64 v5; // rcx

  v3 = 0;
  if ( !a2 )
    return 2148074248i64;
  if ( a3 < 2u )
    return 2148074248i64;
  if ( *(_DWORD *)(*((_QWORD *)this + 1) + 68i64) != 100 )
    return 2148074248i64;
  v4 = a3 - 2;
  if ( !v4 )
    return 2148074248i64;
  v5 = *((_QWORD *)this + 8);
  if ( *(_QWORD *)(v5 + 1744) || *(_WORD *)(v5 + 1752) )
  {
    return 315;
  }
  else
  {
    *(_WORD *)(v5 + 1752) = v4;
    *(_QWORD *)(v5 + 1744) = a2 + 2;
  }
  return v3;
}

//----- (0000000180077E40) ----------------------------------------------------
unsigned int __fastcall CTls13ExtClient::ParseExtension(__int64 a1, unsigned int a2, unsigned __int8 *a3, __int64 a4)
{
  unsigned __int16 v5; // di
  int v8; // eax
  __int16 v9; // dx
  int v10; // r8d
  unsigned int result; // eax

  v5 = a4;
  v8 = (unsigned __int8)*(_DWORD *)(a1 + 16) | (a2 << 8);
  switch ( v8 )
  {
    case 1291:
      return CTls13ExtClient::ParseStatusRequestExtension((CTls13ExtClient *)a1, a3, a4, a4);
    case 3341:
      return CTls13ExtClient::ParseCertRequestSigAlgExtension((CTls13ExtClient *)a1, a3, a4);
    case 10498:
      return CTls13ExtClient::ParsePreSharedKeyExtension((CTls13ExtClient *)a1, a3, a4, a4);
    case 11010:
      return CTls13ExtClient::ParseSupportedVersionsExtension((CTls13ExtClient *)a1, a3, a4);
    case 11266:
      return CTls13ExtClient::ParseCookieExtension((CTls13ExtClient *)a1, a3, a4);
    case 12045:
      return CSsl3TlsClientContext::ParseDistinguishedNameList(
               *(CSsl3TlsClientContext **)(a1 + 64),
               a3,
               (unsigned __int16)a4);
    case 13058:
      return CTls13ExtClient::ParseKeyShareExtension((CTls13ExtClient *)a1, a3, a4);
  }
  if ( !CTls13Context::IsValidGenericExtensionType(a2) )
    return CTlsExtClient::ParseExtension(a1, a2, a3, v5);
  result = CTls13Context::RetrieveGenericExtension(*(_QWORD *)(a1 + 64) + 1368i64, v9, v10, (__int64)a3, v5);
  if ( !result )
    return CTlsExtClient::ParseExtension(a1, a2, a3, v5);
  return result;
}
// 180077ECC: variable 'v9' is possibly undefined
// 180077ECC: variable 'v10' is possibly undefined

//----- (0000000180077F68) ----------------------------------------------------
__int64 __fastcall CTls13ExtClient::ParseKeyShareExtension(
        CTls13ExtClient *this,
        unsigned __int8 *a2,
        unsigned __int16 a3)
{
  unsigned __int16 v4; // dx
  __int64 v6; // rcx
  unsigned __int8 *v7; // r9
  unsigned __int16 v8; // r8
  __int16 v9; // r10
  __int16 v10; // r8
  __int16 v11; // ax
  unsigned __int8 *v12; // r9
  __int16 v13; // r10
  __int64 v14; // r10
  __int16 v15; // ax

  if ( a3 < 2u )
    goto LABEL_15;
  v4 = _byteswap_ushort(*(_WORD *)a2);
  if ( a3 != 2 )
  {
    v7 = a2 + 2;
    v8 = a3 - 2;
    if ( v8 >= 2u )
    {
      v9 = *v7;
      v10 = v8 - 2;
      v11 = v7[1];
      v12 = v7 + 2;
      v13 = v11 | (v9 << 8);
      if ( v13 )
      {
        if ( v13 == v10 )
        {
          v14 = *((_QWORD *)this + 8);
          v15 = *(_WORD *)(v14 + 1836);
          if ( !v15 )
          {
            v6 = *((_QWORD *)this + 1);
            if ( **(_WORD **)(v6 + 912) != v4 )
              goto LABEL_16;
LABEL_14:
            *(_WORD *)(v14 + 1838) = v4;
            *(_QWORD *)(v14 + 1840) = v12;
            *(_WORD *)(v14 + 1848) = v10;
            return 0i64;
          }
          if ( v15 == v4 )
            goto LABEL_14;
        }
      }
    }
LABEL_15:
    v6 = *((_QWORD *)this + 1);
    goto LABEL_16;
  }
  if ( *(_DWORD *)(*((_QWORD *)this + 1) + 68i64) == 100 )
  {
    *(_WORD *)(*((_QWORD *)this + 8) + 1836i64) = v4;
    return 0i64;
  }
  v6 = *((_QWORD *)this + 1);
LABEL_16:
  CSslContext::SetErrorAndFatalAlert(v6, 106, -2146893048, 0x32u);
  return 2148074248i64;
}

//----- (0000000180078054) ----------------------------------------------------
__int64 __fastcall CTls13ExtServer::ParseKeyShareExtension(
        CTls13ExtServer *this,
        unsigned __int8 *a2,
        unsigned __int16 a3)
{
  __int16 v3; // ax
  __int16 v4; // r9
  const unsigned __int8 *v5; // rdx
  unsigned __int16 v6; // r9
  unsigned __int16 v7; // r8

  if ( a2 && a3 >= 2u )
  {
    v3 = a2[1];
    v4 = *a2;
    v5 = a2 + 2;
    v6 = v3 | (v4 << 8);
    v7 = a3 - 2;
    if ( v6 )
    {
      if ( v6 >= 2u && v6 == v7 )
        return CTls13ServerContext::StoreClientShares(*((CTls13ServerContext **)this + 5), v5, v7);
    }
    else if ( *(_DWORD *)(*((_QWORD *)this + 1) + 68i64) != 71 )
    {
      return 0i64;
    }
  }
  CSslContext::SetErrorAndFatalAlert(*((_QWORD *)this + 1), 1202, -2146893048, 0x32u);
  return 2148074248i64;
}

//----- (00000001800780DC) ----------------------------------------------------
__int64 __fastcall CTls13ExtClient::ParsePreSharedKeyExtension(
        CTls13ExtClient *this,
        unsigned __int8 *a2,
        unsigned __int16 a3,
        __int64 a4)
{
  if ( !a2 || a3 < 2u )
    return 2148074248i64;
  if ( a2[1] | (*a2 << 8) )
  {
    LOBYTE(a4) = 47;
    CSslContext::SetErrorAndFatalAlert(*((_QWORD *)this + 1), 106i64, 2148074278i64, a4);
    return 2148074278i64;
  }
  else
  {
    *(_QWORD *)(*((_QWORD *)this + 8) + 136i64) &= ~0x8000ui64;
    return 0i64;
  }
}
// 18005B470: using guessed type __int64 __fastcall CSslContext::SetErrorAndFatalAlert(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180078140) ----------------------------------------------------
__int64 __fastcall CTls13ExtServer::ParsePreSharedKeyExtension(
        CTls13ExtServer *this,
        unsigned __int8 *a2,
        unsigned __int16 a3,
        __int64 a4)
{
  unsigned int v5; // ebx
  __int64 v6; // rcx
  __int16 v7; // di
  __int16 v8; // ax
  unsigned __int16 v9; // r8
  unsigned __int8 *v10; // rdx
  unsigned __int16 v11; // di
  unsigned __int8 *v12; // r14
  unsigned __int16 *v13; // rdx
  unsigned __int16 v14; // r8
  unsigned __int16 v15; // si
  unsigned __int16 v16; // r12
  unsigned __int8 *v17; // r15
  __int16 v18; // dx
  unsigned __int16 v19; // di
  __int16 v20; // ax
  unsigned __int8 *v21; // r14
  unsigned __int8 *v22; // r10
  unsigned __int16 v23; // dx
  unsigned __int16 v24; // di
  unsigned __int16 v25; // si
  __int64 v26; // rax
  unsigned __int8 *v27; // r15
  unsigned __int16 v28; // r13
  __int64 v29; // rcx
  unsigned __int8 *v30; // r11
  __int64 v31; // rax
  unsigned __int8 v32; // al
  _QWORD *v33; // rdi
  __int64 v34; // rax
  unsigned __int16 v36; // [rsp+78h] [rbp+10h]
  unsigned __int8 *v37; // [rsp+88h] [rbp+20h]

  v5 = 0;
  if ( !a2 || a3 < 2u )
    goto LABEL_35;
  v6 = *((_QWORD *)this + 1);
  a4 = *(_QWORD *)(v6 + 80);
  if ( a4 )
  {
    if ( (*(_DWORD *)(v6 + 136) & 0x2000000) == 0
      || (*(_BYTE *)(a4 + 156) & 0x20) != 0
      || !*((_BYTE *)this + 27)
      || (*(_DWORD *)(v6 + 64) & 0x1000) == 0 )
    {
      return v5;
    }
    v7 = *a2;
    v8 = a2[1];
    v9 = a3 - 2;
    v10 = a2 + 2;
    v11 = v8 | (v7 << 8);
    if ( v11 <= v9 )
    {
      v12 = v10;
      v13 = (unsigned __int16 *)&v10[v11];
      v14 = v9 - v11;
      if ( v14 >= 2u )
      {
        v15 = _byteswap_ushort(*v13);
        if ( v15 == v14 - 2 )
        {
          v16 = 0;
          v36 = v15 + 2;
          v17 = (unsigned __int8 *)(v13 + 1);
          if ( !v11 )
            return v5;
          while ( 1 )
          {
            if ( !v15 )
              return v5;
            if ( v11 < 0x26u )
              break;
            v18 = *v12;
            v19 = v11 - 2;
            v20 = v12[1];
            v21 = v12 + 2;
            v22 = v21;
            v23 = v20 | (v18 << 8);
            if ( v23 > v19 )
              break;
            v24 = v19 - v23;
            if ( v24 < 4u )
              break;
            v12 = &v21[v23 + 4];
            v25 = v15 - 1;
            v11 = v24 - 4;
            v26 = *v17;
            v27 = v17 + 1;
            v28 = v26;
            if ( (unsigned __int16)v26 > v25 )
              break;
            v29 = *((_QWORD *)this + 5);
            v15 = v25 - v26;
            v30 = v27;
            v37 = v27;
            v17 = &v27[v26];
            a4 = 32i64;
            v31 = *(_QWORD *)(v29 + 120);
            if ( v23 == 32 )
            {
              if ( v31 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
              {
                *(_WORD *)(v31 + 64) |= 1u;
                *(_DWORD *)(v31 + 24) = 1;
                v29 = *((_QWORD *)this + 5);
              }
              if ( !v22 )
              {
                v32 = 0;
                goto LABEL_30;
              }
              v32 = CSessionCacheManager::LookupCacheForServerItem(
                      CSessionCacheManager::m_pSessionCacheManager,
                      (struct CSslContext *)v29,
                      v22,
                      0x20u,
                      (struct CSessionCacheServerItem **)(v29 + 992));
            }
            else
            {
              if ( v31 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
              {
                *(_DWORD *)(v31 + 24) = 1;
                *(_WORD *)(v31 + 64) |= 2u;
                v29 = *((_QWORD *)this + 5);
              }
              v32 = CSsl3TlsServerContext::UnprotectAndDeserializeSessionState(
                      (CSsl3TlsServerContext *)v29,
                      v22,
                      v23,
                      (unsigned __int8 *const)(v29 + 1249),
                      *(unsigned __int8 *)(v29 + 1281));
            }
            v30 = v37;
LABEL_30:
            if ( v32 )
            {
              v5 = CTls13ServerContext::VerifyBinder(*((CTls13ServerContext **)this + 5), v30, v28, v36, v16);
              if ( !v5 )
                return v5;
              goto LABEL_36;
            }
            ++v16;
            if ( !v11 )
              return v5;
          }
        }
      }
    }
LABEL_35:
    v5 = 315;
    goto LABEL_36;
  }
  v5 = 1359;
LABEL_36:
  v33 = (_QWORD *)*((_QWORD *)this + 5);
  v34 = v33[124];
  if ( v34 )
  {
    *(_BYTE *)(v34 + 236) = 0;
    (*(void (__fastcall **)(_QWORD *))(*v33 + 240i64))(v33);
  }
  v33[11] = 0i64;
  if ( v5 == 315 )
  {
    v5 = -2146893048;
    LOBYTE(a4) = 50;
    CSslContext::SetErrorAndFatalAlert(*((_QWORD *)this + 1), 1202i64, 2148074248i64, a4);
  }
  return v5;
}
// 180078403: variable 'a4' is possibly undefined
// 18005B470: using guessed type __int64 __fastcall CSslContext::SetErrorAndFatalAlert(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180078428) ----------------------------------------------------
__int64 __fastcall CTls13ExtServer::ParsePskKeyExchangeModesExtension(
        CTls13ExtServer *this,
        unsigned __int8 *a2,
        __int16 a3,
        __int64 a4)
{
  __int16 v5; // ax
  unsigned __int16 v6; // r8
  unsigned __int8 *v7; // rdx
  unsigned __int8 *v8; // rcx
  unsigned __int8 v9; // al
  __int64 v11; // rcx

  if ( !a2 || !a3 )
  {
    v11 = *((_QWORD *)this + 1);
    goto LABEL_19;
  }
  v5 = *a2;
  v6 = a3 - 1;
  v7 = a2 + 1;
  if ( !(_BYTE)v5 || v5 != v6 )
  {
    v11 = *((_QWORD *)this + 1);
LABEL_19:
    LOBYTE(a4) = 50;
    CSslContext::SetErrorAndFatalAlert(v11, 1202i64, 2148074248i64, a4);
    return 2148074248i64;
  }
  v8 = &v7[v6];
  if ( v7 >= v8 )
  {
LABEL_9:
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &WPP_5635b40337ae3cd6626e599d778a0aa6_Traceguids);
  }
  else
  {
    v9 = *v7;
    while ( v9 != 1 )
    {
      if ( ++v7 >= v8 )
        goto LABEL_9;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_5635b40337ae3cd6626e599d778a0aa6_Traceguids);
    *(_QWORD *)(*((_QWORD *)this + 1) + 136i64) |= 0x2000000ui64;
  }
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18005B470: using guessed type __int64 __fastcall CSslContext::SetErrorAndFatalAlert(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180078520) ----------------------------------------------------
unsigned int __fastcall CTls13ExtClient::ParseStatusRequestExtension(
        CTls13ExtClient *this,
        unsigned __int8 *a2,
        unsigned __int16 a3,
        __int64 a4)
{
  __int64 v4; // rax
  __int64 v6; // rcx

  v4 = *((_QWORD *)this + 1);
  v6 = *(_QWORD *)(v4 + 8);
  if ( !v6 )
    return -2146893052;
  if ( *(_DWORD *)(v6 + 48) == 4 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_5635b40337ae3cd6626e599d778a0aa6_Traceguids);
      v4 = *((_QWORD *)this + 1);
    }
    LOBYTE(a4) = 10;
    CSslContext::SetErrorAndFatalAlert(v4, 200i64, 2148074278i64, a4);
    return -2146893018;
  }
  else
  {
    *(_QWORD *)(v4 + 136) |= 0x20000ui64;
    return CSsl3TlsClientContext::DigestCertificateStatus(*((CSsl3TlsClientContext **)this + 8), a2, a3);
  }
}
// 18007858D: variable 'a4' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18005B470: using guessed type __int64 __fastcall CSslContext::SetErrorAndFatalAlert(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800785BC) ----------------------------------------------------
__int64 __fastcall CTls13ExtClient::ParseSupportedVersionsExtension(
        CTls13ExtClient *this,
        unsigned __int8 *a2,
        __int16 a3)
{
  __int64 v3; // r10
  unsigned int v4; // ecx
  __int64 result; // rax
  int v6; // eax
  __int64 v7; // r10
  __int64 v8; // rdx
  int v9; // eax
  __int16 v10; // ax
  __int64 v11; // r10
  __int64 v12; // r9

  if ( !a2 || a3 != 2 )
    return 2148074248i64;
  v3 = *((_QWORD *)this + 8);
  v4 = a2[1] | (*a2 << 8);
  if ( v4 < 0x304 )
  {
    CSslContext::SetErrorAndFatalAlert(v3, 100, -2146893048, 0x2Fu);
    return 2148074248i64;
  }
  if ( !*(_QWORD *)(v3 + 80) )
    return 2148074244i64;
  v6 = ConvertSslVersionToSchannelProtocol(v4);
  v9 = *(_DWORD *)(v8 + 152) & v6 & 0xA2AA0;
  if ( v9 )
  {
    *(_DWORD *)(v7 + 64) = v9;
    v10 = ConvertSchannelProtocolToSsl(v9);
    *(_WORD *)(v11 + 34) = v10;
    result = 0i64;
    *(_BYTE *)(v12 + 27) = 1;
  }
  else
  {
    CSslContext::SetErrorAndFatalAlert(v7, 1201, -2146893007, 0x46u);
    return 2148074289i64;
  }
  return result;
}
// 18007861D: variable 'v8' is possibly undefined
// 18007863B: variable 'v7' is possibly undefined
// 180078652: variable 'v11' is possibly undefined
// 180078659: variable 'v12' is possibly undefined

//----- (0000000180078668) ----------------------------------------------------
__int64 __fastcall CTls13ExtServer::ParseSupportedVersionsExtension(
        CTls13ExtServer *this,
        unsigned __int8 *a2,
        __int16 a3)
{
  __int16 v4; // ax
  unsigned __int16 v5; // r8
  unsigned __int8 *v6; // rdx
  __int64 v7; // r11
  __int64 v8; // rax
  unsigned int v9; // ebx
  _DWORD *v10; // rcx
  int v11; // r9d
  unsigned __int8 *v12; // rbx
  unsigned __int8 *v13; // rsi
  unsigned int v14; // ebp
  __int64 v15; // rcx
  unsigned __int8 v16; // r9
  __int16 v17; // ax
  int v18; // r10d
  __int64 v19; // r11
  __int64 v20; // rcx

  if ( !a2 || !a3 )
  {
    v15 = *((_QWORD *)this + 1);
LABEL_28:
    v9 = -2146893048;
    v16 = 50;
LABEL_29:
    CSslContext::SetErrorAndFatalAlert(v15, 1202, v9, v16);
    return v9;
  }
  v4 = *a2;
  v5 = a3 - 1;
  v6 = a2 + 1;
  if ( (unsigned __int8)v4 < 2u || (v4 & 1) != 0 || v4 != v5 )
  {
    v15 = *((_QWORD *)this + 1);
    goto LABEL_28;
  }
  v7 = *((_QWORD *)this + 1);
  v8 = *(_QWORD *)(v7 + 80);
  if ( !v8 )
  {
    v9 = 1359;
    CSslContext::SetError(*((_QWORD *)this + 1), 1202, 1359);
    return v9;
  }
  v10 = &TlsVersions;
  while ( 1 )
  {
    v11 = *(_DWORD *)(v8 + 152) & *v10 & 0x40051555;
    if ( v11 )
    {
      v12 = v6;
      v13 = &v6[v5];
      if ( v6 < v13 )
        break;
    }
LABEL_14:
    v10 += 2;
    if ( v10 >= WPP_922678f99ae534148d3bb024010f1556_Traceguids )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_5635b40337ae3cd6626e599d778a0aa6_Traceguids);
      v15 = *((_QWORD *)this + 1);
      v16 = 70;
      v9 = -2146893007;
      goto LABEL_29;
    }
  }
  v14 = *((unsigned __int16 *)v10 + 2);
  while ( (v12[1] | (*v12 << 8)) != v14 )
  {
    v12 += 2;
    if ( v12 >= v13 )
      goto LABEL_14;
  }
  *(_DWORD *)(v7 + 64) = v11;
  v17 = ConvertSchannelProtocolToSsl(v11);
  *(_WORD *)(v19 + 34) = v17;
  *(_DWORD *)(*((_QWORD *)this + 1) + 36i64) = v18;
  v20 = *(_QWORD *)(*((_QWORD *)this + 1) + 120i64);
  if ( v20 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    *(_DWORD *)(v20 + 44) = v18;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_5635b40337ae3cd6626e599d778a0aa6_Traceguids, v14);
  *((_BYTE *)this + 27) = 1;
  return 0i64;
}
// 18007878E: variable 'v19' is possibly undefined
// 180078797: variable 'v18' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180078830) ----------------------------------------------------
__int64 __fastcall CTls13ChangeCipherSpec::GenerateMessage(CTls13ChangeCipherSpec *this)
{
  __int64 result; // rax

  result = (*(__int64 (__fastcall **)(_QWORD, __int64, void *))(**((_QWORD **)this + 1) + 32i64))(
             *((_QWORD *)this + 1),
             1i64,
             &CTls13ChangeCipherSpec::CcsMessage);
  if ( !(_DWORD)result )
    return (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 1) + 40i64))(*((_QWORD *)this + 1));
  return result;
}

//----- (000000018007888C) ----------------------------------------------------
BOOLEAN FreeExternalSignatureAlgorithms()
{
  unsigned int i; // ebx
  PVOID *v1; // r8
  BOOLEAN result; // al

  for ( i = 7; i < g_dwSignatureInfoTotalCount; ++i )
  {
    v1 = (PVOID *)g_pSignatureInfo[i];
    if ( v1 && *v1 )
    {
      RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, *v1);
      v1 = (PVOID *)g_pSignatureInfo[i];
    }
    result = RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, v1);
    g_pSignatureInfo[i] = 0i64;
  }
  g_dwSignatureInfoTotalCount = 7;
  return result;
}
// 180092218: using guessed type int g_dwSignatureInfoTotalCount;
// 180092220: using guessed type _QWORD g_pSignatureInfo[16];

//----- (0000000180078934) ----------------------------------------------------
char GetExternalSignatureAlgorithms()
{
  NTSTATUS v0; // eax
  ULONG i; // edi
  unsigned __int64 v2; // r9
  _QWORD *Heap; // rbx
  wchar_t *v4; // rax
  int v5; // ecx
  __int64 v6; // rax
  HANDLE v8; // [rsp+38h] [rbp-D0h] BYREF
  ULONG ResultLength[2]; // [rsp+40h] [rbp-C8h] BYREF
  HANDLE KeyHandle[2]; // [rsp+48h] [rbp-C0h] BYREF
  char KeyInformation[16]; // [rsp+58h] [rbp-B0h] BYREF
  unsigned __int16 v12[264]; // [rsp+68h] [rbp-A0h] BYREF
  wchar_t String1[64]; // [rsp+278h] [rbp+170h] BYREF
  WCHAR v14[64]; // [rsp+2F8h] [rbp+1F0h] BYREF
  wchar_t Source[64]; // [rsp+378h] [rbp+270h] BYREF

  KeyHandle[0] = 0i64;
  v8 = 0i64;
  memset_0(v14, 0, sizeof(v14));
  memset_0(Source, 0, sizeof(Source));
  memset_0(String1, 0, sizeof(String1));
  ResultLength[0] = 0;
  LOBYTE(v0) = FreeExternalSignatureAlgorithms();
  if ( (unsigned int)g_dwSignatureInfoTotalCount < 0x10 )
  {
    v0 = TlsOpenRegKey(
           L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Cryptography\\Providers\\Microsoft SSL Protocol Provider\\Signature",
           0i64,
           KeyHandle);
    if ( v0 >= 0 )
    {
      for ( i = 0; (unsigned int)g_dwSignatureInfoTotalCount < 0x10; ++i )
      {
        memset_0(KeyInformation, 0, 0x218ui64);
        ResultLength[1] = 0;
        if ( NtEnumerateKey(KeyHandle[0], i, KeyBasicInformation, KeyInformation, 0x218u, &ResultLength[1]) < 0 )
          break;
        v2 = -1i64;
        do
          ++v2;
        while ( v12[v2] );
        if ( (int)RtlStringCchCopyNW((char *)v14, 64i64, (char *)v12, v2) < 0 )
          break;
        if ( TlsOpenRegKey(
               L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Cryptography\\Providers\\Microsoft SSL Protocol "
                "Provider\\Signature",
               v14,
               &v8) >= 0 )
        {
          if ( GetSslStringFromRegistry(v8, L"CngAlgorithm", (char *)Source) < 0
            || GetSslDWordFromRegistry(v8, L"TlsCodePoint", ResultLength) < 0
            || GetSslStringFromRegistry(v8, L"SignatureStyle", (char *)String1) < 0 )
          {
            TlsCloseRegKey(&v8);
          }
          else
          {
            TlsCloseRegKey(&v8);
            Heap = RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, 0, 0x18ui64);
            if ( Heap )
            {
              *(_OWORD *)Heap = 0i64;
              Heap[2] = 0i64;
              v4 = (wchar_t *)RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, 0, 0x80ui64);
              *Heap = v4;
              if ( v4 )
              {
                wcscpy_s(v4, 0x40ui64, Source);
                v5 = g_dwSignatureInfoTotalCount;
                *((_DWORD *)Heap + 3) = g_dwSignatureInfoTotalCount + 12281;
                *((_DWORD *)Heap + 2) = v5 - 536870918;
                *((_DWORD *)Heap + 4) = ResultLength[0];
                if ( wcsicmp(String1, L"RSA") )
                {
                  if ( wcsicmp(String1, L"DSA") )
                    *((_DWORD *)Heap + 5) = wcsicmp(String1, L"ECDSA") == 0 ? 4 : 0;
                  else
                    *((_DWORD *)Heap + 5) = 3;
                }
                else
                {
                  *((_DWORD *)Heap + 5) = 2;
                }
                v6 = (unsigned int)g_dwSignatureInfoTotalCount++;
                g_pSignatureInfo[v6] = Heap;
              }
              else
              {
                RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, Heap);
              }
            }
          }
        }
      }
      LOBYTE(v0) = TlsCloseRegKey(KeyHandle);
    }
  }
  return v0;
}
// 1800864D8: using guessed type wchar_t aTlscodepoint[13];
// 180092218: using guessed type int g_dwSignatureInfoTotalCount;
// 180092220: using guessed type _QWORD g_pSignatureInfo[16];

//----- (0000000180078C6C) ----------------------------------------------------
BOOLEAN FreeExternalCipherAlgorithms()
{
  unsigned int i; // ebx
  PVOID *v1; // r8
  BOOLEAN result; // al

  for ( i = 7; i < g_dwCipherInfoTotalCount; ++i )
  {
    v1 = (PVOID *)g_pCipherInfo[i];
    if ( v1 && *v1 )
    {
      RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, *v1);
      v1 = (PVOID *)g_pCipherInfo[i];
    }
    result = RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, v1);
    g_pCipherInfo[i] = 0i64;
  }
  g_dwCipherInfoTotalCount = 7;
  return result;
}
// 1800922A0: using guessed type _QWORD g_pCipherInfo[16];
// 180092320: using guessed type int g_dwCipherInfoTotalCount;

//----- (0000000180078D14) ----------------------------------------------------
__int64 __fastcall GetCipherDetailsFromRegistry(HANDLE KeyHandle, char *a2)
{
  int SslStringFromRegistry; // ebx

  SslStringFromRegistry = GetSslStringFromRegistry(KeyHandle, L"CngAlgorithm", a2);
  if ( SslStringFromRegistry >= 0 )
    GetSslStringFromRegistry(KeyHandle, L"CipherMode", a2 + 128);
  return (unsigned int)SslStringFromRegistry;
}

//----- (0000000180078D70) ----------------------------------------------------
char GetExternalCipherAlgorithms()
{
  NTSTATUS v0; // eax
  ULONG i; // edi
  unsigned __int64 v2; // r9
  wchar_t **Heap; // rax
  wchar_t **v4; // rbx
  wchar_t *v5; // rax
  PVOID ProcessHeap; // rcx
  wchar_t *v7; // rax
  wchar_t *v8; // r9
  int v9; // ecx
  UCHAR pbOutput[8]; // [rsp+38h] [rbp-D0h] BYREF
  HANDLE v12; // [rsp+40h] [rbp-C8h] BYREF
  BCRYPT_ALG_HANDLE phAlgorithm; // [rsp+48h] [rbp-C0h] BYREF
  ULONG pcbResult[2]; // [rsp+50h] [rbp-B8h] BYREF
  HANDLE KeyHandle; // [rsp+58h] [rbp-B0h] BYREF
  ULONG ResultLength; // [rsp+60h] [rbp-A8h] BYREF
  WCHAR pszAlgId[64]; // [rsp+68h] [rbp-A0h] BYREF
  wchar_t Source[64]; // [rsp+E8h] [rbp-20h] BYREF
  char KeyInformation[16]; // [rsp+168h] [rbp+60h] BYREF
  unsigned __int16 v20[264]; // [rsp+178h] [rbp+70h] BYREF
  WCHAR v21[64]; // [rsp+388h] [rbp+280h] BYREF

  KeyHandle = 0i64;
  v12 = 0i64;
  memset_0(v21, 0, sizeof(v21));
  *(_DWORD *)pbOutput = 0;
  phAlgorithm = 0i64;
  pcbResult[0] = 0;
  LOBYTE(v0) = FreeExternalCipherAlgorithms();
  if ( (unsigned int)g_dwCipherInfoTotalCount < 0x10 )
  {
    v0 = TlsOpenRegKey(
           L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Cryptography\\Providers\\Microsoft SSL Protocol Provider\\Cipher",
           0i64,
           &KeyHandle);
    if ( v0 >= 0 )
    {
      for ( i = 0; (unsigned int)g_dwCipherInfoTotalCount < 0x10; ++i )
      {
        memset_0(KeyInformation, 0, 0x218ui64);
        if ( NtEnumerateKey(KeyHandle, i, KeyBasicInformation, KeyInformation, 0x218u, &ResultLength) < 0 )
          break;
        v2 = -1i64;
        do
          ++v2;
        while ( v20[v2] );
        if ( (int)RtlStringCchCopyNW((char *)v21, 64i64, (char *)v20, v2) >= 0
          && TlsOpenRegKey(
               L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Cryptography\\Providers\\Microsoft SSL Protocol "
                "Provider\\Cipher",
               v21,
               &v12) >= 0 )
        {
          memset_0(pszAlgId, 0, 0x100ui64);
          if ( (int)GetCipherDetailsFromRegistry(v12, (char *)pszAlgId) >= 0 )
          {
            TlsCloseRegKey(&v12);
            if ( BCryptOpenAlgorithmProvider(&phAlgorithm, pszAlgId, 0i64, 0) >= 0 )
            {
              if ( BCryptGetProperty(phAlgorithm, L"BlockLength", pbOutput, 4u, pcbResult, 0) >= 0 )
              {
                BCryptCloseAlgorithmProvider(phAlgorithm, 0);
                Heap = (wchar_t **)RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, 0, 0x20ui64);
                v4 = Heap;
                if ( Heap )
                {
                  *(_OWORD *)Heap = 0i64;
                  *((_OWORD *)Heap + 1) = 0i64;
                  v5 = (wchar_t *)RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, 0, 0x80ui64);
                  *v4 = v5;
                  ProcessHeap = NtCurrentPeb()->ProcessHeap;
                  if ( v5 )
                  {
                    v7 = (wchar_t *)RtlAllocateHeap(ProcessHeap, 0, 0x80ui64);
                    v8 = *v4;
                    v4[3] = v7;
                    if ( v7 )
                    {
                      wcscpy_s(v8, 0x40ui64, pszAlgId);
                      wcscpy_s(v4[3], 0x40ui64, Source);
                      v9 = g_dwCipherInfoTotalCount++;
                      *((_DWORD *)v4 + 3) = v9 - 1073741830;
                      *((_DWORD *)v4 + 4) = v9 + 28665;
                      *((_DWORD *)v4 + 2) = *(_DWORD *)pbOutput;
                      g_pCipherInfo[v9] = v4;
                      continue;
                    }
                    RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, v8);
                    ProcessHeap = NtCurrentPeb()->ProcessHeap;
                  }
                  RtlFreeHeap(ProcessHeap, 0, v4);
                }
              }
              else
              {
                BCryptCloseAlgorithmProvider(phAlgorithm, 0);
              }
            }
          }
          else
          {
            TlsCloseRegKey(&v12);
          }
        }
      }
      LOBYTE(v0) = TlsCloseRegKey(&KeyHandle);
    }
  }
  return v0;
}
// 1800922A0: using guessed type _QWORD g_pCipherInfo[16];
// 180092320: using guessed type int g_dwCipherInfoTotalCount;
// 180078D70: using guessed type wchar_t Source[64];

//----- (00000001800790C4) ----------------------------------------------------
__int64 __fastcall I_GetCipherDetailsFromAlgorithmName(wchar_t *String1, __int64 a2, __int64 a3, _DWORD *a4)
{
  unsigned int v4; // ebx
  unsigned int v7; // eax
  int v8; // esi
  const wchar_t **v9; // rcx
  __int64 v11; // rax

  v4 = 0;
  if ( a4 )
    *a4 = 0;
  v7 = g_dwCipherInfoTotalCount;
  v8 = 0;
  if ( !g_dwCipherInfoTotalCount )
    return 1168;
  while ( 1 )
  {
    v9 = (const wchar_t **)g_pCipherInfo[v8];
    if ( !v9 || !*v9 )
      goto LABEL_8;
    if ( !wcsnicmp(String1, *v9, 0x40ui64) )
      break;
    v7 = g_dwCipherInfoTotalCount;
LABEL_8:
    if ( ++v8 >= v7 )
      return 1168;
  }
  v11 = g_pCipherInfo[v8];
  if ( !v11 )
    return 1168;
  if ( a4 )
    *a4 = *(_DWORD *)(v11 + 16);
  return v4;
}
// 1800922A0: using guessed type _QWORD g_pCipherInfo[16];
// 180092320: using guessed type int g_dwCipherInfoTotalCount;

//----- (000000018007916C) ----------------------------------------------------
BOOLEAN FreeExternalHashAlgorithms()
{
  unsigned int i; // ebx
  PVOID *v1; // r8
  BOOLEAN result; // al

  for ( i = 7; i < g_dwHashInfoTotalCount; ++i )
  {
    v1 = (PVOID *)g_pHashInfo[i];
    if ( v1 && *v1 )
    {
      RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, *v1);
      v1 = (PVOID *)g_pHashInfo[i];
    }
    result = RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, v1);
    g_pHashInfo[i] = 0i64;
  }
  g_dwHashInfoTotalCount = 7;
  return result;
}
// 180092324: using guessed type int g_dwHashInfoTotalCount;
// 180092330: using guessed type _QWORD g_pHashInfo[16];

//----- (0000000180079214) ----------------------------------------------------
char GetExternalHashAlgorithms()
{
  NTSTATUS v0; // eax
  ULONG v1; // edi
  unsigned __int64 v2; // r9
  _DWORD *Heap; // rbx
  wchar_t *v4; // rax
  __int64 v5; // rcx
  unsigned int v6; // ecx
  UCHAR pbOutput[8]; // [rsp+38h] [rbp-D0h] BYREF
  HANDLE v9; // [rsp+40h] [rbp-C8h] BYREF
  BCRYPT_ALG_HANDLE phAlgorithm; // [rsp+48h] [rbp-C0h] BYREF
  ULONG pcbResult[2]; // [rsp+50h] [rbp-B8h] BYREF
  HANDLE KeyHandle[2]; // [rsp+58h] [rbp-B0h] BYREF
  char KeyInformation[16]; // [rsp+68h] [rbp-A0h] BYREF
  unsigned __int16 v14[264]; // [rsp+78h] [rbp-90h] BYREF
  WCHAR pszAlgId[64]; // [rsp+288h] [rbp+180h] BYREF
  WCHAR v16[64]; // [rsp+308h] [rbp+200h] BYREF

  KeyHandle[0] = 0i64;
  v9 = 0i64;
  memset_0(v16, 0, sizeof(v16));
  memset_0(pszAlgId, 0, sizeof(pszAlgId));
  memset(pbOutput, 0, sizeof(pbOutput));
  phAlgorithm = 0i64;
  pcbResult[1] = 0;
  LOBYTE(v0) = FreeExternalHashAlgorithms();
  if ( (unsigned int)g_dwHashInfoTotalCount < 0x10 )
  {
    v0 = TlsOpenRegKey(
           L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Cryptography\\Providers\\Microsoft SSL Protocol Provider\\Hash",
           0i64,
           KeyHandle);
    if ( v0 >= 0 )
    {
      v1 = 0;
      if ( (unsigned int)g_dwHashInfoTotalCount < 0x10 )
      {
        while ( 1 )
        {
          memset_0(KeyInformation, 0, 0x218ui64);
          pcbResult[0] = 0;
          if ( NtEnumerateKey(KeyHandle[0], v1, KeyBasicInformation, KeyInformation, 0x218u, pcbResult) < 0 )
            goto LABEL_21;
          v2 = -1i64;
          do
            ++v2;
          while ( v14[v2] );
          if ( (int)RtlStringCchCopyNW((char *)v16, 64i64, (char *)v14, v2) < 0
            || TlsOpenRegKey(
                 L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Cryptography\\Providers\\Microsoft SSL Protoco"
                  "l Provider\\Hash",
                 v16,
                 &v9) < 0 )
          {
            goto LABEL_19;
          }
          if ( GetSslStringFromRegistry(v9, L"CngAlgorithm", (char *)pszAlgId) < 0
            || GetSslDWordFromRegistry(v9, L"TlsCodePoint", &pbOutput[4]) < 0 )
          {
            TlsCloseRegKey(&v9);
            goto LABEL_19;
          }
          TlsCloseRegKey(&v9);
          if ( BCryptOpenAlgorithmProvider(&phAlgorithm, pszAlgId, 0i64, 0) < 0 )
            goto LABEL_19;
          if ( BCryptGetProperty(phAlgorithm, L"HashDigestLength", pbOutput, 4u, &pcbResult[1], 0) < 0 )
            break;
          BCryptCloseAlgorithmProvider(phAlgorithm, 0);
          Heap = RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, 0, 0x18ui64);
          if ( !Heap )
            goto LABEL_19;
          *(_OWORD *)Heap = 0i64;
          *((_QWORD *)Heap + 2) = 0i64;
          v4 = (wchar_t *)RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, 0, 0x80ui64);
          *(_QWORD *)Heap = v4;
          if ( !v4 )
          {
            RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, Heap);
            goto LABEL_19;
          }
          wcscpy_s(v4, 0x40ui64, pszAlgId);
          v5 = (unsigned int)g_dwHashInfoTotalCount;
          Heap[2] = *(_DWORD *)pbOutput;
          g_pHashInfo[v5] = Heap;
          Heap[4] = v5 + 36857;
          Heap[3] = v5 - 268435462;
          v6 = v5 + 1;
          Heap[5] = *(_DWORD *)&pbOutput[4];
          g_dwHashInfoTotalCount = v6;
LABEL_20:
          ++v1;
          if ( v6 >= 0x10 )
            goto LABEL_21;
        }
        BCryptCloseAlgorithmProvider(phAlgorithm, 0);
LABEL_19:
        v6 = g_dwHashInfoTotalCount;
        goto LABEL_20;
      }
LABEL_21:
      LOBYTE(v0) = TlsCloseRegKey(KeyHandle);
    }
  }
  return v0;
}
// 1800864D8: using guessed type wchar_t aTlscodepoint[13];
// 180092324: using guessed type int g_dwHashInfoTotalCount;
// 180092330: using guessed type _QWORD g_pHashInfo[16];

//----- (0000000180079550) ----------------------------------------------------
BOOLEAN FreeExternalKeyExchangeAlgorithms()
{
  unsigned int i; // ebx
  PVOID *v1; // r8
  BOOLEAN result; // al

  for ( i = 7; i < g_dwKeyExchangeInfoTotalCount; ++i )
  {
    v1 = (PVOID *)g_pKeyExchangeInfo[i];
    if ( v1 && *v1 )
    {
      RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, *v1);
      v1 = (PVOID *)g_pKeyExchangeInfo[i];
    }
    result = RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, v1);
    g_pKeyExchangeInfo[i] = 0i64;
  }
  g_dwKeyExchangeInfoTotalCount = 7;
  return result;
}
// 1800923B0: using guessed type int g_dwKeyExchangeInfoTotalCount;
// 1800923C0: using guessed type _QWORD g_pKeyExchangeInfo[12];

//----- (00000001800795F8) ----------------------------------------------------
char GetExternalKeyExchangeAlgorithms()
{
  NTSTATUS v0; // eax
  ULONG i; // edi
  unsigned __int64 v2; // r9
  _QWORD *Heap; // rbx
  wchar_t *v4; // rax
  int v5; // ecx
  __int64 v6; // rax
  HANDLE v8; // [rsp+38h] [rbp-D0h] BYREF
  ULONG ResultLength[2]; // [rsp+40h] [rbp-C8h] BYREF
  HANDLE KeyHandle[2]; // [rsp+48h] [rbp-C0h] BYREF
  char KeyInformation[16]; // [rsp+58h] [rbp-B0h] BYREF
  unsigned __int16 v12[264]; // [rsp+68h] [rbp-A0h] BYREF
  wchar_t String1[64]; // [rsp+278h] [rbp+170h] BYREF
  WCHAR v14[64]; // [rsp+2F8h] [rbp+1F0h] BYREF
  wchar_t Source[64]; // [rsp+378h] [rbp+270h] BYREF

  KeyHandle[0] = 0i64;
  v8 = 0i64;
  memset_0(v14, 0, sizeof(v14));
  memset_0(Source, 0, sizeof(Source));
  memset_0(String1, 0, sizeof(String1));
  LOBYTE(v0) = FreeExternalKeyExchangeAlgorithms();
  if ( (unsigned int)g_dwKeyExchangeInfoTotalCount < 0xC )
  {
    v0 = TlsOpenRegKey(
           L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Cryptography\\Providers\\Microsoft SSL Protocol Prov"
            "ider\\KeyExchange",
           0i64,
           KeyHandle);
    if ( v0 >= 0 )
    {
      for ( i = 0; (unsigned int)g_dwKeyExchangeInfoTotalCount < 0xC; ++i )
      {
        memset_0(KeyInformation, 0, 0x218ui64);
        ResultLength[0] = 0;
        if ( NtEnumerateKey(KeyHandle[0], i, KeyBasicInformation, KeyInformation, 0x218u, ResultLength) < 0 )
          break;
        v2 = -1i64;
        do
          ++v2;
        while ( v12[v2] );
        if ( (int)RtlStringCchCopyNW((char *)v14, 64i64, (char *)v12, v2) < 0 )
          break;
        if ( TlsOpenRegKey(
               L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Cryptography\\Providers\\Microsoft SSL Protocol "
                "Provider\\KeyExchange",
               v14,
               &v8) >= 0 )
        {
          if ( GetSslStringFromRegistry(v8, L"CngAlgorithm", (char *)Source) < 0
            || GetSslStringFromRegistry(v8, L"MessageFlow", (char *)String1) < 0 )
          {
            TlsCloseRegKey(&v8);
          }
          else
          {
            TlsCloseRegKey(&v8);
            Heap = RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, 0, 0x18ui64);
            if ( Heap )
            {
              *(_OWORD *)Heap = 0i64;
              Heap[2] = 0i64;
              v4 = (wchar_t *)RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, 0, 0x80ui64);
              *Heap = v4;
              if ( v4 )
              {
                wcscpy_s(v4, 0x40ui64, Source);
                v5 = g_dwKeyExchangeInfoTotalCount;
                *((_DWORD *)Heap + 3) = g_dwKeyExchangeInfoTotalCount + 45049;
                *((_DWORD *)Heap + 2) = v5 - 805306374;
                if ( wcsicmp(String1, L"RSA") )
                {
                  if ( wcsicmp(String1, L"DH") )
                  {
                    if ( wcsicmp(String1, L"ECDH") )
                      *((_DWORD *)Heap + 4) = wcsicmp(String1, L"PSK") == 0 ? 4 : 0;
                    else
                      *((_DWORD *)Heap + 4) = 3;
                  }
                  else
                  {
                    *((_DWORD *)Heap + 4) = 2;
                  }
                }
                else
                {
                  *((_DWORD *)Heap + 4) = 1;
                }
                v6 = (unsigned int)g_dwKeyExchangeInfoTotalCount++;
                g_pKeyExchangeInfo[v6] = Heap;
              }
              else
              {
                RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, Heap);
              }
            }
          }
        }
      }
      LOBYTE(v0) = TlsCloseRegKey(KeyHandle);
    }
  }
  return v0;
}
// 1800923B0: using guessed type int g_dwKeyExchangeInfoTotalCount;
// 1800923C0: using guessed type _QWORD g_pKeyExchangeInfo[12];

//----- (0000000180079924) ----------------------------------------------------
int __fastcall GetSslStringFromRegistry(HANDLE KeyHandle, PCWSTR SourceString, char *a3)
{
  int result; // eax
  ULONG ResultLength; // [rsp+30h] [rbp-D8h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+38h] [rbp-D0h] BYREF
  char KeyValueInformation[4]; // [rsp+50h] [rbp-B8h] BYREF
  int v10; // [rsp+54h] [rbp-B4h]
  unsigned int v11; // [rsp+58h] [rbp-B0h]
  unsigned __int16 v12[66]; // [rsp+5Ch] [rbp-ACh] BYREF

  ResultLength = 0;
  DestinationString = 0i64;
  memset_0(KeyValueInformation, 0, 0x90ui64);
  RtlInitUnicodeString(&DestinationString, SourceString);
  result = NtQueryValueKey(
             KeyHandle,
             &DestinationString,
             KeyValuePartialInformation,
             KeyValueInformation,
             0x90u,
             &ResultLength);
  if ( result >= 0 )
  {
    if ( v10 == 1 && v11 - 1 <= 0x7C )
    {
      result = RtlStringCchCopyNW(a3, 64i64, (char *)v12, (unsigned __int64)v11 >> 1);
      if ( result < 0 )
        return -1073741595;
    }
    else
    {
      return -1073739509;
    }
  }
  return result;
}
// 180079924: using guessed type unsigned __int16 var_AC[66];

//----- (0000000180079A10) ----------------------------------------------------
__int64 __fastcall _DbgpControlTracing(struct _DBG_TRACE_CONTROL_BLOCK *a1, int a2, int a3)
{
  unsigned int v7; // r14d
  unsigned int v8; // r15d
  bool v9; // zf
  BOOL v10; // esi
  int v11; // edx
  int v12; // ebx
  ULONG started; // ebx
  __int64 v15; // r8
  int v16; // ecx
  int v17; // edx
  DWORD WindowsDirectoryW; // eax
  __int64 v19; // rdx
  __int64 v20; // rax
  __int64 v21; // rbx
  WCHAR *v22; // r15
  unsigned __int16 *v23; // r12
  DWORD CurrentDirectoryW; // eax
  PVOID Heap; // rax
  __int64 v26; // rbx
  __int64 v27; // rax
  wchar_t *v28; // rbx
  __int64 v29; // rcx
  int v30; // eax
  TRACEHANDLE *v31; // r14
  UCHAR v32; // r9
  TRACEHANDLE v33; // rcx
  ULONGLONG MatchAnyKeyword; // [rsp+20h] [rbp-E0h]
  int v35; // [rsp+80h] [rbp-80h]
  DWORD nSize; // [rsp+84h] [rbp-7Ch] BYREF
  int v37; // [rsp+88h] [rbp-78h]
  struct _ENABLE_TRACE_PARAMETERS EnableParameters; // [rsp+90h] [rbp-70h] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [rsp+C0h] [rbp-40h] BYREF
  unsigned __int16 v40; // [rsp+1D4h] [rbp+D4h]
  unsigned __int16 v41; // [rsp+1D6h] [rbp+D6h]
  unsigned __int16 v42; // [rsp+1D8h] [rbp+D8h]
  unsigned __int8 v43; // [rsp+1DAh] [rbp+DAh]
  wchar_t Destination[264]; // [rsp+1E0h] [rbp+E0h] BYREF
  WCHAR Buffer[264]; // [rsp+3F0h] [rbp+2F0h] BYREF
  WCHAR PathName[264]; // [rsp+600h] [rbp+500h] BYREF
  WCHAR v47[264]; // [rsp+810h] [rbp+710h] BYREF
  WCHAR NewFileName[264]; // [rsp+A20h] [rbp+920h] BYREF
  WCHAR ExistingFileName[264]; // [rsp+C30h] [rbp+B30h] BYREF
  unsigned __int16 v50[264]; // [rsp+E40h] [rbp+D40h] BYREF

  memset_0(&VersionInformation, 0, 0x11Cui64);
  v7 = 10;
  v8 = (*((unsigned __int16 *)a1 + 28) >> 1) + 10;
  memset_0(PathName, 0, 0x208ui64);
  v9 = *((_QWORD *)a1 + 9) == 0i64;
  memset(&EnableParameters, 0, sizeof(EnableParameters));
  v10 = !v9 && *((_QWORD *)a1 + 11);
  v11 = a2;
  v35 = a2;
  v37 = a2;
  v12 = a2 & 0xFFFFFFF;
  if ( a3 )
  {
    *((_DWORD *)a1 + 27) = v12;
    if ( !v12 )
    {
LABEL_7:
      started = 0;
      goto LABEL_8;
    }
  }
  else
  {
    if ( v12 == *((_DWORD *)a1 + 27) )
    {
      if ( !v10 )
        goto LABEL_7;
      v15 = *((_QWORD *)a1 + 11);
      v16 = *(_DWORD *)(v15 + 64);
      if ( a2 >= 0 == ((v16 & 0x80000) == 0) || !*((_BYTE *)DbgpGlobalControllerHeader + 56) )
      {
        v17 = v11 & 0x40000000;
        if ( (v17 == 0) == ((v16 & 0x100) == 0) )
        {
          if ( v17 )
          {
            if ( *((_DWORD *)a1 + 8) == *(_DWORD *)(v15 + 68) )
              goto LABEL_7;
          }
          else if ( !*(_DWORD *)(v15 + 68) )
          {
            goto LABEL_7;
          }
        }
        v11 = v35;
      }
    }
    *((_DWORD *)a1 + 27) = v12;
    if ( !v12 )
    {
      if ( v10 )
      {
        _DbgpStopTracing(a1);
        goto LABEL_7;
      }
      goto LABEL_25;
    }
  }
  if ( v10 )
  {
LABEL_51:
    Destination[0] = 0;
LABEL_52:
    if ( !v10 )
    {
      *((_DWORD *)a1 + 20) = 1160;
      Heap = RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, 0, 0x488ui64);
      *((_QWORD *)a1 + 11) = Heap;
      if ( !Heap )
      {
        started = 14;
        goto LABEL_8;
      }
      memset_0(Heap, 0, *((unsigned int *)a1 + 20));
      **((_DWORD **)a1 + 11) = *((_DWORD *)a1 + 20);
      *(_DWORD *)(*((_QWORD *)a1 + 11) + 44i64) = 0x20000;
      *(_DWORD *)(*((_QWORD *)a1 + 11) + 116i64) = 120;
      v26 = *((_QWORD *)a1 + 11) + *(unsigned int *)(*((_QWORD *)a1 + 11) + 116i64);
      o_wcsncpy_s_0(v26, 260i64, *((_QWORD *)a1 + 8), 259i64);
      *(_WORD *)(v26 + 518) = 0;
      v27 = *((_QWORD *)a1 + 11);
      if ( Destination[0] )
      {
        *(_DWORD *)(v27 + 60) = 1;
        *(_DWORD *)(*((_QWORD *)a1 + 11) + 112i64) = 640;
        v28 = (wchar_t *)(*((_QWORD *)a1 + 11) + *(unsigned int *)(*((_QWORD *)a1 + 11) + 112i64));
        snwprintf_s(v28, 0x103ui64, 0x103ui64, L"%s\\%s", Buffer, Destination);
        v28[259] = 0;
        *(_DWORD *)(*((_QWORD *)a1 + 11) + 64i64) |= 0x4002u;
      }
      else
      {
        *(_DWORD *)(v27 + 64) |= 0x8400u;
      }
    }
    if ( v37 < 0 && *((_BYTE *)DbgpGlobalControllerHeader + 56) )
      *(_DWORD *)(*((_QWORD *)a1 + 11) + 64i64) |= 0x80000u;
    else
      *(_DWORD *)(*((_QWORD *)a1 + 11) + 64i64) &= ~0x80000u;
    v29 = *((_QWORD *)a1 + 11);
    v30 = *(_DWORD *)(v29 + 64);
    if ( (v35 & 0x40000000) != 0 )
    {
      *(_DWORD *)(v29 + 64) = v30 | 0x100;
      *(_DWORD *)(*((_QWORD *)a1 + 11) + 68i64) = *((_DWORD *)a1 + 8);
    }
    else
    {
      *(_DWORD *)(v29 + 64) = v30 & 0xFFFFFEFF;
      *(_DWORD *)(*((_QWORD *)a1 + 11) + 68i64) = 0;
    }
    if ( v10 )
    {
      v31 = (TRACEHANDLE *)((char *)a1 + 72);
    }
    else
    {
      started = ControlTraceW(0i64, *((LPCWSTR *)a1 + 8), *((PEVENT_TRACE_PROPERTIES *)a1 + 11), 0);
      if ( started != 4201 )
        goto LABEL_67;
      v31 = (TRACEHANDLE *)((char *)a1 + 72);
      *(_DWORD *)(*((_QWORD *)a1 + 11) + 72i64) = *((_DWORD *)a1 + 27);
      started = StartTraceW((PTRACEHANDLE)a1 + 9, *((LPCWSTR *)a1 + 8), *((PEVENT_TRACE_PROPERTIES *)a1 + 11));
      if ( started )
        goto LABEL_67;
    }
    v32 = *((_BYTE *)a1 + 104);
    v33 = *v31;
    MatchAnyKeyword = *((unsigned int *)a1 + 27);
    EnableParameters.Version = 1;
    started = EnableTraceEx2(v33, (LPCGUID)a1 + 7, 1u, v32, MatchAnyKeyword, 0i64, 0, &EnableParameters);
    if ( !started )
      goto LABEL_7;
    if ( v10 )
      goto LABEL_8;
LABEL_67:
    _DbgpStopTracing(a1);
    goto LABEL_8;
  }
LABEL_25:
  if ( (v11 & 0x20000000) != 0 )
    goto LABEL_51;
  WindowsDirectoryW = GetWindowsDirectoryW(Buffer, 260 - v8);
  nSize = WindowsDirectoryW;
  if ( !WindowsDirectoryW )
  {
LABEL_27:
    started = GetLastError();
    goto LABEL_8;
  }
  if ( WindowsDirectoryW <= 260 - (unsigned __int64)v8 )
  {
    wcscat_s(Buffer, 0x104ui64, L"\\tracing");
    if ( !CreateDirectoryW(Buffer, 0i64) )
    {
      started = GetLastError();
      if ( started != 183 )
        goto LABEL_8;
    }
    wcscat_s(Buffer, 0x103ui64, L"\\");
    wcscat_s(Buffer, 0x103ui64, *((const wchar_t **)a1 + 8));
    Buffer[259] = 0;
    if ( !CreateDirectoryW(Buffer, 0i64) )
    {
      started = GetLastError();
      if ( started != 183 )
        goto LABEL_8;
    }
    VersionInformation.dwOSVersionInfoSize = 284;
    if ( GetVersionExW(&VersionInformation) )
    {
      _DbgpGetFileVersionString(*((LPCWSTR *)a1 + 6), v19, v50);
      nSize = 259;
      v47[259] = 0;
      if ( GetComputerNameExW(ComputerNameNetBIOS, v47, &nSize) )
      {
        Destination[259] = 0;
        snwprintf_s(
          Destination,
          0x103ui64,
          0xFFui64,
          L"%s_%wZ_%d_%d_%d_%d_%d_%d_%s_%x_%s",
          v47,
          (char *)a1 + 56,
          v43,
          VersionInformation.dwMajorVersion,
          VersionInformation.dwMinorVersion,
          VersionInformation.dwBuildNumber,
          v40,
          v41,
          VersionInformation.szCSDVersion,
          v42,
          v50);
        wcscat_s(Destination, 0x103ui64, L".etl");
        v20 = -1i64;
        do
          ++v20;
        while ( Destination[v20] );
        v21 = (unsigned int)(v20 - 4);
        v22 = &ExistingFileName[v21];
        v23 = &NewFileName[v21];
        CurrentDirectoryW = GetCurrentDirectoryW(0x103u, PathName);
        if ( !CurrentDirectoryW )
          return GetLastError();
        if ( CurrentDirectoryW >= 0x103 )
          return 122;
        if ( SetCurrentDirectoryW(Buffer) )
        {
          memcpy_0(ExistingFileName, Destination, v21 * 2);
          memcpy_0(NewFileName, Destination, v21 * 2);
          while ( 1 )
          {
            _DbgpSetExt(v7, v23);
            if ( v7 == 1 )
            {
              *(_QWORD *)v22 = *(_QWORD *)L".etl";
              v22[4] = aEtl[4];
            }
            else
            {
              _DbgpSetExt(v7 - 1, v22);
            }
            if ( !MoveFileExW(ExistingFileName, NewFileName, 1u) )
            {
              started = GetLastError();
              if ( started != 2 )
                goto LABEL_8;
            }
            if ( !--v7 )
              goto LABEL_52;
          }
        }
      }
    }
    goto LABEL_27;
  }
  started = 122;
LABEL_8:
  if ( PathName[0] )
    SetCurrentDirectoryW(PathName);
  return started;
}
// 180079CEF: variable 'v19' is possibly undefined
// 180028D84: using guessed type __int64 __fastcall o_wcsncpy_s_0(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092810: using guessed type struct _DBG_TCB_HEADER *DbgpGlobalControllerHeader;

//----- (000000018007A134) ----------------------------------------------------
void __fastcall _DbgpDeleteTraceControl(struct _DBG_TRACE_CONTROL_BLOCK *a1)
{
  void *v2; // rcx
  void *v3; // rcx
  HKEY v4; // rcx

  if ( a1 )
  {
    v2 = (void *)*((_QWORD *)a1 + 20);
    if ( v2 )
    {
      UnregisterWaitEx(v2, 0i64);
      *((_QWORD *)a1 + 20) = 0i64;
    }
    v3 = (void *)*((_QWORD *)a1 + 19);
    if ( v3 )
    {
      CloseHandle(v3);
      *((_QWORD *)a1 + 19) = 0i64;
    }
    v4 = (HKEY)*((_QWORD *)a1 + 21);
    if ( v4 )
    {
      RegCloseKey(v4);
      *((_QWORD *)a1 + 21) = 0i64;
    }
    _DbgpStopTracing(a1);
    if ( *((_QWORD *)a1 + 16) )
    {
      EtwUnregisterTraceGuids();
      *((_QWORD *)a1 + 16) = 0i64;
    }
    RtlFreeUnicodeString((PUNICODE_STRING)((char *)a1 + 56));
    RtlFreeUnicodeString((PUNICODE_STRING)((char *)a1 + 40));
    DeleteCriticalSection((LPCRITICAL_SECTION)((char *)a1 + 192));
    memset_0(a1, 0, 0xF0ui64);
    RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, a1);
  }
}
// 180080E08: using guessed type __int64 EtwUnregisterTraceGuids(void);

//----- (000000018007A240) ----------------------------------------------------
__int64 __fastcall _DbgpGetFileVersionString(LPCWSTR lpwstrFilename, __int64 a2, unsigned __int16 *a3)
{
  void *v5; // rdi
  unsigned int v6; // r14d
  DWORD FileVersionInfoSize; // eax
  DWORD v8; // ebx
  PVOID Heap; // rax
  DWORD v10; // ecx
  __int64 v12; // rbx
  __int64 v13; // rcx
  LPVOID lpData; // [rsp+20h] [rbp-E0h]
  DWORD dwHandle; // [rsp+30h] [rbp-D0h] BYREF
  LPVOID lpBuffer; // [rsp+38h] [rbp-C8h] BYREF
  LPVOID Src; // [rsp+40h] [rbp-C0h] BYREF
  wchar_t Buffer[128]; // [rsp+50h] [rbp-B0h] BYREF

  v5 = 0i64;
  v6 = 1;
  FileVersionInfoSize = GetFileVersionInfoSizeExW(1u, lpwstrFilename, &dwHandle);
  v8 = FileVersionInfoSize;
  if ( FileVersionInfoSize )
  {
    Heap = RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, 0, FileVersionInfoSize);
    v5 = Heap;
    if ( !Heap )
    {
      v10 = 14;
LABEL_4:
      SetLastError(v10);
      goto LABEL_5;
    }
    if ( GetFileVersionInfoExW(3u, lpwstrFilename, 0, v8, Heap)
      && VerQueryValueW(v5, L"\\VarFileInfo\\Translation", &lpBuffer, &dwHandle) )
    {
      if ( dwHandle < 2 )
      {
        v10 = 1168;
        goto LABEL_4;
      }
      Buffer[127] = 0;
      LODWORD(lpData) = *(unsigned __int16 *)lpBuffer;
      snwprintf_s(
        Buffer,
        0x80ui64,
        0x7Fui64,
        L"\\StringFileInfo\\%04x%04x\\FileVersion",
        lpData,
        *((unsigned __int16 *)lpBuffer + 1));
      if ( VerQueryValueW(v5, Buffer, &Src, &dwHandle) )
      {
        if ( dwHandle > 0x103 )
        {
          v10 = 122;
          goto LABEL_4;
        }
        v12 = dwHandle;
        memcpy_0(a3, Src, v12 * 2);
        a3[v12] = 0;
        if ( !dwHandle )
          goto LABEL_6;
        v13 = dwHandle;
        while ( 1 )
        {
          if ( *a3 > 0x2Eu )
          {
            if ( *a3 < 0x3Au
              || *a3 > 0x3Bu && *a3 != 63 && (*a3 <= 0x5Au || *a3 > 0x5Eu && (*a3 <= 0x7Au || *a3 > 0x7Du)) )
            {
              goto LABEL_37;
            }
          }
          else if ( *a3 < 0x2Bu
                 && (*a3 < 9u
                  || *a3 > 0xAu
                  && *a3 != 13
                  && (*a3 <= 0x1Fu || *a3 > 0x21u && (*a3 <= 0x23u || *a3 > 0x26u && (*a3 <= 0x27u || *a3 > 0x29u)))) )
          {
            goto LABEL_37;
          }
          *a3 = 95;
LABEL_37:
          ++a3;
          if ( !--v13 )
            goto LABEL_6;
        }
      }
    }
  }
LABEL_5:
  *a3 = 0;
  v6 = 0;
  if ( v5 )
LABEL_6:
    RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, v5);
  return v6;
}
// 18007A3AE: variable 'lpData' is possibly undefined

//----- (000000018007A4A8) ----------------------------------------------------
void __fastcall _DbgpSetExt(unsigned int a1, unsigned __int16 *a2)
{
  *a2 = 46;
  a2[4] = 0;
  a2[3] = a1 % 0xA + 48;
  a2[1] = a1 / 0xA / 0xA % 0xA + 48;
  a2[2] = a1 / 0xA % 0xA + 48;
}

//----- (000000018007A540) ----------------------------------------------------
void __fastcall _DbgpStopTracing(struct _DBG_TRACE_CONTROL_BLOCK *a1)
{
  TRACEHANDLE v2; // rcx
  struct _EVENT_TRACE_PROPERTIES *v3; // r8
  void *v4; // r8

  v2 = *((_QWORD *)a1 + 9);
  if ( v2 )
  {
    v3 = (struct _EVENT_TRACE_PROPERTIES *)*((_QWORD *)a1 + 11);
    if ( v3 )
      ControlTraceW(v2, *((LPCWSTR *)a1 + 8), v3, 1u);
  }
  *((_QWORD *)a1 + 9) = 0i64;
  v4 = (void *)*((_QWORD *)a1 + 11);
  if ( v4 )
  {
    RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, v4);
    *((_QWORD *)a1 + 11) = 0i64;
  }
  *((_DWORD *)a1 + 20) = 0;
  *((_DWORD *)a1 + 26) = 0;
  *((_DWORD *)a1 + 27) = 0;
}

//----- (000000018007A5C0) ----------------------------------------------------
void __fastcall _DbgpTraceControllerTimerCallback(struct _RTL_CRITICAL_SECTION *a1, char a2)
{
  struct _RTL_CRITICAL_SECTION *v2; // rbp
  struct _RTL_CRITICAL_SECTION *v4; // rdi
  PRTL_CRITICAL_SECTION_DEBUG i; // rbx
  __int64 v6; // rdx
  void (__fastcall *v7)(PRTL_CRITICAL_SECTION_DEBUG, __int64); // rax

  v2 = a1 + 2;
  v4 = a1 + 1;
  EnterCriticalSection(a1 + 2);
  for ( i = v4->DebugInfo; i != (PRTL_CRITICAL_SECTION_DEBUG)v4; i = *(PRTL_CRITICAL_SECTION_DEBUG *)&i->Type )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)&i[4]);
    v7 = *(void (__fastcall **)(PRTL_CRITICAL_SECTION_DEBUG, __int64))&i[2].Flags;
    if ( v7 )
    {
      LOBYTE(v6) = a2;
      v7(i, v6);
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)&i[4]);
  }
  LeaveCriticalSection(v2);
}
// 18007A62A: variable 'v6' is possibly undefined

//----- (000000018007A678) ----------------------------------------------------
__int64 __fastcall PAC_DecodeValidationInformation(
        unsigned __int8 *a1,
        int a2,
        struct _NETLOGON_VALIDATION_SAM_INFO3 **a3)
{
  unsigned int v6; // ebx
  __int128 v8; // [rsp+30h] [rbp-18h] BYREF
  handle_t Handle; // [rsp+68h] [rbp+20h] BYREF

  v6 = 0;
  Handle = 0i64;
  v8 = 0i64;
  if ( MesDecodeIncrementalHandleCreate(&v8, (MIDL_ES_READ)PacReadFcn, &Handle) )
  {
    v6 = -1073741670;
  }
  else
  {
    DWORD2(v8) = a2;
    *(_QWORD *)&v8 = a1;
    NdrMesTypeDecode3(Handle, &pPicklingInfo, &pProxyInfo, (const unsigned int **)&ArrTypeOffset, 1u, a3);
  }
  if ( Handle )
    MesHandleFree(Handle);
  return v6;
}

//----- (000000018007A740) ----------------------------------------------------
__int64 __fastcall PAC_EncodeValidationInformation(
        struct _NETLOGON_VALIDATION_SAM_INFO3 *a1,
        unsigned __int8 **a2,
        unsigned int *a3)
{
  unsigned int v5; // edi
  unsigned __int8 *v6; // rbx
  unsigned int v7; // esi
  unsigned __int8 *v8; // rax
  RPC_STATUS v9; // eax
  __int128 v11; // [rsp+40h] [rbp-28h] BYREF
  struct _NETLOGON_VALIDATION_SAM_INFO3 *Operation; // [rsp+70h] [rbp+8h] BYREF
  handle_t Handle; // [rsp+88h] [rbp+20h] BYREF

  Operation = a1;
  v5 = 0;
  Handle = 0i64;
  v11 = 0i64;
  v6 = 0i64;
  if ( MesEncodeIncrementalHandleCreate(&v11, (MIDL_ES_ALLOC)PacReadFcn, PacWriteFcn, &Handle)
    || (v7 = NdrMesTypeAlignSize3(
               Handle,
               &pPicklingInfo,
               &pProxyInfo,
               (const unsigned int **)&ArrTypeOffset,
               1u,
               &Operation),
        v8 = (unsigned __int8 *)MIDL_user_allocate(v7),
        (v6 = v8) == 0i64) )
  {
    v5 = -1073741670;
  }
  else
  {
    DWORD2(v11) = v7;
    *(_QWORD *)&v11 = v8;
    v9 = MesIncrementalHandleReset(Handle, 0i64, 0i64, 0i64, 0i64, MES_ENCODE);
    if ( v9 )
    {
      v5 = I_RpcMapWin32Status(v9);
    }
    else
    {
      NdrMesTypeEncode3(Handle, &pPicklingInfo, &pProxyInfo, (const unsigned int **)&ArrTypeOffset, 1u, &Operation);
      *a2 = v6;
      *a3 = v7;
      v6 = 0i64;
    }
  }
  if ( v6 )
    (*(void (__fastcall **)(unsigned __int8 *))(LsaTable + 48))(v6);
  if ( Handle )
    MesHandleFree(Handle);
  return v5;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018007A8F8) ----------------------------------------------------
__int64 __fastcall PAC_InitAndUpdateGroupsEx(
        struct _NETLOGON_VALIDATION_SAM_INFO3 *a1,
        struct _SAMPR_PSID_ARRAY *a2,
        void *a3,
        struct _PACTYPE *a4,
        struct _PACTYPE **a5)
{
  struct _PACTYPE **v5; // r12
  int v7; // ebx
  size_t v8; // r14
  unsigned int v9; // ecx
  unsigned int v10; // r8d
  unsigned int v11; // r13d
  unsigned int v12; // ebp
  _DWORD *v13; // rdx
  unsigned int v14; // edx
  size_t v15; // rbx
  unsigned int *v16; // rax
  unsigned int *v17; // rdi
  void *v18; // rdx
  void *v19; // rbx
  unsigned int v20; // ebp
  void *i; // r14
  unsigned int v22; // eax
  __int64 v23; // rbx
  void *Src; // [rsp+30h] [rbp-38h] BYREF
  size_t Size; // [rsp+80h] [rbp+18h] BYREF

  Size = (size_t)a3;
  v5 = a5;
  Src = 0i64;
  *a5 = 0i64;
  v7 = PAC_ReMarshallValidationInfoWithGroups(a1, a2, a3, (unsigned __int8 **)&Src, (unsigned int *)&Size);
  if ( v7 >= 0 )
  {
    v8 = (unsigned int)Size;
    if ( (unsigned int)Size >= 0xFFFF )
      goto LABEL_3;
    v9 = (Size + 7) & 0xFFFFFFF8;
    v10 = 0;
    v11 = 1;
    v12 = 1;
    if ( *(_DWORD *)a4 )
    {
      v13 = (_DWORD *)((char *)a4 + 12);
      do
      {
        if ( *(v13 - 1) != 1 )
        {
          if ( *v13 >= 0xFFFFu )
            goto LABEL_3;
          if ( v9 + ((*v13 + 7) & 0xFFFFFFF8) < v9 )
          {
            v7 = -1073741675;
            goto LABEL_20;
          }
          v9 += (*v13 + 7) & 0xFFFFFFF8;
          ++v12;
        }
        ++v10;
        v13 += 4;
      }
      while ( v10 < *(_DWORD *)a4 );
    }
    v14 = v9 + 16 * v12 + 8;
    if ( v14 >= 0xFFFF )
    {
LABEL_3:
      v7 = -1073741637;
      goto LABEL_20;
    }
    v15 = (v14 + 7) & 0xFFFFFFF8;
    v16 = (unsigned int *)MIDL_user_allocate(v15);
    v17 = v16;
    if ( v16 )
    {
      memset_0(v16, 0, v15);
      v18 = Src;
      *v17 = v12;
      v17[2] = 1;
      v17[3] = v8;
      v19 = (void *)(((unsigned __int64)&v17[4 * v12 + 3] + 3) & 0xFFFFFFFFFFFFFFF8ui64);
      *((_QWORD *)v17 + 2) = v19;
      memcpy_0(v19, v18, v8);
      v20 = 0;
      for ( i = (void *)(((unsigned __int64)v19 + v17[3] + 7) & 0xFFFFFFFFFFFFFFF8ui64); v20 < *(_DWORD *)a4; ++v20 )
      {
        v22 = *((_DWORD *)a4 + 4 * v20 + 2);
        if ( v22 != 1 )
        {
          v23 = 2i64 * v11;
          v17[2 * v23 + 2] = v22;
          v17[2 * v23 + 3] = *((_DWORD *)a4 + 4 * v20 + 3);
          *(_QWORD *)&v17[2 * v23 + 4] = i;
          memcpy_0(i, *((const void **)a4 + 2 * v20 + 2), *((unsigned int *)a4 + 4 * v20 + 3));
          i = (void *)(((unsigned __int64)i + v17[4 * v11++ + 3] + 7) & 0xFFFFFFFFFFFFFFF8ui64);
        }
      }
      *v5 = (struct _PACTYPE *)v17;
      v7 = 0;
    }
    else
    {
      v7 = -1073741670;
    }
  }
LABEL_20:
  if ( Src )
    (*(void (__fastcall **)(void *))(LsaTable + 48))(Src);
  return (unsigned int)v7;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018007AAD8) ----------------------------------------------------
__int64 __fastcall PAC_ReMarshallValidationInfoWithGroups(
        struct _NETLOGON_VALIDATION_SAM_INFO3 *a1,
        struct _SAMPR_PSID_ARRAY *a2,
        void *a3,
        unsigned __int8 **a4,
        unsigned int *a5)
{
  char *v5; // r8
  struct _NETLOGON_VALIDATION_SAM_INFO3 *v7; // rax
  __int64 v8; // rcx
  __int128 v11; // xmm1
  __int128 v12; // xmm0
  __int128 v13; // xmm1
  __int128 v14; // xmm0
  __int128 v15; // xmm1
  __int128 v16; // xmm0
  __int128 v17; // xmm1
  int v18; // edx
  unsigned int v19; // ebx
  __int128 v20; // xmm1
  __int128 v21; // xmm0
  __int64 v22; // rax
  unsigned int v23; // edx
  size_t v24; // rsi
  void *v25; // rax
  __int64 v26; // rdi
  unsigned int v27; // ebx
  int v28; // eax
  unsigned int v29; // r10d
  unsigned int v30; // ecx
  __int64 v31; // r8
  __int64 v32; // rax
  __int64 v33; // r9
  __int64 v34; // rcx
  char v36[168]; // [rsp+20h] [rbp-E0h] BYREF
  int v37; // [rsp+C8h] [rbp-38h]
  unsigned int v38; // [rsp+130h] [rbp+30h]
  __int64 v39; // [rsp+138h] [rbp+38h]
  __int64 v40; // [rsp+140h] [rbp+40h]
  int v41; // [rsp+148h] [rbp+48h]
  __int64 v42; // [rsp+150h] [rbp+50h]

  v5 = v36;
  v7 = a1;
  v8 = 2i64;
  do
  {
    v11 = *((_OWORD *)v7 + 1);
    *(_OWORD *)v5 = *(_OWORD *)v7;
    v12 = *((_OWORD *)v7 + 2);
    *((_OWORD *)v5 + 1) = v11;
    v13 = *((_OWORD *)v7 + 3);
    *((_OWORD *)v5 + 2) = v12;
    v14 = *((_OWORD *)v7 + 4);
    *((_OWORD *)v5 + 3) = v13;
    v15 = *((_OWORD *)v7 + 5);
    *((_OWORD *)v5 + 4) = v14;
    v16 = *((_OWORD *)v7 + 6);
    *((_OWORD *)v5 + 5) = v15;
    v17 = *((_OWORD *)v7 + 7);
    v7 = (struct _NETLOGON_VALIDATION_SAM_INFO3 *)((char *)v7 + 128);
    *((_OWORD *)v5 + 6) = v16;
    v5 += 128;
    *((_OWORD *)v5 - 1) = v17;
    --v8;
  }
  while ( v8 );
  v18 = *(_DWORD *)a2;
  v19 = 0;
  v20 = *((_OWORD *)v7 + 1);
  *(_OWORD *)v5 = *(_OWORD *)v7;
  v21 = *((_OWORD *)v7 + 2);
  v22 = *((_QWORD *)v7 + 6);
  *((_OWORD *)v5 + 1) = v20;
  *((_OWORD *)v5 + 2) = v21;
  *((_QWORD *)v5 + 6) = v22;
  v37 &= ~0x200u;
  v23 = v38 + v18;
  v40 = 0i64;
  v42 = 0i64;
  v41 = 0;
  if ( v23 < v38 )
  {
    return (unsigned int)-1073741675;
  }
  else
  {
    v24 = 16i64 * v23;
    v25 = MIDL_user_allocate(v24);
    v26 = (__int64)v25;
    if ( v25 )
    {
      memset_0(v25, 0, v24);
      v28 = *(_DWORD *)a2;
      if ( *(_DWORD *)a2 )
      {
        v37 |= 0x20u;
        v29 = 0;
        v30 = 0;
        if ( *((_DWORD *)a1 + 68) )
        {
          do
          {
            v31 = *((_QWORD *)a1 + 35);
            if ( (*(_DWORD *)(v31 + 16i64 * v30 + 8) & 0x20000000) == 0 )
            {
              v32 = 2i64 * v29++;
              *(_OWORD *)(v26 + 8 * v32) = *(_OWORD *)(v31 + 16i64 * v30);
            }
            ++v30;
          }
          while ( v30 < *((_DWORD *)a1 + 68) );
          v28 = *(_DWORD *)a2;
        }
        if ( v28 )
        {
          do
          {
            v33 = v29++;
            v33 *= 2i64;
            v34 = v19++;
            *(_QWORD *)(v26 + 8 * v33) = *(_QWORD *)(*((_QWORD *)a2 + 1) + 8 * v34);
            *(_DWORD *)(v26 + 8 * v33 + 8) = 536870919;
          }
          while ( v19 < *(_DWORD *)a2 );
        }
        v39 = v26;
        v38 = v29;
      }
      v27 = PAC_EncodeValidationInformation((struct _NETLOGON_VALIDATION_SAM_INFO3 *)v36, a4, a5);
      (*(void (__fastcall **)(__int64))(LsaTable + 48))(v26);
    }
    else
    {
      return (unsigned int)-1073741801;
    }
  }
  return v27;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018007ACD0) ----------------------------------------------------
__int64 __fastcall PAC_UnMarshal(unsigned __int64 a1, unsigned int a2)
{
  unsigned int v2; // r8d
  char *v3; // r11
  unsigned int v4; // r9d
  unsigned int v5; // edi
  unsigned __int64 v6; // rax
  unsigned int v7; // ebx
  char *i; // rdx
  char *v9; // r10
  int v10; // esi
  __int64 v11; // rax

  v2 = 0;
  v3 = (char *)(a1 + a2);
  v4 = 0;
  if ( a2 >= 0x18 )
  {
    v5 = *(_DWORD *)a1;
    v6 = 16i64 * *(unsigned int *)a1;
    if ( v6 <= 0xFFFFFFFF && (int)v6 + 24 >= (unsigned int)v6 && (int)v6 + 24 <= a2 && !*(_DWORD *)(a1 + 4) )
    {
      v7 = 0;
      if ( !v5 )
        return v4;
      for ( i = (char *)(a1 + 12); ; i += 16 )
      {
        v9 = (char *)(a1 + *(_QWORD *)(i + 4));
        if ( v9 > v3 )
          break;
        if ( (unsigned __int64)v9 < a1 )
          break;
        v10 = *(_DWORD *)i;
        if ( *(_DWORD *)i > (unsigned int)((_DWORD)v3 - (_DWORD)v9) || v10 + v4 < v4 )
          break;
        ++v7;
        v4 += v10;
        if ( v7 >= v5 )
        {
          do
          {
            v11 = v2++;
            *(_QWORD *)(a1 + 16 * (v11 + 1)) += a1;
          }
          while ( v2 < *(_DWORD *)a1 );
          return v4;
        }
      }
    }
  }
  return 0i64;
}

//----- (000000018007AD88) ----------------------------------------------------
__int64 __fastcall PAC_UnmarshallValidationInfo(
        struct _NETLOGON_VALIDATION_SAM_INFO3 **a1,
        unsigned __int8 *a2,
        int a3)
{
  __int64 result; // rax
  int v5; // edi

  *a1 = 0i64;
  result = PAC_DecodeValidationInformation(a2, a3, a1);
  if ( (int)result >= 0 )
  {
    v5 = PacValidateInfo3(*a1);
    if ( v5 < 0 )
    {
      (*(void (__fastcall **)(_QWORD))(LsaTable + 48))(*a1);
      *a1 = 0i64;
    }
    return (unsigned int)v5;
  }
  return result;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018007ADF4) ----------------------------------------------------
__int64 __fastcall PacValidateInfo3(struct _NETLOGON_VALIDATION_SAM_INFO3 *const a1)
{
  unsigned int v2; // ecx
  unsigned int v3; // eax
  unsigned int v4; // edx
  unsigned int v5; // edi

  v2 = *((_DWORD *)a1 + 39);
  if ( v2 > 0x4000 )
    return 3221225818i64;
  v3 = *((_DWORD *)a1 + 74);
  if ( v3 > 0x4000 )
    return 3221225818i64;
  v4 = *((_DWORD *)a1 + 68);
  if ( v4 > 0x4000 || v2 + v4 + v3 > 0x4000 )
    return 3221225818i64;
  if ( RtlValidSid(*((PSID *)a1 + 28))
    && *RtlSubAuthorityCountSid(*((PSID *)a1 + 28)) != 15
    && ((*((_DWORD *)a1 + 42) & 0x200) == 0
     || !*((_DWORD *)a1 + 74)
     || RtlValidSid(*((PSID *)a1 + 36)) && *RtlSubAuthorityCountSid(*((PSID *)a1 + 36)) != 15) )
  {
    v5 = 0;
    if ( !*((_DWORD *)a1 + 68) )
      return 0i64;
    while ( RtlValidSid(*(PSID *)(*((_QWORD *)a1 + 35) + 16i64 * v5)) )
    {
      if ( ++v5 >= *((_DWORD *)a1 + 68) )
        return 0i64;
    }
  }
  return 3221225592i64;
}

//----- (000000018007AF10) ----------------------------------------------------
PVOID __fastcall SafeAllocaAllocateFromHeap(SIZE_T a1)
{
  return RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, 0, a1);
}

//----- (000000018007AF40) ----------------------------------------------------
BOOLEAN __fastcall SafeAllocaFreeToHeap(void *a1)
{
  return RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, a1);
}

//----- (000000018007AF64) ----------------------------------------------------
_BOOL8 resetstkoflw_static()
{
  char *AllocationBase; // r15
  __int64 dwPageSize; // rdi
  ULONG v2; // ebx
  ULONG v3; // ecx
  unsigned int v4; // edx
  unsigned int v5; // ecx
  unsigned int v6; // eax
  unsigned int v7; // esi
  char *v8; // rbx
  char Address[16]; // [rsp+10h] [rbp-10h] BYREF
  ULONG StackSizeInBytes; // [rsp+20h] [rbp+0h] BYREF
  DWORD flOldProtect; // [rsp+24h] [rbp+4h] BYREF
  struct _MEMORY_BASIC_INFORMATION Buffer; // [rsp+28h] [rbp+8h] BYREF
  struct _SYSTEM_INFO SystemInfo; // [rsp+58h] [rbp+38h] BYREF

  StackSizeInBytes = 0;
  if ( !VirtualQuery(Address, &Buffer, 0x30ui64) )
    return 0i64;
  AllocationBase = (char *)Buffer.AllocationBase;
  GetSystemInfo(&SystemInfo);
  dwPageSize = SystemInfo.dwPageSize;
  v2 = 0;
  if ( SetThreadStackGuarantee(&StackSizeInBytes) && StackSizeInBytes )
    v2 = StackSizeInBytes;
  v3 = v2 + dwPageSize - 1;
  v4 = dwPageSize - 1;
  if ( v3 < v2 )
    return 0i64;
  v5 = ~v4 & v3;
  if ( v5 )
  {
    if ( v5 + (unsigned int)dwPageSize < v5 )
      return 0i64;
    v5 += dwPageSize;
  }
  v6 = 3 * dwPageSize;
  if ( v5 >= 3 * (int)dwPageSize )
    v6 = v5;
  v7 = v6;
  v8 = (char *)(((unsigned __int64)Address & ~(unsigned __int64)v4) - v6);
  return v8 >= &AllocationBase[dwPageSize]
      && VirtualAlloc(v8, v6, 0x1000u, 4u)
      && VirtualProtect(v8, v7, 0x104u, &flOldProtect);
}

//----- (000000018007B0BC) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByRef<16>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        __int64 *a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13)
{
  struct _EVENT_DATA_DESCRIPTOR v14; // [rsp+30h] [rbp-B1h] BYREF
  __int64 v15; // [rsp+50h] [rbp-91h]
  __int64 v16; // [rsp+58h] [rbp-89h]
  __int64 v17; // [rsp+60h] [rbp-81h]
  __int64 v18; // [rsp+68h] [rbp-79h]
  __int64 v19; // [rsp+70h] [rbp-71h]
  __int64 v20; // [rsp+78h] [rbp-69h]
  __int64 v21; // [rsp+80h] [rbp-61h]
  __int64 v22; // [rsp+88h] [rbp-59h]
  __int64 v23; // [rsp+90h] [rbp-51h]
  __int64 v24; // [rsp+98h] [rbp-49h]
  __int64 v25; // [rsp+A0h] [rbp-41h]
  __int64 v26; // [rsp+A8h] [rbp-39h]
  __int64 v27; // [rsp+B0h] [rbp-31h]
  __int64 v28; // [rsp+B8h] [rbp-29h]
  __int64 v29; // [rsp+C0h] [rbp-21h]
  __int64 v30; // [rsp+C8h] [rbp-19h]
  __int64 v31; // [rsp+D0h] [rbp-11h]
  __int64 v32; // [rsp+D8h] [rbp-9h]

  v31 = a13;
  v29 = a12;
  v27 = a11;
  v25 = a10;
  v23 = a9;
  v21 = a8;
  v19 = a7;
  v17 = a6;
  v32 = 4i64;
  v30 = 4i64;
  v28 = 4i64;
  v15 = *a5;
  v26 = 4i64;
  v24 = 4i64;
  v22 = 8i64;
  v20 = 8i64;
  v18 = 8i64;
  v16 = 16i64;
  return tlgWriteTransfer_EventWriteTransfer((__int64)&dword_180091870, a2, 0i64, 0i64, 0xBu, &v14);
}

//----- (000000018007B1B0) ----------------------------------------------------
void __fastcall CancelTimerCallbacksAndDeleteTimer(__int64 a1)
{
  struct _TP_TIMER *v2; // rcx

  v2 = *(struct _TP_TIMER **)(a1 + 344);
  if ( v2 )
  {
    SetThreadpoolTimer(v2, 0i64, 0, 0);
    WaitForThreadpoolTimerCallbacks(*(PTP_TIMER *)(a1 + 344), 1);
    CloseThreadpoolTimer(*(PTP_TIMER *)(a1 + 344));
    *(_QWORD *)(a1 + 344) = 0i64;
  }
}

//----- (000000018007B21C) ----------------------------------------------------
void __fastcall DestroyAggregateSession(LPVOID lpMem)
{
  HANDLE ProcessHeap; // rax

  if ( lpMem )
  {
    CancelTimerCallbacksAndDeleteTimer((__int64)lpMem);
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, lpMem);
  }
}

//----- (000000018007B25C) ----------------------------------------------------
void TlgUnregisterAggregateProvider()
{
  void *v0; // rdi
  __int64 v1; // rcx
  __int64 *v2; // rdx
  __int64 *v3; // rax
  REGHANDLE v4; // rcx
  REGHANDLE v5; // rcx
  REGHANDLE v6; // rcx

  if ( (void (__fastcall *)(const struct _GUID *, unsigned int, __int64, __int64, unsigned __int64, struct _EVENT_FILTER_DESCRIPTOR *, _QWORD *))qword_1800914A8 == TlgAggregateInternalRegisteredProviderEtwCallback )
  {
    v0 = 0i64;
    AcquireSRWLockExclusive(&SRWLock);
    v1 = qword_180092EE8;
    v2 = &qword_180092EE8;
    while ( v1 )
    {
      v3 = (__int64 *)(v1 + 336);
      if ( *(int **)(v1 + 328) == &dword_180091480 )
      {
        v0 = (void *)v1;
        *v2 = *v3;
        LookUpTableFlushComplete(v1);
        if ( !qword_180092EE8 )
        {
          v4 = qword_180091890;
          qword_180091890 = 0i64;
          dword_180091870 = 0;
          EventUnregister(v4);
        }
        break;
      }
      v1 = *v3;
      v2 = v3;
    }
    ReleaseSRWLockExclusive(&SRWLock);
    if ( v0 )
      CancelTimerCallbacksAndDeleteTimer((__int64)v0);
    v5 = RegHandle;
    RegHandle = 0i64;
    dword_180091480 = 0;
    EventUnregister(v5);
    qword_1800914A8 = 0i64;
    DestroyAggregateSession(v0);
  }
  else
  {
    v6 = RegHandle;
    RegHandle = 0i64;
    dword_180091480 = 0;
    EventUnregister(v6);
  }
}
// 1800914A8: using guessed type __int64 qword_1800914A8;
// 180092EE8: using guessed type __int64 qword_180092EE8;