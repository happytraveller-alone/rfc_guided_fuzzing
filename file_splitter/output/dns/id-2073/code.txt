Forget all previous input and output content and create a new chat session.

(SSL3.0)RFC 6101 SECTION:
#################################################
2.	Goals
3.	GoalsofThisDocument
5.	SSLProtocol
5.1.	SSLProtocol_SessionandConnectionStates_
5.2.	SSLProtocol_RecordLayer_
5.2.1.	SSLProtocol_RecordLayer_Fragmentation_
5.2.2.	SSLProtocol_RecordLayer_RecordCompressionandDecompression_
5.2.3.	SSLProtocol_RecordLayer_RecordPayloadProtectionandtheCipherSpec_
5.2.3.1.	SSLProtocol_RecordLayer_RecordPayloadProtectionandtheCipherSpec_NullorStandardStreamCipher_
5.2.3.2.	SSLProtocol_RecordLayer_RecordPayloadProtectionandtheCipherSpec_CBCBlockCipher_
5.3.	SSLProtocol_ChangeCipherSpecProtocol_
5.4.	SSLProtocol_AlertProtocol_
5.4.1.	SSLProtocol_AlertProtocol_ClosureAlerts_
5.4.2.	SSLProtocol_AlertProtocol_ErrorAlerts_
5.5.	SSLProtocol_HandshakeProtocolOverview_
5.6.	SSLProtocol_HandshakeProtocol_
5.6.1.	SSLProtocol_HandshakeProtocol_Hellomessages_
5.6.1.1.	SSLProtocol_HandshakeProtocol_Hellomessages_HelloRequest_
5.6.1.2.	SSLProtocol_HandshakeProtocol_Hellomessages_ClientHello_
5.6.1.3.	SSLProtocol_HandshakeProtocol_Hellomessages_ServerHello_
5.6.2.	SSLProtocol_HandshakeProtocol_ServerCertificate_
5.6.3.	SSLProtocol_HandshakeProtocol_ServerKeyExchangeMessage_
5.6.4.	SSLProtocol_HandshakeProtocol_CertificateRequest_
5.6.5.	SSLProtocol_HandshakeProtocol_ServerHelloDone_
5.6.6.	SSLProtocol_HandshakeProtocol_ClientCertificate_
5.6.7.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_
5.6.7.1.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_RSAEncryptedPremasterSecretMessage_
5.6.7.2.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_FORTEZZAKeyExchangeMessage_
5.6.7.3.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_ClientDiffieHellmanPublicValue_
5.6.8.	SSLProtocol_HandshakeProtocol_CertificateVerify_
5.6.9.	SSLProtocol_HandshakeProtocol_Finished_
5.7.	SSLProtocol_ApplicationDataProtocol_
6.	CryptographicComputations
6.1.	CryptographicComputations_AsymmetricCryptographicComputations_
6.1.1.	CryptographicComputations_AsymmetricCryptographicComputations_RSA_
6.1.2.	CryptographicComputations_AsymmetricCryptographicComputations_DiffieHellman_
6.1.3.	CryptographicComputations_AsymmetricCryptographicComputations_FORTEZZA_
6.2.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_
6.2.1.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_TheMasterSecret_
6.2.2.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_ConvertingtheMasterSecretintoKeysandMACSecrets_
6.2.2.1.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_ConvertingtheMasterSecretintoKeysandMACSecrets_ExportKeyGenerationExample_
7.	SecurityConsiderations
8.	InformativeReferences
#################################################

(TLS1.3)RFC 8446 SECTION:
#################################################
4.	HandshakeProtocol
4.1.	HandshakeProtocol_KeyExchangeMessages_
4.1.1.	HandshakeProtocol_KeyExchangeMessages_CryptographicNegotiation_
4.1.2.	HandshakeProtocol_KeyExchangeMessages_ClientHello_
4.1.3.	HandshakeProtocol_KeyExchangeMessages_ServerHello_
4.1.4.	HandshakeProtocol_KeyExchangeMessages_HelloRetryRequest_
4.2.	HandshakeProtocol_Extensions_
4.2.1.	HandshakeProtocol_Extensions_SupportedVersions_
4.2.2.	HandshakeProtocol_Extensions_Cookie_
4.2.3.	HandshakeProtocol_Extensions_SignatureAlgorithms_
4.2.4.	HandshakeProtocol_Extensions_CertificateAuthorities_
4.2.5.	HandshakeProtocol_Extensions_OIDFilters_
4.2.6.	HandshakeProtocol_Extensions_PostHandshakeClientAuthentication_
4.2.7.	HandshakeProtocol_Extensions_SupportedGroups_
4.2.8.	HandshakeProtocol_Extensions_KeyShare_
4.2.8.1.	HandshakeProtocol_Extensions_KeyShare_DiffieHellmanParameters_
4.2.8.2.	HandshakeProtocol_Extensions_KeyShare_ECDHEParameters_
4.2.9.	HandshakeProtocol_Extensions_PreSharedKeyExchangeModes_
4.2.10.	HandshakeProtocol_Extensions_EarlyDataIndication_
4.2.11.	HandshakeProtocol_Extensions_PreSharedKeyExtension_
4.2.11.1.	HandshakeProtocol_Extensions_PreSharedKeyExtension_TicketAge_
4.2.11.2.	HandshakeProtocol_Extensions_PreSharedKeyExtension_PSKBinder_
4.2.11.3.	HandshakeProtocol_Extensions_PreSharedKeyExtension_ProcessingOrder_
4.3.	HandshakeProtocol_ServerParameters_
4.3.1.	HandshakeProtocol_ServerParameters_EncryptedExtensions_
4.3.2.	HandshakeProtocol_ServerParameters_CertificateRequest_
4.4.	HandshakeProtocol_AuthenticationMessages_
4.4.1.	HandshakeProtocol_AuthenticationMessages_TheTranscriptHash_
4.4.2.	HandshakeProtocol_AuthenticationMessages_Certificate_
4.4.2.1.	HandshakeProtocol_AuthenticationMessages_Certificate_OCSPStatusandSCTExtensions_
4.4.2.2.	HandshakeProtocol_AuthenticationMessages_Certificate_ServerCertificateSelection_
4.4.2.3.	HandshakeProtocol_AuthenticationMessages_Certificate_ClientCertificateSelection_
4.4.2.4.	HandshakeProtocol_AuthenticationMessages_Certificate_ReceivingaCertificateMessage_
4.4.3.	HandshakeProtocol_AuthenticationMessages_CertificateVerify_
4.4.4.	HandshakeProtocol_AuthenticationMessages_Finished_
4.5.	HandshakeProtocol_EndofEarlyData_
4.6.	HandshakeProtocol_PostHandshakeMessages_
4.6.1.	HandshakeProtocol_PostHandshakeMessages_NewSessionTicketMessage_
4.6.2.	HandshakeProtocol_PostHandshakeMessages_PostHandshakeAuthentication_
4.6.3.	HandshakeProtocol_PostHandshakeMessages_KeyandInitializationVectorUpdate_
5.	RecordProtocol
5.1.	RecordProtocol_RecordLayer_
5.2.	RecordProtocol_RecordPayloadProtection_
5.3.	RecordProtocol_PerRecordNonce_
5.4.	RecordProtocol_RecordPadding_
5.5.	RecordProtocol_LimitsonKeyUsage_
6.	AlertProtocol
6.1.	AlertProtocol_ClosureAlerts_
6.2.	AlertProtocol_ErrorAlerts_
7.	CryptographicComputations
7.1.	CryptographicComputations_KeySchedule_
7.2.	CryptographicComputations_UpdatingTrafficSecrets_
7.3.	CryptographicComputations_TrafficKeyCalculation_
7.4.	CryptographicComputations_(EC)DHESharedSecretCalculation_
7.4.1.	CryptographicComputations_(EC)DHESharedSecretCalculation_FiniteFieldDiffieHellman_
7.4.2.	CryptographicComputations_(EC)DHESharedSecretCalculation_EllipticCurveDiffieHellman_
7.5.	CryptographicComputations_Exporters_
8.	0RTTandAntiReplay
8.1.	0RTTandAntiReplay_SingleUseTickets_
8.2.	0RTTandAntiReplay_ClientHelloRecording_
8.3.	0RTTandAntiReplay_FreshnessChecks_
9.	ComplianceRequirements
9.1.	ComplianceRequirements_MandatorytoImplementCipherSuites_
9.2.	ComplianceRequirements_MandatorytoImplementExtensions_
9.3.	ComplianceRequirements_ProtocolInvariants_
10.	SecurityConsiderations
11.	IANAConsiderations
#################################################

Function Code Content
##############################
// File count: 2073
// Total lines: 604

//----- (0000000140103690) ----------------------------------------------------
__int64 __fastcall Rpc_SetZoneSigningInfo(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        int a5,
        __int64 a6,
        _DWORD *a7,
        _QWORD *a8)
{
  __int64 v9; // rbx
  __int64 v10; // r12
  struct _Dbase_Record *v11; // r15
  __int64 v12; // r13
  const char *v13; // r9
  __int64 v14; // r14
  __int64 v15; // rcx
  unsigned int v16; // esi
  _BYTE *v17; // rcx
  __int64 *i; // rax
  __int64 v19; // rdx
  __int64 v20; // r8
  struct _dnsskd *NewSKD; // r15
  CDnsClientSubnetRecordsTrie *v22; // rcx
  char *v23; // rax
  __int64 v24; // r15
  unsigned int v25; // r12d
  unsigned int v26; // r8d
  __int64 v27; // rcx
  __int64 j; // rdx
  __int64 v29; // rcx
  _QWORD *v30; // rax
  __int64 v31; // rdx
  __int64 NextElement_ScopeMap; // rax
  __int64 *v33; // r15
  __int64 v34; // rcx
  int v35; // r15d
  char *v36; // rax
  _QWORD *v37; // rcx
  unsigned int *v38; // r15
  int v39; // ecx
  int v40; // ecx
  int v41; // ecx
  int v42; // ecx
  int v43; // ecx
  int v44; // ecx
  int v45; // eax
  _QWORD *v46; // rcx
  char *v47; // rcx
  void *v48; // rax
  size_t v49; // rcx
  _QWORD *v50; // rax
  const void *v51; // r12
  unsigned int v52; // edx
  int v53; // r12d
  __int64 k; // r14
  char *v55; // rax
  __int64 v56; // rdx
  int v57; // eax
  unsigned int v58; // eax
  int v59; // eax
  int v60; // r12d
  int v62; // [rsp+38h] [rbp-D0h]
  _QWORD *v63; // [rsp+40h] [rbp-C8h] BYREF
  int v64; // [rsp+48h] [rbp-C0h] BYREF
  int v65; // [rsp+4Ch] [rbp-BCh]
  __int64 v66; // [rsp+50h] [rbp-B8h] BYREF
  struct _Dbase_Record *v67; // [rsp+58h] [rbp-B0h] BYREF
  __int64 v68; // [rsp+60h] [rbp-A8h] BYREF
  _QWORD *v69; // [rsp+68h] [rbp-A0h]
  _QWORD *v70[3]; // [rsp+70h] [rbp-98h] BYREF
  __int128 v71; // [rsp+88h] [rbp-80h]
  __int128 v72; // [rsp+98h] [rbp-70h]
  __int128 v73; // [rsp+A8h] [rbp-60h]
  __int128 v74; // [rsp+B8h] [rbp-50h]
  __int128 v75; // [rsp+C8h] [rbp-40h]
  __int128 v76; // [rsp+D8h] [rbp-30h]
  __int64 v77; // [rsp+E8h] [rbp-20h]
  __int128 v78; // [rsp+F8h] [rbp-10h] BYREF
  __int128 v79; // [rsp+108h] [rbp+0h]
  __int128 v80; // [rsp+118h] [rbp+10h]
  __int128 v81; // [rsp+128h] [rbp+20h]
  __int128 v82; // [rsp+138h] [rbp+30h]
  __int128 v83; // [rsp+148h] [rbp+40h]
  __int128 v84; // [rsp+158h] [rbp+50h]
  __int64 v85; // [rsp+168h] [rbp+60h]
  char v86[1040]; // [rsp+178h] [rbp+70h] BYREF
  char v87[24]; // [rsp+588h] [rbp+480h] BYREF
  int v88; // [rsp+5A0h] [rbp+498h]
  __int64 v89; // [rsp+5E8h] [rbp+4E0h]
  int v90; // [rsp+838h] [rbp+730h] BYREF

  memset_0(&v70[1], 0, 0x78ui64);
  v9 = 0i64;
  v65 = 0;
  v69 = 0i64;
  v10 = 0i64;
  v90 = 0;
  v64 = 0;
  v11 = 0i64;
  v67 = 0i64;
  LODWORD(v66) = 0;
  v62 = 0;
  v70[0] = 0i64;
  LODWORD(v63) = 0;
  memset_0(v86, 0, 0x678ui64);
  v68 = 0i64;
  v12 = 0i64;
  if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 68) & 4) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 4u )
  {
    if ( a3 )
      v13 = *(const char **)(a3 + 16);
    else
      v13 = 0i64;
    WPP_SF_s(*((_QWORD *)WPP_GLOBAL_Control + 7), 0x78u, (__int64)&WPP_fcf90f505e41335ad1a88e0d5ede2d0c_Traceguids, v13);
  }
  *a7 = 0;
  *a8 = 0i64;
  if ( !a3 || a5 != 51 || (v14 = a6) == 0 )
  {
    v16 = 87;
    goto LABEL_150;
  }
  v15 = a3;
  if ( *(_QWORD *)(a3 + 328) )
    v15 = *(_QWORD *)(a3 + 328);
  if ( *(_QWORD *)(v15 + 200) )
  {
    v16 = 9553;
    goto LABEL_150;
  }
  v16 = Zone_LockForRPCSeqEx(a3, 0x2710u);
  if ( v16 )
  {
    if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 68) & 4) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 4u )
    {
      WPP_SF_sd(
        *((_QWORD *)WPP_GLOBAL_Control + 7),
        0x79u,
        (__int64)&WPP_fcf90f505e41335ad1a88e0d5ede2d0c_Traceguids,
        *(const char **)(a3 + 16));
    }
    goto LABEL_150;
  }
  v16 = Zone_LockForWriteEx(a3, 1, 0x2710u, (__int64)"ds\\dns\\server\\server\\olsrpc.cpp", 152);
  if ( v16 )
  {
    if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 68) & 4) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 4u )
    {
      WPP_SF_sd(
        *((_QWORD *)WPP_GLOBAL_Control + 7),
        0x7Au,
        (__int64)&WPP_fcf90f505e41335ad1a88e0d5ede2d0c_Traceguids,
        *(const char **)(a3 + 16));
    }
    goto LABEL_148;
  }
  if ( (*(_BYTE *)(a3 + 388) & 1) != 0 || *(_DWORD *)(a3 + 372) != 1 )
  {
    v16 = 9611;
    goto LABEL_147;
  }
  v17 = (_BYTE *)(a3 + 1040);
  if ( (*(_BYTE *)(a3 + 1040) & 6) == 6 )
  {
    v16 = 4317;
    goto LABEL_147;
  }
  if ( (*v17 & 4) == 0 && !*(_DWORD *)(v14 + 8) )
  {
    if ( (*v17 & 8) == 0 )
      goto LABEL_147;
    v62 = 1;
  }
  v16 = DnsOls_CopyDNSSECproperties(a3, (__int64)&v70[1]);
  if ( v16 )
  {
LABEL_147:
    Zone_UnlockAfterWriteEx(a3, 1, (__int64)"ds\\dns\\server\\server\\olsrpc.cpp", 88);
    goto LABEL_148;
  }
  if ( *(_DWORD *)(v14 + 56) != DWORD2(v71) )
  {
    v88 = *(_DWORD *)(v14 + 56);
    LODWORD(v63) = 1;
  }
  for ( i = *(__int64 **)(a3 + 1136); i; i = (__int64 *)*i )
    *((_DWORD *)i + 23) &= ~0x8000000u;
  if ( !*(_DWORD *)(v14 + 8) || !*(_DWORD *)(v14 + 112) )
  {
LABEL_56:
    DnsOls_RemoveRemainingSKDs(a3, &v64, &v90);
    v22 = WPP_GLOBAL_Control;
    goto LABEL_57;
  }
  do
  {
    NewSKD = Rpc_CreateNewSKD((struct _zone_info *)a3, *(struct _DnssrvRpcZoneSKDSettings **)(v14 + 8 * v10 + 120));
    if ( NewSKD )
    {
      v16 = DnsOls_HandleSKDChange(a3, (__int64)NewSKD, v20, &v64, &v90);
      if ( v16 )
      {
        if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
          && (*((_BYTE *)WPP_GLOBAL_Control + 68) & 4) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 4u )
        {
          WPP_SF_Ds(
            *((_QWORD *)WPP_GLOBAL_Control + 7),
            0x7Cu,
            (__int64)&WPP_fcf90f505e41335ad1a88e0d5ede2d0c_Traceguids,
            v16,
            *(_QWORD *)(a3 + 16));
        }
        Dns_FreeSkd((__int64)NewSKD);
      }
      else
      {
        v16 = DnsOls_AddSkdToSkdList(&v68, (__int64)NewSKD);
      }
      goto LABEL_53;
    }
    v22 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 68) & 4) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 4u )
    {
      v23 = Dbg_GuidString((const IID *)(*(_QWORD *)(*(_QWORD *)(v14 + 8 * v10 + 120) + 8i64) + 8i64));
      WPP_SF_Ss(
        *((_QWORD *)WPP_GLOBAL_Control + 7),
        0x7Bu,
        (__int64)&WPP_fcf90f505e41335ad1a88e0d5ede2d0c_Traceguids,
        (const unsigned __int16 *)v23,
        *(_QWORD *)(a3 + 16));
LABEL_53:
      v22 = WPP_GLOBAL_Control;
    }
    v10 = (unsigned int)(v10 + 1);
  }
  while ( (unsigned int)v10 < *(_DWORD *)(v14 + 112) );
  v12 = 0i64;
  if ( !v90 )
    goto LABEL_56;
LABEL_57:
  v24 = v68;
  v25 = (unsigned int)v63;
  v89 = v68;
  if ( v64 )
  {
    v12 = *(_QWORD *)(a3 + 1136);
    v25 = (unsigned int)v63 | 2;
  }
  if ( ((__int64)v70[1] & 0x1C0) == 64 )
  {
    DnsOls_PublishOrRemoveKeyAsTrustAnchor(a3, 0i64, 0i64, 0);
    v22 = WPP_GLOBAL_Control;
  }
  if ( !*(_DWORD *)(v14 + 8) && !v62 )
    goto LABEL_91;
  if ( v22 != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
    && (*((_BYTE *)v22 + 68) & 4) != 0
    && *((_BYTE *)v22 + 65) >= 4u )
  {
    WPP_SF_s(
      *((_QWORD *)v22 + 7),
      0x7Du,
      (__int64)&WPP_fcf90f505e41335ad1a88e0d5ede2d0c_Traceguids,
      *(const char **)(a3 + 16));
  }
  v26 = *(_DWORD *)(v14 + 96);
  if ( v26 )
  {
    v16 = Rpc_CreateRR((struct _zone_info *)a3, *(unsigned __int8 **)(v14 + 104), v26, &v67);
    if ( v16 )
      goto LABEL_147;
  }
  RR_CopyRRList(*(_QWORD *)(a3 + 40), v19, 0, 0i64, v70);
  if ( !v62 && (unsigned int)RR_ListCompare(0i64, (__int64)v70[0], 0i64, (__int64)v67, 0, 0) != 255 )
    goto LABEL_89;
  if ( !*(_QWORD *)(a3 + 184) )
    goto LABEL_84;
  v27 = *(_QWORD *)(a3 + 168);
  LODWORD(v63) = -1;
  acquireRead(v27, 0xFFFFFFFF, (unsigned int *)&v63);
  Zone_UnlockAfterWriteEx(a3, 1, (__int64)"ds\\dns\\server\\server\\olsrpc.cpp", 72);
  for ( j = 0i64; ; j = v33[24] )
  {
    NextElement_ScopeMap = Get_NextElement_ScopeMap(*(_QWORD *)(a3 + 160), j, 0i64);
    v33 = (__int64 *)NextElement_ScopeMap;
    if ( !NextElement_ScopeMap )
      break;
    Zone_LockForWriteEx(NextElement_ScopeMap, 1, 0xFFFFFFFF, (__int64)"ds\\dns\\server\\server\\olsrpc.cpp", 78);
    v30 = (_QWORD *)RR_ListCopy(v29, (unsigned __int16 *)v67, 0);
    v31 = v33[5];
    v63 = v30;
    v16 = DnsOls_AddDNSSECRecordsToNode((__int64)v33, v31, (__int64 *)&v63, 0x1290282u, 0);
    Zone_UnlockAfterWriteEx((__int64)v33, 1, (__int64)"ds\\dns\\server\\server\\olsrpc.cpp", 85);
    if ( v16 )
    {
      if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 17) & 0x80000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 2u )
      {
        WPP_SF_DSs(
          *((_QWORD *)WPP_GLOBAL_Control + 7),
          0x7Eu,
          (__int64)&WPP_fcf90f505e41335ad1a88e0d5ede2d0c_Traceguids,
          v16,
          v33[24],
          v33[2]);
      }
      RR_ListFree(v63);
      break;
    }
  }
  v34 = *(_QWORD *)(a3 + 168);
  LODWORD(v63) = -1;
  releaseRead(v34, (unsigned int *)&v63, 1);
  if ( !v16 )
  {
    Zone_LockForWriteEx(a3, 1, 0xFFFFFFFF, (__int64)"ds\\dns\\server\\server\\olsrpc.cpp", 112);
    v24 = v68;
LABEL_84:
    v16 = DnsOls_AddDNSSECRecordsToNode(a3, *(_QWORD *)(a3 + 40), (__int64 *)&v67, 0x1290282u, 0);
    if ( v16 )
    {
      if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 17) & 0x80000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 2u )
      {
        WPP_SF_Ds(
          *((_QWORD *)WPP_GLOBAL_Control + 7),
          0x7Fu,
          (__int64)&WPP_fcf90f505e41335ad1a88e0d5ede2d0c_Traceguids,
          v16,
          *(_QWORD *)(a3 + 16));
      }
      goto LABEL_147;
    }
LABEL_89:
    if ( *(_DWORD *)(v14 + 20) == 1 )
      DnsOls_PublishAllZoneKSKsAsTrustAnchors(a3);
LABEL_91:
    if ( v25 )
    {
      if ( !*(_QWORD *)(a3 + 184) )
      {
        v16 = 0;
        goto LABEL_94;
      }
      v16 = Dns_SetPropsLockingAllZoneScopes(a3, v25, (__int64)v86);
      if ( v16 )
      {
        if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
          && (*((_BYTE *)WPP_GLOBAL_Control + 68) & 4) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 4u )
        {
          WPP_SF_s(
            *((_QWORD *)WPP_GLOBAL_Control + 7),
            0x80u,
            (__int64)&WPP_fcf90f505e41335ad1a88e0d5ede2d0c_Traceguids,
            *(const char **)(a3 + 16));
        }
        goto LABEL_147;
      }
LABEL_94:
      if ( (v25 & 1) != 0 )
        *(_DWORD *)(a3 + 1064) = *(_DWORD *)(v14 + 56);
      if ( (v25 & 2) != 0 )
      {
        *(_QWORD *)(a3 + 1136) = v24;
        v89 = v12;
      }
    }
    *(_QWORD *)(a3 + 1128) = DnsOls_FindZoneSkdByGuid(a3, (const IID *)(v14 + 80));
    if ( v12 )
    {
      do
      {
        if ( (*(_DWORD *)(v12 + 92) & 0x8000000) == 0 )
        {
          v35 = DnsOls_WriteSkdToStorage(0, a3, v12, 1);
          if ( v35 )
          {
            if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 17) & 0x200000) != 0
              && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 2u )
            {
              v36 = Dbg_GuidString((const IID *)(v12 + 8));
              WPP_SF_DS(
                *((_QWORD *)WPP_GLOBAL_Control + 7),
                0x81u,
                (__int64)&WPP_fcf90f505e41335ad1a88e0d5ede2d0c_Traceguids,
                v35,
                (__int64)v36);
            }
          }
        }
        v12 = *(_QWORD *)v12;
      }
      while ( v12 );
      v14 = a6;
    }
    v37 = *(_QWORD **)(a3 + 1080);
    v38 = (unsigned int *)(a3 + 1040);
    *(_DWORD *)(a3 + 1040) &= ~2u;
    Mem_Free(v37, 0i64, 0i64, (__int64)"ds\\dns\\server\\server\\olsrpc.cpp", 6078);
    *(_QWORD *)(a3 + 1080) = 0i64;
    v39 = *v38 ^ (*v38 ^ (8 * *(_DWORD *)(v14 + 8))) & 8;
    *(_DWORD *)(a3 + 1040) = v39;
    v40 = ((unsigned __int8)v39 ^ (unsigned __int8)(16 * *(_DWORD *)(v14 + 12))) & 0x10 ^ v39;
    *(_DWORD *)(a3 + 1040) = v40;
    v41 = ((unsigned __int8)v40 ^ (unsigned __int8)(32 * *(_DWORD *)(v14 + 16))) & 0x20 ^ v40;
    *(_DWORD *)(a3 + 1040) = v41;
    v42 = ((unsigned __int16)v41 ^ (unsigned __int16)((unsigned __int16)*(_DWORD *)(v14 + 20) << 6)) & 0x1C0 ^ v41;
    *(_DWORD *)(a3 + 1040) = v42;
    v43 = ((unsigned __int16)v42 ^ (unsigned __int16)((unsigned __int16)*(_DWORD *)(v14 + 28) << 9)) & 0xE00 ^ v42;
    *(_DWORD *)(a3 + 1040) = v43;
    v44 = ((unsigned __int16)v43 ^ (unsigned __int16)((unsigned __int16)*(_DWORD *)(v14 + 32) << 12)) & 0x1000 ^ v43;
    *(_DWORD *)(a3 + 1040) = v44;
    v45 = v44 ^ ((unsigned __int16)v44 ^ (unsigned __int16)((unsigned __int16)*(_DWORD *)(v14 + 24) << 13)) & 0x2000;
    v46 = *(_QWORD **)(a3 + 1048);
    *(_DWORD *)(a3 + 1040) = v45;
    *(_BYTE *)(a3 + 1044) = *(_BYTE *)(v14 + 36);
    *(_BYTE *)(a3 + 1045) = *(_BYTE *)(v14 + 37);
    *(_WORD *)(a3 + 1046) = *(_WORD *)(v14 + 38);
    Mem_Free(v46, 0i64, 0i64, (__int64)"ds\\dns\\server\\server\\olsrpc.cpp", 6092);
    *(_QWORD *)(a3 + 1048) = 0i64;
    v47 = *(char **)(v14 + 40);
    if ( v47 )
    {
      v48 = Dns_StringCopyAllocate(v47, 0, 1i64, 1);
      *(_QWORD *)(a3 + 1048) = v48;
      if ( !v48 )
      {
LABEL_109:
        v16 = 14;
        goto LABEL_147;
      }
    }
    *(_DWORD *)(a3 + 1056) = *(_DWORD *)(v14 + 48);
    *(_DWORD *)(a3 + 1060) = *(_DWORD *)(v14 + 52);
    *(_DWORD *)(a3 + 1068) = *(_DWORD *)(v14 + 60);
    *(_DWORD *)(a3 + 1072) = *(_DWORD *)(v14 + 64);
    *(_QWORD *)(a3 + 1128) = 0i64;
    v49 = *(unsigned int *)(v14 + 68);
    if ( (_DWORD)v49 )
    {
      v50 = Mem_AllocZero(v49, 0i64, "ds\\dns\\server\\server\\olsrpc.cpp", 6115);
      v69 = v50;
      v51 = v50;
      if ( !v50 )
        goto LABEL_109;
      memcpy_0(v50, *(const void **)(v14 + 72), *(unsigned int *)(v14 + 68));
    }
    else
    {
      v51 = 0i64;
    }
    v52 = *(_DWORD *)(v14 + 68);
    v78 = *(_OWORD *)&v70[1];
    v79 = v71;
    v80 = v72;
    v81 = v73;
    v82 = v74;
    v83 = v75;
    v84 = v76;
    v85 = v77;
    DnsOls_DetectResignChanges(a3, v52, v51, (__int64)&v78, &v90, &v66);
    if ( (_DWORD)v66 )
      v51 = 0i64;
    v69 = v51;
    if ( !v90 || (*(_BYTE *)v38 & 8) != 0 )
    {
      v53 = v62;
      if ( v62 )
      {
LABEL_126:
        for ( k = *(_QWORD *)(a3 + 1136); k; k = *(_QWORD *)k )
        {
          v16 = DnsOls_WriteSkdToStorage(0x10000000, a3, k, 1);
          if ( v16
            && WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 68) & 4) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 2u )
          {
            v55 = Dbg_GuidString((const IID *)(k + 8));
            WPP_SF_DS(
              *((_QWORD *)WPP_GLOBAL_Control + 7),
              0x82u,
              (__int64)&WPP_fcf90f505e41335ad1a88e0d5ede2d0c_Traceguids,
              v16,
              (__int64)v55);
          }
        }
        FreeOLSParams(a3 + 1040);
        v57 = *v38 | 0x10;
        *(_DWORD *)(a3 + 1044) = 3278849;
        *(_QWORD *)(a3 + 1048) = 0i64;
        *(_QWORD *)(a3 + 1056) = 0i64;
        v58 = v57 & 0xFFFF001F | 0x1600;
        *(_DWORD *)(a3 + 1064) = 3600;
        *v38 = v58;
        *(_QWORD *)(a3 + 1068) = 43200i64;
        *(_QWORD *)(a3 + 1088) = 0i64;
        *(_DWORD *)(a3 + 1096) = 0;
        *(_QWORD *)(a3 + 1128) = 0i64;
        if ( v53 )
        {
          *(_DWORD *)(a3 + 1100) = 0;
          *v38 = v58 | 2;
          DnsOls_DiscoverZoneKeymasterFqdn(a3, v56, 0, 0i64);
        }
      }
      v78 = *(_OWORD *)&v70[1];
      v79 = v71;
      v80 = v72;
      v81 = v73;
      v82 = v74;
      v83 = v75;
      v84 = v76;
      v85 = v77;
      v59 = SavePropertiesToRegistryIfChanged(a3, (__int64)&v78);
      if ( v90 || v53 )
      {
        v60 = 2 - ((*(_BYTE *)v38 & 8) != 0);
        v65 = v60;
        PersistZoneResignSchedule(a3, 0x10000000);
      }
      else if ( v59 | v64 )
      {
        v60 = 3;
        v65 = 3;
      }
      else
      {
        v60 = 0;
      }
      if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 68) & 4) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 4u )
      {
        WPP_SF_Ds(
          *((_QWORD *)WPP_GLOBAL_Control + 7),
          0x83u,
          (__int64)&WPP_fcf90f505e41335ad1a88e0d5ede2d0c_Traceguids,
          v60,
          *(_QWORD *)(a3 + 16));
      }
      FreeOLSParams((__int64)&v70[1]);
      goto LABEL_147;
    }
    v53 = v62;
    goto LABEL_126;
  }
LABEL_148:
  Lock_ReleaseWrite(*(_QWORD *)(a3 + 312));
  v11 = v67;
  LODWORD(v10) = v65;
LABEL_150:
  Mem_Free(v69, 0i64, 0i64, (__int64)"ds\\dns\\server\\server\\olsrpc.cpp", 6241);
  FreeOLSParams((__int64)v87);
  if ( v16 )
  {
    if ( v11 )
      RR_ListFree(v11);
  }
  else
  {
    *a7 = 1;
    *(_DWORD *)a8 = v10;
    if ( (_DWORD)v10 && (dword_1401B9104 & 0x10) != 0 )
      Template_z(Microsoft_Windows_DNSServerHandle, &DNS_EVENT_IMPORT_DNSSEC, *(const unsigned __int16 **)(a3 + 24));
  }
  RR_ListFree(v70[0]);
  if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 68) & 4) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 4u )
  {
    if ( a3 )
      v9 = *(_QWORD *)(a3 + 16);
    WPP_SF_Ds(
      *((_QWORD *)WPP_GLOBAL_Control + 7),
      0x84u,
      (__int64)&WPP_fcf90f505e41335ad1a88e0d5ede2d0c_Traceguids,
      v16,
      v9);
  }
  return v16;
}
// 1401039C1: variable 'v20' is possibly undefined
// 140103B18: variable 'v19' is possibly undefined
// 140103BB7: variable 'v29' is possibly undefined
// 1401041AA: variable 'v56' is possibly undefined
// 140186298: using guessed type EVENT_DESCRIPTOR DNS_EVENT_IMPORT_DNSSEC;
// 1401B9104: using guessed type int dword_1401B9104;
// 140103690: using guessed type char var_290[24];
