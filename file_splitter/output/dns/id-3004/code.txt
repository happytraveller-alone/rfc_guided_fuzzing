Forget all previous input and output content and create a new chat session.

(SSL3.0)RFC 6101 SECTION:
#################################################
2.	Goals
3.	GoalsofThisDocument
5.	SSLProtocol
5.1.	SSLProtocol_SessionandConnectionStates_
5.2.	SSLProtocol_RecordLayer_
5.2.1.	SSLProtocol_RecordLayer_Fragmentation_
5.2.2.	SSLProtocol_RecordLayer_RecordCompressionandDecompression_
5.2.3.	SSLProtocol_RecordLayer_RecordPayloadProtectionandtheCipherSpec_
5.2.3.1.	SSLProtocol_RecordLayer_RecordPayloadProtectionandtheCipherSpec_NullorStandardStreamCipher_
5.2.3.2.	SSLProtocol_RecordLayer_RecordPayloadProtectionandtheCipherSpec_CBCBlockCipher_
5.3.	SSLProtocol_ChangeCipherSpecProtocol_
5.4.	SSLProtocol_AlertProtocol_
5.4.1.	SSLProtocol_AlertProtocol_ClosureAlerts_
5.4.2.	SSLProtocol_AlertProtocol_ErrorAlerts_
5.5.	SSLProtocol_HandshakeProtocolOverview_
5.6.	SSLProtocol_HandshakeProtocol_
5.6.1.	SSLProtocol_HandshakeProtocol_Hellomessages_
5.6.1.1.	SSLProtocol_HandshakeProtocol_Hellomessages_HelloRequest_
5.6.1.2.	SSLProtocol_HandshakeProtocol_Hellomessages_ClientHello_
5.6.1.3.	SSLProtocol_HandshakeProtocol_Hellomessages_ServerHello_
5.6.2.	SSLProtocol_HandshakeProtocol_ServerCertificate_
5.6.3.	SSLProtocol_HandshakeProtocol_ServerKeyExchangeMessage_
5.6.4.	SSLProtocol_HandshakeProtocol_CertificateRequest_
5.6.5.	SSLProtocol_HandshakeProtocol_ServerHelloDone_
5.6.6.	SSLProtocol_HandshakeProtocol_ClientCertificate_
5.6.7.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_
5.6.7.1.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_RSAEncryptedPremasterSecretMessage_
5.6.7.2.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_FORTEZZAKeyExchangeMessage_
5.6.7.3.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_ClientDiffieHellmanPublicValue_
5.6.8.	SSLProtocol_HandshakeProtocol_CertificateVerify_
5.6.9.	SSLProtocol_HandshakeProtocol_Finished_
5.7.	SSLProtocol_ApplicationDataProtocol_
6.	CryptographicComputations
6.1.	CryptographicComputations_AsymmetricCryptographicComputations_
6.1.1.	CryptographicComputations_AsymmetricCryptographicComputations_RSA_
6.1.2.	CryptographicComputations_AsymmetricCryptographicComputations_DiffieHellman_
6.1.3.	CryptographicComputations_AsymmetricCryptographicComputations_FORTEZZA_
6.2.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_
6.2.1.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_TheMasterSecret_
6.2.2.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_ConvertingtheMasterSecretintoKeysandMACSecrets_
6.2.2.1.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_ConvertingtheMasterSecretintoKeysandMACSecrets_ExportKeyGenerationExample_
7.	SecurityConsiderations
8.	InformativeReferences
#################################################

(TLS1.3)RFC 8446 SECTION:
#################################################
4.	HandshakeProtocol
4.1.	HandshakeProtocol_KeyExchangeMessages_
4.1.1.	HandshakeProtocol_KeyExchangeMessages_CryptographicNegotiation_
4.1.2.	HandshakeProtocol_KeyExchangeMessages_ClientHello_
4.1.3.	HandshakeProtocol_KeyExchangeMessages_ServerHello_
4.1.4.	HandshakeProtocol_KeyExchangeMessages_HelloRetryRequest_
4.2.	HandshakeProtocol_Extensions_
4.2.1.	HandshakeProtocol_Extensions_SupportedVersions_
4.2.2.	HandshakeProtocol_Extensions_Cookie_
4.2.3.	HandshakeProtocol_Extensions_SignatureAlgorithms_
4.2.4.	HandshakeProtocol_Extensions_CertificateAuthorities_
4.2.5.	HandshakeProtocol_Extensions_OIDFilters_
4.2.6.	HandshakeProtocol_Extensions_PostHandshakeClientAuthentication_
4.2.7.	HandshakeProtocol_Extensions_SupportedGroups_
4.2.8.	HandshakeProtocol_Extensions_KeyShare_
4.2.8.1.	HandshakeProtocol_Extensions_KeyShare_DiffieHellmanParameters_
4.2.8.2.	HandshakeProtocol_Extensions_KeyShare_ECDHEParameters_
4.2.9.	HandshakeProtocol_Extensions_PreSharedKeyExchangeModes_
4.2.10.	HandshakeProtocol_Extensions_EarlyDataIndication_
4.2.11.	HandshakeProtocol_Extensions_PreSharedKeyExtension_
4.2.11.1.	HandshakeProtocol_Extensions_PreSharedKeyExtension_TicketAge_
4.2.11.2.	HandshakeProtocol_Extensions_PreSharedKeyExtension_PSKBinder_
4.2.11.3.	HandshakeProtocol_Extensions_PreSharedKeyExtension_ProcessingOrder_
4.3.	HandshakeProtocol_ServerParameters_
4.3.1.	HandshakeProtocol_ServerParameters_EncryptedExtensions_
4.3.2.	HandshakeProtocol_ServerParameters_CertificateRequest_
4.4.	HandshakeProtocol_AuthenticationMessages_
4.4.1.	HandshakeProtocol_AuthenticationMessages_TheTranscriptHash_
4.4.2.	HandshakeProtocol_AuthenticationMessages_Certificate_
4.4.2.1.	HandshakeProtocol_AuthenticationMessages_Certificate_OCSPStatusandSCTExtensions_
4.4.2.2.	HandshakeProtocol_AuthenticationMessages_Certificate_ServerCertificateSelection_
4.4.2.3.	HandshakeProtocol_AuthenticationMessages_Certificate_ClientCertificateSelection_
4.4.2.4.	HandshakeProtocol_AuthenticationMessages_Certificate_ReceivingaCertificateMessage_
4.4.3.	HandshakeProtocol_AuthenticationMessages_CertificateVerify_
4.4.4.	HandshakeProtocol_AuthenticationMessages_Finished_
4.5.	HandshakeProtocol_EndofEarlyData_
4.6.	HandshakeProtocol_PostHandshakeMessages_
4.6.1.	HandshakeProtocol_PostHandshakeMessages_NewSessionTicketMessage_
4.6.2.	HandshakeProtocol_PostHandshakeMessages_PostHandshakeAuthentication_
4.6.3.	HandshakeProtocol_PostHandshakeMessages_KeyandInitializationVectorUpdate_
5.	RecordProtocol
5.1.	RecordProtocol_RecordLayer_
5.2.	RecordProtocol_RecordPayloadProtection_
5.3.	RecordProtocol_PerRecordNonce_
5.4.	RecordProtocol_RecordPadding_
5.5.	RecordProtocol_LimitsonKeyUsage_
6.	AlertProtocol
6.1.	AlertProtocol_ClosureAlerts_
6.2.	AlertProtocol_ErrorAlerts_
7.	CryptographicComputations
7.1.	CryptographicComputations_KeySchedule_
7.2.	CryptographicComputations_UpdatingTrafficSecrets_
7.3.	CryptographicComputations_TrafficKeyCalculation_
7.4.	CryptographicComputations_(EC)DHESharedSecretCalculation_
7.4.1.	CryptographicComputations_(EC)DHESharedSecretCalculation_FiniteFieldDiffieHellman_
7.4.2.	CryptographicComputations_(EC)DHESharedSecretCalculation_EllipticCurveDiffieHellman_
7.5.	CryptographicComputations_Exporters_
8.	0RTTandAntiReplay
8.1.	0RTTandAntiReplay_SingleUseTickets_
8.2.	0RTTandAntiReplay_ClientHelloRecording_
8.3.	0RTTandAntiReplay_FreshnessChecks_
9.	ComplianceRequirements
9.1.	ComplianceRequirements_MandatorytoImplementCipherSuites_
9.2.	ComplianceRequirements_MandatorytoImplementExtensions_
9.3.	ComplianceRequirements_ProtocolInvariants_
10.	SecurityConsiderations
11.	IANAConsiderations
#################################################

Function Code Content
##############################
// File count: 3004
// Total lines: 276

//----- (000000014015A6A8) ----------------------------------------------------
__int64 __fastcall Dns_ServerNegotiateTkey(__int128 *a1, char *a2, __int64 a3, unsigned __int64 a4, int a5, _QWORD *a6)
{
  char *SecurityContext; // rdi
  __int64 v8; // rsi
  unsigned __int16 v9; // r15
  int v13; // r9d
  unsigned int GssTkeyFromMessage; // eax
  unsigned int v15; // ebx
  __int64 v16; // rdx
  __int128 v17; // xmm1
  __int128 v18; // xmm0
  __int128 v19; // xmm3
  __int128 v20; // xmm2
  __int64 v21; // rax
  __int64 v22; // rdx
  __int64 v23; // r8
  const char *v24; // rax
  const char *v25; // rax
  unsigned int v26; // eax
  int v27; // r9d
  unsigned __int64 v28; // r12
  __int64 v29; // rdx
  __int64 v30; // rcx
  unsigned int GssTsigFromMessage; // eax
  __int64 v32; // r8
  unsigned int v33; // eax
  unsigned int v34; // eax
  int v35; // r14d
  const char *v36; // rcx
  const char *v37; // r12
  const char *v38; // rax
  __int64 v39; // rdx
  __int64 v40; // rcx
  __int64 v41; // [rsp+28h] [rbp-E0h]
  __int64 v42; // [rsp+30h] [rbp-D8h]
  __int128 v43; // [rsp+48h] [rbp-C0h] BYREF
  __int128 v44; // [rsp+58h] [rbp-B0h]
  __int128 v45; // [rsp+68h] [rbp-A0h]
  __int128 v46; // [rsp+78h] [rbp-90h]
  __int128 v47; // [rsp+88h] [rbp-80h]
  __int64 v48; // [rsp+98h] [rbp-70h]
  __int64 v49[8]; // [rsp+A8h] [rbp-60h] BYREF
  __int64 v50; // [rsp+E8h] [rbp-20h]
  __int64 v51; // [rsp+F0h] [rbp-18h]
  __int16 v52; // [rsp+132h] [rbp+2Ah]
  int v53; // [rsp+134h] [rbp+2Ch]
  __int128 Buf1[5]; // [rsp+138h] [rbp+30h] BYREF
  __int64 v55; // [rsp+188h] [rbp+80h]
  __int128 v56[5]; // [rsp+198h] [rbp+90h] BYREF
  __int64 v57; // [rsp+1E8h] [rbp+E0h]

  SecurityContext = 0i64;
  v8 = 0i64;
  v9 = 0;
  if ( (byte_1401BA001 & 0x20) != 0 )
    WPP_SF_(142i64, (unsigned __int16)&WPP_9b9f12dbc4273be48aea1d81c92c8dd1_Traceguids, a3);
  if ( !g_fSecurityPackageInitialized )
    return 5i64;
  memset_0(v49, 0, 0x90ui64);
  v49[0] = 0i64;
  GssTkeyFromMessage = Dns_ExtractGssTkeyFromMessage((__int64)v49, (__int64)a2, a3, v13);
  v15 = GssTkeyFromMessage;
  if ( GssTkeyFromMessage )
  {
    if ( (byte_1401BA001 & 0x20) != 0 )
      WPP_SF_qdD(
        143i64,
        (unsigned __int16)&WPP_9b9f12dbc4273be48aea1d81c92c8dd1_Traceguids,
        (__int64)a2,
        GssTkeyFromMessage,
        GssTkeyFromMessage);
    goto LABEL_8;
  }
  memset_0(&v43, 0, 0x58ui64);
  v17 = a1[2];
  v18 = a1[3];
  *(_QWORD *)&v47 = v51;
  v19 = *a1;
  v20 = a1[1];
  v45 = v17;
  v46 = v18;
  Buf1[2] = v17;
  Buf1[3] = v18;
  Buf1[4] = v47;
  v55 = v48;
  v43 = v19;
  v44 = v20;
  Buf1[0] = v19;
  Buf1[1] = v20;
  v21 = Dns_DequeueSecurityContextByKey(Buf1, 0);
  SecurityContext = (char *)v21;
  if ( v21 )
  {
    v8 = v21;
    if ( (byte_1401BA001 & 0x20) != 0 )
    {
      v24 = DnsAddr_Ntoa((struct in_addr *)&v43);
      WPP_SF_ss(144i64, (unsigned __int16)&WPP_9b9f12dbc4273be48aea1d81c92c8dd1_Traceguids, v47, v24, v41);
    }
    if ( !*((_DWORD *)SecurityContext + 37) )
      goto LABEL_26;
    if ( (byte_1401BA001 & 0x20) != 0 )
    {
      v25 = DnsAddr_Ntoa((struct in_addr *)&v43);
      WPP_SF_ss(145i64, (unsigned __int16)&WPP_9b9f12dbc4273be48aea1d81c92c8dd1_Traceguids, v47, v25, v41);
    }
    if ( *((_DWORD *)SecurityContext + 32) != 3 )
    {
      if ( (byte_1401BA001 & 0x20) != 0 )
        WPP_SF_(147i64, (unsigned __int16)&WPP_9b9f12dbc4273be48aea1d81c92c8dd1_Traceguids, v23);
      SecurityContext = 0i64;
      v9 = 17;
      v15 = 9017;
      goto LABEL_9;
    }
    if ( (byte_1401BA001 & 0x20) != 0 )
      WPP_SF_(146i64, (unsigned __int16)&WPP_9b9f12dbc4273be48aea1d81c92c8dd1_Traceguids, v23);
  }
  v56[0] = v43;
  v56[1] = v44;
  v56[2] = v45;
  v56[3] = v46;
  v56[4] = v47;
  v57 = v48;
  SecurityContext = Dns_FindOrCreateSecurityContext((__int64)v56, v22, v23);
  if ( !SecurityContext )
  {
    v15 = 14;
    goto LABEL_9;
  }
  *((_DWORD *)SecurityContext + 32) = v53;
LABEL_26:
  v49[0] = (__int64)SecurityContext;
  v26 = Dns_ServerAcceptSecurityContext((__int64)v49, v22, v23);
  if ( v26 )
  {
    if ( v26 != 9801 )
    {
      if ( (byte_1401BA003 & 0x10) != 0 )
        WPP_SF_D(148i64, (unsigned __int16)&WPP_9b9f12dbc4273be48aea1d81c92c8dd1_Traceguids, v26, v27);
      v15 = 9017;
      goto LABEL_9;
    }
    v28 = a4;
    v15 = Dns_WriteGssTkeyToMessage((__int64)v49, (__int64)a2, a4, a6);
    if ( v15 )
    {
      v15 = 2;
      goto LABEL_9;
    }
    if ( !*((_DWORD *)SecurityContext + 37) )
    {
LABEL_34:
      if ( (char *)v8 != SecurityContext )
        Dns_FreeSecurityContext(v8);
      if ( (byte_1401BA001 & 0x20) != 0 )
        WPP_SF_q(152i64, (unsigned __int16)&WPP_9b9f12dbc4273be48aea1d81c92c8dd1_Traceguids, (__int64)SecurityContext);
      v30 = (__int64)SecurityContext;
      goto LABEL_39;
    }
    goto LABEL_48;
  }
  GssTsigFromMessage = Dns_ExtractGssTsigFromMessage((__int64)v49, (__int64)a2, a3);
  v15 = GssTsigFromMessage;
  if ( GssTsigFromMessage )
  {
    if ( GssTsigFromMessage == 9505 )
    {
      v15 = 0;
      goto LABEL_47;
    }
    goto LABEL_46;
  }
  v33 = Dns_VerifySignatureOnPacket((__int64)v49, v29, v32);
  v15 = v33;
  if ( v33 )
  {
    if ( (byte_1401BA001 & 0x20) != 0 )
    {
      LODWORD(v41) = v33;
      WPP_SF_qdD(149i64, (unsigned __int16)&WPP_9b9f12dbc4273be48aea1d81c92c8dd1_Traceguids, (__int64)a2, v33, v41);
    }
    v15 = 9016;
LABEL_46:
    v9 = 16;
  }
LABEL_47:
  v28 = a4;
LABEL_48:
  if ( (byte_1401BA001 & 0x20) != 0 )
  {
    LODWORD(v41) = v15;
    WPP_SF_qdDd(0x96u, v29, (__int64)a2, v15, v41, v9);
  }
  a2[2] |= 0x80u;
  v34 = Dns_SignMessageWithGssTsig(v49, a2, v28, a6);
  v15 = v34;
  if ( !v34 )
    goto LABEL_34;
  if ( (byte_1401BA001 & 4) != 0 )
  {
    LODWORD(v41) = v34;
    WPP_SF_qdD(151i64, (unsigned __int16)&WPP_9b9f12dbc4273be48aea1d81c92c8dd1_Traceguids, (__int64)a2, v34, v41);
  }
  v15 = 0;
LABEL_8:
  if ( !v15 )
    goto LABEL_34;
LABEL_9:
  v16 = v50;
  if ( v50 )
  {
    if ( !v52 )
    {
      if ( !v9 )
      {
        v9 = 17;
        if ( v15 == 9017 )
          v9 = 17;
      }
      *(_WORD *)(*(_QWORD *)(v50 + 48) - 4i64) = __ROL2__(v9, 8);
    }
    v15 = 5;
  }
  else
  {
    v15 = 1;
  }
  if ( (byte_1401BA001 & 0x20) != 0 )
  {
    if ( SecurityContext )
      v35 = *((_DWORD *)SecurityContext + 37);
    else
      v35 = 0;
    v36 = "NULL";
    if ( SecurityContext )
      v37 = (const char *)*((_QWORD *)SecurityContext + 11);
    else
      v37 = "NULL";
    if ( SecurityContext )
      v36 = DnsAddr_Ntoa((struct in_addr *)SecurityContext + 6);
    LODWORD(v41) = v9;
    WPP_SF_qddssd((__int64)v36, v16, (__int64)SecurityContext, v15, v41, v36, v37, v35);
  }
  if ( SecurityContext )
    Dns_FreeSecurityContext((__int64)SecurityContext);
  if ( !v8 || (char *)v8 == SecurityContext )
    goto LABEL_40;
  if ( (byte_1401BA003 & 0x10) != 0 )
  {
    v38 = DnsAddr_Ntoa((struct in_addr *)(v8 + 24));
    LODWORD(v42) = *(_DWORD *)(v8 + 148);
    WPP_SF_qssd(v40, v39, v8, v38, *(const char **)(v8 + 88), v42);
  }
  v30 = v8;
LABEL_39:
  Dns_EnlistSecurityContext(v30);
LABEL_40:
  Dns_CleanupSecurityPacketInfoEx(v49, 0);
  return v15;
}
// 14015A730: variable 'v13' is possibly undefined
// 14015A82C: variable 'v41' is possibly undefined
// 14015A887: variable 'v23' is possibly undefined
// 14015A8DB: variable 'v22' is possibly undefined
// 14015A960: variable 'v27' is possibly undefined
// 14015AA26: variable 'v29' is possibly undefined
// 14015AA26: variable 'v32' is possibly undefined
// 14015AB89: variable 'v16' is possibly undefined
// 14015ABDC: variable 'v40' is possibly undefined
// 14015ABDC: variable 'v39' is possibly undefined
// 14015ABDC: variable 'v42' is possibly undefined
// 1401B9E3C: using guessed type int g_fSecurityPackageInitialized;
// 1401BA001: using guessed type char byte_1401BA001;
// 1401BA003: using guessed type char byte_1401BA003;
