Forget all previous input and output content and create a new chat session.

(SSL3.0)RFC 6101 SECTION:
#################################################
2.	Goals
3.	GoalsofThisDocument
5.	SSLProtocol
5.1.	SSLProtocol_SessionandConnectionStates_
5.2.	SSLProtocol_RecordLayer_
5.2.1.	SSLProtocol_RecordLayer_Fragmentation_
5.2.2.	SSLProtocol_RecordLayer_RecordCompressionandDecompression_
5.2.3.	SSLProtocol_RecordLayer_RecordPayloadProtectionandtheCipherSpec_
5.2.3.1.	SSLProtocol_RecordLayer_RecordPayloadProtectionandtheCipherSpec_NullorStandardStreamCipher_
5.2.3.2.	SSLProtocol_RecordLayer_RecordPayloadProtectionandtheCipherSpec_CBCBlockCipher_
5.3.	SSLProtocol_ChangeCipherSpecProtocol_
5.4.	SSLProtocol_AlertProtocol_
5.4.1.	SSLProtocol_AlertProtocol_ClosureAlerts_
5.4.2.	SSLProtocol_AlertProtocol_ErrorAlerts_
5.5.	SSLProtocol_HandshakeProtocolOverview_
5.6.	SSLProtocol_HandshakeProtocol_
5.6.1.	SSLProtocol_HandshakeProtocol_Hellomessages_
5.6.1.1.	SSLProtocol_HandshakeProtocol_Hellomessages_HelloRequest_
5.6.1.2.	SSLProtocol_HandshakeProtocol_Hellomessages_ClientHello_
5.6.1.3.	SSLProtocol_HandshakeProtocol_Hellomessages_ServerHello_
5.6.2.	SSLProtocol_HandshakeProtocol_ServerCertificate_
5.6.3.	SSLProtocol_HandshakeProtocol_ServerKeyExchangeMessage_
5.6.4.	SSLProtocol_HandshakeProtocol_CertificateRequest_
5.6.5.	SSLProtocol_HandshakeProtocol_ServerHelloDone_
5.6.6.	SSLProtocol_HandshakeProtocol_ClientCertificate_
5.6.7.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_
5.6.7.1.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_RSAEncryptedPremasterSecretMessage_
5.6.7.2.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_FORTEZZAKeyExchangeMessage_
5.6.7.3.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_ClientDiffieHellmanPublicValue_
5.6.8.	SSLProtocol_HandshakeProtocol_CertificateVerify_
5.6.9.	SSLProtocol_HandshakeProtocol_Finished_
5.7.	SSLProtocol_ApplicationDataProtocol_
6.	CryptographicComputations
6.1.	CryptographicComputations_AsymmetricCryptographicComputations_
6.1.1.	CryptographicComputations_AsymmetricCryptographicComputations_RSA_
6.1.2.	CryptographicComputations_AsymmetricCryptographicComputations_DiffieHellman_
6.1.3.	CryptographicComputations_AsymmetricCryptographicComputations_FORTEZZA_
6.2.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_
6.2.1.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_TheMasterSecret_
6.2.2.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_ConvertingtheMasterSecretintoKeysandMACSecrets_
6.2.2.1.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_ConvertingtheMasterSecretintoKeysandMACSecrets_ExportKeyGenerationExample_
7.	SecurityConsiderations
8.	InformativeReferences
#################################################

(TLS1.3)RFC 8446 SECTION:
#################################################
4.	HandshakeProtocol
4.1.	HandshakeProtocol_KeyExchangeMessages_
4.1.1.	HandshakeProtocol_KeyExchangeMessages_CryptographicNegotiation_
4.1.2.	HandshakeProtocol_KeyExchangeMessages_ClientHello_
4.1.3.	HandshakeProtocol_KeyExchangeMessages_ServerHello_
4.1.4.	HandshakeProtocol_KeyExchangeMessages_HelloRetryRequest_
4.2.	HandshakeProtocol_Extensions_
4.2.1.	HandshakeProtocol_Extensions_SupportedVersions_
4.2.2.	HandshakeProtocol_Extensions_Cookie_
4.2.3.	HandshakeProtocol_Extensions_SignatureAlgorithms_
4.2.4.	HandshakeProtocol_Extensions_CertificateAuthorities_
4.2.5.	HandshakeProtocol_Extensions_OIDFilters_
4.2.6.	HandshakeProtocol_Extensions_PostHandshakeClientAuthentication_
4.2.7.	HandshakeProtocol_Extensions_SupportedGroups_
4.2.8.	HandshakeProtocol_Extensions_KeyShare_
4.2.8.1.	HandshakeProtocol_Extensions_KeyShare_DiffieHellmanParameters_
4.2.8.2.	HandshakeProtocol_Extensions_KeyShare_ECDHEParameters_
4.2.9.	HandshakeProtocol_Extensions_PreSharedKeyExchangeModes_
4.2.10.	HandshakeProtocol_Extensions_EarlyDataIndication_
4.2.11.	HandshakeProtocol_Extensions_PreSharedKeyExtension_
4.2.11.1.	HandshakeProtocol_Extensions_PreSharedKeyExtension_TicketAge_
4.2.11.2.	HandshakeProtocol_Extensions_PreSharedKeyExtension_PSKBinder_
4.2.11.3.	HandshakeProtocol_Extensions_PreSharedKeyExtension_ProcessingOrder_
4.3.	HandshakeProtocol_ServerParameters_
4.3.1.	HandshakeProtocol_ServerParameters_EncryptedExtensions_
4.3.2.	HandshakeProtocol_ServerParameters_CertificateRequest_
4.4.	HandshakeProtocol_AuthenticationMessages_
4.4.1.	HandshakeProtocol_AuthenticationMessages_TheTranscriptHash_
4.4.2.	HandshakeProtocol_AuthenticationMessages_Certificate_
4.4.2.1.	HandshakeProtocol_AuthenticationMessages_Certificate_OCSPStatusandSCTExtensions_
4.4.2.2.	HandshakeProtocol_AuthenticationMessages_Certificate_ServerCertificateSelection_
4.4.2.3.	HandshakeProtocol_AuthenticationMessages_Certificate_ClientCertificateSelection_
4.4.2.4.	HandshakeProtocol_AuthenticationMessages_Certificate_ReceivingaCertificateMessage_
4.4.3.	HandshakeProtocol_AuthenticationMessages_CertificateVerify_
4.4.4.	HandshakeProtocol_AuthenticationMessages_Finished_
4.5.	HandshakeProtocol_EndofEarlyData_
4.6.	HandshakeProtocol_PostHandshakeMessages_
4.6.1.	HandshakeProtocol_PostHandshakeMessages_NewSessionTicketMessage_
4.6.2.	HandshakeProtocol_PostHandshakeMessages_PostHandshakeAuthentication_
4.6.3.	HandshakeProtocol_PostHandshakeMessages_KeyandInitializationVectorUpdate_
5.	RecordProtocol
5.1.	RecordProtocol_RecordLayer_
5.2.	RecordProtocol_RecordPayloadProtection_
5.3.	RecordProtocol_PerRecordNonce_
5.4.	RecordProtocol_RecordPadding_
5.5.	RecordProtocol_LimitsonKeyUsage_
6.	AlertProtocol
6.1.	AlertProtocol_ClosureAlerts_
6.2.	AlertProtocol_ErrorAlerts_
7.	CryptographicComputations
7.1.	CryptographicComputations_KeySchedule_
7.2.	CryptographicComputations_UpdatingTrafficSecrets_
7.3.	CryptographicComputations_TrafficKeyCalculation_
7.4.	CryptographicComputations_(EC)DHESharedSecretCalculation_
7.4.1.	CryptographicComputations_(EC)DHESharedSecretCalculation_FiniteFieldDiffieHellman_
7.4.2.	CryptographicComputations_(EC)DHESharedSecretCalculation_EllipticCurveDiffieHellman_
7.5.	CryptographicComputations_Exporters_
8.	0RTTandAntiReplay
8.1.	0RTTandAntiReplay_SingleUseTickets_
8.2.	0RTTandAntiReplay_ClientHelloRecording_
8.3.	0RTTandAntiReplay_FreshnessChecks_
9.	ComplianceRequirements
9.1.	ComplianceRequirements_MandatorytoImplementCipherSuites_
9.2.	ComplianceRequirements_MandatorytoImplementExtensions_
9.3.	ComplianceRequirements_ProtocolInvariants_
10.	SecurityConsiderations
11.	IANAConsiderations
#################################################

Function Code Content
##############################
// File count: 2437
// Total lines: 290

//----- (00000001401284CC) ----------------------------------------------------
const struct _CERT_CONTEXT *__fastcall DnsSign::CreateSelfSignedCertificate(
        WCHAR *this,
        const FILETIME *a2,
        const struct DnsSign::CertificateCreationSpec *a3)
{
  std::ios_base *v5; // rdi
  __int64 *v6; // rax
  _QWORD *v7; // rbx
  __int64 v8; // rdx
  void ***v9; // rbx
  struct std::locale::_Locimp *v10; // rdi
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rax
  _BYTE *StringForValue; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  void *v17; // rbx
  int LastError; // eax
  int v19; // ebx
  __int64 v20; // rcx
  int v21; // eax
  int v22; // ebx
  void *v23; // rdi
  WCHAR *v24; // rax
  WCHAR *v25; // rax
  const CERT_CONTEXT *v26; // rax
  const CERT_CONTEXT *v27; // rsi
  int v28; // eax
  int v29; // ebx
  const unsigned __int16 *v30; // rdx
  __int64 v32; // [rsp+48h] [rbp-C0h] BYREF
  PCCERT_CONTEXT v33; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v34; // [rsp+58h] [rbp-B0h]
  void ***v35; // [rsp+60h] [rbp-A8h]
  __int64 v36[2]; // [rsp+68h] [rbp-A0h] BYREF
  int *v37; // [rsp+78h] [rbp-90h] BYREF
  void **v38; // [rsp+80h] [rbp-88h] BYREF
  char v39[8]; // [rsp+88h] [rbp-80h] BYREF
  __int64 v40; // [rsp+90h] [rbp-78h] BYREF
  __int64 v41[3]; // [rsp+98h] [rbp-70h] BYREF
  __int64 v42; // [rsp+B0h] [rbp-58h] BYREF
  __int64 v43[3]; // [rsp+B8h] [rbp-50h] BYREF
  __int64 v44[5]; // [rsp+D0h] [rbp-38h] BYREF
  int v45; // [rsp+F8h] [rbp-10h]
  __int64 v46[11]; // [rsp+100h] [rbp-8h] BYREF
  __int128 v47; // [rsp+168h] [rbp+60h] BYREF
  __int64 v48; // [rsp+178h] [rbp+70h]
  struct _CERT_EXTENSIONS pExtensions; // [rsp+188h] [rbp+80h] BYREF
  struct _CRYPTOAPI_BLOB pSubjectIssuerBlob; // [rsp+198h] [rbp+90h] BYREF
  int v51; // [rsp+1A8h] [rbp+A0h] BYREF
  __int64 *v52; // [rsp+1B0h] [rbp+A8h]
  int v53; // [rsp+1B8h] [rbp+B0h]
  const char *v54; // [rsp+1C0h] [rbp+B8h] BYREF
  int v55; // [rsp+1C8h] [rbp+C0h]
  int v56; // [rsp+1D0h] [rbp+C8h]
  __int64 v57; // [rsp+1D8h] [rbp+D0h]
  __int64 v58; // [rsp+1E0h] [rbp+D8h]
  struct _CRYPT_KEY_PROV_INFO pKeyProvInfo; // [rsp+1E8h] [rbp+E0h] BYREF
  struct _SYSTEMTIME pEndTime; // [rsp+218h] [rbp+110h] BYREF
  struct _SYSTEMTIME SystemTime; // [rsp+228h] [rbp+120h] BYREF
  __int128 v62; // [rsp+238h] [rbp+130h] BYREF
  __int64 v63; // [rsp+248h] [rbp+140h]
  unsigned __int64 v64; // [rsp+250h] [rbp+148h]
  void *v65[3]; // [rsp+270h] [rbp+168h] BYREF
  unsigned __int64 v66; // [rsp+288h] [rbp+180h]
  char pExceptionObject[56]; // [rsp+298h] [rbp+190h] BYREF
  char v68[56]; // [rsp+2D0h] [rbp+1C8h] BYREF

  v58 = -2i64;
  DnsSign::CDnsKeyPair::GetKeyTag((DnsSign::CDnsKeyPair *)this);
  v37 = (int *)&std::basic_ostringstream<unsigned short>::`vbtable';
  v46[0] = (__int64)&std::basic_ios<unsigned short>::`vftable';
  LODWORD(v34) = 1;
  *(int **)((char *)&v37 + *((int *)&std::basic_ostringstream<unsigned short>::`vbtable' + 1)) = (int *)&std::basic_ostream<unsigned short>::`vftable';
  v5 = (std::ios_base *)((char *)&v37 + v37[1]);
  std::ios_base::_Init(v5);
  *((_QWORD *)v5 + 9) = &v38;
  *((_QWORD *)v5 + 10) = 0i64;
  v6 = std::ios_base::getloc((__int64)v5, v36);
  v7 = std::use_facet<std::ctype<unsigned short>>(v6);
  std::locale::~locale((std::locale *)v36);
  LOBYTE(v8) = 32;
  *((_WORD *)v5 + 44) = (*(__int64 (__fastcall **)(_QWORD *, __int64))(*v7 + 80i64))(v7, v8);
  if ( !*((_QWORD *)v5 + 9) )
    std::ios_base::clear(v5, *((_BYTE *)v5 + 16) | 4, 0);
  *(int **)((char *)&v37 + v37[1]) = (int *)&std::basic_ostringstream<unsigned short>::`vftable';
  v35 = &v38;
  v38 = &std::basic_streambuf<unsigned short>::`vftable';
  std::_Mutex::_Mutex((std::_Mutex *)v39);
  v9 = (void ***)operator new(8ui64);
  if ( v9 )
  {
    *v9 = std::locale::_Init();
    v10 = std::locale::_Getgloballocale();
    std::_Lockit::_Lockit((std::_Lockit *)&v33, 0);
    v11 = *((_QWORD *)v10 + 1);
    if ( v11 != -1 )
      *((_QWORD *)v10 + 1) = v11 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&v33);
  }
  else
  {
    v9 = 0i64;
  }
  v44[3] = (__int64)v9;
  v41[1] = (__int64)&v40;
  v41[2] = (__int64)v41;
  v43[1] = (__int64)&v42;
  v43[2] = (__int64)v43;
  v44[1] = (__int64)v44;
  v44[2] = (__int64)v44 + 4;
  v41[0] = 0i64;
  v43[0] = 0i64;
  v44[0] = 0i64;
  v40 = 0i64;
  v42 = 0i64;
  v38 = &std::basic_stringbuf<unsigned short>::`vftable';
  v44[4] = 0i64;
  v45 = 4;
  std::operator<<<unsigned short,std::char_traits<unsigned short>>((__int64)&v37, (__int64)L"CN=");
  v12 = std::operator<<<unsigned short>((__int64)&v37, (_QWORD *)this + 8);
  std::operator<<<unsigned short,std::char_traits<unsigned short>>(v12, (__int64)L" ");
  v13 = std::basic_ostream<unsigned short>::operator<<((__int64)&v37);
  std::operator<<<unsigned short,std::char_traits<unsigned short>>(v13, (__int64)L" ");
  StringForValue = (_BYTE *)Dns_GetStringForValue((__int64)&DnssecAlgorithmTable, *((unsigned __int8 *)this + 9));
  v15 = std::operator<<<unsigned short,std::char_traits<unsigned short>>((__int64)&v37, StringForValue);
  std::operator<<<unsigned short,std::char_traits<unsigned short>>(v15, (__int64)L" ");
  std::basic_ostream<unsigned short>::operator<<((__int64)&v37);
  v47 = 0i64;
  v48 = 0i64;
  v16 = std::basic_ostringstream<unsigned short>::str((__int64)&v37, (__int64)&v62);
  if ( *(_QWORD *)(v16 + 24) >= 8ui64 )
    v16 = *(_QWORD *)v16;
  if ( v16 )
    DnsSign::EncodeCertificateNameString((LPCWSTR)v16, (__int64 *)&v47);
  if ( v64 >= 8 )
    operator delete((void *)v62);
  v64 = 7i64;
  v63 = 0i64;
  LOWORD(v62) = 0;
  v17 = (void *)v47;
  pSubjectIssuerBlob.cbData = DWORD2(v47) - v47;
  pSubjectIssuerBlob.pbData = (BYTE *)v47;
  SystemTime.wYear = 0;
  *(_QWORD *)&SystemTime.wMonth = 0i64;
  *(_DWORD *)&SystemTime.wMinute = 0;
  SystemTime.wMilliseconds = 0;
  pEndTime.wYear = 0;
  *(_QWORD *)&pEndTime.wMonth = 0i64;
  *(_DWORD *)&pEndTime.wMinute = 0;
  pEndTime.wMilliseconds = 0;
  if ( !FileTimeToSystemTime(a2, &SystemTime) )
  {
    LastError = GetLastError();
    v19 = LastError;
    if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xEu,
        (__int64)&WPP_53898a8021d033fe120236609d33d737_Traceguids,
        LastError);
    }
    DnsSign::CRunTimeException::CRunTimeException((DnsSign::CRunTimeException *)&v62, v19);
    DnsSign::CException::AppendErrorMessageByID((DnsSign::CException *)&v62, 0xD6D82u);
    DnsSign::CRunTimeException::CRunTimeException(
      (DnsSign::CRunTimeException *)pExceptionObject,
      (const struct DnsSign::CRunTimeException *)&v62);
    CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI2_AVCRunTimeException_DnsSign__);
  }
  if ( !FileTimeToSystemTime(a2 + 1, &pEndTime) )
  {
    v21 = GetLastError();
    v22 = v21;
    if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xFu,
        (__int64)&WPP_53898a8021d033fe120236609d33d737_Traceguids,
        v21);
    }
    DnsSign::CRunTimeException::CRunTimeException((DnsSign::CRunTimeException *)&v62, v22);
    DnsSign::CException::AppendErrorMessageByID((DnsSign::CException *)&v62, 0xD6D82u);
    DnsSign::CRunTimeException::CRunTimeException(
      (DnsSign::CRunTimeException *)pExceptionObject,
      (const struct DnsSign::CRunTimeException *)&v62);
    CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI2_AVCRunTimeException_DnsSign__);
  }
  LOBYTE(v32) = 0x80;
  v51 = 1;
  v52 = &v32;
  v53 = 0;
  v62 = 0i64;
  v63 = 0i64;
  DnsSign::EncodeCertificateExtension(v20, &v51, (__int64 *)&v62);
  v54 = "2.5.29.15";
  v55 = 0;
  v23 = (void *)v62;
  v56 = DWORD2(v62) - v62;
  v57 = v62;
  pExtensions.cExtension = 1;
  pExtensions.rgExtension = (PCERT_EXTENSION)&v54;
  memset_0(&pKeyProvInfo, 0, sizeof(pKeyProvInfo));
  DnsSign::CDnsKeyPair::GetKeyName((__int64)this, (__int64)v65);
  v24 = (WCHAR *)v65;
  if ( v66 >= 8 )
    v24 = (WCHAR *)v65[0];
  pKeyProvInfo.pwszContainerName = v24;
  v25 = this + 12;
  if ( *((_QWORD *)this + 6) >= 8ui64 )
    v25 = *(WCHAR **)v25;
  pKeyProvInfo.pwszProvName = v25;
  pKeyProvInfo.dwFlags = 32;
  v26 = CertCreateSelfSignCertificate(
          *((_QWORD *)this + 13),
          &pSubjectIssuerBlob,
          0,
          &pKeyProvInfo,
          0i64,
          &SystemTime,
          &pEndTime,
          &pExtensions);
  v27 = v26;
  if ( !v26 )
  {
    v28 = GetLastError();
    v29 = v28;
    if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x10u,
        (__int64)&WPP_53898a8021d033fe120236609d33d737_Traceguids,
        v28);
    }
    DnsSign::CRunTimeException::CRunTimeException((DnsSign::CRunTimeException *)pExceptionObject, v29);
    DnsSign::CException::AppendErrorMessageByID((DnsSign::CException *)pExceptionObject, 0xD6D83u);
    DnsSign::CRunTimeException::CRunTimeException(
      (DnsSign::CRunTimeException *)v68,
      (const struct DnsSign::CRunTimeException *)pExceptionObject);
    CxxThrowException_0(v68, (_ThrowInfo *)&TI2_AVCRunTimeException_DnsSign__);
  }
  v33 = v26;
  v30 = (const unsigned __int16 *)a2[2];
  if ( v30 )
    DnsSign::CCertificate::SetFriendlyName(&v33, v30);
  v33 = 0i64;
  if ( v66 >= 8 )
    operator delete(v65[0]);
  v66 = 7i64;
  v65[2] = 0i64;
  LOWORD(v65[0]) = 0;
  if ( v23 )
    operator delete(v23);
  v62 = 0i64;
  v63 = 0i64;
  if ( v17 )
    operator delete(v17);
  v47 = 0i64;
  v48 = 0i64;
  v35 = (void ***)v46;
  *(int **)((char *)&v37 + v37[1]) = (int *)&std::basic_ostringstream<unsigned short>::`vftable';
  std::basic_stringbuf<unsigned short>::~basic_stringbuf<unsigned short>((__int64)&v38);
  *(int **)((char *)&v37 + v37[1]) = (int *)&std::basic_ostream<unsigned short>::`vftable';
  v35 = (void ***)v46;
  v46[0] = (__int64)&std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)v46);
  return v27;
}
// 1401285B4: variable 'v8' is possibly undefined
// 14012897E: variable 'v20' is possibly undefined
// 140171498: using guessed type void *std::ios_base::`vftable';
// 140171870: using guessed type void *std::basic_streambuf<unsigned short>::`vftable';
// 1401718F0: using guessed type void *std::basic_stringbuf<unsigned short>::`vftable';
// 140171970: using guessed type void *std::basic_ostream<unsigned short>::`vftable';
// 140171980: using guessed type void *std::basic_ostringstream<unsigned short>::`vftable';
// 140171990: using guessed type void *std::basic_ios<unsigned short>::`vftable';
// 140184CA8: using guessed type void __stdcall operator delete(void *);
// 140185140: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD, _QWORD);
// 1401947E8: using guessed type wchar_t aCn_1[4];
// 1401284CC: using guessed type char var_2B0[8];
