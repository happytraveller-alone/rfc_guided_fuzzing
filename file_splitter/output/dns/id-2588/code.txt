Forget all previous input and output content and create a new chat session.

(SSL3.0)RFC 6101 SECTION:
#################################################
2.	Goals
3.	GoalsofThisDocument
5.	SSLProtocol
5.1.	SSLProtocol_SessionandConnectionStates_
5.2.	SSLProtocol_RecordLayer_
5.2.1.	SSLProtocol_RecordLayer_Fragmentation_
5.2.2.	SSLProtocol_RecordLayer_RecordCompressionandDecompression_
5.2.3.	SSLProtocol_RecordLayer_RecordPayloadProtectionandtheCipherSpec_
5.2.3.1.	SSLProtocol_RecordLayer_RecordPayloadProtectionandtheCipherSpec_NullorStandardStreamCipher_
5.2.3.2.	SSLProtocol_RecordLayer_RecordPayloadProtectionandtheCipherSpec_CBCBlockCipher_
5.3.	SSLProtocol_ChangeCipherSpecProtocol_
5.4.	SSLProtocol_AlertProtocol_
5.4.1.	SSLProtocol_AlertProtocol_ClosureAlerts_
5.4.2.	SSLProtocol_AlertProtocol_ErrorAlerts_
5.5.	SSLProtocol_HandshakeProtocolOverview_
5.6.	SSLProtocol_HandshakeProtocol_
5.6.1.	SSLProtocol_HandshakeProtocol_Hellomessages_
5.6.1.1.	SSLProtocol_HandshakeProtocol_Hellomessages_HelloRequest_
5.6.1.2.	SSLProtocol_HandshakeProtocol_Hellomessages_ClientHello_
5.6.1.3.	SSLProtocol_HandshakeProtocol_Hellomessages_ServerHello_
5.6.2.	SSLProtocol_HandshakeProtocol_ServerCertificate_
5.6.3.	SSLProtocol_HandshakeProtocol_ServerKeyExchangeMessage_
5.6.4.	SSLProtocol_HandshakeProtocol_CertificateRequest_
5.6.5.	SSLProtocol_HandshakeProtocol_ServerHelloDone_
5.6.6.	SSLProtocol_HandshakeProtocol_ClientCertificate_
5.6.7.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_
5.6.7.1.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_RSAEncryptedPremasterSecretMessage_
5.6.7.2.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_FORTEZZAKeyExchangeMessage_
5.6.7.3.	SSLProtocol_HandshakeProtocol_ClientKeyExchangeMessage_ClientDiffieHellmanPublicValue_
5.6.8.	SSLProtocol_HandshakeProtocol_CertificateVerify_
5.6.9.	SSLProtocol_HandshakeProtocol_Finished_
5.7.	SSLProtocol_ApplicationDataProtocol_
6.	CryptographicComputations
6.1.	CryptographicComputations_AsymmetricCryptographicComputations_
6.1.1.	CryptographicComputations_AsymmetricCryptographicComputations_RSA_
6.1.2.	CryptographicComputations_AsymmetricCryptographicComputations_DiffieHellman_
6.1.3.	CryptographicComputations_AsymmetricCryptographicComputations_FORTEZZA_
6.2.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_
6.2.1.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_TheMasterSecret_
6.2.2.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_ConvertingtheMasterSecretintoKeysandMACSecrets_
6.2.2.1.	CryptographicComputations_SymmetricCryptographicCalculationsandtheCipherSpec_ConvertingtheMasterSecretintoKeysandMACSecrets_ExportKeyGenerationExample_
7.	SecurityConsiderations
8.	InformativeReferences
#################################################

(TLS1.3)RFC 8446 SECTION:
#################################################
4.	HandshakeProtocol
4.1.	HandshakeProtocol_KeyExchangeMessages_
4.1.1.	HandshakeProtocol_KeyExchangeMessages_CryptographicNegotiation_
4.1.2.	HandshakeProtocol_KeyExchangeMessages_ClientHello_
4.1.3.	HandshakeProtocol_KeyExchangeMessages_ServerHello_
4.1.4.	HandshakeProtocol_KeyExchangeMessages_HelloRetryRequest_
4.2.	HandshakeProtocol_Extensions_
4.2.1.	HandshakeProtocol_Extensions_SupportedVersions_
4.2.2.	HandshakeProtocol_Extensions_Cookie_
4.2.3.	HandshakeProtocol_Extensions_SignatureAlgorithms_
4.2.4.	HandshakeProtocol_Extensions_CertificateAuthorities_
4.2.5.	HandshakeProtocol_Extensions_OIDFilters_
4.2.6.	HandshakeProtocol_Extensions_PostHandshakeClientAuthentication_
4.2.7.	HandshakeProtocol_Extensions_SupportedGroups_
4.2.8.	HandshakeProtocol_Extensions_KeyShare_
4.2.8.1.	HandshakeProtocol_Extensions_KeyShare_DiffieHellmanParameters_
4.2.8.2.	HandshakeProtocol_Extensions_KeyShare_ECDHEParameters_
4.2.9.	HandshakeProtocol_Extensions_PreSharedKeyExchangeModes_
4.2.10.	HandshakeProtocol_Extensions_EarlyDataIndication_
4.2.11.	HandshakeProtocol_Extensions_PreSharedKeyExtension_
4.2.11.1.	HandshakeProtocol_Extensions_PreSharedKeyExtension_TicketAge_
4.2.11.2.	HandshakeProtocol_Extensions_PreSharedKeyExtension_PSKBinder_
4.2.11.3.	HandshakeProtocol_Extensions_PreSharedKeyExtension_ProcessingOrder_
4.3.	HandshakeProtocol_ServerParameters_
4.3.1.	HandshakeProtocol_ServerParameters_EncryptedExtensions_
4.3.2.	HandshakeProtocol_ServerParameters_CertificateRequest_
4.4.	HandshakeProtocol_AuthenticationMessages_
4.4.1.	HandshakeProtocol_AuthenticationMessages_TheTranscriptHash_
4.4.2.	HandshakeProtocol_AuthenticationMessages_Certificate_
4.4.2.1.	HandshakeProtocol_AuthenticationMessages_Certificate_OCSPStatusandSCTExtensions_
4.4.2.2.	HandshakeProtocol_AuthenticationMessages_Certificate_ServerCertificateSelection_
4.4.2.3.	HandshakeProtocol_AuthenticationMessages_Certificate_ClientCertificateSelection_
4.4.2.4.	HandshakeProtocol_AuthenticationMessages_Certificate_ReceivingaCertificateMessage_
4.4.3.	HandshakeProtocol_AuthenticationMessages_CertificateVerify_
4.4.4.	HandshakeProtocol_AuthenticationMessages_Finished_
4.5.	HandshakeProtocol_EndofEarlyData_
4.6.	HandshakeProtocol_PostHandshakeMessages_
4.6.1.	HandshakeProtocol_PostHandshakeMessages_NewSessionTicketMessage_
4.6.2.	HandshakeProtocol_PostHandshakeMessages_PostHandshakeAuthentication_
4.6.3.	HandshakeProtocol_PostHandshakeMessages_KeyandInitializationVectorUpdate_
5.	RecordProtocol
5.1.	RecordProtocol_RecordLayer_
5.2.	RecordProtocol_RecordPayloadProtection_
5.3.	RecordProtocol_PerRecordNonce_
5.4.	RecordProtocol_RecordPadding_
5.5.	RecordProtocol_LimitsonKeyUsage_
6.	AlertProtocol
6.1.	AlertProtocol_ClosureAlerts_
6.2.	AlertProtocol_ErrorAlerts_
7.	CryptographicComputations
7.1.	CryptographicComputations_KeySchedule_
7.2.	CryptographicComputations_UpdatingTrafficSecrets_
7.3.	CryptographicComputations_TrafficKeyCalculation_
7.4.	CryptographicComputations_(EC)DHESharedSecretCalculation_
7.4.1.	CryptographicComputations_(EC)DHESharedSecretCalculation_FiniteFieldDiffieHellman_
7.4.2.	CryptographicComputations_(EC)DHESharedSecretCalculation_EllipticCurveDiffieHellman_
7.5.	CryptographicComputations_Exporters_
8.	0RTTandAntiReplay
8.1.	0RTTandAntiReplay_SingleUseTickets_
8.2.	0RTTandAntiReplay_ClientHelloRecording_
8.3.	0RTTandAntiReplay_FreshnessChecks_
9.	ComplianceRequirements
9.1.	ComplianceRequirements_MandatorytoImplementCipherSuites_
9.2.	ComplianceRequirements_MandatorytoImplementExtensions_
9.3.	ComplianceRequirements_ProtocolInvariants_
10.	SecurityConsiderations
11.	IANAConsiderations
#################################################

Function Code Content
##############################
// File count: 2588
// Total lines: 237

//----- (0000000140132190) ----------------------------------------------------
__int64 __fastcall CDnsPolicy_SubnetRecordCriteriaTree::FindMatchingPolicyForQuery(
        __int64 (__fastcall ***a1)(_QWORD),
        struct in_addr *a2,
        __int64 a3,
        const void ***a4,
        __int64 a5,
        int a6)
{
  __int64 (__fastcall ***v8)(_QWORD); // r14
  int v9; // esi
  _QWORD *v10; // rax
  CDnsClientSubnetRecordsTrie *v11; // rax
  const char *v12; // rax
  unsigned int Node; // r13d
  const char *v14; // rax
  _QWORD *v15; // rdi
  bool i; // zf
  __int64 **v17; // rax
  __int64 *v18; // rbx
  const unsigned __int16 *v19; // r14
  const char *v20; // rax
  __int64 v21; // rdx
  __int64 v22; // r8
  __int64 ***v23; // r14
  __int64 v24; // r8
  CDnsClientSubnetRecordsTrie *v25; // rax
  const void **v26; // rcx
  __int64 v27; // rax
  const wchar_t *v28; // rbx
  int v29; // eax
  const char *CriteriaTypeString; // rax
  __int64 v31; // r8
  _QWORD *v32; // rax
  _QWORD *v33; // rbx
  __int64 (__fastcall ***v35)(_QWORD); // [rsp+30h] [rbp-D0h]
  __int64 v36; // [rsp+40h] [rbp-C0h]
  unsigned int v37; // [rsp+50h] [rbp-B0h] BYREF
  int v38; // [rsp+54h] [rbp-ACh]
  __int64 (__fastcall ***v39)(_QWORD); // [rsp+58h] [rbp-A8h]
  _QWORD *v40; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v41; // [rsp+68h] [rbp-98h]
  __int64 v42; // [rsp+78h] [rbp-88h]
  __int64 v43; // [rsp+80h] [rbp-80h]
  __int64 v44; // [rsp+88h] [rbp-78h]
  __int64 *v45; // [rsp+90h] [rbp-70h] BYREF
  char pExceptionObject[24]; // [rsp+98h] [rbp-68h] BYREF
  void *v47[3]; // [rsp+B0h] [rbp-50h] BYREF
  unsigned __int64 v48; // [rsp+C8h] [rbp-38h]
  void *v49[3]; // [rsp+D8h] [rbp-28h] BYREF
  unsigned __int64 v50; // [rsp+F0h] [rbp-10h]

  v44 = -2i64;
  v43 = a3;
  v8 = a1;
  v39 = a1;
  v42 = a5;
  v9 = 0;
  v38 = 0;
  v41 = 0i64;
  v10 = operator new(0x38ui64);
  if ( !v10 )
  {
    std::bad_alloc::bad_alloc((std::bad_alloc *)pExceptionObject, 0i64);
    CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI2_AVbad_alloc_std__);
  }
  v40 = v10;
  *v10 = v10;
  v10[1] = v10;
  v11 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 17) & 0x400000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 5u )
  {
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 7), 0x29u, (__int64)&WPP_bbbcc621566c3408fe84d6a85874d543_Traceguids, a2);
    v11 = WPP_GLOBAL_Control;
  }
  if ( v11 != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
    && (*((_DWORD *)v11 + 17) & 0x400000) != 0
    && *((_BYTE *)v11 + 65) >= 4u )
  {
    v12 = DnsAddr_Ntoa(a2 + 16);
    WPP_SF_qs(
      *((_QWORD *)WPP_GLOBAL_Control + 7),
      0x2Au,
      (__int64)&WPP_bbbcc621566c3408fe84d6a85874d543_Traceguids,
      a2,
      v12);
  }
  v37 = -1;
  acquireRead((__int64)hClientSubnetRecordsLock, 0xFFFFFFFF, &v37);
  Node = CDnsClientSubnetRecordsTrie::findNode((__int64)g_DnsClientSubnetTrie, (__int64)&a2[16], 0i64, 1, (__int64)&v40);
  if ( v41 )
  {
    v15 = (_QWORD *)*v40;
    for ( i = *v40 == (_QWORD)v40; !i; i = v15 == v40 )
    {
      v17 = std::_Tree<std::_Tmap_traits<std::wstring,CDnsPolicy_CriteriaNode *,bool (*)(std::wstring const &,std::wstring const &),std::allocator<std::pair<std::wstring const,CDnsPolicy_CriteriaNode *>>,0>>::find(
              (__int64)v8[1],
              &v45,
              (__int64)(v15 + 2));
      v18 = *v17;
      if ( *v17 != (__int64 *)v8[1][1] )
      {
        if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 17) & 0x400000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 4u )
        {
          v19 = (const unsigned __int16 *)(v18 + 3);
          if ( (unsigned __int64)v18[6] >= 8 )
            v19 = *(const unsigned __int16 **)v19;
          v20 = DnsAddr_Ntoa(a2 + 16);
          v35 = v39;
          WPP_SF_Ssqq(*((_QWORD *)WPP_GLOBAL_Control + 7), v21, v22, v19, (__int64)v20);
        }
        v23 = (__int64 ***)v18[8];
        Node = CDnsPolicy_CriteriaNode::FindMatchingPolicyForQuery(v23, (__int64)a2, v43, a4, v42, a6);
        if ( Node )
        {
          if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 17) & 0x400000) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 2u )
          {
            v33 = v18 + 3;
            if ( v33[3] >= 8ui64 )
              v33 = (_QWORD *)*v33;
            WPP_SF_qSq(*((_QWORD *)WPP_GLOBAL_Control + 7), 0i64, v24, v23, v33, v39, v35);
          }
          break;
        }
        v25 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 17) & 0x400000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 5u )
        {
          v26 = *a4;
          if ( *a4 )
            v37 = *((_DWORD *)v26 + 26);
          else
            v37 = -1;
          if ( v26 )
          {
            v27 = CDnsPolicy::Name(v26, (__int64)v47);
            v28 = (const wchar_t *)v27;
            v9 |= 1u;
            v38 = v9;
            if ( *(_QWORD *)(v27 + 24) >= 8ui64 )
              v28 = *(const wchar_t **)v27;
          }
          else
          {
            v28 = L"NULL";
          }
          v29 = (**v39)(v39);
          CriteriaTypeString = GetCriteriaTypeString(v29);
          LODWORD(v36) = v37;
          WPP_SF_qsqqSd(*((_QWORD *)WPP_GLOBAL_Control + 7), 0x2Eu, v31, v23, CriteriaTypeString, a2, *a4, v28, v36);
          v25 = WPP_GLOBAL_Control;
        }
        if ( (v9 & 1) != 0 )
        {
          v9 &= ~1u;
          v38 = v9;
          if ( v48 >= 8 )
          {
            operator delete(v47[0]);
            v25 = WPP_GLOBAL_Control;
          }
          v48 = 7i64;
          v47[2] = 0i64;
          LOWORD(v47[0]) = 0;
        }
        if ( a6 == 4 && *a4 )
        {
          if ( v25 != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
            && (*((_DWORD *)v25 + 17) & 0x400000) != 0
            && *((_BYTE *)v25 + 65) >= 4u )
          {
            v32 = (_QWORD *)CDnsPolicy::Name(*a4, (__int64)v49);
            v9 |= 2u;
            v38 = v9;
            if ( v32[3] >= 8ui64 )
              v32 = (_QWORD *)*v32;
            WPP_SF_qS(
              *((_QWORD *)WPP_GLOBAL_Control + 7),
              0x2Fu,
              (__int64)&WPP_bbbcc621566c3408fe84d6a85874d543_Traceguids,
              *a4,
              v32);
          }
          if ( (v9 & 2) != 0 )
          {
            if ( v50 >= 8 )
              operator delete(v49[0]);
            v50 = 7i64;
            v49[2] = 0i64;
            LOWORD(v49[0]) = 0;
          }
          break;
        }
        v8 = v39;
      }
      v15 = (_QWORD *)*v15;
    }
    std::list<std::wstring>::clear((__int64)&v40);
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 17) & 0x400000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 5u )
    {
      v14 = DnsAddr_Ntoa(a2 + 16);
      WPP_SF_sq(
        *((_QWORD *)WPP_GLOBAL_Control + 7),
        0x2Bu,
        (__int64)&WPP_bbbcc621566c3408fe84d6a85874d543_Traceguids,
        v14);
    }
    Node = 0;
  }
  v37 = -1;
  releaseRead((__int64)hClientSubnetRecordsLock, &v37, 1);
  std::list<std::wstring>::clear((__int64)&v40);
  operator delete(v40);
  return Node;
}
// 1401323B4: variable 'v21' is possibly undefined
// 1401323B4: variable 'v22' is possibly undefined
// 1401324AB: variable 'v31' is possibly undefined
// 1401324AB: variable 'v36' is possibly undefined
// 1401325E2: variable 'v24' is possibly undefined
// 1401325E2: variable 'v35' is possibly undefined
// 140184CA8: using guessed type void __stdcall operator delete(void *);
// 140185140: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD, _QWORD);
// 1401B9248: using guessed type struct CDnsClientSubnetRecordsTrie *g_DnsClientSubnetTrie;
// 1401B9DB8: using guessed type void *hClientSubnetRecordsLock;
