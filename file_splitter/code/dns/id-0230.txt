//----- (000000014001DAC0) ----------------------------------------------------
BOOL __fastcall Print_DnsMessage(void (*a1)(__int64, const char *, ...), __int64 a2, __int64 a3, __int64 a4)
{
  BOOL v6; // r12d
  int v8; // r15d
  int v9; // ebx
  int v10; // edi
  const char *v11; // rax
  const char *v12; // r9
  const char *v13; // r8
  unsigned int v14; // r8d
  int v15; // eax
  unsigned int v16; // edx
  int v17; // eax
  const char *v18; // r13
  const char *v19; // rbx
  bool v20; // zf
  int v21; // r12d
  const char *v22; // rax
  int v23; // r15d
  int v24; // r14d
  int v25; // ebp
  int v26; // esi
  int v27; // edi
  u_short v28; // ax
  void (*v29)(__int64, const char *, ...); // r15
  __int64 v30; // rbx
  u_short v31; // di
  u_short v32; // r14
  u_short v33; // si
  u_short v34; // r13
  __int16 v35; // ax
  const char *v36; // rdx
  char *v37; // r14
  int v38; // r12d
  const char *v39; // rax
  bool v40; // zf
  const char *v41; // r8
  const char *v42; // r9
  const char *v43; // r8
  int v44; // eax
  __int64 v45; // rdi
  unsigned __int16 v46; // dx
  int v47; // eax
  u_short *v48; // r14
  int v49; // ebx
  int v50; // edi
  __int64 v51; // rax
  unsigned __int16 v52; // ax
  __int64 v54; // [rsp+20h] [rbp-148h]
  __int64 v55; // [rsp+20h] [rbp-148h]
  __int64 v56; // [rsp+28h] [rbp-140h]
  __int64 v57; // [rsp+30h] [rbp-138h]
  __int64 v58; // [rsp+30h] [rbp-138h]
  __int64 v59; // [rsp+40h] [rbp-128h]
  __int64 v60; // [rsp+48h] [rbp-120h]
  __int64 v61; // [rsp+50h] [rbp-118h]
  __int64 v62; // [rsp+58h] [rbp-110h]
  __int64 v63; // [rsp+60h] [rbp-108h]
  __int64 v64; // [rsp+68h] [rbp-100h]
  __int64 v65; // [rsp+70h] [rbp-F8h]
  int v66; // [rsp+D0h] [rbp-98h]
  u_short v67; // [rsp+D0h] [rbp-98h]
  unsigned __int16 v68; // [rsp+D4h] [rbp-94h]
  int v69; // [rsp+D8h] [rbp-90h]
  u_short v70; // [rsp+D8h] [rbp-90h]
  int v71; // [rsp+DCh] [rbp-8Ch]
  int v72; // [rsp+DCh] [rbp-8Ch]
  BOOL v73; // [rsp+E0h] [rbp-88h]
  unsigned int v74; // [rsp+E4h] [rbp-84h]
  unsigned int v75; // [rsp+E8h] [rbp-80h]
  int v76; // [rsp+ECh] [rbp-7Ch]
  unsigned int v77; // [rsp+F0h] [rbp-78h]
  unsigned int v78; // [rsp+F4h] [rbp-74h]
  unsigned int v79; // [rsp+F8h] [rbp-70h]
  unsigned __int16 *v80; // [rsp+100h] [rbp-68h]
  const char *v81; // [rsp+108h] [rbp-60h]
  char *v82; // [rsp+110h] [rbp-58h]
  char *v83; // [rsp+118h] [rbp-50h]
  u_short v85; // [rsp+170h] [rbp+8h]
  u_short v87; // [rsp+180h] [rbp+18h]

  v87 = 0;
  v6 = (*(_BYTE *)(a4 + 6306) & 0x78) == 40;
  v73 = v6;
  DnsPrint_Lock();
  v8 = *(unsigned __int16 *)(a4 + 6302);
  v9 = *(_DWORD *)(a4 + 44);
  v68 = *(_WORD *)(a4 + 6302);
  v10 = ntohs(*(_WORD *)(a4 + 66));
  v11 = DnsAddr_Ntoa((struct in_addr *)(a4 + 64));
  v12 = "question";
  if ( *(char *)(a4 + 6306) < 0 )
    v12 = "response";
  v13 = "UDP";
  if ( *(_BYTE *)(a4 + 1413) )
    v13 = "TCP";
  a1(
    a2,
    "%s %s info at %p\r\n"
    "  Socket = %u\r\n"
    "  Remote addr %s, port %u\r\n"
    "  Time Query=%u, Queued=%u, Expire=%u\r\n"
    "  Buf length = 0x%04x (%d)\r\n"
    "  Msg length = 0x%04x (%d)\r\n"
    "  Message:\r\n",
    v13,
    v12,
    a4,
    *(_QWORD *)(a4 + 56),
    v11,
    v10,
    *(_DWORD *)(a4 + 568),
    *(_DWORD *)(a4 + 584),
    *(_DWORD *)(a4 + 588),
    v9,
    v9,
    v8,
    v8);
  v14 = *(unsigned __int8 *)(a4 + 6307);
  v75 = *(_BYTE *)(a4 + 6307) & 0xF;
  v15 = v75;
  if ( v75 > 0x13 )
    v15 = 19;
  v16 = *(unsigned __int8 *)(a4 + 6306);
  v78 = (v16 >> 3) & 0xF;
  v82 = ResponseCodeStringTable[v15];
  v17 = v78;
  if ( v78 > 6 )
    v17 = 6;
  v83 = OpcodeStringTable[v17];
  v74 = v6 ? 90 : 81;
  v80 = (unsigned __int16 *)(a4 + 6304);
  v71 = *(unsigned __int16 *)(a4 + 6314);
  v18 = "ACOUNT  ";
  v19 = "QUESTION";
  v69 = *(unsigned __int16 *)(a4 + 6312);
  v20 = !v6;
  v21 = *(unsigned __int16 *)(a4 + 6308);
  v22 = "NS";
  if ( !v20 )
    v22 = "UP";
  v81 = v22;
  v66 = *(unsigned __int16 *)(a4 + 6310);
  if ( !v20 )
    v18 = "PRECOUNT";
  v23 = (v14 >> 4) & 1;
  v24 = (v14 >> 6) & 1;
  v25 = v16 & 1;
  v26 = (v16 >> 1) & 1;
  v27 = (v16 >> 2) & 1;
  v76 = (v14 >> 5) & 1;
  v77 = v14 >> 7;
  if ( (v16 & 0x80u) != 0 )
    v19 = "RESPONSE";
  v79 = v16 >> 7;
  v28 = ntohs(*(_WORD *)(a4 + 6306));
  LODWORD(v65) = v76;
  LODWORD(v64) = v23;
  LODWORD(v63) = v24;
  LODWORD(v62) = v77;
  LODWORD(v61) = v25;
  LODWORD(v60) = v26;
  LODWORD(v59) = v27;
  LODWORD(v57) = v78;
  LODWORD(v54) = v79;
  v29 = a1;
  a1(
    a2,
    "    XID       0x%04hx\r\n"
    "    Flags     0x%04hx\r\n"
    "      QR        %x (%s)\r\n"
    "      OPCODE    %x (%s)\r\n"
    "      AA        %x\r\n"
    "      TC        %x\r\n"
    "      RD        %x\r\n"
    "      RA        %x\r\n"
    "      Z         %x\r\n"
    "      CD        %x\r\n"
    "      AD        %x\r\n"
    "      RCODE     %x (%s)\r\n"
    "    %cCOUNT    %d\r\n"
    "    %s  %d\r\n"
    "    %sCOUNT   %d\r\n"
    "    ARCOUNT   %d\r\n",
    *v80,
    v28,
    v54,
    v19,
    v57,
    v83,
    v59,
    v60,
    v61,
    v62,
    v63,
    v64,
    v65,
    v75,
    v82,
    v74,
    v21,
    v18,
    v66,
    v81,
    v69,
    v71);
  v30 = a4;
  v31 = *(_WORD *)(a4 + 6308);
  v32 = *(_WORD *)(a4 + 6310);
  v33 = *(_WORD *)(a4 + 6314);
  v34 = *(_WORD *)(a4 + 6312);
  v85 = v31;
  v70 = v32;
  v67 = v33;
  if ( v31 )
  {
    v35 = *(_WORD *)(a4 + 6308);
    goto LABEL_19;
  }
  if ( v34 )
  {
    v35 = *(_WORD *)(a4 + 6312);
LABEL_19:
    if ( (v35 & 0xFF00) != 0 )
    {
      ntohs(*(_WORD *)(a4 + 6304));
      v85 = ntohs(v31);
      v31 = v85;
      v70 = ntohs(v32);
      v34 = ntohs(v34);
      v33 = ntohs(v33);
      v67 = v33;
    }
  }
  if ( ((v31 | (unsigned __int16)(v34 | v33)) & 0xFF00) != 0 )
  {
    v36 = "WARNING: Invalid RR set counts -- possible bad packet\r\n    terminating packet print.\r\n";
    goto LABEL_63;
  }
  if ( *(char *)(a4 + 6306) < 0 && *(_WORD *)(a4 + 496) == 3 && ntohs(*(_WORD *)(a4 + 66)) == 137 )
  {
    v36 = "  WINS Response packet.\r\n\r\n";
LABEL_63:
    v29(a2, v36);
    return DnsPrint_Unlock();
  }
  v37 = (char *)(a4 + 6316);
  v38 = 0;
  while ( 1 )
  {
    switch ( v38 )
    {
      case 0:
        v87 = v31;
        v39 = "ZONE";
        v40 = v31 == 0;
        v41 = "QUESTION";
LABEL_29:
        v42 = (const char *)&Annotation;
        if ( v40 )
          v42 = "      empty\r\n";
        if ( v73 )
          v41 = v39;
        v29(a2, "    %s SECTION:\r\n%s", v41, v42);
        break;
      case 1:
        v41 = "ANSWER";
        v87 = v70;
        v40 = v70 == 0;
        v39 = "PREREQUISITE";
        goto LABEL_29;
      case 2:
        v87 = v34;
        v39 = "UPDATE";
        v40 = v34 == 0;
        v41 = "AUTHORITY";
        goto LABEL_29;
      case 3:
        v87 = v33;
        v43 = (const char *)&Annotation;
        if ( !v33 )
          v43 = "      empty\r\n";
        v29(a2, "    ADDITIONAL SECTION:\r\n%s", v43);
        break;
    }
    v44 = 0;
    v72 = 0;
    if ( v87 )
      break;
LABEL_54:
    if ( ++v38 >= 4 )
    {
      v52 = (_WORD)v37 - v30 - 6304;
      if ( v52 < v68 )
      {
        if ( v52 + 2 == v68 )
          v29(a2, "    TAG: %c%c\r\n", (unsigned int)*v37, (unsigned int)v37[1]);
        else
          v29(
            a2,
            "WARNING: message continues beyond these records\r\n"
            "    pch = %p, pCurrent = %p, %d bytes\r\n"
            "    offset = %hu, msg length = %hu, %d bytes\r\n",
            v37);
      }
      v36 = "\r\n";
      goto LABEL_63;
    }
  }
  v45 = v38;
  while ( 1 )
  {
    v46 = (_WORD)v37 - v30 - 6304;
    if ( v46 >= v68 && (unsigned __int64)v37 >= *(_QWORD *)(v30 + 32) )
      break;
    v29(a2, "    Offset = 0x%04x, RR count = %d\r\n", v46, (unsigned int)v44);
    v47 = DnsPrint_PacketName(
            (void (__fastcall *)(__int64, const char *, const unsigned __int8 *, const unsigned __int8 *))v29,
            a2,
            "    Name      \"",
            (unsigned __int8 *)v37,
            v30 + 6304,
            v30 + *(unsigned __int16 *)(v30 + 6302) + 6304i64,
            "\"\r\n");
    if ( !v47 )
    {
      v29(a2, "ERROR: Invalid name length, stop packet print\r\n");
LABEL_53:
      v33 = v67;
      v31 = v85;
      goto LABEL_54;
    }
    v48 = (u_short *)&v37[v47];
    if ( v45 )
    {
      v37 = (char *)v48
          + (int)DnsPrint_PacketRecord(
                   v29,
                   a2,
                   0i64,
                   (__int64)v48,
                   v30 + 6304,
                   v30 + *(unsigned __int16 *)(v30 + 6302) + 6304i64);
    }
    else
    {
      v49 = ntohs(*v48);
      v50 = ntohs(v48[1]);
      v51 = DnsRecordStringForType((unsigned __int16)v49);
      LODWORD(v58) = v50;
      LODWORD(v56) = v74;
      LODWORD(v55) = v49;
      v29(a2, "      %cTYPE   %s (%u)\r\n      %cCLASS  %u\r\n", v74, v51, v55, v56, v58);
      v30 = a4;
      v37 = (char *)(v48 + 2);
      v45 = v38;
    }
    v44 = v72 + 1;
    v72 = v44;
    if ( v44 >= v87 )
      goto LABEL_53;
  }
  v29(
    a2,
    "ERROR: BOGUS PACKET:\r\n"
    "    Following RR (offset %hu) past packet length (%d).\r\n"
    "    pchRecord = %p, pCurrent = %p, %d bytes\r\n",
    v46,
    v68,
    v37,
    *(_QWORD *)(v30 + 32),
    *(_QWORD *)(v30 + 32) - (_QWORD)v37);
  return DnsPrint_Unlock();
}
// 14001DE3D: variable 'v54' is possibly undefined
// 14001DE3D: variable 'v57' is possibly undefined
// 14001DE3D: variable 'v59' is possibly undefined
// 14001DE3D: variable 'v60' is possibly undefined
// 14001DE3D: variable 'v61' is possibly undefined
// 14001DE3D: variable 'v62' is possibly undefined
// 14001DE3D: variable 'v63' is possibly undefined
// 14001DE3D: variable 'v64' is possibly undefined
// 14001DE3D: variable 'v65' is possibly undefined
// 14001E127: variable 'v55' is possibly undefined
// 14001E127: variable 'v56' is possibly undefined
// 14001E127: variable 'v58' is possibly undefined
// 14017B6C0: using guessed type char *OpcodeStringTable[7];
// 14017B700: using guessed type char *ResponseCodeStringTable[20];
// 140183D38: using guessed type __int64 __fastcall DnsRecordStringForType(_QWORD);
// 140185140: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD, _QWORD);
