//----- (0000000140133BD0) ----------------------------------------------------
__int64 *__fastcall CDnsPolicy_InterfaceCriteriaTree::GetCriteriaNodes(__int64 a1, _WORD *a2)
{
  __int64 *v4; // rax
  __int64 *v5; // rbx
  _QWORD *v6; // rax
  __int64 *v7; // rcx
  __int64 v8; // rdi
  _QWORD *v9; // rax
  __int64 v10; // rdx
  char pExceptionObject[32]; // [rsp+28h] [rbp-20h] BYREF
  __int64 *v13; // [rsp+60h] [rbp+18h] BYREF

  v4 = (__int64 *)operator new(0x18ui64);
  v5 = v4;
  v13 = v4;
  if ( v4 )
  {
    v4[1] = 0i64;
    v6 = operator new(0x18ui64);
    if ( !v6 )
    {
      std::bad_alloc::bad_alloc((std::bad_alloc *)pExceptionObject, 0i64);
      CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI2_AVbad_alloc_std__);
    }
    *v5 = (__int64)v6;
    *v6 = v6;
    *(_QWORD *)(*v5 + 8) = *v5;
  }
  else
  {
    v5 = 0i64;
  }
  if ( *a2 == 2 )
  {
    std::_Tree<std::_Tmap_traits<unsigned long,CDnsPolicy_CriteriaNode *,bool (*)(unsigned long const &,unsigned long const &),std::allocator<std::pair<unsigned long const,CDnsPolicy_CriteriaNode *>>,0>>::find(
      *(_QWORD *)(a1 + 8),
      &v13,
      (__int64)(a2 + 2));
    if ( v13 == *(__int64 **)(*(_QWORD *)(a1 + 8) + 8i64) )
      return v5;
    v7 = (__int64 *)v13[4];
  }
  else
  {
    std::_Tree<std::_Tmap_traits<IP6_ADDRESS,CDnsPolicy_CriteriaNode *,bool (*)(IP6_ADDRESS const &,IP6_ADDRESS const &),std::allocator<std::pair<IP6_ADDRESS const,CDnsPolicy_CriteriaNode *>>,0>>::find(
      *(_QWORD *)(a1 + 16),
      &v13,
      (__int64)(a2 + 4));
    if ( v13 == *(__int64 **)(*(_QWORD *)(a1 + 16) + 8i64) )
      return v5;
    v7 = (__int64 *)v13[5];
  }
  v13 = v7;
  if ( v7 )
  {
    v8 = *v5;
    v9 = std::_List_val<CDNSPolicyCriteria *>::_Buynode((__int64)v7, *v5, *(_QWORD *)(*v5 + 8), &v13);
    v10 = v5[1];
    if ( v10 == 0x1FFFFFFFFFFFFFFEi64 )
      std::_Xlength_error("list<T> too long");
    v5[1] = v10 + 1;
    *(_QWORD *)(v8 + 8) = v9;
    *(_QWORD *)v9[1] = v9;
  }
  return v5;
}
