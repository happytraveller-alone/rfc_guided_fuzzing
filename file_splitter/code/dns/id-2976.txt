//----- (0000000140157380) ----------------------------------------------------
__int64 __fastcall Dns_AtmaStringToAddress(_BYTE *a1, unsigned int *a2, const char *a3, unsigned int a4)
{
  __int64 v4; // rbp
  char v6; // r8
  unsigned int v7; // edi
  __int64 v8; // r12
  char *v9; // rcx
  __int64 v10; // rdx
  char v11; // al
  __int64 v12; // r14
  const char *v13; // r15
  unsigned int v14; // esi
  const char *v15; // r13
  char *v16; // rcx
  char v17; // al
  const char *v18; // rdx
  const char *i; // rcx
  char v20; // al
  unsigned __int8 v21; // al
  unsigned int *v22; // r9
  char *v24; // rax
  const char *j; // rbx
  char v26; // cl
  _BYTE *v27; // rcx
  int v28; // r8d
  unsigned __int8 v29; // al
  unsigned __int8 v30; // dl
  unsigned int *v32; // [rsp+28h] [rbp-F0h]
  char v33[80]; // [rsp+30h] [rbp-E8h] BYREF
  char v34[80]; // [rsp+80h] [rbp-98h] BYREF

  LODWORD(v4) = a4;
  v32 = a2;
  v6 = byte_1401BA002;
  v7 = 0;
  v8 = 66i64;
  if ( (byte_1401BA002 & 0x10) != 0 )
  {
    if ( a4 <= 0x7FFFFFFEui64 )
    {
      v9 = v33;
      v10 = 66i64;
      do
      {
        if ( !(v10 + a4 - 66i64) )
          break;
        v11 = v9[a3 - v33];
        if ( !v11 )
          break;
        *v9++ = v11;
        --v10;
      }
      while ( v10 );
      if ( !v10 )
        --v9;
      *v9 = 0;
    }
    else
    {
      v33[0] = 0;
    }
    WPP_SF_sq(15i64, (unsigned __int16)&WPP_b6c352f988363708e81560bf4a2e6515_Traceguids, (__int64)v33, a3);
    v6 = byte_1401BA002;
  }
  v12 = -1i64;
  if ( !(_DWORD)v4 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( a3[v4] );
  }
  v13 = a3;
  v14 = 1;
  v15 = &a3[(unsigned int)v4];
  if ( (v6 & 0x10) != 0 )
  {
    if ( (unsigned int)v4 <= 0x7FFFFFFEui64 )
    {
      v16 = v34;
      do
      {
        if ( !((unsigned int)v4 + v8 - 66) )
          break;
        v17 = v16[a3 - v34];
        if ( !v17 )
          break;
        *v16++ = v17;
        --v8;
      }
      while ( v8 );
      if ( !v8 )
        --v16;
      *v16 = 0;
    }
    else
    {
      v34[0] = 0;
    }
    WPP_SF_sq(12i64, (unsigned __int16)&WPP_b6c352f988363708e81560bf4a2e6515_Traceguids, (__int64)v34, a3);
    v6 = byte_1401BA002;
  }
  if ( !(_DWORD)v4 )
  {
    do
      ++v12;
    while ( a3[v12] );
    LODWORD(v4) = v12;
  }
  v18 = &a3[(unsigned int)v4];
  if ( *a3 == 43 )
  {
    for ( i = a3 + 1; i < v18; ++i )
    {
      v20 = *i;
      if ( v20 != 46 )
        ++v14;
    }
  }
  else
  {
    if ( a3 < v18 )
    {
      do
      {
        v21 = *v13++;
        if ( v21 != 46 )
        {
          if ( HexCharToHexDigitTable[v21] > 0xFu )
          {
            if ( (v6 & 0x10) != 0 )
              WPP_SF_c(0xDu, (__int64)&WPP_b6c352f988363708e81560bf4a2e6515_Traceguids, *(v13 - 1));
            return 13i64;
          }
          ++v14;
        }
      }
      while ( v13 < v18 );
      if ( v14 != 40 )
        goto LABEL_47;
      v14 = 21;
      goto LABEL_42;
    }
LABEL_47:
    if ( (v6 & 0x10) != 0 )
      WPP_SF_D(14i64, (unsigned __int16)&WPP_b6c352f988363708e81560bf4a2e6515_Traceguids, v14, a4);
    v14 = 0;
  }
  if ( !v14 )
    return 13i64;
LABEL_42:
  v22 = v32;
  if ( v14 <= *v32 )
  {
    if ( *a3 == 43 )
    {
      *a1 = 1;
      v24 = a1 + 1;
      for ( j = a3 + 1; j < v15; ++j )
      {
        v26 = *j;
        if ( v26 != 46 )
          *v24++ = v26;
      }
    }
    else
    {
      *a1 = 2;
      v27 = a1 + 1;
LABEL_59:
      v28 = 0;
      while ( a3 < v15 )
      {
        v29 = *a3++;
        if ( v29 != 46 )
        {
          v30 = HexCharToHexDigitTable[v29];
          if ( v30 > 0xFu )
            return 13i64;
          if ( v28 )
          {
            *v27++ += v30;
            goto LABEL_59;
          }
          v28 = 1;
          *v27 = 16 * v30;
        }
      }
    }
  }
  else
  {
    v7 = 234;
  }
  *v22 = v14;
  return v7;
}
// 1401575AB: variable 'a4' is possibly undefined
// 140194FF0: using guessed type _BYTE HexCharToHexDigitTable[256];
// 1401BA002: using guessed type char byte_1401BA002;
