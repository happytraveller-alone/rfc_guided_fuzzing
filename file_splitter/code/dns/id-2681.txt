//----- (000000014013F9C8) ----------------------------------------------------
__int64 __fastcall Free_PolicyMap(__int64 *a1, char *a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 v5; // r14
  char *v6; // rdi
  __int64 *v8; // rbx
  __int64 v9; // rsi
  __int64 PolicyName; // rax
  __int64 result; // rax
  signed __int64 v12; // r15
  __int64 **v13; // rsi
  __int64 v14; // rbx
  void *v15; // rcx
  __int64 v16; // [rsp+30h] [rbp-78h] BYREF
  void *v17[5]; // [rsp+38h] [rbp-70h] BYREF

  v3 = 5i64;
  v5 = 5i64;
  v6 = a2;
  v8 = a1;
  do
  {
    v9 = *v8;
    while ( *(_QWORD *)(v9 + 16) )
    {
      PolicyName = CDnsPolicy::GetPolicyName(*(const void ***)(**(_QWORD **)(v9 + 8) + 64i64), (__int64)v17);
      if ( *(_QWORD *)(PolicyName + 24) >= 8ui64 )
        PolicyName = *(_QWORD *)PolicyName;
      Remove_CDNSPolicy(a3, (char *)PolicyName, 0);
      if ( v17[3] >= (void *)8 )
        operator delete(v17[0]);
    }
    ++v8;
    --v5;
  }
  while ( v5 );
  result = Policy_AcquireWriteLock((__int64 *)(a3 + 296), (unsigned int)a2);
  if ( (_DWORD)result )
  {
    if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 68) & 4) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 2u )
    {
      return WPP_SF_sd(
               *((_QWORD *)WPP_GLOBAL_Control + 7),
               0x59u,
               (__int64)&WPP_7bc0de5581043365e853c04d44d2eaeb_Traceguids,
               *(const char **)(a3 + 16));
    }
  }
  else
  {
    v12 = (char *)a1 - v6;
    do
    {
      v13 = *(__int64 ***)&v6[v12];
      v14 = *(_QWORD *)v6;
      std::_Tree<std::_Tmap_traits<std::wstring,CDnsPolicy *,CDnsCompareName,std::allocator<std::pair<std::wstring const,CDnsPolicy *>>,0>>::clear((__int64)v13);
      *(_QWORD *)&v6[v12] = 0i64;
      *(_QWORD *)v6 = 0i64;
      if ( v13 )
      {
        std::_Tree<std::_Tmap_traits<std::wstring,CDnsPolicy *,CDnsCompareName,std::allocator<std::pair<std::wstring const,CDnsPolicy *>>,0>>::erase(
          (__int64)v13,
          &v16,
          *v13[1],
          (__int64)v13[1]);
        operator delete(v13[1]);
        operator delete(v13);
      }
      if ( v14 )
      {
        v15 = *(void **)(v14 + 32);
        if ( v15 )
          operator delete(v15);
        *(_QWORD *)(v14 + 32) = 0i64;
        *(_QWORD *)(v14 + 40) = 0i64;
        *(_QWORD *)(v14 + 48) = 0i64;
        if ( *(_QWORD *)v14 )
          operator delete(*(void **)v14);
        *(_QWORD *)v14 = 0i64;
        *(_QWORD *)(v14 + 8) = 0i64;
        *(_QWORD *)(v14 + 16) = 0i64;
        operator delete((void *)v14);
      }
      v6 += 8;
      --v3;
    }
    while ( v3 );
    return Lock_ReleaseWrite(*(_QWORD *)(a3 + 296));
  }
  return result;
}
// 14013FA5B: variable 'a2' is possibly undefined
// 140184CA8: using guessed type void __stdcall operator delete(void *);
