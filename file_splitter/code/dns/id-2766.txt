//----- (0000000140145EC0) ----------------------------------------------------
__int64 __fastcall CDNSPolicyCriteriaSubnetRecord::AddCriteria(
        CDNSPolicyCriteriaSubnetRecord *this,
        struct _PolicyCriteriaList *a2,
        char *a3)
{
  char *v3; // r12
  int v6; // edi
  unsigned int v8; // esi
  unsigned int v9; // r14d
  __int64 v10; // r15
  __int64 v11; // rdx
  char *v12; // rcx
  __int64 *v13; // rax
  __int64 v14; // r8
  const unsigned __int16 *v15; // r9
  unsigned int v16; // eax
  __int64 v17; // rsi
  __int64 v18; // rax
  unsigned int v19; // r14d
  __int64 *v20; // rax
  __int64 v21; // r8
  const unsigned __int16 *v22; // r9
  __int64 v23; // rcx
  __int64 v24; // r15
  _QWORD *v25; // rax
  __int64 v26; // rdx
  __int64 v27; // rax
  unsigned int v28; // r14d
  __int64 *v29; // rax
  __int64 v30; // r8
  const unsigned __int16 *v31; // r9
  __int64 v32; // rcx
  __int64 v33; // r15
  _QWORD *v34; // rax
  __int64 v35; // rdx
  unsigned __int64 v36; // r8
  unsigned int v37; // [rsp+34h] [rbp-4Ch]
  void *v39[3]; // [rsp+48h] [rbp-38h] BYREF
  unsigned __int64 v40; // [rsp+60h] [rbp-20h]

  v3 = a3;
  v6 = 0;
  if ( *((_DWORD *)a2 + 1) )
    return 87i64;
  v8 = 0;
  if ( *(_DWORD *)a2 )
  {
    while ( 1 )
    {
      v9 = 0;
      v10 = 16i64 * v8;
      v11 = v10 + *((_QWORD *)a2 + 1);
      if ( *(_DWORD *)(v11 + 4) )
        break;
LABEL_9:
      if ( ++v8 >= *(_DWORD *)a2 )
        goto LABEL_23;
    }
    while ( 1 )
    {
      v12 = *(char **)(*(_QWORD *)(v11 + 8) + 8i64 * v9);
      if ( *((_QWORD *)v12 + 3) >= 8ui64 )
        v12 = *(char **)v12;
      if ( (unsigned int)Verify_SubnetName(v12) )
        break;
      ++v9;
      v11 = v10 + *((_QWORD *)a2 + 1);
      if ( v9 >= *(_DWORD *)(v11 + 4) )
        goto LABEL_9;
    }
    if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 17) & 0x400000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 2u )
    {
      v13 = (__int64 *)CDnsPolicy::Name(*((const void ***)this + 2), (__int64)v39);
      v14 = (__int64)v13;
      LOBYTE(v6) = 1;
      if ( (unsigned __int64)v13[3] >= 8 )
        v14 = *v13;
      v15 = *(const unsigned __int16 **)(*(_QWORD *)(*((_QWORD *)a2 + 1) + 16i64 * v8 + 8) + 8i64 * v9);
      if ( *((_QWORD *)v15 + 3) >= 8ui64 )
        v15 = *(const unsigned __int16 **)v15;
      WPP_SF_SS(
        *((_QWORD *)WPP_GLOBAL_Control + 7),
        0x47u,
        (__int64)&WPP_42dbba61d26d3062f1ad4e084cdc81fe_Traceguids,
        v15,
        v14);
    }
    if ( (v6 & 1) != 0 && v40 >= 8 )
      operator delete(v39[0]);
    return 9976i64;
  }
  else
  {
LABEL_23:
    v16 = 0;
    v37 = 0;
    if ( *(_DWORD *)a2 )
    {
      do
      {
        v17 = 2i64 * v16;
        v18 = *((_QWORD *)a2 + 1);
        if ( *(_DWORD *)(v18 + 8 * v17) == 1 )
        {
          v19 = 0;
          if ( *(_DWORD *)(v18 + 8 * v17 + 4) )
          {
            do
            {
              if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
                && (*((_DWORD *)WPP_GLOBAL_Control + 17) & 0x400000) != 0
                && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 4u )
              {
                v20 = (__int64 *)CDnsPolicy::Name(*((const void ***)this + 2), (__int64)v39);
                v21 = (__int64)v20;
                v6 |= 2u;
                if ( (unsigned __int64)v20[3] >= 8 )
                  v21 = *v20;
                v22 = *(const unsigned __int16 **)(*(_QWORD *)(*((_QWORD *)a2 + 1) + 8 * v17 + 8) + 8i64 * v19);
                if ( *((_QWORD *)v22 + 3) >= 8ui64 )
                  v22 = *(const unsigned __int16 **)v22;
                WPP_SF_SS(
                  *((_QWORD *)WPP_GLOBAL_Control + 7),
                  0x48u,
                  (__int64)&WPP_42dbba61d26d3062f1ad4e084cdc81fe_Traceguids,
                  v22,
                  v21);
              }
              if ( (v6 & 2) != 0 )
              {
                v6 &= ~2u;
                if ( v40 >= 8 )
                  operator delete(v39[0]);
              }
              v23 = *(_QWORD *)(*((_QWORD *)a2 + 1) + 8 * v17 + 8);
              v24 = *((_QWORD *)this + 8);
              v25 = std::_List_val<std::wstring>::_Buynode(
                      v23,
                      v24,
                      *(_QWORD *)(v24 + 8),
                      *(const void ***)(v23 + 8i64 * v19));
              v26 = *((_QWORD *)this + 9);
              if ( v26 == 0x666666666666665i64 )
                std::_Xlength_error("list<T> too long");
              *((_QWORD *)this + 9) = v26 + 1;
              *(_QWORD *)(v24 + 8) = v25;
              *(_QWORD *)v25[1] = v25;
              Increment_ClientSubnetRecordReference(*(const void ***)(*(_QWORD *)(*((_QWORD *)a2 + 1) + 8 * v17 + 8)
                                                                    + 8i64 * v19++));
            }
            while ( v19 < *(_DWORD *)(*((_QWORD *)a2 + 1) + 8 * v17 + 4) );
          }
        }
        v27 = *((_QWORD *)a2 + 1);
        if ( *(_DWORD *)(v27 + 8 * v17) == 2 )
        {
          v28 = 0;
          if ( *(_DWORD *)(v27 + 8 * v17 + 4) )
          {
            do
            {
              if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
                && (*((_DWORD *)WPP_GLOBAL_Control + 17) & 0x400000) != 0
                && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 4u )
              {
                v29 = (__int64 *)CDnsPolicy::Name(*((const void ***)this + 2), (__int64)v39);
                v30 = (__int64)v29;
                v6 |= 4u;
                if ( (unsigned __int64)v29[3] >= 8 )
                  v30 = *v29;
                v31 = *(const unsigned __int16 **)(*(_QWORD *)(*((_QWORD *)a2 + 1) + 8 * v17 + 8) + 8i64 * v28);
                if ( *((_QWORD *)v31 + 3) >= 8ui64 )
                  v31 = *(const unsigned __int16 **)v31;
                WPP_SF_SS(
                  *((_QWORD *)WPP_GLOBAL_Control + 7),
                  0x49u,
                  (__int64)&WPP_42dbba61d26d3062f1ad4e084cdc81fe_Traceguids,
                  v31,
                  v30);
              }
              if ( (v6 & 4) != 0 )
              {
                v6 &= ~4u;
                if ( v40 >= 8 )
                  operator delete(v39[0]);
              }
              v32 = *(_QWORD *)(*((_QWORD *)a2 + 1) + 8 * v17 + 8);
              v33 = *((_QWORD *)this + 11);
              v34 = std::_List_val<std::wstring>::_Buynode(
                      v32,
                      v33,
                      *(_QWORD *)(v33 + 8),
                      *(const void ***)(v32 + 8i64 * v28));
              v35 = *((_QWORD *)this + 12);
              if ( v35 == 0x666666666666665i64 )
                std::_Xlength_error("list<T> too long");
              *((_QWORD *)this + 12) = v35 + 1;
              *(_QWORD *)(v33 + 8) = v34;
              *(_QWORD *)v34[1] = v34;
              Increment_ClientSubnetRecordReference(*(const void ***)(*(_QWORD *)(*((_QWORD *)a2 + 1) + 8 * v17 + 8)
                                                                    + 8i64 * v28++));
            }
            while ( v28 < *(_DWORD *)(*((_QWORD *)a2 + 1) + 8 * v17 + 4) );
          }
        }
        v16 = v37 + 1;
        v37 = v16;
      }
      while ( v16 < *(_DWORD *)a2 );
      v3 = a3;
    }
    v36 = -1i64;
    do
      ++v36;
    while ( *(_WORD *)&v3[2 * v36] );
    std::wstring::assign((char *)this + 24, v3, v36);
    return 0i64;
  }
}
// 140184CA8: using guessed type void __stdcall operator delete(void *);
