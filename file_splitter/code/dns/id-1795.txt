//----- (00000001400E2DF8) ----------------------------------------------------
__int64 __fastcall TrustPoint::EnumerateTrustAnchors(
        LPCRITICAL_SECTION lpCriticalSection,
        struct _DnssrvRpcTrustAnchorList **a2)
{
  struct _DnssrvRpcTrustAnchorList *v4; // rdi
  HANDLE OwningThread; // r15
  unsigned __int64 v6; // rax
  struct _DnssrvRpcTrustAnchorList *zero; // rax
  __int64 v8; // rbp
  _QWORD *v9; // rcx
  _QWORD *v10; // rbx
  struct _DnssrvRpcTrustAnchor *RPCObject; // rax
  __int64 i; // rbx
  void *v14; // rcx

  v4 = 0i64;
  EnterCriticalSection(lpCriticalSection);
  OwningThread = lpCriticalSection[1].OwningThread;
  v6 = 8i64 * (unsigned int)OwningThread;
  if ( v6 <= 0xFFFFFFFF
    && (unsigned int)v6 < 0xFFFFFFE8
    && (zero = (struct _DnssrvRpcTrustAnchorList *)MIDL_user_allocate_zero((unsigned int)(v6 + 24)), (v4 = zero) != 0i64) )
  {
    *(_DWORD *)zero = 1;
    v8 = 0i64;
    v9 = *(_QWORD **)&lpCriticalSection[1].LockCount;
    v10 = (_QWORD *)*v9;
    if ( (_QWORD *)*v9 != v9 )
    {
      do
      {
        if ( (unsigned int)v8 >= (unsigned __int64)OwningThread )
          break;
        if ( *((_DWORD *)v10 + 10) && *((_DWORD *)v10 + 10) != 7 )
        {
          RPCObject = TrustAnchor::GetRPCObject((TrustAnchor *)(v10 + 3));
          if ( !RPCObject )
            goto LABEL_12;
          *((_QWORD *)v4 + v8 + 2) = RPCObject;
          v8 = (unsigned int)(v8 + 1);
          *((_DWORD *)v4 + 2) = v8;
        }
        v10 = (_QWORD *)*v10;
      }
      while ( v10 != *(_QWORD **)&lpCriticalSection[1].LockCount );
    }
    *a2 = v4;
    LeaveCriticalSection(lpCriticalSection);
    return 0i64;
  }
  else
  {
LABEL_12:
    LeaveCriticalSection(lpCriticalSection);
    if ( v4 )
    {
      for ( i = 0i64; (unsigned int)i < *((_DWORD *)v4 + 2); i = (unsigned int)(i + 1) )
      {
        v14 = (void *)*((_QWORD *)v4 + i + 2);
        if ( v14 )
          MIDL_user_free(v14);
      }
      MIDL_user_free(v4);
    }
    return 14i64;
  }
}
