//----- (000000014013EF38) ----------------------------------------------------
__int64 __fastcall Create_CDNSPolicies(struct _zone_info *a1)
{
  _QWORD *v2; // rdi
  __int64 v3; // r14
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  int CDNSPolicy; // eax
  const unsigned __int16 *v7; // rax
  __int64 *v8; // rax
  __int64 i; // rax
  _QWORD *v10; // rsi
  _QWORD *j; // rbx
  __int64 result; // rax

  v2 = &g_ServiceStartTempPolicyMap;
  v3 = 5i64;
  do
  {
    v4 = (_QWORD *)v2[1];
    v5 = (_QWORD *)*v4;
    if ( (_QWORD *)*v4 != v4 )
    {
      do
      {
        CDNSPolicy = Create_CDNSPolicy(a1, v5[4], 1);
        if ( CDNSPolicy )
        {
          if ( CDNSPolicy != 9959 )
          {
            if ( a1 )
            {
              if ( (Microsoft_Windows_DNS_Server_ServiceEnableBits & 0x80u) != 0 )
              {
                if ( *((_DWORD *)a1 + 93) )
                  v7 = (const unsigned __int16 *)*((_QWORD *)a1 + 3);
                else
                  v7 = L"..Cache";
                Template_zsz(
                  Microsoft_Windows_DNS_Server_ServiceHandle,
                  &DNS_EVENT_ZONE_LEVEL_POLICY_LOAD_FAILURE,
                  *(const unsigned __int16 **)v5[4],
                  Str,
                  v7);
              }
            }
            else if ( (Microsoft_Windows_DNS_Server_ServiceEnableBits & 4) != 0 )
            {
              Template_zs(
                Microsoft_Windows_DNS_Server_ServiceHandle,
                &DNS_EVENT_SERVER_LEVEL_POLICY_LOAD_FAILURE,
                *(const unsigned __int16 **)v5[4],
                Str);
            }
          }
          if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 68) & 2) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 2u )
          {
            WPP_SF_Sdd(
              *((_QWORD *)WPP_GLOBAL_Control + 7),
              0x47u,
              (__int64)&WPP_7bc0de5581043365e853c04d44d2eaeb_Traceguids,
              *(const unsigned __int16 **)v5[4]);
          }
        }
        Free_RpcPolicy((void *)v5[4]);
        if ( !*((_BYTE *)v5 + 41) )
        {
          v8 = (__int64 *)v5[2];
          if ( *((_BYTE *)v8 + 41) )
          {
            for ( i = v5[1]; !*(_BYTE *)(i + 41) && v5 == *(_QWORD **)(i + 16); i = *(_QWORD *)(i + 8) )
              v5 = (_QWORD *)i;
            v5 = (_QWORD *)i;
          }
          else
          {
            do
            {
              v5 = v8;
              v8 = (__int64 *)*v8;
            }
            while ( !*((_BYTE *)v8 + 41) );
          }
        }
      }
      while ( v5 != (_QWORD *)v2[1] );
    }
    v10 = *(_QWORD **)(v2[1] + 8i64);
    for ( j = v10; !*((_BYTE *)j + 41); v10 = j )
    {
      std::_Tree<std::_Tmap_traits<_lookup_name *,_DnsTreeNode *,DnsSign::CLookupNameCompare,std::allocator<std::pair<_lookup_name * const,_DnsTreeNode *>>,0>>::_Erase(
        (__int64)v2,
        (void **)j[2]);
      j = (_QWORD *)*j;
      operator delete(v10);
    }
    *(_QWORD *)(v2[1] + 8i64) = v2[1];
    *(_QWORD *)v2[1] = v2[1];
    result = v2[1];
    *(_QWORD *)(result + 16) = result;
    v2[2] = 0i64;
    v2 += 4;
    --v3;
  }
  while ( v3 );
  return result;
}
// 140184CA8: using guessed type void __stdcall operator delete(void *);
// 1401B9140: using guessed type int Microsoft_Windows_DNS_Server_ServiceEnableBits;
