//----- (00000001400E302C) ----------------------------------------------------
void DNSSEC_Read5011State()
{
  char v0; // si
  int v1; // r12d
  __int64 *v2; // rax
  _QWORD *v3; // rbx
  __int64 v4; // rdx
  void ***v5; // rbx
  struct std::locale::_Locimp *v6; // rdi
  __int64 v7; // rcx
  struct _iobuf *v8; // rax
  __int64 *v9; // rax
  struct std::locale::facet *v10; // rax
  char *v11; // rcx
  int v12; // edx
  int v13; // r13d
  struct TrustPoint *v14; // rdi
  __int64 *v15; // rax
  _QWORD *v16; // rbx
  __int64 v17; // rdx
  unsigned __int8 v18; // al
  __int64 v19; // r8
  char *v20; // rdx
  bool v21; // bl
  const char *v22; // rdx
  __int64 NextStateTime; // rax
  char v24; // r9
  volatile signed __int32 *v25; // rbx
  __int64 v26; // r8
  char *v27; // rdx
  bool v28; // bl
  struct _RTL_CRITICAL_SECTION *v29; // rax
  __int64 v30; // rcx
  const char *v31; // rdx
  __int64 v32; // rbx
  __int64 v33; // rcx
  __int64 *v34; // rax
  _QWORD *v35; // rbx
  __int64 v36; // rdx
  unsigned __int8 v37; // al
  __int64 v38; // rbx
  __int64 v39; // rcx
  bool v40; // al
  __int64 v41; // rax
  __int64 i; // rax
  __int64 TrustPointName; // rax
  unsigned __int64 v44; // rbx
  char *v45; // rcx
  int v46; // edx
  struct TrustPoint *v47; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v48; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v49[2]; // [rsp+58h] [rbp-B0h] BYREF
  void **v50; // [rsp+68h] [rbp-A0h] BYREF
  __int64 v51; // [rsp+70h] [rbp-98h] BYREF
  __int64 v52; // [rsp+78h] [rbp-90h] BYREF
  __int64 v53[3]; // [rsp+80h] [rbp-88h] BYREF
  __int64 v54; // [rsp+98h] [rbp-70h] BYREF
  __int64 v55[3]; // [rsp+A0h] [rbp-68h] BYREF
  __int64 v56[9]; // [rsp+B8h] [rbp-50h] BYREF
  FILE *Stream; // [rsp+100h] [rbp-8h]
  __int64 v58[2]; // [rsp+108h] [rbp+0h] BYREF
  int v59; // [rsp+118h] [rbp+10h]
  void ***v60; // [rsp+150h] [rbp+48h]
  __int64 v61; // [rsp+158h] [rbp+50h]
  char v62; // [rsp+160h] [rbp+58h]
  __int64 v63; // [rsp+168h] [rbp+60h] BYREF
  __int64 v64; // [rsp+170h] [rbp+68h] BYREF
  __int64 v65; // [rsp+178h] [rbp+70h] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [rsp+180h] [rbp+78h] BYREF
  __int64 v67; // [rsp+188h] [rbp+80h] BYREF
  __int64 v68; // [rsp+190h] [rbp+88h] BYREF
  unsigned __int16 *v69; // [rsp+198h] [rbp+90h] BYREF
  volatile signed __int32 *v70; // [rsp+1A0h] [rbp+98h]
  int v71; // [rsp+1A8h] [rbp+A0h]
  __int64 v72; // [rsp+1C0h] [rbp+B8h] BYREF
  char *Buffer[3]; // [rsp+1C8h] [rbp+C0h] BYREF
  unsigned __int64 v74; // [rsp+1E0h] [rbp+D8h]
  void *v75[2]; // [rsp+1F0h] [rbp+E8h] BYREF
  size_t v76; // [rsp+200h] [rbp+F8h]
  unsigned __int64 v77; // [rsp+208h] [rbp+100h]
  void *v78[2]; // [rsp+218h] [rbp+110h] BYREF
  size_t v79; // [rsp+228h] [rbp+120h]
  unsigned __int64 v80; // [rsp+230h] [rbp+128h]
  void *v81[5]; // [rsp+240h] [rbp+138h] BYREF
  unsigned __int16 v82[264]; // [rsp+268h] [rbp+160h] BYREF

  v0 = 0;
  LODWORD(v48) = 0;
  v49[0] = (__int64)&std::ifstream::`vbtable';
  v58[0] = (__int64)&std::istream::`vftable';
  v1 = 2;
  v49[1] = 0i64;
  std::ios_base::_Init((std::ios_base *)v58);
  v61 = 0i64;
  v60 = &v50;
  v2 = std::ios_base::getloc((__int64)v58, &v63);
  v3 = std::use_facet<std::ctype<char>>(v2);
  std::locale::~locale((std::locale *)&v63);
  LOBYTE(v4) = 32;
  v62 = (*(__int64 (__fastcall **)(_QWORD *, __int64))(*v3 + 48i64))(v3, v4);
  if ( !v60 )
    std::ios_base::clear((std::ios_base *)v58, v59 | 4, 0);
  *(__int64 *)((char *)v49 + *(int *)(v49[0] + 4)) = (__int64)&std::ifstream::`vftable';
  v50 = &std::streambuf::`vftable';
  std::_Mutex::_Mutex((std::_Mutex *)&v51);
  v5 = (void ***)operator new(8ui64);
  if ( v5 )
  {
    *v5 = std::locale::_Init();
    v6 = std::locale::_Getgloballocale();
    std::_Lockit::_Lockit((std::_Lockit *)&v48, 0);
    v7 = *((_QWORD *)v6 + 1);
    if ( v7 != -1 )
      *((_QWORD *)v6 + 1) = v7 + 1;
    std::_Lockit::~_Lockit((std::_Lockit *)&v48);
  }
  else
  {
    v5 = 0i64;
  }
  v56[3] = (__int64)v5;
  v53[1] = (__int64)&v52;
  v53[0] = 0i64;
  v53[2] = (__int64)v53;
  v55[0] = 0i64;
  v55[1] = (__int64)&v54;
  v56[0] = 0i64;
  v55[2] = (__int64)v55;
  v56[1] = (__int64)v56;
  v56[2] = (__int64)v56 + 4;
  v50 = &std::filebuf::`vftable';
  v52 = 0i64;
  v54 = 0i64;
  std::filebuf::_Init((__int64)&v50, 0i64, 0);
  EnterCriticalSection(&g_csRFC5011_Trust_Points);
  if ( !(unsigned int)File_CreateDatabaseFilePathEx(0i64, 0i64, (char *)v82, 261i64, 0i64, 0i64, L"RFC5011.csv") )
    goto LABEL_112;
  if ( Stream || (v8 = std::_Fiopen(v82, 1, 64)) == 0i64 )
  {
    v11 = (char *)v49 + *(int *)(v49[0] + 4);
    v12 = *((_DWORD *)v11 + 4) | 2;
    if ( !*((_QWORD *)v11 + 9) )
      LOBYTE(v12) = v11[16] | 6;
  }
  else
  {
    std::filebuf::_Init((__int64)&v50, (__int64)v8, 1);
    v9 = std::streambuf::getloc((__int64)&v50, &v64);
    v10 = std::use_facet<std::codecvt<char,char,int>>(v9);
    std::filebuf::_Initcvt(&v50, (__int64)v10);
    std::locale::~locale((std::locale *)&v64);
    v11 = (char *)v49 + *(int *)(v49[0] + 4);
    LOBYTE(v12) = *((_QWORD *)v11 + 9) == 0i64 ? 4 : 0;
  }
  std::ios_base::clear((std::ios_base *)v11, v12, 0);
  if ( !Stream )
  {
    if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 17) & 0x100000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 3u )
    {
      WPP_SF_S(
        *((_QWORD *)WPP_GLOBAL_Control + 7),
        0x49u,
        (__int64)&WPP_4831604f5a2431d08120905ab66c1365_Traceguids,
        v82);
    }
    goto LABEL_112;
  }
  v74 = 15i64;
  v13 = 1;
  Buffer[2] = 0i64;
  LOBYTE(Buffer[0]) = 0;
  v14 = 0i64;
  v47 = 0i64;
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  v15 = std::ios_base::getloc((__int64)v49 + *(int *)(v49[0] + 4), &v65);
  v16 = std::use_facet<std::ctype<char>>(v15);
  std::locale::~locale((std::locale *)&v65);
  LOBYTE(v17) = 10;
  v18 = (*(__int64 (__fastcall **)(_QWORD *, __int64))(*v16 + 48i64))(v16, v17);
  std::getline<char,std::char_traits<char>,std::allocator<char>>((__int64)v49, (size_t *)Buffer, v18);
  if ( (*((_BYTE *)&v50 + *(int *)(v49[0] + 4)) & 6) != 0 )
    goto LABEL_72;
  do
  {
    v76 = 0i64;
    v77 = 15i64;
    LOBYTE(v75[0]) = 0;
    std::string::assign(v75, "TrustAnchor,", (char *)0xC);
    v20 = (char *)v75;
    if ( v77 >= 0x10 )
      v20 = (char *)v75[0];
    v21 = std::string::find((char *)Buffer, v20, v19, v76) == 0;
    if ( v77 >= 0x10 )
      operator delete(v75[0]);
    if ( v21 )
    {
      if ( v14 )
      {
        v22 = (const char *)Buffer;
        if ( v74 >= 0x10 )
          v22 = Buffer[0];
        TrustAnchor::TrustAnchor((TrustAnchor *)&v69, v22);
        if ( v71 <= 0 )
          goto LABEL_33;
        if ( v71 > 2 )
        {
          if ( v71 == 3 )
          {
LABEL_30:
            v24 = 0;
LABEL_32:
            TrustPoint::AddTrustAnchor(v14, (const struct TrustAnchor *)&v69, 0, v24);
            goto LABEL_33;
          }
          if ( v71 > 5 )
          {
            if ( v71 != 6
              || (TrustPoint::DeleteTrustAnchorFromTAZone(v14, &v69),
                  NextStateTime = TrustAnchor::GetNextStateTime((TrustAnchor *)&v69),
                  NextStateTime < *(_QWORD *)&SystemTimeAsFileTime) )
            {
LABEL_33:
              v25 = v70;
              if ( v70 )
              {
                if ( _InterlockedExchangeAdd(v70 + 2, 0xFFFFFFFF) == 1 )
                {
                  (**(void (__fastcall ***)(volatile signed __int32 *))v25)(v25);
                  if ( _InterlockedExchangeAdd(v25 + 3, 0xFFFFFFFF) == 1 )
                    (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v25 + 8i64))(v25);
                }
                v14 = v47;
              }
              goto LABEL_66;
            }
            goto LABEL_30;
          }
        }
        v24 = 1;
        goto LABEL_32;
      }
      if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 17) & 0x100000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 5u )
      {
        WPP_SF_DS(
          *((_QWORD *)WPP_GLOBAL_Control + 7),
          0x47u,
          (__int64)&WPP_4831604f5a2431d08120905ab66c1365_Traceguids,
          v13,
          (__int64)v82);
      }
    }
    else
    {
      v79 = 0i64;
      v80 = 15i64;
      LOBYTE(v78[0]) = 0;
      std::string::assign(v78, "TrustPoint,", (char *)0xB);
      v27 = (char *)v78;
      if ( v80 >= 0x10 )
        v27 = (char *)v78[0];
      v28 = std::string::find((char *)Buffer, v27, v26, v79) == 0;
      if ( v80 >= 0x10 )
        operator delete(v78[0]);
      if ( v28 )
      {
        if ( v14 && !v0 )
        {
          if ( (*((_DWORD *)v14 + 33) & 0xFFFFFFFB) != 0 )
            addTrustPointToGlobalList((struct _RTL_CRITICAL_SECTION **)&v47, 0i64);
          else
            TrustPoint::`scalar deleting destructor'((struct _RTL_CRITICAL_SECTION *)v14);
        }
        v0 = 0;
        v29 = (struct _RTL_CRITICAL_SECTION *)operator new(0x220ui64);
        if ( v29 )
        {
          v31 = (const char *)Buffer;
          if ( v74 >= 0x10 )
            v31 = Buffer[0];
          v14 = TrustPoint::TrustPoint(v29, v31);
        }
        else
        {
          v14 = 0i64;
        }
        v47 = v14;
        if ( v14 )
        {
          if ( !*((_DWORD *)v14 + 33) )
          {
            TrustPoint::`scalar deleting destructor'((struct _RTL_CRITICAL_SECTION *)v14);
            v14 = 0i64;
            v47 = 0i64;
          }
          std::_Tree<std::_Tmap_traits<_CountName,std::unique_ptr<TrustPoint>,CountNameCompare,std::allocator<std::pair<_CountName const,std::unique_ptr<TrustPoint>>>,0>>::find(
            v30,
            &v67,
            (unsigned __int8 *)v14 + 176);
          v32 = v67;
          if ( v67 != qword_1401B9288 )
          {
            v33 = *(_QWORD *)(v67 + 288);
            *(_DWORD *)(v33 + 504) = *((_DWORD *)v14 + 126);
            *(_DWORD *)(v33 + 512) = *((_DWORD *)v14 + 128);
            *(_DWORD *)(v33 + 508) = *((_DWORD *)v14 + 127);
            *(_QWORD *)(v33 + 480) = *((_QWORD *)v14 + 60);
            *(_QWORD *)(v33 + 488) = *((_QWORD *)v14 + 61);
            TrustPoint::`scalar deleting destructor'((struct _RTL_CRITICAL_SECTION *)v14);
            v14 = *(struct TrustPoint **)(v32 + 288);
            v0 = 1;
            v47 = v14;
          }
        }
      }
      else if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
             && (*((_DWORD *)WPP_GLOBAL_Control + 17) & 0x100000) != 0
             && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 5u )
      {
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 7),
          0x48u,
          (__int64)&WPP_4831604f5a2431d08120905ab66c1365_Traceguids,
          v82);
      }
    }
LABEL_66:
    ++v13;
    v34 = std::ios_base::getloc((__int64)v49 + *(int *)(v49[0] + 4), &v68);
    v35 = std::use_facet<std::ctype<char>>(v34);
    std::locale::~locale((std::locale *)&v68);
    LOBYTE(v36) = 10;
    v37 = (*(__int64 (__fastcall **)(_QWORD *, __int64))(*v35 + 48i64))(v35, v36);
    std::getline<char,std::char_traits<char>,std::allocator<char>>((__int64)v49, (size_t *)Buffer, v37);
  }
  while ( (*((_BYTE *)&v50 + *(int *)(v49[0] + 4)) & 6) == 0 );
  if ( v14 && !v0 )
  {
    if ( (*((_DWORD *)v14 + 33) & 0xFFFFFFFB) != 0 )
      addTrustPointToGlobalList((struct _RTL_CRITICAL_SECTION **)&v47, 0i64);
    else
      TrustPoint::`scalar deleting destructor'((struct _RTL_CRITICAL_SECTION *)v14);
  }
LABEL_72:
  if ( v74 >= 0x10 )
    operator delete(Buffer[0]);
  v38 = *(_QWORD *)qword_1401B9288;
  while ( v38 != qword_1401B9288 )
  {
    TrustPoint::UpdateTrustPointState(*(struct _RTL_CRITICAL_SECTION **)(v38 + 288));
    v39 = *(_QWORD *)(v38 + 288);
    if ( *(_DWORD *)(v39 + 132) == 4 || !*(_QWORD *)(v39 + 56) )
    {
      if ( WPP_GLOBAL_Control != (CDnsClientSubnetRecordsTrie *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 17) & 0x100000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 65) >= 4u )
      {
        v1 |= 1u;
        TrustPointName = TrustPoint::GetTrustPointName(v39, (__int64)v81);
        if ( *(_QWORD *)(TrustPointName + 24) >= 0x10ui64 )
          TrustPointName = *(_QWORD *)TrustPointName;
        WPP_SF_s(
          *((_QWORD *)WPP_GLOBAL_Control + 7),
          0x4Au,
          (__int64)&WPP_4831604f5a2431d08120905ab66c1365_Traceguids,
          (const char *)TrustPointName);
      }
      if ( (v1 & 1) != 0 )
      {
        v1 &= ~1u;
        if ( v81[3] >= (void *)0x10 )
          operator delete(v81[0]);
      }
      v38 = *removeTrustPointFromGlobalList(&v72, (__int64 *)v38, 0i64);
    }
    else
    {
      if ( *(_QWORD *)(v39 + 480) )
        v40 = *(_DWORD *)(v39 + 504) == 0;
      else
        v40 = 1;
      TrustPoint::ScheduleActiveRefresh((unsigned int *)v39, !v40, 0);
      if ( !*(_BYTE *)(v38 + 297) )
      {
        v41 = *(_QWORD *)(v38 + 16);
        if ( *(_BYTE *)(v41 + 297) )
        {
          for ( i = *(_QWORD *)(v38 + 8); !*(_BYTE *)(i + 297) && v38 == *(_QWORD *)(i + 16); i = *(_QWORD *)(i + 8) )
            v38 = i;
          v38 = i;
        }
        else
        {
          do
          {
            v38 = v41;
            v41 = *(_QWORD *)v41;
          }
          while ( !*(_BYTE *)(v41 + 297) );
        }
      }
    }
  }
  if ( Stream )
  {
    v44 = (unsigned __int64)&v50 & -(__int64)(std::filebuf::_Endwrite((__int64)&v50) != 0);
    if ( fclose(Stream) )
      v44 = 0i64;
    std::filebuf::_Init((__int64)&v50, 0i64, 2);
    if ( !v44 )
    {
      v45 = (char *)v49 + *(int *)(v49[0] + 4);
      v46 = *((_DWORD *)v45 + 4) | 2;
      if ( !*((_QWORD *)v45 + 9) )
        LOBYTE(v46) = v45[16] | 6;
      std::ios_base::clear((std::ios_base *)v45, v46, 0);
    }
  }
LABEL_112:
  LeaveCriticalSection(&g_csRFC5011_Trust_Points);
  *(__int64 *)((char *)v49 + *(int *)(v49[0] + 4)) = (__int64)&std::ifstream::`vftable';
  std::filebuf::~filebuf<char,std::char_traits<char>>((__int64)&v50);
  *(__int64 *)((char *)v49 + *(int *)(v49[0] + 4)) = (__int64)&std::istream::`vftable';
  v58[0] = (__int64)&std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)v58);
}
// 1400E3424: conditional instruction was optimized away because eax.4>=4
// 1400E30CC: variable 'v4' is possibly undefined
// 1400E332D: variable 'v17' is possibly undefined
// 1400E33BA: variable 'v19' is possibly undefined
// 1400E3566: variable 'v26' is possibly undefined
// 1400E3628: variable 'v30' is possibly undefined
// 1400E3720: variable 'v36' is possibly undefined
// 140171418: using guessed type void *std::streambuf::`vftable';
// 140171498: using guessed type void *std::ios_base::`vftable';
// 1401714D0: using guessed type void *std::filebuf::`vftable';
// 140171650: using guessed type void *std::istream::`vftable';
// 140171660: using guessed type void *std::ifstream::`vftable';
// 140184CA8: using guessed type void __stdcall operator delete(void *);
// 140185140: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD, _QWORD);
// 1401B9288: using guessed type __int64 qword_1401B9288;
