
//----- (0000000180001010) ----------------------------------------------------
int __fastcall dynamic_initializer_for__g_cCipherMill__(CCipherMill *a1)
{
  CCipherMill::CCipherMill(a1);
  return atexit(dynamic_atexit_destructor_for__g_cCipherMill__);
}

//----- (0000000180001040) ----------------------------------------------------
int __fastcall dynamic_initializer_for__g_SslContextManager__(CSslContextManager *a1)
{
  CSslContextManager::CSslContextManager(a1);
  return atexit(dynamic_atexit_destructor_for__g_SslContextManager__);
}

//----- (0000000180001060) ----------------------------------------------------
__int64 __fastcall CSslContext::MakeSessionKeys(CSslContext *this, __int64 a2)
{
  _QWORD *v2; // rsi
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rax
  int v9; // eax
  unsigned int v10; // ebp
  __int64 *v11; // rax
  __int64 v12; // rcx
  int SessionKeys; // eax
  unsigned int v14; // edi
  int v16; // [rsp+40h] [rbp-88h] BYREF
  int v17[2]; // [rsp+48h] [rbp-80h] BYREF
  char *v18; // [rsp+50h] [rbp-78h]
  char v19; // [rsp+60h] [rbp-68h] BYREF

  v16 = 0;
  v2 = (_QWORD *)((char *)this + 160);
  v5 = *((_QWORD *)this + 20);
  if ( v5 )
  {
    SslFreeObject(v5, 0i64);
    *v2 = 0i64;
  }
  v6 = *((_QWORD *)this + 21);
  if ( v6 )
  {
    SslFreeObject(v6, 0i64);
    *((_QWORD *)this + 21) = 0i64;
  }
  if ( (*((_BYTE *)this + 32) & 1) == 0 )
    return 0i64;
  v7 = *((_QWORD *)this + 1);
  if ( !v7 || !*(_DWORD *)(v7 + 28) )
    return 0i64;
  v17[0] = 0;
  v18 = &v19;
  v8 = *(_QWORD *)this;
  v17[1] = 4;
  v9 = (*(__int64 (__fastcall **)(CSslContext *, _QWORD, int *, int *, _QWORD, _QWORD))(v8 + 128))(
         this,
         0i64,
         &v16,
         v17,
         0i64,
         0i64);
  v10 = v9;
  if ( v9 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 601, v9, 0x33u);
    return v10;
  }
  else
  {
    v11 = (__int64 *)*((_QWORD *)this + 1);
    if ( v11 )
      v12 = *v11;
    else
      v12 = 0i64;
    SessionKeys = SslGenerateSessionKeys(v12, a2, v2, (char *)this + 168, v17, 0);
    v14 = SessionKeys;
    if ( !SessionKeys )
      return 0i64;
    CSslContext::SetErrorAndFatalAlert((__int64)this, 600, SessionKeys, 0x33u);
    return v14;
  }
}
// 180098428: using guessed type __int64 __fastcall SslGenerateSessionKeys(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (00000001800011A0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::AllocateAndGenerateCcsAndFinish(CSsl3TlsContext *this, struct SPBuffer *a2)
{
  int v2; // r9d
  unsigned int v5; // ecx
  unsigned int v6; // r9d
  char v7; // al
  int v8; // ecx
  unsigned int v9; // ecx
  unsigned int v10; // r8d
  __int64 result; // rax

  v2 = 1;
  if ( (*((_BYTE *)this + 32) & 4) != 0 )
  {
    v5 = *((_DWORD *)this + 13);
    v6 = *((_DWORD *)this + 12) + 1;
    if ( v5 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v5 -= v6 % v5;
      v6 += v5;
    }
    v2 = *((_DWORD *)this + 11) + v6;
  }
  v7 = *((_BYTE *)this + 233);
  if ( (*((_BYTE *)this + 64) & 0x30) != 0 )
    v8 = v7 != 0 ? 48 : 40;
  else
    v8 = v7 != 0 ? 24 : 16;
  if ( (*((_BYTE *)this + 32) & 1) != 0 )
  {
    v9 = *((_DWORD *)this + 12) + v8;
    v10 = *((_DWORD *)this + 13);
    if ( v10 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v10 -= v9 % v10;
      v9 += v10;
    }
    v8 = *((_DWORD *)this + 11) + v9;
  }
  result = CSsl3TlsContext::AllocateOutputBuffer(this, a2, v2 + v8 + 2 * *((_DWORD *)this + 15));
  if ( !(_DWORD)result )
    return CSsl3TlsContext::GenerateCcsAndFinishMessage(this, a2);
  return result;
}

//----- (0000000180001268) ----------------------------------------------------
__int64 __fastcall VerifyServerCertificate(struct CSsl3TlsContext *a1, DWORD a2, int a3)
{
  __int64 v5; // r13
  __int64 v6; // r15
  unsigned __int16 *v7; // r14
  const CERT_CONTEXT *Ptr; // rsi
  __int64 v9; // r13
  DWORD v10; // eax
  unsigned int v11; // ebx
  __int64 v12; // rdx
  int v13; // eax
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 v24; // rcx
  DWORD dwErrorStatus; // edx
  unsigned __int8 v27; // r9
  int v28; // edx
  int v29; // r8d
  DWORD LastError; // eax
  DWORD v31; // eax
  unsigned __int8 v32; // r9
  char v33[8]; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v34; // [rsp+48h] [rbp-B8h] BYREF
  int v35; // [rsp+50h] [rbp-B0h] BYREF
  PCCERT_CHAIN_CONTEXT pChainContext; // [rsp+58h] [rbp-A8h] BYREF
  int v37; // [rsp+60h] [rbp-A0h]
  __int128 pvData; // [rsp+68h] [rbp-98h] BYREF
  __int128 v39; // [rsp+78h] [rbp-88h] BYREF
  unsigned __int16 *v40; // [rsp+88h] [rbp-78h]
  struct _CERT_CHAIN_POLICY_PARA pPolicyPara; // [rsp+90h] [rbp-70h] BYREF
  struct _CERT_CHAIN_POLICY_STATUS pPolicyStatus; // [rsp+A0h] [rbp-60h] BYREF
  struct _CERT_CHAIN_PARA pChainPara; // [rsp+C0h] [rbp-40h] BYREF
  struct _EVENT_DATA_DESCRIPTOR pCertContext; // [rsp+120h] [rbp+20h] BYREF
  __int64 v45[3]; // [rsp+130h] [rbp+30h] BYREF

  v37 = a3;
  v40 = 0i64;
  v39 = 0i64;
  pPolicyPara = 0i64;
  memset(&pPolicyStatus, 0, sizeof(pPolicyStatus));
  memset_0(&pChainPara, 0, 0x60ui64);
  v5 = *((_QWORD *)a1 + 17);
  v6 = *((_QWORD *)a1 + 10);
  v45[0] = (__int64)"1.3.6.1.5.5.7.3.1";
  pChainContext = 0i64;
  v45[1] = (__int64)"1.3.6.1.4.1.311.10.3.3";
  v7 = 0i64;
  v34 = 0i64;
  v45[2] = (__int64)"2.16.840.1.113730.4.1";
  Ptr = 0i64;
  pCertContext.Ptr = 0i64;
  v9 = v5 & 0x200000000i64;
  v35 = 0;
  v33[0] = 0;
  pvData = 0i64;
  if ( !v6 )
    return (unsigned int)-2146893052;
  (*(void (__fastcall **)(struct CSsl3TlsContext *, __int64 *))(*(_QWORD *)a1 + 224i64))(a1, &v34);
  if ( v34 )
  {
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(v34 + 72), 1u);
    v10 = SPLoadCertificate(
            *(unsigned __int8 **)(v34 + 24),
            *(_DWORD *)(v34 + 32),
            (const struct _CERT_CONTEXT **)&pCertContext);
    Ptr = (const CERT_CONTEXT *)pCertContext.Ptr;
    v11 = v10;
    if ( v10 )
    {
      v27 = 42;
      v28 = 550;
    }
    else
    {
      v12 = v34;
      LODWORD(pvData) = *(_DWORD *)(v34 + 344);
      *((_QWORD *)&pvData + 1) = *(_QWORD *)(v34 + 336);
      if ( (_DWORD)pvData )
      {
        if ( !CertSetCertificateContextProperty((PCCERT_CONTEXT)pCertContext.Ptr, 0x46u, 0, &pvData)
          && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        {
          LastError = GetLastError();
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            21i64,
            &WPP_145b996ecad4340088f3534b93eceddb_Traceguids,
            LastError);
        }
        v12 = v34;
      }
      v13 = *(_DWORD *)(v12 + 360);
      v14 = *(_QWORD *)(v12 + 352);
      *((_QWORD *)&pvData + 1) = v14;
      LODWORD(pvData) = v13;
      if ( v13
        && v14
        && !CertSetCertificateContextProperty(Ptr, 0x77u, 0, &pvData)
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      {
        v31 = GetLastError();
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids, v31);
      }
      if ( SslImpersonateClient(*(_QWORD *)(*((_QWORD *)a1 + 10) + 752i64), &v35) )
      {
        v11 = -2146893052;
LABEL_25:
        if ( v34 )
          RtlReleaseResource((PRTL_RESOURCE)(v34 + 72));
        goto LABEL_27;
      }
      pChainPara.cbSize = 96;
      pChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = (LPSTR *)v45;
      pChainPara.RequestedUsage.dwType = 1;
      pChainPara.RequestedUsage.Usage.cUsageIdentifier = 3;
      if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
        McGenEventWrite_EventWriteTransfer(v15, &ChainBuildStart, v16, v17, &pCertContext);
      if ( CertGetCertificateChain(0i64, Ptr, 0i64, Ptr->hCertStore, &pChainPara, a2, 0i64, &pChainContext) )
      {
        if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
          McGenEventWrite_EventWriteTransfer(v18, &ChainBuildStop, v19, v20, &pCertContext);
        if ( (*(_BYTE *)(v6 + 156) & 2) == 0 )
        {
          v7 = *(unsigned __int16 **)(v34 + 368);
          if ( !v7 || !lstrlenW(*(LPCWSTR *)(v34 + 368)) )
          {
            v11 = -2146893022;
            v28 = 553;
            v27 = 80;
            v29 = -2146893022;
            goto LABEL_40;
          }
        }
        pPolicyPara.dwFlags = 0;
        v39 = 0x200000018ui64;
        v40 = v7;
        pPolicyPara.cbSize = 16;
        pPolicyPara.pvExtraPolicyPara = &v39;
        pPolicyStatus.cbSize = 24;
        if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
          McGenEventWrite_EventWriteTransfer(v18, &ChainVerifyStart, v19, v20, &pCertContext);
        if ( CertVerifyCertificateChainPolicy((LPCSTR)4, pChainContext, &pPolicyPara, &pPolicyStatus) )
        {
          if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
            McGenEventWrite_EventWriteTransfer(v21, &ChainVerifyStop, v22, v23, &pCertContext);
          v24 = v34;
          dwErrorStatus = pChainContext->TrustStatus.dwErrorStatus;
          *(_DWORD *)(v34 + 216) = pPolicyStatus.dwError;
          *(_DWORD *)(v24 + 220) = dwErrorStatus;
          if ( !v9 && (v11 = I_MapWinTrustErrorAndAlert(pPolicyStatus.dwError, 0, v37, v33)) != 0 )
          {
            v32 = v33[0];
            if ( !v33[0] )
              v32 = 80;
            CSslContext::SetErrorAndFatalAlert((__int64)a1, 552, v11, v32);
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              WPP_SF_D(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                24i64,
                &WPP_145b996ecad4340088f3534b93eceddb_Traceguids,
                v11);
            }
            LogBogusServerCertEvent(*(_DWORD *)(v6 + 212), (const unsigned __int16 *)(v6 + 216), Ptr, v7, v11);
          }
          else
          {
            v11 = 0;
          }
          goto LABEL_25;
        }
        if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
          McGenEventWrite_EventWriteTransfer(v21, &ChainVerifyStop, v22, v23, &pCertContext);
        v10 = GetLastError();
        v27 = 80;
        v28 = 552;
        v11 = v10;
      }
      else
      {
        if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
          McGenEventWrite_EventWriteTransfer(v18, &ChainBuildStop, v19, v20, &pCertContext);
        v10 = GetLastError();
        v27 = 80;
        v28 = 551;
        v11 = v10;
      }
    }
    v29 = v10;
LABEL_40:
    CSslContext::SetErrorAndFatalAlert((__int64)a1, v28, v29, v27);
    goto LABEL_25;
  }
  v11 = -2146893052;
LABEL_27:
  if ( pChainContext )
    CertFreeCertificateChain(pChainContext);
  if ( Ptr )
    CertFreeCertificateContext(Ptr);
  if ( v35 )
    RevertToSelf();
  return v11;
}
// 18002B828: variable 'v15' is possibly undefined
// 18002B828: variable 'v16' is possibly undefined
// 18002B828: variable 'v17' is possibly undefined
// 18002B87E: variable 'v18' is possibly undefined
// 18002B87E: variable 'v19' is possibly undefined
// 18002B87E: variable 'v20' is possibly undefined
// 18002B8C5: variable 'v21' is possibly undefined
// 18002B8C5: variable 'v22' is possibly undefined
// 18002B8C5: variable 'v23' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180084C60: using guessed type EVENT_DESCRIPTOR ChainVerifyStop;
// 180084C70: using guessed type EVENT_DESCRIPTOR ChainVerifyStart;
// 180084C80: using guessed type EVENT_DESCRIPTOR ChainBuildStop;
// 180084C90: using guessed type EVENT_DESCRIPTOR ChainBuildStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 180001268: using guessed type char var_140[8];

//----- (0000000180001604) ----------------------------------------------------
ULONG __fastcall SslImpersonateClient(__int64 a1, int *a2)
{
  ULONG result; // eax
  int v4; // eax
  __int64 ThreadInformation; // [rsp+30h] [rbp+8h] BYREF

  ThreadInformation = a1;
  *a2 = 0;
  result = LsaTable;
  if ( LsaTable )
  {
    if ( a1 )
      v4 = NtSetInformationThread((HANDLE)0xFFFFFFFFFFFFFFFEi64, ThreadImpersonationToken, &ThreadInformation, 8u);
    else
      v4 = (*(__int64 (**)(void))(LsaTable + 88))();
    if ( v4 >= 0 )
      *a2 = 1;
    return RtlNtStatusToDosError(v4);
  }
  return result;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180001674) ----------------------------------------------------
__int64 __fastcall I_MapWinTrustErrorAndAlert(int a1, int a2, __int16 a3, char *a4)
{
  char v4; // bl
  CCipherMill *v7; // rcx
  __int64 v8; // rdx

  v4 = 0;
  if ( a1 == -2146885614 )
  {
    if ( (a3 & 0x800) == 0 )
      goto LABEL_32;
    v7 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) == 0 )
      goto LABEL_12;
    v8 = 17i64;
LABEL_26:
    WPP_SF_(*((_QWORD *)v7 + 2), v8, &WPP_145b996ecad4340088f3534b93eceddb_Traceguids);
    goto LABEL_12;
  }
  if ( a1 == -2146885613 )
  {
    if ( (a3 & 0x1000) == 0 )
      goto LABEL_32;
    v7 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) == 0 )
      goto LABEL_12;
    v8 = 18i64;
    goto LABEL_26;
  }
  if ( (a1 & 0x1FFF0000) != 589824 )
  {
    if ( a1 < -2146762495 )
    {
LABEL_35:
      a1 = a2;
      if ( !a2 )
        a1 = -2146893017;
      goto LABEL_37;
    }
    if ( a1 <= -2146762494 )
    {
      a1 = -2146893016;
      v4 = 45;
      goto LABEL_13;
    }
    if ( a1 == -2146762487 )
    {
LABEL_16:
      a1 = -2146893019;
      v4 = 48;
      goto LABEL_13;
    }
    if ( a1 != -2146762484 )
    {
      switch ( a1 )
      {
        case -2146762481:
          a1 = -2146893022;
          break;
        case -2146762480:
          a1 = -2146892983;
          break;
        case -2146762478:
          goto LABEL_16;
        case 0:
LABEL_12:
          a1 = 0;
          goto LABEL_13;
        default:
          goto LABEL_35;
      }
LABEL_32:
      v4 = 43;
      goto LABEL_13;
    }
    a1 = -2146885616;
LABEL_34:
    v4 = 44;
    goto LABEL_13;
  }
  if ( a1 == -2146885616 )
    goto LABEL_34;
  if ( (unsigned int)(a1 + 2146885614) <= 1 )
    goto LABEL_32;
LABEL_37:
  v4 = 46;
LABEL_13:
  if ( a4 )
    *a4 = v4;
  return (unsigned int)a1;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000172C) ----------------------------------------------------
__int64 __fastcall TlsParseAlertMessage(unsigned __int8 *a1, int a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  unsigned int v4; // ebx
  CCipherMill *v8; // rcx
  unsigned int v9; // eax
  int v10; // ecx
  __int64 v12; // rdx
  __int64 v13; // rdx
  __int64 v14; // rdx

  v4 = 0;
  if ( a4 )
    *a4 = 0;
  if ( a2 != 2 || (unsigned __int8)(*a1 - 1) > 1u )
    return 2148074248i64;
  if ( a3 )
  {
    v8 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_L(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x47u,
          (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
          *a1);
        v8 = WPP_GLOBAL_Control;
      }
      if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 1) != 0 )
      {
        WPP_SF_L(*((_QWORD *)v8 + 2), 0x48u, (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, a1[1]);
        v8 = WPP_GLOBAL_Control;
      }
    }
    v9 = a1[1];
    if ( *a1 == 1 )
    {
      if ( (_BYTE)v9 )
      {
        if ( (_BYTE)v9 == 41 )
        {
          if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
            WPP_SF_(*((_QWORD *)v8 + 2), 73i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
          if ( a4 )
            *a4 = 1;
        }
        else if ( (_BYTE)v9 == 100 )
        {
          if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
            WPP_SF_(*((_QWORD *)v8 + 2), 75i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
          v4 = 590688;
        }
        else if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
        {
          WPP_SF_(*((_QWORD *)v8 + 2), 76i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
        }
      }
      else
      {
        if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)v8 + 2), 74i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
        v4 = 590615;
      }
      v10 = *a3;
      *a3 = v10 + 1;
      if ( (unsigned __int8)(v10 + 1) > 5u )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          *a3 = v10;
          WPP_SF_d(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x4Du,
            (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
            v10);
        }
        return 590615;
      }
      return v4;
    }
    if ( v9 > 0x2F )
    {
      if ( v9 > 0x46 )
      {
        switch ( v9 )
        {
          case 'G':
            if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v8 + 2), 94i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146893007;
          case 'P':
            if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v8 + 2), 95i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146893052;
          case 'n':
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893018;
            v12 = 96i64;
            goto LABEL_51;
          case 's':
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893018;
            v12 = 97i64;
            goto LABEL_51;
          case 'x':
            if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v8 + 2), 98i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146892953;
        }
      }
      else
      {
        switch ( v9 )
        {
          case 'F':
            if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v8 + 2), 93i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146893054;
          case '0':
            if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v8 + 2), 88i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146893019;
          case '1':
            if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v8 + 2), 89i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146893044;
          case '2':
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893018;
            v12 = 90i64;
            goto LABEL_51;
          case '3':
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893008;
            v13 = 91i64;
            goto LABEL_56;
          case '<':
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893018;
            v12 = 92i64;
            goto LABEL_51;
        }
      }
    }
    else
    {
      if ( v9 == 47 )
      {
        if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
          return (unsigned int)-2146893018;
        v12 = 87i64;
        goto LABEL_51;
      }
      if ( v9 <= 0x28 )
      {
        switch ( v9 )
        {
          case 0x28u:
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893018;
            v12 = 81i64;
            break;
          case 0xAu:
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893018;
            v12 = 78i64;
            break;
          case 0x14u:
            if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v8 + 2), 79i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146893041;
          case 0x15u:
            if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
              return (unsigned int)-2146893008;
            v13 = 80i64;
LABEL_56:
            WPP_SF_(*((_QWORD *)v8 + 2), v13, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            return (unsigned int)-2146893008;
          case 0x16u:
            return (unsigned int)-2146893018;
          case 0x1Eu:
            return (unsigned int)-2146893041;
          default:
            goto LABEL_48;
        }
LABEL_51:
        WPP_SF_(*((_QWORD *)v8 + 2), v12, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
        return (unsigned int)-2146893018;
      }
      switch ( v9 )
      {
        case '*':
          if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
            return (unsigned int)-2146893017;
          v14 = 82i64;
          goto LABEL_90;
        case '+':
          if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
            return (unsigned int)-2146893017;
          v14 = 83i64;
          goto LABEL_90;
        case ',':
          if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
            WPP_SF_(*((_QWORD *)v8 + 2), 84i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
          return (unsigned int)-2146885616;
        case '-':
          if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
            WPP_SF_(*((_QWORD *)v8 + 2), 85i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
          return (unsigned int)-2146893016;
        case '.':
          if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
            return (unsigned int)-2146893017;
          v14 = 86i64;
LABEL_90:
          WPP_SF_(*((_QWORD *)v8 + 2), v14, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
          return (unsigned int)-2146893017;
      }
    }
LABEL_48:
    if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 4) == 0 )
      return (unsigned int)-2146893018;
    v12 = 99i64;
    goto LABEL_51;
  }
  return 2148074333i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180001820) ----------------------------------------------------
__int64 __fastcall SpUserModeInitialize(int a1, _DWORD *a2, _QWORD *a3, _DWORD *a4)
{
  if ( a2 && a3 && a4 )
  {
    if ( a1 == 0x10000 )
    {
      *a2 = 0x10000;
      *a3 = &SslTable;
      *a4 = 2;
      return (unsigned int)SslInitContextManager() == 0 ? 0xC000009A : 0;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_d(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, a1);
  }
  return 3221225485i64;
}
// 1800912A0: using guessed type struct _SECPKG_USER_FUNCTION_TABLE near *SslTable;

//----- (000000018000187C) ----------------------------------------------------
__int64 SslInitContextManager(void)
{
  unsigned int v0; // ebx
  DWORD v1; // edi
  _QWORD *v2; // rax
  int v4; // eax
  int v5; // eax
  DWORD i; // esi
  DWORD v7; // [rsp+50h] [rbp-28h] BYREF
  HKEY hKey; // [rsp+58h] [rbp-20h] BYREF
  DWORD cbData; // [rsp+80h] [rbp+8h] BYREF
  DWORD Type; // [rsp+88h] [rbp+10h] BYREF
  int Data; // [rsp+90h] [rbp+18h] BYREF
  int v12; // [rsp+98h] [rbp+20h] BYREF

  v0 = 0;
  v1 = 0;
  hKey = 0i64;
  if ( dword_1800921C0 )
    return 1i64;
  if ( !RegCreateKeyExW(
          HKEY_LOCAL_MACHINE,
          L"System\\CurrentControlSet\\Control\\SecurityProviders\\Schannel",
          0,
          (LPWSTR)&Class,
          0,
          0x20019u,
          0i64,
          &hKey,
          &v7) )
  {
    cbData = 4;
    if ( !RegQueryValueExW(hKey, L"UserContextLockCount", 0i64, &Type, (LPBYTE)&Data, &cbData)
      && Type == 4
      && (unsigned int)(Data - 1) <= 0x1FF )
    {
      v4 = dwSslContextLockCount;
      if ( ((Data - 1) & Data) == 0 )
        v4 = Data;
      dwSslContextLockCount = v4;
    }
    cbData = 4;
    if ( !RegQueryValueExW(hKey, L"UserContextListCount", 0i64, &Type, (LPBYTE)&v12, &cbData) && Type == 4 && v12 )
    {
      v5 = dwSslContextListCount;
      if ( ((v12 - 1) & v12) == 0 )
        v5 = v12;
      dwSslContextListCount = v5;
    }
    RegCloseKey(hKey);
    hKey = 0i64;
  }
  SslContextLock = SPExternalAlloc(96 * dwSslContextLockCount);
  if ( !SslContextLock )
    goto LABEL_25;
  while ( 1 )
  {
    cbData = v1;
    if ( v1 >= dwSslContextLockCount )
      break;
    RtlInitializeResource((PRTL_RESOURCE)SslContextLock + v1++);
  }
  SslContextList = SPExternalAlloc(16 * dwSslContextListCount);
  if ( SslContextList )
  {
    while ( v0 < dwSslContextListCount )
    {
      v2 = (char *)SslContextList + 16 * v0;
      v2[1] = v2;
      *v2 = v2;
      ++v0;
    }
    dword_1800921C0 = 1;
    return 1;
  }
  else
  {
LABEL_25:
    if ( SslContextList )
    {
      SPExternalFree(SslContextList);
      SslContextList = 0i64;
    }
    if ( SslContextLock )
    {
      for ( i = 0; i < v1; ++i )
        RtlDeleteResource((PRTL_RESOURCE)SslContextLock + i);
      SPExternalFree(SslContextLock);
      SslContextLock = 0i64;
    }
  }
  return v0;
}
// 1800019FE: conditional instruction was optimized away because esi.4==0
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800919E0: using guessed type unsigned int dwSslContextListCount;
// 1800919E4: using guessed type unsigned int dwSslContextLockCount;
// 1800921C0: using guessed type int dword_1800921C0;

//----- (0000000180001A64) ----------------------------------------------------
__int64 WppInitUm()
{
  CCipherMill *v0; // rbx
  __int64 *v1; // rdi
  __int64 result; // rax
  __int64 v3; // rsi
  HMODULE ModuleHandleW; // rax
  __int64 v5[2]; // [rsp+40h] [rbp-258h] BYREF
  __int128 v6; // [rsp+50h] [rbp-248h] BYREF
  WCHAR v7; // [rsp+60h] [rbp-238h]
  WCHAR Filename[264]; // [rsp+70h] [rbp-228h] BYREF

  v0 = WPP_GLOBAL_Control;
  v1 = &WPP_REGISTRATION_GUIDS;
  memset_0(Filename, 0, 0x208ui64);
  result = SourceString[8];
  v7 = SourceString[8];
  v6 = *(_OWORD *)L"schannel";
  while ( v0 )
  {
    v3 = *v1;
    v5[0] = v3;
    ++v1;
    v5[1] = 0i64;
    *((_QWORD *)v0 + 4) = v3;
    ModuleHandleW = GetModuleHandleW(L"schannel");
    if ( ModuleHandleW )
    {
      GetModuleFileNameW(ModuleHandleW, Filename, 0x104u);
      Filename[259] = 0;
    }
    result = EtwRegisterTraceGuidsW(WppControlCallback, v0, v3, 1i64, v5, Filename, &v6, (char *)v0 + 8);
    v0 = *(CCipherMill **)v0;
  }
  return result;
}
// 180080E10: using guessed type __int64 __fastcall EtwRegisterTraceGuidsW(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 180092A88: using guessed type __int64 WPP_REGISTRATION_GUIDS;

//----- (0000000180001BA0) ----------------------------------------------------
__int64 __fastcall CSessionCacheManager::RunBalancer(CSessionCacheManager *this, int a2)
{
  if ( *((int *)this + 8) > 0 )
    CSessionCacheManager::CacheExpireElements(this, 1, a2 == CSslGlobals::m_dwCleanupIntervalInSeconds);
  return 0i64;
}

//----- (0000000180001BCC) ----------------------------------------------------
__int64 __fastcall VerifyEcdsaParams(
        struct CSsl3TlsClientContext *a1,
        unsigned __int8 *a2,
        unsigned int a3,
        enum _eTlsHashAlgorithm a4,
        unsigned __int8 *pbEncoded,
        DWORD cbEncoded)
{
  struct _RTL_RESOURCE *v7; // rcx
  char *v9; // r14
  const void **v10; // rdi
  BOOL v11; // eax
  struct _RTL_RESOURCE *v12; // rcx
  DWORD LastError; // eax
  DWORD v14; // ebx
  unsigned int v15; // ebx
  enum _eTlsHashAlgorithm v16; // ecx
  NTSTATUS v17; // eax
  NTSTATUS v18; // eax
  unsigned __int8 v20; // r9
  int v21; // r8d
  int v22; // edx
  BCRYPT_KEY_HANDLE *phKey; // [rsp+20h] [rbp-89h]
  __int64 dwFlags; // [rsp+28h] [rbp-81h]
  DWORD cbSignature; // [rsp+40h] [rbp-69h] BYREF
  UCHAR pbOutput[4]; // [rsp+44h] [rbp-65h] BYREF
  ULONG cbHash; // [rsp+48h] [rbp-61h] BYREF
  BCRYPT_KEY_HANDLE hObject; // [rsp+50h] [rbp-59h] BYREF
  ULONG pcbResult; // [rsp+58h] [rbp-51h] BYREF
  unsigned int v30; // [rsp+5Ch] [rbp-4Dh]
  unsigned __int8 *v31; // [rsp+60h] [rbp-49h]
  UCHAR pbHash[64]; // [rsp+70h] [rbp-39h] BYREF

  v31 = a2;
  v7 = (struct _RTL_RESOURCE *)(*((_QWORD *)a1 + 11) + 72i64);
  v30 = a3;
  cbHash = 0;
  hObject = 0i64;
  v9 = 0i64;
  pcbResult = 0;
  v10 = 0i64;
  *(_DWORD *)pbOutput = 0;
  cbSignature = 0;
  RtlAcquireResourceShared(v7, 1u);
  v11 = CryptImportPublicKeyInfoEx2(
          **(_DWORD **)(*((_QWORD *)a1 + 11) + 48i64),
          (PCERT_PUBLIC_KEY_INFO)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 11) + 48i64) + 24i64) + 96i64),
          0x80000000,
          0i64,
          &hObject);
  v12 = (struct _RTL_RESOURCE *)(*((_QWORD *)a1 + 11) + 72i64);
  if ( !v11 )
  {
    RtlReleaseResource(v12);
    LastError = GetLastError();
    v14 = LastError;
    v20 = 43;
LABEL_22:
    v21 = LastError;
    v22 = 1107;
    goto LABEL_34;
  }
  RtlReleaseResource(v12);
  LastError = BCryptGetProperty(hObject, L"KeyLength", pbOutput, 4u, &pcbResult, 0);
  v14 = LastError;
  if ( LastError )
  {
    v20 = 80;
    goto LABEL_22;
  }
  v15 = (*(_DWORD *)pbOutput >> 3) + ((pbOutput[0] & 7) != 0);
  v9 = (char *)SPExternalAlloc(2 * v15);
  if ( !v9 )
  {
    v14 = 14;
    goto LABEL_13;
  }
  if ( CryptDecodeObject(1u, (LPCSTR)0x2F, pbEncoded, cbEncoded, 0, 0i64, &cbSignature) )
  {
    v10 = (const void **)SPExternalAlloc(cbSignature);
    if ( !v10 )
    {
      v14 = -2146893056;
      goto LABEL_13;
    }
    if ( !CryptDecodeObject(1u, (LPCSTR)0x2F, pbEncoded, cbEncoded, 0, v10, &cbSignature) )
    {
      v14 = GetLastError();
      goto LABEL_13;
    }
    if ( *(_DWORD *)v10 <= v15 && *((_DWORD *)v10 + 4) <= v15 )
    {
      memcpy_0(v9, v10[1], *(unsigned int *)v10);
      memcpy_0(&v9[v15], v10[3], *((unsigned int *)v10 + 4));
      cbSignature = 2 * v15;
      ReverseInPlace((unsigned __int8 *)v9, v15);
      ReverseInPlace((unsigned __int8 *)&v9[(unsigned __int64)cbSignature >> 1], cbSignature >> 1);
      v16 = TlsHashAlgorithm_Sha1;
      if ( a4 )
        v16 = a4;
      v17 = GenerateTlsHash(v16, (UCHAR *)a1, v31, v30, pbHash, &cbHash);
      v14 = v17;
      if ( v17 )
      {
        v20 = 80;
        v21 = v17;
        v22 = 1109;
      }
      else
      {
        v18 = BCryptVerifySignature(hObject, 0i64, pbHash, cbHash, (PUCHAR)v9, cbSignature, 0);
        v14 = v18;
        if ( !v18 )
          goto LABEL_13;
        v20 = 51;
        v21 = v18;
        v22 = 1110;
      }
      goto LABEL_34;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      LODWORD(dwFlags) = v15;
      LODWORD(phKey) = *((_DWORD *)v10 + 4);
      WPP_SF_DDD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xAu,
        (__int64)&WPP_3e0ca11e9b65363ec3903422d835754d_Traceguids,
        *(_DWORD *)v10,
        phKey,
        dwFlags);
    }
    v14 = 13;
    v21 = 13;
  }
  else
  {
    v14 = GetLastError();
    v21 = v14;
  }
  v22 = 1108;
  v20 = 50;
LABEL_34:
  CSslContext::SetErrorAndFatalAlert((__int64)a1, v22, v21, v20);
LABEL_13:
  if ( hObject )
    BCryptDestroyKey(hObject);
  if ( v9 )
    SPExternalFree(v9);
  if ( v10 )
    SPExternalFree(v10);
  return v14;
}
// 18002BF6A: variable 'phKey' is possibly undefined
// 18002BF6A: variable 'dwFlags' is possibly undefined

//----- (0000000180001E7C) ----------------------------------------------------
void __fastcall ReverseInPlace(unsigned __int8 *a1, unsigned int a2)
{
  unsigned int v2; // ebx
  unsigned __int8 *v3; // r11
  unsigned __int8 v4; // r8
  unsigned int v5; // eax
  __int64 v6; // rax

  v2 = 0;
  if ( a2 >> 1 )
  {
    v3 = a1;
    do
    {
      v4 = *v3;
      v5 = a2 - v2++;
      v6 = v5 - 1;
      *v3++ = a1[v6];
      a1[(unsigned int)v6] = v4;
    }
    while ( v2 < a2 >> 1 );
  }
}

//----- (0000000180001ED0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::GenerateResponse(CSsl3TlsClientContext *this, struct SPBuffer *a2)
{
  unsigned int CcsAndFinish; // edi
  int v5; // ecx
  int v6; // ecx
  unsigned int ServerHelloResponse; // eax
  int v9; // ecx
  CCipherMill *v10; // rcx
  __int64 v11; // rdx
  unsigned __int8 v12; // [rsp+30h] [rbp+8h] BYREF

  CcsAndFinish = 0;
  v5 = *((_DWORD *)this + 17) - 4;
  if ( v5 )
  {
    v6 = v5 - 87;
    if ( !v6 )
    {
      v12 = 0;
      CcsAndFinish = CSsl3TlsClientContext::CheckForClientCertificatePrivateKeys(this, &v12);
      if ( !v12 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 34i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        ServerHelloResponse = CSsl3TlsClientContext::GenerateServerHelloResponse(this, a2);
        CcsAndFinish = ServerHelloResponse;
        if ( ServerHelloResponse )
        {
          if ( ServerHelloResponse == 590684 )
            *((_DWORD *)this + 17) = 49;
        }
        else
        {
          *((_DWORD *)this + 17) = CSsl3TlsClientContext::IsFalseStartAllowed(this) ? 51 : 46;
        }
      }
      return CcsAndFinish;
    }
    v9 = v6 - 1;
    if ( !v9 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 35i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      CcsAndFinish = CSsl3TlsContext::AllocateAndGenerateCcsAndFinish(this, a2);
      if ( !CcsAndFinish )
        (*(void (__fastcall **)(CSsl3TlsClientContext *))(*(_QWORD *)this + 448i64))(this);
      return CcsAndFinish;
    }
    if ( v9 != 5 )
      return CcsAndFinish;
    v10 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 38i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      v10 = WPP_GLOBAL_Control;
    }
    if ( !*((_BYTE *)this + 233) )
    {
      if ( v10 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v10 + 28) & 4) == 0 )
        return (unsigned int)-2146893018;
      v11 = 39i64;
LABEL_32:
      WPP_SF_(*((_QWORD *)v10 + 2), v11, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      return (unsigned int)-2146893018;
    }
    CcsAndFinish = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, struct SPBuffer *))(*(_QWORD *)this + 216i64))(
                     this,
                     a2);
    if ( !CcsAndFinish )
      *((_DWORD *)this + 17) = 40;
  }
  else
  {
    if ( CSslGlobals::m_fDisableRenegoOnClient )
    {
      v10 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
        return (unsigned int)-2146893018;
      v11 = 36i64;
      goto LABEL_32;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 37i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
    CSchannelTelemetryContext::LogRenegoStart(*((_QWORD *)this + 15), 0, *((_QWORD *)this + 17));
    CcsAndFinish = CSsl3TlsClientContext::GenerateRenegotiateClientHello(this, a2);
    if ( !CcsAndFinish )
    {
      *((_DWORD *)this + 17) = 40;
      if ( *((_BYTE *)this + 233) )
        *(_DWORD *)(*((_QWORD *)this + 73) + 36i64) = *(__int16 *)(*(_QWORD *)(*((_QWORD *)this + 73) + 40i64) + 192i64);
    }
    *((_QWORD *)this + 17) &= ~0x40000000ui64;
  }
  return CcsAndFinish;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800927C4: using guessed type int CSslGlobals::m_fDisableRenegoOnClient;

//----- (0000000180001FC8) ----------------------------------------------------
bool __fastcall CSsl3TlsClientContext::IsFalseStartAllowed(CSsl3TlsClientContext *this)
{
  bool result; // al
  __int64 v2; // rax
  unsigned int v3; // ecx

  result = 0;
  if ( *((_BYTE *)this + 556) )
  {
    if ( *((_DWORD *)this + 16) == 2048 && !*((_BYTE *)this + 1315) && (*((_BYTE *)this + 32) & 8) != 0 )
    {
      v2 = *((_QWORD *)this + 1);
      if ( v2 )
      {
        v3 = *(_DWORD *)(v2 + 28);
        if ( v3 >= 0xC023
          && (v3 <= 0xC024 || v3 > 0xC026 && (v3 <= 0xC028 || v3 > 0xC02A && (v3 <= 0xC02C || v3 - 49199 <= 1))) )
        {
          return 1;
        }
      }
    }
  }
  return result;
}

//----- (0000000180002040) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::GenerateServerHelloResponse(CSsl3TlsClientContext *this, struct SPBuffer *a2)
{
  unsigned int v4; // ebp
  unsigned int v5; // esi
  char v6; // r8
  int v7; // r14d
  __int64 v8; // rax
  __int64 v9; // r12
  unsigned int v10; // r13d
  char v11; // r11
  __int16 v12; // r10
  int v13; // ecx
  unsigned int v14; // ecx
  unsigned int v15; // r8d
  int v16; // ecx
  int v17; // ecx
  int v18; // r8d
  unsigned int v19; // r9d
  unsigned int v20; // r8d
  int v21; // r9d
  unsigned int v22; // r9d
  unsigned int v23; // r10d
  unsigned int OutputBuffer; // ebx
  unsigned int v25; // r14d
  unsigned int v26; // ecx
  __int64 v27; // rax
  __int16 v28; // r12
  _BYTE *v29; // rsi
  unsigned int v30; // r9d
  __int16 *v31; // rbp
  __int16 v32; // cx
  const void *v33; // r8
  __int64 v34; // r9
  unsigned __int8 *v35; // rsi
  unsigned int v36; // r14d
  __int64 v37; // rax
  __int64 v38; // rbx
  __int64 v39; // rax
  unsigned int CcsAndFinishMessage; // eax
  __int64 v42; // rbx
  int UserMappingDataMsg; // esi
  int v44; // edx
  int v45; // r8d
  CSsl3TlsClientContext *v46; // rcx
  __int64 v47; // rdx
  unsigned int v48; // ebx
  int v49; // ecx
  unsigned int v50; // r8d
  unsigned int v51; // ecx
  __int64 v52; // rcx
  int v53; // eax
  unsigned int v54; // r14d
  __int64 v55; // r9
  size_t v56; // r8
  unsigned int v57; // ebp
  bool v58; // zf
  unsigned int v59; // edx
  unsigned int v60; // ebp
  __int64 v61; // r9
  __int64 v62; // rax
  unsigned int CertVerify; // eax
  int v64; // edi
  int v65; // ebx
  __int64 v66; // r9
  int v67; // ebp
  __int16 v68; // cx
  _BYTE *v69; // rdx
  int v70; // eax
  unsigned int v71; // [rsp+30h] [rbp-68h] BYREF
  unsigned int v72; // [rsp+34h] [rbp-64h]
  int v73; // [rsp+38h] [rbp-60h]
  void *Src; // [rsp+40h] [rbp-58h]
  struct _UNICODE_STRING DestinationString; // [rsp+48h] [rbp-50h] BYREF
  size_t Size; // [rsp+A0h] [rbp+8h] BYREF
  unsigned int v77; // [rsp+B0h] [rbp+18h]
  unsigned int v78; // [rsp+B8h] [rbp+20h]

  v78 = 0;
  v4 = 0;
  v71 = 0;
  v5 = 0;
  v6 = *((_BYTE *)this + 233);
  v7 = 0;
  Src = 0i64;
  v77 = 0;
  v8 = *((_QWORD *)this + 1);
  v72 = 0;
  LODWORD(Size) = 0;
  v9 = v6 != 0 ? 13 : 5;
  v73 = v6 != 0 ? 13 : 5;
  v10 = v6 != 0 ? 12 : 4;
  if ( *(_DWORD *)(v8 + 48) == 4 )
  {
    if ( !*((_QWORD *)this + 106) )
      return 590624;
    goto LABEL_3;
  }
  if ( !*((_BYTE *)this + 1315) )
  {
LABEL_3:
    if ( (*((_DWORD *)this + 16) & 0x80800) != 0 )
      CSsl3TlsContext::FreeTlsClientAuthHandshakeHashes(this);
    goto LABEL_5;
  }
  v42 = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *))(*(_QWORD *)this + 248i64))(this);
  if ( v42 )
  {
    if ( *((_BYTE *)this + 922) )
    {
      UserMappingDataMsg = CreateUserMappingDataMsg(
                             0i64,
                             0,
                             *(unsigned __int16 **)(*((_QWORD *)this + 10) + 872i64),
                             *(unsigned __int16 **)(*((_QWORD *)this + 10) + 880i64));
      if ( !UserMappingDataMsg )
      {
        OutputBuffer = 1359;
        v44 = 151;
        v45 = 1359;
        goto LABEL_117;
      }
      v5 = v10 + UserMappingDataMsg;
      v72 = v5;
    }
    v4 = *(_DWORD *)(v42 + 448);
    v46 = this;
    Src = *(void **)(v42 + 440);
    v77 = v4;
    if ( v4 > 0x3FFF )
    {
      OutputBuffer = 1359;
      v44 = 150;
      v45 = 1359;
LABEL_118:
      CSslContext::SetErrorAndFatalAlert((__int64)v46, v44, v45, 0x50u);
      return OutputBuffer;
    }
    LODWORD(Size) = v4 + v10 + 3;
    OutputBuffer = CSsl3TlsClientContext::GenerateCertVerify(this, 0i64, &v71);
    if ( OutputBuffer )
      return OutputBuffer;
    v78 = v10 + v71;
  }
  else
  {
    v47 = *((_QWORD *)this + 10);
    v48 = *(_DWORD *)(v47 + 212);
    if ( (g_dwEventLogging & 2) != 0 )
    {
      RtlInitUnicodeString(&DestinationString, (PCWSTR)(v47 + 216));
      SchEventWrite(&SSLEVENT_NO_CLIENT_CERT_FOUND, L"du", v48, &DestinationString);
    }
    if ( (*((_BYTE *)this + 64) & 0x30) != 0 )
    {
      v49 = 2;
      if ( (*((_BYTE *)this + 32) & 4) != 0 )
      {
        v50 = *((_DWORD *)this + 13);
        v51 = *((_DWORD *)this + 12) + 2;
        if ( v50 )
        {
          if ( (*((_BYTE *)this + 56) & 1) != 0 )
            v50 -= v51 % v50;
          v51 += v50;
        }
        v49 = *((_DWORD *)this + 11) + v51;
      }
      v7 = v49 + *((_DWORD *)this + 15);
    }
    else
    {
      LODWORD(Size) = v10 + 3;
    }
  }
LABEL_5:
  v11 = *((_BYTE *)this + 233);
  v12 = *((_WORD *)this + 16);
  v13 = v5 + v78 + Size + v10 + *((_DWORD *)this + 240);
  if ( v11 )
  {
    v16 = v9 + v13;
  }
  else
  {
    if ( (v12 & 4) != 0 )
    {
      v14 = *((_DWORD *)this + 12) + v13;
      v15 = *((_DWORD *)this + 13);
      if ( v15 )
      {
        if ( (*((_BYTE *)this + 56) & 1) != 0 )
          v15 -= v14 % v15;
        v14 += v15;
      }
      v13 = *((_DWORD *)this + 11) + v14;
    }
    v16 = *((_DWORD *)this + 15) + v13;
  }
  v17 = v7 + v16;
  v18 = 1;
  if ( (v12 & 4) != 0 )
  {
    v19 = *((_DWORD *)this + 13);
    v20 = *((_DWORD *)this + 12) + 1;
    if ( v19 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v19 -= v20 % v19;
      v20 += v19;
    }
    v18 = *((_DWORD *)this + 11) + v20;
  }
  if ( (*((_BYTE *)this + 64) & 0x30) != 0 )
    v21 = v11 != 0 ? 48 : 40;
  else
    v21 = v11 != 0 ? 24 : 16;
  if ( (v12 & 1) != 0 )
  {
    v22 = *((_DWORD *)this + 12) + v21;
    v23 = *((_DWORD *)this + 13);
    if ( v23 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v23 -= v22 % v23;
      v22 += v23;
    }
    v21 = *((_DWORD *)this + 11) + v22;
  }
  OutputBuffer = CSsl3TlsContext::AllocateOutputBuffer(this, a2, v17 + v21 + v18 + 2 * *((_DWORD *)this + 15));
  if ( OutputBuffer )
    return OutputBuffer;
  if ( v7 )
  {
    v52 = *((_BYTE *)this + 233) && (*((_BYTE *)this + 32) & 4) != 0 ? *((unsigned int *)this + 11) : 0i64;
    *(_WORD *)(v52 + v9 + *((_QWORD *)a2 + 1) + *((unsigned int *)a2 + 1)) = 10497;
    v53 = CSsl3TlsContext::WrapMessage((__int64)this, (__int64)a2, 21, 2u);
    OutputBuffer = v53;
    if ( v53 )
    {
      CSslContext::SetError((__int64)this, 951, v53);
      return OutputBuffer;
    }
  }
  v25 = 0;
  if ( !*((_BYTE *)this + 233) && (*((_BYTE *)this + 32) & 4) != 0 )
    v26 = *((_DWORD *)this + 11);
  else
    v26 = 0;
  v27 = v9 + *((unsigned int *)a2 + 1);
  v28 = 0;
  v29 = (_BYTE *)(*((_QWORD *)a2 + 1) + v27 + v26);
  if ( v72 )
  {
    v54 = CreateUserMappingDataMsg(
            &v29[v10],
            v72,
            *(unsigned __int16 **)(*((_QWORD *)this + 10) + 872i64),
            *(unsigned __int16 **)(*((_QWORD *)this + 10) + 880i64));
    if ( !v54 )
      return 1359;
    SetHandshakeHeader((__int64)v29, 23, 0i64, v54, *((_WORD *)this + 110), *((unsigned __int8 *)this + 233));
    if ( *((_BYTE *)this + 233) )
    {
      ++*((_WORD *)this + 110);
      v28 = 1;
    }
    v25 = v10 + v54;
    if ( !*((_BYTE *)this + 1032) )
    {
      LOBYTE(v55) = 1;
      OutputBuffer = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, _BYTE *, _QWORD, __int64))(*(_QWORD *)this
                                                                                                  + 504i64))(
                       this,
                       v29,
                       v25,
                       v55);
    }
    if ( !OutputBuffer )
    {
      v29 += v25;
      goto LABEL_27;
    }
    v45 = OutputBuffer;
    v44 = 1001;
LABEL_117:
    v46 = this;
    goto LABEL_118;
  }
LABEL_27:
  if ( !(_DWORD)Size )
    goto LABEL_28;
  v56 = v4;
  v57 = HIWORD(v4);
  v58 = *((_BYTE *)this + 233) == 0;
  LODWORD(Size) = v77 >> 8;
  if ( v58 )
  {
    memcpy_0(v29 + 7, Src, v56);
    v59 = v77;
    v29[5] = Size;
    v29[6] = v59;
    v29[4] = v57;
  }
  else
  {
    memcpy_0(v29 + 15, Src, v56);
    v59 = v77;
    v29[13] = Size;
    v29[14] = v59;
    v29[12] = v57;
  }
  v60 = v59 + v10 + 3;
  SetHandshakeHeader((__int64)v29, 11, 0i64, v59 + 3, *((_WORD *)this + 110), *((unsigned __int8 *)this + 233));
  if ( *((_BYTE *)this + 233) )
  {
    ++v28;
    ++*((_WORD *)this + 110);
  }
  if ( !*((_BYTE *)this + 1032) )
  {
    LOBYTE(v61) = 1;
    OutputBuffer = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, _BYTE *, _QWORD, __int64))(*(_QWORD *)this
                                                                                                + 504i64))(
                     this,
                     v29,
                     v60,
                     v61);
  }
  if ( OutputBuffer )
  {
    v45 = OutputBuffer;
    v44 = 1002;
    goto LABEL_117;
  }
  v29 += v60;
  v25 += v60;
LABEL_28:
  v30 = *((_DWORD *)this + 240);
  v31 = (__int16 *)((char *)this + 220);
  v32 = *((_WORD *)this + 110);
  v33 = (const void *)*((_QWORD *)this + 119);
  LODWORD(Size) = v30 + v10;
  SetHandshakeHeader((__int64)v29, 16, v33, v30, v32, *((unsigned __int8 *)this + 233));
  if ( *((_BYTE *)this + 233) )
  {
    ++v28;
    ++*v31;
  }
  if ( !*((_BYTE *)this + 1032) )
  {
    LOBYTE(v34) = 1;
    OutputBuffer = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, _BYTE *, _QWORD, __int64))(*(_QWORD *)this
                                                                                                + 504i64))(
                     this,
                     v29,
                     (unsigned int)Size,
                     v34);
  }
  if ( OutputBuffer )
  {
    v45 = OutputBuffer;
    v44 = 1003;
    goto LABEL_117;
  }
  v35 = &v29[(unsigned int)Size];
  v36 = Size + v25;
  if ( (*((_DWORD *)this + 34) & 0x8000000) == 0 || *((_BYTE *)this + 1032) )
    goto LABEL_38;
  v37 = *(_QWORD *)this;
  if ( (unsigned int)(*(_DWORD *)(*((_QWORD *)this + 1) + 48i64) - 2) > 2 )
  {
    v62 = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *))(v37 + 160))(this);
    OutputBuffer = MakeRsaSessionKeysHelper(this, v62);
    (*(void (__fastcall **)(CSsl3TlsClientContext *, _QWORD))(*(_QWORD *)this + 168i64))(this, 0i64);
  }
  else
  {
    v38 = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *))(v37 + 144))(this);
    v39 = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *))(*(_QWORD *)this + 160i64))(this);
    OutputBuffer = MakeEccDhPskSessionKeysHelper(this, v39, v38, 0);
    (*(void (__fastcall **)(CSsl3TlsClientContext *, _QWORD))(*(_QWORD *)this + 168i64))(this, 0i64);
    (*(void (__fastcall **)(CSsl3TlsClientContext *, _QWORD))(*(_QWORD *)this + 152i64))(this, 0i64);
  }
  if ( !OutputBuffer )
  {
LABEL_38:
    if ( !v78 )
      goto LABEL_39;
    CertVerify = CSsl3TlsClientContext::GenerateCertVerify(this, &v35[v10], (unsigned int *)&Size);
    OutputBuffer = CertVerify;
    if ( CertVerify == 590684 )
    {
      v64 = Size;
      if ( (unsigned int)Size > *(_DWORD *)a2 )
      {
        OutputBuffer = 1359;
      }
      else
      {
        memcpy_0(*((void **)a2 + 1), v35, (unsigned int)Size);
        *((_DWORD *)a2 + 1) = v64;
      }
    }
    else if ( !CertVerify )
    {
      v65 = Size;
      SetHandshakeHeader((__int64)v35, 15, 0i64, Size, *v31, *((unsigned __int8 *)this + 233));
      if ( *((_BYTE *)this + 233) )
        ++*v31;
      v67 = v65 + v10;
      LOBYTE(v66) = 1;
      CcsAndFinishMessage = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, unsigned __int8 *, _QWORD, __int64))(*(_QWORD *)this + 504i64))(
                              this,
                              v35,
                              v65 + v10,
                              v66);
      OutputBuffer = CcsAndFinishMessage;
      if ( CcsAndFinishMessage )
      {
        v44 = 1004;
        goto LABEL_116;
      }
      v36 += v67;
LABEL_39:
      if ( *((_BYTE *)this + 233) )
      {
        v68 = *((_WORD *)this + 17);
        v69 = (_BYTE *)*((_QWORD *)a2 + 1);
        v69[1] = HIBYTE(v68);
        v69[11] = BYTE1(v36);
        v70 = v36 + v73;
        v69[2] = v68;
        *v69 = 22;
        v69[12] = v36;
        *((_DWORD *)a2 + 1) += v70;
        goto LABEL_41;
      }
      CcsAndFinishMessage = CSsl3TlsContext::WrapMessage((__int64)this, (__int64)a2, 22, v36);
      OutputBuffer = CcsAndFinishMessage;
      if ( !CcsAndFinishMessage )
      {
LABEL_41:
        CcsAndFinishMessage = CSsl3TlsContext::GenerateCcsAndFinishMessage(this, a2);
        OutputBuffer = CcsAndFinishMessage;
        if ( !CcsAndFinishMessage )
          return OutputBuffer;
        v44 = 152;
        goto LABEL_116;
      }
      v44 = 952;
LABEL_116:
      v45 = CcsAndFinishMessage;
      goto LABEL_117;
    }
    *v31 -= v28;
  }
  return OutputBuffer;
}
// 18000227D: variable 'v34' is possibly undefined
// 18002C3CB: variable 'v55' is possibly undefined
// 18002C4C8: variable 'v61' is possibly undefined
// 18002C5FC: variable 'v66' is possibly undefined

//----- (0000000180002410) ----------------------------------------------------
void __fastcall CSsl3TlsContext::FreeTlsClientAuthHandshakeHashes(CSsl3TlsContext *this)
{
  unsigned int v2; // edi
  __int64 v3; // rcx

  *((_DWORD *)this + 180) = 0;
  if ( *((_DWORD *)this + 137) > 1u )
  {
    v2 = 1;
    do
    {
      v3 = *((_QWORD *)this + v2 + 74);
      if ( v3 )
      {
        SslFreeObject(v3, 0i64);
        *((_QWORD *)this + v2 + 74) = 0i64;
      }
      ++v2;
    }
    while ( v2 < *((_DWORD *)this + 137) );
    *((_DWORD *)this + 137) = 1;
  }
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180002488) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::CheckForClientCertificatePrivateKeys(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2)
{
  __int64 result; // rax

  if ( !a2 )
    return 87i64;
  result = 0i64;
  *a2 = 0;
  if ( *((_BYTE *)this + 923) )
  {
    result = CSsl3TlsClientContext::CheckForClientCred(this);
    if ( *((_BYTE *)this + 923) )
    {
      *((_DWORD *)this + 18) = *((_DWORD *)this + 17);
      result = 590610i64;
      *((_DWORD *)this + 17) = 77;
    }
    else if ( *((_BYTE *)this + 924) || (_DWORD)result != -2146893024 )
    {
      if ( !(_DWORD)result || (_DWORD)result == 590624 || (_DWORD)result == -2146893024 )
        return result;
    }
    else
    {
      result = 590624i64;
    }
    *a2 = 1;
  }
  return result;
}

//----- (00000001800024D0) ----------------------------------------------------
__int64 __fastcall MakeEccDhPskSessionKeysHelper(struct CSsl3TlsContext *a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v8; // rcx
  _WORD *v9; // r9
  int v10; // eax
  unsigned int v11; // edi
  __int64 v12; // rax
  __int64 *v13; // rcx
  __int64 v14; // rcx
  int v15; // eax
  unsigned int v16; // edi
  __int64 v17; // r8
  __int64 *v18; // rdx
  int v19; // r8d
  int v20; // r9d
  __int64 v21; // rcx
  __int64 v22; // rcx
  unsigned int v23; // edi
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // r15
  __int64 v29; // rcx
  __int64 v30; // rax
  int v31; // eax
  unsigned int v32; // esi
  __int64 *v33; // rax
  __int64 v34; // rcx
  __int64 v35; // rcx
  int v37; // edx
  unsigned int v38; // [rsp+60h] [rbp-A0h] BYREF
  int v39; // [rsp+64h] [rbp-9Ch] BYREF
  __int64 v40; // [rsp+68h] [rbp-98h] BYREF
  int v41; // [rsp+70h] [rbp-90h] BYREF
  int v42; // [rsp+74h] [rbp-8Ch]
  __int128 *v43; // [rsp+78h] [rbp-88h]
  struct _EVENT_DATA_DESCRIPTOR v44; // [rsp+80h] [rbp-80h] BYREF
  __int128 v45; // [rsp+90h] [rbp-70h] BYREF
  __int128 v46; // [rsp+A0h] [rbp-60h]
  __int128 v47; // [rsp+B0h] [rbp-50h]
  char v48; // [rsp+C0h] [rbp-40h] BYREF
  char v49[64]; // [rsp+100h] [rbp+0h] BYREF

  v40 = 0i64;
  v42 = 0;
  v45 = 0i64;
  v46 = 0i64;
  v47 = 0i64;
  memset_0(v49, 0, sizeof(v49));
  v38 = 0;
  if ( !a1 )
    return 87i64;
  v43 = &v45;
  v10 = *((_DWORD *)a1 + 34);
  v41 = 0;
  if ( (v10 & 0x8000000) != 0 )
  {
    v11 = *((unsigned __int16 *)a1 + 17);
    v12 = (*(__int64 (__fastcall **)(struct CSsl3TlsContext *, _QWORD))(*(_QWORD *)a1 + 512i64))(a1, 0i64);
    v13 = (__int64 *)*((_QWORD *)a1 + 1);
    if ( v13 )
      v14 = *v13;
    else
      v14 = 0i64;
    v15 = SslComputeSessionHash(v14, v12, v11, v49, 64, &v38, 0);
    v16 = v15;
    if ( v15 )
    {
      CSslContext::SetErrorAndFatalAlert((__int64)a1, 604, v15, 0x33u);
      return v16;
    }
    v17 = 1i64;
    *(_QWORD *)&v45 = v38 | 0x1900000000i64;
    *((_QWORD *)&v45 + 1) = v49;
  }
  else
  {
    *((_QWORD *)&v45 + 1) = (char *)a1 + 272;
    v17 = 2i64;
    *(_QWORD *)&v45 = 0x1400000020i64;
    *((_QWORD *)&v46 + 1) = (char *)a1 + 304;
    *(_QWORD *)&v46 = 0x1500000020i64;
  }
  v18 = (__int64 *)*((_QWORD *)a1 + 1);
  v42 = v17;
  if ( *((_DWORD *)v18 + 12) == 4 )
  {
    v9 = (_WORD *)*((_QWORD *)a1 + 106);
    if ( !v9 )
      return 590624i64;
    if ( !*v9 )
    {
      CSslContext::SetErrorAndFatalAlert((__int64)a1, 602, 87, 0x73u);
      return 87i64;
    }
    v8 = 2i64 * (unsigned int)v17;
    v17 = (unsigned int)(v17 + 1);
    *((_DWORD *)&v45 + 2 * v8 + 1) = 23;
    *((_DWORD *)&v45 + 2 * v8) = (unsigned __int16)*v9;
    *((_QWORD *)&v45 + v8 + 1) = v9 + 1;
    v42 = v17;
  }
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
  {
    McGenEventWrite_EventWriteTransfer(v8, &GenerateMasterKeyStart, v17, (__int64)v9, &v44);
    v18 = (__int64 *)*((_QWORD *)a1 + 1);
  }
  if ( (*((_BYTE *)a1 + 32) & 1) != 0 )
  {
    v18 = (__int64 *)*((_QWORD *)a1 + 1);
    if ( v18 )
    {
      v19 = *((_DWORD *)v18 + 7);
      v20 = *((unsigned __int16 *)a1 + 17);
LABEL_13:
      v21 = *v18;
      goto LABEL_14;
    }
  }
  v20 = *((unsigned __int16 *)a1 + 17);
  v19 = 0;
  if ( v18 )
    goto LABEL_13;
  v21 = 0i64;
LABEL_14:
  v23 = SslGenerateMasterKey(v21, a2, a3, &v40, v20, v19, &v41, 0i64, 0, &v38, (unsigned int)(a4 != 0) + 1);
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EventWriteTransfer(v22, &GenerateMasterKeyStop, v24, v25, &v44);
  if ( v23 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)a1, 602, v23, 0x33u);
    return v23;
  }
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)a1 + 11) + 72i64), 1u);
  v26 = *((_QWORD *)a1 + 11);
  v39 = 0;
  *(_QWORD *)(v26 + 16) = v40;
  v27 = *((_QWORD *)a1 + 20);
  v28 = v40;
  if ( v27 )
  {
    SslFreeObject(v27, 0i64);
    *((_QWORD *)a1 + 20) = 0i64;
  }
  v29 = *((_QWORD *)a1 + 21);
  if ( v29 )
  {
    SslFreeObject(v29, 0i64);
    *((_QWORD *)a1 + 21) = 0i64;
  }
  if ( (*((_BYTE *)a1 + 32) & 1) == 0 )
    goto LABEL_28;
  v30 = *((_QWORD *)a1 + 1);
  if ( !v30 || !*(_DWORD *)(v30 + 28) )
    goto LABEL_28;
  v44.Ptr = 0x400000000i64;
  *(_QWORD *)&v44.Size = &v48;
  v31 = (*(__int64 (__fastcall **)(struct CSsl3TlsContext *, _QWORD, int *, struct _EVENT_DATA_DESCRIPTOR *, _QWORD, _QWORD))(*(_QWORD *)a1 + 128i64))(
          a1,
          0i64,
          &v39,
          &v44,
          0i64,
          0i64);
  v32 = v31;
  if ( v31 )
  {
    v37 = 601;
LABEL_46:
    CSslContext::SetErrorAndFatalAlert((__int64)a1, v37, v31, 0x33u);
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)a1 + 11) + 72i64));
    return v32;
  }
  v33 = (__int64 *)*((_QWORD *)a1 + 1);
  if ( v33 )
    v34 = *v33;
  else
    v34 = 0i64;
  v31 = SslGenerateSessionKeys(v34, v28, (char *)a1 + 160, (char *)a1 + 168, &v44, 0);
  v32 = v31;
  if ( v31 )
  {
    v37 = 600;
    goto LABEL_46;
  }
LABEL_28:
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)a1 + 11) + 72i64));
  v35 = 8i64;
  if ( !a4 )
    v35 = 6i64;
  LsaIModifyPerformanceCounter(v35);
  return 0i64;
}
// 18002C76C: variable 'v8' is possibly undefined
// 18002C76C: variable 'v9' is possibly undefined
// 18002C78A: variable 'v22' is possibly undefined
// 18002C78A: variable 'v24' is possibly undefined
// 18002C78A: variable 'v25' is possibly undefined
// 180084BE0: using guessed type EVENT_DESCRIPTOR GenerateMasterKeyStop;
// 180084BF0: using guessed type EVENT_DESCRIPTOR GenerateMasterKeyStart;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);
// 180098428: using guessed type __int64 __fastcall SslGenerateSessionKeys(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 1800984A0: using guessed type __int64 __fastcall SslGenerateMasterKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 180098530: using guessed type __int64 __fastcall SslComputeSessionHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180002858) ----------------------------------------------------
__int64 __fastcall CSessionCacheClientItem::CloneCacheElement(
        CSessionCacheClientItem *this,
        struct CSessionCacheManager *a2,
        struct CSessionCacheClientItem **a3)
{
  __int64 result; // rax
  struct CSessionCacheClientItem *v6; // rcx
  struct CSessionCacheClientItem *v7; // [rsp+30h] [rbp+8h] BYREF

  v7 = 0i64;
  result = CSessionCacheManager::CacheRetrieveNewClientItem(a2, *((const unsigned __int16 **)this + 46), &v7);
  if ( !(_DWORD)result )
  {
    v6 = v7;
    *((_DWORD *)v7 + 42) = *((_DWORD *)this + 42);
    *(_QWORD *)((char *)v6 + 188) = *(_QWORD *)((char *)this + 188);
    result = 0i64;
    *((_QWORD *)v6 + 48) = this;
    *a3 = v6;
  }
  return result;
}

//----- (00000001800028C8) ----------------------------------------------------
void __fastcall CSessionCacheManager::PurgeCacheForProcessId(CSessionCacheManager *this, int a2)
{
  unsigned int v2; // edi

  v2 = 0;
  if ( *((_DWORD *)this + 8) )
  {
    if ( *((_DWORD *)this + 12) )
    {
      do
        CSessionCacheTable::ExpireItemsBoundToProcess((CSessionCacheTable *)(*((_QWORD *)this + 5) + 152i64 * v2++), a2);
      while ( v2 < *((_DWORD *)this + 12) );
    }
    CSessionCacheManager::CacheExpireElements(this, 0, 0);
  }
}

//----- (0000000180002928) ----------------------------------------------------
void __fastcall CSessionCacheTable::ExpireItemsBoundToProcess(CSessionCacheTable *this, int a2)
{
  struct _RTL_RESOURCE *v2; // rbp
  _QWORD **v4; // r14
  _QWORD *v5; // rdi
  _QWORD *v6; // rbx

  v2 = (struct _RTL_RESOURCE *)((char *)this + 48);
  v4 = (_QWORD **)((char *)this + 16);
  RtlAcquireResourceShared((PRTL_RESOURCE)((char *)this + 48), 1u);
  v5 = *v4;
  while ( v5 != v4 )
  {
    v6 = v5;
    v5 = (_QWORD *)*v5;
    RtlAcquireResourceShared((PRTL_RESOURCE)(v6 - 29), 1u);
    if ( *((_DWORD *)v6 - 8) == a2 )
    {
      RtlConvertSharedToExclusive((PRTL_RESOURCE)(v6 - 29));
      if ( *((_DWORD *)v6 - 8) == a2 )
      {
        *((_DWORD *)v6 - 8) = 0;
        *((_WORD *)v6 - 34) = 0;
      }
    }
    RtlReleaseResource((PRTL_RESOURCE)(v6 - 29));
  }
  RtlReleaseResource(v2);
}

//----- (00000001800029E8) ----------------------------------------------------
__int64 __fastcall MontgomeryGetEccPublicKeyBlob(
        unsigned __int8 *Src,
        size_t Size,
        struct _BCRYPT_ECCKEY_BLOB *a3,
        unsigned int a4)
{
  unsigned int v4; // ebx

  v4 = 0;
  if ( a3 && Src && (unsigned __int64)(unsigned int)(2 * Size) + 8 <= a4 )
    memcpy_0(&a3[1], Src, (unsigned int)Size);
  else
    return (unsigned int)-2146893048;
  return v4;
}

//----- (0000000180002A40) ----------------------------------------------------
__int64 __fastcall MontgomeryGetKeyExchangeBlob(
        struct _BCRYPT_ECCKEY_BLOB *a1,
        unsigned __int8 *a2,
        unsigned __int8 *a3)
{
  unsigned int cbKey_low; // ecx
  unsigned int v6; // ebx
  unsigned __int8 v7; // al

  if ( a1->cbKey > 0xFF )
  {
    return 87;
  }
  else
  {
    cbKey_low = LOBYTE(a1->cbKey);
    v6 = 0;
    if ( a2 )
    {
      v7 = *a3;
      *a3 = cbKey_low;
      if ( v7 < (unsigned __int8)cbKey_low )
        return (unsigned int)-2146893023;
      else
        memcpy_0(a2, &a1[1], cbKey_low);
    }
    else
    {
      *a3 = cbKey_low;
    }
  }
  return v6;
}

//----- (0000000180002A9C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::DigestNewSessionTicket(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  CCipherMill *v6; // rcx
  unsigned int v7; // ebx
  HLOCAL v8; // rsi
  unsigned __int8 v10; // r9
  int v11; // edx
  __int64 v12; // [rsp+20h] [rbp-48h]

  v6 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 61i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
    v6 = WPP_GLOBAL_Control;
  }
  if ( (*((_DWORD *)this + 34) & 0x400000) == 0 )
  {
    if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)v6 + 2), 62i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
    v10 = 10;
    v11 = 1402;
    goto LABEL_21;
  }
  if ( a3 < 6 )
  {
    if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)v6 + 2), 63i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids, a3);
    CSslContext::SetErrorAndFatalAlert((__int64)this, 1400, -2146893018, 0x32u);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x40u,
        (__int64)&WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
        -2146893018,
        -2146893018);
    return 2148074278i64;
  }
  if ( a3 > 0x10005 )
  {
    if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)v6 + 2), 65i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids, a3);
    v10 = 50;
    v11 = 1400;
    goto LABEL_21;
  }
  v7 = a2[5] | (a2[4] << 8);
  if ( a3 - 6 != v7 )
  {
    v10 = 50;
    v11 = 1401;
LABEL_21:
    CSslContext::SetErrorAndFatalAlert((__int64)this, v11, -2146893018, v10);
    return 2148074278i64;
  }
  v8 = SPExternalAlloc(v7);
  if ( !v8 )
    return 14i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 66i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids, v7);
  memcpy_0(v8, a2 + 6, v7);
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64), 1u);
  CSessionCacheClientItem::SetSessionTicket(
    *((CSessionCacheClientItem **)this + 165),
    (unsigned __int8 *)v8,
    v7,
    0i64,
    0,
    0,
    0,
    0,
    0);
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    LODWORD(v12) = 0;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x43u,
      (__int64)&WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
      0,
      v12);
  }
  return 0i64;
}
// 18002C94B: variable 'v12' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180002BF0) ----------------------------------------------------
void __fastcall CSessionCacheClientItem::SetSessionTicket(
        CSessionCacheClientItem *this,
        unsigned __int8 *a2,
        int a3,
        unsigned __int8 *a4,
        char a5,
        unsigned int a6,
        unsigned int a7,
        unsigned int a8,
        __int16 a9)
{
  void *v11; // rcx
  void *v14; // rcx
  DWORD TickCount; // eax
  int v16; // ebx
  unsigned int v17; // esi
  unsigned int ElapsedTime; // eax
  unsigned int v19; // ecx

  v11 = (void *)*((_QWORD *)this + 53);
  if ( v11 )
    SPExternalFree(v11);
  *((_DWORD *)this + 108) = a3;
  *((_QWORD *)this + 53) = a2;
  if ( (a9 & 0x2000) != 0 )
  {
    v14 = (void *)*((_QWORD *)this + 25);
    if ( v14 )
      SPExternalFree(v14);
    *((_BYTE *)this + 208) = a5;
    *((_DWORD *)this + 53) = a6;
    *((_DWORD *)this + 103) = a7;
    *((_QWORD *)this + 25) = a4;
    TickCount = GetTickCount();
    v16 = 1000 * *((_DWORD *)this + 103);
    v17 = a8;
    *((_DWORD *)this + 104) = TickCount;
    if ( CSslGlobals::m_dwClientLifespan < a8 )
      v17 = CSslGlobals::m_dwClientLifespan;
    ElapsedTime = GetElapsedTime(*((_DWORD *)this + 69));
    v19 = v16 + ElapsedTime;
    if ( v16 + ElapsedTime <= ElapsedTime )
    {
      v19 = v17;
    }
    else if ( v19 >= v17 )
    {
      v19 = v17;
    }
    *((_DWORD *)this + 70) = v19;
  }
}

//----- (0000000180002C5C) ----------------------------------------------------
char __fastcall CSessionCacheManager::CacheExpireElements(CSessionCacheManager *this, char a2, char a3)
{
  int v6; // eax
  char v7; // di
  unsigned int v8; // esi
  int v9; // edx
  char v10; // r9

  v6 = _InterlockedIncrement((volatile signed __int32 *)this + 25);
  v7 = 0;
  if ( !a2 || v6 <= 1 )
  {
    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 56));
    v8 = 0;
    if ( *((_DWORD *)this + 12) )
    {
      v9 = *((_DWORD *)this + 7);
      do
      {
        if ( !a2 || (v10 = 1, a3) )
          v10 = 0;
        CSessionCacheTable::ExpireAndPurgeItems(
          (CSessionCacheTable *)(*((_QWORD *)this + 5) + 152i64 * v8),
          (int *)this + 8,
          v9,
          v10);
        v9 = *((_DWORD *)this + 7);
        if ( *((_DWORD *)this + 8) < v9 && a2 && !a3 )
          break;
        ++v8;
      }
      while ( v8 < *((_DWORD *)this + 12) );
    }
    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 56));
    v7 = 1;
  }
  _InterlockedDecrement((volatile signed __int32 *)this + 25);
  return v7;
}

//----- (0000000180002D50) ----------------------------------------------------
unsigned __int8 __fastcall CSessionCacheTable::ExpireAndPurgeItems(CSessionCacheTable *this, int *a2, int a3, char a4)
{
  struct _RTL_RESOURCE *v8; // r12
  DWORD TickCount; // edi
  char *v10; // r14
  int *v11; // rbx
  __int64 *v12; // rbx
  int *v14; // rax
  int *v15; // r9
  unsigned int v16; // r8d
  unsigned int v17; // edx
  char v18; // cl
  __int64 v19; // rdx
  int *v20; // rcx
  int **v21; // r8
  __int64 **v22; // rsi
  __int64 v23; // rcx
  __int64 ***v24; // rax
  __int64 v25; // rcx
  int **v26; // rax
  __int64 **v27; // rax
  __int64 v28; // rax
  __int64 *v29; // rcx
  __int64 *v30; // r8
  __int64 *v31; // rdx
  __int64 *v32; // [rsp+20h] [rbp-38h] BYREF
  __int64 **v33; // [rsp+28h] [rbp-30h]

  v8 = (struct _RTL_RESOURCE *)((char *)this + 48);
  TickCount = GetTickCount();
  v33 = &v32;
  v32 = (__int64 *)&v32;
  RtlAcquireResourceExclusive(v8, 1u);
  v10 = (char *)this + 32;
  v11 = (int *)*((_QWORD *)this + 4);
  while ( v11 != (int *)v10 )
  {
    v14 = v11;
    v15 = v11;
    v11 = *(int **)v11;
    if ( *(v14 - 22) > 1 )
      continue;
    v16 = *(v14 - 10);
    v17 = TickCount - *(v14 - 11);
    if ( TickCount <= *(v14 - 11) )
    {
      if ( TickCount < *(v14 - 11) && v17 - 1 >= v16 )
      {
LABEL_34:
        *((_WORD *)v14 - 42) = 0;
        v18 = 0;
        goto LABEL_8;
      }
    }
    else if ( v17 > v16 )
    {
      goto LABEL_34;
    }
    v18 = *((_BYTE *)v14 - 84);
LABEL_8:
    if ( *a2 > a3 )
    {
      *((_WORD *)v14 - 42) = 0;
    }
    else if ( v18 == 1 )
    {
      continue;
    }
    if ( *((_BYTE *)v14 - 83) != 1 )
    {
      v19 = *((_QWORD *)v14 - 4);
      v20 = v14 - 8;
      if ( *(int **)(v19 + 8) != v14 - 8 )
        goto LABEL_32;
      v21 = (int **)*((_QWORD *)v20 + 1);
      if ( *v21 != v20 )
        goto LABEL_32;
      *v21 = (int *)v19;
      v22 = (__int64 **)(v14 - 4);
      *(_QWORD *)(v19 + 8) = v21;
      v23 = *((_QWORD *)v14 - 2);
      if ( *(int **)(v23 + 8) != v14 - 4 )
        goto LABEL_32;
      v24 = (__int64 ***)v22[1];
      if ( *v24 != v22 )
        goto LABEL_32;
      *v24 = (__int64 **)v23;
      *(_QWORD *)(v23 + 8) = v24;
      v25 = *(_QWORD *)v15;
      if ( *(int **)(*(_QWORD *)v15 + 8i64) != v15 )
        goto LABEL_32;
      v26 = (int **)*((_QWORD *)v15 + 1);
      if ( *v26 != v15 )
        goto LABEL_32;
      *v26 = (int *)v25;
      *(_QWORD *)(v25 + 8) = v26;
      _InterlockedDecrement(a2);
      LsaIModifyPerformanceCounter(4i64);
      v27 = v33;
      if ( *v33 != (__int64 *)&v32 )
        goto LABEL_32;
      v22[1] = (__int64 *)v33;
      *v22 = (__int64 *)&v32;
      *v27 = (__int64 *)v22;
      v33 = v22;
      if ( *a2 < a3 && a4 )
        break;
    }
  }
  RtlReleaseResource(v8);
  v12 = v32;
  if ( v32 != (__int64 *)&v32 )
  {
    while ( 1 )
    {
      v28 = *v12;
      v29 = v12 - 38;
      v30 = v12;
      v12 = (__int64 *)v28;
      if ( *(__int64 **)(v28 + 8) != v30 )
        break;
      v31 = (__int64 *)v30[1];
      if ( (__int64 *)*v31 != v30 )
        break;
      *v31 = v28;
      *(_QWORD *)(v28 + 8) = v31;
      if ( v29 )
        (*(void (__fastcall **)(__int64 *, __int64))(*v29 + 8))(v29, 1i64);
      if ( v12 == (__int64 *)&v32 )
        return 1;
    }
LABEL_32:
    __fastfail(3u);
  }
  return 1;
}
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);

//----- (0000000180002F90) ----------------------------------------------------
void __fastcall CSessionCacheManager::PurgeCacheForCredentialGroup(
        CSessionCacheManager *this,
        struct CCredentialGroup *a2)
{
  unsigned int v2; // edi

  v2 = 0;
  if ( *((_DWORD *)this + 8) )
  {
    if ( *((_DWORD *)this + 12) )
    {
      do
        CSessionCacheTable::ExpireItemsBoundToCred((CSessionCacheTable *)(*((_QWORD *)this + 5) + 152i64 * v2++), a2);
      while ( v2 < *((_DWORD *)this + 12) );
    }
    CSessionCacheManager::CacheExpireElements(this, 0, 0);
  }
}

//----- (0000000180003000) ----------------------------------------------------
void __fastcall CSessionCacheTable::ExpireItemsBoundToCred(CSessionCacheTable *this, struct CCredentialGroup *a2)
{
  struct _RTL_RESOURCE *v2; // r13
  _QWORD **v4; // r14
  _QWORD *v5; // rdi
  __int64 v6; // rbx
  _QWORD *v7; // rbp

  v2 = (struct _RTL_RESOURCE *)((char *)this + 48);
  v4 = (_QWORD **)((char *)this + 16);
  RtlAcquireResourceShared((PRTL_RESOURCE)((char *)this + 48), 1u);
  v5 = *v4;
  while ( v5 != v4 )
  {
    v6 = *((_QWORD *)a2 + 95);
    v7 = v5;
    v5 = (_QWORD *)*v5;
    RtlAcquireResourceShared((PRTL_RESOURCE)(v7 - 29), 1u);
    if ( v6 == *(_QWORD *)((char *)v7 - 116) )
    {
      RtlConvertSharedToExclusive((PRTL_RESOURCE)(v7 - 29));
      if ( v6 == *(_QWORD *)((char *)v7 - 116) )
        *((_WORD *)v7 - 34) = 0;
    }
    RtlReleaseResource((PRTL_RESOURCE)(v7 - 29));
  }
  RtlReleaseResource(v2);
}

//----- (00000001800030F0) ----------------------------------------------------
__int64 __fastcall SpFreeCredentialsHandle(struct CCredentialGroup *a1, __int64 a2, __int64 a3)
{
  int v4; // edi
  CCipherMill *v5; // rcx
  char v6; // al
  unsigned int v7; // eax
  __int64 v8; // rcx
  __int64 v9; // r8
  __int128 v11; // [rsp+30h] [rbp-48h] BYREF
  char v12[8]; // [rsp+40h] [rbp-38h] BYREF
  int v13; // [rsp+48h] [rbp-30h]
  char v14[16]; // [rsp+58h] [rbp-20h] BYREF

  v4 = 8;
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McTemplateU0p_EtwEventWriteTransfer((__int64)a1, a2, (__int64)a1);
  v5 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x43u, (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, a1);
  if ( a1 )
  {
    CSessionCacheManager::PurgeCacheForCredentialGroup(CSessionCacheManager::m_pSessionCacheManager, a1);
    if ( (*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v12) )
    {
      v6 = v13;
      if ( (v13 & 0x20) != 0 )
      {
        CSessionCacheManager::PurgeCacheForProcessId(CSessionCacheManager::m_pSessionCacheManager, *((_DWORD *)a1 + 53));
        v6 = v13;
      }
      if ( (v6 & 0x40) != 0 )
        v4 = 4;
    }
    v7 = *((_DWORD *)a1 + 184);
    if ( v7 > 1 )
    {
      v11 = 2 * v4 * v7;
      *((_QWORD *)&v11 + 1) = (*(__int64 (**)(void))(LsaTable + 384))();
      if ( *((_QWORD *)&v11 + 1) )
        (*(void (__fastcall **)(__int64, _QWORD, _QWORD, __int128 *, _BYTE))(LsaTable + 496))(5i64, 0i64, 0i64, &v11, 0);
    }
    CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, a1);
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McGenEventWrite_EtwEventWriteTransfer(v8, (__int64)&FchStop, v9, 1, (__int64)v14);
    return 0i64;
  }
  else
  {
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McGenEventWrite_EtwEventWriteTransfer((__int64)v5, (__int64)&FchStop, a3, 1, (__int64)v14);
    return 2148074241i64;
  }
}
// 180003262: variable 'v8' is possibly undefined
// 180003262: variable 'v9' is possibly undefined
// 18002CA46: variable 'v5' is possibly undefined
// 18002CA46: variable 'a3' is possibly undefined
// 180092620: using guessed type __int64 LsaTable;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 1800030F0: using guessed type char var_38[8];

//----- (00000001800032C4) ----------------------------------------------------
unsigned __int8 __fastcall HasTimeElapsed(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // eax

  v3 = a2 - a1;
  if ( a2 <= a1 )
  {
    if ( a2 >= a1 || v3 - 1 < a3 )
      return 0;
  }
  else if ( v3 <= a3 )
  {
    return 0;
  }
  return 1;
}

//----- (00000001800032F0) ----------------------------------------------------
CSessionCacheClientItem *__fastcall CSessionCacheClientItem::`vector deleting destructor'(
        CSessionCacheClientItem *this,
        char a2)
{
  CSessionCacheClientItem::~CSessionCacheClientItem(this);
  if ( (a2 & 1) != 0 )
    SPExternalFree(this);
  return this;
}

//----- (0000000180003328) ----------------------------------------------------
void __fastcall CSessionCacheClientItem::~CSessionCacheClientItem(CSessionCacheClientItem *this)
{
  void *v2; // rcx
  void *v3; // rcx
  void *v4; // rcx
  void *v5; // rcx
  __int64 v6; // rcx
  void *v7; // rcx

  *(_QWORD *)this = &CSessionCacheClientItem::`vftable';
  v2 = (void *)*((_QWORD *)this + 42);
  if ( v2 )
    SPExternalFree(v2);
  v3 = (void *)*((_QWORD *)this + 44);
  if ( v3 )
    CryptMemFree(v3);
  v4 = (void *)*((_QWORD *)this + 50);
  if ( v4 )
    SPExternalFree(v4);
  v5 = (void *)*((_QWORD *)this + 46);
  if ( v5 )
    SPExternalFree(v5);
  v6 = *((_QWORD *)this + 48);
  if ( v6 )
    CSessionCacheTable::DereferenceCacheItemInternal(
      *(CSessionCacheTable **)(v6 + 224),
      *((struct CSessionCacheItem **)this + 48),
      1,
      0);
  v7 = (void *)*((_QWORD *)this + 53);
  if ( v7 )
    SPExternalFree(v7);
  CSessionCacheItem::~CSessionCacheItem(this);
}
// 18007C210: using guessed type void *CSessionCacheClientItem::`vftable';

//----- (00000001800033E0) ----------------------------------------------------
struct CSessionCacheItem **__fastcall CSsl3TlsClientContext::`scalar deleting destructor'(
        struct CSessionCacheItem **this)
{
  CSsl3TlsClientContext::~CSsl3TlsClientContext(this);
  return this;
}

//----- (0000000180003400) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::~CSsl3TlsClientContext(struct CSessionCacheItem **this)
{
  struct CSessionCacheItem *v2; // rcx
  struct CSessionCacheItem *v3; // rdx
  bool v4; // zf
  struct CSessionCacheItem *v5; // rdi
  struct CSessionCacheItem *v6; // rdx
  struct CSessionCacheItem *v7; // rdx
  struct CSessionCacheItem *v8; // rdx
  struct CSessionCacheItem *v9; // rdx
  struct CSessionCacheItem *v10; // rdx
  void **v11; // rcx
  struct CSessionCacheItem *v12; // rdx
  struct CSessionCacheItem *v13; // rdx
  struct CSessionCacheItem *v14; // rdx
  struct CSessionCacheItem *v15; // rcx
  struct CSessionCacheItem *v16; // rcx
  struct CSessionCacheItem *v17; // rcx
  struct CSessionCacheItem *v18; // rcx
  struct CSessionCacheItem *v19; // rcx
  struct CSessionCacheItem *v20; // rdi
  __int64 v21; // rcx
  CSslServerKey *v22; // rcx
  int v23; // ecx
  struct CCredentialGroup *v24; // rdx
  struct CSessionCacheItem *v25; // rcx
  volatile signed __int32 *v26; // rcx
  struct CSessionCacheItem *v27; // rax
  struct CSessionCacheItem *v28; // rcx
  struct CSessionCacheItem *v29; // rdx
  struct CSessionCacheItem *v30; // rdi
  DTlsMsgMgr *v31; // rcx
  struct CSessionCacheItem *v32; // rdx

  *this = (struct CSessionCacheItem *)&CSsl3TlsClientContext::`vftable';
  CSsl3TlsClientContext::CleanupConnectedState((CSsl3TlsClientContext *)this);
  v2 = this[166];
  if ( v2 )
    SPExternalFree(v2);
  if ( ((_DWORD)this[17] & 0x80000) != 0 )
  {
    v28 = this[116];
    if ( v28 )
      (*(void (__fastcall **)(struct CSessionCacheItem *, __int64))(*(_QWORD *)v28 + 8i64))(v28, 1i64);
  }
  v3 = this[167];
  if ( v3 )
    CSslContext::FreeMemory((CSslContext *)this, v3);
  v4 = *((_BYTE *)this + 233) == 0;
  *this = (struct CSessionCacheItem *)&CSsl3TlsContext::`vftable';
  if ( v4 )
  {
    v5 = this[58];
    if ( v5 )
    {
      v32 = this[58];
      if ( *(_QWORD *)v5 && *((_QWORD *)v5 + 3) )
      {
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)v5 + 16i64))(*(_QWORD *)v5, *((_QWORD *)v5 + 3));
        *((_QWORD *)v5 + 3) = 0i64;
        *((_DWORD *)v5 + 4) = 0;
        v32 = this[58];
      }
      CSslContext::FreeMemory((CSslContext *)this, v32);
    }
  }
  else
  {
    v29 = this[71];
    if ( v29 )
      CSslContext::FreeMemory((CSslContext *)this, v29);
    v30 = this[73];
    if ( v30 )
    {
      DTlsHandshakeQueue::~DTlsHandshakeQueue(this[73]);
      operator delete(v30);
      this[73] = 0i64;
    }
    v31 = this[72];
    if ( v31 )
    {
      DTlsMsgMgr::`scalar deleting destructor'(v31);
      this[72] = 0i64;
    }
    CSsl3TlsContext::FreeSavedWriteCipherState((CSsl3TlsContext *)this);
  }
  v6 = this[98];
  if ( v6 )
    CSslContext::FreeMemory((CSslContext *)this, v6);
  v7 = this[99];
  if ( v7 )
    CSslContext::FreeMemory((CSslContext *)this, v7);
  v8 = this[100];
  if ( v8 )
    CSslContext::FreeMemory((CSslContext *)this, v8);
  CSsl3TlsContext::FreeSelectedSrtpParameters((CSsl3TlsContext *)this);
  v9 = this[102];
  if ( v9 )
    CSslContext::FreeMemory((CSslContext *)this, v9);
  CSsl3TlsContext::FreeSelectedTBParameters((CSsl3TlsContext *)this);
  v10 = this[104];
  if ( v10 )
  {
    if ( *((_QWORD *)v10 + 1) )
    {
      (*((void (__fastcall **)(struct CSessionCacheItem **, _QWORD))*this + 2))(this, *((_QWORD *)v10 + 1));
      v10 = this[104];
    }
    (*((void (__fastcall **)(struct CSessionCacheItem **, struct CSessionCacheItem *))*this + 2))(this, v10);
    this[104] = 0i64;
  }
  v11 = (void **)this[105];
  if ( v11 )
  {
    if ( v11[1] )
    {
      SPExternalFree(v11[1]);
      v11 = (void **)this[105];
    }
    if ( v11[3] )
    {
      SPExternalFree(v11[3]);
      v11 = (void **)this[105];
    }
    SPExternalFree(v11);
    this[105] = 0i64;
  }
  v12 = this[106];
  if ( v12 )
    CSslContext::FreeMemory((CSslContext *)this, v12);
  v13 = this[107];
  if ( v13 )
    CSslContext::FreeMemory((CSslContext *)this, v13);
  v14 = this[108];
  if ( v14 )
    CSslContext::FreeMemory((CSslContext *)this, v14);
  CSsl3TlsContext::FreeHandshakeHash((CSsl3TlsContext *)this);
  v15 = this[18];
  *this = (struct CSessionCacheItem *)&CSslContext::`vftable';
  if ( v15 )
    SslFreeObject(v15, 0i64);
  v16 = this[19];
  if ( v16 )
    SslFreeObject(v16, 0i64);
  v17 = this[20];
  if ( v17 )
    SslFreeObject(v17, 0i64);
  v18 = this[21];
  if ( v18 )
    SslFreeObject(v18, 0i64);
  v19 = this[14];
  if ( v19 )
    SslFreeObject(v19, 0i64);
  v20 = this[1];
  if ( v20 )
  {
    v21 = *((_QWORD *)v20 + 106);
    if ( v21 )
      CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v21 + 16));
    CMasterCipherInfo::Dereference(*((CMasterCipherInfo **)v20 + 107));
  }
  v22 = this[3];
  if ( v22 )
    CSslServerKey::Dereference(v22);
  v23 = *((_DWORD *)this + 17);
  if ( (unsigned int)(v23 - 3) > 1 && v23 != 79 && ((_DWORD)this[17] & 0x40000) == 0 )
  {
    v27 = this[11];
    if ( v27 )
      *((_BYTE *)v27 + 236) = 0;
  }
  v24 = this[10];
  if ( v24 )
    CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, v24);
  v25 = this[11];
  if ( v25 )
    CSessionCacheTable::DereferenceCacheItemInternal(*((CSessionCacheTable **)v25 + 28), this[11], 1, 0);
  v26 = (volatile signed __int32 *)this[15];
  if ( v26 && _InterlockedExchangeAdd(v26 + 5, 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(volatile signed __int32 *, __int64))(*(_QWORD *)v26 + 8i64))(v26, 1i64);
  *this = (struct CSessionCacheItem *)&ISslSerialize::`vftable';
}
// 18007C000: using guessed type void *CSsl3TlsClientContext::`vftable';
// 18007CBA8: using guessed type void *CSsl3TlsContext::`vftable';
// 18007CDB8: using guessed type void *CSslContext::`vftable';
// 18007CFB8: using guessed type void *ISslSerialize::`vftable';
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180003700) ----------------------------------------------------
void __fastcall CSslContext::FreeMemory(CSslContext *this, void *a2)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(*((_QWORD *)this + 16) + 24i64);
  if ( v2 )
  {
    (*(void (__fastcall **)(__int64, void *))(*(_QWORD *)v2 + 32i64))(v2, a2);
  }
  else if ( LsaTable )
  {
    (*(void (__fastcall **)(void *))(LsaTable + 48))(a2);
  }
  else
  {
    LocalFree(a2);
  }
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180003750) ----------------------------------------------------
CSsl3TlsClientContext *__fastcall CSsl3TlsClientContext::CSsl3TlsClientContext(
        CSsl3TlsClientContext *this,
        struct CSessionCacheClientItem *a2,
        int a3,
        const unsigned __int16 *a4)
{
  unsigned __int16 v8; // ax
  unsigned int v9; // ecx
  int v10; // eax
  _DWORD *v11; // rdi
  __int16 v12; // ax
  __int16 v13; // cx
  CSsl3TlsClientContext *result; // rax
  char v15[8]; // [rsp+20h] [rbp-28h] BYREF
  char v16; // [rsp+28h] [rbp-20h]

  *(_QWORD *)this = &CSslContext::`vftable';
  *((_QWORD *)this + 1) = 0i64;
  *((_QWORD *)this + 2) = 0i64;
  *((_QWORD *)this + 3) = 0i64;
  *((_WORD *)this + 16) = 0;
  *((_DWORD *)this + 9) = 0;
  *(_OWORD *)((char *)this + 40) = 0i64;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 16) = a3;
  *(_QWORD *)((char *)this + 68) = 0i64;
  *((_QWORD *)this + 10) = 0i64;
  *((_QWORD *)this + 11) = a2;
  *((_WORD *)this + 48) = 0;
  *((_QWORD *)this + 13) = 0i64;
  *((_QWORD *)this + 14) = 0i64;
  *((_QWORD *)this + 15) = 0i64;
  *((_QWORD *)this + 16) = 0i64;
  *((_QWORD *)this + 17) = 0i64;
  *((_QWORD *)this + 18) = 0i64;
  *((_QWORD *)this + 19) = 0i64;
  *((_QWORD *)this + 20) = 0i64;
  *((_QWORD *)this + 21) = 0i64;
  *((_QWORD *)this + 22) = 0i64;
  *((_QWORD *)this + 23) = 0i64;
  *((_DWORD *)this + 48) = 0;
  *((_QWORD *)this + 25) = 0i64;
  *((_QWORD *)this + 26) = 0i64;
  *((_DWORD *)this + 54) = 0;
  *((_WORD *)this + 110) = 0;
  *((_QWORD *)this + 28) = 0i64;
  *((_BYTE *)this + 232) = 0;
  *((_WORD *)this + 117) = 0;
  *((_QWORD *)this + 30) = 0i64;
  *((_QWORD *)this + 31) = 0i64;
  *((_QWORD *)this + 32) = 0i64;
  *((_WORD *)this + 132) = 0;
  *((_BYTE *)this + 266) = 0;
  if ( a2 )
    *((_DWORD *)this + 4) = *((_DWORD *)a2 + 46);
  if ( (*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v15) )
  {
    if ( (v16 & 1) != 0 )
      *((_QWORD *)this + 17) |= 0x20000000ui64;
    *((_BYTE *)this + 266) = (v16 & 0x11) == 0;
  }
  v8 = ConvertSchannelProtocolToSsl(*((_DWORD *)this + 16));
  v9 = v8;
  *((_WORD *)this + 17) = v8;
  if ( HIBYTE(v8) != 0xFE || (v10 = 13, v9 > 0xFEFF) )
    v10 = 5;
  *((_DWORD *)this + 15) = v10;
  *((_BYTE *)this + 233) = (a3 & 0xF0000) != 0;
  if ( dword_180091480
    && (qword_180091490 & 0x400000000000i64) != 0
    && (qword_180091498 & 0x400000000000i64) == qword_180091498
    && (v11 = SPExternalAlloc(0x700u)) != 0i64 )
  {
    v11[2] = 0;
    *(_QWORD *)v11 = &CSchannelTelemetryContext::`vftable';
    *((_BYTE *)v11 + 16) = 0;
    v11[5] = 1;
    memset_0(v11 + 6, 0, 0x6E8ui64);
  }
  else
  {
    v11 = 0i64;
  }
  *((_QWORD *)this + 15) = v11;
  memset_0((char *)this + 272, 0, 0x40ui64);
  *((_DWORD *)this + 84) = 0;
  *((_BYTE *)this + 340) = 0;
  memset_0((char *)this + 341, 0, 0x48ui64);
  *((_DWORD *)this + 104) = 0;
  *(_OWORD *)((char *)this + 420) = 0i64;
  *(_OWORD *)((char *)this + 436) = 0i64;
  *(_QWORD *)((char *)this + 452) = 0i64;
  *((_QWORD *)this + 58) = 0i64;
  *((_DWORD *)this + 118) = 0;
  *(_OWORD *)((char *)this + 476) = 0i64;
  *(_OWORD *)((char *)this + 492) = 0i64;
  *((_DWORD *)this + 127) = 0;
  *((_OWORD *)this + 32) = 0i64;
  *((_OWORD *)this + 33) = 0i64;
  *((_WORD *)this + 272) = 0;
  *(_QWORD *)((char *)this + 548) = 0i64;
  *((_BYTE *)this + 556) = 0;
  *((_OWORD *)this + 35) = 0i64;
  memset_0((char *)this + 592, 0, 0x80ui64);
  *((_DWORD *)this + 180) = 0;
  *(_OWORD *)((char *)this + 724) = 0i64;
  v12 = 0;
  *(_OWORD *)((char *)this + 740) = 0i64;
  *(_OWORD *)((char *)this + 756) = 0i64;
  *(_QWORD *)((char *)this + 772) = 0i64;
  *((_DWORD *)this + 195) = 0;
  *((_QWORD *)this + 98) = 0i64;
  *((_QWORD *)this + 99) = 0i64;
  *((_QWORD *)this + 100) = 0i64;
  *((_QWORD *)this + 101) = 0i64;
  *((_QWORD *)this + 102) = 0i64;
  *((_QWORD *)this + 103) = 0i64;
  *((_QWORD *)this + 104) = 0i64;
  *((_QWORD *)this + 105) = 0i64;
  *((_QWORD *)this + 106) = 0i64;
  *((_QWORD *)this + 107) = 0i64;
  *((_QWORD *)this + 108) = 0i64;
  *((_DWORD *)this + 218) = 0;
  *((_QWORD *)this + 110) = 0i64;
  *((_DWORD *)this + 222) = 0;
  *((_QWORD *)this + 112) = 0i64;
  *((_QWORD *)this + 113) = 0i64;
  *((_QWORD *)this + 114) = 0i64;
  *((_DWORD *)this + 230) = 0;
  *((_WORD *)this + 462) = 0;
  if ( *((_BYTE *)this + 233) )
  {
    v12 = 1083;
    v13 = 1096;
  }
  else
  {
    *((_DWORD *)this + 48) = -1;
    v13 = 0;
    *((_QWORD *)this + 25) = 0i64;
    *((_QWORD *)this + 26) = 0i64;
  }
  *((_WORD *)this + 108) = v13;
  *((_WORD *)this + 109) = v12;
  *((_QWORD *)this + 116) = 0i64;
  *(_QWORD *)this = &CSsl3TlsClientContext::`vftable';
  *((_QWORD *)this + 117) = 0i64;
  *((_DWORD *)this + 236) = 0;
  *((_QWORD *)this + 119) = 0i64;
  *((_DWORD *)this + 240) = 0;
  *((_QWORD *)this + 121) = 0i64;
  *((_DWORD *)this + 244) = 0;
  *((_WORD *)this + 490) = 0;
  *(_OWORD *)((char *)this + 982) = 0i64;
  *(_OWORD *)((char *)this + 998) = 0i64;
  *((_QWORD *)this + 127) = 0i64;
  *((_QWORD *)this + 128) = 0i64;
  *((_BYTE *)this + 1032) = 0;
  *((_QWORD *)this + 130) = 0i64;
  *((_DWORD *)this + 262) = 0;
  memset_0((char *)this + 1052, 0, 0xFFui64);
  *(_QWORD *)((char *)this + 1308) = 0i64;
  *((_QWORD *)this + 165) = a2;
  *((_QWORD *)this + 166) = a4;
  *((_QWORD *)this + 167) = 0i64;
  *((_BYTE *)this + 1344) = 0;
  *((_WORD *)this + 673) = 0;
  *((_DWORD *)this + 337) = 0;
  *((_QWORD *)this + 169) = 0i64;
  *((_DWORD *)this + 340) = 0;
  result = this;
  *((_DWORD *)this + 17) = 40;
  *((_QWORD *)this + 73) = 0i64;
  *((_QWORD *)this + 72) = 0i64;
  return result;
}
// 18007C000: using guessed type void *CSsl3TlsClientContext::`vftable';
// 18007CDB8: using guessed type void *CSslContext::`vftable';
// 18007CF58: using guessed type void *CSchannelTelemetryContext::`vftable';
// 180091490: using guessed type __int64 qword_180091490;
// 180091498: using guessed type __int64 qword_180091498;
// 180092620: using guessed type __int64 LsaTable;
// 180003750: using guessed type char var_28[8];

//----- (0000000180003C24) ----------------------------------------------------
void __fastcall CSessionCacheItem::ClearState(CSessionCacheItem *this)
{
  __int64 v2; // rcx
  void *v3; // rcx
  void *v4; // rcx
  const CERT_CONTEXT *v5; // rcx
  void *v6; // rcx
  __int64 v7; // rdi
  __int64 v8; // rcx
  void *v9; // rcx

  v2 = *((_QWORD *)this + 2);
  if ( v2 )
    SslFreeObject(v2, 0i64);
  v3 = (void *)*((_QWORD *)this + 3);
  if ( v3 )
    SPExternalFree(v3);
  v4 = (void *)*((_QWORD *)this + 5);
  if ( v4 )
    SPExternalFree(v4);
  v5 = (const CERT_CONTEXT *)*((_QWORD *)this + 6);
  if ( v5 )
    CertFreeCertificateContext(v5);
  v6 = (void *)*((_QWORD *)this + 7);
  if ( v6 )
    SPExternalFree(v6);
  v7 = *((_QWORD *)this + 22);
  if ( v7 )
  {
    v8 = *(_QWORD *)(v7 + 848);
    if ( v8 )
      CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v8 + 16));
    CMasterCipherInfo::Dereference(*(CMasterCipherInfo **)(v7 + 856));
  }
  v9 = (void *)*((_QWORD *)this + 25);
  if ( v9 )
    SPExternalFree(v9);
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180003CE4) ----------------------------------------------------
__int64 __fastcall CMasterCipherInfo::Dereference(CMasterCipherInfo *this)
{
  unsigned __int32 v1; // ebx

  v1 = _InterlockedDecrement((volatile signed __int32 *)this + 3);
  if ( !v1 )
  {
    _InterlockedDecrement(&CMasterCipherInfo::m_lMasterCiphersCount);
    FreeCipherSuiteData(*((_DWORD *)this + 2), *(NCRYPT_HANDLE **)this, this);
  }
  return v1;
}
// 180092D90: using guessed type int CMasterCipherInfo::m_lMasterCiphersCount;

//----- (0000000180003D20) ----------------------------------------------------
__int64 __fastcall CMasterEccCurveInfo::Dereference(CMasterEccCurveInfo *this)
{
  unsigned __int32 v1; // ebx

  v1 = _InterlockedDecrement((volatile signed __int32 *)this + 3);
  if ( !v1 )
    SPExternalFree(this);
  return v1;
}

//----- (0000000180003D4C) ----------------------------------------------------
void __fastcall CSslCredManager::DereferenceCredentialGroup(CSslCredManager *this, struct CCredentialGroup *a2)
{
  struct _RTL_CRITICAL_SECTION *v3; // rdi
  struct CCredentialGroup **v4; // r8
  struct CCredentialGroup **v5; // rdx

  if ( _InterlockedExchangeAdd((volatile signed __int32 *)a2 + 6, 0xFFFFFFFF) == 1 )
  {
    v3 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 8);
    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
    v4 = (struct CCredentialGroup **)*((_QWORD *)a2 + 1);
    if ( v4[1] != (struct CCredentialGroup *)((char *)a2 + 8)
      || (v5 = (struct CCredentialGroup **)*((_QWORD *)a2 + 2), *v5 != (struct CCredentialGroup *)((char *)a2 + 8)) )
    {
      __fastfail(3u);
    }
    *v5 = (struct CCredentialGroup *)v4;
    v4[1] = (struct CCredentialGroup *)v5;
    RtlLeaveCriticalSection(v3);
    if ( a2 )
      (*(void (__fastcall **)(struct CCredentialGroup *, __int64))(*(_QWORD *)a2 + 8i64))(a2, 1i64);
  }
}

//----- (0000000180003DF0) ----------------------------------------------------
void __fastcall CSsl3TlsContext::FreeHandshakeHash(CSsl3TlsContext *this)
{
  unsigned int v2; // edi
  char *v3; // rsi
  __int64 v4; // rcx

  v2 = 0;
  if ( *((_DWORD *)this + 137) )
  {
    do
    {
      v3 = (char *)this + 8 * v2;
      v4 = *((_QWORD *)v3 + 74);
      if ( v4 )
      {
        SslFreeObject(v4, 0i64);
        *((_QWORD *)v3 + 74) = 0i64;
      }
      ++v2;
    }
    while ( v2 < *((_DWORD *)this + 137) );
    *((_DWORD *)this + 180) = 0;
    *((_DWORD *)this + 137) = 0;
  }
  else
  {
    *((_DWORD *)this + 180) = 0;
    *((_DWORD *)this + 137) = 0;
  }
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180003E7C) ----------------------------------------------------
void __fastcall CSsl3TlsContext::FreeSelectedTBParameters(CSsl3TlsContext *this)
{
  __int64 v1; // rdx

  v1 = *((_QWORD *)this + 103);
  if ( v1 )
  {
    if ( *(_QWORD *)(v1 + 8) )
    {
      (*(void (__fastcall **)(CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 16i64))(this, *(_QWORD *)(v1 + 8));
      v1 = *((_QWORD *)this + 103);
    }
    (*(void (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 16i64))(this, v1);
    *((_QWORD *)this + 103) = 0i64;
  }
}

//----- (0000000180003EA4) ----------------------------------------------------
void __fastcall CSsl3TlsContext::FreeSelectedSrtpParameters(CSsl3TlsContext *this)
{
  __int64 v1; // rdx

  v1 = *((_QWORD *)this + 101);
  if ( v1 )
  {
    if ( *(_QWORD *)(v1 + 8) )
    {
      (*(void (__fastcall **)(CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 16i64))(this, *(_QWORD *)(v1 + 8));
      v1 = *((_QWORD *)this + 101);
    }
    (*(void (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 16i64))(this, v1);
    *((_QWORD *)this + 101) = 0i64;
  }
}

//----- (0000000180003ED0) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::CleanupConnectedState(CSsl3TlsClientContext *this)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  void *v4; // rcx
  void *v5; // rcx
  void *v6; // rcx
  __int64 v7; // rax
  CSslCredential *v8; // rax
  __int64 v9; // rdx
  int v10; // r8d

  v2 = *((_QWORD *)this + 128);
  if ( v2 )
    SslFreeObject(v2, 0i64);
  v3 = *((_QWORD *)this + 127);
  if ( v3 )
    SslFreeObject(v3, 0i64);
  v4 = (void *)*((_QWORD *)this + 119);
  if ( v4 )
  {
    SPExternalFree(v4);
    *((_QWORD *)this + 119) = 0i64;
  }
  v5 = (void *)*((_QWORD *)this + 121);
  if ( v5 )
  {
    SPExternalFree(v5);
    *((_QWORD *)this + 121) = 0i64;
  }
  v6 = (void *)*((_QWORD *)this + 117);
  if ( v6 )
  {
    SPExternalFree(v6);
    *((_QWORD *)this + 117) = 0i64;
  }
  *((_DWORD *)this + 236) = 0;
  CSsl3TlsClientContext::SetDefCredSearched((__int64)this, 0);
  v7 = *(_QWORD *)this;
  *((_BYTE *)this + 1032) = 0;
  if ( (*(__int64 (__fastcall **)(CSsl3TlsClientContext *))(v7 + 248))(this) && (*((_DWORD *)this + 34) & 0x80000) != 0 )
  {
    v8 = (CSslCredential *)(*(__int64 (__fastcall **)(CSsl3TlsClientContext *))(*(_QWORD *)this + 248i64))(this);
    CSslCredential::RemoteCloseKeyHandle(v8, v9, v10);
  }
  *((_WORD *)this + 255) = 0;
  *((_WORD *)this + 272) = 0;
  *((_BYTE *)this + 1313) = 0;
  CSsl3TlsContext::CleanupConnectedState(this);
}
// 18002CD3F: variable 'v9' is possibly undefined
// 18002CD3F: variable 'v10' is possibly undefined
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180003FB0) ----------------------------------------------------
void __fastcall CSsl3TlsContext::CleanupConnectedState(CSsl3TlsContext *this)
{
  void *v2; // rcx
  __int64 v3; // rdx
  _QWORD *v4; // rbx

  v2 = (void *)*((_QWORD *)this + 112);
  if ( v2 )
  {
    SPExternalFree(v2);
    *((_QWORD *)this + 112) = 0i64;
    *((_DWORD *)this + 222) = 0;
  }
  if ( *((_QWORD *)this + 110) )
  {
    (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 110) = 0i64;
  }
  v3 = *((_QWORD *)this + 114);
  *((_DWORD *)this + 218) = 0;
  if ( v3 )
  {
    (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 114) = 0i64;
    *((_WORD *)this + 460) = 0;
  }
  *(_WORD *)((char *)this + 923) = 0;
  *((_BYTE *)this + 472) = 0;
  v4 = (_QWORD *)*((_QWORD *)this + 58);
  if ( v4 && *v4 )
  {
    if ( v4[3] )
    {
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v4 + 16i64))(*v4);
      v4[3] = 0i64;
      *((_DWORD *)v4 + 4) = 0;
    }
  }
}

//----- (000000018000404C) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::SetDefCredSearched(__int64 a1, int a2)
{
  const CERT_CHAIN_CONTEXT *v3; // rcx

  *(_DWORD *)(a1 + 1048) = a2;
  v3 = *(const CERT_CHAIN_CONTEXT **)(a1 + 1040);
  if ( v3 )
    CertFreeCertificateChain(v3);
  *(_QWORD *)(a1 + 1040) = 0i64;
}

//----- (0000000180004080) ----------------------------------------------------
void __fastcall CSessionCacheItem::~CSessionCacheItem(CSessionCacheItem *this)
{
  *(_QWORD *)this = &CSessionCacheItem::`vftable';
  CSessionCacheItem::ClearState(this);
  if ( !*((_DWORD *)this + 17) )
    RtlDeleteResource((PRTL_RESOURCE)((char *)this + 72));
  *(_QWORD *)this = &IAllocate::`vftable';
}
// 18007C298: using guessed type void *IAllocate::`vftable';
// 18007C2C0: using guessed type void *CSessionCacheItem::`vftable';

//----- (00000001800040C8) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::DigestCertificateStatus(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  unsigned int v5; // ebx
  HLOCAL v6; // rax
  HLOCAL v7; // rbp
  __int64 v8; // rax
  unsigned __int8 v10; // r9
  int v11; // edx

  if ( (*((_DWORD *)this + 34) & 0x20000) == 0 )
  {
    v10 = 10;
    v11 = 200;
LABEL_11:
    CSslContext::SetErrorAndFatalAlert((__int64)this, v11, -2146893018, v10);
    return 2148074278i64;
  }
  if ( a3 < 4 )
    goto LABEL_10;
  if ( *a2 != 1 )
    return 0i64;
  v5 = a2[3] + (a2[1] << 16) + (a2[2] << 8);
  if ( v5 > a3 - 4 )
  {
LABEL_10:
    v10 = 50;
    v11 = 201;
    goto LABEL_11;
  }
  v6 = SPExternalAlloc(v5);
  v7 = v6;
  if ( v6 )
  {
    memcpy_0(v6, a2 + 4, v5);
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64), 1u);
    v8 = *((_QWORD *)this + 165);
    *(_DWORD *)(v8 + 344) = v5;
    *(_QWORD *)(v8 + 336) = v7;
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
    return 0i64;
  }
  return 14i64;
}

//----- (00000001800041B0) ----------------------------------------------------
__int64 __fastcall NonMontgomeryGetKeyExchangeBlob(
        struct _BCRYPT_ECCKEY_BLOB *a1,
        unsigned __int8 *a2,
        unsigned __int8 *a3)
{
  unsigned int v5; // ebx
  unsigned __int8 v6; // cl
  unsigned __int8 v7; // al

  if ( a1->cbKey > 0x7F )
  {
    return 1359;
  }
  else
  {
    v5 = 0;
    v6 = 2 * LOBYTE(a1->cbKey) + 1;
    if ( a2 )
    {
      v7 = *a3;
      *a3 = v6;
      if ( v7 < v6 )
      {
        return (unsigned int)-2146893023;
      }
      else
      {
        *a2 = 4;
        memcpy_0(a2 + 1, &a1[1], v6 - 1i64);
      }
    }
    else
    {
      *a3 = v6;
    }
  }
  return v5;
}

//----- (0000000180004214) ----------------------------------------------------
unsigned __int8 __fastcall CSessionCacheManager::FinishCacheAddItem(CSessionCacheManager *this, struct CSslContext *a2)
{
  __int64 *v2; // rsi
  __int64 v5; // rbp
  __int64 v6; // r9
  unsigned int v7; // edx
  unsigned int v8; // eax
  __int64 v9; // rax

  v2 = (__int64 *)*((_QWORD *)a2 + 11);
  if ( !v2 )
    return 0;
  v5 = *((_QWORD *)a2 + 10);
  if ( !v5 )
    return 0;
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(v2[28] + 48), 1u);
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(v2 + 9), 1u);
  v7 = *(_DWORD *)(v5 + 208);
  v8 = *((_DWORD *)v2 + 70);
  *((_BYTE *)v2 + 236) = 1;
  if ( v7 >= v8 )
    v7 = v8;
  v9 = *v2;
  *((_DWORD *)v2 + 70) = v7;
  LOBYTE(v6) = 1;
  (*(void (__fastcall **)(__int64 *, CSessionCacheManager *, struct CSslContext *, __int64))(v9 + 64))(v2, this, a2, v6);
  RtlReleaseResource((PRTL_RESOURCE)(v2 + 9));
  RtlReleaseResource((PRTL_RESOURCE)(v2[28] + 48));
  return 1;
}
// 1800042B3: variable 'v6' is possibly undefined

//----- (0000000180004308) ----------------------------------------------------
__int64 __fastcall VerifyRsaParams(
        UCHAR *a1,
        unsigned __int8 *a2,
        ULONG a3,
        const unsigned __int16 *a4,
        enum _eTlsHashAlgorithm a5,
        ULONG a6,
        PUCHAR pbSignature,
        ULONG cbSignature)
{
  unsigned int v12; // eax
  ULONG v14; // r14d
  unsigned int v15; // ebx
  BOOL v16; // eax
  struct _RTL_RESOURCE *v17; // rcx
  const unsigned __int16 **p_pPaddingInfo; // rdx
  DWORD LastError; // eax
  unsigned __int8 v21; // r9
  int v22; // r8d
  int v23; // edx
  ULONG cbHash; // [rsp+40h] [rbp-79h] BYREF
  BCRYPT_KEY_HANDLE hKey; // [rsp+48h] [rbp-71h] BYREF
  const unsigned __int16 *pPaddingInfo; // [rsp+50h] [rbp-69h] BYREF
  __int128 v27; // [rsp+58h] [rbp-61h] BYREF
  UCHAR pbHash[64]; // [rsp+70h] [rbp-49h] BYREF

  hKey = 0i64;
  memset_0(pbHash, 0, sizeof(pbHash));
  cbHash = 0;
  pPaddingInfo = 0i64;
  v27 = 0i64;
  if ( a5 )
  {
    v12 = GenerateTlsHash(a5, a1, a2, a3, pbHash, &cbHash);
    v14 = cbHash;
  }
  else
  {
    v14 = 36;
    v12 = CSsl3TlsContext::ComputeRsaServerExchangeHashes(a1, a2, a3, pbHash);
    a6 = 2;
  }
  v15 = v12;
  if ( v12 )
  {
    v21 = 80;
    v22 = v12;
    v23 = 1105;
LABEL_18:
    CSslContext::SetErrorAndFatalAlert((__int64)a1, v23, v22, v21);
    goto LABEL_9;
  }
  RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)a1 + 11) + 72i64), 1u);
  v16 = CryptImportPublicKeyInfoEx2(
          **(_DWORD **)(*((_QWORD *)a1 + 11) + 48i64),
          (PCERT_PUBLIC_KEY_INFO)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 11) + 48i64) + 24i64) + 96i64),
          0x80000000,
          0i64,
          &hKey);
  v17 = (struct _RTL_RESOURCE *)(*((_QWORD *)a1 + 11) + 72i64);
  if ( !v16 )
  {
    RtlReleaseResource(v17);
    LastError = GetLastError();
    v15 = LastError;
    v21 = 43;
LABEL_17:
    v22 = LastError;
    v23 = 1106;
    goto LABEL_18;
  }
  RtlReleaseResource(v17);
  if ( a6 == 8 )
  {
    p_pPaddingInfo = (const unsigned __int16 **)&v27;
    *(_QWORD *)&v27 = a4;
    DWORD2(v27) = v14;
    goto LABEL_8;
  }
  if ( a6 == 2 )
  {
    p_pPaddingInfo = &pPaddingInfo;
    pPaddingInfo = a4;
LABEL_8:
    LastError = BCryptVerifySignature(hKey, p_pPaddingInfo, pbHash, v14, pbSignature, cbSignature, a6);
    v15 = LastError;
    if ( !LastError )
      goto LABEL_9;
    v21 = 51;
    goto LABEL_17;
  }
  v15 = -2146893052;
LABEL_9:
  if ( hKey )
    BCryptDestroyKey(hKey);
  return v15;
}

//----- (0000000180004494) ----------------------------------------------------
NTSTATUS __fastcall GenerateTlsHash(
        enum _eTlsHashAlgorithm a1,
        UCHAR *a2,
        unsigned __int8 *a3,
        ULONG a4,
        unsigned __int8 *a5,
        unsigned int *a6)
{
  NTSTATUS result; // eax
  BCRYPT_ALG_HANDLE hAlgorithm; // [rsp+30h] [rbp-18h] BYREF

  hAlgorithm = 0i64;
  result = TlsGetBCryptHashProvider(a1, &hAlgorithm, a6);
  if ( !result )
    return GenerateHash(hAlgorithm, a2, a3, a4, a5, *a6);
  return result;
}

//----- (0000000180004510) ----------------------------------------------------
__int64 __fastcall TlsGetBCryptHashProvider(enum _eTlsHashAlgorithm a1, void **a2, unsigned int *a3)
{
  unsigned int v3; // r10d
  int v6; // ebx
  char *v7; // r9
  BCRYPT_ALG_HANDLE v8; // rax
  __int64 v9; // rcx
  const WCHAR *v10; // rdx
  unsigned int v11; // eax
  unsigned int v12; // ecx
  void *v14; // rbx
  unsigned int v15; // [rsp+48h] [rbp+10h]
  BCRYPT_ALG_HANDLE phAlgorithm; // [rsp+50h] [rbp+18h] BYREF
  const WCHAR *v17; // [rsp+58h] [rbp+20h]

  v3 = 0;
  v6 = g_dwHashInfoTotalCount;
  if ( g_dwHashInfoTotalCount )
  {
    v7 = (char *)g_pHashInfo;
    while ( !*(_QWORD *)v7 || *(_DWORD *)(*(_QWORD *)v7 + 20i64) != a1 )
    {
      ++v3;
      v7 += 8;
      if ( v3 >= g_dwHashInfoTotalCount )
        goto LABEL_8;
    }
    v6 = v3;
  }
LABEL_8:
  if ( v6 < 0 || v6 >= g_dwHashInfoTotalCount )
  {
    v6 = 0;
  }
  else
  {
    if ( v6 == 1 )
    {
      v8 = g_hMD5Provider;
      goto LABEL_13;
    }
    if ( v6 == 2 )
    {
      v8 = g_hSHAProvider;
      goto LABEL_13;
    }
  }
  v8 = (BCRYPT_ALG_HANDLE)qword_180092CF0[v6];
LABEL_13:
  phAlgorithm = v8;
  v15 = 0;
  if ( v6 >= (unsigned int)g_dwHashInfoTotalCount || (_mm_lfence(), (v9 = g_pHashInfo[v6]) == 0) )
  {
    v12 = 1168;
    goto LABEL_17;
  }
  v10 = *(const WCHAR **)v9;
  v11 = *(_DWORD *)(v9 + 8);
  v17 = *(const WCHAR **)v9;
  v15 = v11;
  if ( phAlgorithm )
    goto LABEL_16;
  if ( !v10 )
  {
    v12 = 1359;
    goto LABEL_17;
  }
  v12 = BCryptOpenAlgorithmProvider(&phAlgorithm, v10, 0i64, 0);
  if ( !v12 )
  {
    v14 = (void *)_InterlockedCompareExchange64(&qword_180092CF0[v6], (signed __int64)phAlgorithm, 0i64);
    if ( v14 )
    {
      BCryptCloseAlgorithmProvider(phAlgorithm, 0);
      phAlgorithm = v14;
    }
LABEL_16:
    v12 = 0;
  }
LABEL_17:
  *a2 = phAlgorithm;
  *a3 = v15;
  return v12;
}
// 180092324: using guessed type int g_dwHashInfoTotalCount;
// 180092330: using guessed type _QWORD g_pHashInfo[16];
// 180092CF0: using guessed type signed __int64 qword_180092CF0[1];

//----- (0000000180004658) ----------------------------------------------------
__int64 __fastcall CCipherMill::GetCurveInfo(CCipherMill *this, int a2, struct CEccCurveInfo **a3)
{
  unsigned int CurveInfo; // ebx

  RtlAcquireResourceShared(&Resource, 1u);
  if ( a2 && a3 && qword_1800925C8 )
    CurveInfo = CMasterEccCurveInfo::GetCurveInfo(qword_1800925C8, a2, a3);
  else
    CurveInfo = 87;
  RtlReleaseResource(&Resource);
  return CurveInfo;
}

//----- (00000001800046CC) ----------------------------------------------------
__int64 __fastcall CMasterEccCurveInfo::GetCurveInfo(CMasterEccCurveInfo *this, int a2, struct CEccCurveInfo **a3)
{
  unsigned int v3; // r10d
  unsigned int v4; // r9d
  __int64 v7; // rdi
  unsigned int v8; // edx
  __int64 v9; // rax
  unsigned int v10; // r8d
  __int64 v11; // rbx
  __int64 v12; // rax

  v3 = *((_DWORD *)this + 2);
  v4 = 0;
  if ( !v3 )
    return 1168i64;
  v7 = *(_QWORD *)this;
  while ( 1 )
  {
    v8 = 0;
    v9 = 32i64 * v4;
    v10 = *(_DWORD *)(v9 + v7 + 8);
    if ( v10 )
      break;
LABEL_10:
    if ( ++v4 >= v3 )
      return 1168i64;
  }
  v11 = *(_QWORD *)(v9 + v7);
  while ( 1 )
  {
    v12 = v11 + 780i64 * v8;
    if ( *(_DWORD *)(v12 + 772) == a2 )
      break;
    if ( ++v8 >= v10 )
      goto LABEL_10;
  }
  *a3 = (struct CEccCurveInfo *)v12;
  return 0i64;
}

//----- (0000000180004750) ----------------------------------------------------
__int64 __fastcall CreateServerCertificateSerialChainProperty(struct CSsl3TlsClientContext *a1)
{
  __int64 v1; // rcx
  __int64 v2; // rdx
  __int64 v3; // r10
  __int64 v4; // r9
  __int64 v5; // r8
  int v6; // eax
  __int64 v7; // rbx
  __int64 v8; // rdi
  int v9; // esi
  void *v10; // rcx
  int v12; // [rsp+50h] [rbp+20h] BYREF
  __int64 v13; // [rsp+58h] [rbp+28h] BYREF
  __int64 v14; // [rsp+60h] [rbp+30h] BYREF

  v13 = 0i64;
  v14 = 0i64;
  if ( !a1 )
    return 2148074244i64;
  (*(void (__fastcall **)(struct CSsl3TlsClientContext *, __int64 *))(*(_QWORD *)a1 + 224i64))(a1, &v13);
  if ( !v13 )
    return 2148074244i64;
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(v13 + 72), 1u);
  v1 = v13;
  v2 = *(unsigned int *)(v13 + 32);
  v3 = *(_QWORD *)(v13 + 24);
  v4 = *(unsigned int *)(v13 + 344);
  v5 = *(_QWORD *)(v13 + 336);
  v6 = *(_DWORD *)(v13 + 360);
  v12 = v6;
  if ( (_DWORD)v2 && !v6 )
  {
    if ( (unsigned int)I_CertProcessSslHandshake(v3, v2, v5, v4, &v14, &v12) )
    {
      v7 = v13;
      v8 = v14;
      v9 = v12;
      v10 = *(void **)(v13 + 352);
      if ( v10 )
        CryptMemFree(v10);
      *(_DWORD *)(v7 + 360) = v9;
      *(_QWORD *)(v7 + 352) = v8;
    }
    v1 = v13;
  }
  RtlReleaseResource((PRTL_RESOURCE)(v1 + 72));
  return 0i64;
}
// 180098180: using guessed type __int64 __fastcall I_CertProcessSslHandshake(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180004850) ----------------------------------------------------
__int64 __fastcall AutoVerifyServerCertificate(struct CSsl3TlsContext *a1)
{
  __int64 v3; // rax
  int v4; // r10d
  int v5; // edx
  int v6; // ecx
  int v7; // r9d
  int v8; // r8d
  unsigned int v9; // edx

  if ( !a1 )
    return 2148074244i64;
  if ( (*((_DWORD *)a1 + 34) & 0x4000i64) != 0 )
    return 0i64;
  v3 = *((_QWORD *)a1 + 10);
  if ( !v3 )
    return 2148074244i64;
  v4 = *(_DWORD *)(v3 + 160);
  v5 = ((v4 & 0x100) << 20) | 0x20000000;
  if ( (v4 & 0x200) == 0 )
    v5 = (v4 & 0x100) << 20;
  v6 = v5 | 0x40000000;
  if ( (v4 & 0x400) == 0 )
    v6 = v5;
  v7 = v6 | 4;
  if ( (v4 & 0x2000) == 0 )
    v7 = v6;
  v8 = v4 & 0x800 | 0x1000;
  if ( (v4 & 0x1000) == 0 )
    v8 = v4 & 0x800;
  v9 = v7 | 0x80000000;
  if ( (v4 & 0x4000) == 0 )
    v9 = v7;
  return VerifyServerCertificate(a1, v9, v8);
}

//----- (0000000180004900) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::DigestServerKeyX(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int8 *a4)
{
  unsigned int *v7; // rdi
  int v8; // ecx
  __int64 result; // rax
  unsigned __int8 *v10; // rax
  unsigned __int8 *v11; // r9
  int v12; // ecx

  *((_QWORD *)this + 17) |= 0x8000ui64;
  v7 = (unsigned int *)((char *)this + 960);
  v8 = *(_DWORD *)(*((_QWORD *)this + 1) + 48i64);
  switch ( v8 )
  {
    case 3:
      result = CSsl3TlsClientContext::EccGenerateClientExchangeValue(this, a2, a3, 0i64, v7);
      break;
    case 2:
      result = CSsl3TlsClientContext::DhGenerateClientExchangeValue(this, a2, a3, 0i64, v7);
      break;
    case 4:
      result = CSsl3TlsClientContext::PskGenerateClientExchangeValue(this, a2, a3, 0i64, v7);
      break;
    default:
      result = CSslContext::RsaGenerateClientExchangeValue(this, 0i64, v7, a4);
      break;
  }
  if ( !(_DWORD)result )
  {
    v10 = (unsigned __int8 *)SPExternalAlloc(*v7);
    *((_QWORD *)this + 119) = v10;
    if ( v10 )
    {
      v12 = *(_DWORD *)(*((_QWORD *)this + 1) + 48i64);
      switch ( v12 )
      {
        case 3:
          return CSsl3TlsClientContext::EccGenerateClientExchangeValue(this, a2, a3, v10, v7);
        case 2:
          return CSsl3TlsClientContext::DhGenerateClientExchangeValue(this, a2, a3, v10, v7);
        case 4:
          return CSsl3TlsClientContext::PskGenerateClientExchangeValue(this, a2, a3, v10, v7);
        default:
          return CSslContext::RsaGenerateClientExchangeValue(this, v10, v7, v11);
      }
    }
    else
    {
      return 14i64;
    }
  }
  return result;
}
// 18002CF53: variable 'v11' is possibly undefined

//----- (00000001800049B0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::EccGenerateClientExchangeValue(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int8 *a4,
        unsigned int *a5)
{
  __int64 v5; // rax
  CSsl3TlsClientContext *v7; // rdi
  struct _BCRYPT_ECCKEY_BLOB *p_Size_4; // rsi
  bool v9; // zf
  __int64 v10; // r13
  int v11; // r15d
  int v12; // r12d
  unsigned int v13; // eax
  __int64 v14; // r14
  unsigned int v15; // ecx
  unsigned int v16; // eax
  unsigned int v17; // edx
  CCipherMill *v18; // rcx
  unsigned __int8 *v19; // r14
  unsigned int v20; // r8d
  __int16 v21; // ax
  __int16 v22; // r12
  __int16 v23; // r12
  unsigned int *v24; // r9
  unsigned int v25; // edx
  int v26; // r15d
  unsigned int v27; // eax
  unsigned int EccBcryptKeyBlobFromKeyExchangeBlob; // ebx
  __int64 v29; // rax
  unsigned int v30; // edx
  __int64 v31; // rcx
  unsigned int EphemKey; // eax
  __int64 *v33; // rax
  __int64 v34; // rcx
  unsigned int EphemBlobFromKey; // eax
  struct _BCRYPT_ECCKEY_BLOB *v36; // r14
  unsigned int v37; // edx
  unsigned __int64 v38; // rcx
  unsigned __int64 v39; // rax
  void *v40; // rsp
  unsigned __int8 v41; // r8
  unsigned __int8 *v42; // rdx
  __int64 *v43; // rax
  __int64 v44; // rcx
  ULONG dwMagic; // ebx
  __int64 *v46; // rax
  __int64 v47; // rcx
  unsigned __int8 *v48; // r15
  int v49; // ecx
  int v50; // eax
  unsigned int EccDhPskSessionKeysHelper; // eax
  unsigned int v53; // eax
  unsigned __int8 v54; // r9
  int v55; // edx
  unsigned __int8 v56; // r9
  int v57; // r8d
  int v58; // edx
  int v59; // r8d
  int v60; // edx
  struct _BCRYPT_ECCKEY_BLOB *v61; // rax
  __int64 v62; // rcx
  __int64 v63; // [rsp+0h] [rbp-40h] BYREF
  int v64; // [rsp+40h] [rbp+0h] BYREF
  unsigned int Size; // [rsp+44h] [rbp+4h] BYREF
  enum _eTlsHashAlgorithm Size_4; // [rsp+48h] [rbp+8h] BYREF
  unsigned __int64 v67; // [rsp+50h] [rbp+10h] BYREF
  unsigned __int64 v68; // [rsp+58h] [rbp+18h] BYREF
  enum _eTlsSignatureAlgorithm v69; // [rsp+60h] [rbp+20h] BYREF
  ULONG v70; // [rsp+64h] [rbp+24h] BYREF
  unsigned int v71; // [rsp+68h] [rbp+28h] BYREF
  struct CEccCurveInfo *v72; // [rsp+70h] [rbp+30h] BYREF
  int v73; // [rsp+78h] [rbp+38h]
  unsigned __int8 v74[4]; // [rsp+7Ch] [rbp+3Ch]
  unsigned __int16 *v75; // [rsp+80h] [rbp+40h] BYREF
  struct _BCRYPT_ECCKEY_BLOB *v76; // [rsp+88h] [rbp+48h] BYREF
  unsigned __int8 *v77; // [rsp+90h] [rbp+50h]
  unsigned __int8 *v78; // [rsp+98h] [rbp+58h]

  v5 = *((_QWORD *)this + 1);
  v67 = 0i64;
  v68 = 0i64;
  v7 = this;
  v78 = a4;
  p_Size_4 = 0i64;
  v9 = *(_DWORD *)(v5 + 52) == 2;
  v10 = a3;
  v71 = 0;
  v76 = 0i64;
  v75 = 0i64;
  Size_4 = TlsHashAlgorithm_None;
  v70 = 0;
  if ( v9 )
  {
    v11 = 1;
  }
  else
  {
    if ( *(_DWORD *)(v5 + 52) != 4 )
      return 2148074248i64;
    v11 = 3;
  }
  if ( !a2 )
    return 2148074248i64;
  if ( a3 < 4 )
    goto LABEL_75;
  if ( *a2 != 3 )
  {
    v54 = 47;
    v55 = 800;
LABEL_77:
    EccBcryptKeyBlobFromKeyExchangeBlob = -2146893048;
    CSslContext::SetErrorAndFatalAlert((__int64)this, v55, -2146893048, v54);
    return EccBcryptKeyBlobFromKeyExchangeBlob;
  }
  v12 = a2[2] | (a2[1] << 8);
  v13 = a2[3];
  v73 = v12;
  *(_DWORD *)v74 = v13;
  if ( v13 < 2 )
    goto LABEL_75;
  v14 = v13 + 4;
  if ( (unsigned int)v14 > a3 )
    goto LABEL_75;
  v77 = a2 + 4;
  v15 = v13 + 6;
  if ( a4 )
  {
    if ( *a5 >= v15 )
    {
      v16 = *((unsigned __int16 *)v7 + 460);
      if ( (_WORD)v16 )
      {
        v17 = 0;
        while ( *(unsigned __int16 *)(*((_QWORD *)v7 + 114) + 2i64 * v17) != v12 )
        {
          if ( ++v17 >= v16 )
            goto LABEL_79;
        }
      }
      CSslContext::SetEccCurveInfo(v7, v12);
      if ( !*(_DWORD *)(*((_QWORD *)v7 + 10) + 196i64) )
        goto LABEL_18;
      v72 = 0i64;
      if ( (unsigned int)CCipherMill::GetCurveInfo(v18, v12, &v72) )
      {
        v56 = 80;
        EccBcryptKeyBlobFromKeyExchangeBlob = -2146893052;
        v58 = 800;
        goto LABEL_83;
      }
      if ( IsEcdheAlgorithmBlacklisted(
             *(struct _TLS_PARAMETERS **)(*((_QWORD *)v7 + 10) + 200i64),
             *(_DWORD *)(*((_QWORD *)v7 + 10) + 196i64),
             v72,
             0i64,
             1u) )
      {
LABEL_79:
        v56 = 40;
        EccBcryptKeyBlobFromKeyExchangeBlob = -2146893048;
        v58 = 801;
      }
      else
      {
LABEL_18:
        v19 = &a2[v14];
        v20 = (_DWORD)v19 - (_DWORD)a2;
        v9 = (*((_DWORD *)v7 + 16) & 0x80800) == 0;
        LODWORD(v72) = (_DWORD)v19 - (_DWORD)a2;
        if ( v9 )
        {
LABEL_23:
          if ( v19 + 2 <= &a2[v10] )
          {
            v25 = (*v19 << 8) | v19[1];
            if ( &v19[v25 + 2] <= &a2[v10] )
            {
              v26 = v11 - 1;
              if ( v26 )
              {
                if ( v26 == 2 )
                {
                  v53 = VerifyEcdsaParams(v7, a2, v20, Size_4, v19 + 2, v25);
                  EccBcryptKeyBlobFromKeyExchangeBlob = v53;
                  if ( v53 )
                  {
                    v56 = 51;
                    v57 = v53;
                    v58 = 803;
                    goto LABEL_85;
                  }
                }
              }
              else
              {
                v27 = VerifyRsaParams((UCHAR *)v7, a2, v20, v75, Size_4, v70, v19 + 2, v25);
                EccBcryptKeyBlobFromKeyExchangeBlob = v27;
                if ( v27 )
                {
                  v56 = 51;
                  v57 = v27;
                  v58 = 802;
                  goto LABEL_85;
                }
              }
              if ( (*((_BYTE *)v7 + 32) & 1) != 0 && (v29 = *((_QWORD *)v7 + 1)) != 0 )
              {
                v30 = *(_DWORD *)(v29 + 28);
              }
              else
              {
                v29 = *((_QWORD *)v7 + 1);
                v30 = 0;
                if ( !v29 )
                {
                  v31 = 0i64;
                  goto LABEL_31;
                }
              }
              v31 = *(_QWORD *)v29;
LABEL_31:
              EphemKey = EccGetEphemKey(v31, v30, *((unsigned __int16 *)v7 + 17), v12, &v68, &v71);
              EccBcryptKeyBlobFromKeyExchangeBlob = EphemKey;
              if ( !EphemKey )
              {
                *(_DWORD *)(*((_QWORD *)v7 + 165) + 8i64) = v71;
                v33 = (__int64 *)*((_QWORD *)v7 + 1);
                if ( v33 )
                  v34 = *v33;
                else
                  v34 = 0i64;
                EphemBlobFromKey = GetEphemBlobFromKey(v34, v68, L"ECCPUBLICBLOB", &Size, (unsigned __int8 **)&v76);
                v36 = v76;
                EccBcryptKeyBlobFromKeyExchangeBlob = EphemBlobFromKey;
                if ( EphemBlobFromKey )
                {
                  v59 = EphemBlobFromKey;
                  v60 = 806;
                  goto LABEL_91;
                }
                v37 = Size;
                p_Size_4 = 0i64;
                if ( Size )
                {
                  if ( Size <= (unsigned __int64)g_ulMaxStackAllocSize )
                  {
                    v38 = Size + g_ulAdditionalProbeSize + 8;
                    if ( v38 >= Size )
                    {
                      if ( !(unsigned int)VerifyStackAvailable(v38) )
                      {
LABEL_92:
                        v37 = Size;
                        goto LABEL_93;
                      }
                      v37 = Size;
                      v39 = Size + 8 + 15i64;
                      if ( v39 <= Size + 8 )
                        v39 = 0xFFFFFFFFFFFFFF0i64;
                      v40 = alloca(v39 & 0xFFFFFFFFFFFFFFF0ui64);
                      p_Size_4 = (struct _BCRYPT_ECCKEY_BLOB *)&v64;
                      if ( &v63 != (__int64 *)-64i64 )
                      {
                        v64 = 1801679955;
                        p_Size_4 = (struct _BCRYPT_ECCKEY_BLOB *)&Size_4;
                        if ( &Size_4 )
                        {
                          v37 = Size;
LABEL_44:
                          memset_0(p_Size_4, 0, v37);
                          v41 = v74[0];
                          v42 = v77;
                          *p_Size_4 = *v36;
                          EccBcryptKeyBlobFromKeyExchangeBlob = GetEccBcryptKeyBlobFromKeyExchangeBlob(
                                                                  *((_DWORD *)v7 + 5),
                                                                  v42,
                                                                  v41,
                                                                  p_Size_4,
                                                                  Size);
                          if ( EccBcryptKeyBlobFromKeyExchangeBlob )
                          {
LABEL_54:
                            if ( v36 )
                              SPExternalFree(v36);
                            if ( p_Size_4 && p_Size_4[-1].dwMagic == 1885431112 )
                              ((void (*)(void))g_pfnFree)();
                            goto LABEL_59;
                          }
                          v43 = (__int64 *)*((_QWORD *)v7 + 1);
                          v44 = v43[106];
                          if ( v44 && *(_BYTE *)(v44 + 24) )
                          {
                            dwMagic = p_Size_4->dwMagic;
                            p_Size_4->dwMagic = v12;
                            v46 = (__int64 *)*((_QWORD *)v7 + 1);
                            if ( v46 )
                              v47 = *v46;
                            else
                              v47 = 0i64;
                            if ( !(unsigned int)SslImportKey(v47, &v67, L"SSLECCPUBLICBLOB", p_Size_4, Size, 0) )
                              goto LABEL_50;
                            p_Size_4->dwMagic = dwMagic;
                            v43 = (__int64 *)*((_QWORD *)v7 + 1);
                          }
                          if ( v43 )
                            v62 = *v43;
                          else
                            v62 = 0i64;
                          EccBcryptKeyBlobFromKeyExchangeBlob = SslImportKey(
                                                                  v62,
                                                                  &v67,
                                                                  L"ECCPUBLICBLOB",
                                                                  p_Size_4,
                                                                  Size,
                                                                  0);
                          if ( !EccBcryptKeyBlobFromKeyExchangeBlob )
                          {
LABEL_50:
                            v48 = v78;
                            v49 = *((_DWORD *)v7 + 5);
                            LOBYTE(v64) = *(_BYTE *)a5 - 1;
                            if ( (unsigned int)GetEccKeyExchangeBlobFromBcryptKeyBlob(
                                                 v49,
                                                 v36,
                                                 v78 + 1,
                                                 (unsigned __int8 *)&v64) )
                            {
                              EccBcryptKeyBlobFromKeyExchangeBlob = -2146893048;
                            }
                            else
                            {
                              v50 = (unsigned __int8)v64;
                              *v48 = v64;
                              *a5 = v50 + 1;
                              if ( (*((_DWORD *)v7 + 34) & 0x8000000) != 0 )
                              {
                                (*(void (__fastcall **)(CSsl3TlsClientContext *, unsigned __int64))(*(_QWORD *)v7
                                                                                                  + 152i64))(
                                  v7,
                                  v67);
                                EccDhPskSessionKeysHelper = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, unsigned __int64))(*(_QWORD *)v7 + 168i64))(
                                                              v7,
                                                              v68);
                                v67 = 0i64;
                                v68 = 0i64;
                              }
                              else
                              {
                                EccDhPskSessionKeysHelper = MakeEccDhPskSessionKeysHelper(v7, v68, v67, 0);
                              }
                              EccBcryptKeyBlobFromKeyExchangeBlob = EccDhPskSessionKeysHelper;
                            }
                            goto LABEL_54;
                          }
                          v59 = EccBcryptKeyBlobFromKeyExchangeBlob;
                          v60 = 804;
LABEL_91:
                          CSslContext::SetErrorAndFatalAlert((__int64)v7, v60, v59, 0x33u);
                          goto LABEL_54;
                        }
                        goto LABEL_92;
                      }
                    }
                  }
                }
LABEL_93:
                if ( v37 + 8 >= v37 )
                {
                  v61 = (struct _BCRYPT_ECCKEY_BLOB *)((__int64 (__fastcall *)(_QWORD))g_pfnAllocate)(v37 + 8);
                  p_Size_4 = v61;
                  if ( !v61 )
                    goto LABEL_97;
                  v61->dwMagic = 1885431112;
                  p_Size_4 = v61 + 1;
                  v37 = Size;
                }
                if ( p_Size_4 )
                  goto LABEL_44;
LABEL_97:
                EccBcryptKeyBlobFromKeyExchangeBlob = 14;
                goto LABEL_54;
              }
              v56 = 51;
              v57 = EphemKey;
              v58 = 805;
LABEL_85:
              CSslContext::SetErrorAndFatalAlert((__int64)v7, v58, v57, v56);
LABEL_59:
              if ( v68 )
                SslFreeObject(v68, 0i64);
              if ( v67 )
                SslFreeObject(v67, 0i64);
              return EccBcryptKeyBlobFromKeyExchangeBlob;
            }
          }
LABEL_75:
          v54 = 50;
          v55 = 800;
LABEL_76:
          this = v7;
          goto LABEL_77;
        }
        if ( v19 + 2 > &a2[v10] )
        {
          v56 = 50;
        }
        else
        {
          v21 = *v19;
          v22 = v19[1];
          v19 += 2;
          v23 = v21 | (v22 << 8);
          if ( !CTlsSignatureSuiteList::IsSupportedCodePoint((CSsl3TlsClientContext *)((char *)v7 + 474), v23) )
          {
            v54 = 47;
            v55 = 821;
            goto LABEL_76;
          }
          v69 = TlsSignatureAlgorithm_Anonymous;
          GetSignatureSuiteInfoByCodePoint(v23, &v69, &Size_4, v24, (const unsigned __int16 **)&v75, 0i64, &v70);
          if ( v69 == v11 )
          {
            v20 = (unsigned int)v72;
            v12 = v73;
            goto LABEL_23;
          }
          v56 = 40;
        }
        EccBcryptKeyBlobFromKeyExchangeBlob = -2146893048;
        v58 = 821;
      }
LABEL_83:
      v57 = EccBcryptKeyBlobFromKeyExchangeBlob;
      goto LABEL_85;
    }
    return 2148074273i64;
  }
  else
  {
    *a5 = v15;
    return 0i64;
  }
}
// 180004AAE: conditional instruction was optimized away because eax.4 is in (1..FFFF)
// 180004AF5: variable 'v18' is possibly undefined
// 180004BB1: variable 'v24' is possibly undefined
// 180082258: using guessed type wchar_t aSsleccpublicbl[17];
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);
// 1800985A0: using guessed type __int64 __fastcall SslImportKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180004F90) ----------------------------------------------------
__int64 __fastcall GetEccKeyExchangeBlobFromBcryptKeyBlob(
        char a1,
        struct _BCRYPT_ECCKEY_BLOB *a2,
        unsigned __int8 *a3,
        unsigned __int8 *a4)
{
  if ( !a2 || !a4 )
    return 87i64;
  if ( (a1 & 8) != 0 )
    return MontgomeryGetKeyExchangeBlob(a2, a3, a4);
  return NonMontgomeryGetKeyExchangeBlob(a2, a3, a4);
}

//----- (0000000180004FC4) ----------------------------------------------------
__int64 __fastcall GetEccBcryptKeyBlobFromKeyExchangeBlob(
        char a1,
        unsigned __int8 *a2,
        unsigned __int8 a3,
        struct _BCRYPT_ECCKEY_BLOB *a4,
        unsigned int a5)
{
  unsigned int v5; // ebx

  v5 = 0;
  if ( !a2 || !a4 )
    return 87i64;
  if ( (a1 & 8) != 0 )
    return MontgomeryGetEccPublicKeyBlob(a2, a3, a4, a5);
  if ( *a2 == 4 && (unsigned __int64)a3 + 7 <= a5 )
    memcpy_0(&a4[1], a2 + 1, (unsigned int)a3 - 1);
  else
    return (unsigned int)-2146893048;
  return v5;
}

//----- (000000018000503C) ----------------------------------------------------
__int64 __fastcall EccGetEphemKey(
        __int64 a1,
        unsigned int a2,
        unsigned int a3,
        int a4,
        unsigned __int64 *a5,
        unsigned int *a6)
{
  unsigned int v8; // edi
  unsigned int PublicKeyLength; // eax
  unsigned int EphemeralKey; // ebx
  unsigned int v14; // [rsp+88h] [rbp+20h] BYREF

  v8 = 0;
  v14 = 0;
  RtlAcquireResourceShared(&Resource, 1u);
  if ( a4 && qword_1800925C8 )
  {
    PublicKeyLength = CMasterEccCurveInfo::GetPublicKeyLength(qword_1800925C8, a4, &v14);
    v8 = v14;
    EphemeralKey = PublicKeyLength;
  }
  else
  {
    EphemeralKey = 87;
  }
  RtlReleaseResource(&Resource);
  if ( !EphemeralKey )
  {
    EphemeralKey = SslCreateEphemeralKey(a1, a5, a3, a2, a4, v8, 0i64, 0, 0);
    if ( EphemeralKey
      && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        11i64,
        &WPP_3e0ca11e9b65363ec3903422d835754d_Traceguids,
        EphemeralKey);
    }
    if ( a6 )
      *a6 = v8;
  }
  return EphemeralKey;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098548: using guessed type __int64 __fastcall SslCreateEphemeralKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180005130) ----------------------------------------------------
__int64 __fastcall CMasterEccCurveInfo::GetPublicKeyLength(CMasterEccCurveInfo *this, int a2, unsigned int *a3)
{
  unsigned int v3; // r9d
  unsigned int v4; // r11d
  __int64 v6; // rdi
  unsigned int v7; // ecx
  __int64 v8; // rax
  unsigned int v9; // ebx
  __int64 v10; // r8
  __int64 result; // rax

  *a3 = 0;
  v3 = 0;
  v4 = *((_DWORD *)this + 2);
  if ( !v4 )
    return 1168i64;
  v6 = *(_QWORD *)this;
  while ( 1 )
  {
    v7 = 0;
    v8 = 32i64 * v3;
    v9 = *(_DWORD *)(v8 + v6 + 8);
    if ( v9 )
      break;
LABEL_10:
    if ( ++v3 >= v4 )
      return 1168i64;
  }
  v10 = *(_QWORD *)(v8 + v6);
  while ( *(_DWORD *)(780i64 * v7 + v10 + 772) != a2 )
  {
    if ( ++v7 >= v9 )
      goto LABEL_10;
  }
  result = 0i64;
  *a3 = *(_DWORD *)(780i64 * v7 + v10 + 768);
  return result;
}

//----- (00000001800051C0) ----------------------------------------------------
void __fastcall GetSignatureSuiteInfoByCodePoint(
        __int16 a1,
        enum _eTlsSignatureAlgorithm *a2,
        enum _eTlsHashAlgorithm *a3,
        unsigned int *a4,
        const unsigned __int16 **a5,
        unsigned int *a6,
        unsigned int *a7)
{
  enum _eTlsSignatureAlgorithm *v8; // rcx
  __int16 v9; // ax

  if ( a2 )
    *a2 = TlsSignatureAlgorithm_Anonymous;
  if ( a3 )
    *a3 = TlsHashAlgorithm_None;
  if ( a5 )
    *a5 = 0i64;
  if ( a7 )
    *a7 = 0;
  if ( a6 )
    *a6 = 0;
  if ( a4 )
    *a4 = 0;
  v8 = (enum _eTlsSignatureAlgorithm *)&unk_18007C390;
  v9 = __ROR2__(a1, 8);
  while ( v9 != *(_WORD *)v8 )
  {
    v8 += 18;
    if ( v8 >= (enum _eTlsSignatureAlgorithm *)&CSsl3TlsServerContext::`vftable' )
      return;
  }
  if ( a2 )
    *a2 = v8[7];
  if ( a3 )
    *a3 = *((enum _eTlsHashAlgorithm *)v8 + 10);
  if ( a5 )
    *a5 = (const unsigned __int16 *)*((_QWORD *)v8 + 6);
  if ( a6 )
    *a6 = *((unsigned __int8 *)v8 + 56);
  if ( a7 )
    *a7 = *((_DWORD *)v8 + 15);
  if ( a4 )
    *a4 = *((_DWORD *)v8 + 11);
}
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';

//----- (0000000180005298) ----------------------------------------------------
bool __fastcall CTlsSignatureSuiteList::IsSupportedCodePoint(CTlsSignatureSuiteList *this, __int16 a2)
{
  unsigned __int8 SignatureSuiteInfoRowByCodePoint; // al
  int v3; // r9d
  int v4; // r10d
  __int64 v5; // r11
  int v6; // ecx
  bool result; // al

  SignatureSuiteInfoRowByCodePoint = GetSignatureSuiteInfoRowByCodePoint(a2);
  result = SignatureSuiteInfoRowByCodePoint < 0xCu
        && (v6 = *(unsigned __int16 *)(v5 + 34), _bittest(&v6, SignatureSuiteInfoRowByCodePoint))
        && ((v4 & 0x3000) == 0
         || *((_DWORD *)&unk_18007C390 + 18 * SignatureSuiteInfoRowByCodePoint + 7) != 3
         || *((_DWORD *)&unk_18007C390 + 18 * SignatureSuiteInfoRowByCodePoint + 16) == v3)
        && (v4 & *((_DWORD *)&unk_18007C390 + 18 * SignatureSuiteInfoRowByCodePoint + 6)) != 0;
  return result;
}
// 1800052AE: variable 'v5' is possibly undefined
// 1800052C9: variable 'v4' is possibly undefined
// 18002D6BE: variable 'v3' is possibly undefined

//----- (00000001800052F0) ----------------------------------------------------
unsigned __int8 __fastcall GetSignatureSuiteInfoRowByCodePoint(__int16 a1)
{
  char v1; // dl
  void **v2; // rax
  __int16 v3; // cx

  v1 = 0;
  v2 = (void **)&unk_18007C390;
  v3 = __ROR2__(a1, 8);
  while ( v3 != *(_WORD *)v2 )
  {
    v2 += 9;
    ++v1;
    if ( v2 >= &CSsl3TlsServerContext::`vftable' )
      return -1;
  }
  return v1;
}
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';

//----- (0000000180005324) ----------------------------------------------------
void __fastcall CSslContext::SetEccCurveInfo(CSslContext *this, int a2)
{
  __int64 v2; // rax
  __int64 *v4; // r9
  unsigned int v5; // r10d
  unsigned int v6; // r8d
  __int64 v7; // r11
  __int64 v8; // rdx

  v2 = *((_QWORD *)this + 1);
  *((_DWORD *)this + 4) = a2;
  v4 = *(__int64 **)(v2 + 848);
  if ( v4 )
  {
    v5 = *((_DWORD *)v4 + 2);
    v6 = 0;
    if ( v5 )
    {
      v7 = *v4;
      while ( 1 )
      {
        v8 = 780i64 * v6;
        if ( *(_DWORD *)(v7 + v8 + 772) == a2 )
          break;
        if ( ++v6 >= v5 )
          return;
      }
      if ( v7 + v8 )
        *((_DWORD *)this + 5) = *(_DWORD *)(v7 + v8 + 776);
    }
  }
}

//----- (000000018000538C) ----------------------------------------------------
__int64 __fastcall CSessionCacheManager::CacheRetrieveNewClientItem(
        CSessionCacheManager *this,
        const unsigned __int16 *a2,
        struct CSessionCacheClientItem **a3)
{
  __int64 result; // rax
  bool v5; // zf
  struct CSessionCacheItem *v6; // [rsp+58h] [rbp+20h] BYREF

  result = CSessionCacheManager::CacheRetrieveNewItem(this, 0, a2, 0i64, &v6);
  if ( !(_DWORD)result )
  {
    v5 = v6 == 0i64;
    *a3 = v6;
    if ( v5 )
      return 87i64;
  }
  return result;
}

//----- (00000001800053D0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::ProcessHandshake(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int8 *a4)
{
  unsigned int SessionKeys; // ebx
  bool v5; // cf
  int v8; // ecx
  unsigned int v9; // r15d
  int v10; // eax
  unsigned int v11; // r12d
  unsigned int v12; // ecx
  unsigned __int8 *v13; // r14
  unsigned int v14; // ebp
  CCipherMill *v15; // rcx
  __int64 v16; // r8
  int v17; // r9d
  HLOCAL v18; // rax
  struct _RTL_RESOURCE *v19; // rcx
  int v20; // edx
  __int64 v22; // rax
  CCipherMill *v23; // rcx
  __int64 v24; // rdx
  struct CSessionCacheManager *v25; // rdx
  __int64 v26; // rcx
  struct CSessionCacheClientItem *v27; // rbx
  int v28; // eax
  __int64 v29; // rcx
  __int64 v30; // rcx
  CCipherMill *v31; // rcx
  void *v32; // rcx
  CCipherMill *v33; // rcx
  __int64 v34; // rax
  __int64 v35; // rax
  unsigned __int8 v36; // r9
  int v37; // edx
  __int64 v38; // rdx
  CCipherMill *v39; // rcx
  unsigned int v40; // eax
  struct CSessionCacheClientItem *v41; // [rsp+50h] [rbp-88h] BYREF
  unsigned __int8 *v42; // [rsp+58h] [rbp-80h]
  __int128 Src[2]; // [rsp+60h] [rbp-78h] BYREF

  SessionKeys = 0;
  v5 = *((_BYTE *)this + 233) != 0;
  v42 = a4;
  *(_DWORD *)a4 = 0;
  v8 = *a2;
  v9 = 32;
  v10 = *((unsigned __int16 *)this + 34);
  v41 = 0i64;
  v11 = v5 ? 12 : 4;
  v12 = v10 | (v8 << 16);
  v13 = &a2[v11];
  v14 = a3 - v11;
  memset(Src, 0, sizeof(Src));
  if ( v12 > 0xC0046 )
  {
    if ( v12 < 0xD0029 )
      goto LABEL_151;
    if ( v12 > 0xD002B )
    {
      if ( v12 <= 0xE0028 )
        goto LABEL_151;
      if ( v12 > 0xE002C )
      {
        if ( v12 == 1310765 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 32i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
          }
          SessionKeys = CSsl3TlsContext::DigestFinish(this, v13, v14);
          v19 = (struct _RTL_RESOURCE *)(*((_QWORD *)this + 165) + 72i64);
          if ( !SessionKeys )
          {
            RtlAcquireResourceExclusive(v19, 1u);
            UpdateServerCertificateSerialChainProperty(this, 0);
            RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
            *(_DWORD *)v42 = 1;
            (*(void (__fastcall **)(CSsl3TlsClientContext *))(*(_QWORD *)this + 448i64))(this);
            if ( (*((_DWORD *)this + 34) & 0x8000000) != 0 )
              CSessionCacheManager::FinishCacheAddItem(CSessionCacheManager::m_pSessionCacheManager, this);
            return SessionKeys;
          }
LABEL_130:
          RtlAcquireResourceExclusive(v19, 1u);
          CSessionCacheClientItem::SetSessionTicket(
            *((CSessionCacheClientItem **)this + 165),
            0i64,
            0,
            0i64,
            0,
            0,
            0,
            0,
            0);
          RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
          return SessionKeys;
        }
        if ( v12 == 1310768 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 31i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
          }
          SessionKeys = CSsl3TlsContext::DigestFinish(this, v13, v14);
          v19 = (struct _RTL_RESOURCE *)(*((_QWORD *)this + 165) + 72i64);
          if ( !SessionKeys )
          {
            RtlAcquireResourceExclusive(v19, 1u);
            UpdateServerCertificateSerialChainProperty(this, 1u);
            RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
            *((_DWORD *)this + 17) = 92;
            return SessionKeys;
          }
          goto LABEL_130;
        }
        if ( v12 != 917574 )
        {
          if ( v12 != 1441833 )
            goto LABEL_151;
          v33 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
            v33 = WPP_GLOBAL_Control;
          }
          if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) == 4 )
          {
            if ( v33 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v33 + 28) & 1) != 0 )
              WPP_SF_(*((_QWORD *)v33 + 2), 21i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
            v36 = 10;
            v37 = 200;
            goto LABEL_116;
          }
          SessionKeys = CSsl3TlsClientContext::DigestCertificateStatus(this, v13, v14);
          if ( !SessionKeys )
            *((_DWORD *)this + 17) = 42;
          return SessionKeys;
        }
      }
      v15 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 27i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        v15 = WPP_GLOBAL_Control;
      }
      if ( a3 > v11 )
        return (unsigned int)-2146893048;
      if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) != 4 )
      {
        if ( *((_WORD *)this + 34) == 70 )
        {
          if ( v15 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v15 + 28) & 1) == 0 )
            goto LABEL_155;
          v38 = 28i64;
          goto LABEL_154;
        }
        CreateServerCertificateSerialChainProperty(this);
        SessionKeys = AutoVerifyServerCertificate(this);
        if ( SessionKeys )
          return SessionKeys;
      }
      SessionKeys = CSsl3TlsClientContext::DigestServerKeyX(
                      this,
                      *((unsigned __int8 **)this + 121),
                      *((_DWORD *)this + 244),
                      a4);
      if ( !SessionKeys )
      {
        v32 = (void *)*((_QWORD *)this + 121);
        if ( v32 )
        {
          SPExternalFree(v32);
          *((_QWORD *)this + 121) = 0i64;
        }
        *((_DWORD *)this + 17) = 91;
        *((_BYTE *)this + 924) = 0;
        if ( *((_BYTE *)this + 1314) )
        {
          SessionKeys = CSsl3TlsClientContext::CheckForClientCred(this);
          *((_BYTE *)this + 1314) = 0;
        }
        if ( *((_BYTE *)this + 1313) )
          return 590624;
      }
      return SessionKeys;
    }
    v39 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 25i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      v39 = WPP_GLOBAL_Control;
    }
    if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) == 4 )
    {
      if ( v39 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v39 + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)v39 + 2), 26i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      v36 = 10;
      v37 = 400;
      goto LABEL_116;
    }
    SessionKeys = CSsl3TlsClientContext::DigestCertificateRequest(this, v13, v14);
    if ( SessionKeys )
      return SessionKeys;
    v40 = CSsl3TlsClientContext::CheckForClientCred(this);
    SessionKeys = v40;
    if ( v40 == -2146893024 )
    {
      *((_BYTE *)this + 1313) = 1;
    }
    else if ( v40 != 590624 )
    {
      if ( v40 )
        return SessionKeys;
      goto LABEL_147;
    }
    SessionKeys = 0;
LABEL_147:
    *((_BYTE *)this + 1315) = 1;
    *((_DWORD *)this + 17) = 44;
    return SessionKeys;
  }
  switch ( v12 )
  {
    case 0xC0046u:
LABEL_11:
      v15 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        v15 = WPP_GLOBAL_Control;
      }
      v16 = *((_QWORD *)this + 1);
      v17 = *(_DWORD *)(v16 + 48);
      if ( v17 == 4 )
      {
LABEL_17:
        *((_DWORD *)this + 244) = v14;
        v18 = SPExternalAlloc(v14);
        *((_QWORD *)this + 121) = v18;
        if ( v18 )
        {
          memcpy_0(v18, v13, *((unsigned int *)this + 244));
          *((_DWORD *)this + 17) = 43;
        }
        else
        {
          return 14;
        }
        return SessionKeys;
      }
      if ( *((_WORD *)this + 34) != 70 )
      {
        if ( (unsigned int)(v17 - 2) > 1 && !*(_BYTE *)(v16 + 72) )
        {
          if ( v15 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v15 + 28) & 1) != 0 )
            WPP_SF_(*((_QWORD *)v15 + 2), 24i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
          v36 = 10;
          v37 = 824;
LABEL_116:
          SessionKeys = -2146893018;
          CSslContext::SetErrorAndFatalAlert((__int64)this, v37, -2146893018, v36);
          return SessionKeys;
        }
        goto LABEL_17;
      }
      if ( v15 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v15 + 28) & 1) == 0 )
        goto LABEL_155;
      v38 = 23i64;
      goto LABEL_154;
    case 0x20028u:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      SessionKeys = CSsl3TlsClientContext::DigestServerHello(this, v13, v14, (int *)&v41);
      if ( SessionKeys )
        return SessionKeys;
      if ( (_DWORD)v41 )
      {
        v34 = *((_QWORD *)this + 17);
        if ( (v34 & 0x1000000) == 0 )
        {
          if ( (v34 & 0x8000000) == 0 )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
            }
            v36 = 40;
            v37 = 106;
            goto LABEL_116;
          }
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 16i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
          }
          v35 = *((_QWORD *)this + 15);
          if ( v35 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
          {
            *(_WORD *)(v35 + 64) |= 4u;
            *(_DWORD *)(v35 + 24) = 1;
          }
          RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64), 1u);
          SessionKeys = CSslContext::MakeSessionKeys(this, *(_QWORD *)(*((_QWORD *)this + 165) + 16i64));
          RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
          if ( SessionKeys )
            return SessionKeys;
        }
        v20 = 47;
      }
      else
      {
        v20 = 70;
      }
      *((_DWORD *)this + 17) = v20;
      *((_BYTE *)this + 1315) = 0;
      return SessionKeys;
    case 0x30028u:
      SessionKeys = CSsl3TlsClientContext::DigestServerHelloVerifyRequest(this, v13, v14);
      if ( !SessionKeys )
        *((_DWORD *)this + 17) = 97;
      return SessionKeys;
    case 0xB0046u:
      goto LABEL_47;
    case 0x4002Eu:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 29i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      SessionKeys = CSsl3TlsClientContext::DigestNewSessionTicket(this, v13, v14);
      if ( !SessionKeys )
        *((_DWORD *)this + 17) = 50;
      return SessionKeys;
    case 0xB002Fu:
      v22 = *((_QWORD *)this + 17);
      if ( (v22 & 0x1000000) != 0 )
      {
        v23 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_S(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x11u,
            (__int64)&WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
            *(const wchar_t **)(*((_QWORD *)this + 165) + 368i64));
          v22 = *((_QWORD *)this + 17);
        }
        v24 = *((_QWORD *)this + 165);
        *((_QWORD *)this + 17) = v22 & 0xFFFFFFFFFEFFFFFFui64;
        CSessionCacheManager::AcquireCacheTableLock((__int64)v23, *(const unsigned __int16 **)(v24 + 368), 0i64);
        RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64), 1u);
        v25 = CSessionCacheManager::m_pSessionCacheManager;
        *(_BYTE *)(*((_QWORD *)this + 165) + 236i64) = 0;
        SessionKeys = CSessionCacheClientItem::CloneCacheElement(*((CSessionCacheClientItem **)this + 165), v25, &v41);
        RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
        if ( SessionKeys )
        {
          CSessionCacheManager::ReleaseCacheTableLock(
            v26,
            *(const unsigned __int16 **)(*((_QWORD *)this + 165) + 368i64),
            0i64);
          return SessionKeys;
        }
        v27 = v41;
        RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)v41 + 72), 1u);
        v28 = *((_DWORD *)this + 16);
        *((_QWORD *)this + 165) = v27;
        *((_QWORD *)this + 11) = v27;
        *((_DWORD *)v27 + 42) = v28;
        if ( *((unsigned __int16 *)this + 490) > 0x20u
          || (v9 = *((unsigned __int16 *)this + 490),
              memcpy_0(Src, (char *)this + 982, *((unsigned __int16 *)this + 490)),
              v9) )
        {
          v29 = *((_QWORD *)this + 165);
          *(_WORD *)(v29 + 238) = v9;
          memcpy_0((void *)(v29 + 240), Src, v9);
        }
        RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64));
        CSessionCacheManager::ReleaseCacheTableLock(
          v30,
          *(const unsigned __int16 **)(*((_QWORD *)this + 165) + 368i64),
          0i64);
      }
LABEL_47:
      v31 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        v31 = WPP_GLOBAL_Control;
      }
      if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) == 4 )
      {
        if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v31 + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)v31 + 2), 19i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        v36 = 10;
        v37 = 250;
        goto LABEL_116;
      }
      SessionKeys = CSsl3TlsContext::DigestRemoteCertificate(this, v13, v14);
      if ( !SessionKeys )
      {
        if ( (*((_DWORD *)this + 34) & 0x20000000) == 0
          || (RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64), 1u),
              SessionKeys = CSessionCacheClientItem::UpdateRemoteEndpointBindings(*((CSessionCacheClientItem **)this
                                                                                  + 165)),
              RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 165) + 72i64)),
              !SessionKeys) )
        {
          *((_DWORD *)this + 17) = 41;
        }
      }
      return SessionKeys;
  }
  if ( v12 != 262191 )
  {
    if ( v12 > 0xC0028 && v12 <= 0xC002A )
      goto LABEL_11;
LABEL_151:
    v15 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      goto LABEL_155;
    v38 = 33i64;
LABEL_154:
    WPP_SF_(*((_QWORD *)v15 + 2), v38, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
LABEL_155:
    if ( (*((_DWORD *)this + 16) & 0xF3FC0) != 0 )
    {
      *((_DWORD *)this + 17) = 96;
      *((_WORD *)this + 48) = 2562;
    }
    return (unsigned int)-2146893018;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 30i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
  SessionKeys = CSsl3TlsClientContext::DigestNewSessionTicket(this, v13, v14);
  if ( !SessionKeys )
    *((_DWORD *)this + 17) = 52;
  return SessionKeys;
}
// 1800056F2: variable 'v23' is possibly undefined
// 1800057F4: variable 'v30' is possibly undefined
// 1800058D0: variable 'a4' is possibly undefined
// 18002D70A: variable 'v26' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180005B10) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::DigestServerHello(
        CSsl3TlsClientContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        int *a4)
{
  CSsl3TlsClientContext *v4; // rdi
  int v5; // r15d
  unsigned int v6; // esi
  int v7; // r8d
  size_t v8; // r14
  unsigned __int8 *v9; // r12
  unsigned __int8 *v10; // rbx
  unsigned int v11; // esi
  int v12; // eax
  __int64 v13; // rdx
  int v14; // eax
  __int64 v15; // rcx
  unsigned int v16; // r8d
  __int64 v17; // r9
  unsigned int v18; // r10d
  unsigned int v19; // eax
  int v20; // r8d
  unsigned int v21; // r8d
  int v22; // eax
  unsigned int v23; // ebx
  struct CSessionCacheClientItem *v24; // rbx
  __int64 v25; // rcx
  int v26; // esi
  __int64 v27; // rcx
  CCipherMill *v28; // rcx
  __int64 v29; // rdx
  __int64 result; // rax
  __int64 v31; // r9
  int *v32; // rax
  __int64 v33; // rdx
  __int64 v34; // rax
  __int64 v35; // rax
  struct CSessionCacheManager *v36; // rdx
  __int64 v37; // rcx
  int v38; // edx
  unsigned __int8 v39; // r9
  unsigned __int8 IsMaliciousDowngrade; // al
  CCipherMill *v41; // rcx
  __int64 v42; // rdx
  unsigned int v43; // [rsp+34h] [rbp-45h]
  struct CSessionCacheClientItem *v44; // [rsp+38h] [rbp-41h] BYREF
  int *v45; // [rsp+40h] [rbp-39h]
  __int64 Buf1[3]; // [rsp+50h] [rbp-29h] BYREF
  int v47; // [rsp+68h] [rbp-11h]
  char v48; // [rsp+70h] [rbp-9h]
  __int64 v49; // [rsp+78h] [rbp-1h]
  int v50; // [rsp+80h] [rbp+7h]
  char v51; // [rsp+84h] [rbp+Bh]
  CSsl3TlsClientContext *v52; // [rsp+88h] [rbp+Fh]

  v45 = a4;
  v4 = this;
  v44 = 0i64;
  v5 = 32;
  *((_BYTE *)this + 554) = 0;
  if ( a3 < 0x23 )
    goto LABEL_78;
  v6 = a3 - 35;
  v7 = a2[1] | (*a2 << 8);
  *((_OWORD *)this + 19) = *(_OWORD *)(a2 + 2);
  *((_OWORD *)this + 20) = *(_OWORD *)(a2 + 18);
  v8 = a2[34];
  if ( (unsigned int)v8 > 0x20 )
  {
    v38 = 103;
LABEL_79:
    v39 = 50;
    goto LABEL_80;
  }
  if ( v6 < (int)v8 + 3 )
  {
LABEL_78:
    v38 = 100;
    goto LABEL_79;
  }
  v9 = a2 + 35;
  v10 = &a2[v8 + 35];
  v43 = v10[1] | (*v10 << 8);
  if ( v10[2] )
  {
    v39 = 30;
    v38 = 104;
LABEL_80:
    v23 = -2146893018;
    goto LABEL_81;
  }
  v11 = -3 - v8 + v6;
  if ( !*((_QWORD *)this + 10) )
    return 2148074244i64;
  v12 = ConvertSslVersionToSchannelProtocol(v7);
  v14 = *(_DWORD *)(v13 + 152) & v12 & 0xA2AA0;
  if ( !v14 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)v4, 105, -2146893007, 0x46u);
    return 2148074289i64;
  }
  *((_DWORD *)v4 + 16) = v14;
  *((_WORD *)v4 + 17) = ConvertSchannelProtocolToSsl(v14);
  v19 = *((_DWORD *)v4 + 9);
  if ( *((_BYTE *)v4 + 233) == (_BYTE)v17 )
  {
    if ( v19 <= v16 || v19 < 0x303 )
      goto LABEL_9;
  }
  else if ( v19 > 0xFEFD || v19 >= v16 )
  {
    goto LABEL_9;
  }
  IsMaliciousDowngrade = CSsl3TlsClientContext::IsMaliciousDowngrade(v4, v16);
  v17 = 0i64;
  if ( IsMaliciousDowngrade )
    return 2148074248i64;
  v18 = 2;
LABEL_9:
  if ( v11 <= v18 )
  {
    *((_BYTE *)v4 + 922) = v17;
  }
  else
  {
    Buf1[2] = 0i64;
    v47 = 0;
    v20 = v10[3];
    Buf1[0] = (__int64)&CTlsExtClient::`vftable';
    Buf1[1] = (__int64)v4;
    v48 = v17;
    v49 = v17;
    v50 = v17;
    v52 = v4;
    v51 = *((_BYTE *)v4 + 922);
    v21 = v10[4] | (v20 << 8);
    if ( v11 - 2 < v21 )
    {
      *((_BYTE *)v4 + 922) = v17;
    }
    else
    {
      v22 = CTlsExt::ParseTlsExtensions((__int64)Buf1, v10 + 5, v21, v18);
      v23 = v22;
      if ( v22 )
      {
        if ( v22 != -2146892986 )
          CSslContext::SetErrorAndFatalAlert((__int64)v4, 106, v22, 0xAu);
        CTlsExtClient::~CTlsExtClient((CTlsExtClient *)Buf1);
        return v23;
      }
    }
    CTlsExtClient::~CTlsExtClient((CTlsExtClient *)Buf1);
    LODWORD(v17) = 0;
  }
  if ( *((_BYTE *)v4 + 554) == (_BYTE)v17 )
  {
    if ( *((_BYTE *)v4 + 553) == (_BYTE)v17 )
    {
      if ( g_fAllowInsecureRenegoServers != (_DWORD)v17 )
        goto LABEL_14;
      v41 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      {
LABEL_73:
        CSslContext::SetErrorAndFatalAlert((__int64)v4, 1207, -2146892986, 0x28u);
        result = 2148074310i64;
        *((_DWORD *)v4 + 17) = 96;
        *((_WORD *)v4 + 48) = 10242;
        return result;
      }
      v42 = 52i64;
    }
    else
    {
      v41 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        goto LABEL_73;
      v42 = 51i64;
    }
    WPP_SF_(*((_QWORD *)v41 + 2), v42, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
    goto LABEL_73;
  }
LABEL_14:
  CSessionCacheManager::AcquireCacheTableLock(v15, *(const unsigned __int16 **)(*((_QWORD *)v4 + 165) + 368i64), 0i64);
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)v4 + 165) + 72i64), 1u);
  v24 = (struct CSessionCacheClientItem *)*((_QWORD *)v4 + 165);
  if ( *((unsigned __int16 *)v24 + 119) <= 0x20u )
  {
    v5 = *((unsigned __int16 *)v24 + 119);
    memcpy_0(Buf1, (char *)v24 + 240, *((unsigned __int16 *)v24 + 119));
  }
  if ( !*((_QWORD *)v24 + 2) )
  {
LABEL_17:
    *((_DWORD *)v24 + 42) = *((_DWORD *)v4 + 16);
    if ( (_DWORD)v8 )
    {
      v25 = *((_QWORD *)v4 + 165);
      *(_WORD *)(v25 + 238) = v8;
      if ( v9 )
        memcpy_0((void *)(v25 + 240), v9, v8);
    }
    v26 = 0;
    goto LABEL_21;
  }
  if ( v5 && v5 == (_DWORD)v8 && !memcmp_0(Buf1, v9, v8) )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 53i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
    v35 = *((_QWORD *)v4 + 15);
    v26 = 1;
    if ( v35 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    {
      *(_WORD *)(v35 + 64) |= 1u;
      *(_DWORD *)(v35 + 24) = 1;
    }
  }
  else
  {
    v33 = *((_QWORD *)v4 + 17);
    if ( (v33 & 0xC00000) == 0 )
    {
      v36 = CSessionCacheManager::m_pSessionCacheManager;
      *((_BYTE *)v24 + 236) = 0;
      v23 = CSessionCacheClientItem::CloneCacheElement(*((CSessionCacheClientItem **)v4 + 165), v36, &v44);
      RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 165) + 72i64));
      if ( v23 )
      {
        CSessionCacheManager::ReleaseCacheTableLock(
          v37,
          *(const unsigned __int16 **)(*((_QWORD *)v4 + 165) + 368i64),
          0i64);
        return v23;
      }
      v24 = v44;
      RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)v44 + 72), 1u);
      *((_QWORD *)v4 + 165) = v24;
      *((_QWORD *)v4 + 11) = v24;
      goto LABEL_17;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 54i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
      v33 = *((_QWORD *)v4 + 17);
    }
    *((_QWORD *)v4 + 17) = v33 | 0x1000000;
    v26 = 1;
    if ( (_DWORD)v8 )
    {
      *((_WORD *)v4 + 490) = v8;
      if ( v9 )
        memcpy_0((char *)v4 + 982, v9, v8);
    }
    v34 = *((_QWORD *)v4 + 15);
    if ( v34 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    {
      *(_DWORD *)(v34 + 24) = 1;
      *(_WORD *)(v34 + 64) |= 2u;
    }
  }
LABEL_21:
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 165) + 72i64));
  CSessionCacheManager::ReleaseCacheTableLock(v27, *(const unsigned __int16 **)(*((_QWORD *)v4 + 165) + 368i64), 0i64);
  v23 = CCipherMill::SetServerHelloCipher(v28, v4, v43);
  if ( v23 )
  {
    v39 = 40;
    v38 = 107;
    this = v4;
LABEL_81:
    CSslContext::SetErrorAndFatalAlert((__int64)this, v38, v23, v39);
    return v23;
  }
  LOBYTE(v29) = (*((_DWORD *)v4 + 16) & 0x80800) != 0;
  result = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, __int64))(*(_QWORD *)v4 + 496i64))(v4, v29);
  if ( (_DWORD)result )
    return result;
  *((_BYTE *)v4 + 340) = 0;
  LOBYTE(v31) = 1;
  v23 = (*(__int64 (__fastcall **)(CSsl3TlsClientContext *, _QWORD, _QWORD, __int64))(*(_QWORD *)v4 + 504i64))(
          v4,
          *((_QWORD *)v4 + 110),
          *((unsigned int *)v4 + 218),
          v31);
  if ( *((_QWORD *)v4 + 110) )
  {
    (*(void (__fastcall **)(CSsl3TlsClientContext *))(*(_QWORD *)v4 + 16i64))(v4);
    *((_QWORD *)v4 + 110) = 0i64;
  }
  v32 = v45;
  *((_DWORD *)v4 + 218) = 0;
  *v32 = v26;
  return v23;
}
// 180005F4A: conditional instruction was optimized away because rsi.8!=0
// 180005BF4: variable 'v13' is possibly undefined
// 180005C1D: variable 'v17' is possibly undefined
// 180005C26: variable 'v16' is possibly undefined
// 180005C2F: variable 'v18' is possibly undefined
// 180005CC6: variable 'v15' is possibly undefined
// 180005D7F: variable 'v27' is possibly undefined
// 180005D8B: variable 'v28' is possibly undefined
// 180005DBB: variable 'v29' is possibly undefined
// 180005DF3: variable 'v31' is possibly undefined
// 18002DD70: variable 'v37' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18007D048: using guessed type void *CTlsExtClient::`vftable';
// 1800919A8: using guessed type int g_fAllowInsecureRenegoServers;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180005FC4) ----------------------------------------------------
__int64 __fastcall ConvertSslVersionToSchannelProtocol(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v7; // ecx
  int v8; // ecx

  v1 = a1 - 2;
  if ( !v1 )
    return 12i64;
  v2 = v1 - 766;
  if ( !v2 )
    return 48i64;
  v3 = v2 - 1;
  if ( !v3 )
    return 192i64;
  v4 = v3 - 1;
  if ( !v4 )
    return 768i64;
  v5 = v4 - 1;
  if ( !v5 )
    return 3072i64;
  v7 = v5 - 1;
  if ( !v7 )
    return 12288i64;
  v8 = v7 - 64505;
  if ( !v8 )
    return 786432i64;
  if ( v8 == 2 )
    return 196608i64;
  return 0i64;
}

//----- (0000000180006034) ----------------------------------------------------
bool __fastcall CSessionCacheTable::LookupCacheByName(
        CSessionCacheTable *this,
        unsigned int a2,
        const unsigned __int16 *a3,
        struct CCredentialGroup *a4,
        struct CSessionCacheItem **a5)
{
  __int64 v6; // r13
  _QWORD *v8; // rdi
  int v9; // r15d
  __int64 v10; // r13
  _QWORD **v11; // rcx
  _QWORD *v12; // r14
  _QWORD *v14; // rsi
  struct CCredentialGroup *v15; // rbx
  CSessionCacheTable *v16; // rcx
  __int64 v17; // rcx
  _QWORD *v18; // rdx
  __int64 v19; // [rsp+30h] [rbp-58h] BYREF
  PRTL_RESOURCE Resource; // [rsp+38h] [rbp-50h]
  __int64 v21; // [rsp+90h] [rbp+8h] BYREF
  unsigned int TickCount; // [rsp+98h] [rbp+10h]
  const unsigned __int16 *v23; // [rsp+A0h] [rbp+18h]
  struct CCredentialGroup *v24; // [rsp+A8h] [rbp+20h]

  v24 = a4;
  v23 = a3;
  v6 = a2;
  v8 = 0i64;
  v9 = 0;
  TickCount = GetTickCount();
  v19 = *(_QWORD *)((char *)a4 + 740);
  Resource = (PRTL_RESOURCE)((char *)this + 48);
  RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)this + 48), 1u);
  v10 = 16 * v6;
  v11 = (_QWORD **)(v10 + *(_QWORD *)this);
  v12 = *v11;
  if ( *v11 == v11 )
    goto LABEL_2;
  do
  {
    v14 = v12 - 36;
    v12 = (_QWORD *)*v12;
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(v14 + 9), 1u);
    if ( *((_BYTE *)v14 + 236) )
    {
      if ( !HasTimeElapsed(*((_DWORD *)v14 + 69), TickCount, *((_DWORD *)v14 + 70)) )
      {
        v15 = v24;
        v21 = *((_QWORD *)v24 + 95);
        if ( (*(unsigned __int8 (__fastcall **)(_QWORD *, __int64 *, const unsigned __int16 *, __int64 *, _DWORD))(*v14 + 80i64))(
               v14,
               &v19,
               v23,
               &v21,
               *((_DWORD *)v24 + 38)) )
        {
          if ( CSessionCacheItem::DoesAppAllowCipher((CSessionCacheItem *)v14, v15) )
          {
            if ( !v8 )
            {
              v9 = CSessionCacheTable::ReferenceCacheItemInternal(v16, (struct CSessionCacheItem *)v14);
LABEL_9:
              v8 = v14;
              goto LABEL_10;
            }
            if ( *((_DWORD *)v14 + 69) > *((_DWORD *)v8 + 69) )
            {
              v9 = CSessionCacheTable::ReferenceCacheItemInternal(v16, (struct CSessionCacheItem *)v14);
              RtlAcquireResourceExclusive((PRTL_RESOURCE)(v8 + 9), 1u);
              *((_BYTE *)v8 + 236) = 0;
              CSessionCacheTable::DereferenceCacheItemInternal(this, (struct CSessionCacheItem *)v8, 0, 0);
              RtlReleaseResource((PRTL_RESOURCE)(v8 + 9));
              goto LABEL_9;
            }
            *((_BYTE *)v14 + 236) = 0;
          }
        }
      }
    }
LABEL_10:
    RtlReleaseResource((PRTL_RESOURCE)(v14 + 9));
  }
  while ( v12 != (_QWORD *)(v10 + *(_QWORD *)this) );
  if ( v8 )
  {
    *a5 = (struct CSessionCacheItem *)v8;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xBu, (__int64)&WPP_54aae497645f38b3b161e68e12f6f932_Traceguids, v8);
    if ( v9 == 2 )
    {
      v17 = v8[40];
      if ( *(_QWORD **)(v17 + 8) != v8 + 40 || (v18 = (_QWORD *)v8[41], (_QWORD *)*v18 != v8 + 40) )
        __fastfail(3u);
      *v18 = v17;
      *(_QWORD *)(v17 + 8) = v18;
    }
    LsaIModifyPerformanceCounter(7i64);
  }
LABEL_2:
  RtlReleaseResource(Resource);
  return v8 != 0i64;
}
// 18000618D: variable 'v16' is possibly undefined
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);

//----- (000000018000629C) ----------------------------------------------------
__int64 __fastcall CSessionCacheManager::AcquireCacheTableLock(
        __int64 a1,
        const unsigned __int16 *a2,
        unsigned __int8 *const a3)
{
  CSessionCacheManager *v3; // rbx
  unsigned int v4; // eax
  __int64 v5; // rcx

  v3 = CSessionCacheManager::m_pSessionCacheManager;
  v4 = 0;
  if ( !CSessionCacheManager::m_pSessionCacheManager )
    return 0i64;
  if ( a2 )
  {
    v4 = CSessionCacheManager::ComputeClientCacheIndex(CSessionCacheManager::m_pSessionCacheManager, a2);
  }
  else if ( a3 )
  {
    v4 = *(_DWORD *)a3 % *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 4);
  }
  v5 = *((_QWORD *)v3 + 5) + 152i64 * (v4 / *((_DWORD *)v3 + 13));
  if ( !v5 )
    return 0i64;
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(v5 + 48), 1u);
  return 1i64;
}

//----- (0000000180006300) ----------------------------------------------------
void __fastcall CSessionCacheManager::ReleaseCacheTableLock(
        __int64 a1,
        const unsigned __int16 *a2,
        unsigned __int8 *const a3)
{
  CSessionCacheManager *v3; // rbx
  unsigned int v4; // eax
  __int64 v5; // rcx

  v3 = CSessionCacheManager::m_pSessionCacheManager;
  v4 = 0;
  if ( CSessionCacheManager::m_pSessionCacheManager )
  {
    if ( a2 )
    {
      v4 = CSessionCacheManager::ComputeClientCacheIndex(CSessionCacheManager::m_pSessionCacheManager, a2);
    }
    else if ( a3 )
    {
      v4 = *(_DWORD *)a3 % *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 4);
    }
    v5 = *((_QWORD *)v3 + 5) + 152i64 * (v4 / *((_DWORD *)v3 + 13));
    if ( v5 )
      RtlReleaseResource((PRTL_RESOURCE)(v5 + 48));
  }
}

//----- (0000000180006358) ----------------------------------------------------
__int64 __fastcall CSessionCacheManager::ComputeClientCacheIndex(
        CSessionCacheManager *this,
        const unsigned __int16 *a2)
{
  unsigned int v4; // edx
  __int64 v5; // rax
  __int64 v6; // r10
  __int64 v7; // r8
  unsigned __int64 v8; // r11
  __int64 v9; // rcx
  __int64 v10; // rax
  int v12; // r10d
  int v13; // r10d
  int v14; // r10d
  int v15; // r10d
  int v16; // r10d
  int v17; // r10d

  v4 = 0;
  if ( a2 )
  {
    v5 = -1i64;
    do
      ++v5;
    while ( a2[v5] );
    v6 = (unsigned int)(2 * v5);
    v7 = 314159i64;
    if ( (unsigned __int64)v6 >= 8 )
    {
      v8 = (unsigned __int64)(unsigned int)v6 >> 3;
      v6 -= 8 * v8;
      do
      {
        v9 = *((unsigned __int8 *)a2 + 6)
           + 37
           * (*((unsigned __int8 *)a2 + 5)
            + 37
            * (*((unsigned __int8 *)a2 + 4)
             + 37
             * (*((unsigned __int8 *)a2 + 3)
              + 37
              * (*((unsigned __int8 *)a2 + 2)
               + 37 * (*((unsigned __int8 *)a2 + 1) + 37 * (*(unsigned __int8 *)a2 + 37 * v7))))));
        v10 = *((unsigned __int8 *)a2 + 7);
        a2 += 4;
        v7 = v10 + 37 * v9;
        --v8;
      }
      while ( v8 );
    }
    if ( v6 < 1 || v6 > 7 )
      return (unsigned int)v7 % *((_DWORD *)this + 4);
    v12 = v6 - 1;
    if ( v12 )
    {
      v13 = v12 - 1;
      if ( v13 )
      {
        v14 = v13 - 1;
        if ( v14 )
        {
          v15 = v14 - 1;
          if ( v15 )
          {
            v16 = v15 - 1;
            if ( v16 )
            {
              v17 = v16 - 1;
              if ( v17 )
              {
                if ( v17 != 1 )
                  return (unsigned int)v7 % *((_DWORD *)this + 4);
                LODWORD(v7) = *(unsigned __int8 *)a2 + 37 * v7;
                a2 = (const unsigned __int16 *)((char *)a2 + 1);
              }
              LODWORD(v7) = *(unsigned __int8 *)a2 + 37 * v7;
              a2 = (const unsigned __int16 *)((char *)a2 + 1);
            }
            LODWORD(v7) = *(unsigned __int8 *)a2 + 37 * v7;
            a2 = (const unsigned __int16 *)((char *)a2 + 1);
          }
          LODWORD(v7) = *(unsigned __int8 *)a2 + 37 * v7;
          a2 = (const unsigned __int16 *)((char *)a2 + 1);
        }
        LODWORD(v7) = *(unsigned __int8 *)a2 + 37 * v7;
        a2 = (const unsigned __int16 *)((char *)a2 + 1);
      }
      LODWORD(v7) = *(unsigned __int8 *)a2 + 37 * v7;
      a2 = (const unsigned __int16 *)((char *)a2 + 1);
    }
    LODWORD(v7) = *(unsigned __int8 *)a2 + 37 * v7;
    return (unsigned int)v7 % *((_DWORD *)this + 4);
  }
  return v4;
}

//----- (0000000180006430) ----------------------------------------------------
__int64 __fastcall CTlsExt::ParseTlsExtensions(__int64 a1, unsigned __int8 *a2, unsigned int a3, int a4)
{
  __int64 v4; // rax
  char v5; // bp
  unsigned int v6; // ebx
  unsigned __int8 *v7; // rdi
  char v9; // r12
  CCipherMill *v10; // rcx
  unsigned __int16 v11; // r15
  unsigned int v12; // r14d
  unsigned __int8 *v13; // rdi
  unsigned int v14; // ebx
  unsigned __int8 *v15; // r8
  __int64 result; // rax

  v4 = *(_QWORD *)(a1 + 8);
  v5 = 0;
  v6 = a3;
  v7 = a2;
  v9 = *(_BYTE *)(v4 + 64) & 0x30;
  *(_DWORD *)(a1 + 16) = a4;
  *(_BYTE *)(v4 + 922) = 0;
  *(_BYTE *)(a1 + 27) = 0;
  if ( a3 )
  {
    v10 = WPP_GLOBAL_Control;
    while ( v6 >= 4 )
    {
      v11 = _byteswap_ushort(*((_WORD *)v7 + 1));
      v12 = v7[1] | (*v7 << 8);
      if ( v10 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v10 + 28) & 4) != 0 )
      {
        WPP_SF_D(*((_QWORD *)v10 + 2), 73i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids, v12);
        v10 = WPP_GLOBAL_Control;
      }
      v13 = v7 + 4;
      a2 = (unsigned __int8 *)v11;
      v14 = v6 - 4;
      if ( v14 < v11 )
      {
        if ( v10 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v10 + 28) & 2) != 0 )
          WPP_SF_(*((_QWORD *)v10 + 2), 74i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
        return 2148074278i64;
      }
      v15 = v13;
      v7 = &v13[v11];
      v6 = v14 - v11;
      if ( !v9 || v12 == 65281 )
      {
        result = (*(__int64 (__fastcall **)(__int64, _QWORD, unsigned __int8 *, _QWORD))(*(_QWORD *)a1 + 8i64))(
                   a1,
                   v12,
                   v15,
                   v11);
        if ( (_DWORD)result )
          return result;
        v10 = WPP_GLOBAL_Control;
        if ( v12 == 65281 )
          v5 = 1;
      }
      if ( !v6 )
        goto LABEL_13;
    }
    return 2148074278i64;
  }
  else
  {
LABEL_13:
    LOBYTE(a2) = v5;
    (*(void (__fastcall **)(_QWORD, unsigned __int8 *))(**(_QWORD **)(a1 + 8) + 352i64))(*(_QWORD *)(a1 + 8), a2);
    return 0i64;
  }
}
// 18000654D: variable 'a2' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000657C) ----------------------------------------------------
__int64 __fastcall UpdateServerCertificateSerialChainProperty(struct CSsl3TlsClientContext *a1, unsigned int a2)
{
  __int64 v4; // rdx
  __int64 v6; // [rsp+30h] [rbp+8h] BYREF

  v6 = 0i64;
  (*(void (__fastcall **)(struct CSsl3TlsClientContext *, __int64 *))(*(_QWORD *)a1 + 224i64))(a1, &v6);
  v4 = *(unsigned int *)(v6 + 360);
  if ( (_DWORD)v4 )
    I_CertFinishSslHandshake(
      *(_QWORD *)(v6 + 352),
      v4,
      *((unsigned __int8 *)a1 + 307) | ((*((unsigned __int8 *)a1 + 306) | ((*((unsigned __int8 *)a1 + 305) | (*((unsigned __int8 *)a1 + 304) << 8)) << 8)) << 8),
      a2);
  return 0i64;
}
// 180098188: using guessed type __int64 __fastcall I_CertFinishSslHandshake(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180006620) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::DigestFinish(CSsl3TlsContext *this, unsigned __int8 *Src, int a3)
{
  int v3; // r14d
  unsigned int v4; // esi
  int v7; // r14d
  __int64 v8; // rdi
  __int64 *v9; // rax
  unsigned int v10; // r15d
  CCipherMill *v11; // rdi
  char Buf1[40]; // [rsp+30h] [rbp-68h] BYREF

  v3 = *((_DWORD *)this + 16);
  v4 = 36;
  if ( (v3 & 0xF3FC0) != 0 )
    v4 = 12;
  if ( a3 == v4 )
  {
    v7 = v3 & 0xA2AA0;
    v8 = 0i64;
    RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
    v9 = (__int64 *)*((_QWORD *)this + 1);
    if ( v9 )
      v8 = *v9;
    v10 = SslComputeFinishedHash(
            v8,
            *(_QWORD *)(*((_QWORD *)this + 11) + 16i64),
            *((_QWORD *)this + 74),
            Buf1,
            v4,
            (unsigned int)(v7 != 0) + 1);
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
    if ( v10 )
    {
      CSslContext::SetErrorAndFatalAlert((__int64)this, 902, v10, 0x33u);
      return v10;
    }
    else
    {
      v11 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 61i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        v11 = WPP_GLOBAL_Control;
      }
      if ( !memcmp_0(Buf1, Src, v4) )
      {
        if ( v7 )
        {
          if ( v11 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)v11 + 7) & 0x800) != 0 )
            WPP_SF_(*((_QWORD *)v11 + 2), 63i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          memcpy_0((char *)this + 420, Src, v4);
          *((_DWORD *)this + 114) = v4;
        }
        else
        {
          if ( v11 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)v11 + 7) & 0x800) != 0 )
            WPP_SF_(*((_QWORD *)v11 + 2), 64i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          memcpy_0((char *)this + 377, Src, v4);
          *((_DWORD *)this + 104) = v4;
        }
        if ( !*((_BYTE *)this + 340) )
        {
          memcpy_0((char *)this + 341, Buf1, v4);
          *((_BYTE *)this + 340) = 1;
          CSsl3TlsContext::SetTokenBindingEKM(this);
        }
        if ( *((_BYTE *)this + 233) )
        {
          if ( (*((_DWORD *)this + 16) & 0xA0000) != 0 )
            CSsl3TlsContext::FreeSavedWriteCipherState(this);
        }
        return 0i64;
      }
      else
      {
        if ( v11 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v11 + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)v11 + 2), 62i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        CSslContext::SetErrorAndFatalAlert((__int64)this, 900, -2146893048, 0x33u);
        return 2148074248i64;
      }
    }
  }
  else
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 903, -2146893048, 0x32u);
    return 2148074248i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180098538: using guessed type __int64 __fastcall SslComputeFinishedHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180006808) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetTokenBindingEKM(CSsl3TlsContext *this)
{
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rdi
  void *v6; // rbp
  __int64 *v7; // rax
  __int64 v8; // rcx
  unsigned int v9; // esi
  __int64 v10; // rax
  void *v11; // rdi

  if ( !*((_QWORD *)this + 103) )
    return 6i64;
  v3 = *((_QWORD *)this + 11);
  if ( !v3 )
    return 1359i64;
  RtlAcquireResourceShared((PRTL_RESOURCE)(v3 + 72), 1u);
  v4 = *((_QWORD *)this + 11);
  v5 = *(_QWORD *)(v4 + 16);
  if ( !v5 )
  {
    RtlReleaseResource((PRTL_RESOURCE)(v4 + 72));
    return 6i64;
  }
  v6 = (void *)(*(__int64 (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 8i64))(this, 32i64);
  if ( !v6 )
  {
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
    return 14i64;
  }
  v7 = (__int64 *)*((_QWORD *)this + 1);
  if ( v7 )
    v8 = *v7;
  else
    v8 = 0i64;
  v9 = SslExportKeyingMaterial(v8, v5, "EXPORTER-Token-Binding", (char *)this + 272, 64, 0i64, 0, v6, 32, 0);
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
  if ( v9 )
    goto LABEL_16;
  v10 = *((_QWORD *)this + 104);
  if ( v10 )
  {
    v11 = *(void **)(v10 + 8);
    if ( v11 )
    {
      memset(v11, 0, 0x20ui64);
      (*(void (__fastcall **)(CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 16i64))(
        this,
        *(_QWORD *)(*((_QWORD *)this + 104) + 8i64));
      v10 = *((_QWORD *)this + 104);
    }
    goto LABEL_20;
  }
  v10 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 8i64))(this, 16i64);
  *((_QWORD *)this + 104) = v10;
  if ( v10 )
  {
LABEL_20:
    *(_DWORD *)v10 = 32;
    *(_QWORD *)(*((_QWORD *)this + 104) + 8i64) = v6;
    return v9;
  }
  v9 = 14;
LABEL_16:
  memset(v6, 0, 0x20ui64);
  (*(void (__fastcall **)(CSsl3TlsContext *, void *))(*(_QWORD *)this + 16i64))(this, v6);
  return v9;
}
// 180098560: using guessed type __int64 __fastcall SslExportKeyingMaterial(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD, _QWORD, _DWORD, _DWORD);

//----- (000000018000685C) ----------------------------------------------------
__int64 __fastcall CSessionCacheManager::CacheRetrieveNewItem(
        CSessionCacheManager *this,
        char a2,
        const unsigned __int16 *a3,
        unsigned __int8 *const a4,
        struct CSessionCacheItem **a5)
{
  __int64 v7; // rbx
  unsigned int v8; // ebx
  wchar_t *v9; // rax
  unsigned __int16 *v10; // rdi
  unsigned int v11; // r14d
  CSessionCacheClientItem *v12; // rax
  CSessionCacheClientItem *v13; // rdi
  unsigned int v14; // ebx
  unsigned int v15; // ebx
  CSessionCacheTable *v16; // rcx
  _QWORD *v17; // rbp
  __int64 *v18; // r8
  __int64 v19; // rcx
  __int64 **v20; // rax
  _QWORD *v21; // rdi
  _QWORD *v22; // rcx
  __int128 v24; // xmm0
  unsigned int v25; // eax
  int v26; // edx
  unsigned int v27; // ecx
  CSessionCacheItem *v28; // rax
  unsigned __int8 v29[16]; // [rsp+20h] [rbp-38h] BYREF
  __int128 v30; // [rsp+30h] [rbp-28h]

  if ( !a2 )
  {
    v7 = -1i64;
    do
      ++v7;
    while ( a3[v7] );
    v8 = v7 + 1;
    v9 = (wchar_t *)SPExternalAlloc(2 * v8);
    v10 = v9;
    if ( !v9 )
      return 14i64;
    wcscpy_s(v9, v8, a3);
    v11 = CSessionCacheManager::ComputeClientCacheIndex(this, v10);
    v12 = (CSessionCacheClientItem *)SPExternalAlloc(0x1B8u);
    if ( !v12 )
      return 14i64;
    v13 = CSessionCacheClientItem::CSessionCacheClientItem(v12, this, *((_DWORD *)this + 5), v10);
LABEL_7:
    if ( v13 )
      goto LABEL_8;
    return 14i64;
  }
  v24 = *((_OWORD *)a4 + 1);
  v25 = _mm_cvtsi128_si32(*(__m128i *)a4);
  *(_OWORD *)v29 = *(_OWORD *)a4;
  v26 = v25 % *((_DWORD *)this + 4);
  v27 = *(_DWORD *)&v29[4];
  v11 = v26;
  *(_DWORD *)v29 = v26;
  if ( g_SslMachineID != -1 )
    v27 = g_SslMachineID;
  *(_DWORD *)&v29[4] = v27;
  v30 = v24;
  v28 = (CSessionCacheItem *)(*(__int64 (__fastcall **)(struct IAllocate *, __int64))(*(_QWORD *)CSessionCacheServerItem::m_pServerCacheLookaside
                                                                                    + 24i64))(
                               CSessionCacheServerItem::m_pServerCacheLookaside,
                               360i64);
  v13 = v28;
  if ( !v28 )
  {
    v13 = 0i64;
    goto LABEL_7;
  }
  CSessionCacheItem::CSessionCacheItem(v28, *((_DWORD *)this + 6), v29);
  *((_QWORD *)v13 + 42) = 0i64;
  *(_QWORD *)v13 = &CSessionCacheServerItem::`vftable';
  *((_QWORD *)v13 + 43) = 0i64;
  *((_DWORD *)v13 + 88) = 0;
  *((_DWORD *)v13 + 54) = -2146893019;
LABEL_8:
  v14 = *((_DWORD *)v13 + 17);
  if ( v14 )
  {
    (*(void (__fastcall **)(CSessionCacheClientItem *, __int64))(*(_QWORD *)v13 + 8i64))(v13, 1i64);
    return v14;
  }
  else
  {
    v15 = *((_DWORD *)this + 13);
    *a5 = v13;
    v16 = (CSessionCacheTable *)(v11 / v15);
    v17 = (_QWORD *)(*((_QWORD *)this + 5) + 152i64 * (_QWORD)v16);
    CSessionCacheTable::ReferenceCacheItemInternal(v16, v13);
    *((_QWORD *)v13 + 28) = v17;
    v18 = (__int64 *)((char *)v13 + 288);
    v19 = *v17 + 16i64 * (v11 % v15);
    v20 = *(__int64 ***)(v19 + 8);
    if ( *v20 != (__int64 *)v19
      || (*((_QWORD *)v13 + 37) = v20,
          v21 = (_QWORD *)((char *)v13 + 304),
          *v18 = v19,
          *v20 = v18,
          *(_QWORD *)(v19 + 8) = v18,
          v22 = (_QWORD *)v17[3],
          (_QWORD *)*v22 != v17 + 2) )
    {
      __fastfail(3u);
    }
    *v21 = v17 + 2;
    v21[1] = v22;
    *v22 = v21;
    v17[3] = v21;
    _InterlockedIncrement((volatile signed __int32 *)this + 8);
    LsaIModifyPerformanceCounter(4i64);
    return 0i64;
  }
}
// 18007C330: using guessed type void *CSessionCacheServerItem::`vftable';
// 1800919F4: using guessed type unsigned int g_SslMachineID;
// 1800927F8: using guessed type struct IAllocate *CSessionCacheServerItem::m_pServerCacheLookaside;
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);

//----- (00000001800069C4) ----------------------------------------------------
__int64 __fastcall CSessionCacheTable::ReferenceCacheItemInternal(
        CSessionCacheTable *this,
        struct CSessionCacheItem *a2)
{
  unsigned __int32 v2; // ebx

  v2 = _InterlockedIncrement((volatile signed __int32 *)a2 + 58);
  if ( v2 == 2 )
    LsaIModifyPerformanceCounter(5i64);
  return v2;
}
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);

//----- (0000000180006A04) ----------------------------------------------------
CSessionCacheClientItem *__fastcall CSessionCacheClientItem::CSessionCacheClientItem(
        CSessionCacheClientItem *this,
        struct CSessionCacheManager *a2,
        int a3,
        unsigned __int16 *a4)
{
  CSessionCacheItem::CSessionCacheItem(this, a3, 0i64);
  *((_QWORD *)this + 46) = a4;
  *(_QWORD *)this = &CSessionCacheClientItem::`vftable';
  *((_QWORD *)this + 49) = a2;
  *((_QWORD *)this + 42) = 0i64;
  *((_DWORD *)this + 86) = 0;
  *((_QWORD *)this + 44) = 0i64;
  *((_DWORD *)this + 90) = 0;
  *((_QWORD *)this + 48) = 0i64;
  *((_QWORD *)this + 50) = 0i64;
  *((_QWORD *)this + 51) = 0i64;
  *((_DWORD *)this + 104) = 0;
  *((_QWORD *)this + 53) = 0i64;
  *((_DWORD *)this + 108) = 0;
  SslGetClientLogonId((struct _LUID *)this + 47);
  return this;
}
// 18007C210: using guessed type void *CSessionCacheClientItem::`vftable';

//----- (0000000180006AAC) ----------------------------------------------------
ULONG __fastcall SslGetClientLogonId(struct _LUID *a1)
{
  NTSTATUS v2; // eax
  struct _LUID v4; // [rsp+20h] [rbp-28h] BYREF

  *a1 = 0i64;
  v2 = (*(__int64 (__fastcall **)(struct _LUID *))(LsaTable + 128))(&v4);
  if ( v2 >= 0 )
    *a1 = v4;
  return RtlNtStatusToDosError(v2);
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180006B10) ----------------------------------------------------
CSchannelTelemetryContext *__fastcall CSchannelTelemetryContext::`vector deleting destructor'(
        CSchannelTelemetryContext *this,
        char a2)
{
  *(_QWORD *)this = &IAllocate::`vftable';
  if ( (a2 & 1) != 0 )
  {
    if ( LsaTable )
      (*(void (**)(void))(LsaTable + 48))();
    else
      LocalFree(this);
  }
  return this;
}
// 18007C298: using guessed type void *IAllocate::`vftable';
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180006B5C) ----------------------------------------------------
CSessionCacheItem *__fastcall CSessionCacheItem::CSessionCacheItem(
        CSessionCacheItem *this,
        int a2,
        unsigned __int8 *const a3)
{
  char v6; // al
  int v7; // ecx
  int v9[10]; // [rsp+20h] [rbp-28h] BYREF

  CSslBasicAllocator::CSslBasicAllocator(this);
  *(_QWORD *)this = &CSessionCacheItem::`vftable';
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = 0i64;
  *((_QWORD *)this + 3) = 0i64;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = 0i64;
  *((_QWORD *)this + 6) = 0i64;
  *((_QWORD *)this + 7) = 0i64;
  *((_DWORD *)this + 16) = 0;
  *((_DWORD *)this + 42) = 0;
  *((_QWORD *)this + 22) = 0i64;
  *((_DWORD *)this + 46) = 0;
  *((_QWORD *)this + 25) = 0i64;
  *((_BYTE *)this + 208) = 0;
  *((_DWORD *)this + 53) = 0;
  *((_DWORD *)this + 54) = -2146893042;
  *((_DWORD *)this + 55) = 0;
  *((_DWORD *)this + 58) = 1;
  *((_BYTE *)this + 236) = 0;
  *((_DWORD *)this + 69) = GetTickCount();
  *((_DWORD *)this + 70) = a2;
  if ( a3 )
  {
    *((_OWORD *)this + 15) = *(_OWORD *)a3;
    *((_OWORD *)this + 16) = *((_OWORD *)a3 + 1);
  }
  else
  {
    *((_OWORD *)this + 15) = 0i64;
    *((_OWORD *)this + 16) = 0i64;
  }
  if ( LsaTable )
  {
    v6 = (*(__int64 (__fastcall **)(int *))(LsaTable + 192))(v9);
    v7 = -1;
    if ( v6 )
      v7 = v9[0];
    *((_DWORD *)this + 68) = v7;
  }
  else
  {
    *((_DWORD *)this + 68) = GetCurrentProcessId();
  }
  *(_QWORD *)((char *)this + 188) = 0i64;
  RtlInitializeResource((PRTL_RESOURCE)((char *)this + 72));
  *((_DWORD *)this + 17) = 0;
  return this;
}
// 18007C2C0: using guessed type void *CSessionCacheItem::`vftable';
// 180092620: using guessed type __int64 LsaTable;
// 180006B5C: using guessed type int var_28[10];

//----- (0000000180006CCC) ----------------------------------------------------
char __fastcall CTlsSignatureSuiteList::AddBCryptSignatureSuites(
        CTlsSignatureSuiteList *this,
        const unsigned __int16 **const a2,
        unsigned int a3,
        char a4)
{
  char v4; // di
  __int64 i; // r15
  unsigned __int8 v9; // bl
  wchar_t **v10; // rsi
  int v11; // eax
  const wchar_t **v12; // rcx

  v4 = 0;
  if ( a3 )
  {
    for ( i = a3; i; --i )
    {
      v9 = 0;
      v10 = &off_18007C3A0;
      while ( v9 < 0xCu )
      {
        v11 = *((unsigned __int16 *)this + 17);
        if ( !_bittest(&v11, v9) )
          break;
        v4 = 1;
LABEL_9:
        v10 += 9;
        ++v9;
        if ( v10 - 2 >= (wchar_t **)&CSsl3TlsServerContext::`vftable' )
          goto LABEL_10;
      }
      v12 = (const wchar_t **)(v10 - 1);
      if ( !a4 )
        v12 = (const wchar_t **)v10;
      if ( wcsicmp(*v12, *a2) )
        goto LABEL_9;
      v4 |= CTlsSignatureSuiteList::AddSignatureSuite(this, v9);
      if ( !a4 )
        goto LABEL_9;
LABEL_10:
      ++a2;
    }
  }
  if ( a4 )
    CTlsSignatureSuiteList::SetRsaSignatureFlags();
  return v4;
}
// 18007C3A0: using guessed type wchar_t *off_18007C3A0;
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';

//----- (0000000180006DA4) ----------------------------------------------------
unsigned __int8 __fastcall CTlsSignatureSuiteList::AddSignatureSuite(CTlsSignatureSuiteList *this, unsigned __int8 a2)
{
  int v2; // eax
  __int16 v3; // ax

  if ( a2 < 0xCu )
  {
    v2 = *((unsigned __int16 *)this + 17);
    if ( _bittest(&v2, a2) )
      return 1;
    if ( *(_WORD *)this < 0x10u )
    {
      *((_WORD *)this + *(unsigned __int16 *)this + 1) = __ROR2__(*((_WORD *)&unk_18007C390 + 36 * a2), 8);
      v3 = *((_WORD *)this + 17);
      ++*(_WORD *)this;
      *((_WORD *)this + 17) = v3 | (1 << a2);
      return 1;
    }
  }
  return 0;
}

//----- (0000000180006E00) ----------------------------------------------------
__int64 __fastcall CTlsSignatureSuiteList::GetRunningHashList(
        CTlsSignatureSuiteList *this,
        const unsigned __int16 *a2,
        int a3,
        enum _eTlsHashAlgorithm *const a4,
        wchar_t **a5,
        unsigned int *a6)
{
  unsigned __int8 v6; // bl
  unsigned int v10; // ebp
  unsigned int v11; // r14d
  signed int v12; // edi
  unsigned int HashDetailsFromIndex; // eax
  wchar_t *v14; // rsi
  int v15; // eax
  char v16; // cl
  enum _eTlsHashAlgorithm *v17; // rdx
  unsigned __int16 v18; // r9
  __int64 v19; // r10
  int v20; // eax
  enum _eTlsHashAlgorithm v21; // r8d
  int v22; // eax
  __int64 v24; // rcx
  __int64 v25; // [rsp+20h] [rbp-48h]
  enum _eTlsHashAlgorithm v26; // [rsp+30h] [rbp-38h] BYREF
  wchar_t *String2; // [rsp+38h] [rbp-30h] BYREF

  v6 = 0;
  v26 = TlsHashAlgorithm_None;
  String2 = 0i64;
  v10 = -2146893007;
  v11 = 0;
  v12 = 4;
  if ( g_dwHashInfoTotalCount > 4 )
  {
    while ( 1 )
    {
      HashDetailsFromIndex = I_GetHashDetailsFromIndex(v12, &String2, 0i64, (__int64)a4, v25, &v26);
      v14 = String2;
      v10 = HashDetailsFromIndex;
      if ( !HashDetailsFromIndex && !wcsnicmp(a2, String2, 0x40ui64) )
        break;
      v15 = g_dwHashInfoTotalCount;
      if ( ++v12 >= g_dwHashInfoTotalCount )
        goto LABEL_5;
    }
    v15 = g_dwHashInfoTotalCount;
LABEL_5:
    if ( v12 < v15 && v14 )
    {
      v16 = v26;
      v17 = (enum _eTlsHashAlgorithm *)&unk_18007C3B8;
      v11 = 1;
      *a4 = v26;
      v10 = 0;
      v18 = 1 << v16;
      *a5 = v14;
      v19 = 12i64;
      do
      {
        if ( v6 < 0xCu )
        {
          v20 = *((unsigned __int16 *)this + 17);
          if ( _bittest(&v20, v6) )
          {
            if ( (a3 & *(v17 - 4)) != 0 )
            {
              v21 = *v17;
              v22 = v18;
              if ( !_bittest(&v22, *v17) )
              {
                v24 = v11;
                v18 |= 1 << v21;
                ++v11;
                a4[v24] = v21;
                a5[v24] = (wchar_t *)*((_QWORD *)v17 + 1);
              }
            }
          }
        }
        v17 += 18;
        ++v6;
        --v19;
      }
      while ( v19 );
    }
  }
  *a6 = v11;
  return v10;
}
// 180006E5D: variable 'a4' is possibly undefined
// 180006E5D: variable 'v25' is possibly undefined
// 180092324: using guessed type int g_dwHashInfoTotalCount;

//----- (0000000180006F5C) ----------------------------------------------------
__int64 __fastcall CTlsSignatureSuiteList::Blacklist(
        CTlsSignatureSuiteList *this,
        struct _TLS_PARAMETERS *a2,
        unsigned int a3)
{
  unsigned int v3; // ebx
  const wchar_t **v7; // r14
  unsigned __int8 v8; // di
  __int64 v9; // r12
  int v10; // eax

  v3 = 0;
  if ( !a2 || !a3 )
    return 0i64;
  *(_WORD *)this = 0;
  v7 = (const wchar_t **)&off_18007C3B0;
  v8 = 0;
  v9 = 12i64;
  do
  {
    if ( v8 < 0xCu )
    {
      v10 = *((unsigned __int16 *)this + 17);
      if ( _bittest(&v10, v8) )
      {
        *((_WORD *)this + 17) = v10 & ~(1 << v8);
        if ( !IsCngAlgorithmBlacklisted((unsigned __int64)a2, a3, 4, v7[2], 0i64, 0, 0i64, 1)
          && !IsCngAlgorithmBlacklisted((unsigned __int64)a2, a3, 4, *v7, 0i64, 0, 0i64, 1) )
        {
          CTlsSignatureSuiteList::AddSignatureSuite(this, v8);
        }
      }
    }
    v7 += 9;
    ++v8;
    --v9;
  }
  while ( v9 );
  if ( !*(_WORD *)this )
    return (unsigned int)-2146893007;
  return v3;
}
// 18007C3B0: using guessed type wchar_t *off_18007C3B0;

//----- (000000018000706C) ----------------------------------------------------
__int64 __fastcall CCipherMill::BuildCipherSuiteList(
        __int64 a1,
        unsigned int *a2,
        unsigned int a3,
        char a4,
        __int64 a5,
        unsigned int a6,
        __int64 a7,
        _DWORD *a8,
        _QWORD *a9,
        _WORD *a10)
{
  __int64 v11; // rbx
  __int64 v12; // r12
  unsigned int v13; // r13d
  struct _TLS_PARAMETERS *v14; // rdi
  unsigned int v15; // ebp
  _QWORD *v16; // r15
  HLOCAL v17; // rax
  CMasterCipherInfo *v18; // rax
  __int64 v19; // rsi
  __int64 v20; // rdi
  __int64 v21; // rcx
  __int64 v22; // r12
  unsigned int v23; // r15d
  __int64 v24; // rbp
  _WORD *v25; // rax
  unsigned int v26; // ecx
  __int64 v28; // r8
  unsigned int v29; // edx
  char v30; // [rsp+70h] [rbp-68h]
  int v31; // [rsp+74h] [rbp-64h]
  unsigned int v32; // [rsp+78h] [rbp-60h]
  struct _TLS_PARAMETERS *v33; // [rsp+80h] [rbp-58h]
  __int64 v34; // [rsp+88h] [rbp-50h]
  char v35; // [rsp+E0h] [rbp+8h]
  unsigned int v39; // [rsp+100h] [rbp+28h]

  v11 = 0i64;
  v12 = 0i64;
  v30 = 0;
  v13 = 0;
  v34 = 0i64;
  if ( !a5 )
    goto LABEL_57;
  v14 = *(struct _TLS_PARAMETERS **)(a5 + 200);
  v15 = *(_DWORD *)(a5 + 196);
  v33 = v14;
  v39 = v15;
  RtlAcquireResourceShared(&Resource, 1u);
  v16 = a9;
  if ( a9 )
  {
    v17 = SPExternalAlloc(2 * (unsigned int)(unsigned __int16)word_1800925D0);
    *a9 = v17;
    if ( !v17 )
    {
      v13 = 14;
      goto LABEL_46;
    }
  }
  if ( !v15 || (v35 = 1, !IsEcdsaAlgorithmBlacklisted(v14, v15, 0i64, 0, 0, 0i64, 1)) )
    v35 = 0;
  v18 = xmmword_1800925B0;
  if ( *(_BYTE *)(a5 + 172) )
    v18 = *(&xmmword_1800925B0 + 1);
  v19 = 0i64;
  if ( v18 )
  {
    v20 = *(_QWORD *)v18;
    v31 = 0;
    v32 = *((_DWORD *)v18 + 2);
    if ( v32 )
    {
      while ( (unsigned int)v11 < *a8 )
      {
        if ( CCipherMill::IsCipherSuiteAllowed(
               (__int64)g_cCipherMill,
               a2,
               a3,
               a4,
               (*(_DWORD *)(a5 + 156) >> 12) & 1,
               *(_DWORD *)(a5 + 156) & 0x800,
               *(_DWORD *)(a5 + 168),
               *(_DWORD *)(a5 + 164),
               a6,
               v20,
               0i64,
               (unsigned __int64)v33,
               v15,
               1) )
        {
          if ( !v16 || *(_DWORD *)(v20 + 48) != 3 && (*(_DWORD *)(v20 + 8) & 0x3000) == 0 || v12 == *(_QWORD *)v20 )
            goto LABEL_16;
          v22 = *(_QWORD *)(v20 + 848);
          if ( !v22 )
            goto LABEL_22;
          if ( !v30 )
          {
            v23 = 0;
            if ( *(_DWORD *)(v22 + 8) )
            {
              while ( 1 )
              {
                v24 = *(_QWORD *)v22 + 780i64 * v23;
                v25 = (_WORD *)*a9;
                if ( *a9 && (v26 = 0, (_DWORD)v19) )
                {
                  while ( (unsigned __int16)*(_DWORD *)(v24 + 772) != *v25 )
                  {
                    ++v26;
                    ++v25;
                    if ( v26 >= (unsigned int)v19 )
                      goto LABEL_35;
                  }
                }
                else
                {
LABEL_35:
                  if ( (unsigned int)v19 >= (unsigned __int16)word_1800925D0 )
                  {
                    v13 = 1359;
                    goto LABEL_46;
                  }
                  if ( !v39
                    || !IsEcdheAlgorithmBlacklisted(
                          v33,
                          v39,
                          (struct CEccCurveInfo *)(*(_QWORD *)v22 + 780i64 * v23),
                          0i64,
                          1u)
                    && (v35
                     || !IsEcdsaAlgorithmBlacklisted(
                           v33,
                           v39,
                           (const unsigned __int16 *)v24,
                           *(_DWORD *)(v24 + 772),
                           *(_DWORD *)(v24 + 768),
                           0i64,
                           1)) )
                  {
                    *(_WORD *)(*a9 + 2 * v19) = *(_WORD *)(v24 + 772);
                    v19 = (unsigned int)(v19 + 1);
                  }
                }
                if ( ++v23 >= *(_DWORD *)(v22 + 8) )
                {
                  v15 = v39;
                  break;
                }
              }
            }
            v16 = a9;
            v34 = *(_QWORD *)v20;
            v30 = 1;
LABEL_16:
            v21 = 0i64;
            if ( (_DWORD)v11 )
            {
              while ( *(_DWORD *)(v20 + 28) != *(_DWORD *)(a7 + 4 * v21) )
              {
                v21 = (unsigned int)(v21 + 1);
                if ( (unsigned int)v21 >= (unsigned int)v11 )
                  goto LABEL_19;
              }
            }
            else
            {
LABEL_19:
              if ( *(_DWORD *)(v20 + 48) != 3 && (*(_DWORD *)(v20 + 8) & 0x3000) == 0 || (_DWORD)v19 )
              {
                *(_DWORD *)(a7 + 4 * v11) = *(_DWORD *)(v20 + 28);
                v11 = (unsigned int)(v11 + 1);
              }
            }
            goto LABEL_22;
          }
          v28 = 0i64;
          if ( !(_DWORD)v19 )
            goto LABEL_16;
          while ( 1 )
          {
            v29 = 0;
            if ( !*(_DWORD *)(v22 + 8) )
              break;
            while ( *(unsigned __int16 *)(*v16 + 2 * v28) != *(_DWORD *)(780i64 * v29 + *(_QWORD *)v22 + 772) )
            {
              if ( ++v29 >= *(_DWORD *)(v22 + 8) )
                goto LABEL_22;
            }
            v28 = (unsigned int)(v28 + 1);
            if ( (unsigned int)v28 >= (unsigned int)v19 )
              goto LABEL_16;
          }
        }
LABEL_22:
        v20 += 864i64;
        if ( ++v31 >= v32 )
          break;
        v12 = v34;
      }
    }
  }
  *a8 = v11;
  if ( a10 )
    *a10 = v19;
LABEL_46:
  RtlReleaseResource(&Resource);
  if ( !(_DWORD)v11 )
  {
LABEL_57:
    v13 = -2146893007;
    LogCipherMismatchEvent(*(_DWORD *)(a5 + 212), (const unsigned __int16 *)(a5 + 216), a6);
  }
  return v13;
}
// 1800925D0: using guessed type __int16 word_1800925D0;
// 18000706C: using guessed type __int64 arg_20;

//----- (0000000180007410) ----------------------------------------------------
char __fastcall CCipherMill::IsCipherSuiteAllowed(
        __int64 a1,
        unsigned int *a2,
        unsigned int a3,
        char a4,
        int a5,
        int a6,
        unsigned int a7,
        unsigned int a8,
        int a9,
        __int64 a10,
        const UNICODE_STRING *a11,
        unsigned __int64 a12,
        unsigned int a13,
        char a14)
{
  const wchar_t *v17; // r13
  int v18; // r8d
  _DWORD *v19; // rax
  unsigned int v20; // ecx
  char *v21; // rax
  int v22; // edi
  _DWORD *v23; // rax
  unsigned int v24; // ecx
  _DWORD *v25; // rax
  int v26; // ebp
  _DWORD *v27; // rax
  unsigned int v28; // ecx
  _DWORD *v29; // rcx
  int v30; // esi
  _DWORD *v31; // rcx
  unsigned int v32; // eax
  _DWORD *v33; // rcx
  unsigned int v35; // eax
  CCipherMill *v36; // rcx
  unsigned int v37; // eax
  CCipherMill *v38; // rcx
  unsigned int v39; // eax
  unsigned int v40; // eax
  unsigned __int16 v41; // dx
  __int64 v42; // rcx
  unsigned __int16 v43; // dx
  bool v44; // bl
  int v45; // r8d
  int v46; // [rsp+20h] [rbp-48h]

  if ( !a10 )
  {
    v17 = L"<NULL>";
LABEL_46:
    v36 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v43 = 10;
    v46 = a9;
    goto LABEL_116;
  }
  v17 = (const wchar_t *)(a10 + 74);
  if ( (*(_DWORD *)(a10 + 8) & a9) == 0 )
    goto LABEL_46;
  if ( (*(_DWORD *)(a10 + 48) == 4) != a5 )
    return 0;
  if ( a6 )
  {
    v35 = *(_DWORD *)(a10 + 40);
    if ( v35 < 0x6604 || v35 >= 0x6801 )
    {
      v37 = v35 - 24576;
      if ( !v37 || (v39 = v37 - 1537) == 0 || (v40 = v39 - 2) == 0 || v40 == 510 )
      {
        v38 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          return 0;
        v41 = 11;
        goto LABEL_113;
      }
    }
    if ( *(_BYTE *)(a10 + 72) || *(_DWORD *)(a10 + 44) == 32771 )
      return 0;
  }
  if ( a8 )
  {
    if ( !a7 )
    {
LABEL_9:
      if ( *(_DWORD *)(a10 + 20) >= a8 )
        goto LABEL_10;
      v36 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
        return 0;
      v43 = 14;
      v46 = a8;
LABEL_116:
      v42 = *((_QWORD *)v36 + 2);
LABEL_117:
      WPP_SF_SD(v42, v43, (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids, v17, v46);
      return 0;
    }
  }
  else if ( !a7 )
  {
    if ( *(_DWORD *)(a10 + 40) != 24576 )
    {
      v38 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
        return 0;
      v41 = 12;
      goto LABEL_113;
    }
    goto LABEL_10;
  }
  if ( *(_DWORD *)(a10 + 20) > a7 )
  {
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v46 = a7;
    v43 = 13;
    v42 = *((_QWORD *)WPP_GLOBAL_Control + 2);
    goto LABEL_117;
  }
  if ( a8 )
    goto LABEL_9;
LABEL_10:
  v18 = *(_DWORD *)(a10 + 32);
  v19 = &g_AvailableExch;
  v20 = 0;
  while ( *v19 != v18 )
  {
    ++v20;
    v19 += 16;
    if ( v20 >= 4 )
      goto LABEL_16;
  }
  v21 = (char *)&g_AvailableExch + 64 * (unsigned __int64)v20;
  if ( v21 && (a9 & *((_DWORD *)v21 + 1)) == 0 )
  {
    v38 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v41 = 15;
    goto LABEL_113;
  }
LABEL_16:
  v22 = *(_DWORD *)(a10 + 44);
  v23 = &unk_180091028;
  v24 = 0;
  while ( *v23 != v22 )
  {
    ++v24;
    v23 += 10;
    if ( v24 >= 5 )
      goto LABEL_22;
  }
  v25 = (_DWORD *)((char *)&g_AvailableHashes + 40 * v24);
  if ( v25 && (a9 & *v25) == 0 )
  {
    v38 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v41 = 16;
    goto LABEL_113;
  }
LABEL_22:
  v26 = *(_DWORD *)(a10 + 40);
  v27 = &unk_180091100;
  v28 = 0;
  while ( *v27 != v26 )
  {
    ++v28;
    v27 += 14;
    if ( v28 >= 8 )
      goto LABEL_26;
  }
  v29 = (_DWORD *)((char *)&g_AvailableCiphers + 56 * v28);
  if ( v29 && (a9 & 0xF3FFFu & *v29) <= (a9 & 0xF3FFFu) >> 1 )
  {
    v36 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v43 = 17;
    v46 = a9 & 0xF3FFF;
    goto LABEL_116;
  }
LABEL_26:
  v30 = *(_DWORD *)(a10 + 36);
  v31 = &unk_1800913EC;
  v32 = 0;
  while ( *v31 != v30 )
  {
    ++v32;
    v31 += 8;
    if ( v32 >= 5 )
      goto LABEL_32;
  }
  v33 = (_DWORD *)((char *)&g_AvailableSigs + 32 * v32);
  if ( v33 && (a9 & *v33) == 0 )
  {
    v36 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v43 = 18;
    v46 = a9 & 0xF3FFF;
    goto LABEL_116;
  }
LABEL_32:
  if ( a3 )
  {
    v44 = (*(_DWORD *)(a10 + 8) & 0x3000) == 0;
    if ( (a4 & 4) == 0 || !v44 || DoesCredAllowAlgId(a2, a3, v18) )
    {
      if ( (a4 & 1) == 0 || !v44 || DoesCredAllowAlgId(a2, a3, v30) )
      {
        if ( (a4 & 8) == 0 || DoesCredAllowAlgId(a2, a3, v26) )
        {
          if ( (a4 & 2) == 0 || DoesCredAllowAlgId(a2, a3, v22) )
            return 1;
          v36 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          {
            return 0;
          }
          v43 = 22;
          v46 = v22;
        }
        else
        {
          v36 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          {
            return 0;
          }
          v43 = 21;
          v46 = v26;
        }
      }
      else
      {
        v36 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          return 0;
        v43 = 20;
        v46 = v30;
      }
    }
    else
    {
      v36 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
        return 0;
      v43 = 19;
      v46 = v45;
    }
    goto LABEL_116;
  }
  if ( !a13 )
    return 1;
  if ( IsCngAlgorithmBlacklisted(a12, a13, 0, (const wchar_t *)(a10 + 330), 0i64, 0, a11, a14) )
  {
    v38 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v41 = 23;
    goto LABEL_113;
  }
  if ( IsCngAlgorithmBlacklisted(a12, a13, 1, (const wchar_t *)(a10 + 458), 0i64, 0, a11, a14) )
  {
    v38 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v41 = 24;
    goto LABEL_113;
  }
  if ( IsCngAlgorithmBlacklisted(
         a12,
         a13,
         2,
         (const wchar_t *)(a10 + 202),
         (wchar_t *)(a10 + 714),
         *(_DWORD *)(a10 + 20),
         a11,
         a14) )
  {
    v38 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 0;
    v41 = 25;
    goto LABEL_113;
  }
  if ( !IsCngAlgorithmBlacklisted(a12, a13, 3, (const wchar_t *)(a10 + 586), 0i64, 0, a11, a14) )
    return 1;
  v38 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    v41 = 26;
LABEL_113:
    WPP_SF_S(
      *((_QWORD *)v38 + 2),
      v41,
      (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
      (const wchar_t *)(a10 + 74));
  }
  return 0;
}
// 18003384F: variable 'v45' is possibly undefined
// 1800856E0: using guessed type wchar_t aNull_1[7];

//----- (00000001800077A0) ----------------------------------------------------
char __fastcall IsCngAlgorithmBlacklisted(
        unsigned __int64 a1,
        unsigned int a2,
        int a3,
        const wchar_t *a4,
        wchar_t *a5,
        unsigned int a6,
        const UNICODE_STRING *String2,
        char a8)
{
  int v9; // r15d
  unsigned __int64 v10; // rdi
  __int64 v11; // rax
  unsigned __int64 v12; // rbp
  unsigned int v14; // esi
  unsigned __int64 v15; // rsi
  unsigned __int64 v16; // r8
  __int64 v17; // rax
  __int64 v18; // rax
  unsigned int v19; // eax
  unsigned int v20; // eax
  const wchar_t **v21; // r15
  unsigned __int64 v22; // r8
  __int64 v23; // rax
  __int64 v24; // rdx
  __int64 v25; // r8

  v9 = a3;
  v10 = a1;
  if ( !a2 )
    return 0;
  if ( !a1 )
    return 0;
  if ( !a4 )
    return 0;
  v11 = -1i64;
  do
    ++v11;
  while ( a4[v11] );
  if ( !v11 )
    return 0;
  v12 = a1 + 40i64 * a2;
  if ( a1 >= v12 )
    return 0;
  while ( 1 )
  {
    if ( *(_DWORD *)(v10 + 20) )
    {
      if ( !*(_DWORD *)v10 )
        goto LABEL_15;
      if ( String2 )
        break;
    }
LABEL_11:
    v10 += 40i64;
    if ( v10 >= v12 )
      return 0;
  }
  v14 = 0;
  while ( RtlCompareUnicodeString((PCUNICODE_STRING)(*(_QWORD *)(v10 + 8) + 16i64 * v14), String2, 1u) )
  {
    if ( ++v14 >= *(_DWORD *)v10 )
      goto LABEL_11;
  }
LABEL_15:
  if ( a8 && (*(_BYTE *)(v10 + 32) & 1) != 0 )
    goto LABEL_11;
  v15 = *(_QWORD *)(v10 + 24);
  if ( v15 >= v15 + 48i64 * *(unsigned int *)(v10 + 20) )
    goto LABEL_11;
  while ( 1 )
  {
    if ( *(_DWORD *)v15 != v9 )
      goto LABEL_19;
    v16 = *(unsigned __int16 *)(v15 + 8);
    v17 = -1i64;
    do
      ++v17;
    while ( a4[v17] );
    if ( 2 * v17 != v16 || wcsncmp(*(const wchar_t **)(v15 + 16), a4, v16 >> 1) )
      goto LABEL_19;
    v18 = *(unsigned int *)(v15 + 24);
    if ( !(_DWORD)v18 && !*(_DWORD *)(v15 + 40) && !*(_DWORD *)(v15 + 44) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_Sd(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xCu,
          (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
          a4,
          v9);
      return 1;
    }
    if ( !a5 )
      goto LABEL_28;
    v21 = *(const wchar_t ***)(v15 + 32);
    if ( v21 < &v21[2 * v18] )
      break;
LABEL_39:
    v9 = a3;
LABEL_28:
    if ( a6 )
    {
      v19 = *(_DWORD *)(v15 + 40);
      if ( !v19 )
      {
        if ( !*(_DWORD *)(v15 + 44) )
          goto LABEL_19;
        v20 = *(_DWORD *)(v15 + 44);
LABEL_49:
        if ( v20 < a6 )
        {
LABEL_50:
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_Sdd(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xEu,
              (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
              a4,
              a6,
              v9);
          }
          return 1;
        }
        goto LABEL_19;
      }
      if ( v19 > a6 )
        goto LABEL_50;
      v20 = *(_DWORD *)(v15 + 44);
      if ( v20 )
        goto LABEL_49;
    }
LABEL_19:
    v15 += 48i64;
    if ( v15 >= *(_QWORD *)(v10 + 24) + 48 * (unsigned __int64)*(unsigned int *)(v10 + 20) )
      goto LABEL_11;
  }
  while ( 1 )
  {
    v22 = *(unsigned __int16 *)v21;
    v23 = -1i64;
    do
      ++v23;
    while ( a5[v23] );
    if ( 2 * v23 == v22 && !wcsncmp(v21[1], a5, v22 >> 1) )
      break;
    v21 += 2;
    if ( (unsigned __int64)v21 >= *(_QWORD *)(v15 + 32) + 16 * (unsigned __int64)*(unsigned int *)(v15 + 24) )
      goto LABEL_39;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_SSd(*((_QWORD *)WPP_GLOBAL_Control + 2), v24, v25, a4, a5, a3);
  return 1;
}
// 180033AB9: variable 'v24' is possibly undefined
// 180033AB9: variable 'v25' is possibly undefined

//----- (00000001800079EC) ----------------------------------------------------
char __fastcall IsEcdheAlgorithmBlacklisted(
        struct _TLS_PARAMETERS *a1,
        unsigned int a2,
        struct CEccCurveInfo *a3,
        struct _UNICODE_STRING *a4,
        unsigned __int8 a5)
{
  unsigned int v9; // r15d
  struct _TLS_PARAMETERS *v10; // rdi
  struct _TLS_PARAMETERS *v11; // rax
  const wchar_t *v12; // r9
  unsigned int v14; // ebx
  unsigned __int64 v15; // rbx
  unsigned __int64 i; // rcx
  struct _TLS_PARAMETERS *v17; // [rsp+40h] [rbp-38h]

  if ( !a2 || !a1 || !a3 )
    return 0;
  v9 = *((_DWORD *)a3 + 192);
  v10 = a1;
  v11 = (struct _TLS_PARAMETERS *)((char *)a1 + 40 * a2);
  v17 = v11;
  if ( a1 < v11 )
  {
    while ( 1 )
    {
      if ( !*((_DWORD *)v10 + 5) )
        goto LABEL_8;
      if ( *(_DWORD *)v10 )
      {
        if ( !a4 )
          goto LABEL_8;
        v14 = 0;
        while ( RtlCompareUnicodeString((PCUNICODE_STRING)(*((_QWORD *)v10 + 1) + 16i64 * v14), a4, 1u) )
        {
          if ( ++v14 >= *(_DWORD *)v10 )
          {
LABEL_35:
            v11 = v17;
            goto LABEL_8;
          }
        }
        v11 = v17;
      }
      if ( !a5 || (*((_BYTE *)v10 + 32) & 1) == 0 )
        break;
LABEL_8:
      v10 = (struct _TLS_PARAMETERS *)((char *)v10 + 40);
      if ( v10 >= v11 )
        goto LABEL_9;
    }
    v15 = *((_QWORD *)v10 + 3);
    for ( i = v15 + 48i64 * *((unsigned int *)v10 + 5); ; i = *((_QWORD *)v10 + 3) + 48i64 * *((unsigned int *)v10 + 5) )
    {
      if ( v15 >= i )
        goto LABEL_35;
      if ( !*(_DWORD *)v15 && *(_WORD *)(v15 + 8) == 8 && !wcsncmp(*(const wchar_t **)(v15 + 16), L"ECDH", 4ui64) )
      {
        if ( !*(_DWORD *)(v15 + 24) && !*(_DWORD *)(v15 + 40) && !*(_DWORD *)(v15 + 44) )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_Sd(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xCu,
              (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
              L"ECDH",
              0);
          }
          return 1;
        }
        if ( v9 )
        {
          if ( *(_DWORD *)(v15 + 40) )
          {
            if ( *(_DWORD *)(v15 + 40) > v9 )
              goto LABEL_46;
          }
          else if ( !*(_DWORD *)(v15 + 44) )
          {
            goto LABEL_25;
          }
          if ( *(_DWORD *)(v15 + 44) && *(_DWORD *)(v15 + 44) < v9 )
          {
LABEL_46:
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_Sdd(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0xEu,
                (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
                L"ECDH",
                v9,
                0);
            }
            return 1;
          }
        }
      }
LABEL_25:
      v15 += 48i64;
    }
  }
LABEL_9:
  if ( !IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 0, (const wchar_t *)a3, 0i64, 0, a4, a5) )
  {
    switch ( *((_DWORD *)a3 + 193) )
    {
      case 0x17:
        v12 = L"ECDH_P256";
        return IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 0, v12, 0i64, 0, a4, a5);
      case 0x18:
        v12 = L"ECDH_P384";
        return IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 0, v12, 0i64, 0, a4, a5);
      case 0x19:
        v12 = L"ECDH_P521";
        return IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 0, v12, 0i64, 0, a4, a5);
    }
    return 0;
  }
  return 1;
}

//----- (0000000180007C20) ----------------------------------------------------
char __fastcall IsEcdsaAlgorithmBlacklisted(
        struct _TLS_PARAMETERS *a1,
        unsigned int a2,
        const unsigned __int16 *a3,
        int a4,
        unsigned int a5,
        PCUNICODE_STRING String2,
        char a7)
{
  struct _TLS_PARAMETERS *v10; // rax
  struct _TLS_PARAMETERS *v11; // rdi
  int v12; // esi
  int v13; // esi
  const wchar_t *v15; // r9
  unsigned int v16; // ebx
  unsigned __int64 v17; // rbx
  unsigned __int64 i; // rcx
  struct _TLS_PARAMETERS *v19; // [rsp+40h] [rbp-38h]
  const unsigned __int16 *v20; // [rsp+90h] [rbp+18h]

  v20 = a3;
  if ( !a2 || !a1 )
    return 0;
  v10 = (struct _TLS_PARAMETERS *)((char *)a1 + 40 * a2);
  v19 = v10;
  v11 = a1;
  if ( a1 < v10 )
  {
    while ( 1 )
    {
      if ( !*((_DWORD *)v11 + 5) )
        goto LABEL_7;
      if ( *(_DWORD *)v11 )
      {
        if ( !String2 )
          goto LABEL_7;
        v16 = 0;
        while ( RtlCompareUnicodeString((PCUNICODE_STRING)(*((_QWORD *)v11 + 1) + 16i64 * v16), String2, 1u) )
        {
          if ( ++v16 >= *(_DWORD *)v11 )
          {
LABEL_36:
            v10 = v19;
            goto LABEL_7;
          }
        }
        v10 = v19;
      }
      if ( !a7 || (*((_BYTE *)v11 + 32) & 1) == 0 )
        break;
LABEL_7:
      v11 = (struct _TLS_PARAMETERS *)((char *)v11 + 40);
      if ( v11 >= v10 )
      {
        a3 = v20;
        goto LABEL_9;
      }
    }
    v17 = *((_QWORD *)v11 + 3);
    for ( i = v17 + 48i64 * *((unsigned int *)v11 + 5); ; i = *((_QWORD *)v11 + 3) + 48i64 * *((unsigned int *)v11 + 5) )
    {
      if ( v17 >= i )
        goto LABEL_36;
      if ( *(_DWORD *)v17 == 1 && *(_WORD *)(v17 + 8) == 10 && !wcsncmp(*(const wchar_t **)(v17 + 16), L"ECDSA", 5ui64) )
      {
        if ( !*(_DWORD *)(v17 + 24) && !*(_DWORD *)(v17 + 40) && !*(_DWORD *)(v17 + 44) )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_Sd(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xCu,
              (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
              L"ECDSA",
              1);
          }
          return 1;
        }
        if ( a5 )
        {
          if ( *(_DWORD *)(v17 + 40) )
          {
            if ( *(_DWORD *)(v17 + 40) > a5 )
              goto LABEL_47;
          }
          else if ( !*(_DWORD *)(v17 + 44) )
          {
            goto LABEL_26;
          }
          if ( *(_DWORD *)(v17 + 44) && *(_DWORD *)(v17 + 44) < a5 )
          {
LABEL_47:
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_Sdd(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0xEu,
                (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
                L"ECDSA",
                a5,
                1);
            }
            return 1;
          }
        }
      }
LABEL_26:
      v17 += 48i64;
    }
  }
LABEL_9:
  if ( a3 && IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 1, a3, 0i64, 0, String2, a7) )
    return 1;
  v12 = a4 - 23;
  if ( v12 )
  {
    v13 = v12 - 1;
    if ( v13 )
    {
      if ( v13 != 1 )
        return 0;
      v15 = L"ECDSA_P521";
    }
    else
    {
      v15 = L"ECDSA_P384";
    }
  }
  else
  {
    v15 = L"ECDSA_P256";
  }
  return IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 1, v15, 0i64, 0, String2, a7);
}
// 1800821D8: using guessed type wchar_t aEcdsaP384[11];
// 180082E10: using guessed type wchar_t aEcdsaP521[11];

//----- (0000000180007E50) ----------------------------------------------------
__int64 __fastcall I_GetHashDetailsFromIndex(
        unsigned int a1,
        _QWORD *a2,
        _DWORD *a3,
        __int64 a4,
        __int64 a5,
        _DWORD *a6)
{
  __int64 v6; // rcx

  if ( a3 )
    *a3 = 0;
  if ( a2 )
    *a2 = 0i64;
  if ( a6 )
    *a6 = 0;
  if ( a1 < g_dwHashInfoTotalCount && (v6 = g_pHashInfo[a1]) != 0 )
    return I_GetHashDetailsFromHashInfo(v6, a2, a3, (__int64)a2, 0i64, a6);
  else
    return 1168i64;
}
// 180092324: using guessed type int g_dwHashInfoTotalCount;
// 180092330: using guessed type _QWORD g_pHashInfo[16];

//----- (0000000180007EB0) ----------------------------------------------------
__int64 __fastcall I_GetHashDetailsFromHashInfo(__int64 a1, _QWORD *a2, _DWORD *a3, __int64 a4, _DWORD *a5, _DWORD *a6)
{
  if ( a3 )
    *a3 = *(_DWORD *)(a1 + 8);
  if ( a5 )
    *a5 = *(_DWORD *)(a1 + 16);
  if ( a2 )
    *a2 = *(_QWORD *)a1;
  if ( a6 )
    *a6 = *(_DWORD *)(a1 + 20);
  return 0i64;
}

//----- (0000000180007EF4) ----------------------------------------------------
char __fastcall CTlsSignatureSuiteList::AddCertificateSignatureSuite(
        CTlsSignatureSuiteList *this,
        PCCERT_CONTEXT pCertContext)
{
  BOOL CertificateContextProperty; // eax
  DWORD v4; // edx
  unsigned __int64 v5; // rdx
  DWORD pcbData; // [rsp+20h] [rbp-A8h] BYREF
  unsigned __int16 *v8; // [rsp+28h] [rbp-A0h] BYREF
  __int16 pvData[64]; // [rsp+30h] [rbp-98h] BYREF

  pcbData = 128;
  v8 = (unsigned __int16 *)pvData;
  CertificateContextProperty = CertGetCertificateContextProperty(pCertContext, 0x59u, pvData, &pcbData);
  v4 = pcbData >> 1;
  if ( !CertificateContextProperty || v4 - 1 > 0x3F )
    return 0;
  v5 = v4 - 1;
  if ( v5 >= 64 )
    _report_rangecheckfailure(0i64);
  pvData[v5] = 0;
  return CTlsSignatureSuiteList::AddBCryptSignatureSuites(this, (const unsigned __int16 **const)&v8, 1u, 0);
}
// 1800281B8: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD);

//----- (0000000180007FAC) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::DigestRemoteCertificate(
        CSsl3TlsContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  unsigned int v3; // edi
  CSsl3TlsContext *v4; // rsi
  unsigned __int8 *v5; // r14
  int v6; // ebp
  unsigned int v7; // ebp
  _QWORD *v8; // rax
  void *v9; // rcx
  void *v10; // rcx
  const CERT_CONTEXT *v11; // rcx
  int v12; // ebx
  unsigned __int8 *v13; // r9
  unsigned int v14; // ecx
  DWORD v15; // r8d
  __int64 v16; // rax
  PCCERT_CONTEXT CertificateContext; // rax
  const struct _CERT_CONTEXT *v18; // r14
  unsigned int PublicKeyFromCert; // ebx
  int *v20; // r13
  int v21; // r12d
  __int64 v22; // rcx
  struct _SecPkgContext_ApplicationProtocol *v23; // rax
  _DWORD *v24; // rax
  _DWORD *v25; // r14
  unsigned __int8 *v26; // r12
  _DWORD *v27; // r15
  const void *v28; // rdx
  size_t v29; // r8
  __int64 v30; // rbx
  __int64 v31; // rax
  __int64 v33; // rax
  __int64 v34; // rax
  const unsigned __int16 *v35; // rbx
  const wchar_t *v36; // r9
  int v37; // r8d
  int v38; // edx
  unsigned __int8 v39; // r9
  struct _SecPkgContext_ApplicationProtocol *v40; // [rsp+20h] [rbp-A8h]
  struct CCipherSuiteInfo *v41; // [rsp+28h] [rbp-A0h]
  unsigned int v42; // [rsp+40h] [rbp-88h]
  int v43; // [rsp+40h] [rbp-88h]
  int v44; // [rsp+44h] [rbp-84h]
  struct _PUBLICKEY *v45; // [rsp+48h] [rbp-80h] BYREF
  unsigned __int8 *v46; // [rsp+50h] [rbp-78h]
  unsigned __int8 *v47; // [rsp+58h] [rbp-70h]
  __int16 v48; // [rsp+60h] [rbp-68h] BYREF
  __int128 v49; // [rsp+62h] [rbp-66h]
  __int128 v50; // [rsp+72h] [rbp-56h]
  __int16 v51; // [rsp+82h] [rbp-46h]

  v3 = 0;
  v48 = 0;
  v4 = this;
  v49 = 0i64;
  v50 = 0i64;
  v51 = 0;
  if ( a3 < 3 )
    goto LABEL_66;
  v5 = a2 + 3;
  v6 = (*a2 << 16) + (a2[1] << 8);
  v47 = a2 + 3;
  v7 = a2[2] + v6;
  if ( a3 != v7 + 3 )
    goto LABEL_66;
  if ( v7 )
  {
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
    v8 = (_QWORD *)*((_QWORD *)v4 + 11);
    v9 = (void *)v8[3];
    if ( v9 )
    {
      SPExternalFree(v9);
      v33 = *((_QWORD *)v4 + 11);
      *(_DWORD *)(v33 + 32) = 0;
      *(_QWORD *)(v33 + 24) = 0i64;
      v8 = (_QWORD *)*((_QWORD *)v4 + 11);
    }
    v10 = (void *)v8[5];
    if ( v10 )
    {
      SPExternalFree(v10);
      *(_QWORD *)(*((_QWORD *)v4 + 11) + 40i64) = 0i64;
      v8 = (_QWORD *)*((_QWORD *)v4 + 11);
    }
    v11 = (const CERT_CONTEXT *)v8[6];
    if ( v11 )
    {
      CertFreeCertificateContext(v11);
      *(_QWORD *)(*((_QWORD *)v4 + 11) + 48i64) = 0i64;
    }
    v12 = 0;
    v44 = 0;
    v13 = v5;
    v14 = v7;
    while ( 1 )
    {
      if ( v14 <= 3
        || (v15 = v13[2] + (*v13 << 16) + (v13[1] << 8), v16 = v15 + 3, v14 < (unsigned int)v16)
        || (v46 = &v13[v16],
            v42 = -3 - v15 + v14,
            CertificateContext = CertCreateCertificateContext(1u, v13 + 3, v15),
            (v18 = CertificateContext) == 0i64) )
      {
        RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
        this = v4;
        goto LABEL_66;
      }
      if ( (*((_DWORD *)v4 + 16) & 0xC0C00) != 0 )
      {
        if ( v12
          && CertCompareCertificateName(
               CertificateContext->dwCertEncodingType,
               &CertificateContext->pCertInfo->Issuer,
               &CertificateContext->pCertInfo->Subject) )
        {
LABEL_36:
          CertFreeCertificateContext(v18);
          goto LABEL_28;
        }
        if ( !CTlsSignatureSuiteList::AddCertificateSignatureSuite((CTlsSignatureSuiteList *)&v48, v18) )
        {
          RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
          v3 = -2146893048;
          CSslContext::SetErrorAndFatalAlert((__int64)v4, 252, -2146893048, 0x2Bu);
          CertFreeCertificateContext(v18);
          return v3;
        }
      }
      if ( v12 )
        goto LABEL_36;
      v45 = 0i64;
      PublicKeyFromCert = GetPublicKeyFromCert(v18, &v45, 0i64);
      if ( PublicKeyFromCert )
      {
        RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
        v37 = -2146893048;
        goto LABEL_56;
      }
      v20 = (int *)*((_QWORD *)v4 + 1);
      v21 = *((_DWORD *)v4 + 16) & 0x40051555;
      if ( !v20 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 51i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
        PublicKeyFromCert = -1073741595;
        v39 = 80;
        v37 = -1073741595;
        v38 = 254;
        goto LABEL_58;
      }
      v22 = *((_QWORD *)v4 + 10);
      if ( *(_DWORD *)(v22 + 196) )
      {
        if ( v21 )
        {
          v23 = (struct _SecPkgContext_ApplicationProtocol *)(*(__int64 (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)v4 + 88i64))(v4);
          v22 = *((_QWORD *)v4 + 10);
        }
        else
        {
          v23 = 0i64;
        }
        PublicKeyFromCert = IsRemoteCertificateBlacklisted(
                              *(struct _TLS_PARAMETERS **)(v22 + 200),
                              *(_DWORD *)(v22 + 196),
                              v18,
                              v45,
                              v23,
                              (struct CCipherSuiteInfo *)v20,
                              v21 != 0);
        if ( PublicKeyFromCert )
        {
          RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
          if ( PublicKeyFromCert == -2146893007 )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 52i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
            }
            v37 = -2146893007;
LABEL_56:
            v38 = 251;
            v39 = 43;
LABEL_58:
            CSslContext::SetErrorAndFatalAlert((__int64)v4, v38, v37, v39);
          }
          CertFreeCertificateContext(v18);
          return PublicKeyFromCert;
        }
      }
      if ( !v21 && !(unsigned int)IsCertKeyUsageCompliant(v20[8], v20[9], v18) )
      {
        v34 = (*(__int64 (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)v4 + 320i64))(v4);
        v35 = (const unsigned __int16 *)v34;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          v36 = L"NULL";
          if ( v34 )
            v36 = (const wchar_t *)v34;
          LODWORD(v40) = v20[8];
          LODWORD(v41) = v20[9];
          WPP_SF_Sdd(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x35u,
            (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
            v36,
            v40,
            v41);
        }
        CSchannelTelemetryContext::LogCertKeyUsageError((unsigned int)v20[8], v20[9], v35);
      }
      v12 = v44;
      *(_QWORD *)(*((_QWORD *)v4 + 11) + 40i64) = v45;
      *(_QWORD *)(*((_QWORD *)v4 + 11) + 48i64) = v18;
LABEL_28:
      v14 = v42;
      v44 = ++v12;
      if ( !v42 )
      {
        if ( (*((_DWORD *)v4 + 16) & 0xC0C00) != 0
          && !CTlsSignatureSuiteList::IsSupportedSignatureSuiteList(
                (CSsl3TlsContext *)((char *)v4 + 474),
                (struct CTlsSignatureSuiteList *)&v48) )
        {
          RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
          v3 = -2146893048;
          CSslContext::SetErrorAndFatalAlert((__int64)v4, 252, -2146893048, 0x28u);
        }
        else
        {
          v43 = v12 + v7;
          v24 = SPExternalAlloc(v12 + v7);
          v25 = v24;
          if ( v24 )
          {
            v26 = v47;
            v27 = v24;
            do
            {
              v28 = v26 + 3;
              v29 = v26[2] + (*v26 << 16) + (v26[1] << 8);
              *v27 = v29;
              v7 += -3 - v29;
              v30 = (unsigned int)v29;
              v26 += (unsigned int)(v29 + 3);
              memcpy_0(v27 + 1, v28, v29);
              v27 = (_DWORD *)((char *)v27 + v30 + 4);
            }
            while ( v7 );
            v31 = *((_QWORD *)v4 + 11);
            *(_DWORD *)(v31 + 32) = v43;
            *(_QWORD *)(v31 + 24) = v25;
            RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
          }
          else
          {
            RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)v4 + 11) + 72i64));
            return 14;
          }
        }
        return v3;
      }
      v13 = v46;
    }
  }
  if ( (*((_DWORD *)this + 16) & 0x800A2AAA) != 0 )
  {
LABEL_66:
    v3 = -2146893048;
    CSslContext::SetErrorAndFatalAlert((__int64)this, 250, -2146893048, 0x2Au);
  }
  else
  {
    *((_BYTE *)this + 552) = 1;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 50i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
  }
  return v3;
}
// 180033D18: variable 'v40' is possibly undefined
// 180033D18: variable 'v41' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180083C60: using guessed type wchar_t aNull_0[5];

//----- (0000000180008310) ----------------------------------------------------
char __fastcall IsCertificateBlacklisted(
        struct _TLS_PARAMETERS *a1,
        unsigned int a2,
        int a3,
        unsigned int a4,
        struct CEccCurveInfo *a5,
        unsigned __int8 a6,
        unsigned __int8 a7,
        const unsigned __int16 *a8,
        const unsigned __int16 *a9,
        struct _UNICODE_STRING *String2,
        char a11)
{
  char v14; // si
  char v15; // al
  char v17; // al

  if ( a2 && a1 && a3 && a8 && a9 )
  {
    if ( a3 == 8707 )
    {
      if ( a5 )
      {
        v15 = IsEcdsaAlgorithmBlacklisted(a1, a2, (const unsigned __int16 *)a5, *((_DWORD *)a5 + 193), a4, String2, a11);
        goto LABEL_11;
      }
    }
    else
    {
      if ( a3 == 8704 )
      {
        v15 = IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 1, L"DSA", 0i64, a4, String2, a11);
        goto LABEL_11;
      }
      if ( ((a3 - 9216) & 0xFFFF7FFF) != 0 )
        goto LABEL_12;
      v14 = 0;
      if ( a6 )
      {
        if ( a3 == 41984 )
        {
          v17 = IsRsaAlgorithmBlacklisted((unsigned __int64)a1, a2, 0, a4, String2, a11);
          v14 = v17;
          if ( !a7 )
          {
            if ( v17 )
              return 1;
          }
        }
      }
      v15 = IsRsaAlgorithmBlacklisted((unsigned __int64)a1, a2, 1, a4, String2, a11);
      if ( !a7 || v14 )
      {
LABEL_11:
        if ( !v15 )
          goto LABEL_12;
        return 1;
      }
    }
LABEL_12:
    if ( !IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 4, a8, 0i64, 0, 0i64, 1) )
      return IsCngAlgorithmBlacklisted((unsigned __int64)a1, a2, 4, a9, 0i64, 0, 0i64, 1);
    return 1;
  }
  return 0;
}

//----- (00000001800084B0) ----------------------------------------------------
char __fastcall CCipherMill::IsUserSpecifiedCipherAllowed(
        __int64 a1,
        unsigned int *a2,
        unsigned int a3,
        char a4,
        int a5,
        int a6,
        unsigned int a7,
        unsigned int a8,
        int a9,
        char a10,
        unsigned __int64 a11,
        unsigned int a12)
{
  char v12; // bl
  CMasterCipherInfo *v13; // rax
  unsigned int v14; // edi
  unsigned int v15; // esi
  __int64 i; // rbp
  char IsCipherSuiteAllowed; // al

  v12 = 0;
  RtlAcquireResourceShared(&Resource, 1u);
  v13 = xmmword_1800925B0;
  if ( a10 )
    v13 = *(&xmmword_1800925B0 + 1);
  if ( v13 )
  {
    v14 = *((_DWORD *)v13 + 2);
    v15 = 0;
    for ( i = *(_QWORD *)v13; v15 < v14; v12 = IsCipherSuiteAllowed )
    {
      if ( v12 )
        break;
      IsCipherSuiteAllowed = CCipherMill::IsCipherSuiteAllowed(
                               (__int64)g_cCipherMill,
                               a2,
                               a3,
                               a4,
                               a5,
                               a6,
                               a7,
                               a8,
                               a9,
                               i + 864i64 * v15++,
                               0i64,
                               a11,
                               a12,
                               1);
    }
  }
  RtlReleaseResource(&Resource);
  return v12;
}

//----- (0000000180008600) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::InitHandshakeHash(CSsl3TlsContext *this, char a2)
{
  __int64 *v2; // rax
  __int64 v5; // r14
  unsigned int v6; // r15d
  unsigned int v7; // ebp
  unsigned int i; // edi
  __int64 result; // rax
  unsigned int v10; // edi
  unsigned int CipherSuitePRFHashAlgorithm; // r13d
  int v12; // r8d
  unsigned int v13; // esi
  char *v14; // r12
  __int64 v15; // rcx
  unsigned int v16[4]; // [rsp+30h] [rbp-148h] BYREF
  unsigned __int16 *v17[16]; // [rsp+40h] [rbp-138h] BYREF
  unsigned __int16 v18[64]; // [rsp+C0h] [rbp-B8h] BYREF

  v2 = (__int64 *)*((_QWORD *)this + 1);
  if ( v2 )
    v5 = *v2;
  else
    v5 = 0i64;
  v6 = *((unsigned __int16 *)this + 17);
  if ( (*((_BYTE *)this + 32) & 1) != 0 && v2 )
    v7 = *((_DWORD *)v2 + 7);
  else
    v7 = 0;
  for ( i = 0; i < *((_DWORD *)this + 137); ++i )
  {
    v14 = (char *)this + 8 * i;
    v15 = *((_QWORD *)v14 + 74);
    if ( v15 )
    {
      SslFreeObject(v15, 0i64);
      *((_QWORD *)v14 + 74) = 0i64;
    }
  }
  *((_DWORD *)this + 180) = 0;
  *((_DWORD *)this + 137) = 0;
  result = SslCreateHandshakeHash(v5, (char *)this + 592, v6, v7, 0);
  if ( !(_DWORD)result )
  {
    v10 = 1;
    *((_DWORD *)this + 137) = 1;
    if ( !a2 )
      return 0i64;
    v16[0] = 0;
    CipherSuitePRFHashAlgorithm = SslGetCipherSuitePRFHashAlgorithm(v5, v6, v7, 0i64, v18, 0);
    if ( !CipherSuitePRFHashAlgorithm )
    {
      v12 = *((_DWORD *)this + 16);
      v18[63] = 0;
      CipherSuitePRFHashAlgorithm = CTlsSignatureSuiteList::GetRunningHashList(
                                      (CSsl3TlsContext *)((char *)this + 474),
                                      v18,
                                      v12,
                                      (enum _eTlsHashAlgorithm *const)this + 180,
                                      v17,
                                      v16);
      if ( !CipherSuitePRFHashAlgorithm )
      {
        v13 = v16[0];
        if ( v16[0] <= 1 )
          return 0i64;
        while ( 1 )
        {
          CipherSuitePRFHashAlgorithm = SslCreateClientAuthHash(v5, (char *)this + 8 * v10 + 592, v6, v7, v17[v10], 0);
          if ( CipherSuitePRFHashAlgorithm )
            break;
          *((_DWORD *)this + 137) = ++v10;
          if ( v10 >= v13 )
            return 0i64;
        }
      }
    }
    CSsl3TlsContext::FreeHandshakeHash(this);
    return CipherSuitePRFHashAlgorithm;
  }
  return result;
}
// 180098430: using guessed type __int64 __fastcall SslCreateClientAuthHash(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098438: using guessed type __int64 __fastcall SslGetCipherSuitePRFHashAlgorithm(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098440: using guessed type __int64 __fastcall SslCreateHandshakeHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);
// 180008600: using guessed type unsigned int var_148[4];

//----- (00000001800087D0) ----------------------------------------------------
__int64 __fastcall CCipherMill::SetServerHelloCipher(CCipherMill *this, struct CSsl3TlsClientContext *a2, int a3)
{
  __int64 v3; // rdi
  unsigned int v4; // ebp
  unsigned int *v7; // r15
  unsigned int v8; // r12d
  int v9; // r13d
  CMasterCipherInfo *v10; // rax
  unsigned int v11; // ecx
  __int64 v12; // rbx
  unsigned int v13; // eax
  __int64 v14; // rax
  unsigned int v15; // ebx

  v3 = *((_QWORD *)a2 + 10);
  v4 = *((_DWORD *)a2 + 16);
  v7 = *(unsigned int **)(v3 + 184);
  v8 = *(_DWORD *)(v3 + 176);
  v9 = *(_DWORD *)(v3 + 192);
  RtlAcquireResourceShared(&Resource, 1u);
  v10 = xmmword_1800925B0;
  if ( (*((_DWORD *)a2 + 34) & 0x20000000) != 0 )
    v10 = *(&xmmword_1800925B0 + 1);
  if ( !v10 )
    goto LABEL_15;
  v11 = *((_DWORD *)v10 + 2);
  v12 = *(_QWORD *)v10;
  v13 = 0;
  if ( !v11 )
    goto LABEL_15;
  while ( *(_DWORD *)(v12 + 28) != a3 )
  {
    ++v13;
    v12 += 864i64;
    if ( v13 >= v11 )
      goto LABEL_15;
  }
  if ( !CCipherMill::IsCipherSuiteAllowed(
          (__int64)g_cCipherMill,
          v7,
          v8,
          v9,
          (*(_DWORD *)(v3 + 156) >> 12) & 1,
          *(_DWORD *)(v3 + 156) & 0x800,
          *(_DWORD *)(v3 + 168),
          *(_DWORD *)(v3 + 164),
          v4,
          v12,
          0i64,
          0i64,
          0,
          1) )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 58i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
LABEL_15:
    RtlReleaseResource(&Resource);
    LogCipherMismatchEvent(*(_DWORD *)(v3 + 212), (const unsigned __int16 *)(v3 + 216), v4);
    return 2148074289i64;
  }
  v14 = *(_QWORD *)(v12 + 848);
  if ( v14 )
    _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v14 + 16) + 12i64));
  _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v12 + 856) + 12i64));
  v15 = CSslContext::SetCipherState(a2, (struct CCipherSuiteInfo *)v12);
  RtlReleaseResource(&Resource);
  return v15;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180008948) ----------------------------------------------------
__int64 __fastcall CSslContext::SetCipherState(CSslContext *this, struct CCipherSuiteInfo *a2)
{
  unsigned int v4; // ebp
  __int64 v5; // rax
  __int64 v6; // rsi
  CSslCredential *v7; // r14
  CSslServerKey *v8; // rcx
  int v9; // eax
  __int64 result; // rax
  __int64 v11; // rcx
  unsigned int v12; // ecx
  int v13; // eax
  _BYTE Source1[20]; // [rsp+40h] [rbp-38h] BYREF

  v4 = 0;
  v5 = (*(__int64 (__fastcall **)(CSslContext *))(*(_QWORD *)this + 248i64))(this);
  v6 = *((_QWORD *)this + 1);
  v7 = (CSslCredential *)v5;
  if ( v6 )
  {
    v11 = *(_QWORD *)(v6 + 848);
    if ( v11 )
      CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v11 + 16));
    CMasterCipherInfo::Dereference(*(CMasterCipherInfo **)(v6 + 856));
  }
  v8 = (CSslServerKey *)*((_QWORD *)this + 3);
  if ( v8 )
  {
    CSslServerKey::Dereference(v8);
    *((_QWORD *)this + 3) = 0i64;
  }
  if ( v7 )
    CSslCredential::GetProviderSpecificMasterKey(v7, *(_QWORD *)a2, (struct CSslServerKey **)this + 3);
  if ( (*((_DWORD *)this + 16) & 0xF3F00) != 0 )
  {
    v4 = SslLookupCipherLengths(
           *(_QWORD *)a2,
           *((unsigned __int16 *)this + 17),
           *((unsigned int *)a2 + 7),
           *((unsigned int *)this + 4),
           Source1,
           20,
           0);
    if ( v4 )
      goto LABEL_10;
  }
  else
  {
    *(_QWORD *)&Source1[12] = 0i64;
    v12 = *((_DWORD *)a2 + 3);
    v13 = *((_DWORD *)a2 + 4);
    *(_QWORD *)Source1 = 20i64;
    *(_DWORD *)&Source1[8] = v13;
    if ( v12 > 1 )
    {
      *(_DWORD *)&Source1[16] |= 1u;
      *(_DWORD *)&Source1[12] = v12;
    }
  }
  if ( (*((_BYTE *)this + 32) & 1) == 0 || RtlCompareMemory(Source1, (char *)this + 40, 0x14ui64) == 20 )
  {
    v9 = *(_DWORD *)&Source1[16];
    *(_OWORD *)((char *)this + 40) = *(_OWORD *)Source1;
    *((_DWORD *)this + 14) = v9;
  }
  else
  {
    v4 = -2146893007;
  }
LABEL_10:
  *((_WORD *)this + 16) |= 1u;
  result = v4;
  *((_QWORD *)this + 1) = a2;
  return result;
}
// 1800984F0: using guessed type __int64 __fastcall SslLookupCipherLengths(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180008A4C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::PackClientHello(
        CSsl3TlsClientContext *this,
        struct _Ssl2_Client_Hello *a2,
        struct SPBuffer *a3)
{
  unsigned int v6; // esi
  char v7; // al
  bool v8; // cf
  unsigned int v9; // eax
  __int64 v10; // rcx
  int v11; // r14d
  unsigned int ClientHelloExtensionsLength; // ebx
  char v13; // dl
  unsigned int v14; // r14d
  unsigned int v15; // r15d
  unsigned int v16; // ecx
  unsigned int v17; // r15d
  unsigned int v18; // r15d
  unsigned int v19; // esi
  _BYTE *v20; // rsi
  _BYTE *v21; // rsi
  __int64 v22; // rdx
  int v23; // ecx
  _BYTE *v24; // rsi
  _BYTE *i; // rsi
  _BYTE *v26; // rsi
  char v27; // al
  unsigned int v28; // eax
  __int64 v29; // rcx
  HLOCAL Memory; // rax
  __int64 v32; // rcx
  _BYTE *v33; // rsi
  __int16 v34; // cx
  _BYTE *v35; // rdx
  __int16 v36; // [rsp+20h] [rbp-60h]
  int v37; // [rsp+28h] [rbp-58h]
  unsigned int v38; // [rsp+30h] [rbp-50h]
  unsigned int Size; // [rsp+34h] [rbp-4Ch]
  unsigned int Size_4; // [rsp+38h] [rbp-48h]
  unsigned int v41; // [rsp+3Ch] [rbp-44h]
  __int64 v42[3]; // [rsp+40h] [rbp-40h] BYREF
  int v43; // [rsp+58h] [rbp-28h]
  char v44; // [rsp+60h] [rbp-20h]
  __int64 v45; // [rsp+68h] [rbp-18h]
  int v46; // [rsp+70h] [rbp-10h]
  char v47; // [rsp+74h] [rbp-Ch]
  CSsl3TlsClientContext *v48; // [rsp+78h] [rbp-8h]
  unsigned __int8 v49; // [rsp+C0h] [rbp+40h]
  unsigned int v50; // [rsp+D8h] [rbp+58h] BYREF

  v42[1] = (__int64)this;
  v42[2] = 0i64;
  v42[0] = (__int64)&CTlsExtClient::`vftable';
  v43 = 0;
  v44 = 0;
  v45 = 0i64;
  v6 = 0;
  v46 = 0;
  v48 = this;
  v47 = *((_BYTE *)this + 922);
  v7 = *((_BYTE *)this + 233);
  Size = 0;
  v50 = 0;
  if ( !v7 && (*((_BYTE *)this + 32) & 4) != 0 )
    v38 = *((_DWORD *)this + 11);
  else
    v38 = 0;
  v8 = v7 != 0;
  v49 = 0;
  v9 = *((_DWORD *)this + 15);
  v10 = *((_QWORD *)this + 165);
  Size_4 = v9;
  v11 = v8 ? 12 : 4;
  v41 = v11;
  if ( v10 )
    RtlAcquireResourceShared((PRTL_RESOURCE)(v10 + 72), 1u);
  ClientHelloExtensionsLength = CTlsExtClient::GetClientHelloExtensionsLength((CTlsExtClient *)v42, &v50);
  if ( ClientHelloExtensionsLength )
    goto LABEL_42;
  v13 = *((_BYTE *)this + 233);
  if ( v13 )
  {
    if ( *((_DWORD *)this + 327) )
    {
      v6 = *((unsigned __int8 *)this + 1312);
      Size = v6;
    }
    else
    {
      Size = 0;
    }
  }
  v14 = v50 + v11 + 2 * *((_DWORD *)a2 + 1) + *((_DWORD *)a2 + 2) + 39;
  if ( v13 )
    v14 += v6 + 1;
  if ( (*((_DWORD *)this + 16) & 0x2A88) == 0 && (*((_BYTE *)this + 64) & 0x20) != 0 && !v50 )
  {
    v14 += 2;
    v49 = 1;
  }
  v15 = v14;
  if ( v13 )
  {
    v19 = Size_4;
    v18 = v14 + Size_4;
  }
  else
  {
    if ( (*((_BYTE *)this + 32) & 4) != 0 )
    {
      v16 = *((_DWORD *)this + 13);
      v17 = v14 + *((_DWORD *)this + 12);
      if ( v16 )
      {
        if ( (*((_BYTE *)this + 56) & 1) != 0 )
          v16 -= v17 % v16;
        v17 += v16;
      }
      v15 = *((_DWORD *)this + 11) + v17;
    }
    v18 = *((_DWORD *)this + 15) + v15;
    v19 = Size_4;
  }
  ClientHelloExtensionsLength = CSsl3TlsContext::AllocateOutputBuffer(this, a3, v18);
  if ( ClientHelloExtensionsLength )
  {
LABEL_42:
    v32 = *((_QWORD *)this + 165);
    if ( v32 )
      RtlReleaseResource((PRTL_RESOURCE)(v32 + 72));
  }
  else
  {
    v20 = (_BYTE *)(*((_QWORD *)a3 + 1) + v19 + v38 + (unsigned __int64)v41);
    *v20++ = *((_BYTE *)a2 + 1);
    *v20++ = *(_BYTE *)a2;
    *(_OWORD *)v20 = *((_OWORD *)a2 + 3);
    *((_OWORD *)v20 + 1) = *((_OWORD *)a2 + 4);
    v20 += 32;
    *v20++ = *((_BYTE *)a2 + 8);
    memcpy_0(v20, (char *)a2 + 16, *((unsigned int *)a2 + 2));
    v21 = &v20[*((unsigned int *)a2 + 2)];
    if ( *((_BYTE *)this + 233) )
    {
      *v21++ = Size;
      if ( *((_DWORD *)this + 327) && Size )
      {
        memcpy_0(v21, (char *)this + 1052, Size);
        v21 += Size;
      }
      else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
             && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_13477250810f3961702f89c94d47ffd6_Traceguids);
      }
    }
    v22 = 0i64;
    v23 = 2 * (*((_DWORD *)a2 + 1) + v49);
    *v21 = (unsigned __int16)(*((_WORD *)a2 + 2) + v49) >> 7;
    v24 = v21 + 1;
    *v24 = v23;
    for ( i = v24 + 1; (unsigned int)v22 < *((_DWORD *)a2 + 1); i = v26 + 1 )
    {
      *i = *((_BYTE *)a2 + 4 * v22 + 81);
      v26 = i + 1;
      v27 = *((_BYTE *)a2 + 4 * v22 + 80);
      v22 = (unsigned int)(v22 + 1);
      *v26 = v27;
    }
    if ( v49 )
    {
      *i = 0;
      v33 = i + 1;
      *v33 = -1;
      i = v33 + 1;
    }
    *i = 1;
    i[1] = 0;
    v28 = CTlsExtClient::BuildClientHelloExtension((CTlsExtClient *)v42, v50, i + 2, &v50);
    v29 = *((_QWORD *)this + 165);
    ClientHelloExtensionsLength = v28;
    if ( v29 )
      RtlReleaseResource((PRTL_RESOURCE)(v29 + 72));
    if ( !ClientHelloExtensionsLength )
    {
      v37 = *((unsigned __int8 *)this + 233);
      v36 = *((_WORD *)this + 110);
      *((_WORD *)this + 110) = v36 + 1;
      SetHandshakeHeader(
        *((_QWORD *)a3 + 1) + v38 + (unsigned __int64)Size_4,
        1,
        0i64,
        (unsigned __int16)(v14 - v41),
        v36,
        v37);
      if ( *((_QWORD *)this + 110) )
      {
        (*(void (__fastcall **)(CSsl3TlsClientContext *))(*(_QWORD *)this + 16i64))(this);
        *((_QWORD *)this + 110) = 0i64;
      }
      *((_DWORD *)this + 218) = v14;
      Memory = CSslContext::GetMemory(this, v14);
      *((_QWORD *)this + 110) = Memory;
      if ( Memory )
      {
        memcpy_0(
          Memory,
          (const void *)(*((_QWORD *)a3 + 1) + v38 + (unsigned __int64)Size_4),
          *((unsigned int *)this + 218));
        if ( *((_BYTE *)this + 233) )
        {
          v34 = *((_WORD *)this + 17);
          ClientHelloExtensionsLength = 0;
          v35 = (_BYTE *)*((_QWORD *)a3 + 1);
          v35[12] = v14;
          v35[11] = BYTE1(v14);
          v35[1] = HIBYTE(v34);
          v35[2] = v34;
          *v35 = 22;
          *((_DWORD *)a3 + 1) += v18;
        }
        else
        {
          ClientHelloExtensionsLength = CSsl3TlsContext::WrapMessage((__int64)this, (__int64)a3, 22, v14);
        }
      }
      else
      {
        ClientHelloExtensionsLength = 14;
      }
    }
  }
  CTlsExtClient::~CTlsExtClient((CTlsExtClient *)v42);
  return ClientHelloExtensionsLength;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18007D048: using guessed type void *CTlsExtClient::`vftable';

//----- (0000000180008DA0) ----------------------------------------------------
void __fastcall CTlsExtClient::~CTlsExtClient(CTlsExtClient *this)
{
  void *v2; // rcx

  *(_QWORD *)this = &CTlsExtClient::`vftable';
  v2 = (void *)*((_QWORD *)this + 5);
  if ( v2 )
    SPExternalFree(v2);
  *(_QWORD *)this = &CTlsExt::`vftable';
}
// 18007D038: using guessed type void *CTlsExt::`vftable';
// 18007D048: using guessed type void *CTlsExtClient::`vftable';

//----- (0000000180008DE0) ----------------------------------------------------
__int64 __fastcall SpDeleteContext(void *a1)
{
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  const wchar_t *v5; // rbp
  __int64 v6; // rbx
  int v7; // esi
  unsigned int v8; // eax
  CCipherMill *v9; // rax
  __int64 v10; // rcx
  int v11; // esi
  int v12; // ebp
  int v13; // ebx
  __int64 v14; // rsi
  char v15; // bl
  __int64 v16; // rcx
  __int64 v17; // r8
  const wchar_t *v19; // r9
  unsigned int v20; // ecx
  unsigned int v21; // eax
  __int64 v22; // r14
  void *v23; // rax
  __int64 v24; // rax
  void *v25; // rax
  void (__fastcall *v26)(__int64, __int64); // rbx
  __int64 v27; // rax
  void *v28; // rax
  __int128 v29; // [rsp+40h] [rbp-48h] BYREF
  __int64 v30; // [rsp+50h] [rbp-38h]
  int v31[2]; // [rsp+58h] [rbp-30h] BYREF
  __int64 v32; // [rsp+60h] [rbp-28h]

  v2 = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)a1 + 1) + 320i64))(*((_QWORD *)a1 + 1));
  v4 = *((_QWORD *)a1 + 1);
  v5 = (const wchar_t *)v2;
  v6 = *(_QWORD *)(v4 + 80);
  if ( v6 && LsaTable )
  {
    v29 = 0i64;
    v30 = 0i64;
    v7 = 8;
    if ( (*(unsigned __int8 (__fastcall **)(__int128 *))(LsaTable + 192))(&v29) && (BYTE8(v29) & 0x40) != 0 )
      v7 = 4;
    v8 = *(_DWORD *)(v6 + 736);
    if ( v8 > 1 )
    {
      v32 = 0i64;
      v31[1] = 0;
      v31[0] = 2 * v7 * v8;
      v32 = (*(__int64 (**)(void))(LsaTable + 384))();
      if ( v32 )
        (*(void (__fastcall **)(__int64, _QWORD, _QWORD, int *, _BYTE))(LsaTable + 496))(5i64, 0i64, 0i64, v31, 0);
    }
  }
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
  {
    v19 = &Class;
    if ( v5 )
      v19 = v5;
    McTemplateU0pz_EtwEventWriteTransfer(v4, v3, (__int64)a1, v19);
  }
  v9 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x34u, (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids, a1);
    v9 = WPP_GLOBAL_Control;
  }
  v10 = *((_QWORD *)a1 + 1);
  v11 = *(_DWORD *)(v10 + 64);
  v12 = *(_DWORD *)(v10 + 68);
  if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
  {
    WPP_SF_q(*((_QWORD *)v9 + 2), 0x12u, (__int64)&WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids, a1);
    v10 = *((_QWORD *)a1 + 1);
  }
  if ( v10 )
  {
    v13 = *(_DWORD *)(v10 + 64);
    (**(void (__fastcall ***)(__int64, _QWORD))v10)(v10, 0i64);
    if ( (v13 & 0x800A2AAA) != 0 )
      SPExternalFree(*((void **)a1 + 1));
    *((_QWORD *)a1 + 1) = 0i64;
  }
  if ( (v11 & 0x51550) != 0 )
  {
    v14 = *((_QWORD *)a1 + 3);
    v15 = *((_BYTE *)a1 + 32);
    if ( !v14 )
    {
LABEL_20:
      *((_QWORD *)a1 + 3) = 0i64;
      (*(void (__fastcall **)(_QWORD, void *))(*(_QWORD *)xmmword_180092DD0 + 32i64))(xmmword_180092DD0, a1);
      goto LABEL_21;
    }
    if ( v12 == 4 )
    {
      v20 = (*(unsigned __int16 (__fastcall **)(__int64))(*(_QWORD *)v14 + 64i64))(v14);
      v21 = qword_180092DB8;
      if ( (unsigned int)qword_180092DB8 <= v20 )
        v21 = v20;
      LODWORD(qword_180092DB8) = v21;
      if ( _InterlockedIncrement((_DWORD *)&qword_180092DB0 + 1) == 100 )
      {
        v22 = *((_QWORD *)&xmmword_180092DD0 + 1);
        if ( !*((_QWORD *)&xmmword_180092DD0 + 1) )
          goto LABEL_44;
        LODWORD(qword_180092DC0) = qword_180092DB8;
        if ( dword_180092DE0 )
        {
          v23 = operator new(0x80ui64);
          if ( v23 )
          {
            v24 = CSslLookasidePreallocate::CSslLookasidePreallocate((__int64)v23, qword_180092DC0, dword_180092DE0);
LABEL_40:
            v22 = *((_QWORD *)&xmmword_180092DD0 + 1);
            if ( v24 )
              v22 = v24;
            *((_QWORD *)&xmmword_180092DD0 + 1) = v22;
            goto LABEL_44;
          }
        }
        else
        {
          v25 = operator new(0x50ui64);
          if ( v25 )
          {
            v24 = CSslLookaside::CSslLookaside((__int64)v25, qword_180092DC0, 1);
            goto LABEL_40;
          }
        }
      }
    }
    v22 = *((_QWORD *)&xmmword_180092DD0 + 1);
LABEL_44:
    if ( v15 )
    {
      v28 = (void *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 40i64))(v14);
      SPExternalFree(v28);
    }
    else
    {
      v26 = *(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v22 + 32i64);
      v27 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14 + 40i64))(v14);
      v26(v22, v27);
    }
    goto LABEL_20;
  }
  SPExternalFree(a1);
LABEL_21:
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
    McGenEventWrite_EtwEventWriteTransfer(v16, (__int64)&DscStop, v17, 1, (__int64)v31);
  return 0i64;
}
// 18003446B: variable 'v16' is possibly undefined
// 18003446B: variable 'v17' is possibly undefined
// 1800342C5: variable 'v4' is possibly undefined
// 1800342C5: variable 'v3' is possibly undefined
// 180092620: using guessed type __int64 LsaTable;
// 180092DB0: using guessed type __int64 qword_180092DB0;
// 180092DB8: using guessed type __int64 qword_180092DB8;
// 180092DC0: using guessed type __int64 qword_180092DC0;
// 180092DD0: using guessed type __int128 xmmword_180092DD0;
// 180092DE0: using guessed type int dword_180092DE0;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;

//----- (0000000180008FB8) ----------------------------------------------------
void __fastcall FreeTlsParameters(struct _TLS_PARAMETERS *a1, unsigned int a2)
{
  unsigned int v2; // r12d
  char *v5; // rbx
  unsigned int i; // edi
  void *v7; // rcx
  __int64 j; // r14
  __int64 v9; // rdi
  void *v10; // rcx
  void *v11; // rdx
  void *v12; // rcx
  __int64 v13; // rcx
  void *v14; // rcx
  unsigned int v15; // r15d
  void *v16; // rcx

  v2 = 0;
  if ( a2 )
  {
    v5 = (char *)a1 + 20;
    while ( a1 )
    {
      for ( i = 0; i < *((_DWORD *)v5 - 5); ++i )
      {
        v13 = *(_QWORD *)(v5 - 12);
        if ( v13 )
        {
          v14 = *(void **)(v13 + 16i64 * i + 8);
          if ( v14 )
            SPExternalFree(v14);
        }
      }
      v7 = *(void **)(v5 - 12);
      if ( v7 )
      {
        SPExternalFree(v7);
        *(_QWORD *)(v5 - 12) = 0i64;
        *((_DWORD *)v5 - 5) = 0;
      }
      for ( j = 0i64; (unsigned int)j < *(_DWORD *)v5; j = (unsigned int)(j + 1) )
      {
        v9 = *(_QWORD *)(v5 + 4);
        if ( !v9 )
          break;
        v10 = *(void **)(v9 + 48 * j + 16);
        if ( v10 )
          SPExternalFree(v10);
        v11 = *(void **)(v9 + 48 * j + 32);
        if ( v11 )
        {
          v15 = 0;
          if ( *(_DWORD *)(v9 + 48 * j + 24) )
          {
            do
            {
              v16 = v11;
              if ( v11 && *((_QWORD *)v11 + 2 * v15 + 1) )
              {
                SPExternalFree(*((void **)v11 + 2 * v15 + 1));
                v11 = *(void **)(v9 + 48 * j + 32);
                v16 = v11;
              }
              ++v15;
            }
            while ( v15 < *(_DWORD *)(v9 + 48 * j + 24) );
            if ( !v16 )
              continue;
          }
          else
          {
            v16 = *(void **)(v9 + 48 * j + 32);
          }
          SPExternalFree(v16);
          *(_QWORD *)(v9 + 48 * j + 32) = 0i64;
        }
      }
      v12 = *(void **)(v5 + 4);
      if ( v12 )
      {
        SPExternalFree(v12);
        *(_QWORD *)(v5 + 4) = 0i64;
        *(_DWORD *)v5 = 0;
      }
      ++v2;
      v5 += 40;
      if ( v2 >= a2 )
        goto LABEL_16;
    }
  }
  else
  {
LABEL_16:
    if ( a1 )
      SPExternalFree(a1);
  }
}

//----- (000000018000909C) ----------------------------------------------------
void __fastcall SPExternalFree(void *a1)
{
  if ( LsaTable )
    (*(void (__fastcall **)(void *))(LsaTable + 48))(a1);
  else
    LocalFree(a1);
}
// 180092620: using guessed type __int64 LsaTable;

//----- (00000001800090D0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::GenerateCcsAndFinishMessage(CSsl3TlsContext *this, struct SPBuffer *a2)
{
  __int64 v2; // rdi
  __int64 v5; // r14
  unsigned int v6; // edx
  __int64 v7; // r8
  int v8; // eax
  unsigned int v9; // edi
  char v10; // cl
  _BYTE *v11; // r13
  int v12; // r15d
  unsigned int v13; // ebp
  _BYTE *v14; // r14
  __int64 *v15; // rax
  __int64 v16; // rcx
  unsigned int v17; // edi
  size_t v18; // r12
  __int64 v19; // r9
  __int16 v20; // cx
  _BYTE *v21; // rdi
  bool v22; // zf
  char v23; // cl
  __int64 v24; // rdx
  unsigned int v25; // eax
  int v26; // r14d
  int v27; // eax
  unsigned int v28; // edi
  __int64 result; // rax
  __int16 v30; // cx
  __int64 v31; // rcx
  __int64 v32; // rcx
  __int64 v33; // rdi
  void *v34; // r12
  __int64 *v35; // rax
  __int64 v36; // rcx
  int v37; // edi
  __int64 v38; // rax
  void *v39; // rdi
  __int16 v40; // cx
  __int64 v41; // [rsp+58h] [rbp-60h]
  __int64 v42; // [rsp+60h] [rbp-58h]
  int v43; // [rsp+C8h] [rbp+10h]
  unsigned int v44; // [rsp+D0h] [rbp+18h]
  unsigned int v45; // [rsp+D8h] [rbp+20h]

  v2 = *((_QWORD *)a2 + 1) + *((unsigned int *)a2 + 1);
  v42 = *((_DWORD *)this + 34) & 0x8000;
  if ( *((_BYTE *)this + 233) )
  {
    v45 = *((_DWORD *)this + 15);
    v5 = 12i64;
    goto LABEL_3;
  }
  v45 = *((_DWORD *)this + 15);
  v5 = 4i64;
  if ( (*((_BYTE *)this + 32) & 4) == 0 )
  {
LABEL_3:
    v6 = 0;
    goto LABEL_4;
  }
  v6 = *((_DWORD *)this + 11);
LABEL_4:
  v7 = v45;
  v44 = v6;
  v43 = v5;
  *(_BYTE *)(v45 + (unsigned __int64)v6 + v2) = 1;
  if ( *((_BYTE *)this + 233) )
  {
    v30 = *((_WORD *)this + 17);
    *(_BYTE *)(v2 + 2) = v30;
    *(_BYTE *)(v2 + 1) = HIBYTE(v30);
    *(_BYTE *)v2 = 20;
    *(_WORD *)(v2 + 11) = 256;
    *((_DWORD *)a2 + 1) += v6 + v45 + 1;
  }
  else
  {
    v8 = CSsl3TlsContext::WrapMessage((__int64)this, (__int64)a2, 20, 1u);
    v9 = v8;
    if ( v8 )
    {
      CSslContext::SetErrorAndFatalAlert((__int64)this, 950, v8, 0x50u);
      return v9;
    }
    *((_WORD *)this + 16) |= 0xCu;
    v10 = *((_BYTE *)this + 233);
    if ( !v10 && *((_QWORD *)this + 19) )
    {
      SslFreeObject(*((_QWORD *)this + 19), 0i64);
      v10 = *((_BYTE *)this + 233);
    }
    *((_QWORD *)this + 19) = *((_QWORD *)this + 21);
    *((_QWORD *)this + 21) = 0i64;
    if ( !v10 )
      *((_QWORD *)this + 23) = 0i64;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 59i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    v7 = v45;
    if ( (*((_BYTE *)this + 32) & 4) != 0 )
      v6 = *((_DWORD *)this + 11);
    else
      v6 = 0;
    v44 = v6;
  }
  v11 = (_BYTE *)(*((_QWORD *)a2 + 1) + *((unsigned int *)a2 + 1));
  v12 = *((_DWORD *)this + 16) & 0xA2AA0;
  if ( (*((_DWORD *)this + 16) & 0xF3FC0) != 0 )
    v13 = 12;
  else
    v13 = 36;
  v41 = v6;
  v14 = &v11[v7 + v6 + v5];
  RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
  v15 = (__int64 *)*((_QWORD *)this + 1);
  if ( v15 )
    v16 = *v15;
  else
    v16 = 0i64;
  v17 = SslComputeFinishedHash(
          v16,
          *(_QWORD *)(*((_QWORD *)this + 11) + 16i64),
          *((_QWORD *)this + 74),
          v14,
          v13,
          2 - (unsigned int)(v12 != 0));
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
  if ( v17 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 901, v17, 0x50u);
    return v17;
  }
  if ( !*((_BYTE *)this + 340) )
  {
    memcpy_0((char *)this + 341, v14, v13);
    *((_BYTE *)this + 340) = 1;
    if ( *((_QWORD *)this + 103) )
    {
      v31 = *((_QWORD *)this + 11);
      if ( v31 )
      {
        RtlAcquireResourceShared((PRTL_RESOURCE)(v31 + 72), 1u);
        v32 = *((_QWORD *)this + 11);
        v33 = *(_QWORD *)(v32 + 16);
        if ( !v33 )
        {
LABEL_58:
          RtlReleaseResource((PRTL_RESOURCE)(v32 + 72));
          goto LABEL_24;
        }
        v34 = (void *)(*(__int64 (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 8i64))(this, 32i64);
        if ( !v34 )
        {
          v32 = *((_QWORD *)this + 11);
          goto LABEL_58;
        }
        v35 = (__int64 *)*((_QWORD *)this + 1);
        if ( v35 )
          v36 = *v35;
        else
          v36 = 0i64;
        v37 = SslExportKeyingMaterial(v36, v33, "EXPORTER-Token-Binding", (char *)this + 272, 64, 0i64, 0, v34, 32, 0);
        RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
        if ( v37 )
          goto LABEL_65;
        v38 = *((_QWORD *)this + 104);
        if ( v38 )
        {
          v39 = *(void **)(v38 + 8);
          if ( v39 )
          {
            memset(v39, 0, 0x20ui64);
            (*(void (__fastcall **)(CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 16i64))(
              this,
              *(_QWORD *)(*((_QWORD *)this + 104) + 8i64));
            v38 = *((_QWORD *)this + 104);
          }
        }
        else
        {
          v38 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 8i64))(this, 16i64);
          *((_QWORD *)this + 104) = v38;
          if ( !v38 )
          {
LABEL_65:
            memset(v34, 0, 0x20ui64);
            (*(void (__fastcall **)(CSsl3TlsContext *, void *))(*(_QWORD *)this + 16i64))(this, v34);
            goto LABEL_24;
          }
        }
        *(_DWORD *)v38 = 32;
        *(_QWORD *)(*((_QWORD *)this + 104) + 8i64) = v34;
      }
    }
  }
LABEL_24:
  if ( v12 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 65i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    v18 = v13;
    memcpy_0((char *)this + 377, v14, v13);
    *((_DWORD *)this + 104) = v13;
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 66i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    v18 = v13;
    memcpy_0((char *)this + 420, v14, v13);
    *((_DWORD *)this + 114) = v13;
  }
  v20 = *((_WORD *)this + 110);
  v21 = &v11[v41 + v45];
  v22 = *((_BYTE *)this + 233) == 0;
  *v21 = 20;
  if ( v22 )
  {
    v23 = v13;
    v24 = 4i64;
    v25 = HIWORD(v13);
  }
  else
  {
    v21[5] = v20;
    v24 = 12i64;
    v21[4] = HIBYTE(v20);
    v23 = v13;
    v25 = HIWORD(v13);
    v21[11] = v13;
    *(_WORD *)(v21 + 7) = 0;
    v21[6] = 0;
    *(_WORD *)(v21 + 9) = BYTE2(v13);
  }
  v21[1] = v25;
  v21[3] = v23;
  v21[2] = 0;
  if ( v14 )
    memcpy_0(&v21[v24], v14, v18);
  if ( *((_BYTE *)this + 233) )
    ++*((_WORD *)this + 110);
  if ( !v42 )
  {
    if ( !v12 )
      goto LABEL_37;
LABEL_41:
    v26 = v43;
    goto LABEL_38;
  }
  if ( !v12 )
    goto LABEL_41;
LABEL_37:
  v26 = v43;
  LOBYTE(v19) = 1;
  v27 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, _BYTE *, _QWORD, __int64))(*(_QWORD *)this + 504i64))(
          this,
          v21,
          v43 + v13,
          v19);
  v28 = v27;
  if ( v27 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 1000, v27, 0x50u);
    return v28;
  }
LABEL_38:
  if ( !*((_BYTE *)this + 233) )
    return CSsl3TlsContext::WrapMessage((__int64)this, (__int64)a2, 22, v26 + v13);
  *((_DWORD *)a2 + 1) += v44 + v45 + v26 + v13;
  v40 = *((_WORD *)this + 17);
  v11[2] = v40;
  v11[1] = HIBYTE(v40);
  v11[12] = v26 + v13;
  v11[11] = (unsigned __int16)(v26 + v13) >> 8;
  result = 0i64;
  *v11 = 22;
  return result;
}
// 1800093BF: variable 'v19' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180098538: using guessed type __int64 __fastcall SslComputeFinishedHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);
// 180098560: using guessed type __int64 __fastcall SslExportKeyingMaterial(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD, _QWORD, _DWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180009470) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::WrapMessage(__int64 a1, __int64 a2, int a3, unsigned int a4)
{
  _BYTE *v5; // rbx
  unsigned int v6; // r15d
  unsigned int v10; // ecx
  int v11; // r8d
  __int16 v12; // bp
  __int16 v13; // r10
  unsigned int v14; // r11d
  unsigned int v15; // ecx
  char v16; // al
  int v17; // r14d
  char v18; // cl
  __int64 result; // rax
  unsigned int v20; // r9d
  unsigned int v21; // ecx
  __int64 v22; // rdx
  __int64 *v23; // rax
  __int64 v24; // r10
  unsigned int v25; // eax
  unsigned int v26; // [rsp+50h] [rbp-48h]
  unsigned int v27; // [rsp+A0h] [rbp+8h] BYREF
  unsigned int v28; // [rsp+A8h] [rbp+10h]
  __int16 v29; // [rsp+B8h] [rbp+20h]

  v5 = (_BYTE *)(*(_QWORD *)(a2 + 8) + *(unsigned int *)(a2 + 4));
  v6 = 0;
  v10 = a4;
  v11 = *(_DWORD *)(a1 + 60);
  v12 = *(_WORD *)(a1 + 34);
  v13 = *(_WORD *)(a1 + 32) & 4;
  if ( v13 )
  {
    v20 = *(_DWORD *)(a1 + 52);
    v21 = a4 + *(_DWORD *)(a1 + 48);
    v14 = *(_DWORD *)(a1 + 44);
    v28 = v14;
    if ( v20 )
    {
      if ( (*(_BYTE *)(a1 + 56) & 1) != 0 )
        v20 -= v21 % v20;
      v21 += v20;
    }
    v10 = v14 + v21;
  }
  else
  {
    v14 = 0;
    v28 = 0;
  }
  v15 = v11 + v10;
  v16 = v12;
  v17 = v11;
  v29 = v12;
  v27 = v15;
  if ( v15 > *(_DWORD *)a2 )
    return 122i64;
  if ( !v13 || (v22 = *(_QWORD *)(a1 + 8)) == 0 || !*(_DWORD *)(v22 + 28) )
  {
    v18 = *(_BYTE *)(a1 + 233);
    if ( !v18 )
      ++*(_QWORD *)(a1 + 184);
    goto LABEL_7;
  }
  if ( *(_QWORD *)(a1 + 152) )
  {
LABEL_19:
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_Di(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xCu,
        (__int64)&WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids,
        a4,
        *(_QWORD *)(a1 + 184));
      v15 = v27;
      v14 = v28;
    }
    v23 = *(__int64 **)(a1 + 8);
    if ( v23 )
      v24 = *v23;
    else
      v24 = 0i64;
    v25 = SslEncryptPacket(v24, *(_QWORD *)(a1 + 152), &v5[v17 + v14], a4, v5, v15, &v27, *(_QWORD *)(a1 + 184), a3, 0);
    v6 = v25;
    if ( v25 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids, v25);
      v18 = *(_BYTE *)(a1 + 233);
      v6 = -2146893015;
    }
    else
    {
      v18 = *(_BYTE *)(a1 + 233);
      if ( !v18 )
        ++*(_QWORD *)(a1 + 184);
    }
    v16 = v29;
LABEL_7:
    *v5 = a3;
    v5[1] = HIBYTE(v12);
    v5[2] = v16;
    if ( v18 )
    {
      v5[3] = *(_BYTE *)(a1 + 191);
      v5[4] = *(_BYTE *)(a1 + 190);
      v5[5] = *(_BYTE *)(a1 + 189);
      v5[6] = *(_BYTE *)(a1 + 188);
      v5[7] = *(_BYTE *)(a1 + 187);
      v5[8] = *(_BYTE *)(a1 + 186);
      v5[9] = *(_BYTE *)(a1 + 185);
      v5[10] = *(_BYTE *)(a1 + 184);
      v5[11] = (unsigned __int16)(v27 - v17) >> 8;
      v5[12] = v27 - v17;
      *(_QWORD *)(a1 + 184) ^= (*(_QWORD *)(a1 + 184) ^ (*(_QWORD *)(a1 + 184) + 1i64)) & 0xFFFFFFFFFFFFi64;
    }
    else
    {
      v5[3] = (unsigned __int16)(v27 - v17) >> 8;
      v5[4] = v27 - v17;
    }
    *(_DWORD *)(a2 + 4) += v27;
    return v6;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids);
  result = RemotelyGetUserKeys((struct CSslContext *)a1, 2u);
  v26 = result;
  if ( !(_DWORD)result )
  {
    v15 = v27;
    v14 = v28;
    goto LABEL_19;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    WPP_SF_D(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      11i64,
      &WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids,
      (unsigned int)result);
    return v26;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098508: using guessed type __int64 __fastcall SslEncryptPacket(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180009670) ----------------------------------------------------
__int64 __fastcall CTlsExtClient::GetClientHelloExtensionsLength(CTlsExtClient *this, unsigned int *a2)
{
  __int64 v4; // rcx
  unsigned int v5; // edi
  __int64 v6; // rsi
  int v7; // edx
  int v8; // r8d
  int v9; // edx
  const unsigned __int16 *v10; // rax
  __int64 result; // rax
  __int64 v12; // rcx
  __int64 v13; // rax
  int v14; // ecx
  unsigned __int16 *v15; // r8
  unsigned __int16 *v16; // rax
  __int64 v17; // rcx
  __int64 v18; // rcx
  unsigned int v19; // edx
  __int64 v20; // rax
  __int64 v21; // r8
  unsigned int v22; // ecx
  __int64 v23; // rax
  __int64 v24; // rax
  unsigned __int16 *v25; // rax
  int v26; // ecx
  int v27; // r9d
  unsigned __int8 *v28; // rax
  __int64 v29; // [rsp+30h] [rbp+8h] BYREF

  v4 = *((_QWORD *)this + 7);
  v5 = 0;
  v6 = *(_QWORD *)(v4 + 80);
  v7 = *((_DWORD *)this + 5) + 5;
  v29 = 0i64;
  *((_BYTE *)this + 26) = 1;
  v8 = *(_DWORD *)(v4 + 416);
  v9 = v8 + v7;
  *((_DWORD *)this + 5) = v9;
  if ( (*(_DWORD *)(v4 + 64) & 0x2A88) == 0 && (*(_BYTE *)(v4 + 64) & 0x20) != 0 )
  {
    if ( *(_BYTE *)(*((_QWORD *)this + 1) + 553i64) && v8 )
      v5 = v9 + 2;
    else
      *((_BYTE *)this + 26) = 0;
    *((_DWORD *)this + 5) = v5;
    *a2 = v5;
    return 0i64;
  }
  if ( (*(_DWORD *)(v4 + 64) & 0xA2A80) != 0 )
  {
    if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 320i64))(v4) )
    {
      v10 = (const unsigned __int16 *)(*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 7) + 320i64))(*((_QWORD *)this + 7));
      result = CTlsExtClient::BuildServerNameString(this, v10);
      if ( (_DWORD)result )
        return result;
      v12 = *((_QWORD *)this + 5);
      if ( v12 )
      {
        v13 = -1i64;
        do
          ++v13;
        while ( *(_BYTE *)(v12 + v13) );
        *((_DWORD *)this + 12) = v13;
        *((_DWORD *)this + 5) += v13 + 9;
      }
    }
    v14 = *((_DWORD *)this + 5);
    if ( (*(_DWORD *)(v6 + 160) & 0x700) != 0 )
    {
      v14 += 9;
      *((_BYTE *)this + 24) = 1;
      *((_DWORD *)this + 5) = v14;
    }
    v15 = (unsigned __int16 *)*((_QWORD *)this + 7);
    if ( v15[460] )
    {
      *((_BYTE *)this + 32) = 1;
      *((_DWORD *)this + 5) = v14 + 2 * (v15[460] + 6);
    }
    v16 = (unsigned __int16 *)(*(__int64 (__fastcall **)(unsigned __int16 *))(*(_QWORD *)v15 + 320i64))(v15);
    if ( (unsigned int)CheckUserMappingTarget(v16) && (*(_QWORD *)(v6 + 872) || *(_QWORD *)(v6 + 880)) )
    {
      *((_DWORD *)this + 5) += 6;
      *((_BYTE *)this + 25) = 1;
    }
    v17 = *((_QWORD *)this + 7);
    if ( *(_BYTE *)(v17 + 925) )
      *((_DWORD *)this + 5) += 2 * *(unsigned __int16 *)(v17 + 474) + 6;
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v17 + 224i64))(v17, &v29);
    if ( v29 )
      *((_DWORD *)this + 5) += *(_DWORD *)(v29 + 432) + 4;
    v18 = *((_QWORD *)this + 1);
    v19 = *((_DWORD *)this + 5);
    v20 = *(_QWORD *)(v18 + 784);
    if ( v20 )
    {
      v19 += *(unsigned __int16 *)(v20 + 4) + 6;
      *((_DWORD *)this + 5) = v19;
    }
    if ( CSslGlobals::m_fDisableClientExtendedMS )
    {
      v24 = *(_QWORD *)(v18 + 120);
      if ( !v24 || !CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
        goto LABEL_23;
      *(_WORD *)(v24 + 66) |= 8u;
    }
    else
    {
      *(_BYTE *)(*((_QWORD *)this + 7) + 1344i64) = 1;
      *((_DWORD *)this + 5) += 4;
    }
    v19 = *((_DWORD *)this + 5);
LABEL_23:
    v21 = *((_QWORD *)this + 7);
    v22 = v19;
    if ( *(_BYTE *)(v21 + 233) )
    {
      v25 = *(unsigned __int16 **)(v21 + 800);
      if ( v25 )
      {
        v26 = *v25;
        v27 = 7;
        v28 = *(unsigned __int8 **)(v21 + 1336);
        if ( v28 )
          v27 = *v28 + 7;
        v22 = v27 + v19 + v26;
        *((_DWORD *)this + 5) = v22;
      }
    }
    v23 = *(_QWORD *)(v21 + 816);
    if ( v23 )
    {
      v22 += *(unsigned __int8 *)(v23 + 2) + 7;
      *((_DWORD *)this + 5) = v22;
    }
    if ( v22 )
    {
      v22 += 2;
      *((_DWORD *)this + 5) = v22;
    }
    *a2 = v22;
  }
  return 0i64;
}
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 1800927B8: using guessed type int CSslGlobals::m_fDisableClientExtendedMS;

//----- (000000018000988C) ----------------------------------------------------
__int64 __fastcall CheckUserMappingTarget(unsigned __int16 *a1)
{
  const wchar_t *v1; // rbx
  int v4; // edx
  CCipherMill *v5; // rcx
  __int64 v6; // rdx
  __int64 v7; // rax
  unsigned __int16 *v8; // rbp
  unsigned __int16 *v9; // rdi
  wchar_t *v10; // rdx
  __int64 v11; // rax
  const wchar_t *i; // rcx
  wchar_t v13; // ax

  v1 = (const wchar_t *)g_pszDomainList;
  if ( !a1 || !g_pszDomainList )
    return 0i64;
  v4 = *(unsigned __int16 *)g_pszDomainList - 42;
  if ( *(_WORD *)g_pszDomainList == 42 )
    v4 = *((unsigned __int16 *)g_pszDomainList + 1);
  if ( !v4 )
  {
    v5 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      return 1i64;
    v6 = 18i64;
    goto LABEL_33;
  }
  v7 = -1i64;
  do
    ++v7;
  while ( a1[v7] );
  v8 = &a1[v7];
  if ( !*(_WORD *)g_pszDomainList )
    return 0i64;
  while ( 1 )
  {
    v9 = v8 - 1;
    v10 = wcschr(v1, 0x2Cu);
    if ( !v10 )
    {
      v11 = -1i64;
      do
        ++v11;
      while ( v1[v11] );
      v10 = (wchar_t *)&v1[v11];
    }
    for ( i = v10 - 1; i >= v1 && v9 >= a1 && *i == *v9; --i )
      --v9;
    if ( i == v1 - 1 && (v9 == a1 - 1 || *v9 == 46) )
      break;
    v13 = *v10;
    if ( *v10 == 44 )
    {
      v1 = v10 + 1;
      v13 = v10[1];
    }
    else
    {
      v1 = v10;
    }
    if ( !v13 )
      return 0i64;
  }
  v5 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    v6 = 19i64;
LABEL_33:
    WPP_SF_(*((_QWORD *)v5 + 2), v6, &WPP_652d1bd98c7033c24f7b4105215d66be_Traceguids);
  }
  return 1i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (00000001800098E4) ----------------------------------------------------
__int64 __fastcall CTlsExtClient::BuildServerNameString(CTlsExtClient *this, const unsigned __int16 *a2)
{
  DWORD LastError; // esi
  __int64 v4; // r12
  __int64 v5; // rax
  size_t v6; // r15
  unsigned __int64 v7; // rdi
  CTlsExtClient **v8; // rbx
  unsigned __int64 v9; // rcx
  __int64 v10; // rcx
  signed __int64 v11; // rcx
  void *v12; // rsp
  void *v13; // rsp
  _BYTE *v14; // r13
  const WCHAR *v15; // rdi
  __int16 v16; // cx
  CTlsExtClient **v17; // rdx
  const WCHAR *v18; // rax
  HLOCAL v19; // rax
  _DWORD *v21; // rax
  __int64 v22; // [rsp+0h] [rbp-40h] BYREF
  CTlsExtClient *v23; // [rsp+40h] [rbp+0h] BYREF
  __int64 v24[5]; // [rsp+48h] [rbp+8h] BYREF

  v23 = this;
  LastError = 0;
  if ( a2 && *a2 )
  {
    if ( IsIpAddress(a2) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_S(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x10u,
          (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
          a2);
    }
    else
    {
      v4 = -1i64;
      v5 = -1i64;
      do
        ++v5;
      while ( a2[v5] );
      v6 = 2 * v5 + 2;
      if ( v6 <= 0x4000 )
      {
        v7 = 3 * v6;
        v8 = 0i64;
        if ( 3 * v6 )
        {
          if ( v7 <= g_ulMaxStackAllocSize )
          {
            v9 = v7 + g_ulAdditionalProbeSize + 8;
            if ( v9 >= v7 )
            {
              if ( (unsigned int)VerifyStackAvailable(v9) )
              {
                v10 = v7 + 23;
                if ( v7 + 23 <= v7 + 8 )
                  v10 = 0xFFFFFFFFFFFFFF0i64;
                v11 = v10 & 0xFFFFFFFFFFFFFFF0ui64;
                v12 = alloca(v11);
                v13 = alloca(v11);
                v8 = &v23;
                if ( &v22 != (__int64 *)-64i64 )
                {
                  LODWORD(v23) = 1801679955;
                  v8 = (CTlsExtClient **)v24;
                  if ( v24 )
                    goto LABEL_15;
                }
              }
            }
          }
        }
        if ( v7 + 8 >= v7 )
        {
          v21 = (_DWORD *)((__int64 (*)(void))g_pfnAllocate)();
          if ( !v21 )
            return 14;
          *v21 = 1885431112;
          v8 = (CTlsExtClient **)(v21 + 2);
        }
        if ( v8 )
        {
LABEL_15:
          v14 = (char *)v8 + v6;
          v15 = (const WCHAR *)v8;
          memcpy_0(v8, a2, v6);
          v16 = *(_WORD *)v8;
          v17 = v8;
          while ( v16 )
          {
            v17 = (CTlsExtClient **)((char *)v17 + 2);
            v18 = (const WCHAR *)v17;
            if ( v16 != 47 )
              v18 = v15;
            v16 = *(_WORD *)v17;
            v15 = v18;
          }
          if ( WideCharToMultiByte(0xFDE9u, 0, v15, -1, (LPSTR)v8 + v6, 2 * v6, 0i64, 0i64) )
          {
            if ( *v14 )
            {
              do
                ++v4;
              while ( v14[v4] );
              v19 = SPExternalAlloc((int)v4 + 1);
              *((_QWORD *)v23 + 5) = v19;
              if ( v19 )
                memcpy_0(v19, (char *)v8 + v6, (unsigned int)(v4 + 1));
              else
                LastError = 14;
            }
          }
          else
          {
            LastError = GetLastError();
          }
          if ( v8 )
          {
            if ( *((_DWORD *)v8 - 2) == 1885431112 )
              ((void (*)(void))g_pfnFree)();
          }
          return LastError;
        }
        return 14;
      }
    }
  }
  return 0i64;
}
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;

//----- (0000000180009AE4) ----------------------------------------------------
__int64 __fastcall CopyTlsParameters(
        struct _TLS_PARAMETERS *a1,
        unsigned int a2,
        int a3,
        char a4,
        struct _TLS_PARAMETERS **a5,
        unsigned int *a6)
{
  struct _TLS_PARAMETERS **v6; // r14
  char v7; // bl
  unsigned int *v8; // rdi
  unsigned int v10; // r15d
  struct _TLS_PARAMETERS *v11; // rsi
  struct _TLS_PARAMETERS *v12; // rax
  __int64 v13; // rdx
  char *v14; // rdi
  signed __int64 v15; // rcx
  unsigned __int64 v16; // r9
  __int64 v17; // rdx
  unsigned int v18; // ebx
  int v19; // eax
  unsigned int v20; // r13d
  int v21; // eax
  HLOCAL v22; // rax
  __int64 v23; // rcx
  __int64 v24; // rsi
  char v25; // r9
  __int64 v26; // r14
  __int64 v27; // r9
  __int64 v28; // rdx
  unsigned int v29; // eax
  unsigned int v30; // ecx
  __int64 v31; // rbx
  unsigned int v32; // edx
  unsigned int v33; // r14d
  __int128 v35; // xmm1
  __int64 v36; // rax
  HLOCAL v37; // rax
  int v38; // eax
  unsigned int v39; // esi
  int v40; // r14d
  __int64 v41; // rcx
  unsigned int v42; // eax
  HLOCAL v43; // rax
  unsigned int v44; // eax
  int v45; // edx
  __int64 v46; // rcx
  struct _UNICODE_STRING *v47; // r8
  unsigned int v48; // eax
  int v50; // [rsp+34h] [rbp-A5h]
  unsigned int v51; // [rsp+38h] [rbp-A1h]
  int v52; // [rsp+3Ch] [rbp-9Dh]
  int v53; // [rsp+40h] [rbp-99h]
  __int64 v54; // [rsp+48h] [rbp-91h]
  signed __int64 v55; // [rsp+50h] [rbp-89h]
  struct _TLS_PARAMETERS *v56; // [rsp+58h] [rbp-81h]
  __int128 v58; // [rsp+78h] [rbp-61h] BYREF
  __int128 v59; // [rsp+88h] [rbp-51h]
  __int64 v60; // [rsp+98h] [rbp-41h]
  __int128 v61; // [rsp+A0h] [rbp-39h] BYREF
  __int128 v62; // [rsp+B0h] [rbp-29h]
  __int128 v63; // [rsp+C0h] [rbp-19h]

  v6 = a5;
  v7 = a4;
  v8 = a6;
  v10 = a2;
  v11 = a1;
  if ( !a2 )
    return 0i64;
  if ( a5 && a6 && (a1 || a3) && a2 <= 0x10 )
  {
    v12 = (struct _TLS_PARAMETERS *)SPExternalAlloc(40 * a2);
    v56 = v12;
    if ( v12 )
    {
      v13 = 0i64;
      v53 = 0;
      if ( !v10 )
      {
LABEL_45:
        v18 = 0;
        goto LABEL_46;
      }
      v14 = (char *)v12 + 24;
      v15 = v11 - v12;
      v55 = v11 - v12;
      while ( 1 )
      {
        v60 = 0i64;
        v58 = 0i64;
        v59 = 0i64;
        if ( v7 )
        {
          if ( a3 )
          {
            v16 = (unsigned int)(a3 + 24 * v13);
            v17 = 24i64;
          }
          else
          {
            v16 = (unsigned __int64)v11 + 40 * v13;
            v17 = 40i64;
          }
          v18 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int128 *, unsigned __int64))(LsaTable + 80))(
                  0i64,
                  v17,
                  &v58,
                  v16);
          if ( v18 )
            goto LABEL_71;
          v7 = a4;
        }
        else
        {
          v35 = *(_OWORD *)&v14[v15 - 8];
          v58 = *(_OWORD *)&v14[v15 - 24];
          v60 = *(_QWORD *)&v14[v15 + 8];
          v59 = v35;
        }
        if ( (_DWORD)v58 )
        {
          if ( (unsigned int)v58 > 0x10 )
            goto LABEL_70;
          v37 = SPExternalAlloc(16 * (int)v58);
          *((_QWORD *)v14 - 2) = v37;
          if ( !v37 )
            goto LABEL_82;
          v38 = v58;
          v39 = 0;
          *((_DWORD *)v14 - 6) = v58;
          if ( v38 )
          {
            v40 = 0;
            do
            {
              v41 = 16i64 * v39;
              v42 = a3
                  ? Wow64CopyUnicodeString(v40 + DWORD1(v58), (struct _UNICODE_STRING *)(v41 + *((_QWORD *)v14 - 2)))
                  : CopyUnicodeString(
                      v7,
                      (struct _UNICODE_STRING *)(v41 + *((_QWORD *)&v58 + 1)),
                      (struct _UNICODE_STRING *)(v41 + *((_QWORD *)v14 - 2)));
              v18 = v42;
              if ( v42 )
                goto LABEL_71;
              v7 = a4;
              ++v39;
              v40 += 8;
            }
            while ( v39 < (unsigned int)v58 );
          }
        }
        v19 = DWORD2(v58);
        v20 = HIDWORD(v58);
        if ( !a3 )
          v19 = v59;
        *((_DWORD *)v14 - 2) = v19;
        v21 = DWORD1(v59);
        if ( !a3 )
          v20 = DWORD1(v59);
        if ( v20 )
          break;
LABEL_41:
        if ( !a3 )
          v21 = v60;
        v13 = (unsigned int)(v53 + 1);
        *((_DWORD *)v14 + 2) = v21;
        v14 += 40;
        v53 = v13;
        if ( (unsigned int)v13 >= v10 )
        {
          v12 = v56;
          v8 = a6;
          v6 = a5;
          goto LABEL_45;
        }
        v15 = v55;
        v7 = a4;
        v11 = a1;
      }
      if ( v20 > 0x10 )
      {
LABEL_70:
        v18 = -2146892963;
        goto LABEL_71;
      }
      v22 = SPExternalAlloc(48 * v20);
      *(_QWORD *)v14 = v22;
      if ( v22 )
      {
        v23 = 0i64;
        *((_DWORD *)v14 - 1) = v20;
        v50 = 0;
        v24 = 0i64;
        while ( 1 )
        {
          v25 = a4;
          v26 = *(_QWORD *)v14;
          v54 = *(_QWORD *)v14;
          v61 = 0i64;
          v62 = 0i64;
          v63 = 0i64;
          if ( a4 )
          {
            if ( a3 )
            {
              v27 = (unsigned int)(v59 + 28 * v23);
              v28 = 28i64;
            }
            else
            {
              v27 = *((_QWORD *)&v59 + 1) + 48 * v23;
              v28 = 48i64;
            }
            v18 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int128 *, __int64))(LsaTable + 80))(
                    0i64,
                    v28,
                    &v61,
                    v27);
            if ( v18 )
              goto LABEL_71;
            LODWORD(v23) = v50;
            v25 = a4;
          }
          else
          {
            v36 = *(_QWORD *)&v14[v55];
            v61 = *(_OWORD *)(v36 + v24);
            v62 = *(_OWORD *)(v36 + v24 + 16);
            v63 = *(_OWORD *)(v36 + v24 + 32);
          }
          if ( a3 )
            v29 = Wow64CopyUnicodeString((int)v59 + 4 + 28 * (int)v23, (struct _UNICODE_STRING *)(v24 + v26 + 8));
          else
            v29 = CopyUnicodeString(
                    v25,
                    (struct _UNICODE_STRING *)(48i64 * (unsigned int)v23 + *((_QWORD *)&v59 + 1) + 8i64),
                    (struct _UNICODE_STRING *)(v24 + v26 + 8));
          v18 = v29;
          if ( v29 )
            goto LABEL_71;
          v30 = DWORD2(v62);
          v31 = v26;
          if ( !a3 )
            v30 = HIDWORD(v63);
          *(_DWORD *)(v24 + v26 + 44) = v30;
          v32 = DWORD1(v62);
          if ( !a3 )
            v32 = DWORD2(v63);
          *(_DWORD *)(v24 + v26 + 40) = v32;
          *(_DWORD *)(v24 + v26) = v61;
          if ( v30 )
          {
            if ( v32 > v30 )
              goto LABEL_70;
          }
          v33 = HIDWORD(v61);
          if ( !a3 )
            v33 = DWORD2(v62);
          if ( v33 )
          {
            if ( v33 > 0x10 )
              goto LABEL_70;
            v43 = SPExternalAlloc(16 * v33);
            *(_QWORD *)(v24 + v31 + 32) = v43;
            if ( v43 )
            {
              v44 = 0;
              *(_DWORD *)(v24 + v31 + 24) = v33;
              v45 = 0;
              v51 = 0;
              v52 = 0;
              while ( 1 )
              {
                v46 = 16i64 * v44;
                v47 = (struct _UNICODE_STRING *)(v46 + *(_QWORD *)(v24 + v31 + 32));
                v48 = a3
                    ? Wow64CopyUnicodeString(v45 + (int)v62, v47)
                    : CopyUnicodeString(a4, (struct _UNICODE_STRING *)(v46 + v63), v47);
                v18 = v48;
                if ( v48 )
                  goto LABEL_71;
                v44 = v51 + 1;
                v31 = v54;
                v45 = v52 + 8;
                v51 = v44;
                v52 += 8;
                if ( v44 >= v33 )
                  goto LABEL_39;
              }
            }
            break;
          }
LABEL_39:
          v24 += 48i64;
          v23 = (unsigned int)(v50 + 1);
          v50 = v23;
          if ( (unsigned int)v23 >= v20 )
          {
            v21 = DWORD1(v59);
            goto LABEL_41;
          }
        }
      }
LABEL_82:
      v18 = -2146893056;
LABEL_71:
      FreeTlsParameters(v56, v10);
      v8 = a6;
      v6 = a5;
    }
    else
    {
      v18 = -2146893056;
    }
  }
  else
  {
    v18 = -2146892963;
  }
  v10 = 0;
  v12 = 0i64;
LABEL_46:
  *v6 = v12;
  *v8 = v10;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v18 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x44u,
      (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
      v18,
      v18);
  }
  return v18;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180009E8C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::AllocateOutputBuffer(CSsl3TlsContext *this, struct SPBuffer *a2, unsigned int a3)
{
  HLOCAL Memory; // rax

  if ( *((_QWORD *)a2 + 1) )
  {
    if ( *(_DWORD *)a2 >= a3 )
      goto LABEL_3;
    *((_DWORD *)a2 + 1) = a3;
    return 2148074273i64;
  }
  else
  {
    *(_DWORD *)a2 = a3;
    Memory = CSslContext::GetMemory(this, a3);
    *((_QWORD *)a2 + 1) = Memory;
    if ( Memory )
    {
LABEL_3:
      *((_DWORD *)a2 + 1) = 0;
      return 0i64;
    }
    return 14i64;
  }
}

//----- (0000000180009ED4) ----------------------------------------------------
__int64 __fastcall GetEphemBlobFromKey(
        __int64 a1,
        __int64 a2,
        const unsigned __int16 *a3,
        unsigned int *a4,
        unsigned __int8 **a5)
{
  unsigned int v9; // ebx
  unsigned __int8 *v10; // rax
  unsigned int v11; // edi

  v9 = SslExportKey(a1, a2, a3);
  if ( v9 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_8452d3335a5c3be980705cc51c40b5db_Traceguids, v9);
    return v9;
  }
  else
  {
    v10 = (unsigned __int8 *)SPExternalAlloc(*a4);
    *a5 = v10;
    if ( v10 )
    {
      v11 = SslExportKey(a1, a2, a3);
      if ( v11 )
      {
        SPExternalFree(*a5);
        *a5 = 0i64;
      }
      return v11;
    }
    else
    {
      return 14i64;
    }
  }
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098528: using guessed type __int64 __fastcall SslExportKey(_QWORD, _QWORD, _QWORD);

//----- (0000000180009F90) ----------------------------------------------------
__int64 __fastcall CSslContextManager::InstantiateClientContext(
        CSslContextManager *this,
        const unsigned __int16 *a2,
        struct CCredentialGroup *a3,
        struct CSslParentContext **a4,
        __int64 a5)
{
  CSessionCacheManager *v5; // rbx
  unsigned __int16 *v8; // rdi
  unsigned int v9; // eax
  __int64 v10; // r8
  struct CSessionCacheItem *v11; // rsi
  char v12; // r15
  CCipherMill *v13; // rcx
  unsigned int v14; // ebx
  __int64 v15; // rcx
  int v16; // ebx
  unsigned __int64 v17; // r12
  __int64 v18; // rbp
  unsigned int v19; // ebp
  wchar_t *v20; // rax
  CSsl3TlsClientContext *v21; // rax
  CTls13ClientContext *v22; // rax
  CTls13ClientContext *v23; // rdi
  unsigned int v24; // esi
  _QWORD *v25; // rax
  int v26; // ecx
  struct CSslParentContext **v27; // rax
  struct CSslParentContext *v28; // r8
  const char *v30; // rax
  unsigned __int8 *v31; // rax
  CTls13ClientContext *v32; // rbp
  struct CTlsRecord *Record; // rax
  void *v34; // rcx
  struct CSessionCacheItem *v35; // [rsp+60h] [rbp+8h] BYREF
  struct CSslParentContext **v36; // [rsp+78h] [rbp+20h]

  v36 = a4;
  v35 = this;
  v5 = CSessionCacheManager::m_pSessionCacheManager;
  v8 = 0i64;
  v9 = CSessionCacheManager::ComputeClientCacheIndex(CSessionCacheManager::m_pSessionCacheManager, a2);
  if ( CSessionCacheTable::LookupCacheByName(
         (CSessionCacheTable *)(*((_QWORD *)v5 + 5) + 152i64 * (v9 / *((_DWORD *)v5 + 13))),
         v9 % *((_DWORD *)v5 + 13),
         a2,
         a3,
         &v35) )
  {
    v11 = v35;
    v12 = 1;
  }
  else
  {
    v11 = 0i64;
    v35 = 0i64;
    v12 = 0;
  }
  v13 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    v30 = "FOUND";
    if ( !v12 )
      v30 = "NO ENTRY";
    WPP_SF_Ss(*((_QWORD *)WPP_GLOBAL_Control + 2), (__int64)"NO ENTRY", v10, a2, v30);
  }
  if ( !v12 )
  {
    CSessionCacheManager::AcquireCacheTableLock((__int64)v13, a2, 0i64);
    v14 = CSessionCacheManager::CacheRetrieveNewClientItem(CSessionCacheManager::m_pSessionCacheManager, a2, &v35);
    CSessionCacheManager::ReleaseCacheTableLock(v15, a2, 0i64);
    if ( v14 )
      return v14;
    v11 = v35;
  }
  v16 = *((_DWORD *)a3 + 38) & 0x800A2AAA;
  v17 = a5 & 0x100000000i64;
  if ( (a5 & 0x100000000i64) != 0 && (*((_DWORD *)a3 + 38) & 0x800A0AAA) != 0 )
    return 2148074333i64;
  if ( (*((_DWORD *)a3 + 38) & 0xA2AA0) == 0 )
    return 2148074289i64;
  if ( a2 )
  {
    v18 = -1i64;
    do
      ++v18;
    while ( a2[v18] );
    v19 = v18 + 1;
    v20 = (wchar_t *)SPExternalAlloc(2 * v19);
    v8 = v20;
    if ( !v20 )
      return 14i64;
    wcscpy_s(v20, v19, a2);
  }
  if ( (v16 & 0x2AA0) != 0 && (v16 & 0xA0000) != 0 )
  {
    if ( (a5 & 0x400) != 0 )
      v16 &= 0xF0000u;
    else
      v16 &= 0xFFF0FFFF;
  }
  if ( v12 && (*((_DWORD *)v11 + 42) & 0x2000) == 0 )
    v16 &= 0xFFFFCFFF;
  if ( (v16 & 0x2000) != 0 )
  {
    v31 = (unsigned __int8 *)SPExternalAlloc(v17 != 0 ? 1936 : 1952);
    v32 = (CTls13ClientContext *)v31;
    if ( v31 )
    {
      Record = CTlsRecord::MakeRecord(a5, v31 + 1856, (struct CSsl3TlsContext *)v31);
      if ( Record )
      {
        v22 = CTls13ClientContext::CTls13ClientContext(v32, Record, v11, v16, v8);
        goto LABEL_20;
      }
      if ( v8 )
        SPExternalFree(v8);
      v34 = v32;
      goto LABEL_40;
    }
LABEL_43:
    if ( !v8 )
      return 14i64;
    v34 = v8;
LABEL_40:
    SPExternalFree(v34);
    return 14i64;
  }
  v21 = (CSsl3TlsClientContext *)SPExternalAlloc(0x558u);
  if ( !v21 )
    goto LABEL_43;
  v22 = CSsl3TlsClientContext::CSsl3TlsClientContext(v21, v11, v16, v8);
LABEL_20:
  v23 = v22;
  v24 = (*(__int64 (__fastcall **)(CTls13ClientContext *))(*(_QWORD *)v22 + 184i64))(v22);
  if ( !v24 )
  {
    v25 = SPExternalAlloc(0x28u);
    if ( v25 )
    {
      v25[1] = v23;
      *((_QWORD *)v23 + 16) = v25;
      v26 = (unsigned __int16)ConvertSchannelProtocolToSsl(v16);
      v27 = v36;
      *((_DWORD *)v23 + 9) = v26;
      *v27 = v28;
      return 0i64;
    }
    (**(void (__fastcall ***)(void *, _QWORD))v23)(v23, 0i64);
    v24 = 14;
  }
  SPExternalFree(v23);
  return v24;
}
// 18000A02C: variable 'v13' is possibly undefined
// 18000A04D: variable 'v15' is possibly undefined
// 18000A17D: variable 'v28' is possibly undefined
// 180034E7F: variable 'v10' is possibly undefined

//----- (000000018000A1D0) ----------------------------------------------------
HLOCAL __fastcall CSslContext::GetMemory(CSslContext *this, unsigned int a2)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(*((_QWORD *)this + 16) + 24i64);
  if ( v2 )
    return (HLOCAL)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 48i64))(v2);
  else
    return SPExternalAlloc(a2);
}

//----- (000000018000A1F4) ----------------------------------------------------
HLOCAL __fastcall SPExternalAlloc(unsigned int a1)
{
  if ( LsaTable )
    return (HLOCAL)(*(__int64 (**)(void))(LsaTable + 40))();
  else
    return LocalAlloc(0x40u, a1);
}
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018000A230) ----------------------------------------------------
NTSTATUS __fastcall GenerateHash(
        BCRYPT_ALG_HANDLE hAlgorithm,
        UCHAR *a2,
        unsigned __int8 *a3,
        ULONG a4,
        unsigned __int8 *a5,
        ULONG cbOutput)
{
  NTSTATUS result; // eax
  __int64 v11; // rdx
  ULONG v12; // r9d
  UCHAR *p_phHash; // rbx
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rax
  void *v16; // rsp
  NTSTATUS v17; // edi
  _DWORD *v18; // rax
  __int64 v19; // [rsp+0h] [rbp-40h] BYREF
  UCHAR pbOutput[4]; // [rsp+40h] [rbp+0h] BYREF
  BCRYPT_HASH_HANDLE phHash; // [rsp+48h] [rbp+8h] BYREF
  ULONG pcbResult; // [rsp+50h] [rbp+10h] BYREF

  phHash = 0i64;
  result = BCryptGetProperty(hAlgorithm, L"ObjectLength", pbOutput, 4u, &pcbResult, 0);
  if ( result )
    return result;
  v12 = *(_DWORD *)pbOutput;
  p_phHash = 0i64;
  if ( *(_DWORD *)pbOutput )
  {
    v11 = *(unsigned int *)pbOutput;
    if ( *(unsigned int *)pbOutput <= (unsigned __int64)g_ulMaxStackAllocSize )
    {
      v14 = *(unsigned int *)pbOutput + g_ulAdditionalProbeSize + 8;
      if ( v14 >= *(unsigned int *)pbOutput )
      {
        if ( !(unsigned int)VerifyStackAvailable(v14) )
        {
LABEL_22:
          v12 = *(_DWORD *)pbOutput;
          goto LABEL_23;
        }
        v12 = *(_DWORD *)pbOutput;
        v15 = (unsigned int)(*(_DWORD *)pbOutput + 8) + 15i64;
        if ( v15 <= (unsigned int)(*(_DWORD *)pbOutput + 8) )
          v15 = 0xFFFFFFFFFFFFFF0i64;
        v16 = alloca(v15 & 0xFFFFFFFFFFFFFFF0ui64);
        p_phHash = pbOutput;
        if ( &v19 != (__int64 *)-64i64 )
        {
          *(_DWORD *)pbOutput = 1801679955;
          p_phHash = (UCHAR *)&phHash;
          if ( &phHash )
          {
            v12 = *(_DWORD *)pbOutput;
            goto LABEL_11;
          }
          goto LABEL_22;
        }
      }
    }
  }
LABEL_23:
  if ( v12 + 8 >= v12 )
  {
    v18 = (_DWORD *)((__int64 (__fastcall *)(_QWORD, __int64))g_pfnAllocate)(v12 + 8, v11);
    if ( !v18 )
      return 14;
    *v18 = 1885431112;
    p_phHash = (UCHAR *)(v18 + 2);
    v12 = *(_DWORD *)pbOutput;
  }
  if ( !p_phHash )
    return 14;
LABEL_11:
  v17 = BCryptCreateHash(hAlgorithm, &phHash, p_phHash, v12, 0i64, 0, 0);
  if ( !v17 )
  {
    v17 = BCryptHashData(phHash, a2 + 272, 0x40u, 0);
    if ( !v17 )
    {
      v17 = BCryptHashData(phHash, a3, a4, 0);
      if ( !v17 )
        v17 = BCryptFinishHash(phHash, a5, cbOutput, 0);
    }
  }
  if ( phHash )
    BCryptDestroyHash(phHash);
  if ( p_phHash )
  {
    if ( *((_DWORD *)p_phHash - 2) == 1885431112 )
      ((void (__fastcall *)(UCHAR *))g_pfnFree)(p_phHash - 8);
  }
  return v17;
}
// 180034FB4: variable 'v11' is possibly undefined
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;

//----- (000000018000A418) ----------------------------------------------------
__int64 __fastcall VerifyStackAvailable(unsigned __int64 a1)
{
  InternalVerifyStackAvailable(a1);
  return 1i64;
}

//----- (000000018000A444) ----------------------------------------------------
signed __int64 __fastcall InternalVerifyStackAvailable(unsigned __int64 a1)
{
  __int64 v1; // rax
  signed __int64 result; // rax
  void *v3; // rsp

  v1 = a1 + 15;
  if ( a1 + 15 <= a1 )
    v1 = 0xFFFFFFFFFFFFFF0i64;
  result = v1 & 0xFFFFFFFFFFFFFFF0ui64;
  v3 = alloca(result);
  return result;
}

//----- (000000018000A498) ----------------------------------------------------
_BOOL8 __fastcall IsIpAddress(PCWSTR AddressString)
{
  USHORT Port[2]; // [rsp+20h] [rbp-A8h] BYREF
  ULONG ScopeId[3]; // [rsp+24h] [rbp-A4h] BYREF
  char v5[4]; // [rsp+30h] [rbp-98h] BYREF
  struct in_addr Address; // [rsp+34h] [rbp-94h] BYREF
  struct in6_addr v7; // [rsp+38h] [rbp-90h] BYREF

  memset_0(v5, 0, 0x80ui64);
  return RtlIpv4StringToAddressExW(AddressString, 1u, &Address, Port) >= 0
      || RtlIpv6StringToAddressExW(AddressString, &v7, ScopeId, Port) >= 0;
}
// 18000A498: using guessed type char var_98[4];
// 18000A498: using guessed type ULONG ScopeId[3];

//----- (000000018000A534) ----------------------------------------------------
void *__fastcall SetHandshakeHeader(__int64 a1, char a2, const void *a3, unsigned int a4, __int16 a5, int a6)
{
  void *result; // rax

  *(_BYTE *)a1 = a2;
  if ( a6 )
  {
    *(_BYTE *)(a1 + 5) = a5;
    *(_BYTE *)(a1 + 4) = HIBYTE(a5);
    result = (void *)HIWORD(a4);
    *(_BYTE *)(a1 + 9) = BYTE2(a4);
    *(_WORD *)(a1 + 7) = 0;
    *(_BYTE *)(a1 + 6) = 0;
    *(_BYTE *)(a1 + 11) = a4;
    *(_BYTE *)(a1 + 10) = BYTE1(a4);
  }
  else
  {
    result = (void *)HIWORD(a4);
  }
  *(_BYTE *)(a1 + 1) = (_BYTE)result;
  *(_BYTE *)(a1 + 3) = a4;
  *(_BYTE *)(a1 + 2) = BYTE1(a4);
  if ( a3 )
    return memcpy_0((void *)(a1 + 4 + (a6 != 0 ? 8 : 0)), a3, a4);
  return result;
}

//----- (000000018000A590) ----------------------------------------------------
__int64 __fastcall CTlsExtClient::ParseExtension(__int64 a1, __int64 a2, unsigned __int8 *a3, unsigned __int16 a4)
{
  unsigned int v4; // ebp
  unsigned int v5; // edi
  unsigned __int8 *v8; // r9
  int v9; // r8d
  __int64 v10; // rax
  __int64 v11; // rcx
  unsigned int v12; // r13d
  int v13; // r9d
  CCipherMill *v14; // rcx
  __int64 result; // rax
  _DWORD *v16; // rax
  unsigned __int16 v17; // r8
  __int64 v18; // rcx
  int v19; // edx
  __int64 v20; // rax
  CCipherMill *v21; // rcx
  __int64 v22; // rdx
  char *v23; // r14
  CCipherMill *v24; // r15
  __int64 v25; // rdx
  CSsl3TlsClientContext *v26; // rcx
  __int64 v27; // rcx
  CSsl3TlsClientContext *v28; // r10
  __int16 v29; // cx
  unsigned __int16 v30; // ax
  unsigned __int8 *v31; // r14
  unsigned __int16 *v32; // rdx
  unsigned __int8 *v33; // r14
  unsigned __int16 v34; // cx
  unsigned __int8 *v35; // r14
  unsigned int v36; // ecx
  _BYTE *v37; // r14
  unsigned int Size; // [rsp+30h] [rbp-48h]
  void *Buf2; // [rsp+38h] [rbp-40h]
  void *v40; // [rsp+40h] [rbp-38h]

  v4 = 0;
  v5 = a4;
  v8 = 0i64;
  v9 = 5;
  switch ( (_DWORD)a2 )
  {
    case 5:
      *(_QWORD *)(*(_QWORD *)(a1 + 8) + 136i64) |= 0x20000ui64;
      goto LABEL_20;
    case 6:
      if ( (_WORD)v5 )
      {
        v36 = *a3;
        v37 = a3 + 1;
        if ( v36 == v5 - 1 )
        {
          if ( !*(_BYTE *)(a1 + 52) )
            return 0i64;
          if ( v36 )
          {
            while ( *v37 != 64 )
            {
              ++v4;
              ++v37;
              if ( v4 >= v36 )
                goto LABEL_80;
            }
            *(_BYTE *)(*(_QWORD *)(a1 + 8) + 922i64) = 1;
          }
LABEL_80:
          v9 = 6;
          goto LABEL_20;
        }
      }
      return 2148074278i64;
    case 0xE:
      v28 = *(CSsl3TlsClientContext **)(a1 + 56);
      if ( (*((_DWORD *)v28 + 34) & 0x2000i64) == 0 || (unsigned __int16)(v5 - 5) > 0xFFu )
      {
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v22 = 37i64;
        goto LABEL_126;
      }
      v29 = *a3;
      v30 = a3[1];
      v31 = a3 + 2;
      if ( (v30 | (unsigned __int16)(v29 << 8)) != 2 )
      {
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v22 = 38i64;
        goto LABEL_126;
      }
      v32 = (unsigned __int16 *)v31;
      v33 = v31 + 2;
      v34 = *v33;
      v35 = v33 + 1;
      if ( (_BYTE)v34 )
      {
        if ( (unsigned __int16)(v5 - 5) < v34 )
        {
          v21 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            return 2148074278i64;
          }
          v22 = 39i64;
          goto LABEL_126;
        }
        v8 = v35;
      }
      result = CSsl3TlsClientContext::SetNegotiatedSrtpParameters(v28, v32, 2u, v8, v34);
      if ( !(_DWORD)result )
      {
        v9 = 14;
        goto LABEL_20;
      }
      break;
    case 0x10:
      v16 = (_DWORD *)(*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD))(**(_QWORD **)(a1 + 8) + 88i64))(
                        *(_QWORD *)(a1 + 8),
                        a2,
                        5i64,
                        0i64);
      if ( v16 && *v16 )
      {
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v22 = 33i64;
        goto LABEL_126;
      }
      if ( (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 136i64) & 0x4000000) == 0 || (unsigned __int16)(v5 - 4) > 0xFEu )
      {
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v22 = 34i64;
        goto LABEL_126;
      }
      v17 = _byteswap_ushort(*(_WORD *)a3);
      if ( v17 != v5 - 2 )
      {
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v22 = 35i64;
        goto LABEL_126;
      }
      result = CSsl3TlsClientContext::SetSelectedApplicationProtocol(*(CSsl3TlsClientContext **)(a1 + 56), a3 + 2, v17);
      if ( !(_DWORD)result )
      {
        v9 = 16;
        goto LABEL_20;
      }
      break;
    case 0x17:
      if ( !*(_BYTE *)(*(_QWORD *)(a1 + 56) + 1344i64) )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 36i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
        v27 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 120i64);
        if ( v27 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
          *(_WORD *)(v27 + 66) |= 4u;
        return 2148074278i64;
      }
      v9 = 23;
      *(_QWORD *)(*(_QWORD *)(a1 + 8) + 136i64) |= 0x8000000ui64;
      goto LABEL_20;
    case 0x18:
      v26 = *(CSsl3TlsClientContext **)(a1 + 56);
      if ( (*((_DWORD *)v26 + 34) & 0x80000000) == 0 || v5 < 4 )
      {
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v22 = 40i64;
        goto LABEL_126;
      }
      if ( (unsigned __int16)(v5 - 3) < a3[2] || a3[2] != 1 )
      {
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v22 = 41i64;
        goto LABEL_126;
      }
      result = CSsl3TlsClientContext::SetNegotiatedTBParameters(v26, *a3, a3[1], a3 + 3, a3[2]);
      if ( !(_DWORD)result )
      {
        v9 = 24;
        goto LABEL_20;
      }
      break;
    case 0x23:
      v9 = 35;
      *(_QWORD *)(*(_QWORD *)(a1 + 8) + 136i64) |= 0x400000ui64;
LABEL_20:
      CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 120i64), 1, v9);
      return 0i64;
    case 0xFF01:
      v10 = *(_QWORD *)(a1 + 8);
      if ( *(_DWORD *)(v10 + 416) && !*(_BYTE *)(v10 + 553) )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 42i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
          v10 = *(_QWORD *)(a1 + 8);
        }
        CSslContext::SetErrorAndFatalAlert(v10, 1207, -2146892986, 0x28u);
        v18 = *(_QWORD *)(a1 + 8);
        *(_DWORD *)(v18 + 68) = 96;
        *(_WORD *)(v18 + 96) = 10242;
        return 2148074310i64;
      }
      *(_BYTE *)(v10 + 553) = 1;
      v11 = *(_QWORD *)(a1 + 8);
      v12 = *(_DWORD *)(v11 + 456);
      Buf2 = (void *)(v11 + 377);
      v40 = (void *)(v11 + 420);
      Size = *(_DWORD *)(v11 + 416);
      if ( (_WORD)v5 )
      {
        v13 = *a3;
        if ( v13 + 1 == v5 )
        {
          if ( (_WORD)v5 == 1 )
          {
            v14 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 45i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
              v14 = WPP_GLOBAL_Control;
            }
            if ( !v12 )
              return 0i64;
            if ( v14 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v14 + 28) & 1) != 0 )
              WPP_SF_DD(*((_QWORD *)v14 + 2), 0x2Eu, (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids, v5, v12);
            v19 = 1207;
            goto LABEL_38;
          }
          v23 = (char *)(a3 + 1);
          if ( v13 != *(_DWORD *)(v11 + 416) + v12 )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              WPP_SF_DD(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0x2Fu,
                (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
                v13,
                *(_DWORD *)(v11 + 416));
              v11 = *(_QWORD *)(a1 + 8);
            }
            v19 = 1207;
            goto LABEL_39;
          }
          v24 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
          {
            if ( (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 48i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
              v24 = WPP_GLOBAL_Control;
            }
            if ( v24 != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_DWORD *)v24 + 7) & 0x800) != 0 )
              {
                WPP_SF_(*((_QWORD *)v24 + 2), 49i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
                v24 = WPP_GLOBAL_Control;
              }
              if ( v24 != (CCipherMill *)&WPP_GLOBAL_Control )
              {
                if ( (*((_DWORD *)v24 + 7) & 0x800) != 0 )
                {
                  WPP_SF_(*((_QWORD *)v24 + 2), 50i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
                  v24 = WPP_GLOBAL_Control;
                }
                if ( v24 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)v24 + 7) & 0x800) != 0 )
                {
                  WPP_SF_(*((_QWORD *)v24 + 2), 51i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
                  v24 = WPP_GLOBAL_Control;
                }
              }
            }
          }
          if ( memcmp_0(v23, Buf2, Size) )
          {
            if ( v24 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v24 + 28) & 1) == 0 )
              goto LABEL_73;
            v25 = 52i64;
LABEL_72:
            WPP_SF_(*((_QWORD *)v24 + 2), v25, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
LABEL_73:
            v19 = 108;
LABEL_38:
            v11 = *(_QWORD *)(a1 + 8);
LABEL_39:
            CSslContext::SetErrorAndFatalAlert(v11, v19, -2146892986, 0x28u);
            v20 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v20 + 68) = 96;
            *(_WORD *)(v20 + 96) = 10242;
            return 2148074310i64;
          }
          if ( memcmp_0(&v23[Size], v40, v12) )
          {
            if ( v24 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v24 + 28) & 1) == 0 )
              goto LABEL_73;
            v25 = 53i64;
            goto LABEL_72;
          }
          v9 = 65281;
          goto LABEL_20;
        }
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
        {
          WPP_SF_DD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x2Cu,
            (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
            v13,
            v5);
        }
        return 2148074278i64;
      }
      v21 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074278i64;
      v22 = 43i64;
LABEL_126:
      WPP_SF_(*((_QWORD *)v21 + 2), v22, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
      return 2148074278i64;
    default:
      CSchannelTelemetryContext::LogUnknownTlsExtension(
        *(CSchannelTelemetryContext **)(*(_QWORD *)(a1 + 8) + 120i64),
        a2);
      return 0i64;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (000000018000A7D4) ----------------------------------------------------
__int64 __fastcall CTlsExtClient::BuildClientHelloExtension(
        CTlsExtClient *this,
        unsigned int a2,
        unsigned __int8 *a3,
        unsigned int *a4)
{
  unsigned int v4; // eax
  unsigned __int16 *v5; // r12
  unsigned __int8 *v7; // r13
  unsigned __int8 *v8; // rsi
  int v9; // r11d
  unsigned __int8 v10; // al
  __int64 v11; // rax
  unsigned __int8 *v12; // rbx
  unsigned __int8 *v13; // rbx
  __int64 v14; // rcx
  int v15; // edx
  __int64 v16; // rcx
  unsigned int v17; // r9d
  __int16 v18; // cx
  _BYTE *v19; // rbx
  bool i; // cf
  __int64 v21; // r8
  __int64 v22; // rcx
  int v23; // edx
  _BYTE *v24; // rcx
  CTlsSignatureSuiteList *v25; // rcx
  int v26; // eax
  unsigned int v27; // edi
  unsigned __int8 *v28; // rbx
  __int64 v29; // rcx
  CTlsExt *v30; // rcx
  size_t v31; // rdi
  const void *v32; // r15
  unsigned int v33; // eax
  __int64 v34; // r15
  size_t v35; // rdi
  __int64 v36; // rax
  __int64 v37; // rax
  __int64 v38; // rcx
  __int64 v39; // rax
  __int16 v40; // r11
  __int64 v41; // rbx
  __int64 v42; // rbx
  __int64 result; // rax
  __int64 v44; // rax
  size_t v45; // rbx
  const void *v46; // rdi
  __int64 v47; // rcx
  __int64 v48; // rax
  size_t v49; // rbx
  unsigned __int8 *v50; // r15
  unsigned __int8 v51; // di
  __int16 v52; // ax
  __int16 v53; // cx
  char *v54; // rsi
  char *v55; // rbx
  __int64 v56; // rax
  __int64 v57; // [rsp+80h] [rbp+40h] BYREF
  unsigned __int8 *v58; // [rsp+90h] [rbp+50h] BYREF

  v4 = *((_DWORD *)this + 5);
  LOBYTE(v5) = 0;
  v7 = &a3[a2];
  v57 = 0i64;
  if ( v4 )
  {
    if ( a2 < v4 )
      return 234i64;
    *a4 = a2;
    v8 = a3 + 2;
    *a3 = (unsigned __int16)(v4 - 2) >> 8;
    v9 = 1;
    v10 = *((_BYTE *)this + 20) - 2;
    v58 = a3 + 2;
    a3[1] = v10;
    v11 = *((_QWORD *)this + 1);
    if ( (*(_DWORD *)(v11 + 64) & 0x2A88) != 0 || (*(_BYTE *)(v11 + 64) & 0x20) == 0 )
    {
      v12 = a3 + 2;
      if ( *((_QWORD *)this + 5) )
      {
        *(_WORD *)v8 = 0;
        v13 = a3 + 11;
        a3[4] = (unsigned __int16)(*((_WORD *)this + 24) + 5) >> 8;
        a3[5] = *((_BYTE *)this + 48) + 5;
        a3[6] = (unsigned __int16)(*((_WORD *)this + 24) + 3) >> 8;
        a3[7] = *((_BYTE *)this + 48) + 3;
        a3[8] = 0;
        a3[9] = *((_BYTE *)this + 49);
        a3[10] = *((_BYTE *)this + 48);
        memcpy_0(a3 + 11, *((const void **)this + 5), *((unsigned int *)this + 12));
        v14 = *((_QWORD *)this + 1);
        v58 = &v13[*((unsigned int *)this + 12)];
        v8 = v58;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v14 + 120), 0, 0);
        v12 = v8;
        v9 = v15 + 1;
      }
      if ( *((_BYTE *)this + 24) )
      {
        *v8 = 0;
        *(_QWORD *)(v12 + 1) = 17104901i64;
        v8 = v12 + 9;
        v16 = *((_QWORD *)this + 1);
        v58 = v12 + 9;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v16 + 120), 0, 5);
        v12 += 9;
      }
      if ( *((_BYTE *)this + 25) )
      {
        *v8 = 0;
        *(_DWORD *)(v12 + 1) = 16908294;
        v8 = v12 + 6;
        v12[5] = 64;
        v48 = *((_QWORD *)this + 1);
        v58 = v12 + 6;
        *(_BYTE *)(v48 + 922) = v9;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 6);
        v12 += 6;
      }
      if ( *((_BYTE *)this + 32) )
      {
        v17 = 0;
        v18 = *(_WORD *)(*((_QWORD *)this + 7) + 920i64);
        *v8 = 0;
        v18 *= 2;
        v12[1] = 10;
        v12[2] = (unsigned __int16)(v18 + 2) >> 8;
        v12[3] = v18 + 2;
        v12[4] = HIBYTE(v18);
        v12[5] = v18;
        v19 = v12 + 6;
        for ( i = *(_WORD *)(*((_QWORD *)this + 7) + 920i64) != 0;
              i;
              i = v17 < *(unsigned __int16 *)(*((_QWORD *)this + 7) + 920i64) )
        {
          v21 = v17;
          v17 += v9;
          *v19 = *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 7) + 912i64) + 2 * v21 + 1);
          v19[1] = *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 7) + 912i64) + 2 * v21);
          v19 += 2;
        }
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 10);
        *v19 = 0;
        *(_DWORD *)(v19 + 1) = 16908299;
        v8 = v19 + 6;
        v19[5] = 0;
        v22 = *((_QWORD *)this + 1);
        v58 = v19 + 6;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v22 + 120), v23, v23 + 11);
        v12 = v19 + 6;
      }
      v24 = (_BYTE *)*((_QWORD *)this + 7);
      if ( v24[925] )
      {
        v25 = (CTlsSignatureSuiteList *)(v24 + 474);
        v26 = *(unsigned __int16 *)v25;
        *v8 = 0;
        v12[1] = 13;
        v27 = 2 * v26 + 2;
        v12[2] = BYTE1(v27);
        v12[3] = 2 * v26 + 2;
        v28 = v12 + 4;
        CTlsSignatureSuiteList::BuildSupportedSignatureAlgorithms(v25, v28, v27);
        v29 = *((_QWORD *)this + 1);
        v8 = &v28[v27];
        v58 = v8;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v29 + 120), 0, 13);
        v24 = (_BYTE *)*((_QWORD *)this + 7);
        v12 = v8;
      }
      (*(void (__fastcall **)(_BYTE *, __int64 *))(*(_QWORD *)v24 + 224i64))(v24, &v57);
      if ( v57 )
      {
        v32 = *(const void **)(v57 + 424);
        v33 = *(_DWORD *)(v57 + 432);
        v31 = v33;
        *v8 = 0;
        v8 = v12 + 4;
        v12[1] = 35;
        v12[2] = BYTE1(v33);
        v12[3] = v33;
        v58 = v12 + 4;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids, v33);
        v12 += 4;
        if ( (_DWORD)v31 )
        {
          *(_QWORD *)(*((_QWORD *)this + 1) + 136i64) |= 0x800000ui64;
          v47 = *(_QWORD *)(*((_QWORD *)this + 1) + 120i64);
          if ( v47 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
          {
            *(_WORD *)(v47 + 64) |= 2u;
            *(_DWORD *)(v47 + 24) = 1;
          }
          memcpy_0(v8, v32, v31);
          v12 = &v8[v31];
          v8 = v12;
          v58 = v12;
        }
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 35);
      }
      v34 = *(_QWORD *)(*((_QWORD *)this + 1) + 784i64);
      if ( v34 )
      {
        v35 = *(unsigned __int16 *)(v34 + 4);
        *v8 = 0;
        v12[1] = 16;
        v12[2] = (unsigned __int16)(v35 + 2) >> 8;
        v12[3] = v35 + 2;
        v12[4] = BYTE1(v35);
        v12[5] = v35;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            11i64,
            &WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
            (unsigned int)v35);
        memcpy_0(v12 + 6, (const void *)(v34 + 6), v35);
        v36 = *((_QWORD *)this + 1);
        v8 = &v12[v35 + 6];
        v58 = v8;
        *(_QWORD *)(v36 + 136) |= 0x4000000ui64;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 16);
        v12 = v8;
      }
      v37 = *((_QWORD *)this + 7);
      if ( *(_BYTE *)(v37 + 1344) )
      {
        *v8 = 0;
        v8 = v12 + 4;
        v58 = v12 + 4;
        v12[1] = 23;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
        v38 = *((_QWORD *)this + 1);
        v39 = *(_QWORD *)(v38 + 120);
        if ( v39 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
        {
          *(_WORD *)(v39 + 66) |= 1u;
          v38 = *((_QWORD *)this + 1);
        }
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v38 + 120), 0, 23);
        v37 = *((_QWORD *)this + 7);
      }
      else
      {
        v40 = 1;
      }
      v41 = v37;
      if ( *(_BYTE *)(v37 + 233) )
      {
        v5 = *(unsigned __int16 **)(v37 + 800);
        if ( v5 )
        {
          v49 = *v5;
          v50 = *(unsigned __int8 **)(v37 + 1336);
          if ( v50 )
          {
            v51 = *v50;
            v52 = v40 + *v50;
          }
          else
          {
            v52 = 1;
            v51 = 0;
          }
          v53 = v52 + v49 + 2;
          *(_WORD *)v8 = 3584;
          v8[2] = HIBYTE(v53);
          v8[3] = v53;
          v8[4] = BYTE1(v49);
          v8[5] = v49;
          v54 = (char *)(v8 + 6);
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_DD(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xDu,
              (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
              v49,
              v51);
          }
          memcpy_0(v54, v5 + 1, v49);
          v54[v49] = v51;
          LOBYTE(v5) = 0;
          v55 = &v54[v49 + 1];
          if ( v50 )
            memcpy_0(v55, v50 + 1, v51);
          v56 = *((_QWORD *)this + 7);
          v8 = (unsigned __int8 *)&v55[v51];
          v58 = v8;
          *(_QWORD *)(v56 + 136) |= 0x2000ui64;
          CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 14);
          v41 = *((_QWORD *)this + 7);
        }
      }
      v42 = *(_QWORD *)(v41 + 816);
      if ( v42 )
      {
        result = CTlsExt::BuildTBExtension(
                   v30,
                   *(_BYTE *)v42,
                   *(_BYTE *)(v42 + 1),
                   (unsigned __int8 *const)(v42 + 4),
                   *(_BYTE *)(v42 + 2),
                   v7,
                   &v58);
        if ( (_DWORD)result )
          return result;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            14i64,
            &WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
            *(unsigned __int16 *)(v42 + 2));
        *(_QWORD *)(*((_QWORD *)this + 7) + 136i64) |= 0x80000000ui64;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 24);
        v8 = v58;
      }
      LOBYTE(v9) = 1;
    }
    if ( *((_BYTE *)this + 26) != (_BYTE)v5 )
    {
      v44 = *((_QWORD *)this + 7);
      v45 = *(unsigned int *)(v44 + 416);
      v46 = (const void *)(v44 + 377);
      *(_WORD *)v8 = 511;
      v8[2] = (unsigned __int16)(v45 + 1) >> 8;
      v8[3] = v9 + v45;
      v8[4] = v45;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
      }
      if ( (_DWORD)v45 )
        memcpy_0(v8 + 5, v46, v45);
      CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 65281);
    }
  }
  return 0i64;
}
// 18000A8C1: variable 'v15' is possibly undefined
// 18003564D: variable 'v9' is possibly undefined
// 18000A9C1: variable 'v23' is possibly undefined
// 18000ABFE: variable 'v30' is possibly undefined
// 1800356F6: variable 'v40' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (000000018000AD34) ----------------------------------------------------
__int64 __fastcall CSchannelTelemetryContext::LogTlsExtensionTelemetry(__int64 a1, int a2, int a3)
{
  char v3; // r9
  int v4; // r8d
  int v5; // r8d
  int v6; // r8d
  int v7; // r8d
  int v8; // r8d
  int v9; // r8d
  int v10; // r8d
  int v11; // r8d
  __int64 result; // rax

  v3 = a3;
  if ( a1 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
  {
    v4 = a3 - 10;
    if ( v4 )
    {
      v5 = v4 - 1;
      if ( v5 )
      {
        v6 = v5 - 2;
        if ( v6 )
        {
          v7 = v6 - 1;
          if ( v7 )
          {
            v8 = v7 - 2;
            if ( v8 )
            {
              v9 = v8 - 7;
              if ( v9 )
              {
                v10 = v9 - 1;
                if ( v10 )
                {
                  v11 = v10 - 11;
                  if ( v11 )
                  {
                    if ( v11 == 65246 )
                      v3 = 16;
                  }
                  else
                  {
                    v3 = 13;
                  }
                }
                else
                {
                  v3 = 15;
                }
              }
              else
              {
                v3 = 12;
              }
            }
            else
            {
              v3 = 11;
            }
          }
          else
          {
            v3 = 10;
          }
        }
        else
        {
          v3 = 9;
        }
      }
      else
      {
        v3 = 8;
      }
    }
    else
    {
      v3 = 7;
    }
    result = 1i64;
    if ( a2 )
    {
      if ( a2 == 1 )
      {
        result = (unsigned int)(1 << v3);
        *(_DWORD *)(a1 + 72) |= result;
      }
    }
    else
    {
      result = (unsigned int)(1 << v3);
      *(_DWORD *)(a1 + 68) |= result;
    }
  }
  return result;
}
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (000000018000ADF4) ----------------------------------------------------
void __fastcall CTlsSignatureSuiteList::BuildSupportedSignatureAlgorithms(
        CTlsSignatureSuiteList *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  size_t v4; // rdx

  if ( a2 )
  {
    v4 = 2 * (unsigned int)*(unsigned __int16 *)this;
    if ( a3 >= v4 + 2 )
    {
      *a2 = BYTE1(v4);
      a2[1] = v4;
      memcpy_0(a2 + 2, (char *)this + 2, v4);
    }
  }
}

//----- (000000018000AE3C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::GenerateSsl3TlsClientHello(CSsl3TlsClientContext *this, struct SPBuffer *a2)
{
  CSsl3TlsClientContext *v3; // rbx
  ULONG Random; // eax
  __int64 v5; // rdx
  unsigned int v6; // r8d
  __int64 result; // rax
  int v8; // ecx
  __int64 v9; // rax
  unsigned int v10; // [rsp+20h] [rbp-1B8h]
  __int128 v11; // [rsp+40h] [rbp-198h] BYREF
  char v12[352]; // [rsp+50h] [rbp-188h] BYREF

  v3 = this;
  v11 = 0i64;
  if ( !*((_DWORD *)this + 327) || *((_DWORD *)this + 17) == 4 )
  {
    Random = CSsl3TlsContext::TlsGenerateRandom(this);
    this = (CSsl3TlsClientContext *)Random;
    if ( Random )
    {
LABEL_12:
      if ( *((_BYTE *)v3 + 233) )
      {
        if ( (_DWORD)this )
          return (unsigned int)this;
        v9 = *((_QWORD *)&v11 + 1);
        if ( !*((_QWORD *)&v11 + 1) )
          return (unsigned int)this;
        if ( !*((_DWORD *)v3 + 327) || *((_DWORD *)v3 + 17) == 4 )
        {
          LODWORD(this) = CSsl3TlsContext::DtlsGetOutgoingRecord(v3, (struct SPBuffer *)&v11, a2);
          return (unsigned int)this;
        }
      }
      else
      {
        v9 = *((_QWORD *)&v11 + 1);
      }
      *((_QWORD *)a2 + 1) = v9;
      *(_QWORD *)a2 = v11;
      return (unsigned int)this;
    }
  }
  if ( (*((_DWORD *)v3 + 16) & 0x80800) == 0 )
  {
LABEL_8:
    if ( *((_BYTE *)v3 + 233) )
      v8 = *((_DWORD *)v3 + 16);
    else
      v8 = 2720;
    LODWORD(this) = CSslContext::GenerateHelloMessage(
                      v3,
                      (struct _Ssl2_Client_Hello *)v12,
                      (unsigned int)v8 & *(_DWORD *)(*((_QWORD *)v3 + 10) + 152i64),
                      (unsigned __int8 *)v3 + 272,
                      v10,
                      (unsigned __int16 **)v3 + 114,
                      (unsigned __int16 *)v3 + 460);
    if ( !(_DWORD)this )
      LODWORD(this) = CSsl3TlsClientContext::PackClientHello(
                        v3,
                        (struct _Ssl2_Client_Hello *)v12,
                        (struct SPBuffer *)&v11);
    goto LABEL_12;
  }
  CCipherMill::GetSignatureSuiteList(this, (CSsl3TlsClientContext *)((char *)v3 + 474));
  v5 = *((_QWORD *)v3 + 10);
  v6 = *(_DWORD *)(v5 + 196);
  if ( !v6 )
    goto LABEL_7;
  result = CTlsSignatureSuiteList::Blacklist(
             (CSsl3TlsClientContext *)((char *)v3 + 474),
             *(struct _TLS_PARAMETERS **)(v5 + 200),
             v6);
  if ( (_DWORD)result )
    return result;
  if ( *((_WORD *)v3 + 237) )
  {
LABEL_7:
    *((_BYTE *)v3 + 925) = 1;
    goto LABEL_8;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_13477250810f3961702f89c94d47ffd6_Traceguids);
  return 2148074289i64;
}
// 18000AF1E: variable 'v10' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000AF8C) ----------------------------------------------------
__int64 __fastcall CSslContext::GenerateHelloMessage(
        CSslContext *this,
        struct _Ssl2_Client_Hello *a2,
        unsigned int a3,
        unsigned __int8 *a4,
        unsigned int a5,
        unsigned __int16 **a6,
        unsigned __int16 *a7)
{
  __int64 v7; // rbx
  unsigned int *v12; // rdx
  unsigned int v13; // r8d
  int v14; // r9d
  __int64 result; // rax
  unsigned __int16 v16; // ax
  int v17; // r8d
  int v18; // ecx
  unsigned int v19; // ebx
  __int64 v20; // rax
  __int64 v21; // rdx
  unsigned int v22; // eax

  v7 = *((_QWORD *)this + 10);
  v12 = *(unsigned int **)(v7 + 184);
  v13 = *(_DWORD *)(v7 + 176);
  v14 = *(_DWORD *)(v7 + 192);
  *((_DWORD *)a2 + 1) = 68;
  result = CCipherMill::BuildCipherSuiteList(
             (__int64)this,
             v12,
             v13,
             v14,
             v7,
             a3,
             (__int64)a2 + 80,
             (_DWORD *)a2 + 1,
             a6,
             a7);
  if ( !(_DWORD)result )
  {
    v16 = ConvertSchannelProtocolToSsl(a3);
    v18 = v16;
    v19 = v17 + 32;
    *((_DWORD *)a2 + 2) = v17;
    if ( !v16 )
      v18 = 768;
    *(_DWORD *)a2 = v18;
    v20 = *((_QWORD *)this + 11);
    if ( v20 && *(_WORD *)(v20 + 238) > (unsigned __int16)v17 )
    {
      *((_DWORD *)a2 + 2) = v19;
      v21 = *((_QWORD *)this + 11);
      v22 = *(unsigned __int16 *)(v21 + 238);
      if ( v22 <= v19 )
      {
        *((_DWORD *)a2 + 2) = v22;
        memcpy_0((char *)a2 + 16, (const void *)(v21 + 240), *(unsigned __int16 *)(v21 + 238));
      }
    }
    result = 0i64;
    *((_OWORD *)a2 + 3) = *(_OWORD *)a4;
    *((_OWORD *)a2 + 4) = *((_OWORD *)a4 + 1);
    *((_DWORD *)a2 + 3) = v19;
  }
  return result;
}
// 18000B01E: variable 'v17' is possibly undefined

//----- (000000018000B0B0) ----------------------------------------------------
__int64 __fastcall SpInitUserModeContext(__int64 a1, struct _SecBuffer *a2)
{
  unsigned int v4; // ebx
  CCipherMill *v6; // rcx
  int v7; // [rsp+20h] [rbp-18h]
  unsigned int v8; // [rsp+20h] [rbp-18h]

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
  if ( (unsigned int)SchannelInit(1) )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_q(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x10u,
        (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids,
        a1);
    v4 = SslAddUserContext(a1, 0i64, a2, 0);
    if ( g_pFreeContextBuffer )
    {
      g_pFreeContextBuffer(a2->pvBuffer);
      a2->pvBuffer = 0i64;
      a2->cbBuffer = 0;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
      && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v4 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
    {
      v8 = v4;
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x11u,
        (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids,
        v4,
        v8);
    }
    return v4;
  }
  else
  {
    v6 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
        v6 = WPP_GLOBAL_Control;
      }
      if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 5) != 0 )
      {
        v7 = -2146893052;
        WPP_SF_DD(*((_QWORD *)v6 + 2), 0xFu, (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, -2146893052, v7);
      }
    }
    return 2148074244i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800921A0: using guessed type int (__stdcall *g_pFreeContextBuffer)(void *);

//----- (000000018000B190) ----------------------------------------------------
__int64 __fastcall SslAddUserContext(__int64 a1, void *a2, struct _SecBuffer *a3, int a4)
{
  CCipherMill *v8; // rcx
  struct CSslUserContext *v9; // rdi
  unsigned int v10; // ebx
  unsigned int v11; // ebx
  __int64 v12; // rsi
  char *v13; // rax
  char *v14; // rcx
  char **v15; // rdx
  __int64 v17; // [rsp+20h] [rbp-48h]
  __int128 v18; // [rsp+30h] [rbp-38h] BYREF
  __int64 v19; // [rsp+40h] [rbp-28h]
  int v20; // [rsp+48h] [rbp-20h]
  int v21; // [rsp+4Ch] [rbp-1Ch]
  struct CSslUserContext *v22; // [rsp+80h] [rbp+18h] BYREF

  v19 = 0i64;
  v20 = 0;
  v21 = 0;
  v18 = 0i64;
  v8 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_ba773d91511536867a821af0ee22c47a_Traceguids);
      v8 = WPP_GLOBAL_Control;
    }
    if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
      WPP_SF_q(*((_QWORD *)v8 + 2), 0xCu, (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids, a1);
  }
  if ( !a4 )
    SslDeleteUserContext(a1);
  if ( (unsigned int)CSslSerializeHelper::DeserializeContext(
                       (CSslSerializeHelper *)&v18,
                       (unsigned __int8 *)a3->pvBuffer,
                       a3->cbBuffer,
                       &v22) )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xDu,
        (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids,
        -2146893008,
        -2146893008);
    return 2148074288i64;
  }
  else
  {
    v9 = v22;
    if ( a2 || a4 )
      *((_QWORD *)v22 + 33) = a2;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_qq(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xEu,
        (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids,
        v9,
        a1);
    *((_QWORD *)v9 + 36) = a1;
    v10 = BYTE3(a1) + a1 + WORD1(a1) + ((unsigned int)a1 >> 8);
    v11 = (dwSslContextListCount - 1) & ((v10 >> 4) + v10);
    v12 = 96i64 * (v11 & (dwSslContextLockCount - 1));
    RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)SslContextLock + v12), 1u);
    v13 = (char *)v9 + 304;
    v14 = (char *)SslContextList + 16 * v11;
    v15 = (char **)*((_QWORD *)v14 + 1);
    if ( *v15 != v14 )
      __fastfail(3u);
    *(_QWORD *)v13 = v14;
    *((_QWORD *)v9 + 39) = v15;
    *v15 = v13;
    *((_QWORD *)v14 + 1) = v13;
    RtlReleaseResource((PRTL_RESOURCE)((char *)SslContextLock + v12));
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      LODWORD(v17) = 0;
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xFu,
        (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids,
        0,
        v17);
    }
    return 0i64;
  }
}
// 180035A1F: variable 'v17' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800919E0: using guessed type unsigned int dwSslContextListCount;
// 1800919E4: using guessed type unsigned int dwSslContextLockCount;

//----- (000000018000B32C) ----------------------------------------------------
__int64 __fastcall CSslSerializeHelper::DeserializeContext(
        CSslSerializeHelper *this,
        unsigned __int8 *a2,
        int a3,
        struct CSslUserContext **a4)
{
  unsigned int v4; // ebx
  unsigned __int8 *v7; // r8
  unsigned int v8; // eax
  unsigned int v9; // ecx
  int v10; // r9d
  unsigned int v11; // ebx
  struct CSslUserContext *UserContext; // rax

  *a4 = 0i64;
  v4 = 0;
  *((_DWORD *)this + 6) = a3;
  v7 = &a2[a3];
  *((_QWORD *)this + 1) = a2;
  while ( 1 )
  {
    if ( a2 + 16 > v7 )
      goto LABEL_11;
    v8 = *((_DWORD *)a2 + 2);
    v9 = *((_DWORD *)a2 + 1);
    if ( v8 > v9 )
      goto LABEL_11;
    v10 = *(_DWORD *)a2;
    if ( !*(_DWORD *)a2 )
      break;
    if ( v10 == 1 )
    {
      if ( v9 < 0xC8 )
        goto LABEL_11;
      v4 = 464;
    }
    else
    {
      if ( v10 <= 1 )
        goto LABEL_18;
      if ( v10 > 3 )
      {
        if ( v10 > 17 )
        {
          if ( v10 > 20 )
          {
LABEL_18:
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              WPP_SF_d(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0xBu,
                (__int64)&WPP_3fd35671b5b538c236a2a452323fc10e_Traceguids,
                v10);
            }
LABEL_11:
            v11 = -2146893052;
            goto LABEL_22;
          }
        }
        else
        {
          v4 += (v8 + 7) & 0xFFFFFFF8;
        }
      }
    }
    a2 += v9 + 16;
  }
  UserContext = CreateUserContext(v4);
  *a4 = UserContext;
  if ( UserContext )
  {
    v11 = CSslSerializeHelper::DeserializeContextWorker(this, UserContext);
    if ( !v11 )
      return v11;
  }
  else
  {
    v11 = -2146893056;
  }
LABEL_22:
  if ( *a4 )
    DeleteUserContext(*a4);
  return v11;
}

//----- (000000018000B400) ----------------------------------------------------
void __fastcall SslDeleteUserContext(__int64 a1)
{
  struct CSslUserContext *v2; // rax

  v2 = SslReferenceUserContext(a1, 1u);
  if ( v2 )
  {
    DeleteUserContext(v2);
  }
  else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x1Bu, (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids, a1);
  }
}

//----- (000000018000B448) ----------------------------------------------------
__int64 __fastcall CSslSerializeHelper::DeserializeContextWorker(CSslSerializeHelper *this, struct CSslUserContext *a2)
{
  __int64 v2; // rdi
  unsigned int SslProvHandle; // ebp
  int v5; // r9d
  __int128 *v6; // rbx
  __int128 *v7; // rcx
  __int64 v8; // rax
  __int128 *v10; // rdx
  __int64 v11; // rax
  __int128 v12; // xmm0
  __int64 v13; // rax
  __int64 v14; // rdx
  const wchar_t *v15; // r9
  CCipherMill *v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // [rsp+20h] [rbp-18h]

  v2 = *((_QWORD *)this + 1);
  SslProvHandle = 0;
  v5 = *(_DWORD *)v2;
  if ( *(_DWORD *)v2 == 1 )
  {
    v6 = (__int128 *)((char *)a2 + 464);
    while ( 1 )
    {
      v7 = (__int128 *)(v2 + 16);
      if ( v5 > 10 )
      {
        if ( v5 <= 15 )
        {
          switch ( v5 )
          {
            case 15:
              *((_QWORD *)a2 + 51) = v6;
              break;
            case 11:
              *((_QWORD *)a2 + 31) = v6;
              memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
              *((_DWORD *)a2 + 64) = *(_DWORD *)(v2 + 8);
              goto LABEL_24;
            case 12:
              *((_QWORD *)a2 + 49) = v6;
              v10 = v6;
              v11 = 2i64;
              do
              {
                v12 = *v7;
                v7 += 8;
                *v10 = v12;
                v10 += 8;
                *(v10 - 7) = *(v7 - 7);
                *(v10 - 6) = *(v7 - 6);
                *(v10 - 5) = *(v7 - 5);
                *(v10 - 4) = *(v7 - 4);
                *(v10 - 3) = *(v7 - 3);
                *(v10 - 2) = *(v7 - 2);
                *(v10 - 1) = *(v7 - 1);
                --v11;
              }
              while ( v11 );
              *(_QWORD *)v10 = *(_QWORD *)v7;
              goto LABEL_24;
            case 13:
              *((_QWORD *)a2 + 50) = v6;
              break;
            default:
              v13 = *((_QWORD *)a2 + 50);
LABEL_63:
              *(_QWORD *)(v13 + 8) = v6;
              memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
              goto LABEL_24;
          }
          *v6 = *v7;
          goto LABEL_24;
        }
        switch ( v5 )
        {
          case 16:
            v13 = *((_QWORD *)a2 + 51);
            goto LABEL_63;
          case 17:
            *((_QWORD *)a2 + 53) = v6;
            memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
            *((_DWORD *)a2 + 104) = *(_DWORD *)(v2 + 8);
            goto LABEL_24;
          case 18:
            goto LABEL_11;
        }
        if ( v5 > 20 )
        {
LABEL_67:
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            WPP_SF_d(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xFu,
              (__int64)&WPP_3fd35671b5b538c236a2a452323fc10e_Traceguids,
              v5);
          }
          return 2148074244i64;
        }
        if ( !a2 || !*((_QWORD *)a2 + 11) )
          return SslProvHandle;
        v14 = 440i64;
        if ( v5 != 19 )
          v14 = 448i64;
        SslProvHandle = SslImportKey(
                          *((_QWORD *)a2 + 11),
                          (char *)a2 + v14,
                          L"OpaqueKeyBlob",
                          v2 + 16,
                          *(_DWORD *)(v2 + 8),
                          0);
        if ( SslProvHandle )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            v15 = L"read";
            if ( *(_DWORD *)v2 != 19 )
              v15 = L"write";
            LODWORD(v18) = SslProvHandle;
            WPP_SF_SD(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xEu,
              (__int64)&WPP_3fd35671b5b538c236a2a452323fc10e_Traceguids,
              v15,
              v18);
          }
          return SslProvHandle;
        }
      }
      else
      {
        if ( v5 == 10 )
        {
          *((_QWORD *)a2 + 29) = v6;
          memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
          *((_DWORD *)a2 + 60) = *(_DWORD *)(v2 + 8);
          goto LABEL_24;
        }
        if ( v5 <= 5 )
        {
          switch ( v5 )
          {
            case 5:
              *((_QWORD *)a2 + 21) = v6;
              memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
              *((_DWORD *)a2 + 44) = *(_DWORD *)(v2 + 8);
              goto LABEL_24;
            case 0:
              return 0i64;
            case 1:
              *((_DWORD *)a2 + 2) = *(_DWORD *)v7;
              *((_QWORD *)a2 + 2) = *(_QWORD *)(v2 + 24);
              *((_DWORD *)a2 + 6) = *(_DWORD *)(v2 + 32);
              *((_BYTE *)a2 + 32) = *(_BYTE *)(v2 + 60);
              *((_DWORD *)a2 + 7) = *(_DWORD *)(v2 + 44);
              *((_QWORD *)a2 + 12) = *(_QWORD *)(v2 + 64);
              *((_QWORD *)a2 + 13) = *(_QWORD *)(v2 + 72);
              *((_DWORD *)a2 + 14) = *(_DWORD *)(v2 + 36);
              *((_DWORD *)a2 + 15) = *(_DWORD *)(v2 + 40);
              *((_DWORD *)a2 + 16) = *(_DWORD *)(v2 + 48);
              *((_DWORD *)a2 + 18) = *(_DWORD *)(v2 + 52);
              *((_DWORD *)a2 + 17) = *(_DWORD *)(v2 + 168);
              *((_DWORD *)a2 + 29) = *(_DWORD *)(v2 + 192);
              *((_QWORD *)a2 + 15) = *(_QWORD *)(v2 + 176);
              *((_QWORD *)a2 + 16) = *(_QWORD *)(v2 + 184);
              *((_WORD *)a2 + 68) = *(_WORD *)(v2 + 196);
              *((_WORD *)a2 + 69) = *(_WORD *)(v2 + 198);
              *((_DWORD *)a2 + 36) = *(_DWORD *)(v2 + 200);
              *((_DWORD *)a2 + 115) = *(_DWORD *)(v2 + 204);
              *((_BYTE *)a2 + 456) = *(_BYTE *)(v2 + 208);
              *((_DWORD *)a2 + 49) = *(_DWORD *)(v2 + 56);
              *((_DWORD *)a2 + 95) = *(_DWORD *)(v2 + 164);
              *((_DWORD *)a2 + 94) = *(_DWORD *)(v2 + 160);
              *((_QWORD *)a2 + 33) = *(_QWORD *)(v2 + 80);
              *((_DWORD *)a2 + 68) = *(_DWORD *)(v2 + 88);
              *((_QWORD *)a2 + 37) = *(_QWORD *)(v2 + 96);
              *((_DWORD *)a2 + 80) = *(_DWORD *)(v2 + 104);
              memcpy_0((char *)a2 + 324, (const void *)(v2 + 108), *(unsigned int *)(v2 + 104));
              goto LABEL_25;
          }
          if ( v5 <= 1 )
            goto LABEL_67;
          if ( v5 > 3 )
          {
            *((_QWORD *)a2 + 19) = v6;
            memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
            *((_DWORD *)a2 + 40) = *(_DWORD *)(v2 + 8);
LABEL_24:
            v6 = (__int128 *)((char *)v6 + ((*(unsigned int *)(v2 + 8) + 7i64) & 0xFFFFFFFFFFFFFFF8ui64));
            goto LABEL_25;
          }
LABEL_11:
          if ( !a2 || !*((_QWORD *)a2 + 11) )
            return SslProvHandle;
          if ( v5 == 2 )
          {
            v8 = 40i64;
          }
          else
          {
            v8 = 432i64;
            if ( v5 == 3 )
              v8 = 48i64;
          }
          SslProvHandle = SslImportKey(
                            *((_QWORD *)a2 + 11),
                            (char *)a2 + v8,
                            L"OpaqueKeyBlob",
                            v2 + 16,
                            *(_DWORD *)(v2 + 8),
                            0);
          if ( SslProvHandle )
          {
            v16 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v17 = 13i64;
LABEL_74:
              WPP_SF_D(*((_QWORD *)v16 + 2), v17, &WPP_3fd35671b5b538c236a2a452323fc10e_Traceguids, SslProvHandle);
            }
            return SslProvHandle;
          }
          goto LABEL_25;
        }
        switch ( v5 )
        {
          case 6:
            *((_QWORD *)a2 + 23) = v6;
            memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
            *((_DWORD *)a2 + 48) = *(_DWORD *)(v2 + 8);
            goto LABEL_24;
          case 7:
            *((_QWORD *)a2 + 25) = v6;
            memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
            *((_DWORD *)a2 + 52) = *(_DWORD *)(v2 + 8);
            goto LABEL_24;
          case 8:
            *((_QWORD *)a2 + 27) = v6;
            memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
            *((_DWORD *)a2 + 56) = *(_DWORD *)(v2 + 8);
            goto LABEL_24;
        }
        *((_QWORD *)a2 + 10) = v6;
        memcpy_0(v6, (const void *)(v2 + 16), *(unsigned int *)(v2 + 8));
        v6 = (__int128 *)((char *)v6 + ((*(unsigned int *)(v2 + 8) + 7i64) & 0xFFFFFFFFFFFFFFF8ui64));
        SslProvHandle = GetSslProvHandle(*((const unsigned __int16 **)a2 + 10), (unsigned __int64 *)a2 + 11);
        if ( SslProvHandle )
        {
          v16 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            v17 = 12i64;
            goto LABEL_74;
          }
          return SslProvHandle;
        }
      }
LABEL_25:
      v2 += (unsigned int)(*(_DWORD *)(v2 + 4) + 16);
      v5 = *(_DWORD *)v2;
    }
  }
  return 2148074244i64;
}
// 18000B58E: conditional instruction was optimized away because r9d.4==4
// 180035B6A: conditional instruction was optimized away because r9d.4>=13
// 18000B54B: conditional instruction was optimized away because r9d.4==9
// 180035B1E: conditional instruction was optimized away because r9d.4==E
// 180035C1C: variable 'v18' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082320: using guessed type wchar_t aOpaquekeyblob[14];
// 180085368: using guessed type wchar_t aRead[5];
// 180085378: using guessed type wchar_t aWrite[6];
// 1800985A0: using guessed type __int64 __fastcall SslImportKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (000000018000B810) ----------------------------------------------------
__int64 __fastcall SpInitLsaModeContext(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int a4,
        __int64 a5,
        struct _SecBufferDesc *a6,
        struct CSslParentContext **a7,
        struct _SecBufferDesc *a8,
        _DWORD *a9,
        union _LARGE_INTEGER *a10,
        unsigned __int8 *a11,
        struct _SecBuffer *a12)
{
  unsigned __int64 v15; // rsi
  struct CSslParentContext *v17; // r14
  unsigned __int64 v18; // r13
  CCipherMill *v19; // rcx
  unsigned int v20; // ebx
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // rax
  unsigned __int64 v24; // rax
  __int64 v25; // rdi
  __int64 v26; // r12
  struct _SecBuffer *v27; // rbx
  __int64 v28; // rdi
  __int64 v29; // rbx
  char v30; // al
  unsigned __int64 v31; // r9
  __int64 v32; // r8
  int v33; // ebx
  __int64 v34; // rax
  struct _SecBuffer *v35; // r14
  struct _SecBuffer *v36; // rdx
  const unsigned __int16 *v38; // rdx
  unsigned int v39; // eax
  __int64 v40; // rdi
  struct _SecBuffer *v41; // r15
  __int64 *pvBuffer; // rbx
  __int64 v43; // r9
  _QWORD *v44; // rax
  void *v45; // rcx
  __int64 v46; // rcx
  int v47; // ebx
  struct _SecBuffer **v48; // [rsp+28h] [rbp-E0h]
  struct CSslParentContext *v49; // [rsp+78h] [rbp-90h] BYREF
  char v50[4]; // [rsp+80h] [rbp-88h] BYREF
  unsigned int v51; // [rsp+84h] [rbp-84h]
  void *Src; // [rsp+88h] [rbp-80h]
  struct _SecBuffer *v53; // [rsp+90h] [rbp-78h] BYREF
  struct _SecBuffer *v54; // [rsp+98h] [rbp-70h] BYREF
  struct _SecBuffer *v55; // [rsp+A0h] [rbp-68h] BYREF
  struct _SecBuffer *v56; // [rsp+A8h] [rbp-60h] BYREF
  struct _SecBuffer *v57; // [rsp+B0h] [rbp-58h] BYREF
  struct _SecBuffer *v58; // [rsp+B8h] [rbp-50h] BYREF
  struct _SecBuffer *v59; // [rsp+C0h] [rbp-48h] BYREF
  struct _SecBuffer *v60; // [rsp+C8h] [rbp-40h] BYREF
  struct _SecBuffer *v61; // [rsp+D0h] [rbp-38h] BYREF
  struct _SecBuffer *v62; // [rsp+D8h] [rbp-30h] BYREF
  struct _SecBuffer *v63; // [rsp+E0h] [rbp-28h] BYREF
  struct _SecBuffer *v64; // [rsp+E8h] [rbp-20h] BYREF
  struct _SecBuffer *v65; // [rsp+F0h] [rbp-18h] BYREF
  unsigned __int64 *v66; // [rsp+F8h] [rbp-10h]
  __int128 v67; // [rsp+100h] [rbp-8h] BYREF
  struct _SecBuffer *v68; // [rsp+110h] [rbp+8h] BYREF
  struct _SecBuffer *v69; // [rsp+118h] [rbp+10h] BYREF
  char v70[16]; // [rsp+120h] [rbp+18h] BYREF
  struct _SecBuffer *v71; // [rsp+130h] [rbp+28h] BYREF
  int v74; // [rsp+190h] [rbp+88h]

  v62 = 0i64;
  v53 = 0i64;
  v55 = 0i64;
  v15 = 28i64;
  v54 = 0i64;
  v56 = 0i64;
  v58 = 0i64;
  v17 = 0i64;
  v57 = 0i64;
  v65 = 0i64;
  v60 = 0i64;
  v59 = 0i64;
  v63 = 0i64;
  v64 = 0i64;
  v67 = 0i64;
  v49 = 0i64;
  v74 = 0;
  v66 = 0i64;
  v18 = a4;
  v19 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 23i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
      v19 = WPP_GLOBAL_Control;
    }
    if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v19 + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)v19 + 2), 24i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
        v19 = WPP_GLOBAL_Control;
      }
      if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)v19 + 28) & 4) != 0 )
        {
          WPP_SF_q(*((_QWORD *)v19 + 2), 0x19u, (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids, a1);
          v19 = WPP_GLOBAL_Control;
        }
        if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)v19 + 28) & 4) != 0 )
          {
            WPP_SF_q(*((_QWORD *)v19 + 2), 0x1Au, (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids, a2);
            v19 = WPP_GLOBAL_Control;
          }
          if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v19 + 28) & 4) != 0 )
          {
            WPP_SF_D(*((_QWORD *)v19 + 2), 27i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids, a4);
            v19 = WPP_GLOBAL_Control;
          }
        }
      }
    }
  }
  if ( a3 && v19 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v19 + 28) & 4) != 0 )
  {
    WPP_SF_S(
      *((_QWORD *)v19 + 2),
      0x1Cu,
      (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
      *(const wchar_t **)(a3 + 8));
    v19 = WPP_GLOBAL_Control;
  }
  if ( !a1 )
  {
    v20 = -2146893055;
    goto LABEL_69;
  }
  if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)v19 + 28) & 4) != 0 )
    {
      WPP_SF_D(
        *((_QWORD *)v19 + 2),
        29i64,
        &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
        *(unsigned int *)(a1 + 212));
      v19 = WPP_GLOBAL_Control;
    }
    if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v19 + 28) & 4) != 0 )
      WPP_SF_S(
        *((_QWORD *)v19 + 2),
        0x1Eu,
        (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
        (const wchar_t *)(a1 + 216));
  }
  v20 = ParseOutputBufferDesc(a8, v18, &v61, (struct SPBuffer *)v50, &v62, (struct SPBuffer *)&v67, &v65, &v60, &v64);
  if ( v20 )
    goto LABEL_66;
  v21 = ((-(__int64)((v18 & 0x4000) != 0) & 0x4000) + 28) | 0x100;
  v22 = (v18 & 0x4000) != 0 ? 0x200 : 0;
  if ( (v18 & 0x100) == 0 )
    v21 = (-(__int64)((v18 & 0x4000) != 0) & 0x4000) + 28;
  if ( (v18 & 0x800) != 0 )
    v22 |= 0x1000ui64;
  v15 = v21 | ((-(__int64)((v18 & 0x800) != 0) & 0xFFFFFFFFFFFF8800ui64) + 0x8000);
  v23 = v18 & 0x80000;
  if ( (v18 & 2) != 0 )
  {
    v15 |= 2ui64;
    v22 |= 0x100ui64;
    if ( v23 )
    {
      v20 = 120;
      goto LABEL_66;
    }
  }
  else
  {
    if ( v23 )
    {
      v15 |= 0x80000ui64;
      v22 |= 0x4000ui64;
    }
    if ( g_fManualCredValidation )
      v22 |= 0x4000ui64;
  }
  v24 = v15;
  v15 |= 0x80ui64;
  if ( (v18 & 0x80) == 0 )
    v15 = v24;
  v25 = v22 | 0x400;
  if ( (v18 & 0x80) == 0 )
    v25 = v22;
  if ( (v18 & 0x400) != 0 )
  {
    v15 |= 0x400ui64;
    if ( (v18 & 0x800) != 0
      && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 31i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
    }
  }
  v20 = ParseInputBufferDesc(
          a6,
          &v68,
          (struct SPBuffer *)v70,
          &v69,
          &v71,
          &v53,
          &v55,
          &v54,
          &v56,
          &v58,
          &v57,
          &v59,
          &v63);
  if ( v20 )
    goto LABEL_66;
  v26 = v25;
  if ( v63 )
  {
    pvBuffer = (__int64 *)v63->pvBuffer;
    if ( !pvBuffer || v63->cbBuffer < 8 )
    {
      v20 = 87;
      goto LABEL_66;
    }
    v43 = *pvBuffer;
    v26 = v25;
    if ( (*pvBuffer & 0x100000000i64) != 0 )
    {
      v26 = v25 | 0x100000000i64;
      v15 |= 0x100000000ui64;
    }
    if ( (v43 & 0x200000000i64) != 0 )
    {
      v19 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 32i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
        v43 = *pvBuffer;
        v19 = WPP_GLOBAL_Control;
      }
      v26 |= 0x200000000ui64;
      v15 |= 0x200000000ui64;
    }
    else
    {
      v19 = WPP_GLOBAL_Control;
    }
    if ( (v43 & ~v26 & 0xFFFFFFFF00000000ui64) != 0 )
    {
      if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v19 + 28) & 4) != 0 )
      {
        WPP_SF_i(
          *((_QWORD *)v19 + 2),
          0x21u,
          (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
          v43 & ~v26 & 0xFFFFFFFF00000000ui64);
        v19 = WPP_GLOBAL_Control;
      }
      goto LABEL_121;
    }
    v18 |= v43;
    if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v19 + 28) & 4) != 0 )
      WPP_SF_i(*((_QWORD *)v19 + 2), 0x22u, (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
  }
  v27 = v64;
  if ( v64 )
  {
    v44 = v64->pvBuffer;
    if ( !v44 )
    {
      v44 = SPExternalAlloc(8u);
      v27->pvBuffer = v44;
      if ( !v44 )
      {
        v20 = -2146893056;
        goto LABEL_66;
      }
      v27->cbBuffer = 8;
    }
    v66 = v44;
  }
  if ( !a2 )
  {
    if ( a3 )
      v38 = *(const unsigned __int16 **)(a3 + 8);
    else
      v38 = &Class;
    v39 = CSslContextManager::InstantiateClientContext(v19, v38, (struct CCredentialGroup *)a1, &v49, v18);
    v17 = v49;
    v20 = v39;
    if ( v39 )
      goto LABEL_66;
    v40 = *((_QWORD *)v49 + 1);
    *(_QWORD *)(v40 + 136) |= v26;
    CSslContext::SetCredentialGroup((CSslContext *)v40, (struct CCredentialGroup *)a1);
    v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v40 + 296i64))(v40, v53);
    if ( v20 )
      goto LABEL_66;
    v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *, struct _SecBuffer *))(*(_QWORD *)v40 + 304i64))(
            v40,
            v55,
            v54);
    if ( v20 )
      goto LABEL_66;
    v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v40 + 312i64))(v40, v56);
    if ( v20 )
      goto LABEL_66;
    v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *, struct _SecBuffer *))(*(_QWORD *)v40 + 328i64))(
            v40,
            v58,
            v57);
    if ( v20 )
      goto LABEL_66;
    v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v40 + 344i64))(v40, v59);
    if ( v20 )
      goto LABEL_66;
    v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBufferDesc *, struct _SecBuffer *))(*(_QWORD *)v40 + 368i64))(
            v40,
            a6,
            v60);
    if ( v20 )
      goto LABEL_66;
    v20 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v40 + 216i64))(v40, v50);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 36i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
    if ( v20 && (HIBYTE(*(_WORD *)(v40 + 34)) != 0xFE || v20 != 590692) )
    {
      if ( (v18 & 0x100) != 0 && Src )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v40 + 16i64))(v40);
LABEL_140:
      CSslContextManager::DeleteFullSslContext((CSslContextManager *)&g_SslContextManager, v17);
      goto LABEL_66;
    }
    *a7 = v17;
    CSchannelTelemetryContext::LogHandshakeStart(*(_QWORD *)(v40 + 120), 0, v18, a1, (__int64)v17);
    v41 = v61;
    if ( (v18 & 0x100) != 0 )
    {
      v61->pvBuffer = Src;
    }
    else
    {
      v45 = v61->pvBuffer;
      if ( v45 != Src )
      {
        if ( v61->cbBuffer < v51 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            LODWORD(v48) = v51;
            WPP_SF_dd(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x25u,
              (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
              v61->cbBuffer,
              v48);
          }
          v20 = -2146893023;
          goto LABEL_140;
        }
        memcpy_0(v45, Src, v51);
        (*(void (__fastcall **)(__int64, void *))(*(_QWORD *)v40 + 16i64))(v40, Src);
      }
    }
    v41->cbBuffer = v51;
    v19 = WPP_GLOBAL_Control;
    if ( v20 != 590692 )
      v20 = 590610;
    goto LABEL_67;
  }
  v28 = *(_QWORD *)(a2 + 8);
  v74 = 1;
  v49 = (struct CSslParentContext *)a2;
  if ( _InterlockedIncrement((volatile signed __int32 *)a2) != 1 )
  {
    v17 = v49;
    v20 = 120;
    goto LABEL_66;
  }
  *(_WORD *)(a2 + 34) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  *(_QWORD *)(v28 + 136) |= v26;
  CSslContext::SetCredentialGroup((CSslContext *)v28, (struct CCredentialGroup *)a1);
  if ( (*(_QWORD *)(v28 + 136) & 0x200004000i64) != 0x200004000i64 )
  {
    if ( *(_DWORD *)(v28 + 68) != 4
      || (v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v28 + 296i64))(v28, v53)) == 0
      && (v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *, struct _SecBuffer *))(*(_QWORD *)v28 + 304i64))(
                  v28,
                  v55,
                  v54)) == 0
      && (v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v28 + 312i64))(v28, v56)) == 0 )
    {
      v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *, struct _SecBuffer *))(*(_QWORD *)v28 + 328i64))(
              v28,
              v58,
              v57);
      if ( !v20 )
      {
        v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v28 + 344i64))(v28, v59);
        if ( !v20 )
        {
          v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBufferDesc *, struct _SecBuffer *))(*(_QWORD *)v28
                                                                                                 + 368i64))(
                  v28,
                  a6,
                  v60);
          if ( !v20 )
          {
            v29 = *(_QWORD *)v28;
            v30 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v28 + 384i64))(v28);
            v31 = v18 >> 8;
            LOBYTE(v31) = BYTE1(v18) & 1;
            LOBYTE(v32) = v30;
            v20 = (*(__int64 (__fastcall **)(__int64, struct _SecBufferDesc *, __int64, unsigned __int64))(v29 + 376))(
                    v28,
                    a8,
                    v32,
                    v31);
            if ( !v20 )
            {
              v33 = (*(__int64 (__fastcall **)(__int64, char *, char *))(*(_QWORD *)v28 + 192i64))(v28, v70, v50);
              if ( (*(_DWORD *)(v28 + 136) & 0x40000) == 0 )
              {
LABEL_54:
                v34 = *(_QWORD *)(v28 + 136);
                if ( (v34 & 0x10000000) != 0 )
                {
                  v15 |= 0x4000ui64;
                  *(_QWORD *)(v28 + 136) = v34 & 0xFFFFFFFFEFFFFFFFui64;
                }
                if ( v33 && !*(_DWORD *)(a2 + 36) )
                  *(_DWORD *)(a2 + 36) = v33;
                if ( v62 )
                  GenerateFatalAlertMessage(v33, v28, v18, (__int64)&v67);
                v35 = v61;
                if ( v33 == 590624 )
                {
                  if ( v65 )
                    GeneratePSKExchangeMessage(v28, (__int64)v65);
                }
                else if ( v33 == 590684 )
                {
                  v61->BufferType = 3;
                }
                if ( !IsFatalError(v33) )
                  *a7 = (struct CSslParentContext *)a2;
                v20 = AscIscPostProcessing(
                        v33,
                        (struct CSslContext *)v28,
                        (struct CSslParentContext *)a2,
                        a12,
                        v69,
                        v68,
                        (struct SPBuffer *)v70,
                        v35,
                        (struct SPBuffer *)v50,
                        v18,
                        a11,
                        a10);
                goto LABEL_65;
              }
              v46 = *(_QWORD *)(a2 + 8);
              v47 = *(_DWORD *)(v46 + 64);
              (**(void (__fastcall ***)(__int64, _QWORD))v46)(v46, 0i64);
              if ( (v47 & 0x800A2AAA) != 0 )
                SPExternalFree(*(void **)(a2 + 8));
              v28 = *(_QWORD *)(a2 + 16);
              *(_QWORD *)(a2 + 8) = v28;
              *(_QWORD *)(a2 + 16) = 0i64;
              if ( v28 )
              {
                v33 = (*(__int64 (__fastcall **)(__int64, char *, char *))(*(_QWORD *)v28 + 192i64))(v28, v70, v50);
                goto LABEL_54;
              }
              v20 = 1359;
            }
          }
        }
      }
    }
LABEL_65:
    v17 = v49;
LABEL_66:
    v19 = WPP_GLOBAL_Control;
    goto LABEL_67;
  }
  v19 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 38i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
    v19 = WPP_GLOBAL_Control;
  }
  v17 = v49;
LABEL_121:
  v20 = -2146892963;
LABEL_67:
  v36 = v62;
  if ( v62 )
  {
    v62->pvBuffer = (void *)*((_QWORD *)&v67 + 1);
    v36->cbBuffer = DWORD1(v67);
    v19 = WPP_GLOBAL_Control;
  }
LABEL_69:
  if ( a9 )
  {
    *a9 = v15;
    v19 = WPP_GLOBAL_Control;
  }
  if ( v66 )
  {
    *v66 = v15 & 0xFFFFFFFF00000000ui64;
    v19 = WPP_GLOBAL_Control;
  }
  if ( v74 && v17 )
  {
    _InterlockedDecrement((volatile signed __int32 *)v17);
    v19 = WPP_GLOBAL_Control;
  }
  if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v19 + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)v19 + 2), 39i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids, v20);
  return TranslateToSecurityStatus(v20);
}
// 180036081: conditional instruction was optimized away because ecx.4 is in (FE00..FEFF)
// 18000BC28: variable 'v32' is possibly undefined
// 18000BDF0: variable 'v19' is possibly undefined
// 1800360CF: variable 'v48' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092DA0: using guessed type __int64 g_SslContextManager;
// 180092F04: using guessed type int g_fManualCredValidation;

//----- (000000018000BFE0) ----------------------------------------------------
__int64 __fastcall SpSealMessage(__int64 a1, int a2, struct _SecBufferDesc *a3)
{
  struct CSslUserContext *UserContext; // rax
  struct CSslUserContext *v7; // rcx
  int v9; // eax
  unsigned int v10; // eax
  int v11; // edx
  unsigned int v12; // eax
  unsigned int v13; // ebx
  CCipherMill *v14; // r10
  __int64 v15; // r10
  int v16; // [rsp+20h] [rbp-18h]

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
  UserContext = SslFindUserContext(a1);
  v7 = UserContext;
  if ( UserContext )
  {
    v9 = *((_DWORD *)UserContext + 2);
    if ( v9 == 4 || (v10 = v9 - 51, v10 <= 0x1B) && (v11 = 167772161, _bittest(&v11, v10)) )
    {
      if ( (*((_DWORD *)v7 + 4) & 0x1000i64) != 0 )
        v12 = SslSealMessageConnection(v7, a2, a3);
      else
        v12 = SslSealMessageStream(v7, a2, a3);
      v13 = v12;
      v14 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && (unsigned int)TranslateToSecurityStatus(v12)
         || (*((_BYTE *)v14 + 28) & 4) != 0) )
      {
        v16 = TranslateToSecurityStatus(v13);
        WPP_SF_DD(*(_QWORD *)(v15 + 16), 0x15u, (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, v16, v16);
      }
      return TranslateToSecurityStatus(v13);
    }
    else
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
        WPP_SF_DD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x14u,
          (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids,
          -2146893033,
          -2146893033);
      return 2148074263i64;
    }
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x13u,
        (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids,
        -2146893055,
        -2146893055);
    return 2148074241i64;
  }
}
// 18000C102: variable 'v14' is possibly undefined
// 18000C110: variable 'v15' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000C160) ----------------------------------------------------
__int64 __fastcall SpUserQueryContextAttributes(__int64 a1, unsigned int a2, struct _SecPkgContext_TokenBinding *a3)
{
  struct CSslUserContext *UserContext; // rax
  struct CSslUserContext *v6; // rcx
  struct CSslUserContext *v7; // rbx
  unsigned int v9; // ecx
  __int64 v11; // rax

  UserContext = SslFindUserContext(a1);
  v7 = UserContext;
  if ( !UserContext )
    return 2148074241i64;
  if ( a2 > 0x24 )
  {
    if ( a2 > 0x6C )
    {
      switch ( a2 )
      {
        case 'm':
          return (unsigned int)SpQueryTokenBinding(UserContext, a3);
        case 'n':
          return (unsigned int)SpQueryConnectionInfoEx(UserContext, (struct _SecPkgContext_ConnectionInfoEx *)a3);
        case 'o':
          return (unsigned int)SpQueryTokenBindingEKM(UserContext, (struct _SecPkgContext_KeyingMaterial *)a3);
        case 'p':
          return (unsigned int)SpQueryKeyingMaterial(UserContext, (struct _SecPkgContext_KeyingMaterial_Inproc *)a3);
        case 'r':
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 19i64, &WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids);
          }
          return (unsigned int)SpQueryCertificateValidationResult(
                                 *((_QWORD *)v7 + 2),
                                 *((_DWORD *)v7 + 95),
                                 *((_DWORD *)v7 + 94),
                                 (struct _SecPkgContext_CertificateValidationResult *)a3);
      }
    }
    else
    {
      switch ( a2 )
      {
        case 'l':
          return (unsigned int)SpQuerySrtpParameters(UserContext, (struct _SecPkgContext_SrtpParameters *)a3);
        case 'Z':
          return (unsigned int)GetOldConnectionInfo(UserContext, (struct _SecPkgContext_ConnectionInfo *)a3);
        case 'S':
          return SpQueryRemoteCertContext(UserContext, (const CERT_CONTEXT **)a3);
        case ']':
          return (unsigned int)SpQuerySessionInfo(UserContext, (struct _SecPkgContext_SessionInfo *)a3);
        case 'Q':
          return SpQueryRemoteCred(UserContext, a3);
        case 'd':
          return (unsigned int)GetCipherInfo(UserContext, (struct _SecPkgContext_CipherInfo *)a3);
      }
    }
  }
  else
  {
    if ( a2 == 36 )
      return (unsigned int)SpQueryNegotiatedTlsExtensions(
                             UserContext,
                             (struct _SecPkgContext_NegotiatedTlsExtensions *)a3);
    if ( a2 > 7 )
    {
      switch ( a2 )
      {
        case 0xAu:
          return (unsigned int)SpQueryPackageInfo(v6, a3);
        case 0x12u:
          v11 = *((_QWORD *)UserContext + 33);
          if ( v11 )
          {
            *(_QWORD *)&a3->MajorVersion = v11;
            return 0;
          }
          else
          {
            v9 = -2146893045;
            if ( *((_DWORD *)v7 + 68) )
              return *((unsigned int *)v7 + 68);
          }
          return v9;
        case 0x19u:
          return (unsigned int)SpQueryUniqueBindings(UserContext, (struct _SecPkgContext_Bindings *)a3);
        case 0x1Au:
          return (unsigned int)SpQueryEndpointBindings(UserContext, (struct _SecPkgContext_Bindings *)a3);
        case 0x23u:
          return (unsigned int)SpQueryApplicationProtocol(UserContext, (struct _SecPkgContext_ApplicationProtocol *)a3);
      }
    }
    else
    {
      switch ( a2 )
      {
        case 7u:
          return (unsigned int)SpQueryProtoInfo(UserContext, a3);
        case 0u:
          return (unsigned int)SpQuerySizes(UserContext, (struct _SecPkgContext_Sizes *)a3);
        case 1u:
          return SpQueryNames(UserContext, (struct _SecPkgContext_NamesW *)a3);
        case 2u:
          return (unsigned int)SpQueryLifespan(UserContext, (struct _SecPkgContext_Lifespan *)a3);
        case 4u:
          return (unsigned int)SpQueryStreamSizes(UserContext, (struct _SecPkgContext_StreamSizes *)a3);
        case 5u:
          return (unsigned int)SpQueryKeyInfo(UserContext, a3);
      }
    }
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    WPP_SF_d(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x14u, (__int64)&WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids, a2);
  return 2148074242i64;
}
// 1800363C3: variable 'v6' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000C2D0) ----------------------------------------------------
__int64 __fastcall SpUnsealMessage(__int64 a1, struct _SecBufferDesc *a2)
{
  struct CSslUserContext *UserContext; // rax
  unsigned int v5; // eax
  unsigned int v6; // ebx
  CCipherMill *v7; // r10
  unsigned int v9; // eax
  __int64 v10; // r10
  __int64 v11; // r10
  int v12; // [rsp+20h] [rbp-18h]

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
  UserContext = SslFindUserContext(a1);
  if ( UserContext )
  {
    if ( *((_DWORD *)UserContext + 2) == 4 || *((_DWORD *)UserContext + 2) == 79 )
    {
      if ( (*((_DWORD *)UserContext + 4) & 0x1000i64) != 0 )
        v5 = SslUnsealMessageConnection(UserContext, a2);
      else
        v5 = SslUnsealMessageStream(UserContext, a2);
      v6 = v5;
      v7 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        v9 = TranslateToSecurityStatus(v5);
        WPP_SF_D(*(_QWORD *)(v10 + 16), 25i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, v9);
        v7 = WPP_GLOBAL_Control;
      }
      if ( v6 == -2146893008 )
      {
        SslUnsealHideDecryptErrorDelay();
        v7 = WPP_GLOBAL_Control;
      }
      if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control
        && ((*((_BYTE *)v7 + 28) & 1) != 0 && (unsigned int)TranslateToSecurityStatus(v6)
         || (*((_BYTE *)v7 + 28) & 4) != 0) )
      {
        v12 = TranslateToSecurityStatus(v6);
        WPP_SF_DD(*(_QWORD *)(v11 + 16), 0x1Au, (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, v12, v12);
      }
      return TranslateToSecurityStatus(v6);
    }
    else
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
        WPP_SF_DD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x18u,
          (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids,
          -2146893033,
          -2146893033);
      return 2148074263i64;
    }
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x17u,
        (__int64)&WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids,
        -2146893055,
        -2146893055);
    return 2148074241i64;
  }
}
// 180036574: variable 'v10' is possibly undefined
// 18000C373: variable 'v7' is possibly undefined
// 1800365BB: variable 'v11' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000C3A8) ----------------------------------------------------
__int64 __fastcall TranslateToSecurityStatus(unsigned int a1)
{
  if ( (a1 & 0x1FFF0000) == 589824 )
  {
    if ( a1 + 2146893823 <= 0x2E )
      return 2148074244i64;
    if ( a1 + 2146889727 > 0x100E && a1 + 2146885612 > 0xFEC && a1 != -2146885615 )
      return a1;
  }
  else if ( !a1 )
  {
    return 0i64;
  }
  if ( a1 > 0x80092004 )
  {
    switch ( a1 )
    {
      case 0x800B0101:
      case 0x800B0102:
        return 2148074280i64;
      case 0x800B0109:
        return 2148074277i64;
      case 0x800B010C:
        return 2148081680i64;
      case 0x800B010F:
        return 2148074274i64;
      default:
        return 2148074244i64;
    }
  }
  else
  {
    switch ( a1 )
    {
      case 0x80092004:
        return 2148074253i64;
      case 0xEu:
        return 2148074240i64;
      case 0x57u:
        return 2148074333i64;
      case 0x78u:
        return 2148074242i64;
      case 0x7Au:
        return 2148074273i64;
      default:
        return 2148074244i64;
    }
  }
}

//----- (000000018000C40C) ----------------------------------------------------
__int64 __fastcall SslUnsealMessageStream(struct CSslUserContext *a1, struct _SecBufferDesc *a2)
{
  struct _SecBuffer *v2; // rdi
  struct _SecBuffer *v3; // rsi
  struct _SecBuffer *v4; // r12
  struct _SecBuffer *v5; // r14
  CCipherMill *v8; // r10
  unsigned int cBuffers; // r11d
  unsigned int v10; // ecx
  PSecBuffer pBuffers; // rdx
  unsigned int *p_BufferType; // r9
  __int64 v13; // r8
  _BYTE *pvBuffer; // rdx
  unsigned int v15; // ecx
  unsigned int v16; // r11d
  int v17; // r9d
  unsigned int v18; // r15d
  int v19; // r8d
  int v20; // eax
  unsigned int v21; // r9d
  unsigned int v22; // eax
  unsigned int v23; // ebx
  unsigned int v25; // eax
  unsigned __int16 v26; // dx
  bool v27; // zf
  int v28; // ecx
  int v29; // eax
  unsigned int v30; // r11d
  __int64 v31; // [rsp+20h] [rbp-30h]
  unsigned int v32; // [rsp+30h] [rbp-20h] BYREF
  unsigned int cbBuffer; // [rsp+34h] [rbp-1Ch]
  unsigned __int8 *v34; // [rsp+38h] [rbp-18h]
  __int128 v35; // [rsp+40h] [rbp-10h] BYREF
  unsigned __int8 v36; // [rsp+98h] [rbp+48h] BYREF
  struct _SecBuffer *v37; // [rsp+A0h] [rbp+50h]

  v2 = 0i64;
  v3 = 0i64;
  v4 = 0i64;
  v5 = 0i64;
  v37 = 0i64;
  v36 = 0;
  v35 = 0i64;
  v8 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 72i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
    v8 = WPP_GLOBAL_Control;
  }
  cBuffers = a2->cBuffers;
  v10 = 0;
  if ( !cBuffers )
    goto LABEL_95;
  pBuffers = a2->pBuffers;
  p_BufferType = &pBuffers->BufferType;
  do
  {
    v13 = *p_BufferType;
    if ( (_DWORD)v13 )
    {
      v13 = (unsigned int)(v13 - 1);
      if ( (_DWORD)v13 )
      {
        if ( (_DWORD)v13 == 16 )
          v37 = &pBuffers[v10];
      }
      else
      {
        v2 = &pBuffers[v10];
      }
    }
    else if ( v3 )
    {
      if ( v4 )
      {
        if ( !v5 )
          v5 = &pBuffers[v10];
      }
      else
      {
        v4 = &pBuffers[v10];
      }
    }
    else
    {
      v3 = &pBuffers[v10];
    }
    ++v10;
    p_BufferType += 4;
  }
  while ( v10 < cBuffers );
  if ( !v2 || !v3 || !v4 || !v5 )
  {
LABEL_95:
    if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 5) == 0 )
      return 2148074248i64;
    v26 = 73;
    goto LABEL_97;
  }
  pvBuffer = v2->pvBuffer;
  if ( !pvBuffer )
  {
    if ( v8 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v8 + 28) & 5) == 0 )
      return 2148074248i64;
    v26 = 74;
LABEL_97:
    WPP_SF_DD(
      *((_QWORD *)v8 + 2),
      v26,
      (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
      -2146893048,
      -2146893048);
    return 2148074248i64;
  }
  v15 = *((_DWORD *)a1 + 6);
  v34 = (unsigned __int8 *)v2->pvBuffer;
  cbBuffer = v2->cbBuffer;
  v16 = v2->cbBuffer;
  v32 = v2->cbBuffer;
  if ( v15 > 0x800 )
  {
    if ( v15 == 4096 || v15 == 0x2000 || v15 == 0x10000 || v15 == 0x20000 || v15 == 0x40000 )
      goto LABEL_20;
    v27 = v15 == 0x80000;
  }
  else
  {
    if ( v15 == 2048 || v15 == 16 || v15 == 32 || v15 == 64 || v15 == 128 || v15 == 256 || v15 == 512 )
      goto LABEL_20;
    v27 = v15 == 1024;
  }
  if ( !v27 )
  {
    v23 = -2146893055;
    goto LABEL_34;
  }
LABEL_20:
  v17 = *((_DWORD *)a1 + 17);
  v18 = v17 + *((_DWORD *)a1 + 16);
  if ( v16 < v18 )
  {
    if ( (v15 & 0x50000) != 0 && !*((_BYTE *)a1 + 140) )
    {
      if ( pvBuffer[1] == 0xFE && ((unsigned __int8)pvBuffer[2] | ((unsigned __int8)pvBuffer[1] << 8)) <= 0xFEFFu )
      {
        v28 = (unsigned __int8)pvBuffer[11];
        v29 = (unsigned __int8)pvBuffer[12];
      }
      else
      {
        v28 = (unsigned __int8)pvBuffer[3];
        v29 = (unsigned __int8)pvBuffer[4];
      }
      if ( v17 + (v29 | (unsigned int)(v28 << 8)) < v18
        && *pvBuffer == 20
        && ((unsigned __int8)pvBuffer[4] | ((unsigned __int8)pvBuffer[3] << 8)) < *((_DWORD *)a1 + 29) )
      {
        v23 = -2146893005;
        goto LABEL_34;
      }
    }
    cbBuffer = v17 + *((_DWORD *)a1 + 16);
    goto LABEL_44;
  }
  if ( pvBuffer[1] == 0xFE && ((unsigned __int8)pvBuffer[2] | ((unsigned __int8)pvBuffer[1] << 8)) <= 0xFEFFu )
  {
    v19 = (unsigned __int8)pvBuffer[11];
    v20 = (unsigned __int8)pvBuffer[12];
  }
  else
  {
    v19 = (unsigned __int8)pvBuffer[3];
    v20 = (unsigned __int8)pvBuffer[4];
  }
  v13 = v20 | (unsigned int)(v19 << 8);
  v21 = v13 + v17;
  if ( v21 < v18 )
  {
    v23 = -2146893048;
    v36 = 50;
    goto LABEL_34;
  }
  LODWORD(v35) = v16;
  *((_QWORD *)&v35 + 1) = &pvBuffer[v18];
  DWORD1(v35) = v21 - v18;
  if ( v16 < v21 )
  {
    cbBuffer = v21;
LABEL_44:
    v23 = -2146893032;
    goto LABEL_45;
  }
  if ( (v15 & 0x3000) != 0 )
    v22 = Tls13DecryptHandler(a1, (struct SPBuffer *)&v32, (struct SPBuffer *)&v35, &v36);
  else
    v22 = TlsDecryptHandler(a1, (struct SPBuffer *)&v32, (struct SPBuffer *)&v35, &v36);
  v23 = v22;
  if ( (*((_DWORD *)a1 + 6) & 0xF0000) != 0 )
  {
    if ( !v22 )
    {
      if ( !CSslUserContext::DTLSCheckRecordValidity(
              a1,
              v34[10] | ((v34[9] | ((v34[8] | ((v34[7] | ((v34[6] | ((v34[5] | ((v34[4] | ((unsigned __int64)v34[3] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) )
      {
        v8 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 76i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v30);
          v8 = WPP_GLOBAL_Control;
        }
        v23 = -2146893040;
        goto LABEL_34;
      }
      goto LABEL_30;
    }
  }
  else if ( !v22 )
  {
LABEL_30:
    if ( cbBuffer < v2->cbBuffer )
    {
      v5->BufferType = 5;
      v5->cbBuffer = v2->cbBuffer - cbBuffer;
      v5->pvBuffer = (char *)v2->pvBuffer + cbBuffer;
    }
    v2->BufferType = 7;
    v2->cbBuffer = v18;
    v3->BufferType = 1;
    v3->pvBuffer = (void *)*((_QWORD *)&v35 + 1);
    v3->cbBuffer = DWORD1(v35);
    v4->BufferType = 6;
    v4->pvBuffer = (char *)v3->pvBuffer + DWORD1(v35);
    v4->cbBuffer = v32 - DWORD1(v35) - v18;
    goto LABEL_33;
  }
  if ( v22 == 590625 )
    goto LABEL_30;
  if ( v22 == -2146893032 )
  {
LABEL_45:
    v3->BufferType = 4;
    v25 = cbBuffer - v2->cbBuffer;
    v3->cbBuffer = v25;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_ddd(*((_QWORD *)WPP_GLOBAL_Control + 2), (__int64)pvBuffer, v13, v2->cbBuffer, cbBuffer, v25);
    v2->BufferType = 4;
    v2->cbBuffer = cbBuffer - v2->cbBuffer;
    v8 = WPP_GLOBAL_Control;
    goto LABEL_34;
  }
LABEL_33:
  v8 = WPP_GLOBAL_Control;
LABEL_34:
  if ( v37 )
  {
    GenerateUserFatalAlertMessage(a1, (__int64)v37, v36);
    v8 = WPP_GLOBAL_Control;
  }
  if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)v8 + 28) & 1) != 0 && v23 || (*((_BYTE *)v8 + 28) & 4) != 0) )
  {
    LODWORD(v31) = v23;
    WPP_SF_DD(*((_QWORD *)v8 + 2), 0x52u, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v23, v31);
  }
  return v23;
}
// 1800368C6: variable 'pvBuffer' is possibly undefined
// 1800368C6: variable 'v13' is possibly undefined
// 180036894: variable 'v30' is possibly undefined
// 180036908: variable 'v31' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000C710) ----------------------------------------------------
struct CSslUserContext *__fastcall SslFindUserContext(__int64 a1)
{
  struct CSslUserContext *v2; // rax
  struct CSslUserContext *v3; // rbx

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_ba773d91511536867a821af0ee22c47a_Traceguids);
  v2 = SslReferenceUserContext(a1, 0);
  v3 = v2;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x17u, (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids, v2);
  return v3;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000C774) ----------------------------------------------------
struct CSslUserContext *__fastcall SslReferenceUserContext(__int64 a1, unsigned __int8 a2)
{
  int v2; // r14d
  _QWORD *v4; // rbx
  CCipherMill *v5; // r10
  unsigned int v6; // ebp
  __int64 v7; // rdi
  __int64 v8; // rdi
  struct _RTL_RESOURCE *v9; // rcx
  _QWORD **v10; // rdx
  _QWORD *v11; // rax
  CCipherMill *v12; // rcx
  __int64 v14; // rcx
  _QWORD *v15; // rdx
  __int64 v16; // [rsp+20h] [rbp-28h]

  v2 = a2;
  v4 = 0i64;
  v5 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 16i64, &WPP_ba773d91511536867a821af0ee22c47a_Traceguids);
    v5 = WPP_GLOBAL_Control;
  }
  v6 = (dwSslContextListCount - 1) & (BYTE3(a1)
                                    + a1
                                    + WORD1(a1)
                                    + ((unsigned int)a1 >> 8)
                                    + ((BYTE3(a1) + (_DWORD)a1 + WORD1(a1) + ((unsigned int)a1 >> 8)) >> 4));
  v7 = v6 & (dwSslContextLockCount - 1);
  if ( v5 != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)v5 + 28) & 4) != 0 )
    {
      WPP_SF_qd(*((_QWORD *)v5 + 2), 0x11u, (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids, a1, v2);
      v5 = WPP_GLOBAL_Control;
    }
    if ( v5 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v5 + 28) & 4) != 0 )
    {
      LODWORD(v16) = v7;
      WPP_SF_dd(*((_QWORD *)v5 + 2), 0x12u, (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids, v6, v16);
    }
  }
  v8 = 96 * v7;
  v9 = (struct _RTL_RESOURCE *)((char *)SslContextLock + v8);
  if ( (_BYTE)v2 )
    RtlAcquireResourceExclusive(v9, 1u);
  else
    RtlAcquireResourceShared(v9, 1u);
  v10 = (_QWORD **)((char *)SslContextList + 16 * v6);
  v11 = *v10;
  while ( v11 != v10 )
  {
    v4 = v11 - 38;
    if ( *(v11 - 2) == a1 )
    {
      if ( (_BYTE)v2 )
      {
        v14 = *v11;
        if ( *(_QWORD **)(*v11 + 8i64) != v11 || (v15 = (_QWORD *)v11[1], (_QWORD *)*v15 != v11) )
          __fastfail(3u);
        *v15 = v14;
        *(_QWORD *)(v14 + 8) = v15;
      }
      break;
    }
    v11 = (_QWORD *)*v11;
    v4 = 0i64;
  }
  RtlReleaseResource((PRTL_RESOURCE)((char *)SslContextLock + v8));
  v12 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_q(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x13u,
        (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids,
        v4);
      v12 = WPP_GLOBAL_Control;
    }
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v12 + 28) & 4) != 0 )
      {
        WPP_SF_qq(*((_QWORD *)v12 + 2), 0x14u, (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids, a1, v4);
        v12 = WPP_GLOBAL_Control;
      }
      if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
        WPP_SF_q(*((_QWORD *)v12 + 2), 0x15u, (__int64)&WPP_ba773d91511536867a821af0ee22c47a_Traceguids, v4);
    }
  }
  return (struct CSslUserContext *)v4;
}
// 1800369DF: variable 'v16' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800919E0: using guessed type unsigned int dwSslContextListCount;
// 1800919E4: using guessed type unsigned int dwSslContextLockCount;

//----- (000000018000C91C) ----------------------------------------------------
__int64 __fastcall TlsDecryptHandler(
        struct CSslUserContext *a1,
        struct SPBuffer *a2,
        struct SPBuffer *a3,
        unsigned __int8 *a4)
{
  int v4; // eax
  int v5; // r14d
  unsigned __int8 *v10; // r8
  int v11; // edx
  bool v12; // zf
  int v13; // ecx
  unsigned int v14; // ebp
  int v15; // ecx
  int v16; // ecx
  CCipherMill *v17; // rcx
  unsigned int v18; // eax
  CCipherMill *v19; // rcx
  unsigned __int64 v21; // r14
  unsigned int v22; // eax
  unsigned int v23; // r15d
  int v24; // eax
  unsigned int v25; // esi
  CCipherMill *v26; // rcx
  unsigned __int16 v27; // dx
  unsigned __int16 v28; // dx
  CCipherMill *v29; // r10
  int v30; // r14d
  int v31; // r8d
  unsigned int v32; // eax
  unsigned int v33; // r12d
  CCipherMill *v34; // rcx
  unsigned int v35; // r12d
  unsigned __int8 *v36; // r8
  unsigned __int64 v37; // r14
  unsigned int v38; // eax
  unsigned int v39; // r15d
  CCipherMill *v40; // rcx
  CCipherMill *v41; // rcx
  unsigned __int16 v42; // dx
  _BYTE *v43; // rax
  unsigned __int8 *v44; // rcx
  unsigned __int64 v45; // rbp
  __int64 v46; // rcx
  int v47; // r9d
  _BYTE *v48; // r14
  unsigned int v49; // eax
  unsigned int v50; // ebp
  CCipherMill *v51; // rcx
  unsigned __int64 *v52; // [rsp+20h] [rbp-78h]
  struct SPBuffer *v53; // [rsp+28h] [rbp-70h]
  unsigned int v54; // [rsp+28h] [rbp-70h]
  struct SPBuffer *v55; // [rsp+30h] [rbp-68h]
  unsigned __int8 *v56; // [rsp+38h] [rbp-60h]
  unsigned __int8 *v57; // [rsp+38h] [rbp-60h]
  __int64 v58; // [rsp+40h] [rbp-58h]
  unsigned int v59; // [rsp+50h] [rbp-48h] BYREF
  unsigned int v60; // [rsp+54h] [rbp-44h] BYREF
  int v61; // [rsp+58h] [rbp-40h]
  unsigned int v62; // [rsp+A0h] [rbp+8h] BYREF
  int v63; // [rsp+A8h] [rbp+10h]
  unsigned __int8 *v64; // [rsp+B8h] [rbp+20h]

  v64 = a4;
  v4 = 4;
  v5 = *((_DWORD *)a1 + 17) + *((_DWORD *)a1 + 16);
  v61 = v5;
  v10 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
  v11 = *((_DWORD *)a1 + 6) & 0xF0000;
  v62 = v11;
  if ( v11 )
    v4 = 12;
  v12 = *((_DWORD *)a1 + 2) == 4;
  v63 = v4;
  if ( !v12 )
  {
    v26 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
      return 2148074248i64;
    v27 = 34;
    goto LABEL_102;
  }
  v13 = *v10;
  if ( ((v13 - 20) & 0xFFFFFFFC) == 0 && v13 != 21 )
    *((_BYTE *)a1 + 112) = 0;
  v14 = -2146893008;
  v15 = v13 - 21;
  if ( v15 )
  {
    v16 = v15 - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        v17 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 35i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
            v17 = WPP_GLOBAL_Control;
          }
          if ( v17 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v17 + 28) & 4) != 0 )
            WPP_SF_(*((_QWORD *)v17 + 2), 36i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
        }
        v18 = TlsDecryptMessage(
                *((_QWORD *)a1 + 11),
                *((_QWORD *)a1 + 5),
                v5 - *((_DWORD *)a1 + 17),
                *((_DWORD *)a1 + 17),
                (unsigned __int64 *)a1 + 12,
                a2,
                a3,
                a4);
        v14 = v18;
        v19 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 37i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v18);
            v19 = WPP_GLOBAL_Control;
          }
          if ( v19 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v19 + 28) & 4) != 0 )
          {
            WPP_SF_i(
              *((_QWORD *)v19 + 2),
              0x26u,
              (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
              *((_QWORD *)a1 + 12));
            v19 = WPP_GLOBAL_Control;
          }
        }
        if ( v62 && !*((_BYTE *)a1 + 140) )
        {
          *((_BYTE *)a1 + 140) = 1;
          v19 = WPP_GLOBAL_Control;
        }
        if ( v19 == (CCipherMill *)&WPP_GLOBAL_Control
          || ((*((_BYTE *)v19 + 28) & 1) == 0 || !v14) && (*((_BYTE *)v19 + 28) & 4) == 0 )
        {
          return v14;
        }
        v28 = 39;
LABEL_56:
        LODWORD(v52) = v14;
        WPP_SF_DD(*((_QWORD *)v19 + 2), v28, (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v14, v52);
        return v14;
      }
      v26 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 62i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
        v26 = WPP_GLOBAL_Control;
      }
      *a4 = 10;
      if ( v26 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v26 + 28) & 5) == 0 )
        return 2148074248i64;
      v27 = 63;
      goto LABEL_102;
    }
    v29 = WPP_GLOBAL_Control;
    v30 = 40;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 40i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
      v29 = WPP_GLOBAL_Control;
      v11 = v62;
    }
    v31 = *((_DWORD *)a1 + 6);
    if ( (v31 & 0x800A2AAA) != 0 )
    {
      v32 = QueryStreamSizes(*((_QWORD *)a1 + 11), *((_DWORD *)a1 + 14), v31, *((_DWORD *)a1 + 15), 0i64, &v60, &v59);
      v33 = v32;
      if ( v32 )
      {
        v34 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 41i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v32);
            v34 = WPP_GLOBAL_Control;
          }
          if ( v34 != (CCipherMill *)&WPP_GLOBAL_Control
            && ((*((_BYTE *)v34 + 28) & 1) != 0 || (*((_BYTE *)v34 + 28) & 4) != 0) )
          {
            LODWORD(v52) = v33;
            WPP_SF_DD(*((_QWORD *)v34 + 2), 0x2Au, (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v33, v52);
          }
        }
        return v33;
      }
      if ( *(_DWORD *)a2 > v61 + v63 + v59 + v60 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 43i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
        goto LABEL_142;
      }
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 44i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
      v35 = v62;
      v36 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
      if ( v62 )
        v37 = v36[10] | ((v36[9] | ((v36[8] | ((v36[7] | ((v36[6] | ((v36[5] | ((v36[4] | ((unsigned __int64)v36[3] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      else
        v37 = *((_QWORD *)a1 + 12);
      LODWORD(v58) = 0;
      v56 = (unsigned __int8 *)v37;
      v55 = (struct SPBuffer *)((char *)a3 + 4);
      LODWORD(v53) = *(_DWORD *)a3;
      v52 = (unsigned __int64 *)*((_QWORD *)a3 + 1);
      v38 = SslDecryptPacket(*((_QWORD *)a1 + 11), *((_QWORD *)a1 + 5), v36);
      v39 = v38;
      v40 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 45i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v38);
          v40 = WPP_GLOBAL_Control;
        }
        if ( v40 != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)v40 + 28) & 4) != 0 )
          {
            WPP_SF_D(
              *((_QWORD *)v40 + 2),
              46i64,
              &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
              *((unsigned int *)a3 + 1));
            v40 = WPP_GLOBAL_Control;
          }
          if ( v40 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v40 + 28) & 4) != 0 )
            WPP_SF_i(
              *((_QWORD *)v40 + 2),
              0x2Fu,
              (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
              *((_QWORD *)a1 + 12),
              v52,
              v53,
              v55,
              v37,
              0);
        }
      }
      if ( v35 )
        *((_QWORD *)a1 + 12) = v37;
      else
        ++*((_QWORD *)a1 + 12);
      if ( !v39 )
      {
        if ( *((_DWORD *)a3 + 1) != v63 || (v43 = (_BYTE *)*((_QWORD *)a3 + 1), *v43) )
        {
          *v64 = 10;
          v26 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
          {
            return 2148074248i64;
          }
          v27 = 49;
LABEL_102:
          LODWORD(v52) = -2146893048;
          WPP_SF_DD(
            *((_QWORD *)v26 + 2),
            v27,
            (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
            -2146893048,
            v52);
          return 2148074248i64;
        }
        v30 = 76;
        *((_DWORD *)a1 + 36) = (unsigned __int8)v43[5] + 1 + ((unsigned __int8)v43[4] << 8);
LABEL_143:
        *((_DWORD *)a1 + 2) = v30;
        *((_DWORD *)a3 + 1) = 0;
        v19 = WPP_GLOBAL_Control;
        v14 = 590625;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
          return v14;
        v28 = 57;
        goto LABEL_56;
      }
      *v64 = 20;
      v41 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
        return v14;
      v42 = 48;
      goto LABEL_109;
    }
    if ( !v11 )
    {
      v30 = 76;
LABEL_142:
      *((_DWORD *)a2 + 1) = 0;
      goto LABEL_143;
    }
    v44 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
    v45 = v44[10] | ((v44[9] | ((v44[8] | ((v44[7] | ((v44[6] | ((v44[5] | ((v44[4] | ((unsigned __int64)v44[3] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
    if ( HIWORD(v45) < (unsigned int)*((int *)a1 + 29) )
    {
      v14 = -2146893005;
      if ( v29 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v29 + 28) & 5) == 0 )
        return v14;
      v46 = *((_QWORD *)v29 + 2);
      v42 = 50;
      v47 = -2146893005;
      goto LABEL_110;
    }
    v62 = *((_DWORD *)a2 + 1);
    v48 = LocalAlloc(0x40u, v62);
    if ( !v48 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
        WPP_SF_DD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x33u,
          (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
          -2146893056,
          -2146893056);
      return 2148074240i64;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 52i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
    v57 = (unsigned __int8 *)v45;
    v54 = v62;
    HIDWORD(v52) = HIDWORD(v48);
    v49 = SslDecryptPacket(*((_QWORD *)a1 + 11), *((_QWORD *)a1 + 5), *((_QWORD *)a2 + 1));
    v50 = v49;
    v51 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 53i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v49);
        v51 = WPP_GLOBAL_Control;
      }
      if ( v51 != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)v51 + 28) & 4) != 0 )
        {
          WPP_SF_D(
            *((_QWORD *)v51 + 2),
            54i64,
            &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
            *((unsigned int *)a3 + 1));
          v51 = WPP_GLOBAL_Control;
        }
        if ( v51 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v51 + 28) & 4) != 0 )
          WPP_SF_i(
            *((_QWORD *)v51 + 2),
            0x37u,
            (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
            *((_QWORD *)a1 + 12),
            v48,
            v54,
            &v62,
            v57,
            0);
      }
    }
    if ( v50 )
    {
      *a4 = 20;
      v14 = -2146893008;
      goto LABEL_137;
    }
    if ( v62 >= 0xC )
    {
      if ( !*((_BYTE *)a1 + 140) )
      {
        if ( *v48 != 1 )
        {
          v14 = -2146893005;
          goto LABEL_137;
        }
        goto LABEL_135;
      }
      if ( *v48 == 1 )
      {
LABEL_135:
        v14 = 590625;
        *((_DWORD *)a1 + 36) = (unsigned __int8)v48[5] + ((unsigned __int8)v48[4] << 8);
        goto LABEL_137;
      }
    }
    v14 = -2146893048;
    *a4 = 10;
LABEL_137:
    LocalFree(v48);
    *((_DWORD *)a3 + 1) = 0;
    *((_DWORD *)a2 + 1) = 0;
    v19 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
      || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
    {
      return v14;
    }
    v28 = 56;
    goto LABEL_56;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 58i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
    v10 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
  }
  if ( (*((_DWORD *)a1 + 6) & 0xF0000) != 0 )
    v21 = v10[10] | ((v10[9] | ((v10[8] | ((v10[7] | ((v10[6] | ((v10[5] | ((v10[4] | ((unsigned __int64)v10[3] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
  else
    v21 = *((_QWORD *)a1 + 12);
  LODWORD(v58) = 0;
  v56 = (unsigned __int8 *)v21;
  v55 = (struct SPBuffer *)((char *)a3 + 4);
  LODWORD(v53) = *(_DWORD *)a3;
  v52 = (unsigned __int64 *)*((_QWORD *)a3 + 1);
  v22 = SslDecryptPacket(*((_QWORD *)a1 + 11), *((_QWORD *)a1 + 5), v10);
  v23 = v22;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 59i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v22);
  if ( (*((_DWORD *)a1 + 6) & 0xF0000) != 0 )
    *((_QWORD *)a1 + 12) = v21;
  else
    ++*((_QWORD *)a1 + 12);
  if ( v23 )
  {
    *a4 = 20;
    v41 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
      return v14;
    v42 = 60;
LABEL_109:
    v46 = *((_QWORD *)v41 + 2);
    v47 = -2146893008;
LABEL_110:
    LODWORD(v52) = v14;
    WPP_SF_Dd(v46, v42, (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v47, v52, v53, v55, v56, v58);
    return v14;
  }
  v24 = TlsParseAlertMessage(*((unsigned __int8 **)a3 + 1), *((_DWORD *)a3 + 1), (unsigned __int8 *)a1 + 112, 0i64);
  *((_DWORD *)a3 + 1) = 0;
  v25 = v24;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v24 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    LODWORD(v52) = v24;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x3Du,
      (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids,
      v24,
      v52,
      (_DWORD)v53,
      v55,
      v21,
      0);
  }
  return v25;
}
// 180036B8D: variable 'v52' is possibly undefined
// 180036E06: variable 'v53' is possibly undefined
// 180036F74: variable 'v55' is possibly undefined
// 180036F74: variable 'v56' is possibly undefined
// 180036F74: variable 'v58' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800984E0: using guessed type __int64 __fastcall SslDecryptPacket(_QWORD, _QWORD, _QWORD);

//----- (000000018000CB70) ----------------------------------------------------
__int64 __fastcall TlsDecryptMessage(
        __int64 a1,
        __int64 a2,
        int a3,
        int a4,
        unsigned __int64 *a5,
        struct SPBuffer *a6,
        struct SPBuffer *a7,
        unsigned __int8 *a8)
{
  int v9; // r14d
  CCipherMill *v12; // rcx
  unsigned __int8 *v13; // r8
  unsigned int v14; // edi
  int v15; // edx
  int v16; // eax
  unsigned __int8 *v17; // r10
  int v18; // r9d
  unsigned int v19; // edx
  unsigned __int8 *v20; // rax
  unsigned int v21; // eax
  unsigned int v22; // ebx
  __int64 v24; // [rsp+20h] [rbp-68h]
  unsigned int Size; // [rsp+54h] [rbp-34h]
  unsigned __int8 *Size_4; // [rsp+58h] [rbp-30h]

  v9 = a3 + a4;
  v12 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 64i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
    v12 = WPP_GLOBAL_Control;
  }
  v13 = (unsigned __int8 *)*((_QWORD *)a6 + 1);
  *((_DWORD *)a6 + 1) = a4;
  v14 = v13[2] | (v13[1] << 8);
  if ( v14 - 768 > 3 && v14 != 65277 && v14 != 65279 )
  {
    v22 = -2146893048;
    *a8 = 70;
    goto LABEL_21;
  }
  if ( BYTE1(v14) == 0xFE && v14 <= 0xFEFF )
  {
    v15 = v13[11];
    v16 = v13[12];
  }
  else
  {
    v15 = v13[3];
    v16 = v13[4];
  }
  v17 = &v13[v9];
  Size_4 = v17;
  v18 = (v16 | (v15 << 8)) + a4;
  v19 = *(_DWORD *)a6 - v9;
  *((_DWORD *)a6 + 1) = v18;
  Size = v19;
  v20 = v13;
  if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)v12 + 2), 65i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
    v13 = (unsigned __int8 *)*((_QWORD *)a6 + 1);
    v20 = v13;
    HIDWORD(v17) = HIDWORD(Size_4);
  }
  if ( BYTE1(v14) != 0xFE || v14 > 0xFEFF )
    v13 = v20;
  HIDWORD(v24) = HIDWORD(v17);
  v21 = SslDecryptPacket(a1, a2, v13);
  v22 = v21;
  v12 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 66i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v21);
    v12 = WPP_GLOBAL_Control;
  }
  if ( v22 )
  {
    if ( v12 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v12 + 28) & 1) == 0 )
      goto LABEL_38;
    WPP_SF_D(*((_QWORD *)v12 + 2), 67i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v22);
    goto LABEL_37;
  }
  if ( BYTE1(v14) != 0xFE || v14 > 0xFEFF )
  {
    ++*a5;
    v12 = WPP_GLOBAL_Control;
  }
  if ( *((unsigned __int8 **)a7 + 1) == Size_4 )
    goto LABEL_20;
  if ( *(_DWORD *)a7 >= Size )
  {
    memcpy_0(*((void **)a7 + 1), Size_4, Size);
LABEL_20:
    *((_DWORD *)a7 + 1) = Size;
    v12 = WPP_GLOBAL_Control;
    goto LABEL_21;
  }
  if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 1) != 0 )
  {
    WPP_SF_(*((_QWORD *)v12 + 2), 68i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids);
LABEL_37:
    v12 = WPP_GLOBAL_Control;
  }
LABEL_38:
  v22 = -2146893008;
  *a8 = 20;
LABEL_21:
  if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)v12 + 28) & 4) != 0 )
    {
      WPP_SF_D(*((_QWORD *)v12 + 2), 69i64, &WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v22);
      v12 = WPP_GLOBAL_Control;
    }
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control
      && ((*((_BYTE *)v12 + 28) & 1) != 0 && v22 || (*((_BYTE *)v12 + 28) & 4) != 0) )
    {
      LODWORD(v24) = v22;
      WPP_SF_DD(*((_QWORD *)v12 + 2), 0x46u, (__int64)&WPP_bf20500307af3a1a22cf0d610b67b788_Traceguids, v22, v24);
    }
  }
  return v22;
}
// 18003743D: variable 'v24' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800984E0: using guessed type __int64 __fastcall SslDecryptPacket(_QWORD, _QWORD, _QWORD);

//----- (000000018000CD3C) ----------------------------------------------------
__int64 __fastcall SslSealMessageStream(struct CSslUserContext *a1, int a2, struct _SecBufferDesc *a3)
{
  struct _SecBuffer *v3; // rdi
  struct _SecBuffer *v4; // rsi
  struct _SecBuffer *v5; // r15
  CCipherMill *v9; // r10
  unsigned int cBuffers; // r11d
  unsigned int v11; // edx
  PSecBuffer pBuffers; // r8
  unsigned int *p_BufferType; // r9
  unsigned __int8 *pvBuffer; // rbx
  __int64 cbBuffer; // rdx
  __int64 v16; // r8
  BOOL v17; // r9d
  unsigned int v18; // r12d
  unsigned int v19; // ecx
  unsigned int v20; // edx
  int v21; // r8d
  bool v22; // zf
  __int64 v23; // rdx
  unsigned __int8 *v24; // r13
  unsigned int v25; // ebx
  unsigned int KeyUpdateRecord; // ebx
  unsigned int v27; // ecx
  unsigned __int64 v28; // rdx
  unsigned int v29; // ecx
  unsigned int v30; // eax
  unsigned int v31; // ecx
  unsigned int v32; // eax
  unsigned int v33; // ecx
  CCipherMill *v34; // rcx
  unsigned __int16 v36; // dx
  unsigned int v37; // edx
  char *v38; // rax
  char *v39; // rcx
  __int64 v40; // rax
  size_t v41; // r8
  void *v42; // rdx
  __int64 v43; // rdx
  _BYTE *v44; // r13
  unsigned int v45; // ebx
  CCipherMill *v46; // rcx
  __int64 v47; // rbx
  unsigned int v48; // eax
  __int64 v49; // rdx
  __int64 v50; // r9
  __int64 v51; // rcx
  unsigned __int8 v52; // cl
  __int64 v53; // rax
  char v54; // r8
  unsigned int v55; // edx
  const wchar_t *v56; // r9
  char *v57; // r14
  __int64 v58; // [rsp+20h] [rbp-49h]
  BOOL v59; // [rsp+50h] [rbp-19h]
  __int64 v60; // [rsp+58h] [rbp-11h] BYREF
  unsigned __int8 *v61; // [rsp+60h] [rbp-9h]
  void *Src; // [rsp+68h] [rbp-1h]
  unsigned int v63; // [rsp+70h] [rbp+7h]
  unsigned int v64; // [rsp+74h] [rbp+Bh] BYREF
  char *v65; // [rsp+78h] [rbp+Fh]
  __int128 v66[4]; // [rsp+80h] [rbp+17h] BYREF
  unsigned int v67; // [rsp+E0h] [rbp+77h]
  int v68; // [rsp+E8h] [rbp+7Fh]

  v3 = 0i64;
  v4 = 0i64;
  Src = 0i64;
  v5 = 0i64;
  v63 = 0;
  v68 = 23;
  LODWORD(v60) = 23;
  v66[0] = 0i64;
  v9 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
    v9 = WPP_GLOBAL_Control;
  }
  cBuffers = a3->cBuffers;
  v11 = 0;
  if ( !cBuffers )
    goto LABEL_181;
  pBuffers = a3->pBuffers;
  p_BufferType = &pBuffers->BufferType;
  do
  {
    switch ( *p_BufferType )
    {
      case 1u:
        v5 = &pBuffers[v11];
        if ( !v3 )
          v3 = &pBuffers[v11];
        break;
      case 2u:
        if ( !v3 )
          goto LABEL_9;
        if ( !v4 )
LABEL_76:
          v4 = &pBuffers[v11];
        break;
      case 6u:
        goto LABEL_76;
      case 7u:
LABEL_9:
        v3 = &pBuffers[v11];
        break;
    }
    ++v11;
    p_BufferType += 4;
  }
  while ( v11 < cBuffers );
  if ( !v3 || !v5 )
  {
LABEL_181:
    if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 5) != 0 )
      WPP_SF_DD(
        *((_QWORD *)v9 + 2),
        0xEu,
        (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
        -2146893048,
        -2146893048);
    return 2148074248i64;
  }
  pvBuffer = (unsigned __int8 *)v5->pvBuffer;
  cbBuffer = v3->cbBuffer;
  v16 = (__int64)v3->pvBuffer;
  v61 = pvBuffer;
  v17 = pvBuffer != (unsigned __int8 *)(v16 + cbBuffer);
  v59 = v17;
  if ( v4 )
  {
    if ( v4->pvBuffer != &pvBuffer[v5->cbBuffer] )
      v17 = 1;
    v59 = v17;
  }
  v18 = v5->cbBuffer;
  v19 = v5->cbBuffer + cbBuffer;
  if ( v19 < (unsigned int)cbBuffer )
  {
    if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 5) != 0 )
    {
      v36 = 18;
      goto LABEL_91;
    }
    return 2148074333i64;
  }
  if ( !v17 )
  {
    v64 = 0;
    v65 = (char *)v16;
    v20 = v3->cbBuffer + v5->cbBuffer;
    v67 = v18;
    v63 = v20;
    if ( !v4 )
      goto LABEL_22;
    if ( v20 + v4->cbBuffer >= v20 )
    {
      v63 = v20 + v4->cbBuffer;
      v67 = v18 + v4->cbBuffer;
      goto LABEL_22;
    }
    if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 5) != 0 )
    {
      v36 = 19;
      goto LABEL_91;
    }
    return 2148074333i64;
  }
  v63 = v5->cbBuffer + cbBuffer;
  if ( !v4 )
  {
LABEL_94:
    v38 = (char *)LocalAlloc(0x40u, v19);
    Src = v38;
    v39 = v38;
    if ( !v38 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
        WPP_SF_DD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x15u,
          (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
          -2146893056,
          -2146893056);
      return 2148074240i64;
    }
    v64 = 0;
    v65 = v38;
    v40 = v3->cbBuffer;
    v41 = v5->cbBuffer;
    v42 = v5->pvBuffer;
    v18 = v5->cbBuffer;
    pvBuffer = (unsigned __int8 *)&v39[v40];
    v61 = (unsigned __int8 *)&v39[v40];
    v67 = v63 - v40;
    memcpy_0(&v39[v40], v42, v41);
    v9 = WPP_GLOBAL_Control;
LABEL_22:
    if ( a2 == 0x40000000 )
    {
      KeyUpdateRecord = HandleSpecialMessage(a1, pvBuffer, v18, (enum eTlsRecordType *)&v60);
      if ( KeyUpdateRecord )
      {
        v34 = WPP_GLOBAL_Control;
LABEL_167:
        if ( !v59 )
        {
LABEL_68:
          if ( v34 != (CCipherMill *)&WPP_GLOBAL_Control
            && ((*((_BYTE *)v34 + 28) & 1) != 0 && KeyUpdateRecord || (*((_BYTE *)v34 + 28) & 4) != 0) )
          {
            LODWORD(v58) = KeyUpdateRecord;
            WPP_SF_DD(
              *((_QWORD *)v34 + 2),
              0x31u,
              (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
              KeyUpdateRecord,
              v58);
          }
          return KeyUpdateRecord;
        }
        v57 = (char *)Src;
        goto LABEL_178;
      }
      v21 = v60;
      v9 = WPP_GLOBAL_Control;
      v68 = v60;
    }
    else
    {
      v21 = 23;
    }
    v22 = (*((_DWORD *)a1 + 6) & 0xF0000) == 0;
    v23 = *((_QWORD *)a1 + 13);
    v60 = v23;
    if ( !v22 )
      v60 = ((__int64)*((int *)a1 + 29) << 48) | v23;
    if ( (*((_BYTE *)a1 + 24) & 0x30) == 0 && (*((_BYTE *)a1 + 24) & 0xC0) == 0 )
      goto LABEL_28;
    v43 = *((unsigned int *)a1 + 17);
    if ( v3->cbBuffer <= (unsigned int)(v43 + *((_DWORD *)a1 + 16)) )
    {
      if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)v9 + 2), 31i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
        v9 = WPP_GLOBAL_Control;
LABEL_28:
        v24 = v61;
        v25 = v67;
        goto LABEL_29;
      }
      v25 = v67;
      v24 = v61;
    }
    else if ( v21 == 23 && v18 > 1 )
    {
      v44 = (char *)v3->pvBuffer + (unsigned int)v43;
      v45 = v3->cbBuffer - v43;
      *((_QWORD *)&v66[0] + 1) = v65;
      *(_QWORD *)&v66[0] = v63;
      *v44 = *(_BYTE *)v5->pvBuffer;
      v46 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
          v46 = WPP_GLOBAL_Control;
        }
        if ( v46 != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)v46 + 28) & 4) != 0 )
          {
            WPP_SF_D(*((_QWORD *)v46 + 2), 23i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, 1i64);
            v46 = WPP_GLOBAL_Control;
          }
          if ( v46 != (CCipherMill *)&WPP_GLOBAL_Control )
          {
            if ( (*((_BYTE *)v46 + 28) & 4) != 0 )
            {
              WPP_SF_D(*((_QWORD *)v46 + 2), 24i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v45);
              v46 = WPP_GLOBAL_Control;
            }
            if ( v46 != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_BYTE *)v46 + 28) & 4) != 0 )
              {
                WPP_SF_q(*((_QWORD *)v46 + 2), 0x19u, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v44);
                v46 = WPP_GLOBAL_Control;
              }
              if ( v46 != (CCipherMill *)&WPP_GLOBAL_Control )
              {
                if ( (*((_BYTE *)v46 + 28) & 4) != 0 )
                {
                  WPP_SF_D(
                    *((_QWORD *)v46 + 2),
                    26i64,
                    &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
                    DWORD1(v66[0]));
                  v46 = WPP_GLOBAL_Control;
                }
                if ( v46 != (CCipherMill *)&WPP_GLOBAL_Control )
                {
                  if ( (*((_BYTE *)v46 + 28) & 4) != 0 )
                  {
                    WPP_SF_D(
                      *((_QWORD *)v46 + 2),
                      27i64,
                      &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
                      LODWORD(v66[0]));
                    v46 = WPP_GLOBAL_Control;
                  }
                  if ( v46 != (CCipherMill *)&WPP_GLOBAL_Control )
                  {
                    if ( (*((_BYTE *)v46 + 28) & 4) != 0 )
                    {
                      WPP_SF_q(
                        *((_QWORD *)v46 + 2),
                        0x1Cu,
                        (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
                        *((_QWORD *)&v66[0] + 1));
                      v46 = WPP_GLOBAL_Control;
                    }
                    if ( v46 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v46 + 28) & 4) != 0 )
                      WPP_SF_D(
                        *((_QWORD *)v46 + 2),
                        29i64,
                        &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
                        *((unsigned int *)a1 + 26));
                  }
                }
              }
            }
          }
        }
      }
      v47 = v60;
      v48 = SslEncryptPacket(
              *((_QWORD *)a1 + 11),
              *((_QWORD *)a1 + 6),
              v44,
              1i64,
              *((_QWORD *)&v66[0] + 1),
              v66[0],
              (char *)v66 + 4,
              v60,
              23,
              0);
      if ( v48 )
      {
        v34 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          goto LABEL_166;
        v49 = 30i64;
        v50 = v48;
        goto LABEL_164;
      }
      v51 = DWORD1(v66[0]);
      ++*((_QWORD *)a1 + 13);
      v65 += v51;
      v24 = v61 + 1;
      v9 = WPP_GLOBAL_Control;
      --v18;
      v60 = v47 + 1;
      v25 = v67 - 1;
      v63 -= v51;
    }
    else
    {
      v24 = (unsigned __int8 *)v3->pvBuffer + v43;
      v25 = v63 - v43;
      if ( v18 )
      {
        memmove_0(v24, v5->pvBuffer, v18);
        v9 = WPP_GLOBAL_Control;
      }
    }
LABEL_29:
    if ( (*((_DWORD *)a1 + 6) & 0x3000) != 0 )
    {
      v52 = v68;
      v53 = v18++;
      v68 = 23;
      v24[v53] = v52;
      v9 = WPP_GLOBAL_Control;
    }
    if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)v9 + 2), 32i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
        v9 = WPP_GLOBAL_Control;
      }
      if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
        {
          WPP_SF_D(*((_QWORD *)v9 + 2), 33i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v18);
          v9 = WPP_GLOBAL_Control;
        }
        if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
          {
            WPP_SF_D(*((_QWORD *)v9 + 2), 34i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v25);
            v9 = WPP_GLOBAL_Control;
          }
          if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
          {
            if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
            {
              WPP_SF_q(*((_QWORD *)v9 + 2), 0x23u, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v24);
              v9 = WPP_GLOBAL_Control;
            }
            if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
              {
                WPP_SF_D(*((_QWORD *)v9 + 2), 36i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v64);
                v9 = WPP_GLOBAL_Control;
              }
              if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
              {
                if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
                {
                  WPP_SF_D(*((_QWORD *)v9 + 2), 37i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v63);
                  v9 = WPP_GLOBAL_Control;
                }
                if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control )
                {
                  if ( (*((_BYTE *)v9 + 28) & 4) != 0 )
                  {
                    WPP_SF_q(*((_QWORD *)v9 + 2), 0x26u, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v65);
                    v9 = WPP_GLOBAL_Control;
                  }
                  if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 4) != 0 )
                    WPP_SF_D(
                      *((_QWORD *)v9 + 2),
                      39i64,
                      &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
                      *((unsigned int *)a1 + 26));
                }
              }
            }
          }
        }
      }
    }
    KeyUpdateRecord = SslEncryptPacket(*((_QWORD *)a1 + 11), *((_QWORD *)a1 + 6), v24, v18, v65, v63, &v64, v60, v68, 0);
    if ( !KeyUpdateRecord )
    {
      v27 = v64;
      if ( (*((_DWORD *)a1 + 6) & 0xF0000) != 0 && v64 > *((unsigned __int16 *)a1 + 68) )
      {
        v34 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          goto LABEL_166;
        v49 = 41i64;
        v50 = 0i64;
        goto LABEL_164;
      }
      v28 = *((_QWORD *)a1 + 13) + 1i64;
      v22 = (*((_DWORD *)a1 + 6) & 0x3000) == 0;
      *((_QWORD *)a1 + 13) = v28;
      if ( !v22 )
      {
        v54 = *((_BYTE *)a1 + 456);
        if ( v54 || v28 >= *((unsigned int *)a1 + 115) )
        {
          v55 = v63;
          if ( v63 < v27 )
          {
            v34 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
            {
              goto LABEL_166;
            }
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 42i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
LABEL_165:
            v34 = WPP_GLOBAL_Control;
LABEL_166:
            KeyUpdateRecord = -2146893015;
            goto LABEL_167;
          }
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            v56 = L"peer request";
            if ( !v54 )
              v56 = L"write counter";
            WPP_SF_S(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x2Bu,
              (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
              v56);
            v27 = v64;
            v55 = v63;
          }
          *(_QWORD *)&v66[0] = v55 - v27;
          *((_QWORD *)&v66[0] + 1) = &v65[v27];
          KeyUpdateRecord = CSslUserContext::GenerateKeyUpdateRecord(a1, (struct SPBuffer *)v66);
          if ( KeyUpdateRecord )
          {
            v34 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
            {
              goto LABEL_166;
            }
            v49 = 44i64;
            goto LABEL_163;
          }
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 45i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
          }
          v27 = v64;
          *((_BYTE *)a1 + 456) = 0;
        }
      }
      v29 = DWORD1(v66[0]) + v27;
      v30 = v29;
      if ( v29 >= v3->cbBuffer )
        v30 = v3->cbBuffer;
      v31 = v29 - v30;
      v3->cbBuffer = v30;
      if ( v4 )
      {
        v32 = v31;
        if ( v31 >= v5->cbBuffer )
          v32 = v5->cbBuffer;
        v5->cbBuffer = v32;
        v33 = v31 - v32;
        if ( v33 >= v4->cbBuffer )
          v33 = v4->cbBuffer;
        v4->cbBuffer = v33;
      }
      else
      {
        if ( v31 >= v5->cbBuffer )
          v31 = v5->cbBuffer;
        v5->cbBuffer = v31;
      }
      if ( !v59 )
        goto LABEL_67;
      v57 = (char *)Src;
      memcpy_0(v3->pvBuffer, Src, v3->cbBuffer);
      memcpy_0(v5->pvBuffer, &v57[v3->cbBuffer], v5->cbBuffer);
      if ( v4 )
        memcpy_0(v4->pvBuffer, &v57[v5->cbBuffer + v3->cbBuffer], v4->cbBuffer);
LABEL_178:
      LocalFree(v57);
LABEL_67:
      v34 = WPP_GLOBAL_Control;
      goto LABEL_68;
    }
    v34 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      goto LABEL_166;
    v49 = 40i64;
LABEL_163:
    v50 = KeyUpdateRecord;
LABEL_164:
    WPP_SF_D(*((_QWORD *)v34 + 2), v49, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v50);
    goto LABEL_165;
  }
  v37 = v19 + v4->cbBuffer;
  if ( v37 >= v19 )
  {
    v19 += v4->cbBuffer;
    v63 = v37;
    goto LABEL_94;
  }
  if ( v9 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v9 + 28) & 5) != 0 )
  {
    v36 = 20;
LABEL_91:
    WPP_SF_DD(
      *((_QWORD *)v9 + 2),
      v36,
      (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
      -2146892963,
      -2146892963);
  }
  return 2148074333i64;
}
// 180037C6F: variable 'v58' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180085398: using guessed type wchar_t aPeerRequest[13];
// 1800853B8: using guessed type wchar_t aWriteCounter[14];
// 180098508: using guessed type __int64 __fastcall SslEncryptPacket(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (000000018000D0A8) ----------------------------------------------------
__int64 __fastcall SpQueryStreamSizes(struct CSslUserContext *a1, struct _SecPkgContext_StreamSizes *a2)
{
  int v4; // ebp
  unsigned int v5; // eax
  unsigned int v6; // edi
  unsigned int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // r10d
  unsigned int v10; // r11d
  __int64 v11; // r8
  __int64 v12; // rdx
  unsigned int v13; // r9d
  unsigned int v14; // eax
  CCipherMill *v15; // rcx
  CCipherMill *v17; // rcx
  unsigned int v18; // eax
  unsigned int v19; // eax
  unsigned int v20; // eax
  unsigned int v21; // eax
  unsigned int v22; // eax
  unsigned int v23; // eax
  bool v24; // zf
  unsigned int *v25; // [rsp+20h] [rbp-48h]
  unsigned int *v26; // [rsp+28h] [rbp-40h]
  unsigned int *v27; // [rsp+30h] [rbp-38h]
  unsigned int v28; // [rsp+70h] [rbp+8h] BYREF
  unsigned int v29; // [rsp+80h] [rbp+18h] BYREF
  unsigned int v30; // [rsp+88h] [rbp+20h] BYREF

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 98i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
  v4 = *((_DWORD *)a1 + 6) & 0xF0000;
  v5 = QueryStreamSizes(
         *((_QWORD *)a1 + 11),
         *((_DWORD *)a1 + 14),
         *((_DWORD *)a1 + 6),
         *((_DWORD *)a1 + 15),
         &v30,
         &v28,
         &v29);
  v6 = v5;
  if ( !v5 )
  {
    a2->cbHeader = 0;
    v7 = *((_DWORD *)a1 + 6);
    v8 = 0;
    if ( v7 > 0x800 )
    {
      if ( v7 == 4096 || v7 == 0x2000 || v7 == 0x10000 || v7 == 0x20000 || v7 == 0x40000 )
        goto LABEL_7;
      v24 = v7 == 0x80000;
    }
    else
    {
      if ( v7 == 2048 )
        goto LABEL_7;
      v18 = v7 - 16;
      if ( !v18 || (v19 = v18 - 16) == 0 || (v20 = v19 - 32) == 0 || (v21 = v20 - 64) == 0 )
      {
        v8 = *((_DWORD *)a1 + 18);
        a2->cbHeader = v8;
        goto LABEL_7;
      }
      v22 = v21 - 128;
      if ( !v22 )
        goto LABEL_7;
      v23 = v22 - 256;
      if ( !v23 )
        goto LABEL_7;
      v24 = v23 == 512;
    }
    if ( !v24 )
    {
      a2->cbTrailer = 0;
      v12 = 0x4000i64;
      v11 = 0i64;
      a2->cbMaximumMessage = 0x4000;
      v13 = 0;
LABEL_11:
      v14 = v30;
      a2->cbBlockSize = v30;
      a2->cBuffers = 4;
      v15 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          LODWORD(v27) = 4;
          LODWORD(v26) = v12;
          LODWORD(v25) = v11;
          WPP_SF_DDDDD(*((_QWORD *)WPP_GLOBAL_Control + 2), v12, v11, v13, v25, v26, v27, v14);
          v15 = WPP_GLOBAL_Control;
        }
        if ( v15 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v15 + 28) & 4) != 0 )
        {
          LODWORD(v25) = 0;
          WPP_SF_DD(*((_QWORD *)v15 + 2), 0x66u, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, 0, v25);
        }
      }
      return 0i64;
    }
LABEL_7:
    v9 = v28;
    v10 = v29;
    v11 = v28 + v29;
    a2->cbTrailer = v11;
    if ( v4 )
      v12 = *((unsigned __int16 *)a1 + 68);
    else
      v12 = 0x4000i64;
    a2->cbMaximumMessage = v12;
    v13 = v8 + *((_DWORD *)a1 + 16) + *((_DWORD *)a1 + 17);
    a2->cbHeader = v13;
    if ( (*((_DWORD *)a1 + 6) & 0x3000) != 0 )
    {
      v11 = v9 + (_DWORD)v11 + v13 + v10 + 7;
      a2->cbTrailer = v11;
    }
    goto LABEL_11;
  }
  v17 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 99i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v5);
      v17 = WPP_GLOBAL_Control;
    }
    if ( v17 != (CCipherMill *)&WPP_GLOBAL_Control
      && ((*((_BYTE *)v17 + 28) & 1) != 0 || (*((_BYTE *)v17 + 28) & 4) != 0) )
    {
      LODWORD(v25) = v6;
      WPP_SF_DD(*((_QWORD *)v17 + 2), 0x64u, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v6, v25);
    }
  }
  return v6;
}
// 180037DF4: variable 'v25' is possibly undefined
// 180037DF4: variable 'v26' is possibly undefined
// 180037DF4: variable 'v27' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000D1CC) ----------------------------------------------------
__int64 __fastcall QueryStreamSizes(
        __int64 a1,
        unsigned int a2,
        int a3,
        unsigned int a4,
        unsigned int *a5,
        unsigned int *a6,
        unsigned int *a7)
{
  __int64 v11; // r13
  __int64 result; // rax
  unsigned int v13; // ecx
  unsigned int v14; // eax
  __int128 v15; // [rsp+40h] [rbp-328h] BYREF
  int v16; // [rsp+50h] [rbp-318h]
  char v17[272]; // [rsp+60h] [rbp-308h] BYREF
  unsigned int v18; // [rsp+170h] [rbp-1F8h]
  unsigned int v19; // [rsp+1F4h] [rbp-174h]

  memset_0(v17, 0, 0x2A4ui64);
  v11 = (unsigned __int16)ConvertSchannelProtocolToSsl(a3);
  result = SslLookupCipherSuiteInfo(a1, v11, a2, a4, v17, 0);
  if ( !(_DWORD)result )
  {
    v13 = v18;
    if ( a5 )
      *a5 = v18;
    if ( a6 )
      *a6 = v19 >> 3;
    if ( a7 )
    {
      v14 = 0;
      if ( v13 > 1 )
        v14 = v13;
      *a7 = v14;
    }
    if ( (a3 & 0x3F00) != 0 )
    {
      v16 = 0;
      v15 = 0i64;
      if ( !(unsigned int)SslLookupCipherLengths(a1, (unsigned int)v11, a2, a4, &v15, 20, 0) )
      {
        if ( a6 )
          *a6 = DWORD2(v15);
        if ( a7 )
          *a7 = HIDWORD(v15);
      }
    }
    return 0i64;
  }
  return result;
}
// 1800984F0: using guessed type __int64 __fastcall SslLookupCipherLengths(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);
// 180098510: using guessed type __int64 __fastcall SslLookupCipherSuiteInfo(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);

//----- (000000018000D31C) ----------------------------------------------------
__int64 __fastcall ConvertSchannelProtocolToSsl(int a1)
{
  __int64 result; // rax

  if ( (a1 & 0x3FFC) != 0 && (a1 & 0xF0000) != 0 )
    return 0i64;
  if ( (a1 & 0xC0000) != 0 )
    return 65277i64;
  if ( (a1 & 0x30000) != 0 )
    return 65279i64;
  if ( (a1 & 0x3000) != 0 )
    return 772i64;
  if ( (a1 & 0xC00) != 0 )
    return 771i64;
  result = 768i64;
  if ( (a1 & 0x300) != 0 )
    return 770i64;
  if ( (a1 & 0xC0) != 0 )
    return 769i64;
  if ( (a1 & 0x30) == 0 )
  {
    if ( (a1 & 0xC) != 0 )
      return 2i64;
    return 0i64;
  }
  return result;
}

//----- (000000018000D37C) ----------------------------------------------------
void __fastcall CSslContext::SetCredentialGroup(CSslContext *this, struct CCredentialGroup *a2)
{
  struct CCredentialGroup *v4; // rdx
  int v5; // eax
  __int64 v6; // rcx

  v4 = (struct CCredentialGroup *)*((_QWORD *)this + 10);
  if ( v4 != a2 )
  {
    if ( v4 )
    {
      CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, v4);
      (*(void (__fastcall **)(CSslContext *, _QWORD))(*(_QWORD *)this + 256i64))(this, 0i64);
    }
    _InterlockedIncrement((volatile signed __int32 *)a2 + 6);
    *((_QWORD *)this + 10) = a2;
    v5 = *((_DWORD *)a2 + 39);
    if ( (v5 & 4) != 0 )
    {
      v6 = *((_QWORD *)this + 17);
      if ( (v6 & 0x100) == 0 )
      {
        *((_QWORD *)this + 17) = v6 | 0x4000;
        v5 = *((_DWORD *)a2 + 39);
      }
    }
    if ( (v5 & 0x4000) != 0 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_c955f13c15ab3d9e41a0e2d56db0bfe4_Traceguids);
      *((_QWORD *)this + 17) |= 0x200000000ui64;
    }
    if ( *((_DWORD *)this + 17) == 91 || *((_DWORD *)this + 17) == 101 )
    {
      if ( *((_BYTE *)this + 266) )
      {
        *((_BYTE *)this + 923) = 1;
        CSsl3TlsClientContext::SetDefCredSearched((__int64)this, 0);
      }
      else
      {
        CSsl3TlsClientContext::CheckForClientCred(this);
      }
    }
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000D410) ----------------------------------------------------
__int64 __fastcall ParseInputBufferDesc(
        struct _SecBufferDesc *a1,
        struct _SecBuffer **a2,
        struct SPBuffer *a3,
        struct _SecBuffer **a4,
        struct _SecBuffer **a5,
        struct _SecBuffer **a6,
        struct _SecBuffer **a7,
        struct _SecBuffer **a8,
        struct _SecBuffer **a9,
        struct _SecBuffer **a10,
        struct _SecBuffer **a11,
        struct _SecBuffer **a12,
        struct _SecBuffer **a13)
{
  unsigned int cBuffers; // r11d
  unsigned int cbBuffer; // r10d
  struct SPBuffer *v15; // rsi
  struct _SecBuffer *v16; // rbx
  struct _SecBuffer *v17; // rdi
  struct _SecBuffer *v18; // rbp
  struct _SecBuffer *v19; // r14
  struct _SecBuffer *v20; // r15
  struct _SecBuffer *v21; // r12
  struct _SecBuffer *v22; // r13
  unsigned int v23; // eax
  PSecBuffer pBuffers; // r9
  unsigned int *p_BufferType; // r8
  int v26; // ecx
  struct _SecBuffer *v28; // [rsp+20h] [rbp-68h]
  struct _SecBuffer *v29; // [rsp+28h] [rbp-60h]
  struct _SecBuffer *v30; // [rsp+30h] [rbp-58h]
  struct _SecBuffer *v31; // [rsp+38h] [rbp-50h]
  struct _SecBuffer *v32; // [rsp+90h] [rbp+8h]

  cBuffers = a1->cBuffers;
  cbBuffer = 0;
  v32 = 0i64;
  v15 = a3;
  v28 = 0i64;
  v16 = 0i64;
  v29 = 0i64;
  v17 = 0i64;
  v30 = 0i64;
  v18 = 0i64;
  v31 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0;
  if ( !cBuffers )
    goto LABEL_22;
  pBuffers = a1->pBuffers;
  p_BufferType = &pBuffers->BufferType;
  do
  {
    v26 = *p_BufferType & 0xFFFFFFF;
    if ( v26 )
    {
      if ( v26 == 2 )
        goto LABEL_12;
      if ( v26 == 18 )
      {
        v19 = &pBuffers[v23];
      }
      else
      {
        switch ( v26 )
        {
          case 3:
            v32 = &pBuffers[v23];
            break;
          case 5:
            v18 = &pBuffers[v23];
            break;
          case 19:
            v20 = &pBuffers[v23];
            break;
          case 20:
            v21 = &pBuffers[v23];
            break;
          case 21:
            v28 = &pBuffers[v23];
            break;
          case 22:
            v22 = &pBuffers[v23];
            break;
          case 23:
            v29 = &pBuffers[v23];
            break;
          case 24:
            v30 = &pBuffers[v23];
            break;
          case 27:
            v31 = &pBuffers[v23];
            break;
          default:
            break;
        }
      }
    }
    else
    {
      if ( !v16 && !v32 && (*p_BufferType & 0x40000000) == 0 )
      {
LABEL_12:
        v16 = &pBuffers[v23];
        goto LABEL_13;
      }
      if ( !v17 )
        v17 = &pBuffers[v23];
    }
LABEL_13:
    ++v23;
    p_BufferType += 4;
  }
  while ( v23 < cBuffers );
  v15 = a3;
  cbBuffer = 0;
  if ( v16 )
    goto LABEL_15;
  if ( v32 )
  {
    v16 = v32;
LABEL_15:
    *((_QWORD *)a3 + 1) = v16->pvBuffer;
    *(_DWORD *)a3 = v16->cbBuffer;
    cbBuffer = v16->cbBuffer;
  }
  else
  {
LABEL_22:
    *((_QWORD *)v15 + 1) = 0i64;
    *(_DWORD *)v15 = 0;
  }
  *((_DWORD *)v15 + 1) = cbBuffer;
  if ( !v17
    && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
  }
  *a2 = v16;
  *a4 = v17;
  *a5 = v18;
  *a6 = v19;
  *a7 = v20;
  *a8 = v21;
  *a9 = v28;
  *a10 = v22;
  *a11 = v29;
  *a12 = v30;
  *a13 = v31;
  return 0i64;
}
// 18000D5F0: conditional instruction was optimized away because rbx.8==0
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000D6A8) ----------------------------------------------------
__int64 __fastcall ParseOutputBufferDesc(
        struct _SecBufferDesc *a1,
        __int16 a2,
        struct _SecBuffer **a3,
        struct SPBuffer *a4,
        struct _SecBuffer **a5,
        struct SPBuffer *a6,
        struct _SecBuffer **a7,
        struct _SecBuffer **a8,
        struct _SecBuffer **a9)
{
  unsigned int cBuffers; // r15d
  unsigned int v11; // ebx
  struct _SecBuffer *v12; // r10
  struct _SecBuffer *v13; // rdi
  struct _SecBuffer *v14; // rsi
  struct _SecBuffer *v15; // r14
  struct _SecBuffer *v16; // r11
  unsigned int v17; // ebp
  PSecBuffer pBuffers; // rcx
  unsigned int *p_BufferType; // r8
  __int64 v20; // rdx
  void *v21; // rax
  __int64 result; // rax
  void *pvBuffer; // rax

  cBuffers = a1->cBuffers;
  v11 = 0;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0;
  if ( !cBuffers )
    goto LABEL_8;
  pBuffers = a1->pBuffers;
  p_BufferType = &pBuffers->BufferType;
  do
  {
    if ( (*p_BufferType & 0xFFFFFFF) != 0 )
    {
      switch ( *p_BufferType & 0xFFFFFFF )
      {
        case 2u:
          goto LABEL_5;
        case 0x11u:
          v13 = &pBuffers[v17];
          break;
        case 0x17u:
          v14 = &pBuffers[v17];
          break;
        case 0x1Au:
          v15 = &pBuffers[v17];
          break;
        case 0x1Bu:
          v16 = &pBuffers[v17];
          break;
      }
    }
    else if ( !v12 && (a2 & 0x100) != 0 )
    {
LABEL_5:
      v12 = &pBuffers[v17];
    }
    ++v17;
    p_BufferType += 4;
  }
  while ( v17 < cBuffers );
  if ( v14 )
  {
    if ( (a2 & 0x100) != 0 )
    {
      v14->pvBuffer = 0i64;
      v14->cbBuffer = 0;
    }
    else if ( !v14->pvBuffer )
    {
      v11 = 14;
    }
  }
LABEL_8:
  *a7 = v14;
  if ( v15 )
  {
    if ( (a2 & 0x100) != 0 )
    {
      v15->pvBuffer = 0i64;
      v15->cbBuffer = 0;
    }
    else if ( !v15->pvBuffer )
    {
      v11 = 14;
    }
  }
  *a8 = v15;
  if ( v16 )
  {
    if ( (a2 & 0x100) != 0 )
    {
      v16->pvBuffer = 0i64;
      v16->cbBuffer = 0;
    }
    else if ( v16->pvBuffer )
    {
      if ( v16->cbBuffer < 8 )
      {
        v16->cbBuffer = 8;
        v11 = -2146893023;
      }
    }
    else
    {
      v11 = 14;
    }
  }
  v20 = a2 & 0x100;
  *a9 = v16;
  if ( v13 )
  {
    if ( v20 )
    {
      v13->pvBuffer = 0i64;
      v13->cbBuffer = 0;
    }
    else
    {
      pvBuffer = v13->pvBuffer;
      if ( pvBuffer )
      {
LABEL_49:
        *((_QWORD *)a6 + 1) = pvBuffer;
        *(_QWORD *)a6 = v13->cbBuffer;
        goto LABEL_11;
      }
      v11 = 14;
    }
    pvBuffer = 0i64;
    goto LABEL_49;
  }
LABEL_11:
  *a5 = v13;
  if ( !v12 )
    return 2148074248i64;
  v12->BufferType = 2;
  if ( v20 )
  {
    v12->pvBuffer = 0i64;
    v21 = 0i64;
    v12->cbBuffer = 0;
    goto LABEL_14;
  }
  v21 = v12->pvBuffer;
  if ( !v21 )
    return 14i64;
LABEL_14:
  *((_QWORD *)a4 + 1) = v21;
  result = v11;
  *(_QWORD *)a4 = v12->cbBuffer;
  *a3 = v12;
  return result;
}

//----- (000000018000D7D0) ----------------------------------------------------
__int64 __fastcall AscIscPostProcessing(
        int a1,
        struct CSslContext *a2,
        struct CSslParentContext *a3,
        struct _SecBuffer *a4,
        struct _SecBuffer *a5,
        struct _SecBuffer *a6,
        struct SPBuffer *a7,
        struct _SecBuffer *a8,
        struct SPBuffer *a9,
        unsigned __int64 a10,
        unsigned __int8 *a11,
        union _LARGE_INTEGER *a12)
{
  int v12; // r8d
  unsigned int v13; // r13d
  unsigned int v15; // edi
  int v16; // esi
  int v17; // eax
  int v18; // edi
  __int64 v19; // rax
  int v20; // eax
  const WCHAR *v21; // rdi
  WCHAR *v22; // r14
  __int64 v23; // rsi
  __int64 v24; // r12
  const WCHAR *v25; // rsi
  __int64 v26; // r15
  const WCHAR *v27; // r15
  __int64 v28; // rax
  int v29; // r12d
  int v30; // ecx
  unsigned int v31; // r9d
  __int64 v33; // rbx
  __int64 v34; // rax
  struct _RTL_RESOURCE *v35; // rcx
  DWORD v36; // eax
  WCHAR *v37; // rax
  __int64 v38; // rcx
  CCipherMill *v39; // rcx
  unsigned int v40; // edi
  const WCHAR *v41; // rdx
  __int64 v42; // rdx
  __int64 csz; // [rsp+20h] [rbp-A1h]
  const WCHAR *SourceString; // [rsp+50h] [rbp-71h]
  struct _UNICODE_STRING v45; // [rsp+58h] [rbp-69h] BYREF
  struct _UNICODE_STRING v46; // [rsp+68h] [rbp-59h] BYREF
  struct _UNICODE_STRING v47; // [rsp+78h] [rbp-49h] BYREF
  struct _UNICODE_STRING v48; // [rsp+88h] [rbp-39h] BYREF
  char DestinationString[24]; // [rsp+98h] [rbp-29h] BYREF
  __int64 v50; // [rsp+B0h] [rbp-11h]
  DWORD v51; // [rsp+118h] [rbp+57h]
  DWORD v52; // [rsp+118h] [rbp+57h]

  v12 = 0;
  v13 = 590610;
  v15 = a1;
  if ( a1 == 590610 && a2 && *((_DWORD *)a2 + 17) == 77 )
  {
    v16 = 1;
  }
  else
  {
    v16 = 0;
    if ( a1 == -2146893032 )
    {
      if ( a5 && a6 )
      {
        a5->BufferType = 1073741828;
        v31 = *((_DWORD *)a7 + 1) - a6->cbBuffer;
        a5->cbBuffer = v31;
        a5->pvBuffer = 0i64;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_8;
        WPP_SF_d(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x10u,
          (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
          v31);
      }
      else
      {
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_8;
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 17i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
      }
      v12 = 0;
      goto LABEL_8;
    }
  }
  if ( (a10 & 0x100) != 0 || !v16 )
  {
    a8->pvBuffer = (void *)*((_QWORD *)a9 + 1);
    a8->cbBuffer = *((_DWORD *)a9 + 1);
  }
  if ( a1 != -2146893023 )
  {
    if ( !a1 )
      goto LABEL_8;
    if ( a1 < 0 )
    {
      if ( a1 != -2146892950 && a1 != -2146892949 )
        goto LABEL_64;
LABEL_8:
      if ( a8->cbBuffer && !v16 )
        goto LABEL_10;
      goto LABEL_64;
    }
    if ( (a1 & 0x1FFF0000) == 589824 )
      goto LABEL_8;
  }
LABEL_64:
  if ( (a10 & 0x100) != 0 && a8->pvBuffer )
  {
    if ( !a2 )
      return v15;
    (*(void (__fastcall **)(struct CSslContext *, void *))(*(_QWORD *)a2 + 16i64))(a2, a8->pvBuffer);
    v12 = 0;
    *(_QWORD *)&a8->cbBuffer = 0i64;
    a8->pvBuffer = 0i64;
    goto LABEL_11;
  }
LABEL_10:
  if ( !a2 )
    return v15;
LABEL_11:
  if ( !v16 )
  {
    if ( !v15 || v15 == 590614 || v15 == -2146892950 )
    {
      if ( a6 )
      {
        if ( *((_DWORD *)a7 + 1) < a6->cbBuffer )
        {
          if ( a5 )
          {
            a5->BufferType = 1073741829;
            a5->cbBuffer = a6->cbBuffer - *((_DWORD *)a7 + 1);
            a5->pvBuffer = 0i64;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 19i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
              v12 = 0;
            }
          }
        }
      }
      if ( !v15 )
      {
        v17 = *((_DWORD *)a2 + 17);
        if ( v17 != 4 && v17 != 51 && v17 != 79 || (*((_DWORD *)a2 + 34) & 0x40000000) != 0 )
          goto LABEL_44;
        *(_QWORD *)DestinationString = a2;
        *(_OWORD *)&DestinationString[8] = 0i64;
        v50 = 0i64;
        *a11 = 1;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
        v15 = CSslSerializeHelper::SerializeContextWorker(
                (CSslSerializeHelper *)DestinationString,
                (void (__fastcall *)(__int64, __int64 *))SslRelocateToken);
        if ( !v15 )
        {
          v18 = v50;
          v19 = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)DestinationString + 8i64))(
                  *(_QWORD *)DestinationString,
                  (unsigned int)v50);
          *(_QWORD *)&DestinationString[8] = v19;
          if ( v19 )
          {
            HIDWORD(v50) = v18;
            *(_QWORD *)&DestinationString[16] = v19;
            v15 = CSslSerializeHelper::SerializeContextWorker(
                    (CSslSerializeHelper *)DestinationString,
                    (void (__fastcall *)(__int64, __int64 *))SslRelocateToken);
            if ( !v15 )
            {
              a4->pvBuffer = *(void **)&DestinationString[8];
              a4->cbBuffer = v50;
              *((_QWORD *)a2 + 17) |= 0x40000000ui64;
              v20 = *((_DWORD *)a2 + 17);
              if ( v20 != 4 && v20 != 79 )
              {
                v38 = *((_QWORD *)a2 + 19);
                if ( v38 )
                {
                  SslFreeObject(v38, 0i64);
                  *((_QWORD *)a2 + 19) = 0i64;
                }
                v12 = 1;
LABEL_44:
                v30 = *((_DWORD *)a2 + 17);
                if ( (unsigned int)(v30 - 3) <= 1 || v30 == 79 )
                {
                  v13 = 0;
                  goto LABEL_58;
                }
                if ( v12 )
                {
                  v39 = WPP_GLOBAL_Control;
                  if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
                    || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
                  {
                    goto LABEL_82;
                  }
                  v42 = 21i64;
                }
                else
                {
                  if ( (*(unsigned __int8 (__fastcall **)(struct CSslContext *, CCipherMill **))(*(_QWORD *)a2 + 384i64))(
                         a2,
                         &WPP_GLOBAL_Control)
                    || (*((_DWORD *)a2 + 16) & 0x1000) == 0
                    || *((_DWORD *)a2 + 17) != 70 )
                  {
LABEL_58:
                    if ( a12 )
                    {
                      v33 = *((_QWORD *)a2 + 11);
                      if ( v33 )
                      {
                        RtlAcquireResourceShared((PRTL_RESOURCE)(v33 + 72), 1u);
                        v34 = *(_QWORD *)(v33 + 48);
                        v35 = (struct _RTL_RESOURCE *)(v33 + 72);
                        if ( v34 )
                        {
                          *a12 = *(union _LARGE_INTEGER *)(*(_QWORD *)(v34 + 24) + 72i64);
                          RtlReleaseResource(v35);
                          return v13;
                        }
                        RtlReleaseResource(v35);
                      }
                      a12->QuadPart = 0x7FFFFF36D5969FFFi64;
                    }
                    return v13;
                  }
                  v39 = WPP_GLOBAL_Control;
                  if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
                    || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
                  {
LABEL_82:
                    v13 = 590694;
                    goto LABEL_58;
                  }
                  v42 = 22i64;
                }
                WPP_SF_(*((_QWORD *)v39 + 2), v42, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
                goto LABEL_82;
              }
              (*(void (__fastcall **)(struct CSslContext *))(*(_QWORD *)a2 + 264i64))(a2);
              if ( *((_BYTE *)a2 + 265) )
              {
                *((_BYTE *)a2 + 265) = 0;
LABEL_43:
                v12 = 0;
                goto LABEL_44;
              }
              v21 = 0i64;
              v22 = 0i64;
              v23 = (*(__int64 (__fastcall **)(struct CSslContext *))(*(_QWORD *)a2 + 248i64))(a2);
              v24 = (*(__int64 (__fastcall **)(struct CSslContext *))(*(_QWORD *)a2 + 320i64))(a2);
              if ( v23 )
                v21 = *(const WCHAR **)(v23 + 400);
              RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)a2 + 11) + 72i64), 1u);
              v25 = &Class;
              v26 = *(_QWORD *)(*((_QWORD *)a2 + 11) + 48i64);
              if ( v26
                && (v36 = CertNameToStrW(
                            *(_DWORD *)v26,
                            (PCERT_NAME_BLOB)(*(_QWORD *)(v26 + 24) + 80i64),
                            0x20000003u,
                            0i64,
                            0),
                    (v52 = v36) != 0)
                && (v37 = (WCHAR *)SPExternalAlloc(2 * v36), (v22 = v37) != 0i64) )
              {
                CertNameToStrW(*(_DWORD *)v26, (PCERT_NAME_BLOB)(*(_QWORD *)(v26 + 24) + 80i64), 0x20000003u, v37, v52);
                RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)a2 + 11) + 72i64));
              }
              else
              {
                RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)a2 + 11) + 72i64));
                if ( !v22 )
                {
                  SourceString = &Class;
LABEL_33:
                  v27 = &Class;
                  if ( v21 )
                    v27 = v21;
                  if ( v24 )
                    v25 = (const WCHAR *)v24;
                  v51 = *(_DWORD *)(*((_QWORD *)a2 + 11) + 8i64);
                  if ( (*((_BYTE *)a2 + 32) & 8) != 0 && (v28 = *((_QWORD *)a2 + 1)) != 0 )
                    v29 = *(_DWORD *)(v28 + 28);
                  else
                    v29 = 0;
                  if ( (g_dwEventLogging & 4) != 0 )
                  {
                    v40 = *((_DWORD *)a2 + 16);
                    MapProtocolToString(v40, &v48);
                    v41 = (const WCHAR *)pszClientString;
                    if ( (v40 & 0x40051555) != 0 )
                      v41 = pszServerString;
                    RtlInitUnicodeString((PUNICODE_STRING)DestinationString, v41);
                    RtlInitUnicodeString(&v47, v25);
                    RtlInitUnicodeString(&v46, v27);
                    RtlInitUnicodeString(&v45, SourceString);
                    LODWORD(csz) = v29;
                    SchEventWrite(
                      &SSLEVENT_HANDSHAKE_INFO,
                      L"uuddpuuu",
                      (__int64)DestinationString,
                      &v48,
                      csz,
                      v51,
                      a3,
                      &v47,
                      &v46,
                      &v45);
                  }
                  if ( v22 )
                    SPExternalFree(v22);
                  goto LABEL_43;
                }
              }
              SourceString = v22;
              goto LABEL_33;
            }
            (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)DestinationString + 16i64))(
              *(_QWORD *)DestinationString,
              *(_QWORD *)&DestinationString[8]);
          }
          else
          {
            return 14;
          }
        }
      }
    }
    return v15;
  }
  return 0i64;
}
// 18000DD53: conditional instruction was optimized away because ecx.4 is in (<-7FF6FCE8|80090319..80090320|>=80090322u)
// 1800382AA: variable 'csz' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018000DDA0) ----------------------------------------------------
__int64 __fastcall CSslSerializeHelper::SerializeContextWorker(
        CSslSerializeHelper *this,
        void (__fastcall *a2)(__int64, __int64 *))
{
  __int64 result; // rax
  __int64 v5; // rax
  unsigned int v7; // edx
  unsigned int v8; // edi
  __int64 v9; // rdx
  __int64 v10; // rsi
  _DWORD *v11; // rdi
  int v12; // eax
  int v13; // edx
  __int64 v14; // rdx
  _DWORD *v15; // rdi
  int v16; // eax
  int v17; // edx
  __int64 v18; // rcx
  void *v19; // r9
  unsigned int v20; // edi
  void *v21; // r9
  unsigned int v22; // edi
  void *v23; // rdx
  size_t v24; // r8
  unsigned int v25; // edi
  void *v26; // r9
  unsigned int v27; // edi
  __int128 *v28; // rcx
  const void **v29; // rax
  const void **v30; // rdi
  const void **v31; // rax
  const void **v32; // rdi
  __int64 v33; // rax
  __int64 v34; // rax
  bool v35; // cf
  __int64 v36; // rax
  __int64 v37; // rsi
  _DWORD *v38; // rcx
  _DWORD *v39; // rcx
  size_t v40; // r8
  __int64 v41; // rax
  _DWORD *v42; // rcx
  size_t v43; // r8
  _DWORD *v44; // rcx
  size_t v45; // r8
  _DWORD *v46; // rcx
  _DWORD *v47; // rax
  _QWORD *v48; // rdx
  __int128 v49; // xmm0
  const void *v50; // r8
  __int64 v51; // [rsp+70h] [rbp-90h] BYREF
  size_t v52; // [rsp+78h] [rbp-88h] BYREF
  unsigned int v53; // [rsp+80h] [rbp-80h] BYREF
  size_t Size; // [rsp+84h] [rbp-7Ch] BYREF
  __int64 v55; // [rsp+90h] [rbp-70h] BYREF
  unsigned int v56; // [rsp+98h] [rbp-68h] BYREF
  unsigned int v57; // [rsp+9Ch] [rbp-64h] BYREF
  __int64 v58; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v59; // [rsp+A8h] [rbp-58h] BYREF
  const void *v60; // [rsp+B0h] [rbp-50h] BYREF
  const void *v61; // [rsp+B8h] [rbp-48h] BYREF
  const void *v62; // [rsp+C0h] [rbp-40h] BYREF
  void *v63; // [rsp+C8h] [rbp-38h] BYREF
  void *v64; // [rsp+D0h] [rbp-30h] BYREF
  __int64 v65; // [rsp+D8h] [rbp-28h] BYREF
  __int64 v66; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v67; // [rsp+E8h] [rbp-18h] BYREF
  void *v68; // [rsp+F0h] [rbp-10h] BYREF
  void *v69; // [rsp+F8h] [rbp-8h] BYREF
  _WORD Src[256]; // [rsp+100h] [rbp+0h] BYREF

  v52 = 0i64;
  v60 = 0i64;
  v61 = 0i64;
  v62 = 0i64;
  v53 = 0;
  v63 = 0i64;
  Size = 0i64;
  v64 = 0i64;
  if ( *((_QWORD *)this + 1) )
  {
    v35 = *((_DWORD *)this + 7) < 0xD8u;
    v51 = 0i64;
    if ( v35 )
      return 2148074244i64;
    v36 = *((_QWORD *)this + 2);
    *(_DWORD *)v36 = 1;
    v37 = v36 + 16;
    *(_QWORD *)(v36 + 4) = 200i64;
    result = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)this + 24i64))(*(_QWORD *)this, v36 + 16);
    if ( (_DWORD)result )
      return result;
    (*(void (__fastcall **)(_QWORD, __int64 *, __int64))(**(_QWORD **)this + 72i64))(*(_QWORD *)this, &v65, v37 + 72);
    if ( v65 )
    {
      if ( a2 )
        a2(v65, &v51);
      *(_QWORD *)(v37 + 64) = v51;
    }
    *((_QWORD *)this + 2) += 216i64;
    *((_DWORD *)this + 7) -= 216;
  }
  else
  {
    *((_DWORD *)this + 6) += 216;
  }
  result = (*(__int64 (__fastcall **)(_QWORD, _WORD *, __int64 *))(**(_QWORD **)this + 32i64))(
             *(_QWORD *)this,
             Src,
             &v55);
  if ( (_DWORD)result )
    return result;
  v5 = -1i64;
  while ( Src[++v5] != 0 )
    ;
  v7 = 2 * v5 + 2;
  v8 = (2 * v5 + 25) & 0xFFFFFFF8;
  if ( *((_QWORD *)this + 1) )
  {
    if ( *((_DWORD *)this + 7) < v8 )
      return 1359i64;
    v38 = (_DWORD *)*((_QWORD *)this + 2);
    v38[2] = v7;
    *v38 = 9;
    v38[1] = v8 - 16;
    memcpy_0((void *)(*((_QWORD *)this + 2) + 16i64), Src, v7);
    *((_QWORD *)this + 2) += v8;
    *((_DWORD *)this + 7) -= v8;
  }
  else
  {
    *((_DWORD *)this + 6) += v8;
  }
  (*(void (__fastcall **)(_QWORD, __int64 *, __int64 *))(**(_QWORD **)this + 40i64))(*(_QWORD *)this, &v66, &v67);
  v9 = v66;
  v10 = 2i64;
  if ( v66 )
  {
    v11 = (_DWORD *)*((_QWORD *)this + 2);
    v12 = *((_DWORD *)this + 7);
    if ( *((_QWORD *)this + 1) )
    {
      v12 -= 16;
      *((_QWORD *)this + 2) = v11 + 4;
      *((_DWORD *)this + 7) = v12;
    }
    LODWORD(v51) = v12;
    result = SslExportKey(v55, v9, L"OpaqueKeyBlob");
    if ( (_DWORD)result && (_DWORD)result != -2146893784 )
      return result;
    v13 = (v51 + 23) & 0xFFFFFFF8;
    if ( *((_QWORD *)this + 1) )
    {
      *v11 = 2;
      v11[1] = v13 - 16;
      v11[2] = v51;
      *((_QWORD *)this + 2) += (unsigned int)(v13 - 16);
      *((_DWORD *)this + 7) += 16 - v13;
    }
    else
    {
      *((_DWORD *)this + 6) += v13;
    }
  }
  v14 = v67;
  if ( !v67 )
    goto LABEL_20;
  v15 = (_DWORD *)*((_QWORD *)this + 2);
  v16 = *((_DWORD *)this + 7);
  if ( *((_QWORD *)this + 1) )
  {
    v16 -= 16;
    *((_QWORD *)this + 2) = v15 + 4;
    *((_DWORD *)this + 7) = v16;
  }
  LODWORD(v51) = v16;
  result = SslExportKey(v55, v14, L"OpaqueKeyBlob");
  if ( !(_DWORD)result || (_DWORD)result == -2146893784 )
  {
    v17 = (v51 + 23) & 0xFFFFFFF8;
    if ( *((_QWORD *)this + 1) )
    {
      *v15 = 3;
      v15[1] = v17 - 16;
      v15[2] = v51;
      *((_QWORD *)this + 2) += (unsigned int)(v17 - 16);
      *((_DWORD *)this + 7) += 16 - v17;
    }
    else
    {
      *((_DWORD *)this + 6) += v17;
    }
LABEL_20:
    v18 = *(_QWORD *)this;
    v58 = 0i64;
    v59 = 0i64;
    (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)v18 + 48i64))(v18, &v58, &v59);
    if ( v58 )
    {
      result = CSslSerializeHelper::SerializeEncryptionKey((__int64)this, 19, v55, v58);
      if ( (_DWORD)result )
        return result;
    }
    if ( v59 )
    {
      result = CSslSerializeHelper::SerializeEncryptionKey((__int64)this, 20, v55, v59);
      if ( (_DWORD)result )
        return result;
    }
    (*(void (__fastcall **)(_QWORD, const void **, unsigned int *, void **, size_t *, void **, char *, const void **, unsigned int *, const void **, unsigned int *, void **, size_t *))(**(_QWORD **)this + 56i64))(
      *(_QWORD *)this,
      &v60,
      &v56,
      &v68,
      &v52,
      &v69,
      (char *)&v52 + 4,
      &v61,
      &v57,
      &v62,
      &v53,
      &v63,
      &Size);
    if ( v60 )
    {
      result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 4, v60, v56);
      if ( (_DWORD)result )
        return result;
    }
    if ( (_DWORD)v52 )
    {
      v19 = v68;
      v20 = (v52 + 23) & 0xFFFFFFF8;
      if ( *((_QWORD *)this + 1) )
      {
        if ( *((_DWORD *)this + 7) < v20 )
          return 1359i64;
        v42 = (_DWORD *)*((_QWORD *)this + 2);
        v43 = (unsigned int)v52;
        v42[2] = v52;
        *v42 = 5;
        v42[1] = v20 - 16;
        memcpy_0((void *)(*((_QWORD *)this + 2) + 16i64), v19, v43);
        *((_QWORD *)this + 2) += v20;
        *((_DWORD *)this + 7) -= v20;
      }
      else
      {
        *((_DWORD *)this + 6) += v20;
      }
    }
    if ( HIDWORD(v52) )
    {
      v21 = v69;
      v22 = (HIDWORD(v52) + 23) & 0xFFFFFFF8;
      if ( *((_QWORD *)this + 1) )
      {
        if ( *((_DWORD *)this + 7) < v22 )
          return 1359i64;
        v44 = (_DWORD *)*((_QWORD *)this + 2);
        v45 = HIDWORD(v52);
        v44[2] = HIDWORD(v52);
        *v44 = 6;
        v44[1] = v22 - 16;
        memcpy_0((void *)(*((_QWORD *)this + 2) + 16i64), v21, v45);
        *((_QWORD *)this + 2) += v22;
        *((_DWORD *)this + 7) -= v22;
      }
      else
      {
        *((_DWORD *)this + 6) += v22;
      }
    }
    if ( v61 )
    {
      result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 7, v61, v57);
      if ( (_DWORD)result )
        return result;
    }
    if ( v62 )
    {
      if ( v53 )
      {
        result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 8, v62, v53);
        if ( (_DWORD)result )
          return result;
      }
    }
    v23 = v63;
    if ( v63 )
    {
      v24 = (unsigned int)Size;
      v25 = (Size + 23) & 0xFFFFFFF8;
      if ( *((_QWORD *)this + 1) )
      {
        if ( *((_DWORD *)this + 7) < v25 )
          return 1359i64;
        v46 = (_DWORD *)*((_QWORD *)this + 2);
        *v46 = 10;
        v46[1] = v25 - 16;
        v46[2] = v24;
        memcpy_0((void *)(*((_QWORD *)this + 2) + 16i64), v23, v24);
        *((_QWORD *)this + 2) += v25;
        *((_DWORD *)this + 7) -= v25;
      }
      else
      {
        *((_DWORD *)this + 6) += v25;
      }
    }
    (*(void (__fastcall **)(_QWORD, void **, char *))(**(_QWORD **)this + 80i64))(
      *(_QWORD *)this,
      &v64,
      (char *)&Size + 4);
    if ( HIDWORD(Size) )
    {
      v26 = v64;
      v27 = (HIDWORD(Size) + 23) & 0xFFFFFFF8;
      if ( *((_QWORD *)this + 1) )
      {
        if ( *((_DWORD *)this + 7) < v27 )
          return 1359i64;
        v39 = (_DWORD *)*((_QWORD *)this + 2);
        v40 = HIDWORD(Size);
        v39[2] = HIDWORD(Size);
        *v39 = 11;
        v39[1] = v27 - 16;
        memcpy_0((void *)(*((_QWORD *)this + 2) + 16i64), v26, v40);
        *((_QWORD *)this + 2) += v27;
        *((_DWORD *)this + 7) -= v27;
      }
      else
      {
        *((_DWORD *)this + 6) += v27;
      }
    }
    v28 = (__int128 *)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)this + 88i64))(*(_QWORD *)this);
    if ( v28 )
    {
      if ( *((_QWORD *)this + 1) )
      {
        if ( *((_DWORD *)this + 7) < 0x118u )
          return 1359i64;
        v47 = (_DWORD *)*((_QWORD *)this + 2);
        *v47 = 12;
        v47[1] = 264;
        v47[2] = 264;
        v48 = (_QWORD *)(*((_QWORD *)this + 2) + 16i64);
        do
        {
          v48 += 16;
          v49 = *v28;
          v28 += 8;
          *((_OWORD *)v48 - 8) = v49;
          *((_OWORD *)v48 - 7) = *(v28 - 7);
          *((_OWORD *)v48 - 6) = *(v28 - 6);
          *((_OWORD *)v48 - 5) = *(v28 - 5);
          *((_OWORD *)v48 - 4) = *(v28 - 4);
          *((_OWORD *)v48 - 3) = *(v28 - 3);
          *((_OWORD *)v48 - 2) = *(v28 - 2);
          *((_OWORD *)v48 - 1) = *(v28 - 1);
          --v10;
        }
        while ( v10 );
        *v48 = *(_QWORD *)v28;
        *((_QWORD *)this + 2) += 280i64;
        *((_DWORD *)this + 7) -= 280;
      }
      else
      {
        *((_DWORD *)this + 6) += 280;
      }
    }
    v29 = (const void **)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)this + 96i64))(*(_QWORD *)this);
    v30 = v29;
    if ( v29 )
    {
      result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 13, v29, 0x10u);
      if ( (_DWORD)result )
        return result;
      if ( *((_BYTE *)v30 + 2) )
      {
        result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 14, v30[1], *((unsigned __int8 *)v30 + 2));
        if ( (_DWORD)result )
          return result;
      }
    }
    v31 = (const void **)(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)this + 104i64))(*(_QWORD *)this);
    v32 = v31;
    if ( v31 )
    {
      result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 15, v31, 0x10u);
      if ( (_DWORD)result )
        return result;
      if ( *((_WORD *)v32 + 1) )
      {
        result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 16, v32[1], *((unsigned __int16 *)v32 + 1));
        if ( (_DWORD)result )
          return result;
      }
    }
    v33 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)this + 112i64))(*(_QWORD *)this);
    if ( v33 )
    {
      v50 = *(const void **)(v33 + 8);
      if ( v50 )
      {
        result = CSslSerializeHelper::SerializeDataBlob((__int64)this, 17, v50, *(_DWORD *)v33);
        if ( (_DWORD)result )
          return result;
      }
    }
    v34 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)this + 120i64))(*(_QWORD *)this);
    if ( v34 )
    {
      result = CSslSerializeHelper::SerializeEncryptionKey((__int64)this, 18, v55, v34);
      if ( (_DWORD)result )
        return result;
    }
    if ( !*((_QWORD *)this + 1) )
    {
      *((_DWORD *)this + 6) += 16;
      return 0i64;
    }
    if ( *((_DWORD *)this + 7) >= 0x10u )
    {
      v41 = *((_QWORD *)this + 2);
      *(_QWORD *)v41 = 0i64;
      *(_DWORD *)(v41 + 8) = 0;
      *((_QWORD *)this + 2) += 16i64;
      *((_DWORD *)this + 7) -= 16;
      return 0i64;
    }
    return 1359i64;
  }
  return result;
}
// 180082320: using guessed type wchar_t aOpaquekeyblob[14];
// 180098528: using guessed type __int64 __fastcall SslExportKey(_QWORD, _QWORD, _QWORD);
// 18000DDA0: using guessed type _WORD Src[256];

//----- (000000018000E544) ----------------------------------------------------
__int64 __fastcall CSslSerializeHelper::SerializeDataBlob(__int64 a1, int a2, const void *a3, unsigned int a4)
{
  unsigned int v4; // edi
  _DWORD *v7; // rcx

  v4 = (a4 + 23) & 0xFFFFFFF8;
  if ( !*(_QWORD *)(a1 + 8) )
  {
    *(_DWORD *)(a1 + 24) += v4;
    return 0i64;
  }
  if ( *(_DWORD *)(a1 + 28) >= v4 )
  {
    v7 = *(_DWORD **)(a1 + 16);
    *v7 = a2;
    v7[1] = v4 - 16;
    v7[2] = a4;
    memcpy_0((void *)(*(_QWORD *)(a1 + 16) + 16i64), a3, a4);
    *(_QWORD *)(a1 + 16) += v4;
    *(_DWORD *)(a1 + 28) -= v4;
    return 0i64;
  }
  return 1359i64;
}

//----- (000000018000E5B4) ----------------------------------------------------
bool __fastcall IsFatalError(int a1)
{
  if ( !a1 )
    return 0;
  if ( a1 < 0 )
    return a1 != -2146893032 && a1 != -2146893023 && (unsigned int)(a1 + 2146892950) > 1;
  return (a1 & 0x1FFF0000) != 589824;
}

//----- (000000018000E5E4) ----------------------------------------------------
__int64 __fastcall GetSslProvHandle(const unsigned __int16 *a1, unsigned __int64 *a2)
{
  int v4; // ebp
  unsigned __int64 SslProvHandleInCache; // rdi
  unsigned int v6; // eax
  unsigned int v7; // ebx
  CCipherMill *v8; // rcx
  unsigned int CachedSslProv; // eax
  __int64 v11; // rdx
  __int64 v12; // r8
  __int64 v13; // [rsp+20h] [rbp-38h]
  __int64 v14[5]; // [rsp+30h] [rbp-28h] BYREF

  v4 = 0;
  RtlAcquireResourceShared(g_pSslProvCacheRWLock, 1u);
  SslProvHandleInCache = FindSslProvHandleInCache(a1);
  RtlReleaseResource(g_pSslProvCacheRWLock);
  if ( SslProvHandleInCache )
    goto LABEL_2;
  CachedSslProv = CreateCachedSslProv((struct CACHED_SSL_PROVIDER *)v14, a1);
  v7 = CachedSslProv;
  if ( !CachedSslProv )
  {
    v4 = 1;
    RtlAcquireResourceExclusive(g_pSslProvCacheRWLock, 1u);
    SslProvHandleInCache = FindSslProvHandleInCache(a1);
    if ( SslProvHandleInCache )
    {
      DestroyCachedSslProv((struct CACHED_SSL_PROVIDER *)v14);
      v4 = 0;
    }
    else
    {
      SslProvHandleInCache = v14[0];
      CacheClientSideSslProv((struct CACHED_SSL_PROVIDER *)v14);
    }
    RtlReleaseResource(g_pSslProvCacheRWLock);
LABEL_2:
    v6 = SslIncrementProviderReferenceCount(SslProvHandleInCache);
    v7 = v6;
    if ( v6 )
    {
      v8 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_qD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x18u,
          &WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids,
          SslProvHandleInCache,
          v6);
        v8 = WPP_GLOBAL_Control;
      }
      if ( !v4 )
        goto LABEL_5;
      DestroyCachedSslProv((struct CACHED_SSL_PROVIDER *)v14);
    }
    else
    {
      *a2 = SslProvHandleInCache;
    }
    goto LABEL_4;
  }
  v8 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control )
    return v7;
  if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    WPP_SF_qSD(*((_QWORD *)WPP_GLOBAL_Control + 2), v11, v12, v14, a1, CachedSslProv);
LABEL_4:
    v8 = WPP_GLOBAL_Control;
  }
LABEL_5:
  if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)v8 + 28) & 1) != 0 && v7 || (*((_BYTE *)v8 + 28) & 4) != 0) )
  {
    LODWORD(v13) = v7;
    WPP_SF_DD(*((_QWORD *)v8 + 2), 0x19u, (__int64)&WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids, v7, v13);
  }
  return v7;
}
// 1800384E4: variable 'v11' is possibly undefined
// 1800384E4: variable 'v12' is possibly undefined
// 18003855B: variable 'v13' is possibly undefined
// 1800984E8: using guessed type __int64 __fastcall SslIncrementProviderReferenceCount(_QWORD);

//----- (000000018000E714) ----------------------------------------------------
unsigned __int64 __fastcall FindSslProvHandleInCache(const unsigned __int16 *a1)
{
  __int64 v1; // rax
  _QWORD *i; // r8
  const unsigned __int16 *v4; // rdx
  int v5; // r11d
  int v6; // ecx

  v1 = 0i64;
  if ( !g_cCachedPagedSslProvs )
    return 0i64;
  for ( i = &unk_180092AA8; ; i += 2 )
  {
    v4 = a1;
    do
    {
      v5 = *(const unsigned __int16 *)((char *)v4 + *i - (_QWORD)a1);
      v6 = *v4 - v5;
      if ( v6 )
        break;
      ++v4;
    }
    while ( v5 );
    if ( !v6 )
      break;
    v1 = (unsigned int)(v1 + 1);
    if ( (unsigned int)v1 >= g_cCachedPagedSslProvs )
      return 0i64;
  }
  return *((_QWORD *)&g_rgCachedPagedSslProvs + 2 * v1);
}
// 180092A90: using guessed type unsigned int g_cCachedPagedSslProvs;

//----- (000000018000E778) ----------------------------------------------------
struct CSslUserContext *__fastcall CreateUserContext(size_t Size)
{
  unsigned int v1; // edi
  _DWORD *v2; // rax
  _DWORD *v3; // rbx

  if ( (unsigned int)Size < 0x1D0 )
    return 0i64;
  v1 = Size;
  v2 = LocalAlloc(0x40u, (unsigned int)Size);
  v3 = v2;
  if ( !v2 )
    return 0i64;
  memset_0(v2, 0, v1);
  v3[95] = 0;
  *((_QWORD *)v3 + 49) = 0i64;
  *((_QWORD *)v3 + 50) = 0i64;
  *((_QWORD *)v3 + 51) = 0i64;
  *((_QWORD *)v3 + 54) = 0i64;
  *((_QWORD *)v3 + 55) = 0i64;
  *(_QWORD *)v3 = &CSslUserContext::`vftable';
  *((_QWORD *)v3 + 56) = 0i64;
  v3[36] = -1;
  *((_BYTE *)v3 + 32) = 0;
  *((_BYTE *)v3 + 112) = 0;
  *((_BYTE *)v3 + 140) = 0;
  *((_BYTE *)v3 + 456) = 0;
  v3[115] = 23726566;
  *((_OWORD *)v3 + 26) = 0i64;
  v3[96] = -1;
  return (struct CSslUserContext *)v3;
}
// 18007D058: using guessed type void *CSslUserContext::`vftable';

//----- (000000018000E850) ----------------------------------------------------
__int64 __fastcall SchannelInit(int a1)
{
  unsigned int v2; // ebx
  __int64 v4; // r8
  CCipherMill *v5; // rcx
  CSessionCacheManager *CacheManager; // rax
  CSslCredManager *v7; // rax
  unsigned int LastError; // edi
  unsigned __int16 *v9; // rcx

  v2 = 1;
  if ( !CSslGlobals::m_bSchannelInitialized )
  {
    RtlEnterCriticalSection(&CSslGlobals::m_InitCriticalSection);
    if ( CSslGlobals::m_bSchannelInitialized )
    {
LABEL_7:
      RtlLeaveCriticalSection(&CSslGlobals::m_InitCriticalSection);
      return v2;
    }
    DisableThreadLibraryCalls(CSslGlobals::m_hInstance);
    SafeAllocaInitialize();
    if ( !a1 )
    {
      if ( BCryptOpenAlgorithmProvider(&g_hSHAProvider, L"SHA1", 0i64, 0)
        || BCryptOpenAlgorithmProvider(&g_hMD5Provider, L"MD5", 0i64, 0)
        || BCryptOpenAlgorithmProvider(&g_hDSAProvider, L"DSA", 0i64, 0)
        || BCryptOpenAlgorithmProvider(&g_hRSAProvider, L"RSA", 0i64, 0)
        || (unsigned int)CCipherMill::BuildCipherMill(v5) )
      {
        goto LABEL_33;
      }
      if ( !CryptAcquireContextW(&g_hDhSchannelProv, 0i64, 0i64, 0x12u, 0xF0000000) )
      {
        g_hDhSchannelProv = 0i64;
        LastError = GetLastError();
        v9 = (unsigned __int16 *)WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            10i64,
            &WPP_60bc9b1becfd3dd8c20089fcdaea9e65_Traceguids,
            LastError);
        LogGlobalAcquireContextFailedEvent(v9, LastError);
      }
      if ( !(unsigned int)LoadSslRegistryOptions() )
        goto LABEL_33;
      SchInitializeEvents();
      CacheManager = CSessionCacheManager::CreateCacheManager();
      if ( !CacheManager
        || (unsigned int)CSessionCacheManager::InitializeSessionCache(CacheManager)
        || (unsigned int)InitializeIssuerCache() )
      {
        goto LABEL_33;
      }
      v7 = CSslCredManager::m_pCredManager;
      if ( !CSslCredManager::m_pCredManager )
      {
        v7 = (CSslCredManager *)SPExternalAlloc(0x60u);
        if ( v7 )
          *(_QWORD *)v7 = &CSslCredManager::`vftable';
        CSslCredManager::m_pCredManager = v7;
        if ( !v7 )
          goto LABEL_33;
      }
      if ( !CSslCredManager::InitCredentialManager(v7) )
        goto LABEL_33;
      SslInitSystemMapper();
      if ( (unsigned int)InitializeSslMemoryOptions()
        || (unsigned int)CSslGlobals::InitializePeriodicCleanupHandler()
        || (unsigned int)CSslGlobals::InitializeCryptLocatorEvents() )
      {
        goto LABEL_33;
      }
      I_CertWnfEnableFlushCache();
    }
    if ( !(unsigned int)InitializeClientSideSslProvCache() )
    {
      LoadSecurityDll();
      CSslGlobals::m_bSchannelInitialized = 1;
      if ( a1 )
        goto LABEL_7;
      if ( (g_dwEventLogging & 4) != 0 )
        SchEventWrite(&SSLEVENT_SCHANNEL_STARTED, 0i64, v4);
      if ( !(unsigned int)TlgRegisterAggregateProviderEx() )
      {
        CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized = 1;
        QueryPerformanceFrequency(&CSchannelTelemetryContext::m_liPerfCtrFreq);
      }
LABEL_31:
      if ( !CSslGlobals::m_bSchannelInitialized )
        SchannelShutdown();
      goto LABEL_7;
    }
LABEL_33:
    v2 = 0;
    goto LABEL_31;
  }
  return v2;
}
// 18000E98F: variable 'v5' is possibly undefined
// 1800385D6: variable 'v4' is possibly undefined
// 1800385C2: variable 'v9' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 18007D478: using guessed type void *CSslCredManager::`vftable';
// 1800921D8: using guessed type int CSslGlobals::m_bSchannelInitialized;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 180098170: using guessed type __int64 I_CertWnfEnableFlushCache(void);

//----- (000000018000EABC) ----------------------------------------------------
void __fastcall CCipherMill::GetSignatureSuiteList(CCipherMill *this, struct CTlsSignatureSuiteList *a2)
{
  RtlAcquireResourceShared(&Resource, 1u);
  CTlsSignatureSuiteList::SetSignatureSuiteList(a2, (const struct CTlsSignatureSuiteList *)&word_1800925E8);
  RtlReleaseResource(&Resource);
}
// 1800925E8: using guessed type __int16 word_1800925E8;

//----- (000000018000EB08) ----------------------------------------------------
void __fastcall CTlsSignatureSuiteList::SetSignatureSuiteList(
        CTlsSignatureSuiteList *this,
        const struct CTlsSignatureSuiteList *a2)
{
  __int64 v2; // r8

  *(_WORD *)this = 0;
  *((_WORD *)this + 17) = 0;
  v2 = *(unsigned __int16 *)a2;
  if ( (unsigned int)v2 <= 0x10 )
  {
    *(_WORD *)this = v2;
    *((_WORD *)this + 17) = *((_WORD *)a2 + 17);
    memcpy_0((char *)this + 2, (char *)a2 + 2, 2 * v2);
  }
}

//----- (000000018000EB48) ----------------------------------------------------
ULONG __fastcall CSsl3TlsContext::TlsGenerateRandom(CSsl3TlsContext *this)
{
  unsigned __int64 v2; // rdx
  __time32_t Time; // [rsp+30h] [rbp+8h] BYREF

  time32_0(&Time);
  v2 = (-(__int64)((*((_DWORD *)this + 16) & 0xA2AA0) != 0) & 0xFFFFFFFFFFFFFFE0ui64) + 304;
  *(_DWORD *)((char *)this + v2) = _byteswap_ulong(Time);
  return GenerateRandomBits((PUCHAR)this + v2 + 4, 0x1Cu);
}

//----- (000000018000EB9C) ----------------------------------------------------
ULONG __fastcall GenerateRandomBits(PUCHAR pbBuffer, ULONG cbBuffer)
{
  int v2; // ecx
  ULONG result; // eax

  v2 = BCryptGenRandom(0i64, pbBuffer, cbBuffer, 2u);
  result = 0;
  if ( v2 < 0 )
    return RtlNtStatusToDosError(v2);
  return result;
}

//----- (000000018000EBEC) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::LogHandshakeStart(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5)
{
  bool v8; // zf

  if ( a1 )
  {
    if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    {
      *(_DWORD *)(a1 + 12) = a2;
      QueryPerformanceCounter((LARGE_INTEGER *)(a1 + 80));
      *(_DWORD *)(a1 + 24) = 0;
      v8 = *(_DWORD *)(a1 + 12) == 1;
      *(_QWORD *)(a1 + 120) = a3;
      *(_QWORD *)(a1 + 136) = a4;
      *(_BYTE *)(a1 + 28) = v8;
      *(_QWORD *)(a1 + 144) = a5;
      CSchannelTelemetryContext::LogAppName((CSchannelTelemetryContext *)a1);
    }
  }
}
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (000000018000EC6C) ----------------------------------------------------
void __fastcall CSslUserContext::~CSslUserContext(CSslUserContext *this)
{
  *(_QWORD *)this = &CSslUserContext::`vftable';
  CSslUserContext::CleanupUserContext(this);
  *(_QWORD *)this = &ISslSerialize::`vftable';
}
// 18007CFB8: using guessed type void *ISslSerialize::`vftable';
// 18007D058: using guessed type void *CSslUserContext::`vftable';

//----- (000000018000EC9C) ----------------------------------------------------
void __fastcall CSslUserContext::CleanupUserContext(CSslUserContext *this)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  void *v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx

  if ( *((_QWORD *)this + 11) )
    SslDecrementProviderReferenceCount();
  v2 = *((_QWORD *)this + 5);
  if ( v2 )
    SslFreeObject(v2, 0i64);
  v3 = *((_QWORD *)this + 6);
  if ( v3 )
    SslFreeObject(v3, 0i64);
  v4 = (void *)*((_QWORD *)this + 33);
  if ( v4 )
    NtClose(v4);
  v5 = *((_QWORD *)this + 54);
  if ( v5 )
    SslFreeObject(v5, 0i64);
  v6 = *((_QWORD *)this + 55);
  if ( v6 )
    SslFreeObject(v6, 0i64);
  v7 = *((_QWORD *)this + 56);
  if ( v7 )
    SslFreeObject(v7, 0i64);
}
// 180098518: using guessed type __int64 SslDecrementProviderReferenceCount(void);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (000000018000ED40) ----------------------------------------------------
CSslUserContext *__fastcall CSslUserContext::`vector deleting destructor'(CSslUserContext *this)
{
  CSslUserContext::~CSslUserContext(this);
  return this;
}

//----- (000000018000ED60) ----------------------------------------------------
void __fastcall DeleteUserContext(struct CSslUserContext *a1)
{
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x7Eu, (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, a1);
  (**(void (__fastcall ***)(struct CSslUserContext *, _QWORD))a1)(a1, 0i64);
  LocalFree(a1);
}

//----- (000000018000EDBC) ----------------------------------------------------
__int64 __fastcall GetCipherInfo(struct CSslUserContext *a1, struct _SecPkgContext_CipherInfo *a2)
{
  unsigned __int16 v4; // ax
  unsigned int v5; // r14d
  __int64 v6; // rdi
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  int v12[3]; // [rsp+30h] [rbp-D0h] BYREF
  _WORD Src[64]; // [rsp+3Ch] [rbp-C4h] BYREF
  _WORD v14[64]; // [rsp+BCh] [rbp-44h] BYREF
  DWORD v15; // [rsp+13Ch] [rbp+3Ch]
  DWORD v16; // [rsp+140h] [rbp+40h]
  _WORD v17[64]; // [rsp+144h] [rbp+44h] BYREF
  DWORD v18; // [rsp+1C4h] [rbp+C4h]
  _WORD v19[64]; // [rsp+1C8h] [rbp+C8h] BYREF
  DWORD v20; // [rsp+248h] [rbp+148h]
  DWORD v21; // [rsp+24Ch] [rbp+14Ch]
  _WORD v22[72]; // [rsp+250h] [rbp+150h] BYREF

  memset_0(v12, 0, 0x2A4ui64);
  v4 = ConvertSchannelProtocolToSsl(*((_DWORD *)a1 + 6));
  v5 = SslLookupCipherSuiteInfo(
         *((_QWORD *)a1 + 11),
         v4,
         *((unsigned int *)a1 + 14),
         *((unsigned int *)a1 + 15),
         v12,
         0);
  if ( !v5 )
  {
    v6 = -1i64;
    a2->dwProtocol = v12[0];
    v7 = -1i64;
    a2->dwCipherSuite = v12[1];
    a2->dwBaseCipherSuite = v12[2];
    a2->dwVersion = 1;
    do
      ++v7;
    while ( Src[v7] );
    memcpy_0(a2->szCipherSuite, Src, 2i64 * (unsigned int)(v7 + 1));
    v8 = -1i64;
    do
      ++v8;
    while ( v14[v8] );
    memcpy_0(a2->szCipher, v14, 2i64 * (unsigned int)(v8 + 1));
    a2->dwCipherLen = v15;
    a2->dwCipherBlockLen = v16;
    v9 = -1i64;
    do
      ++v9;
    while ( v17[v9] );
    memcpy_0(a2->szHash, v17, 2i64 * (unsigned int)(v9 + 1));
    a2->dwHashLen = v18;
    v10 = -1i64;
    do
      ++v10;
    while ( v19[v10] );
    memcpy_0(a2->szExchange, v19, 2i64 * (unsigned int)(v10 + 1));
    a2->dwMinExchangeLen = v20;
    a2->dwMaxExchangeLen = v21;
    do
      ++v6;
    while ( v22[v6] );
    memcpy_0(a2->szCertificate, v22, 2i64 * (unsigned int)(v6 + 1));
    a2->dwKeyType = *((_DWORD *)a1 + 15);
  }
  return v5;
}
// 180098510: using guessed type __int64 __fastcall SslLookupCipherSuiteInfo(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 18000EDBC: using guessed type _WORD Src[64];
// 18000EDBC: using guessed type _WORD var_254[64];
// 18000EDBC: using guessed type _WORD var_1CC[64];
// 18000EDBC: using guessed type _WORD var_148[64];
// 18000EDBC: using guessed type _WORD var_C0[72];

//----- (000000018000EFA0) ----------------------------------------------------
__int64 __fastcall GetOldConnectionInfo(struct CSslUserContext *a1, struct _SecPkgContext_ConnectionInfo *a2)
{
  unsigned __int16 v4; // ax
  unsigned int v5; // esi
  ALG_ID v6; // eax
  ALG_ID v7; // eax
  __int64 v8; // rdx
  ALG_ID v9; // eax
  int v11; // [rsp+30h] [rbp-348h] BYREF
  char v12[268]; // [rsp+34h] [rbp-344h] BYREF
  DWORD v13; // [rsp+140h] [rbp-238h]
  DWORD v14; // [rsp+1C8h] [rbp-1B0h]

  v11 = 1;
  memset_0(v12, 0, 0x324ui64);
  v4 = ConvertSchannelProtocolToSsl(*((_DWORD *)a1 + 6));
  v5 = SslLookupCipherSuiteInfo(
         *((_QWORD *)a1 + 11),
         v4,
         *((unsigned int *)a1 + 14),
         *((unsigned int *)a1 + 15),
         v12,
         0);
  if ( !v5 )
  {
    a2->dwProtocol = *((_DWORD *)a1 + 6);
    v6 = LookupSymmetricCipherAlg((struct _NCRYPT_SSL_CIPHER_SUITE_EX *)&v11);
    a2->aiCipher = v6;
    if ( v6 - 28672 <= 0xF )
      a2->aiCipher = 28672;
    a2->dwCipherStrength = v13;
    v7 = LookupChecksumAlg((wchar_t *)&v11);
    a2->aiHash = v7;
    if ( v7 - 36864 <= 0xF )
      a2->aiHash = 36864;
    a2->dwHashStrength = v14;
    v9 = LookupExchangeAlg((wchar_t *)&v11, v8);
    a2->aiExch = v9;
    if ( v9 - 45056 <= 4 )
      a2->aiExch = 45056;
    a2->dwExchStrength = *((_DWORD *)a1 + 7);
  }
  return v5;
}
// 18000F069: variable 'v8' is possibly undefined
// 180098510: using guessed type __int64 __fastcall SslLookupCipherSuiteInfo(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);

//----- (000000018000F0CC) ----------------------------------------------------
__int64 __fastcall LookupExchangeAlg(wchar_t *a1, __int64 a2)
{
  const wchar_t *v2; // rbx
  unsigned int v4; // [rsp+30h] [rbp+8h] BYREF

  v4 = 0;
  v2 = a1 + 206;
  if ( (unsigned int)I_GetKeyExchangeDetailsFromAlgorithmName(a1 + 206, a2, &v4)
    && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids, v2);
  }
  return v4;
}

//----- (000000018000F120) ----------------------------------------------------
__int64 __fastcall LookupChecksumAlg(wchar_t *a1)
{
  const wchar_t *v1; // rsi
  unsigned int v3; // ebx
  __int64 HashInfoFromAlgorithmName; // rax
  __int64 v5; // r9
  int v6; // eax
  int v7; // edx
  int HashDetailsFromHashInfo; // eax
  unsigned int v10; // [rsp+40h] [rbp+8h] BYREF

  v1 = a1 + 140;
  v3 = 0;
  v10 = 0;
  HashInfoFromAlgorithmName = I_GetHashInfoFromAlgorithmName(a1 + 140);
  if ( HashInfoFromAlgorithmName )
  {
    HashDetailsFromHashInfo = I_GetHashDetailsFromHashInfo(HashInfoFromAlgorithmName, 0i64, 0i64, v5, &v10, 0i64);
    v3 = v10;
    if ( !HashDetailsFromHashInfo )
      return v3;
  }
  v6 = *((_DWORD *)a1 + 2);
  if ( v6 == 49199 )
    return 32780;
  v7 = 4101;
  if ( (unsigned int)(v6 - 156) <= 0xC )
  {
    if ( _bittest(&v7, v6 - 156) )
      return 32780;
  }
  if ( v6 == 49200 || v6 == 49196 )
    return 32781;
  if ( v6 == 49195 || v6 == 4865 || v6 == 4867 )
    return 32780;
  if ( (unsigned int)(v6 - 157) <= 0xC && _bittest(&v7, v6 - 157) || v6 == 4866 )
    return 32781;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xEu, (__int64)&WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids, v1);
  return v3;
}
// 18000F1A5: variable 'v5' is possibly undefined

//----- (000000018000F1FC) ----------------------------------------------------
__int64 __fastcall LookupSymmetricCipherAlg(struct _NCRYPT_SSL_CIPHER_SUITE_EX *a1)
{
  wchar_t *v1; // rdi
  unsigned int v3; // ebx
  int v4; // eax
  __int64 v6; // rdx
  __int64 v7; // r8
  unsigned int v8; // [rsp+30h] [rbp+8h] BYREF

  v1 = (wchar_t *)((char *)a1 + 144);
  v3 = 0;
  if ( !wcscmp_0((const wchar_t *)a1 + 72, L"AES") )
  {
    v4 = *((_DWORD *)a1 + 68);
    if ( v4 == 256 )
    {
      return 26128;
    }
    else
    {
      v3 = 26129;
      if ( v4 == 128 )
        return 26126;
    }
  }
  else if ( !wcscmp_0(v1, L"DES") )
  {
    return 26113;
  }
  else if ( !wcscmp_0(v1, L"RC4") )
  {
    return 26625;
  }
  else if ( !wcscmp_0(v1, L"3DES") )
  {
    return 26115;
  }
  else if ( *v1 )
  {
    v8 = 0;
    if ( wcscmp_0(v1, L"CHACHA20_POLY1305") )
    {
      if ( (unsigned int)I_GetCipherDetailsFromAlgorithmName(v1, v6, v7, &v8)
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_S(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xDu,
          (__int64)&WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids,
          v1);
      }
      return v8;
    }
  }
  else
  {
    return 24576;
  }
  return v3;
}
// 1800386FD: variable 'v6' is possibly undefined
// 1800386FD: variable 'v7' is possibly undefined

//----- (000000018000F2C0) ----------------------------------------------------
__int64 __fastcall SpQueryEndpointBindings(struct CSslUserContext *a1, struct _SecPkgContext_Bindings *a2)
{
  unsigned __int8 *v2; // rdi
  unsigned int v4; // ebx
  unsigned __int8 *v5; // rbp
  unsigned int v6; // ebx
  unsigned int v7; // r14d
  SEC_CHANNEL_BINDINGS *v8; // rax
  SEC_CHANNEL_BINDINGS *Bindings; // rcx
  unsigned int v11; // [rsp+50h] [rbp+8h] BYREF
  unsigned __int8 *v12; // [rsp+58h] [rbp+10h] BYREF

  v2 = 0i64;
  a2->BindingsLength = 0;
  a2->Bindings = 0i64;
  if ( (*((_BYTE *)a1 + 24) & 0xC) != 0 )
  {
    v6 = -2146893054;
    goto LABEL_13;
  }
  v4 = *((_DWORD *)a1 + 60);
  v5 = (unsigned __int8 *)*((_QWORD *)a1 + 29);
  v12 = v5;
  v11 = v4;
  if ( !v4 )
  {
    v6 = GenerateRemoteEndpointBindingsHash((__int64)a1, &v12, &v11);
    if ( v6 )
      goto LABEL_13;
    v2 = v12;
    v4 = v11;
    v5 = v12;
  }
  if ( !v5 || !v4 )
    goto LABEL_10;
  v7 = v4 + 53;
  if ( v4 + 53 < v4 )
  {
    v6 = -2146893052;
  }
  else
  {
    v8 = (SEC_CHANNEL_BINDINGS *)LocalAlloc(0x40u, v7);
    a2->Bindings = v8;
    if ( v8 )
    {
      v8->cbApplicationDataLength = v4 + 21;
      a2->Bindings->dwApplicationDataOffset = 32;
      Bindings = a2->Bindings;
      qmemcpy(&Bindings[1], "tls-server-end-point:", 21);
      memcpy_0((char *)&Bindings[1].dwAcceptorOffset + 1, v5, v4);
      a2->BindingsLength = v7;
LABEL_10:
      v6 = 0;
      goto LABEL_11;
    }
    v6 = -2146893056;
  }
LABEL_11:
  if ( v2 )
    SPExternalFree(v2);
LABEL_13:
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v6 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x67u,
      (__int64)&WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids,
      v6,
      v6);
  }
  return v6;
}

//----- (000000018000F3F4) ----------------------------------------------------
__int64 __fastcall GenerateRemoteEndpointBindingsHash(__int64 a1, unsigned __int8 **a2, unsigned int *a3)
{
  DWORD CertEndpointBindings; // ebx
  PCCERT_CONTEXT pCertContext; // [rsp+30h] [rbp+8h] BYREF

  *a2 = 0i64;
  *a3 = 0;
  pCertContext = 0i64;
  if ( (*(_DWORD *)(a1 + 24) & 0x40051555) != 0 || !*(_QWORD *)(a1 + 152) )
    return 0i64;
  CertEndpointBindings = SPLoadCertificate(*(unsigned __int8 **)(a1 + 152), *(_DWORD *)(a1 + 160), &pCertContext);
  if ( !CertEndpointBindings )
  {
    CertEndpointBindings = GetCertEndpointBindings(pCertContext, a2, a3);
    CertFreeCertificateContext(pCertContext);
  }
  return CertEndpointBindings;
}

//----- (000000018000F484) ----------------------------------------------------
DWORD __fastcall GetCertEndpointBindings(const struct _CERT_CONTEXT *a1, unsigned __int8 **a2, unsigned int *a3)
{
  PCCRYPT_OID_INFO OIDInfo; // rax
  const wchar_t *v7; // rbx
  unsigned __int8 *pbComputedHash; // rdi
  DWORD v9; // eax
  DWORD LastError; // ebx
  DWORD pcbComputedHash; // [rsp+60h] [rbp+8h] BYREF

  pcbComputedHash = 0;
  OIDInfo = CryptFindOIDInfo(1u, a1->pCertInfo->SignatureAlgorithm.pszObjId, 0x40000004u);
  if ( !OIDInfo
    || OIDInfo->dwValue != -1
    || (v7 = *(const wchar_t **)&OIDInfo[1].cbSize) == 0i64
    || !wcscmp_0(*(const wchar_t **)&OIDInfo[1].cbSize, L"SHA1")
    || !wcscmp_0(v7, L"MD5") )
  {
    v7 = L"SHA256";
  }
  if ( !CryptHashCertificate2(v7, 0, 0i64, a1->pbCertEncoded, a1->cbCertEncoded, 0i64, &pcbComputedHash) )
    return GetLastError();
  pbComputedHash = (unsigned __int8 *)SPExternalAlloc(pcbComputedHash);
  if ( !pbComputedHash )
    return -2146893056;
  if ( CryptHashCertificate2(v7, 0, 0i64, a1->pbCertEncoded, a1->cbCertEncoded, pbComputedHash, &pcbComputedHash) )
  {
    v9 = pcbComputedHash;
    *a2 = pbComputedHash;
    *a3 = v9;
    return 0;
  }
  else
  {
    LastError = GetLastError();
    SPExternalFree(pbComputedHash);
    return LastError;
  }
}

//----- (000000018000F5C0) ----------------------------------------------------
DWORD __fastcall SPLoadCertificate(unsigned __int8 *a1, DWORD LastError, const struct _CERT_CONTEXT **a3)
{
  HCERTSTORE v6; // r14
  int v7; // r15d
  __int64 v8; // rbp
  unsigned int v9; // ebx
  const BYTE *v10; // rsi
  PCCERT_CONTEXT pCertContext; // [rsp+60h] [rbp+18h] BYREF

  pCertContext = 0i64;
  if ( !a3 )
    return -2146893052;
  if ( *a3 )
    CertFreeCertificateContext(*a3);
  *a3 = 0i64;
  v6 = CertOpenStore((LPCSTR)2, 0, 0i64, 4u, 0i64);
  if ( !v6 )
    return GetLastError();
  v7 = 1;
  while ( LastError >= 4 )
  {
    v8 = *(unsigned int *)a1;
    v9 = LastError - 4;
    v10 = a1 + 4;
    if ( (unsigned int)v8 > v9 )
      break;
    if ( !CertAddEncodedCertificateToStore(v6, 1u, v10, v8, 2u, &pCertContext) )
    {
      LastError = GetLastError();
      goto LABEL_12;
    }
    a1 = (unsigned __int8 *)&v10[v8];
    LastError = v9 - v8;
    if ( v7 )
    {
      v7 = 0;
      *a3 = pCertContext;
    }
    else
    {
      CertFreeCertificateContext(pCertContext);
    }
    pCertContext = 0i64;
    if ( !LastError )
      goto LABEL_12;
  }
  LastError = -2146893052;
LABEL_12:
  CertCloseStore(v6, 0);
  if ( LastError )
  {
    if ( pCertContext )
      CertFreeCertificateContext(pCertContext);
    if ( *a3 )
    {
      CertFreeCertificateContext(*a3);
      *a3 = 0i64;
    }
  }
  return LastError;
}

//----- (000000018000F6EC) ----------------------------------------------------
__int64 __fastcall SpQueryApplicationProtocol(
        struct CSslUserContext *a1,
        struct _SecPkgContext_ApplicationProtocol *a2)
{
  _OWORD *v4; // rax
  __int64 v5; // rcx
  __int128 v6; // xmm1

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 108i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
  v4 = (_OWORD *)*((_QWORD *)a1 + 49);
  if ( v4 )
  {
    v5 = 2i64;
    do
    {
      *(_OWORD *)&a2->ProtoNegoStatus = *v4;
      *(_OWORD *)&a2->ProtocolId[7] = v4[1];
      *(_OWORD *)&a2->ProtocolId[23] = v4[2];
      *(_OWORD *)&a2->ProtocolId[39] = v4[3];
      *(_OWORD *)&a2->ProtocolId[55] = v4[4];
      *(_OWORD *)&a2->ProtocolId[71] = v4[5];
      *(_OWORD *)&a2->ProtocolId[87] = v4[6];
      a2 = (struct _SecPkgContext_ApplicationProtocol *)((char *)a2 + 128);
      v6 = v4[7];
      v4 += 8;
      *(_OWORD *)&a2[-1].ProtocolId[239] = v6;
      --v5;
    }
    while ( v5 );
    *(_QWORD *)&a2->ProtoNegoStatus = *(_QWORD *)v4;
  }
  else
  {
    memset_0(a2, 0, sizeof(struct _SecPkgContext_ApplicationProtocol));
  }
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018000F7A4) ----------------------------------------------------
__int64 __fastcall GetUserKeysCallback(
        struct CSslUserContext *a1,
        void *(__stdcall *a2)(unsigned int),
        void (__stdcall *a3)(void *),
        char a4,
        struct _SecBuffer *a5)
{
  char v5; // di
  unsigned int v8; // ebx
  __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 v11; // rdx
  __int64 v12; // rdx
  _QWORD *v13; // rax
  __int64 v14; // rdx
  __int64 v15; // rdx
  __int64 v16; // rdx
  __int64 v17; // rdx
  CCipherMill *v19; // rcx
  __int64 v20; // rdx
  void *pvBuffer; // rcx
  CCipherMill *v22; // rcx
  __int64 v23; // rdx
  char v24; // [rsp+B0h] [rbp+58h]

  v5 = a4 & 8;
  a5->pvBuffer = 0i64;
  v8 = 0;
  v24 = a4 & 8;
  if ( *((_DWORD *)a1 + 14) )
  {
    if ( (a4 & 1) != 0 )
    {
      v9 = *((_QWORD *)a1 + 5);
      if ( v9 )
      {
        v8 = SslExportKey(*((_QWORD *)a1 + 11), v9, L"OpaqueKeyBlob");
        if ( v8 )
        {
          v19 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_27;
          }
          v20 = 127i64;
LABEL_26:
          WPP_SF_D(*((_QWORD *)v19 + 2), v20, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v8);
          goto LABEL_27;
        }
      }
    }
    if ( (a4 & 2) != 0 )
    {
      v10 = *((_QWORD *)a1 + 6);
      if ( v10 )
      {
        v8 = SslExportKey(*((_QWORD *)a1 + 11), v10, L"OpaqueKeyBlob");
        if ( v8 )
        {
          v19 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_27;
          }
          v20 = 128i64;
          goto LABEL_26;
        }
      }
    }
    v11 = *((_QWORD *)a1 + 55);
    if ( v11 )
    {
      v8 = SslExportKey(*((_QWORD *)a1 + 11), v11, L"OpaqueKeyBlob");
      if ( v8 )
      {
        v19 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          goto LABEL_27;
        v20 = 129i64;
        goto LABEL_26;
      }
    }
    v12 = *((_QWORD *)a1 + 56);
    if ( v12 )
    {
      v8 = SslExportKey(*((_QWORD *)a1 + 11), v12, L"OpaqueKeyBlob");
      if ( v8 )
      {
        v19 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          goto LABEL_27;
        v20 = 130i64;
        goto LABEL_26;
      }
    }
  }
  if ( v5 )
    v13 = SPExternalAlloc(0x3Du);
  else
    v13 = PvExtVirtualAlloc(0x3Du);
  if ( v13 )
  {
    a5->pvBuffer = v13;
    a5->cbBuffer = 61;
    a5->BufferType = 1;
    *v13 = *((_QWORD *)a1 + 12);
    v13[1] = *((_QWORD *)a1 + 13);
    *((_DWORD *)v13 + 4) = *((_DWORD *)a1 + 29);
    *(_QWORD *)((char *)v13 + 20) = *((_QWORD *)a1 + 15);
    *(_QWORD *)((char *)v13 + 28) = *((_QWORD *)a1 + 16);
    *((_WORD *)v13 + 18) = *((_WORD *)a1 + 68);
    *((_WORD *)v13 + 19) = *((_WORD *)a1 + 69);
    *((_DWORD *)v13 + 10) = *((_DWORD *)a1 + 36);
    *((_BYTE *)v13 + 44) = *((_BYTE *)a1 + 456);
    *(_DWORD *)((char *)v13 + 45) = 0;
    *(_DWORD *)((char *)v13 + 49) = 0;
    *(_DWORD *)((char *)v13 + 53) = 0;
    *(_DWORD *)((char *)v13 + 57) = 0;
    if ( *((_DWORD *)a1 + 14) )
    {
      if ( (a4 & 1) != 0 )
      {
        v14 = *((_QWORD *)a1 + 5);
        if ( v14 )
        {
          v8 = SslExportKey(*((_QWORD *)a1 + 11), v14, L"OpaqueKeyBlob");
          if ( v8 )
          {
            v22 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
            {
              goto LABEL_21;
            }
            v23 = 131i64;
            goto LABEL_47;
          }
        }
      }
      if ( (a4 & 2) != 0 )
      {
        v15 = *((_QWORD *)a1 + 6);
        if ( v15 )
        {
          v8 = SslExportKey(*((_QWORD *)a1 + 11), v15, L"OpaqueKeyBlob");
          if ( v8 )
          {
            v22 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
            {
              goto LABEL_21;
            }
            v23 = 132i64;
            goto LABEL_47;
          }
        }
      }
      v16 = *((_QWORD *)a1 + 55);
      if ( v16 )
      {
        v8 = SslExportKey(*((_QWORD *)a1 + 11), v16, L"OpaqueKeyBlob");
        if ( v8 )
        {
          v22 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_21;
          }
          v23 = 133i64;
          goto LABEL_47;
        }
      }
      v17 = *((_QWORD *)a1 + 56);
      if ( v17 )
      {
        v8 = SslExportKey(*((_QWORD *)a1 + 11), v17, L"OpaqueKeyBlob");
        if ( v8 )
        {
          v22 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_21;
          }
          v23 = 134i64;
LABEL_47:
          WPP_SF_D(*((_QWORD *)v22 + 2), v23, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids, v8);
LABEL_21:
          v5 = v24;
LABEL_27:
          pvBuffer = a5->pvBuffer;
          if ( pvBuffer )
          {
            if ( v5 )
              SPExternalFree(pvBuffer);
            else
              FreeExtVirtualAlloc(pvBuffer);
            a5->pvBuffer = 0i64;
          }
          *(_QWORD *)&a5->cbBuffer = 0i64;
        }
      }
    }
    return v8;
  }
  return 2148074240i64;
}
// 18000F9D0: conditional instruction was optimized away because ebx.4==0
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082320: using guessed type wchar_t aOpaquekeyblob[14];
// 180098528: using guessed type __int64 __fastcall SslExportKey(_QWORD, _QWORD, _QWORD);

//----- (000000018000F9F8) ----------------------------------------------------
DWORD __fastcall SpQueryRemoteCertContext(struct CSslUserContext *a1, const CERT_CONTEXT **a2)
{
  unsigned __int8 *v4; // rcx
  DWORD result; // eax
  const CERT_CONTEXT *v6; // rdi
  __int64 v7; // rax
  DWORD LastError; // eax
  DWORD v9; // eax
  int pvData; // [rsp+20h] [rbp-18h] BYREF
  __int64 v11; // [rsp+28h] [rbp-10h]
  PCCERT_CONTEXT pCertContext; // [rsp+40h] [rbp+8h] BYREF

  pCertContext = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids);
  v4 = (unsigned __int8 *)*((_QWORD *)a1 + 19);
  if ( !v4 )
    return -2146893042;
  result = SPLoadCertificate(v4, *((_DWORD *)a1 + 40), &pCertContext);
  if ( !result )
  {
    v6 = pCertContext;
    if ( *((_QWORD *)a1 + 25) )
    {
      v11 = *((_QWORD *)a1 + 25);
      pvData = *((_DWORD *)a1 + 52);
      if ( !CertSetCertificateContextProperty(pCertContext, 0x46u, 0, &pvData)
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
      {
        LastError = GetLastError();
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          13i64,
          &WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids,
          LastError);
      }
    }
    v7 = *((_QWORD *)a1 + 27);
    if ( v7 )
    {
      if ( *((_DWORD *)a1 + 56) )
      {
        pvData = *((_DWORD *)a1 + 56);
        v11 = v7;
        if ( !CertSetCertificateContextProperty(v6, 0x77u, 0, &pvData)
          && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        {
          v9 = GetLastError();
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &WPP_6dc6bfeff2363ebb5c4b35617de21a59_Traceguids, v9);
        }
      }
    }
    *a2 = v6;
    return 0;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000FB04) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::InitializeCredentialGroup(
        CCredentialGroup *this,
        unsigned int a2,
        struct _LUID *a3,
        __int64 a4,
        struct LSA_SCHANNEL_CRED *a5,
        unsigned __int16 *a6)
{
  int v9; // r15d
  unsigned int v10; // esi
  int v11; // eax
  unsigned int RandomBits; // esi
  unsigned int v13; // edx
  int v14; // eax
  __int64 v15; // rax
  __int64 v16; // rax
  const WCHAR *v18; // rdx
  CSslCredential *v19; // rax
  CSslCredential *v20; // r13
  CCredentialGroup *v21; // rdx
  CCredentialGroup **v22; // rcx
  unsigned int v23; // r8d
  int v24; // edx
  char v25; // si
  char v26; // r10
  unsigned int v27; // r15d
  PCCERT_CONTEXT *v28; // rcx
  void *v29; // rcx
  HCERTSTORE v30; // rax
  DWORD LastError; // eax
  void *v32; // rcx
  __int64 v33; // rax
  char pvData[4]; // [rsp+50h] [rbp-88h] BYREF
  unsigned int i; // [rsp+54h] [rbp-84h]
  DWORD pcbData; // [rsp+58h] [rbp-80h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+60h] [rbp-78h] BYREF
  struct _UNICODE_STRING v38; // [rsp+70h] [rbp-68h] BYREF
  int v39; // [rsp+80h] [rbp-58h] BYREF
  char v40; // [rsp+88h] [rbp-50h]

  pcbData = 0;
  v9 = 0;
  RtlInitializeResource((PRTL_RESOURCE)((char *)this + 48));
  *((_DWORD *)this + 36) = 1;
  if ( (*(unsigned __int8 (__fastcall **)(int *))(LsaTable + 192))(&v39) )
  {
    *((_DWORD *)this + 53) = v39;
    *((_BYTE *)this + 172) = v40 & 1;
    *((_BYTE *)this + 173) = (v40 & 0x11) == 0;
  }
  StringCchCopyW((char *)this + 216, 260i64, (char *)a6);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_qD(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x15u, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, this, a2);
  v10 = *((_DWORD *)this + 53);
  if ( (g_dwEventLogging & 4) != 0 )
  {
    v18 = (const WCHAR *)pszClientString;
    if ( (a2 & 0x40051555) != 0 )
      v18 = pszServerString;
    RtlInitUnicodeString(&DestinationString, v18);
    RtlInitUnicodeString(&v38, (PCWSTR)this + 108);
    SchEventWrite(&SSLEVENT_CREATE_CRED, L"duub", v10, &v38, &DestinationString, 80i64, a5);
  }
  v11 = CopyTlsParameters(
          *((struct _TLS_PARAMETERS **)a5 + 13),
          *((_DWORD *)a5 + 24),
          0,
          0,
          (struct _TLS_PARAMETERS **)this + 25,
          (unsigned int *)this + 49);
  if ( v11 )
  {
    RandomBits = 87;
    if ( v11 == -2146893056 )
      RandomBits = 14;
    v9 = 10017;
    goto LABEL_35;
  }
  RandomBits = CCredentialGroup::InitializeEnabledProtocols(
                 this,
                 *(_DWORD *)a5,
                 *((_DWORD *)a5 + 18),
                 *((_DWORD *)a5 + 22),
                 a2);
  if ( RandomBits )
  {
    v9 = 10013;
    goto LABEL_35;
  }
  *(struct _LUID *)((char *)this + 740) = *a3;
  *((_QWORD *)this + 94) = a4;
  if ( (a2 & 0x800A2AAA) != 0 )
  {
    if ( bDomainJoined )
    {
      RandomBits = CCredentialGroup::InitializeClientNameInfo(this, a4);
      if ( RandomBits )
        goto LABEL_35;
    }
  }
  RandomBits = GenerateRandomBits((PUCHAR)this + 760, 8u);
  if ( RandomBits )
    goto LABEL_35;
  for ( i = 0; i < *((_DWORD *)a5 + 1); ++i )
  {
    v19 = (CSslCredential *)SPExternalAlloc(0x498u);
    if ( v19 )
      v20 = CSslCredential::CSslCredential(v19);
    else
      v20 = 0i64;
    if ( !v20 )
    {
      RandomBits = 14;
      goto LABEL_35;
    }
    v21 = (CSslCredential *)((char *)v20 + 8);
    v22 = (CCredentialGroup **)*((_QWORD *)this + 5);
    if ( *v22 != (CCredentialGroup *)((char *)this + 32) )
      __fastfail(3u);
    *(_QWORD *)v21 = (char *)this + 32;
    *((_QWORD *)v20 + 2) = v22;
    *v22 = v21;
    *((_QWORD *)this + 5) = v21;
    ++*((_DWORD *)this + 7);
    v23 = *((_DWORD *)a5 + 22);
    v24 = HIWORD(v23) & 1 | 4;
    if ( (v23 & 0x20000) == 0 )
      v24 = HIWORD(*((_DWORD *)a5 + 22)) & 1;
    v25 = v24 | 8;
    if ( (v23 & 0x40000) == 0 )
      v25 = v24;
    if ( g_fDisableOcsp )
    {
      v26 = v25 | 0x10;
    }
    else
    {
      v26 = v25;
      if ( (v23 & 0x180000) == 0x80000 && !g_fEnableOcspForSni )
      {
        v27 = i;
        v28 = (PCCERT_CONTEXT *)(*((_QWORD *)a5 + 1) + 56i64 * i);
        pvData[0] = 0;
        pcbData = 1;
        if ( !CertGetCertificateContextProperty(*v28, 0x79u, pvData, &pcbData) || (v26 = v25, !pvData[0]) )
          v26 = v25 | 0x10;
        goto LABEL_53;
      }
    }
    v27 = i;
LABEL_53:
    RandomBits = CSslCredential::CreateCredential(
                   v20,
                   *((_DWORD *)this + 53),
                   (char *)this + 216,
                   a4,
                   (struct LSA_SCHANNEL_SUB_CRED *)(*((_QWORD *)a5 + 1) + 56i64 * v27),
                   v26,
                   1u,
                   *((_QWORD *)a5 + 3) != 0i64,
                   *((struct _TLS_PARAMETERS **)this + 25),
                   *((_DWORD *)this + 49));
    pcbData = *((unsigned __int8 *)v20 + 76);
    v9 = *((_DWORD *)v20 + 18);
    if ( RandomBits )
      goto LABEL_35;
    if ( *((_DWORD *)v20 + 35) )
      *((_BYTE *)this + 900) = 1;
  }
  CCredentialGroup::InitializeFlags(this, *((_DWORD *)a5 + 22));
  if ( (a2 & 0x40051555) != 0 && (*((_DWORD *)this + 39) & 0x4000) != 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids);
    RandomBits = 87;
    v9 = 10019;
    goto LABEL_35;
  }
  if ( (*((_DWORD *)this + 39) & 0x2000) != 0 )
  {
    *((_DWORD *)a5 + 19) = -1;
    v13 = -1;
  }
  else
  {
    v13 = *((_DWORD *)a5 + 19);
  }
  RandomBits = CCredentialGroup::InitializeMinMaxStrengths(this, v13, *((_DWORD *)a5 + 20));
  if ( RandomBits )
  {
    v9 = 10010;
LABEL_35:
    if ( !pcbData )
      LogCreateCredFailedEvent(*((_DWORD *)this + 53), (const WCHAR *)this + 108, (a2 & 0x40051555) != 0, v9);
    *((_QWORD *)this + 94) = 0i64;
    return RandomBits;
  }
  if ( !BuildUserRequestedAlgList(
          this,
          *((_BYTE *)this + 172),
          *((unsigned int **)a5 + 8),
          *((_DWORD *)a5 + 14),
          (unsigned int **)this + 23,
          (unsigned int *)this + 44,
          (CCredentialGroup *)((char *)this + 192)) )
  {
    RandomBits = -2146893007;
    v9 = 10011;
    goto LABEL_35;
  }
  if ( *((_DWORD *)a5 + 21) )
  {
    v14 = 0;
    if ( *((_DWORD *)a5 + 21) != -1 )
      v14 = *((_DWORD *)a5 + 21);
  }
  else if ( (*((_DWORD *)this + 38) & 0x800A2AAA) != 0 )
  {
    v14 = *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 5);
  }
  else
  {
    v14 = *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 6);
  }
  *((_DWORD *)this + 52) = v14;
  if ( (a2 & 0x40051555) != 0 )
  {
    v29 = (void *)*((_QWORD *)a5 + 2);
    if ( v29 )
    {
      v30 = CertDuplicateStore(v29);
      *((_QWORD *)this + 96) = v30;
      if ( !v30
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        LastError = GetLastError();
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          23i64,
          &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids,
          LastError);
      }
    }
  }
  v15 = *((_QWORD *)a5 + 3);
  if ( v15 )
    *((_QWORD *)this + 100) = v15;
  else
    v15 = *((_QWORD *)this + 100);
  if ( v15 )
  {
    v32 = (void *)*((_QWORD *)a5 + 4);
    if ( v32 )
      CertCloseStore(v32, 0);
  }
  v16 = *((_QWORD *)a5 + 5);
  if ( v16 )
  {
    *((_QWORD *)this + 101) = v16;
    v33 = *((_QWORD *)a5 + 6);
    if ( v33 )
      *((_QWORD *)this + 102) = v33;
  }
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082B38: using guessed type GUID WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids;
// 180092620: using guessed type __int64 LsaTable;
// 180092648: using guessed type int bDomainJoined;
// 1800927A4: using guessed type int g_fDisableOcsp;
// 1800927A8: using guessed type int g_fEnableOcspForSni;
// 18000FB04: using guessed type char pvData[4];

//----- (000000018000FDD4) ----------------------------------------------------
char __fastcall BuildUserRequestedAlgList(
        struct CCredentialGroup *a1,
        char a2,
        unsigned int *a3,
        unsigned int a4,
        unsigned int **a5,
        unsigned int *a6,
        enum efAlgFlags *a7)
{
  int v7; // ebp
  unsigned int *v8; // r14
  char IsUserSpecifiedCipherAllowed; // di
  __int64 v13; // r15
  unsigned int v14; // r8d
  __int64 v16; // r12
  unsigned int *v17; // rax
  unsigned int v18; // esi
  unsigned int v19; // ecx
  _DWORD *v20; // rax
  CCipherMill *v21; // rcx
  __int64 v22; // r9
  __int64 v23; // rdx
  int v24; // eax
  struct kexch *KeyExchangeInfo; // rax
  struct hsel *HashInfo; // rax
  struct csel *CipherInfo; // rax
  unsigned int v28; // ecx
  struct sigsel *SigInfo; // rax
  unsigned int *v30; // [rsp+A0h] [rbp+8h]

  v7 = 0;
  v8 = 0i64;
  IsUserSpecifiedCipherAllowed = 1;
  if ( a1 )
  {
    v13 = 0i64;
    if ( !a3 )
    {
      v14 = *((_DWORD *)a1 + 49);
      if ( !v14 )
        return IsUserSpecifiedCipherAllowed;
LABEL_4:
      IsUserSpecifiedCipherAllowed = CCipherMill::IsUserSpecifiedCipherAllowed(
                                       *((_DWORD *)a1 + 39) & 0x800,
                                       v8,
                                       v13,
                                       v7,
                                       (*((_DWORD *)a1 + 39) >> 12) & 1,
                                       *((_DWORD *)a1 + 39) & 0x800,
                                       *((_DWORD *)a1 + 42),
                                       *((_DWORD *)a1 + 41),
                                       *((_DWORD *)a1 + 38),
                                       a2,
                                       *((_QWORD *)a1 + 25),
                                       v14);
      if ( !IsUserSpecifiedCipherAllowed && !v8 )
        SPExternalFree(0i64);
      return IsUserSpecifiedCipherAllowed;
    }
    v8 = (unsigned int *)SPExternalAlloc(0x44u);
    if ( v8 )
    {
      v16 = 0i64;
      if ( a4 )
      {
        v17 = a3;
        v30 = a3;
        while ( 1 )
        {
          v18 = *v17;
          v19 = 0;
          v20 = &unk_180085640;
          do
          {
            if ( v18 == *v20 )
              goto LABEL_17;
            ++v19;
            ++v20;
          }
          while ( v19 < 0x11 );
          if ( v19 == 17 )
            break;
LABEL_17:
          v24 = v18 & 0xE000;
          switch ( v24 )
          {
            case 8192:
              SigInfo = GetSigInfo(v18);
              if ( !SigInfo || (*((_DWORD *)a1 + 38) & *(_DWORD *)SigInfo) == 0 )
              {
LABEL_42:
                v21 = WPP_GLOBAL_Control;
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                {
                  v23 = 12i64;
                  v22 = v18;
LABEL_40:
                  WPP_SF_D(*((_QWORD *)v21 + 2), v23, &WPP_f57d92ef57843aa8f0882fb6fd501a9b_Traceguids, v22);
                }
                return 0;
              }
              v7 |= 1u;
              break;
            case 24576:
              CipherInfo = GetCipherInfo(v18);
              if ( !CipherInfo )
                goto LABEL_42;
              if ( *((_DWORD *)CipherInfo + 8) != v18 )
                goto LABEL_42;
              v28 = *((_DWORD *)CipherInfo + 10);
              if ( v28 < *((_DWORD *)a1 + 41)
                || v28 > *((_DWORD *)a1 + 42)
                || (*((_DWORD *)a1 + 38) & *(_DWORD *)CipherInfo) == 0 )
              {
                goto LABEL_42;
              }
              v7 |= 8u;
              break;
            case 32768:
              HashInfo = GetHashInfo(v18);
              if ( !HashInfo || (*((_DWORD *)a1 + 38) & *(_DWORD *)HashInfo) == 0 )
                goto LABEL_42;
              v7 |= 2u;
              break;
            case 40960:
              KeyExchangeInfo = GetKeyExchangeInfo(v18);
              if ( !KeyExchangeInfo || (*((_DWORD *)a1 + 38) & *((_DWORD *)KeyExchangeInfo + 1)) == 0 )
                goto LABEL_42;
              v7 |= 4u;
              break;
            default:
              goto LABEL_42;
          }
          if ( !DoesCredAllowAlgId(v8, v13, v18) )
          {
            v8[v13] = v18;
            v13 = (unsigned int)(v13 + 1);
          }
          v16 = (unsigned int)(v16 + 1);
          v17 = ++v30;
          if ( (unsigned int)v16 >= a4 )
            goto LABEL_39;
        }
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          v22 = a3[v16];
          v23 = 11i64;
          goto LABEL_40;
        }
        return 0;
      }
LABEL_39:
      *a5 = v8;
      *a6 = v13;
      *(_DWORD *)a7 = v7;
      v14 = *((_DWORD *)a1 + 49);
      goto LABEL_4;
    }
  }
  return 0;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000FEC0) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::InitializeMinMaxStrengths(
        CCredentialGroup *this,
        unsigned int a2,
        unsigned int a3)
{
  unsigned int *v3; // rdi
  unsigned int *v5; // r14

  v3 = (unsigned int *)((char *)this + 168);
  v5 = (unsigned int *)((char *)this + 164);
  CCipherMill::GetBaseCipherSizes(this, *((_BYTE *)this + 172), (unsigned int *)this + 41, (unsigned int *)this + 42);
  if ( a2 )
  {
    if ( a2 == -1 )
    {
      a2 = 0;
    }
    else if ( a2 > *v3 )
    {
      return 2148074289i64;
    }
  }
  else
  {
    a2 = *v5;
    if ( *v5 < 0x28 )
      a2 = 40;
  }
  *v5 = a2;
  if ( a3 )
  {
    if ( a3 == -1 )
    {
      *v3 = 0;
    }
    else
    {
      if ( a3 < a2 )
        return 2148074289i64;
      *v3 = a3;
    }
  }
  if ( *v3 >= a2 )
    return 0i64;
  return 2148074289i64;
}

//----- (000000018000FF48) ----------------------------------------------------
void __fastcall CCipherMill::GetBaseCipherSizes(CCipherMill *this, char a2, unsigned int *a3, unsigned int *a4)
{
  CMasterCipherInfo *v7; // rax
  unsigned int v8; // r8d
  unsigned int v9; // edx
  unsigned int *v10; // rcx
  unsigned int v11; // eax
  unsigned int v12; // eax

  *a3 = 0;
  *a4 = 0;
  RtlAcquireResourceShared(&Resource, 1u);
  v7 = xmmword_1800925B0;
  if ( a2 )
    v7 = *(&xmmword_1800925B0 + 1);
  if ( v7 )
  {
    v8 = *((_DWORD *)v7 + 2);
    v9 = 0;
    if ( v8 )
    {
      v10 = (unsigned int *)(*(_QWORD *)v7 + 20i64);
      do
      {
        if ( v9 )
        {
          v11 = *a3;
          if ( *a3 >= *v10 )
            v11 = *v10;
        }
        else
        {
          v11 = *v10;
        }
        *a3 = v11;
        v12 = *a4;
        if ( *a4 <= *v10 )
          v12 = *v10;
        ++v9;
        v10 += 216;
        *a4 = v12;
      }
      while ( v9 < v8 );
    }
  }
  RtlReleaseResource(&Resource);
}

//----- (000000018000FFF4) ----------------------------------------------------
void __fastcall CCredentialGroup::InitializeFlags(CCredentialGroup *this, int a2)
{
  int v2; // eax

  if ( (a2 & 2) != 0 )
    *((_DWORD *)this + 39) |= 1u;
  if ( (a2 & 4) != 0 )
    *((_DWORD *)this + 39) |= 2u;
  if ( (a2 & 8) != 0 )
    *((_DWORD *)this + 39) |= 4u;
  if ( (a2 & 0x4000000) != 0 )
    *((_DWORD *)this + 39) |= 0x4000u;
  if ( (a2 & 0x10) != 0 )
    *((_DWORD *)this + 39) |= 8u;
  if ( (a2 & 0x20) != 0 )
    *((_DWORD *)this + 39) &= ~4u;
  if ( (a2 & 0x40) != 0 )
    *((_DWORD *)this + 39) &= ~8u;
  if ( (a2 & 0x80u) != 0 )
    *((_DWORD *)this + 39) |= 0x20u;
  if ( (a2 & 0x40000) != 0 )
    *((_DWORD *)this + 39) |= 0x80u;
  if ( (a2 & 0x80000) != 0 )
  {
    v2 = *((_DWORD *)this + 39) | 0x100;
    *((_DWORD *)this + 39) = v2;
    if ( (a2 & 0x100000) == 0 )
      *((_DWORD *)this + 39) = v2 | 0x200;
  }
  if ( (a2 & 0x200000) != 0 )
    *((_DWORD *)this + 39) |= 0x400u;
  if ( (a2 & 0x400000) != 0 )
    *((_DWORD *)this + 39) |= 0x800u;
  if ( (a2 & 0x800000) != 0 )
    *((_DWORD *)this + 39) |= 0x1000u;
  if ( (a2 & 0x2000000) != 0 )
    *((_DWORD *)this + 39) |= 0x2000u;
  if ( (a2 & 0x8000) != 0 )
    *((_DWORD *)this + 40) |= 0x2000u;
  if ( (a2 & 0x100) != 0 )
    *((_DWORD *)this + 40) |= 0x100u;
  if ( (a2 & 0x200) != 0 )
    *((_DWORD *)this + 40) |= 0x200u;
  if ( (a2 & 0x400) != 0 )
    *((_DWORD *)this + 40) |= 0x400u;
  if ( (a2 & 0x800) != 0 )
    *((_DWORD *)this + 40) |= 0x800u;
  if ( (a2 & 0x1000) != 0 )
    *((_DWORD *)this + 40) |= 0x1000u;
  if ( (a2 & 0x4000) != 0 )
    *((_DWORD *)this + 40) |= 0x4000u;
}

//----- (000000018001011C) ----------------------------------------------------
__int64 __fastcall CCredentialGroup::InitializeEnabledProtocols(
        CCredentialGroup *this,
        unsigned int a2,
        int a3,
        int a4,
        unsigned int a5)
{
  __int64 v6; // r9
  CCipherMill *v10; // rcx
  unsigned int ProtocolsWithCipherSuitesEnabled; // eax
  __int64 v12; // rcx
  unsigned int v13; // esi
  int v14; // eax
  int v15; // ebp
  unsigned __int64 v16; // r8
  unsigned int v17; // edx
  __int64 v18; // rax
  unsigned __int64 v19; // r9
  int v20; // eax
  __int64 v21; // r9
  int v22; // eax

  v6 = CSslGlobals::m_ProtEnabled;
  if ( CSslGlobals::m_bFipsMode )
    v6 = CSslGlobals::m_ProtEnabled & 0xBFFFFFCF;
  *((_DWORD *)this + 38) = v6;
  v10 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, v6);
    v10 = WPP_GLOBAL_Control;
  }
  ProtocolsWithCipherSuitesEnabled = CCipherMill::GetProtocolsWithCipherSuitesEnabled(v10, *((_BYTE *)this + 172));
  v13 = ProtocolsWithCipherSuitesEnabled;
  if ( (CCipherMill **)v12 != &WPP_GLOBAL_Control && (*(_BYTE *)(v12 + 28) & 4) != 0 )
    WPP_SF_D(
      *(_QWORD *)(v12 + 16),
      12i64,
      &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids,
      ProtocolsWithCipherSuitesEnabled);
  v14 = v13 & *((_DWORD *)this + 38);
  v15 = a4 & 0x1000000;
  if ( v15 )
    v14 &= 0xF0000u;
  if ( a3 )
  {
    v17 = a3 & v14;
  }
  else
  {
    v16 = *((_QWORD *)this + 25);
    v17 = v14 & ~CSslGlobals::m_ProtDisabledByDefault;
    v18 = *((unsigned int *)this + 49);
    *((_DWORD *)this + 38) = v17;
    v19 = v16 + 40 * v18;
    if ( v16 < v19 )
    {
      do
      {
        if ( !*(_DWORD *)v16 )
        {
          v20 = *(_DWORD *)(v16 + 16);
          if ( v20 )
          {
            if ( (*(_BYTE *)(v16 + 32) & 1) == 0 )
              *((_DWORD *)this + 38) &= ~v20;
          }
        }
        v16 += 40i64;
      }
      while ( v16 < v19 );
      v17 = *((_DWORD *)this + 38);
    }
  }
  if ( a2 >= 5 )
  {
    if ( !v15 )
      v17 &= 0x3FF0u;
  }
  else
  {
    v17 &= 0xFFFFCFFF;
  }
  if ( (v17 & 0x3000) != 0 )
    v17 &= 0xFFFFFFCF;
  v21 = v17 & ((a5 & 0x40051555) != 0 ? 1074074965 : -2146817366);
  *((_DWORD *)this + 38) = v21;
  v22 = v17 & ((a5 & 0x40051555) != 0 ? 1074074965 : -2146817366);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids, v21);
    v22 = *((_DWORD *)this + 38);
  }
  return v22 == 0 ? 0x80090331 : 0;
}
// 1800101A3: variable 'v12' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800919F8: using guessed type unsigned int CSslGlobals::m_ProtEnabled;
// 1800919FC: using guessed type unsigned int CSslGlobals::m_ProtDisabledByDefault;
// 180092F18: using guessed type int CSslGlobals::m_bFipsMode;

//----- (00000001800102DC) ----------------------------------------------------
__int64 __fastcall IsRemoteCertificateBlacklisted(
        struct _TLS_PARAMETERS *a1,
        unsigned int a2,
        const struct _CERT_CONTEXT *a3,
        struct _PUBLICKEY *a4,
        struct _SecPkgContext_ApplicationProtocol *a5,
        struct CCipherSuiteInfo *a6,
        unsigned __int8 a7)
{
  unsigned int v7; // ebx
  struct CEccCurveInfo *v11; // r13
  PCERT_INFO pCertInfo; // rdx
  unsigned int PublicKeyLength; // r12d
  int v15; // edi
  DWORD CngHashAndSignatureString; // eax
  __int64 v17; // r9
  unsigned int EccCurveType; // eax
  CCipherMill *v20; // rcx
  unsigned int CurveInfo; // eax
  ULONG v22; // eax
  CCipherMill *v23; // rcx
  __int64 v24; // rdx
  DWORD v25; // [rsp+20h] [rbp-E0h]
  bool v26; // [rsp+60h] [rbp-A0h]
  unsigned int v27; // [rsp+64h] [rbp-9Ch] BYREF
  unsigned int v28; // [rsp+68h] [rbp-98h]
  struct CEccCurveInfo *v29; // [rsp+70h] [rbp-90h] BYREF
  struct _UNICODE_STRING *v30; // [rsp+78h] [rbp-88h]
  struct _UNICODE_STRING v31; // [rsp+80h] [rbp-80h] BYREF
  struct _TLS_PARAMETERS *v32; // [rsp+90h] [rbp-70h]
  unsigned __int16 v33[64]; // [rsp+A0h] [rbp-60h] BYREF
  unsigned __int16 v34[64]; // [rsp+120h] [rbp+20h] BYREF
  char v35[512]; // [rsp+1A0h] [rbp+A0h] BYREF

  v7 = 0;
  v28 = a2;
  v32 = a1;
  v27 = 0;
  v29 = 0i64;
  v26 = 0;
  v11 = 0i64;
  memset_0(v34, 0, sizeof(v34));
  memset_0(v33, 0, sizeof(v33));
  memset_0(v35, 0, 0x1FEui64);
  *(_DWORD *)&v31.Length = 33423360;
  v31.Buffer = (PWSTR)v35;
  v30 = 0i64;
  if ( !a1 || !a2 || !a3 || !a6 || !a4 || !*(_QWORD *)a4 || !a3->pCertInfo )
    return 2148074244i64;
  pCertInfo = a3->pCertInfo;
  if ( a5
    && a5->ProtoNegoStatus == SecApplicationProtocolNegotiationStatus_Success
    && a5->ProtoNegoExt == SecApplicationProtocolNegotiationExt_ALPN )
  {
    v22 = CreateUnicodeStringFromAlpnId(a5->ProtocolId, a5->ProtocolIdSize, 1, &v31);
    v17 = v22;
    if ( v22 )
    {
      v23 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074244i64;
      v24 = 16i64;
      goto LABEL_38;
    }
    pCertInfo = a3->pCertInfo;
    v30 = &v31;
  }
  PublicKeyLength = CertGetPublicKeyLength(1u, &pCertInfo->SubjectPublicKeyInfo);
  v15 = *(_DWORD *)(*(_QWORD *)a4 + 4i64);
  if ( !PublicKeyLength || !v15 )
    return 2148074244i64;
  if ( v15 == 8707 )
  {
    EccCurveType = CertGetEccCurveType((__int64)a3, &v27);
    v17 = EccCurveType;
    if ( EccCurveType )
    {
      v23 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074244i64;
      v24 = 17i64;
      goto LABEL_38;
    }
    CurveInfo = CCipherMill::GetCurveInfo(v20, v27, &v29);
    v17 = CurveInfo;
    if ( CurveInfo )
    {
      v23 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074244i64;
      v24 = 18i64;
      goto LABEL_38;
    }
    v11 = v29;
  }
  v27 = 64;
  CngHashAndSignatureString = GetCngHashAndSignatureString(a3, v33, &v27, (char *)v34, v25);
  v17 = CngHashAndSignatureString;
  if ( CngHashAndSignatureString )
  {
    v23 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074244i64;
    v24 = 19i64;
LABEL_38:
    WPP_SF_D(*((_QWORD *)v23 + 2), v24, &WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids, v17);
    return 2148074244i64;
  }
  if ( !a7 && v15 == 41984 )
    v26 = *((_DWORD *)a6 + 8) == 41984;
  if ( IsCertificateBlacklisted(v32, v28, v15, PublicKeyLength, v11, v26, 0, v34, v33, v30, 1) )
    return (unsigned int)-2146893007;
  return v7;
}
// 18001042C: variable 'v25' is possibly undefined
// 1800104EC: variable 'v20' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018001050C) ----------------------------------------------------
DWORD __fastcall GetCngHashAndSignatureString(
        const struct _CERT_CONTEXT *a1,
        unsigned __int16 *a2,
        unsigned int *a3,
        char *a4,
        DWORD a5)
{
  unsigned int v8; // ebx
  bool v9; // zf
  DWORD v10; // edx
  unsigned __int16 *v11; // rax
  __int64 v13; // rbx

  v8 = 0;
  if ( !a1 || !a2 || !a3 || 2 * (unsigned __int64)*a3 > 0xFFFFFFFF )
    return 87;
  a5 = 2 * *a3;
  if ( CertGetCertificateContextProperty(a1, 0x59u, a2, &a5) )
  {
    v9 = a5 >> 1 == 0;
    v10 = a5 >> 1;
    a2[(a5 >> 1) - 1] = 0;
    if ( v9 )
    {
LABEL_10:
      if ( v8 == v10 )
        return 1359;
    }
    else
    {
      v11 = a2;
      while ( *v11 != 47 )
      {
        ++v8;
        ++v11;
        if ( v8 >= v10 )
          goto LABEL_10;
      }
      *a3 = v8;
      a2[v8] = 0;
    }
    v13 = v8 + 1;
    if ( (_DWORD)v13 != v10
      && (!a4 || v10 - (unsigned int)v13 >= 0x40 || !(unsigned int)StringCchCopyW(a4, 64i64, (char *)&a2[v13])) )
    {
      return 0;
    }
    return 1359;
  }
  *a3 = a5 >> 1;
  return GetLastError();
}

//----- (0000000180010610) ----------------------------------------------------
__int64 __fastcall StringCchCopyW(char *a1, __int64 a2, char *a3)
{
  __int64 v3; // r9
  signed __int64 v4; // r10
  unsigned __int16 v5; // ax
  unsigned __int16 *v6; // rax
  __int64 result; // rax

  if ( (unsigned __int64)(a2 - 1) > 0x7FFFFFFE )
  {
    result = 2147942487i64;
    if ( a2 )
      *(_WORD *)a1 = 0;
  }
  else
  {
    v3 = 2147483646 - a2;
    v4 = a3 - a1;
    do
    {
      if ( !(v3 + a2) )
        break;
      v5 = *(_WORD *)&a1[v4];
      if ( !v5 )
        break;
      *(_WORD *)a1 = v5;
      a1 += 2;
      --a2;
    }
    while ( a2 );
    v6 = (unsigned __int16 *)(a1 - 2);
    if ( a2 )
      v6 = (unsigned __int16 *)a1;
    *v6 = 0;
    return a2 == 0 ? 0x8007007A : 0;
  }
  return result;
}

//----- (0000000180010674) ----------------------------------------------------
__int64 __fastcall CSslCredManager::CreateCredentialGroup(
        CSslCredManager *this,
        struct CCredentialGroup **a2,
        __int64 a3,
        struct _LUID *a4,
        void *a5,
        struct LSA_SCHANNEL_CRED *a6,
        unsigned __int16 *a7)
{
  unsigned int v9; // r13d
  CCredentialGroup *v11; // rax
  CCredentialGroup *v12; // rax
  struct CCredentialGroup *v13; // rdi
  unsigned int v14; // ebx
  CSslCredManager **v15; // rdx
  CSslCredManager *v16; // rax
  __int64 v18; // r8
  unsigned int v19; // ebp
  CCipherMill *v20; // rcx
  unsigned int v21; // edi
  __int64 v22; // rsi
  int v23; // r9d
  int v24; // r9d
  int v25; // r9d
  CCipherMill *v26; // rcx
  __int64 v27; // r9
  __int64 v28; // r9
  struct LSA_SCHANNEL_CRED *v29; // [rsp+20h] [rbp-38h]

  v9 = a3;
  if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
    goto LABEL_2;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_d(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x10u,
        (__int64)&WPP_d7209deee65a328fe195e0fa91b71573_Traceguids,
        *(_DWORD *)a6);
  }
  DbgDumpSubCreds(*((struct LSA_SCHANNEL_SUB_CRED **)a6 + 1), *((_DWORD *)a6 + 1), a3);
  v19 = *((_DWORD *)a6 + 14);
  if ( v19 && *((_QWORD *)a6 + 8) )
  {
    v20 = WPP_GLOBAL_Control;
    v21 = 0;
    v22 = 0i64;
    do
    {
      if ( v20 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v20 + 28) & 4) != 0 )
      {
        LODWORD(v29) = *(_DWORD *)(v22 + *((_QWORD *)a6 + 8));
        WPP_SF_dD(*((_QWORD *)v20 + 2), 0x11u, v18, v21, v29);
        v20 = WPP_GLOBAL_Control;
      }
      ++v21;
      v22 += 4i64;
    }
    while ( v21 < v19 );
  }
  else
  {
    v20 = WPP_GLOBAL_Control;
  }
  if ( v20 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v20 + 28) & 4) != 0 )
  {
    WPP_SF_D(*((_QWORD *)v20 + 2), 18i64, &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids, *((unsigned int *)a6 + 18));
    v20 = WPP_GLOBAL_Control;
  }
  v23 = *((_DWORD *)a6 + 19);
  if ( v23 && v20 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v20 + 28) & 4) != 0 )
  {
    WPP_SF_d(*((_QWORD *)v20 + 2), 0x13u, (__int64)&WPP_d7209deee65a328fe195e0fa91b71573_Traceguids, v23);
    v20 = WPP_GLOBAL_Control;
  }
  v24 = *((_DWORD *)a6 + 20);
  if ( v24 && v20 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v20 + 28) & 4) != 0 )
    WPP_SF_d(*((_QWORD *)v20 + 2), 0x14u, (__int64)&WPP_d7209deee65a328fe195e0fa91b71573_Traceguids, v24);
  DbgDumpTlsParams(*((struct _TLS_PARAMETERS **)a6 + 13), *((unsigned int *)a6 + 24), v18);
  v25 = *((_DWORD *)a6 + 21);
  if ( v25 )
  {
    v26 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
      goto LABEL_37;
    WPP_SF_d(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x15u, (__int64)&WPP_d7209deee65a328fe195e0fa91b71573_Traceguids, v25);
  }
  v26 = WPP_GLOBAL_Control;
LABEL_37:
  v27 = *((unsigned int *)a6 + 22);
  if ( (_DWORD)v27 && v26 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v26 + 28) & 4) != 0 )
  {
    WPP_SF_D(*((_QWORD *)v26 + 2), 22i64, &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids, v27);
    v26 = WPP_GLOBAL_Control;
  }
  v28 = *((unsigned int *)a6 + 23);
  if ( (_DWORD)v28 && v26 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v26 + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)v26 + 2), 23i64, &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids, v28);
LABEL_2:
  v11 = (CCredentialGroup *)SPExternalAlloc(0x388u);
  if ( v11 && (v12 = CCredentialGroup::CCredentialGroup(v11), (v13 = v12) != 0i64) )
  {
    v14 = CCredentialGroup::InitializeCredentialGroup(v12, v9, a4, (__int64)a5, a6, a7);
    if ( v14 )
    {
      (*(void (__fastcall **)(struct CCredentialGroup *, __int64))(*(_QWORD *)v13 + 8i64))(v13, 1i64);
    }
    else
    {
      RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
      v15 = (CSslCredManager **)*((_QWORD *)this + 7);
      v16 = (struct CCredentialGroup *)((char *)v13 + 8);
      if ( *v15 != (CSslCredManager *)((char *)this + 48) )
        __fastfail(3u);
      *(_QWORD *)v16 = (char *)this + 48;
      *((_QWORD *)v13 + 2) = v15;
      *v15 = v16;
      *((_QWORD *)this + 7) = v16;
      RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
      _InterlockedIncrement((volatile signed __int32 *)v13 + 6);
      *a2 = v13;
    }
  }
  else
  {
    return 14;
  }
  return v14;
}
// 180039487: variable 'a3' is possibly undefined
// 1800394CE: variable 'v18' is possibly undefined
// 1800394CE: variable 'v29' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180010780) ----------------------------------------------------
CCredentialGroup *__fastcall CCredentialGroup::CCredentialGroup(CCredentialGroup *this)
{
  CCredentialGroup *result; // rax

  *(_QWORD *)this = &CCredentialGroup::`vftable';
  *((_DWORD *)this + 36) = 0;
  *(_QWORD *)((char *)this + 156) = 0i64;
  *((_WORD *)this + 86) = 0;
  *((_DWORD *)this + 44) = 0;
  *((_QWORD *)this + 23) = 0i64;
  *((_QWORD *)this + 24) = 0i64;
  *((_QWORD *)this + 25) = 0i64;
  *(_QWORD *)((char *)this + 212) = 0i64;
  memset_0((char *)this + 220, 0, 0x204ui64);
  *((_QWORD *)this + 94) = 0i64;
  *((_QWORD *)this + 5) = (char *)this + 32;
  *((_QWORD *)this + 4) = (char *)this + 32;
  result = this;
  *((_QWORD *)this + 96) = 0i64;
  *((_QWORD *)this + 97) = 0i64;
  *((_QWORD *)this + 98) = 0i64;
  *((_QWORD *)this + 99) = 0i64;
  *((_QWORD *)this + 102) = 0i64;
  *((_QWORD *)this + 103) = 0i64;
  *((_QWORD *)this + 104) = 0i64;
  *((_QWORD *)this + 105) = 0i64;
  *((_QWORD *)this + 106) = 0i64;
  *((_QWORD *)this + 108) = 0i64;
  *((_QWORD *)this + 109) = 0i64;
  *((_QWORD *)this + 110) = 0i64;
  *((_QWORD *)this + 111) = 0i64;
  *((_DWORD *)this + 224) = 0;
  *((_BYTE *)this + 900) = 0;
  return result;
}
// 18007D0D8: using guessed type void *CCredentialGroup::`vftable';

//----- (0000000180010874) ----------------------------------------------------
__int64 __fastcall SpCommonAcquireCredentialsHandle(
        struct _UNICODE_STRING *a1,
        unsigned int a2,
        struct _LUID *a3,
        struct _SCHANNEL_CRED *a4,
        unsigned __int64 *a5,
        union _LARGE_INTEGER *a6)
{
  int ProcessImageName; // eax
  __int64 v10; // rdx
  __int64 v11; // r8
  __int64 v12; // r9
  CCipherMill *v13; // rcx
  int v14; // r12d
  char v15; // r15
  NTSTATUS v16; // eax
  CCipherMill *v17; // rax
  signed int v18; // eax
  int v19; // ecx
  char v20; // r15
  bool v21; // zf
  unsigned int v22; // ebx
  unsigned int DefaultMachineCred; // ebx
  union _LARGE_INTEGER *v24; // r14
  CCredentialGroup **v25; // rsi
  int v26; // eax
  unsigned int v27; // ecx
  unsigned int v28; // ebx
  char v29; // al
  unsigned int cbBuffer; // edx
  CCredentialGroup *v32; // rcx
  unsigned int updated; // ebx
  NTSTATUS v34; // ecx
  unsigned __int16 v35; // dx
  _DWORD *v36; // rax
  struct _SCHANNEL_CRED **v37; // rax
  signed int v38; // eax
  void *pvBuffer; // rcx
  __int64 DesiredAccess; // [rsp+20h] [rbp-E0h]
  char v41; // [rsp+41h] [rbp-BFh]
  unsigned int v42; // [rsp+50h] [rbp-B0h] BYREF
  struct _SecBuffer v43; // [rsp+58h] [rbp-A8h] BYREF
  void *TargetHandle; // [rsp+68h] [rbp-98h] BYREF
  struct _SecBuffer v45; // [rsp+70h] [rbp-90h] BYREF
  CCredentialGroup *v46; // [rsp+80h] [rbp-80h] BYREF
  unsigned int v47; // [rsp+88h] [rbp-78h] BYREF
  unsigned int v48; // [rsp+8Ch] [rbp-74h]
  struct _LUID v49; // [rsp+90h] [rbp-70h] BYREF
  __int64 v50; // [rsp+98h] [rbp-68h] BYREF
  struct _SECPKG_CALL_INFO v51; // [rsp+A0h] [rbp-60h] BYREF
  struct _LUID v52; // [rsp+B8h] [rbp-48h] BYREF
  char v53; // [rsp+C8h] [rbp-38h]
  int v54; // [rsp+CCh] [rbp-34h]
  HANDLE SourceHandle; // [rsp+D0h] [rbp-30h]
  int v56[18]; // [rsp+E0h] [rbp-20h] BYREF
  int v57; // [rsp+128h] [rbp+28h]
  unsigned __int16 v58[264]; // [rsp+150h] [rbp+50h] BYREF

  v48 = a2;
  *(_QWORD *)&v43.cbBuffer = a5;
  v46 = 0i64;
  memset_0(v56, 0, 0x70ui64);
  TargetHandle = 0i64;
  v42 = 0;
  v45 = 0i64;
  v50 = 0i64;
  v41 = 0;
  if ( (unsigned int)SchannelInit(0)
    && (*(unsigned __int8 (__fastcall **)(struct _SECPKG_CALL_INFO *))(LsaTable + 192))(&v51) )
  {
    memset_0(v58, 0, 0x208ui64);
    ProcessImageName = GetProcessImageName(v58, &v51);
    v12 = (unsigned int)ProcessImageName;
    if ( ProcessImageName < 0 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_DD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x32u,
          (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
          ProcessImageName,
          v51.ProcessId);
    }
    else
    {
      v13 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            51i64,
            &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
            v51.ProcessId);
          v13 = WPP_GLOBAL_Control;
        }
        if ( v13 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v13 + 28) & 4) != 0 )
          WPP_SF_S(*((_QWORD *)v13 + 2), 0x34u, (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, v58);
      }
    }
    v14 = v51.Attributes & 0x40;
    v15 = v51.Attributes & 1;
    if ( (v51.Attributes & 0x11) == 0 )
    {
      v41 = 1;
      if ( (*(int (__fastcall **)(unsigned int *, _QWORD, _QWORD, struct _SecBuffer *, _QWORD))(LsaTable + 488))(
             &v42,
             0i64,
             0i64,
             &v45,
             0i64) < 0 )
        goto LABEL_61;
      if ( v42 == 4 )
      {
        v25 = *(CCredentialGroup ***)&v43.cbBuffer;
        cbBuffer = v45.cbBuffer;
        v43.BufferType = 1;
        v32 = *(CCredentialGroup **)v45.pvBuffer;
        v43.pvBuffer = (char *)v45.pvBuffer + 8;
        v43.cbBuffer = v45.cbBuffer - 8;
        *v25 = v32;
        v46 = v32;
        if ( v32 )
        {
          if ( cbBuffer != 8 )
          {
            v24 = a6;
            updated = UpdatePrivateKeysForCreds(v32, &v43, v14 != 0);
            CCredentialGroup::GetCredentialExpirationTime(v46, a6);
            v28 = TranslateToSecurityStatus(updated);
LABEL_124:
            v20 = v41;
            goto LABEL_45;
          }
          v28 = -2146893043;
        }
        else
        {
          v28 = -2146893052;
        }
LABEL_123:
        v24 = a6;
        goto LABEL_124;
      }
    }
    if ( (*(int (__fastcall **)(struct _LUID *, __int64, __int64, __int64))(LsaTable + 128))(&v52, v10, v11, v12) >= 0 )
    {
      if ( a3 && (a3->LowPart || a3->HighPart) )
      {
        if ( !v53 )
        {
          v34 = -1073741727;
LABEL_120:
          v18 = RtlNtStatusToDosError(v34);
          goto LABEL_121;
        }
        v49 = *a3;
        v16 = (*(__int64 (__fastcall **)(struct _LUID *, void **))(LsaTable + 368))(a3, &TargetHandle);
        if ( v16 >= 0 )
        {
          v17 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          {
            goto LABEL_21;
          }
          v35 = 53;
          goto LABEL_75;
        }
      }
      else
      {
        if ( (char *)SourceHandle - 1 > (char *)0xFFFFFFFFFFFFFFFDi64 )
        {
          v34 = -1073741670;
          goto LABEL_120;
        }
        v49 = v52;
        v16 = NtDuplicateObject(
                (HANDLE)0xFFFFFFFFFFFFFFFFi64,
                SourceHandle,
                (HANDLE)0xFFFFFFFFFFFFFFFFi64,
                &TargetHandle,
                0,
                0,
                2u);
        if ( v16 >= 0 )
        {
          v17 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          {
            goto LABEL_21;
          }
          v35 = 54;
LABEL_75:
          WPP_SF_q(*((_QWORD *)v17 + 2), v35, (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, TargetHandle);
LABEL_21:
          if ( v54 > 1 )
          {
            v56[0] = 4;
            if ( !a4 )
            {
LABEL_34:
              v20 = v41;
LABEL_35:
              if ( (v57 & 0xF0000) != 0 && (v57 & 0xFFF0FFFF) != 0 )
              {
                v28 = -2146893007;
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
                {
                  LODWORD(DesiredAccess) = -2146893007;
                  WPP_SF_Dd(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    0x3Au,
                    (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                    -2146893007,
                    DesiredAccess);
                }
                return v28;
              }
              v21 = a4 == 0i64;
              v22 = v48;
              if ( v21 && (v48 & 0x40051555) != 0 )
              {
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
                {
                  WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 59i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
                }
                DefaultMachineCred = FindDefaultMachineCred(&v46, v22, &v49, TargetHandle, v51.ProcessId, v58);
              }
              else
              {
                DefaultMachineCred = CSslCredManager::CreateCredentialGroup(
                                       CSslCredManager::m_pCredManager,
                                       &v46,
                                       v48,
                                       &v49,
                                       TargetHandle,
                                       (struct LSA_SCHANNEL_CRED *)v56,
                                       v58);
                FreeSchannelCred((struct LSA_SCHANNEL_CRED *)v56, 0);
              }
              v24 = a6;
              if ( DefaultMachineCred )
              {
                v25 = *(CCredentialGroup ***)&v43.cbBuffer;
                goto LABEL_43;
              }
              CCredentialGroup::GetCredentialExpirationTime(v46, a6);
              v25 = *(CCredentialGroup ***)&v43.cbBuffer;
              **(_QWORD **)&v43.cbBuffer = v46;
              if ( v20 )
              {
                if ( !LsaTable )
                {
                  v28 = -2146893052;
                  goto LABEL_45;
                }
                v26 = (*(__int64 (__fastcall **)(unsigned int *, __int64 *, _QWORD, struct _SecBuffer *, _QWORD))(LsaTable + 488))(
                        &v42,
                        &v50,
                        0i64,
                        &v45,
                        0i64);
                DefaultMachineCred = v26;
                if ( v26 >= 0 )
                {
                  if ( v42 != 4 )
                    goto LABEL_43;
                  *(_QWORD *)v45.pvBuffer = *v25;
                  LOBYTE(DesiredAccess) = 1;
                  v26 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, struct _SecBuffer *, _DWORD))(LsaTable + 496))(
                          v42,
                          v50,
                          4i64,
                          &v45,
                          DesiredAccess);
                  if ( v26 >= 0 )
                  {
                    v28 = -2146893055;
                    v29 = 1;
                    goto LABEL_46;
                  }
                }
                v27 = v26;
                goto LABEL_44;
              }
LABEL_43:
              v27 = DefaultMachineCred;
LABEL_44:
              v28 = TranslateToSecurityStatus(v27);
LABEL_45:
              v29 = 0;
LABEL_46:
              if ( !TargetHandle || v29 )
              {
                if ( !v28 )
                  goto LABEL_49;
              }
              else
              {
                if ( !v28 )
                {
LABEL_49:
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v28
                     || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
                  {
                    LODWORD(DesiredAccess) = v28;
                    WPP_SF_DD(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      0x3Du,
                      (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                      v28,
                      DesiredAccess);
                  }
                  return v28;
                }
                NtClose(TargetHandle);
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
                {
                  WPP_SF_q(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    0x3Cu,
                    (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                    TargetHandle);
                }
              }
              if ( v28 != -2146893055 )
              {
                pvBuffer = 0i64;
                if ( !v20 )
                  pvBuffer = v45.pvBuffer;
                CleanupAppModeInfo(pvBuffer);
                if ( v46 )
                  CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, v46);
                if ( v25 )
                  *v25 = 0i64;
                if ( v24 )
                  v24->QuadPart = 0i64;
              }
              goto LABEL_49;
            }
            if ( v15 )
            {
              if ( a4->dwVersion == 4 )
              {
                v18 = MapKernelAuthDataV4(a4, a1, TargetHandle, (struct LSA_SCHANNEL_CRED *)v56);
              }
              else
              {
                if ( a4->dwVersion != 5 )
                  goto LABEL_34;
                v18 = MapKernelAuthDataV5(a4, a1, TargetHandle, (struct LSA_SCHANNEL_CRED *)v56);
              }
              if ( v18 >= 0 )
                goto LABEL_34;
            }
            else
            {
              v18 = (*(__int64 (__fastcall **)(_QWORD, __int64, unsigned int *, struct _SCHANNEL_CRED *))(LsaTable + 80))(
                      0i64,
                      4i64,
                      &v47,
                      a4);
              if ( v18 >= 0 )
              {
                v19 = v47;
                if ( v47 < 3 )
                  goto LABEL_103;
                if ( v47 <= 5 )
                {
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
                  {
                    WPP_SF_d(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      0x38u,
                      (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                      v47);
                    v19 = v47;
                  }
                  if ( v14 )
                    v18 = SpWow64MapVersion3Certificate(a4, v19, &v45, (struct LSA_SCHANNEL_CRED *)v56);
                  else
                    v18 = SpMapVersion3Certificate(a4, v19, &v45, (struct LSA_SCHANNEL_CRED *)v56);
                  if ( v18 != 590610 )
                  {
                    if ( v18 >= 0 )
                      goto LABEL_34;
                    goto LABEL_121;
                  }
                  v20 = v41;
                  if ( !v41 )
                    goto LABEL_35;
                  if ( !LsaTable )
                  {
                    v28 = -2146893052;
LABEL_93:
                    v25 = *(CCredentialGroup ***)&v43.cbBuffer;
                    v24 = a6;
                    goto LABEL_45;
                  }
                  v42 = 10;
                  if ( v14 )
                  {
                    v45.cbBuffer = 4;
                    v36 = (_DWORD *)(*(__int64 (__fastcall **)(__int64))(LsaTable + 384))(4i64);
                    v45.pvBuffer = v36;
                    if ( v36 )
                    {
                      *v36 = (_DWORD)a4;
                      goto LABEL_100;
                    }
                  }
                  else
                  {
                    v45.cbBuffer = 8;
                    v37 = (struct _SCHANNEL_CRED **)(*(__int64 (__fastcall **)(__int64))(LsaTable + 384))(8i64);
                    v45.pvBuffer = v37;
                    if ( v37 )
                    {
                      *v37 = a4;
LABEL_100:
                      v45.BufferType = 1;
                      LOBYTE(DesiredAccess) = 1;
                      v38 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, struct _SecBuffer *, _DWORD))(LsaTable + 496))(
                              v42,
                              0i64,
                              8i64,
                              &v45,
                              DesiredAccess);
                      if ( v38 >= 0 )
                        v28 = -2146893055;
                      else
                        v28 = TranslateToSecurityStatus(v38);
                      goto LABEL_93;
                    }
                  }
                  v28 = -2146893056;
                  goto LABEL_93;
                }
                if ( v47 != 512 )
                {
LABEL_103:
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                  {
                    WPP_SF_d(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      0x39u,
                      (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                      v47);
                  }
                  v28 = -2146893043;
                  goto LABEL_122;
                }
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
                {
                  WPP_SF_d(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    0x37u,
                    (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                    512);
                }
                v18 = SpMapAuthIdentity(a4, (struct LSA_SCHANNEL_CRED *)v56, (__int64)TargetHandle);
                if ( !v18 )
                  goto LABEL_34;
              }
            }
LABEL_121:
            v28 = TranslateToSecurityStatus(v18);
            goto LABEL_122;
          }
          v28 = -2146893042;
LABEL_122:
          v25 = *(CCredentialGroup ***)&v43.cbBuffer;
          goto LABEL_123;
        }
      }
      v34 = v16;
      goto LABEL_120;
    }
LABEL_61:
    v28 = -2146893052;
    goto LABEL_122;
  }
  return 2148074244i64;
}
// 180010A07: variable 'v10' is possibly undefined
// 180010A07: variable 'v11' is possibly undefined
// 180010A07: variable 'v12' is possibly undefined
// 18003998D: variable 'DesiredAccess' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180010CB0) ----------------------------------------------------
void __fastcall CCredentialGroup::GetCredentialExpirationTime(CCredentialGroup *this, union _LARGE_INTEGER *a2)
{
  struct _RTL_RESOURCE *v4; // rsi
  _QWORD *v5; // rdi
  _QWORD *v6; // rcx
  __int64 v7; // rax

  if ( a2 )
  {
    a2->QuadPart = 0x7FFFFF36D5969FFFi64;
    if ( *((_DWORD *)this + 7) )
    {
      v4 = (struct _RTL_RESOURCE *)((char *)this + 48);
      RtlAcquireResourceShared((PRTL_RESOURCE)((char *)this + 48), 1u);
      v5 = (_QWORD *)((char *)this + 32);
      v6 = (_QWORD *)*v5;
      while ( v6 != v5 )
      {
        v7 = v6[3];
        v6 = (_QWORD *)*v6;
        if ( v7 )
        {
          *a2 = *(union _LARGE_INTEGER *)(*(_QWORD *)(v7 + 24) + 72i64);
          break;
        }
      }
      RtlReleaseResource(v4);
    }
  }
}

//----- (0000000180010CF8) ----------------------------------------------------
void __fastcall FreeSchannelCred(struct LSA_SCHANNEL_CRED *a1, char a2)
{
  void *v4; // rcx
  void *v5; // rcx
  struct _TLS_PARAMETERS *v6; // rcx
  unsigned int i; // ebp
  __int64 v8; // rsi
  _WORD *v9; // rdi
  __int64 v10; // rcx
  void *v11; // rcx
  void *v12; // rcx
  void *v13; // rcx
  void *v14; // rcx

  if ( *((_QWORD *)a1 + 1) )
  {
    for ( i = 0; i < *((_DWORD *)a1 + 1); *(_QWORD *)(v8 + 48) = 0i64 )
    {
      v8 = *((_QWORD *)a1 + 1) + 56i64 * i;
      if ( *(_QWORD *)v8 )
        CertFreeCertificateContext(*(PCCERT_CONTEXT *)v8);
      v9 = *(_WORD **)(v8 + 8);
      if ( v9 )
      {
        v10 = -1i64;
        do
          ++v10;
        while ( v9[v10] );
        memset(v9, 0, 2 * v10);
        SPExternalFree(*(void **)(v8 + 8));
      }
      *(_OWORD *)v8 = 0i64;
      ++i;
      *(_OWORD *)(v8 + 16) = 0i64;
      *(_OWORD *)(v8 + 32) = 0i64;
    }
    SPExternalFree(*((void **)a1 + 1));
    *((_QWORD *)a1 + 1) = 0i64;
  }
  v4 = (void *)*((_QWORD *)a1 + 2);
  if ( v4 )
  {
    CertCloseStore(v4, 0);
    *((_QWORD *)a1 + 2) = 0i64;
  }
  v5 = (void *)*((_QWORD *)a1 + 8);
  if ( v5 )
  {
    SPExternalFree(v5);
    *((_QWORD *)a1 + 8) = 0i64;
  }
  v6 = (struct _TLS_PARAMETERS *)*((_QWORD *)a1 + 13);
  if ( v6 )
  {
    FreeTlsParameters(v6, *((_DWORD *)a1 + 24));
    *((_QWORD *)a1 + 13) = 0i64;
    *((_DWORD *)a1 + 24) = 0;
  }
  if ( a2 )
  {
    v11 = (void *)*((_QWORD *)a1 + 3);
    if ( v11 )
      CryptObjectLocatorFree(v11);
    v12 = (void *)*((_QWORD *)a1 + 4);
    if ( v12 )
      CertCloseStore(v12, 0);
    v13 = (void *)*((_QWORD *)a1 + 5);
    if ( v13 )
      CryptObjectLocatorFree(v13);
    v14 = (void *)*((_QWORD *)a1 + 6);
    if ( v14 )
      CertCloseStore(v14, 0);
  }
  memset(a1, 0, 0x70ui64);
}
// 180098018: using guessed type void __stdcall CryptObjectLocatorFree(void *);

//----- (0000000180010D8C) ----------------------------------------------------
__int64 __fastcall GetProcessImageName(unsigned __int16 *a1, struct _SECPKG_CALL_INFO *a2)
{
  unsigned int v2; // ebx
  DWORD ProcessId; // r15d
  HANDLE v5; // r13
  int v6; // eax
  __int64 v7; // rsi
  int v9; // eax
  HLOCAL v10; // r15
  int v11; // eax
  void *v12; // rcx
  const wchar_t *v13; // r8
  DWORD LastError; // eax
  DWORD v15; // eax
  CCipherMill *v16; // rcx
  __int64 v17; // rdx
  CCipherMill *v18; // rcx
  DWORD dwSize; // [rsp+50h] [rbp-B0h] BYREF
  _QWORD v20[3]; // [rsp+58h] [rbp-A8h] BYREF
  DWORD v21; // [rsp+70h] [rbp-90h] BYREF
  HLOCAL hMem; // [rsp+78h] [rbp-88h]
  __int128 v23; // [rsp+80h] [rbp-80h]
  wchar_t String1[256]; // [rsp+A0h] [rbp-60h] BYREF
  wchar_t v25[264]; // [rsp+2A0h] [rbp+1A0h] BYREF
  WCHAR ExeName[264]; // [rsp+4B0h] [rbp+3B0h] BYREF

  v2 = 0;
  if ( !a2 || !a1 )
    return 87i64;
  ProcessId = a2->ProcessId;
  if ( (a2->Attributes & 0x2000) != 0 )
  {
    v13 = L"SYSTEM";
  }
  else
  {
    if ( ProcessId )
    {
      v5 = OpenProcess(0x1000u, 0, ProcessId);
      if ( !v5 )
      {
        LastError = GetLastError();
        v2 = LastError;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            10i64,
            &WPP_0dcdb9265ec2314c20be99baf3bba51a_Traceguids,
            LastError);
        return v2;
      }
      memset_0(ExeName, 0, 0x208ui64);
      dwSize = 260;
      if ( !QueryFullProcessImageNameW(v5, 0, ExeName, &dwSize) )
      {
        v15 = GetLastError();
        v2 = v15;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_0dcdb9265ec2314c20be99baf3bba51a_Traceguids, v15);
        goto LABEL_14;
      }
      memset_0(String1, 0, sizeof(String1));
      v6 = wsplitpath_s(ExeName, 0i64, 0i64, 0i64, 0i64, String1, 0x100ui64, 0i64, 0i64);
      if ( v6 )
      {
        v16 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) == 0 )
          goto LABEL_57;
        v17 = 12i64;
        goto LABEL_56;
      }
      memset_0(v25, 0, 0x208ui64);
      v7 = -1i64;
      if ( wcsnicmp(String1, L"svchost", 7ui64) )
        goto LABEL_9;
      LODWORD(v20[0]) = ProcessId;
      memset((char *)v20 + 4, 0, 20);
      HIDWORD(v20[0]) = NtCurrentTeb()->SubProcessTag;
      if ( (unsigned int)I_QueryTagInformation(0i64, 1i64, v20) )
      {
        v21 = ProcessId;
        hMem = 0i64;
        v9 = I_QueryTagInformation(0i64, 3i64, &v21);
        if ( v9 )
        {
          if ( v9 < 0
            && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
          {
            WPP_SF_D(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              13i64,
              &WPP_0dcdb9265ec2314c20be99baf3bba51a_Traceguids,
              (unsigned int)v9);
          }
          goto LABEL_9;
        }
        v10 = hMem;
        if ( !hMem )
        {
          do
LABEL_9:
            ++v7;
          while ( v25[v7] );
          if ( v7 )
            v6 = StringCchPrintfW(a1, 260i64, L"%ls[%ls]", String1, v25);
          else
            v6 = StringCchCopyW((char *)a1, 260i64, (char *)String1);
          if ( v6 == -2147024774 )
          {
            v18 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
              {
                WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &WPP_0dcdb9265ec2314c20be99baf3bba51a_Traceguids);
                v18 = WPP_GLOBAL_Control;
              }
              if ( v18 != (CCipherMill *)&WPP_GLOBAL_Control )
              {
                if ( (*((_BYTE *)v18 + 28) & 2) != 0 )
                {
                  WPP_SF_S(
                    *((_QWORD *)v18 + 2),
                    0xFu,
                    (__int64)&WPP_0dcdb9265ec2314c20be99baf3bba51a_Traceguids,
                    String1);
                  v18 = WPP_GLOBAL_Control;
                }
                if ( v18 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v18 + 28) & 2) != 0 )
                  WPP_SF_S(*((_QWORD *)v18 + 2), 0x10u, (__int64)&WPP_0dcdb9265ec2314c20be99baf3bba51a_Traceguids, v25);
              }
            }
            goto LABEL_14;
          }
          if ( v6 >= 0 )
          {
LABEL_14:
            CloseHandle(v5);
            return v2;
          }
          v16 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
LABEL_57:
            v2 = 1359;
            goto LABEL_14;
          }
          v17 = 17i64;
LABEL_56:
          WPP_SF_D(*((_QWORD *)v16 + 2), v17, &WPP_0dcdb9265ec2314c20be99baf3bba51a_Traceguids, (unsigned int)v6);
          goto LABEL_57;
        }
        if ( *(_DWORD *)hMem == 1 )
        {
          v11 = _mm_cvtsi128_si32(*(__m128i *)*((_QWORD *)hMem + 1));
          v23 = *(_OWORD *)*((_QWORD *)hMem + 1);
          if ( v11 == 1 )
          {
            if ( *((_QWORD *)&v23 + 1) )
              o_wcsncpy_s_0(v25, 260i64, *((_QWORD *)&v23 + 1), -1i64);
          }
        }
        v12 = v10;
      }
      else
      {
        if ( !v20[2] )
          goto LABEL_9;
        o_wcsncpy_s_0(v25, 260i64, v20[2], -1i64);
        v12 = (void *)v20[2];
      }
      LocalFree(v12);
      goto LABEL_9;
    }
    v13 = L"<UNKNOWN>";
  }
  o_wcsncpy_s_0(a1, 260i64, v13, -1i64);
  return 0i64;
}
// 180028D84: using guessed type __int64 __fastcall o_wcsncpy_s_0(_QWORD, _QWORD, _QWORD, _QWORD);
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080DC0: using guessed type __int64 __fastcall I_QueryTagInformation(_QWORD, _QWORD, _QWORD);
// 180085478: using guessed type wchar_t aSystem[7];
// 180085488: using guessed type wchar_t aUnknown_0[10];
// 180010D8C: using guessed type wchar_t var_460[264];

//----- (0000000180011040) ----------------------------------------------------
__int64 __fastcall SpUniAcquireCredentialsHandle(
        struct _UNICODE_STRING *a1,
        __int64 a2,
        struct _LUID *a3,
        struct _SCHANNEL_CRED *a4,
        int a5,
        int a6,
        unsigned __int64 *a7,
        union _LARGE_INTEGER *a8)
{
  unsigned int v10; // ebx
  CCipherMill *v12; // rcx
  char v13; // al
  unsigned int v14; // edx
  __int64 v15; // rdx
  unsigned int v16; // ebx
  CCipherMill *v17; // rcx
  unsigned __int64 *v19; // [rsp+20h] [rbp-68h]
  char v20[16]; // [rsp+30h] [rbp-58h] BYREF

  v10 = a2;
  v12 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 62i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
      v12 = WPP_GLOBAL_Control;
    }
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v12 + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)v12 + 2), 63i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
        v12 = WPP_GLOBAL_Control;
      }
      if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
      {
        WPP_SF_D(*((_QWORD *)v12 + 2), 64i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, v10);
        v12 = WPP_GLOBAL_Control;
      }
    }
  }
  v13 = Microsoft_Windows_Schannel_EventsEnableBits;
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
  {
    McGenEventWrite_EtwEventWriteTransfer((__int64)v12, (__int64)&AchStart, (__int64)a3, 1, (__int64)v20);
    v12 = WPP_GLOBAL_Control;
    v13 = Microsoft_Windows_Schannel_EventsEnableBits;
  }
  if ( (v10 & 1) != 0 )
  {
    v14 = 0x40000000;
LABEL_15:
    v16 = SpCommonAcquireCredentialsHandle(a1, v14, a3, a4, a7, a8);
    v17 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 66i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
    if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
      McTemplateU0d_EtwEventWriteTransfer((__int64)v17, v15, v16);
    return v16;
  }
  if ( (v10 & 2) != 0 )
  {
    v14 = 0x80000000;
    goto LABEL_15;
  }
  v16 = -2146893042;
  if ( (v13 & 1) != 0 )
  {
    McTemplateU0d_EtwEventWriteTransfer((__int64)v12, a2, 2148074254i64);
    v12 = WPP_GLOBAL_Control;
  }
  if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 5) != 0 )
  {
    LODWORD(v19) = -2146893042;
    WPP_SF_DD(*((_QWORD *)v12 + 2), 0x41u, (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids, -2146893042, v19);
  }
  return v16;
}
// 180039FDF: variable 'a3' is possibly undefined
// 18003A014: variable 'v17' is possibly undefined
// 18003A014: variable 'v15' is possibly undefined
// 18003A02B: variable 'a2' is possibly undefined
// 18003A06C: variable 'v19' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;
// 180011040: using guessed type char var_58[16];

//----- (0000000180011144) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::LogAppName(CSchannelTelemetryContext *this)
{
  __int64 v1; // r8

  if ( this && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
  {
    v1 = *((_QWORD *)this + 17);
    if ( v1 )
      o_wcsncpy_s_0((char *)this + 664, 256i64, v1 + 216, -1i64);
  }
}
// 180028D84: using guessed type __int64 __fastcall o_wcsncpy_s_0(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (000000018001118C) ----------------------------------------------------
__int64 __fastcall SpMapVersion3Certificate(void *a1, int a2, struct _SecBuffer *a3, struct LSA_SCHANNEL_CRED *a4)
{
  unsigned int v7; // ebx
  void *v8; // r12
  void *v9; // r15
  int v10; // r14d
  int v11; // ebx
  __int64 v12; // r15
  __int64 v13; // rax
  unsigned int v14; // r12d
  struct _SecBuffer *v15; // rbx
  unsigned int *pvBuffer; // rsi
  unsigned int cbBuffer; // r14d
  unsigned int *v18; // rbx
  int v19; // r13d
  int v20; // eax
  void *v21; // rcx
  unsigned int v23; // eax
  unsigned int v24; // eax
  _QWORD *v25; // rax
  HLOCAL v26; // rax
  unsigned int v27; // r15d
  __int64 v28; // r8
  __int64 v29; // rcx
  unsigned int *v30; // rdx
  __int64 ppvContext; // r9
  DWORD v32; // r8d
  int v33; // eax
  __int64 v34; // rcx
  int *v35; // r8
  HCERTSTORE v36; // r14
  const CERT_CONTEXT *i; // rdx
  DWORD v38; // eax
  const CERT_CONTEXT *v39; // rax
  const CERT_CONTEXT *v40; // rsi
  DWORD LastError; // eax
  __int64 v42; // rcx
  HCERTSTORE v43; // rax
  unsigned int v44; // ebx
  HLOCAL v45; // rax
  void *pvPara; // [rsp+28h] [rbp-A9h]
  HCERTSTORE hCertStore; // [rsp+48h] [rbp-89h]
  HLOCAL v48; // [rsp+50h] [rbp-81h]
  unsigned int v49; // [rsp+58h] [rbp-79h]
  struct _SecBuffer v50; // [rsp+60h] [rbp-71h] BYREF
  __int64 v51; // [rsp+70h] [rbp-61h]
  unsigned int v52; // [rsp+78h] [rbp-59h] BYREF
  int *v53; // [rsp+80h] [rbp-51h]
  char v54[4]; // [rsp+88h] [rbp-49h] BYREF
  unsigned int v55; // [rsp+8Ch] [rbp-45h]
  __int64 v56; // [rsp+90h] [rbp-41h]
  __int64 v57; // [rsp+98h] [rbp-39h]
  __int64 v58; // [rsp+A0h] [rbp-31h]
  unsigned int v59; // [rsp+B0h] [rbp-21h]
  __int64 v60; // [rsp+B8h] [rbp-19h]
  unsigned int v61; // [rsp+C0h] [rbp-11h]
  int v62; // [rsp+C4h] [rbp-Dh]
  struct _TLS_PARAMETERS *v63; // [rsp+C8h] [rbp-9h]
  __int64 v64; // [rsp+D0h] [rbp-1h]
  __int128 v65; // [rsp+D8h] [rbp+7h] BYREF
  __int64 v66; // [rsp+E8h] [rbp+17h]

  v48 = 0i64;
  hCertStore = 0i64;
  v7 = 80;
  v8 = 0i64;
  v9 = 0i64;
  memset_0(v54, 0, 0x50ui64);
  v65 = 0i64;
  v66 = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
  if ( !LsaTable )
    return 2148074333i64;
  if ( !(*(unsigned __int8 (__fastcall **)(__int128 *))(LsaTable + 192))(&v65) )
    return 2148074244i64;
  v10 = BYTE8(v65) & 0x11;
  if ( a2 == 3 )
  {
    v11 = (*(__int64 (__fastcall **)(_QWORD, __int64, char *, void *))(LsaTable + 80))(0i64, 72i64, v54, a1);
    if ( v11 < 0 )
      goto LABEL_26;
    v64 = 0i64;
  }
  else
  {
    if ( a2 != 4 )
      v7 = 72;
    v11 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, char *, void *))(LsaTable + 80))(0i64, v7, v54, a1);
    if ( v11 < 0 )
      goto LABEL_26;
  }
  memset_0((char *)a4 + 4, 0, 0x6Cui64);
  *(_DWORD *)a4 = a2;
  if ( a2 == 4 )
  {
    v12 = v56;
    v13 = v57;
    v14 = v55;
  }
  else
  {
    v12 = v57;
    v13 = v58;
    v14 = v56;
  }
  v51 = v13;
  if ( v14 > 0x64 )
  {
    v9 = 0i64;
    v11 = -2146893056;
    v8 = 0i64;
    goto LABEL_26;
  }
  v15 = a3;
  pvBuffer = (unsigned int *)a3->pvBuffer;
  if ( pvBuffer )
    goto LABEL_64;
  if ( v14 && v12 || (pvBuffer = 0i64, v13) )
  {
    if ( !v10 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
      v9 = 0i64;
      v11 = 590610;
      v8 = 0i64;
      goto LABEL_26;
    }
    v50.cbBuffer = 8;
    v50.BufferType = 1;
    v25 = SPExternalAlloc(8u);
    v50.pvBuffer = v25;
    if ( !v25 )
    {
      v11 = -2146893056;
LABEL_59:
      v9 = 0i64;
      v8 = 0i64;
      goto LABEL_26;
    }
    *v25 = a1;
    v11 = PerformApplicationCallback(10i64, 0i64, 0i64, &v50, a3, 1, 0, 1);
    if ( v50.pvBuffer )
      SPExternalFree(v50.pvBuffer);
    if ( v11 < 0 )
      goto LABEL_59;
    v15 = a3;
    pvBuffer = (unsigned int *)a3->pvBuffer;
    if ( !pvBuffer )
    {
      v11 = -2146893052;
      goto LABEL_59;
    }
LABEL_64:
    cbBuffer = v15->cbBuffer;
    goto LABEL_17;
  }
  cbBuffer = 0;
LABEL_17:
  v18 = pvBuffer;
  if ( v14 && v12 )
  {
    v48 = SPExternalAlloc(8 * v14);
    if ( !v48 )
    {
      v9 = 0i64;
      v11 = -2146893056;
      v8 = 0i64;
      goto LABEL_26;
    }
    v11 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, HLOCAL, __int64))(LsaTable + 80))(0i64, 8 * v14, v48, v12);
    if ( v11 < 0 )
      goto LABEL_72;
    *((_DWORD *)a4 + 1) = v14;
    v26 = SPExternalAlloc(56 * v14);
    *((_QWORD *)a4 + 1) = v26;
    if ( !v26 )
    {
      v11 = -2146893056;
LABEL_72:
      v9 = hCertStore;
LABEL_74:
      v8 = v48;
      goto LABEL_26;
    }
    hCertStore = CertOpenStore((LPCSTR)2, 0, 0i64, 4u, 0i64);
    v9 = hCertStore;
    if ( !hCertStore )
    {
      GetLastError();
      v11 = -2146893056;
      goto LABEL_74;
    }
    v27 = 0;
    v28 = 0i64;
    *(_QWORD *)&v50.cbBuffer = 0i64;
    v18 = pvBuffer;
    while ( 1 )
    {
      v29 = *v18;
      v30 = v18 + 1;
      cbBuffer += -4 - v29;
      v18 = (unsigned int *)((char *)v18 + v29 + 4);
      if ( !v30 )
        break;
      if ( (unsigned int)v29 < 0xC )
        break;
      ppvContext = v28 + *((_QWORD *)a4 + 1);
      *(_QWORD *)(ppvContext + 16) = *(_QWORD *)v30;
      v32 = v30[2];
      if ( (int)v29 - 12 < v32 )
        break;
      if ( !CertAddSerializedElementToStore(
              hCertStore,
              (const BYTE *)v30 + 12,
              v32,
              4u,
              0,
              2u,
              0i64,
              (const void **)ppvContext) )
        goto LABEL_99;
      v33 = HIDWORD(v60);
      if ( a2 == 4 )
        v33 = v64;
      if ( (v33 & 0x10000) != 0 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
        v34 = *v18;
        v35 = (int *)(v18 + 1);
        v18 = (unsigned int *)((char *)v18 + v34 + 4);
        v49 = -4 - v34 + cbBuffer;
        if ( v35 )
        {
          if ( (unsigned int)v34 >= 4 )
          {
            v52 = *v35;
            v53 = v35 + 1;
            if ( v34 - 4 >= (unsigned __int64)v52 )
            {
              v36 = CertOpenStore((LPCSTR)6, 1u, 0i64, 0, &v52);
              if ( !v36 )
                goto LABEL_109;
              for ( i = 0i64; ; i = v40 )
              {
                v39 = CertEnumCertificatesInStore(v36, i);
                v40 = v39;
                if ( !v39 )
                {
                  if ( !CertCloseStore(v36, 2u)
                    && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
                  {
                    LastError = GetLastError();
                    WPP_SF_D(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      15i64,
                      &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                      LastError);
                  }
                  cbBuffer = v49;
                  goto LABEL_107;
                }
                if ( !CertAddCertificateContextToStore(hCertStore, v39, 1u, 0i64) && GetLastError() != -2146885627 )
                  break;
              }
              if ( !CertCloseStore(v36, 2u)
                && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
              {
                v38 = GetLastError();
                WPP_SF_D(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  14i64,
                  &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
                  v38);
              }
              CertFreeCertificateContext(v40);
LABEL_99:
              v11 = -2146893043;
              goto LABEL_72;
            }
          }
        }
        goto LABEL_110;
      }
LABEL_107:
      ++v27;
      v28 = *(_QWORD *)&v50.cbBuffer + 56i64;
      *(_QWORD *)&v50.cbBuffer += 56i64;
      if ( v27 >= v14 )
        goto LABEL_18;
    }
LABEL_71:
    v11 = -2146893052;
    goto LABEL_72;
  }
LABEL_18:
  if ( v51 )
  {
    v42 = *v18;
    if ( v18 == (unsigned int *)-4i64 || (unsigned int)v42 < 4 )
      goto LABEL_71;
    v52 = v18[1];
    v53 = (int *)(v18 + 2);
    if ( v42 - 4 < (unsigned __int64)v52 )
    {
LABEL_110:
      v11 = -2146893052;
      goto LABEL_25;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 16i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
    v43 = CertOpenStore((LPCSTR)6, 1u, 0i64, 0, &v52);
    *((_QWORD *)a4 + 2) = v43;
    if ( !v43 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 17i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
LABEL_109:
      v11 = -2146893043;
      goto LABEL_25;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_q(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x12u,
        (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
        v43);
  }
  v19 = a2 - 4;
  if ( v19 )
  {
    if ( v19 != 1 )
    {
LABEL_24:
      v11 = 0;
      goto LABEL_25;
    }
    v11 = CopyTlsParameters(v63, v61, 0, 1, (struct _TLS_PARAMETERS **)a4 + 13, (unsigned int *)a4 + 24);
    if ( !v11 )
    {
      *(_QWORD *)((char *)a4 + 84) = v60;
      v20 = v55;
LABEL_23:
      *((_DWORD *)a4 + 23) = v20;
      goto LABEL_24;
    }
  }
  else
  {
    v23 = v59;
    if ( !v59 || !v60 )
      goto LABEL_41;
    if ( v59 > 0x100
      || (v44 = 4 * v59, *((_DWORD *)a4 + 14) = v59, v45 = SPExternalAlloc(4 * v23), (*((_QWORD *)a4 + 8) = v45) == 0i64) )
    {
      v11 = -2146893056;
      goto LABEL_25;
    }
    v11 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, HLOCAL, __int64))(LsaTable + 80))(0i64, v44, v45, v60);
    if ( v11 >= 0 )
    {
LABEL_41:
      v24 = v61;
      if ( v61 == -1 )
        v24 = 0;
      *((_DWORD *)a4 + 18) = v24 & 0x3FFFFFFF;
      *((_DWORD *)a4 + 19) = v62;
      *((_QWORD *)a4 + 10) = v63;
      *((_DWORD *)a4 + 22) = v64;
      v20 = HIDWORD(v64);
      goto LABEL_23;
    }
  }
LABEL_25:
  v9 = hCertStore;
  v8 = v48;
LABEL_26:
  if ( a3 )
  {
    v21 = a3->pvBuffer;
    if ( v21 && (BYTE8(v65) & 0x10) != 0 )
      SPExternalFree(v21);
    a3->pvBuffer = 0i64;
    *(_QWORD *)&a3->cbBuffer = 0i64;
    CleanupAppModeInfo(0i64);
  }
  if ( v8 )
    SPExternalFree(v8);
  if ( v9 )
    CertCloseStore(v9, 0);
  if ( v11 < 0 )
    FreeSchannelCred(a4, 1);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v11 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    LODWORD(pvPara) = v11;
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x13u,
      (__int64)&WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids,
      v11,
      pvPara);
  }
  return (unsigned int)v11;
}
// 18003A716: variable 'pvPara' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180011434) ----------------------------------------------------
void __fastcall CleanupAppModeInfo(void *a1)
{
  char v1; // [rsp+20h] [rbp-18h]

  if ( a1 )
    (*(void (**)(void))(LsaTable + 392))();
  v1 = 0;
  (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, char))(LsaTable + 496))(0i64, 0i64, 0i64, 0i64, v1);
}
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018001147C) ----------------------------------------------------
__int64 __fastcall ParseKeyBuffer(struct CSslContext *a1, __int64 a2, unsigned __int8 *a3, unsigned int a4)
{
  unsigned int v4; // esi
  char v7; // r14
  int v9; // ebp
  unsigned __int8 *v10; // rbx
  __int64 v11; // rax
  _QWORD *v12; // rbx
  _QWORD *v13; // r14
  _QWORD *v14; // rbx
  unsigned int v15; // eax
  unsigned int v16; // eax
  CCipherMill *v17; // rcx
  _DWORD *v18; // rbx
  unsigned int v19; // r14d
  unsigned int *v20; // rax
  _BYTE *v21; // rbx
  __int64 v22; // r9
  __int64 v23; // r14
  __int64 v24; // r15
  unsigned int v25; // r12d
  _BYTE *v26; // rbx
  _BYTE *v27; // r8
  _BYTE *v28; // r13
  _BYTE *v29; // rbx
  _QWORD *v30; // rax
  __int64 v31; // rcx
  __int64 *v33; // rax
  __int64 v34; // rcx
  CCipherMill *v35; // rcx
  __int64 v36; // rdx
  __int64 *v37; // rax
  __int64 v38; // rdx
  CCipherMill *v39; // rcx
  const wchar_t *v40; // r9
  unsigned __int16 v41; // dx
  _QWORD *v42; // rax
  __int64 v43; // rdx
  __int64 v44; // [rsp+20h] [rbp-58h]
  int v45; // [rsp+80h] [rbp+8h]
  int v46; // [rsp+88h] [rbp+10h]

  v4 = 0;
  v45 = *((_DWORD *)a1 + 16) & 0x40051555;
  v7 = a2;
  if ( !a3 || a4 < 0x3D )
    return 87;
  v9 = a2 & 1;
  if ( (a2 & 1) != 0 )
  {
    *((_QWORD *)a1 + 22) = *(_QWORD *)a3;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_i(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x1Du, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
  }
  v46 = v7 & 2;
  if ( (v7 & 2) != 0 )
  {
    *((_QWORD *)a1 + 23) = *((_QWORD *)a3 + 1);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_i(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x1Eu, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
  }
  v10 = a3 + 16;
  if ( v9
    && (v11 = *(int *)v10, *((_DWORD *)a1 + 48) = v11, WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control)
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_i(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x1Fu, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v11);
    v12 = v10 + 4;
    v13 = v12;
  }
  else
  {
    v12 = v10 + 4;
    v13 = v12;
    if ( !v9 )
      goto LABEL_17;
  }
  *((_QWORD *)a1 + 25) = *v12;
  if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
  {
LABEL_17:
    v14 = v12 + 1;
    if ( !v9 )
      goto LABEL_21;
    goto LABEL_18;
  }
  WPP_SF_i(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x20u, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
  v14 = v13 + 1;
LABEL_18:
  *((_QWORD *)a1 + 26) = *v14;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_i(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x21u, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
LABEL_21:
  v15 = *((unsigned __int16 *)v14 + 4);
  *((_WORD *)a1 + 108) = v15;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 34i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v15);
  v16 = *((unsigned __int16 *)v14 + 5);
  *((_WORD *)a1 + 109) = v16;
  v17 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 35i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v16);
    v17 = WPP_GLOBAL_Control;
  }
  v18 = (_DWORD *)v14 + 3;
  if ( v9 )
  {
    v19 = *v18;
    if ( v17 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v17 + 28) & 4) != 0 )
      WPP_SF_D(*((_QWORD *)v17 + 2), 36i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v19);
    v20 = (unsigned int *)*((_QWORD *)a1 + 28);
    if ( v20 )
    {
      *v20 = v19;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          37i64,
          &WPP_66cada2652f531372f2ad4492a08a619_Traceguids,
          **((unsigned int **)a1 + 28));
    }
  }
  v21 = v18 + 1;
  LOBYTE(a2) = *v21;
  (*(void (__fastcall **)(struct CSslContext *, __int64))(*(_QWORD *)a1 + 408i64))(a1, a2);
  v22 = *(unsigned int *)++v21;
  v21 += 4;
  v23 = *(unsigned int *)v21;
  v21 += 4;
  v24 = *(unsigned int *)v21;
  v21 += 4;
  v25 = *(_DWORD *)v21;
  v26 = v21 + 4;
  if ( (unsigned int)v22 > 0x10000 || (unsigned int)v23 > 0x10000 || (unsigned int)v24 > 0x10000 || v25 > 0x10000 )
    return 87;
  if ( a4 - 61 != (_DWORD)v22 + (_DWORD)v23 + v25 + (_DWORD)v24 )
  {
    v4 = 1359;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 38i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
    return v4;
  }
  v27 = v26;
  v28 = &v26[v22];
  v29 = &v26[v22 + v23];
  if ( v9 )
  {
    if ( (_DWORD)v22 )
    {
      v33 = (__int64 *)*((_QWORD *)a1 + 1);
      if ( v33 )
        v34 = *v33;
      else
        v34 = 0i64;
      v4 = SslImportKey(v34, (char *)a1 + 144, L"OpaqueKeyBlob", v27, v22, 0);
      if ( v4 )
      {
        v35 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return v4;
        v36 = 39i64;
LABEL_65:
        WPP_SF_D(*((_QWORD *)v35 + 2), v36, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v4);
        return v4;
      }
    }
    else
    {
      *((_QWORD *)a1 + 18) = 0i64;
    }
  }
  if ( v46 )
  {
    if ( !(_DWORD)v23 )
    {
      *((_QWORD *)a1 + 19) = 0i64;
      goto LABEL_45;
    }
    v30 = (_QWORD *)*((_QWORD *)a1 + 1);
    v31 = v30 ? *v30 : 0i64;
    v4 = SslImportKey(v31, (char *)a1 + 152, L"OpaqueKeyBlob", v28, v23, 0);
    if ( v4 )
    {
      v35 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return v4;
      v36 = 40i64;
      goto LABEL_65;
    }
  }
LABEL_45:
  if ( (_DWORD)v24
    && ((v37 = (__int64 *)*((_QWORD *)a1 + 1)) == 0i64 ? (v38 = 0i64) : (v38 = *v37),
        LOBYTE(v27) = 1,
        (v4 = (*(__int64 (__fastcall **)(struct CSslContext *, __int64, _BYTE *, _BYTE *, _DWORD))(*(_QWORD *)a1 + 400i64))(
                a1,
                v38,
                v27,
                v29,
                v24)) != 0) )
  {
    v39 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      v40 = L"server";
      v41 = 41;
      if ( v45 )
        v40 = L"client";
      goto LABEL_81;
    }
  }
  else if ( v25 )
  {
    v42 = (_QWORD *)*((_QWORD *)a1 + 1);
    v43 = v42 ? *v42 : 0i64;
    v4 = (*(__int64 (__fastcall **)(struct CSslContext *, __int64, _QWORD, _BYTE *, unsigned int))(*(_QWORD *)a1 + 400i64))(
           a1,
           v43,
           0i64,
           &v29[v24],
           v25);
    if ( v4 )
    {
      v39 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        v40 = L"server";
        v41 = 42;
        if ( !v45 )
          v40 = L"client";
LABEL_81:
        LODWORD(v44) = v4;
        WPP_SF_SD(*((_QWORD *)v39 + 2), v41, (__int64)&WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v40, v44);
      }
    }
  }
  return v4;
}
// 180011622: variable 'a2' is possibly undefined
// 18003A9A2: variable 'v27' is possibly undefined
// 18003AA20: variable 'v44' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082320: using guessed type wchar_t aOpaquekeyblob[14];
// 180084B40: using guessed type wchar_t aServer_1[7];
// 180084B50: using guessed type wchar_t aClient[7];
// 1800985A0: using guessed type __int64 __fastcall SslImportKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180011740) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::ProcessAppModeInfo(CSsl3TlsContext *this)
{
  unsigned int v2; // ebx
  int v3; // esi
  unsigned int v4; // r9d
  CCipherMill *v6; // rcx
  unsigned __int16 v7; // dx
  unsigned __int64 v8; // rcx
  __int64 v9; // r9
  __int64 v10; // r10
  __int64 v11; // rax
  int v12; // eax
  HLOCAL v13; // rax
  void *Src[2]; // [rsp+30h] [rbp-30h] BYREF
  char v15[32]; // [rsp+40h] [rbp-20h] BYREF
  int v16; // [rsp+80h] [rbp+20h] BYREF
  __int64 v17; // [rsp+88h] [rbp+28h] BYREF

  v17 = 0i64;
  v16 = 0;
  v2 = -1073741595;
  *(_OWORD *)Src = 0i64;
  if ( LsaTable )
  {
    if ( (*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v15) )
    {
      v3 = v15[8] & 0x40;
      v2 = (*(__int64 (__fastcall **)(int *, _QWORD, __int64 *, void **, _QWORD))(LsaTable + 488))(
             &v16,
             0i64,
             &v17,
             Src,
             0i64);
      if ( v2 )
        goto LABEL_12;
      v4 = (unsigned int)Src[0];
      if ( (!Src[1] || !LODWORD(Src[0])) && v16 != 4 )
        goto LABEL_12;
      switch ( v16 )
      {
        case 1:
          v12 = *((_DWORD *)this + 16) & 0x2000;
          *((_DWORD *)this + 236) = Src[0];
          *((_DWORD *)this + 18) = v12 != 0 ? 101 : 91;
          v13 = SPExternalAlloc(v4);
          *((_QWORD *)this + 117) = v13;
          if ( v13 )
          {
            memcpy_0(v13, Src[1], LODWORD(Src[0]));
            *((_BYTE *)this + 1032) = 1;
            goto LABEL_10;
          }
          break;
        case 4:
          if ( !this )
            v2 = 1359;
          if ( Src[1] )
          {
            if ( LODWORD(Src[0]) == (v3 != 0 ? 28 : 36) )
            {
              v8 = -(__int64)(v3 != 0) & 0xFFFFFFFFFFFFFFFCui64;
              if ( v3 )
              {
                v9 = *((unsigned int *)Src[1] + 5);
                v10 = *(unsigned int *)((char *)Src[1] + v8 + 28);
              }
              else
              {
                v9 = *(_QWORD *)((char *)Src[1] + 20);
                v10 = *(_QWORD *)((char *)Src[1] + v8 + 28);
              }
              v11 = *((_QWORD *)this + 116);
              if ( !v11 )
                v2 = 1359;
              *(_QWORD *)(v11 + 104) = v9;
              *(_QWORD *)(v11 + 112) = v10;
              *((_BYTE *)this + 923) = 0;
              CSsl3TlsClientContext::SetDefCredSearched((__int64)this, 0);
            }
            else
            {
              v2 = 1359;
            }
          }
          else
          {
            CSsl3TlsClientContext::SetActiveClientCred(this, 0i64, 0);
          }
          goto LABEL_10;
        case 7:
          v2 = ParseKeyBuffer(this, (unsigned int)v17, (unsigned __int8 *)Src[1], (unsigned int)Src[0]);
          if ( !v2 )
          {
LABEL_10:
            *((_DWORD *)this + 17) = *((_DWORD *)this + 18);
            *((_DWORD *)this + 18) = 77;
            CleanupAppModeInfo(0i64);
            return v2;
          }
LABEL_12:
          v2 = -1073741595;
          goto LABEL_10;
        case 9:
          *((_BYTE *)this + 472) = *(_BYTE *)Src[1];
          goto LABEL_10;
      }
      v2 = 1359;
      goto LABEL_10;
    }
    v6 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
    {
      v7 = 99;
      goto LABEL_21;
    }
  }
  else
  {
    v6 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) != 0 )
    {
      v7 = 98;
LABEL_21:
      WPP_SF_DD(
        *((_QWORD *)v6 + 2),
        v7,
        (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
        -1073741595,
        -1073741595);
    }
  }
  return v2;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180011860) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SslProtocolHandler(CSsl3TlsContext *this, struct SPBuffer *a2, struct SPBuffer *a3)
{
  unsigned int v6; // ebp
  char v7; // al
  unsigned int v8; // eax
  unsigned int v9; // ecx
  __int64 result; // rax
  __int64 v11; // rcx
  unsigned int v12; // edx
  DTlsMsgMgr *v13; // rcx
  CSsl3TlsContext *v14; // rcx
  int v15; // edx
  int v16; // eax
  unsigned int v17; // eax
  int v18; // [rsp+20h] [rbp-18h] BYREF
  int v19; // [rsp+24h] [rbp-14h]
  __int64 v20; // [rsp+28h] [rbp-10h]

  v6 = 0;
  if ( *((_DWORD *)this + 17) == 77 && (unsigned int)CSsl3TlsContext::ProcessAppModeInfo(this) )
    return 3221225701i64;
  v7 = *((_BYTE *)this + 266);
  if ( !v7 && (*((_DWORD *)this + 16) & 0x3000) == 0 )
    goto LABEL_50;
  v11 = *((_QWORD *)this + 17);
  if ( (v11 & 0x40000000) == 0 && !*((_BYTE *)this + 265) )
    goto LABEL_50;
  v12 = 0;
  if ( !*((_QWORD *)this + 19) )
    v12 = 2;
  if ( !*((_QWORD *)this + 18) )
    v12 |= 1u;
  if ( !v12 )
    goto LABEL_50;
  *((_QWORD *)this + 17) = v11 & 0xFFFFFFFFBFFFFFFFui64;
  if ( v7 )
  {
    *((_DWORD *)this + 18) = *((_DWORD *)this + 17);
    *((_DWORD *)this + 17) = 77;
    return RemotelyGetUserKeys(this, v12);
  }
  result = RemotelyGetUserKeys(this, v12);
  if ( !(_DWORD)result )
  {
LABEL_50:
    if ( *((_BYTE *)this + 233) )
    {
      v13 = (DTlsMsgMgr *)*((_QWORD *)this + 72);
      if ( *((DTlsMsgMgr **)v13 + 7) != (DTlsMsgMgr *)((char *)v13 + 56) )
        return CSsl3TlsContext::PrepareNextOutgoingRecord(this, a3);
      if ( *((_DWORD *)this + 17) != 4 && !*(_DWORD *)a2 && !*((_DWORD *)a2 + 1) && !*((_QWORD *)a2 + 1) )
      {
        result = DTlsMsgMgr::swapSaveAndOutgoing(v13);
        if ( !(_DWORD)result )
        {
          LogDtlsRetransmitRequested(
            *(_DWORD *)(*((_QWORD *)this + 10) + 212i64),
            (const unsigned __int16 *)(*((_QWORD *)this + 10) + 216i64));
          result = CSsl3TlsContext::RestoreWriteCipherState(this);
          if ( !(_DWORD)result )
            return CSsl3TlsContext::PrepareNextOutgoingRecord(v14, a3);
        }
        return result;
      }
    }
    if ( (*(unsigned __int8 (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 384i64))(this) )
    {
      if ( (*((_DWORD *)this + 34) & 0x1000i64) != 0 )
      {
        v15 = *((_DWORD *)a2 + 1);
        do
        {
          v20 = *((_QWORD *)a2 + 1) + v6;
          v16 = *(_DWORD *)a2 - v6;
          v19 = v15 - v6;
          v18 = v16;
          v17 = CSsl3TlsContext::TlsProtocolHandlerWorker(this, (struct SPBuffer *)&v18, a3);
          v6 += v19;
          v9 = v17;
          if ( *((_DWORD *)this + 17) == 4 )
            break;
          if ( v17 )
            break;
          v15 = *((_DWORD *)a2 + 1);
        }
        while ( v15 != v6 );
        *((_DWORD *)a2 + 1) = v6;
LABEL_9:
        if ( *((_DWORD *)this + 16) == 4096
          && *((_DWORD *)this + 17) == 4
          && (*((_DWORD *)this + 34) & 0x100i64) != 0
          && !*((_BYTE *)this + 552)
          && !v9 )
        {
          v9 = (*(__int64 (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 472i64))(this);
          if ( v9 == 590614 && *((_DWORD *)this + 17) == 4 )
            return 0;
        }
        return v9;
      }
      v8 = CSsl3TlsContext::TlsProtocolHandlerWorker(this, a2, a3);
    }
    else
    {
      v8 = CSsl3TlsContext::TlsNulRecordHandlerWorker(this, a2, a3);
    }
    v9 = v8;
    goto LABEL_9;
  }
  return result;
}
// 18003AC8B: variable 'v14' is possibly undefined

//----- (00000001800119B0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::TlsProtocolHandlerWorker(
        CSsl3TlsContext *this,
        struct SPBuffer *a2,
        struct SPBuffer *a3)
{
  int v3; // edi
  struct SPBuffer *v5; // r15
  unsigned int v7; // r12d
  __int64 v8; // rax
  __int64 result; // rax
  unsigned int v10; // r8d
  int v11; // edx
  CCipherMill *v12; // rcx
  unsigned __int8 *v13; // r14
  unsigned int v14; // esi
  __int64 v15; // r8
  unsigned int v16; // esi
  int v17; // esi
  int v18; // eax
  unsigned int v19; // esi
  int v20; // ecx
  __int64 v21; // rdx
  unsigned int v22; // r11d
  unsigned __int8 *v23; // rsi
  unsigned int v24; // r15d
  unsigned int v25; // r14d
  __int64 v26; // rdx
  unsigned int v27; // esi
  __int64 v28; // r8
  unsigned int v29; // esi
  int v30; // edx
  __int64 v31; // rax
  __int64 v32; // rcx
  int v33; // esi
  __int64 v34; // r14
  bool v35; // r9
  __int64 v36; // rax
  __int64 v37; // r11
  int v38; // r10d
  __int64 v39; // rcx
  __int64 v40; // r11
  __int64 v41; // rax
  unsigned int v42; // eax
  int v43; // edx
  int v44; // r14d
  int v45; // eax
  unsigned int AppDataStatus; // eax
  CCipherMill *v47; // rcx
  __int64 v48; // rdx
  unsigned __int8 *v49; // rdx
  int v50; // r9d
  int v51; // r15d
  unsigned __int64 v52; // r11
  CCipherMill *v53; // r10
  unsigned int v54; // eax
  bool v55; // zf
  __int64 v56; // rax
  __int64 v57; // rdx
  int v58; // r15d
  int v59; // eax
  __int64 v60; // rax
  __int64 v61; // rdx
  int v62; // r15d
  int v63; // eax
  int v64; // eax
  unsigned int v65; // r15d
  struct DTlsMessage *NextReadyHandshakeMsg; // rax
  unsigned int v67; // ecx
  int v68; // eax
  struct DTlsMessage *v69; // rax
  unsigned int ResponseCommon; // eax
  __int64 v71; // rdx
  CCipherMill *v72; // rcx
  __int64 v73; // rdx
  unsigned int v74; // edi
  unsigned int UserKeys; // eax
  struct kexch *KeyExchangeInfo; // rax
  int v77; // r10d
  _DWORD *v78; // r11
  __int64 v79; // [rsp+20h] [rbp-100h]
  __int64 v80; // [rsp+28h] [rbp-F8h]
  unsigned int v81; // [rsp+A0h] [rbp-80h]
  unsigned int v82; // [rsp+A0h] [rbp-80h]
  int v83; // [rsp+A0h] [rbp-80h]
  unsigned int v84; // [rsp+A4h] [rbp-7Ch]
  DTlsMessage *v85; // [rsp+A8h] [rbp-78h]
  DTlsMessage *v86; // [rsp+A8h] [rbp-78h]
  int v87; // [rsp+B0h] [rbp-70h]
  unsigned int v88; // [rsp+B4h] [rbp-6Ch]
  unsigned __int64 v89; // [rsp+B8h] [rbp-68h]
  unsigned __int8 *v90; // [rsp+C0h] [rbp-60h]
  __int64 v91; // [rsp+C8h] [rbp-58h] BYREF
  __int64 v92; // [rsp+D0h] [rbp-50h]
  int v93; // [rsp+D8h] [rbp-48h]
  int v94; // [rsp+DCh] [rbp-44h]
  unsigned __int64 v95; // [rsp+E0h] [rbp-40h]
  int v96[2]; // [rsp+E8h] [rbp-38h] BYREF
  unsigned __int8 *v97; // [rsp+F0h] [rbp-30h]
  int v98[2]; // [rsp+F8h] [rbp-28h] BYREF
  unsigned __int8 *v99; // [rsp+100h] [rbp-20h]
  int v100[2]; // [rsp+108h] [rbp-18h] BYREF
  unsigned __int8 *v101; // [rsp+110h] [rbp-10h]
  char v102[8]; // [rsp+120h] [rbp+0h] BYREF
  int v103; // [rsp+128h] [rbp+8h]
  int v104; // [rsp+12Ch] [rbp+Ch]
  bool v105; // [rsp+860h] [rbp+740h]
  unsigned int v108; // [rsp+878h] [rbp+758h]

  v3 = 0;
  v5 = a2;
  v87 = 0;
  v94 = *((_DWORD *)a2 + 1);
  v7 = 5;
  if ( *((_BYTE *)this + 233) )
    v7 = 13;
  v8 = *(_QWORD *)this;
  v105 = 0;
  v92 = 0i64;
  v91 = 0i64;
  result = (*(__int64 (__fastcall **)(CSsl3TlsContext *))(v8 + 432))(this);
  v81 = result;
  v10 = result;
  if ( (_DWORD)result )
    return result;
  v11 = *((_DWORD *)this + 17);
  if ( (v11 < 6 || v11 >= 91) && v11 >= 2 )
  {
    switch ( v11 )
    {
      case 2:
      case 4:
      case 5:
      case 91:
      case 93:
      case 95:
      case 96:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        if ( *((_BYTE *)this + 233) && *((_DWORD *)this + 17) == 91 )
        {
          result = CSsl3TlsContext::GenerateResponseCommon(this, (struct SPBuffer *)&v91);
          if ( !(_DWORD)result && v92 )
            result = CSsl3TlsContext::DtlsGetOutgoingRecord(this, (struct SPBuffer *)&v91, a3);
        }
        else
        {
          result = CSsl3TlsContext::GenerateResponseCommon(this, a3);
        }
        break;
      default:
        goto LABEL_6;
    }
    return result;
  }
LABEL_6:
  if ( v11 == 76 && !*((_BYTE *)this + 555) && *((_QWORD *)v5 + 1) && (*((_DWORD *)this + 16) & 0x50000) != 0 )
  {
    v12 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
      v12 = WPP_GLOBAL_Control;
      v10 = 0;
    }
    if ( *((_BYTE *)this + 266) )
    {
      if ( *((_DWORD *)this + 18) == 77 )
      {
LABEL_136:
        v105 = *((_BYTE *)this + 472) == 0;
        goto LABEL_8;
      }
      *((_DWORD *)this + 18) = *((_DWORD *)this + 17);
    }
    AppDataStatus = RemotelyGetAppDataStatus(this);
    v81 = AppDataStatus;
    v10 = AppDataStatus;
    if ( AppDataStatus == 590610 )
    {
      *((_DWORD *)this + 17) = 77;
      v47 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        v48 = 12i64;
        goto LABEL_296;
      }
      return 590610i64;
    }
    if ( AppDataStatus )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        return v81;
      }
      return v10;
    }
    v12 = WPP_GLOBAL_Control;
    goto LABEL_136;
  }
  v12 = WPP_GLOBAL_Control;
LABEL_8:
  v13 = (unsigned __int8 *)*((_QWORD *)v5 + 1);
  v14 = *((_DWORD *)v5 + 1);
  v90 = v13;
  v88 = v14;
  while ( 1 )
  {
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)v12 + 2), 14i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
      v12 = WPP_GLOBAL_Control;
      v10 = v81;
    }
    if ( v14 < v7 )
      break;
    v15 = *v13;
    v108 = v15;
    if ( (unsigned int)(v15 - 20) > 3 )
    {
      CSslContext::SetErrorAndFatalAlert((__int64)this, 10, -2146893048, 0xAu);
      return 2148074248i64;
    }
    v16 = v13[2] | (v13[1] << 8);
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
    {
      WPP_SF_D(*((_QWORD *)v12 + 2), 15i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids, v16);
      v12 = WPP_GLOBAL_Control;
      v15 = v108;
    }
    if ( v16 < 0x300 )
    {
      if ( *((_DWORD *)this + 9) >= 0x302u && (*((_DWORD *)this + 16) & 0x800A00AA) != 0 )
      {
        v74 = -2146893018;
        CSslContext::SetError((__int64)this, 11, -2146893018);
      }
      else
      {
        v74 = -2146893048;
        CSslContext::SetErrorAndFatalAlert((__int64)this, 11, -2146893048, 0x46u);
      }
      return v74;
    }
    if ( v13[1] == 0xFE && (v13[2] | (v13[1] << 8)) <= 0xFEFFu )
    {
      v17 = v13[11];
      v18 = v13[12];
    }
    else
    {
      v17 = v13[3];
      v18 = v13[4];
    }
    v19 = v18 | (v17 << 8);
    v84 = v19;
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
    {
      WPP_SF_D(*((_QWORD *)v12 + 2), 16i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids, v19);
      v15 = v108;
    }
    v20 = v19 + v7;
    v93 = v19 + v7;
    if ( v19 + v7 > v88 )
    {
      if ( !v87 )
      {
        *((_DWORD *)v5 + 1) = v20;
        CSslContext::SetError((__int64)this, 13, -2146893032);
        return 2148074264i64;
      }
      v10 = v81;
LABEL_104:
      if ( *((_BYTE *)this + 233) && !v10 )
      {
        if ( v92 )
          return (unsigned int)CSsl3TlsContext::DtlsGetOutgoingRecord(this, (struct SPBuffer *)&v91, a3);
      }
      return v10;
    }
    *((_DWORD *)v5 + 1) = v20 + v87;
    v87 += v20;
    if ( *((_BYTE *)this + 233) )
    {
      v49 = 0i64;
      v50 = 0;
      v51 = 0;
      v83 = 0;
      v86 = 0i64;
      v95 = v13[10] | ((v13[9] | ((v13[8] | ((v13[7] | ((v13[6] | ((v13[5] | ((v13[4] | ((unsigned __int64)v13[3] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
      v52 = HIWORD(v95);
      v89 = HIWORD(v95);
      v53 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          LODWORD(v79) = v95;
          WPP_SF_DD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x11u,
            (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
            v52,
            v79);
          v53 = WPP_GLOBAL_Control;
          v20 = v19 + v7;
          LOBYTE(v15) = v108;
          v49 = 0i64;
          LODWORD(v52) = v89;
          v50 = 0;
        }
        if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
        {
          LODWORD(v80) = **((_DWORD **)this + 28);
          LODWORD(v79) = *((unsigned __int16 *)this + 110);
          WPP_SF_DDD(
            *((_QWORD *)v53 + 2),
            0x12u,
            (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
            *((_DWORD *)this + 48),
            v79,
            v80);
          v53 = WPP_GLOBAL_Control;
          v20 = v19 + v7;
          LOBYTE(v15) = v108;
          v49 = 0i64;
          LODWORD(v52) = v89;
          v50 = 0;
        }
      }
      if ( v105 )
      {
        if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
        {
          WPP_SF_(*((_QWORD *)v53 + 2), 19i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          v53 = WPP_GLOBAL_Control;
          v20 = v19 + v7;
          LOBYTE(v15) = v108;
          v49 = 0i64;
          LODWORD(v52) = v89;
          v50 = 0;
        }
        v54 = *((_DWORD *)this + 48);
        v55 = (_DWORD)v52 == v54;
        if ( (unsigned int)v52 < v54 )
        {
          if ( (_BYTE)v15 == 20 )
          {
            if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_BYTE *)v53 + 28) & 4) != 0 )
              {
                v71 = 20i64;
                goto LABEL_272;
              }
              goto LABEL_273;
            }
            goto LABEL_276;
          }
          v55 = (_DWORD)v52 == v54;
        }
        if ( v55 )
        {
          if ( (_BYTE)v15 == 23 )
          {
            if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control )
            {
              if ( (*((_BYTE *)v53 + 28) & 4) != 0 )
              {
                v71 = 21i64;
LABEL_272:
                WPP_SF_(*((_QWORD *)v53 + 2), v71, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
                v53 = WPP_GLOBAL_Control;
              }
LABEL_273:
              if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
                WPP_SF_(*((_QWORD *)v53 + 2), 27i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
            }
LABEL_276:
            LogDtlsRetransmitRequested(
              *(_DWORD *)(*((_QWORD *)this + 10) + 212i64),
              (const unsigned __int16 *)(*((_QWORD *)this + 10) + 216i64));
            DTlsMsgMgr::swapSaveAndOutgoing(*((DTlsMsgMgr **)this + 72));
            v74 = CSsl3TlsContext::RestoreWriteCipherState(this);
            if ( v74 )
            {
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 28i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
                return v74;
              }
            }
            else
            {
              *((_QWORD *)this + 17) &= ~0x40000000ui64;
              *((_BYTE *)this + 265) = 1;
              *((_DWORD *)this + 17) = 4;
              if ( v83 || *((_BYTE *)this + 266) )
                return CSsl3TlsContext::PrepareNextOutgoingRecord(this, a3);
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
              {
                WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 29i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
              }
              UserKeys = RemotelyGetUserKeys(this, 1u);
              v74 = UserKeys;
              if ( !UserKeys )
                return CSsl3TlsContext::PrepareNextOutgoingRecord(this, a3);
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                WPP_SF_D(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  30i64,
                  &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
                  UserKeys);
                return v74;
              }
            }
            return v74;
          }
          if ( (_BYTE)v15 == 22 && (*((_BYTE *)this + 32) & 2) != 0 )
          {
            v56 = *((_QWORD *)this + 1);
            if ( v56 )
            {
              if ( *(_DWORD *)(v56 + 28) )
              {
                if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
                {
                  WPP_SF_(*((_QWORD *)v53 + 2), 22i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
                  v20 = v19 + v7;
                }
                v96[0] = v20;
                v96[1] = v20;
                v97 = v13;
                if ( (unsigned int)CSsl3TlsContext::UnwrapMessage(this, (struct SPBuffer *)v96) )
                {
                  v47 = WPP_GLOBAL_Control;
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                  {
                    v48 = 23i64;
                    goto LABEL_296;
                  }
                  return 590610i64;
                }
                v50 = 1;
                v83 = 1;
                if ( (*((_BYTE *)this + 32) & 2) != 0 )
                  v57 = *((unsigned int *)this + 11);
                else
                  v57 = 0i64;
                if ( v13[1] == 0xFE && (v13[2] | (v13[1] << 8)) <= 0xFEFFu )
                {
                  v58 = v13[11];
                  v59 = v13[12];
                }
                else
                {
                  v58 = v13[3];
                  v59 = v13[4];
                }
                v51 = v59 | (v58 << 8);
                if ( v19 < (unsigned int)v57 + v51 + v7 )
                {
                  v72 = WPP_GLOBAL_Control;
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                  {
                    v73 = 24i64;
                    goto LABEL_310;
                  }
                  return 2148074278i64;
                }
                v49 = &v13[v7 + v57];
                v86 = (DTlsMessage *)v49;
                if ( !v51 )
                {
                  v72 = WPP_GLOBAL_Control;
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                  {
                    v73 = 25i64;
                    goto LABEL_310;
                  }
                  return 2148074278i64;
                }
                if ( *v49 == 20 )
                {
                  v53 = WPP_GLOBAL_Control;
                  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
                  {
                    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
                    {
                      v71 = 26i64;
                      goto LABEL_272;
                    }
                    goto LABEL_273;
                  }
                  goto LABEL_276;
                }
                v53 = WPP_GLOBAL_Control;
                v20 = v19 + v7;
                LODWORD(v52) = v89;
              }
            }
          }
        }
      }
      if ( *((_DWORD *)this + 17) == 76 && *((_BYTE *)this + 233) )
      {
        if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
        {
          WPP_SF_(*((_QWORD *)v53 + 2), 31i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          v50 = v83;
          LODWORD(v52) = v89;
        }
        *(_DWORD *)(*((_QWORD *)this + 73) + 36i64) = *(__int16 *)(*(_QWORD *)(*((_QWORD *)this + 73) + 40i64) + 192i64);
        v20 = v19 + v7;
        v53 = WPP_GLOBAL_Control;
        v49 = (unsigned __int8 *)v86;
      }
      if ( (*((_BYTE *)this + 32) & 2) != 0 && (v60 = *((_QWORD *)this + 1)) != 0 && *(_DWORD *)(v60 + 28) )
      {
        if ( !v50 )
        {
          if ( (_DWORD)v52 == *(_DWORD *)(*((_QWORD *)this + 73) + 36i64) )
          {
            if ( (unsigned int)v52 < *((_DWORD *)this + 48) )
            {
              if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
                WPP_SF_(*((_QWORD *)v53 + 2), 32i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
              LogDtlsRecordOutOfRecvWindow(
                *(_DWORD *)(*((_QWORD *)this + 10) + 212i64),
                (const unsigned __int16 *)(*((_QWORD *)this + 10) + 216i64));
              return 590610i64;
            }
            if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
            {
              WPP_SF_(*((_QWORD *)v53 + 2), 33i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
              v20 = v19 + v7;
            }
            v98[0] = v20;
            v98[1] = v20;
            v99 = v13;
            if ( (unsigned int)CSsl3TlsContext::UnwrapMessage(this, (struct SPBuffer *)v98) )
            {
              v47 = WPP_GLOBAL_Control;
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                v48 = 34i64;
LABEL_296:
                WPP_SF_(*((_QWORD *)v47 + 2), v48, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
              }
              return 590610i64;
            }
            if ( (*((_BYTE *)this + 32) & 2) != 0 )
              v61 = *((unsigned int *)this + 11);
            else
              v61 = 0i64;
            if ( v13[1] == 0xFE && (v13[2] | (v13[1] << 8)) <= 0xFEFFu )
            {
              v62 = v13[11];
              v63 = v13[12];
            }
            else
            {
              v62 = v13[3];
              v63 = v13[4];
            }
            v51 = v63 | (v62 << 8);
            if ( v19 < (unsigned int)v61 + v51 + v7 )
            {
              v72 = WPP_GLOBAL_Control;
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                v73 = 35i64;
                goto LABEL_310;
              }
              return 2148074278i64;
            }
            v49 = &v13[v7 + v61];
            goto LABEL_202;
          }
LABEL_198:
          if ( v53 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v53 + 28) & 4) != 0 )
            WPP_SF_(*((_QWORD *)v53 + 2), 36i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          v51 = v19;
          v49 = &v13[v7];
        }
      }
      else if ( !v50 )
      {
        goto LABEL_198;
      }
LABEL_202:
      DTlsHandshakeQueue::DtlsReorderHandshake(*((_QWORD *)this + 73), v108, (__int64)v49, v51, v95);
      v15 = v108;
      v20 = v93;
    }
    v21 = 0i64;
    v85 = 0i64;
    v22 = v15;
    v82 = v15;
    v23 = 0i64;
    v24 = 0;
    if ( (*((_DWORD *)this + 16) & 0x3000) != 0 && (_BYTE)v15 == 20 )
    {
      v29 = v84;
      v64 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, unsigned __int8 *, _QWORD, _QWORD))(*(_QWORD *)this + 488i64))(
              this,
              v13,
              v7,
              v84);
      v65 = v64;
      if ( v64 )
      {
        if ( v64 == -2146893018 || v64 == -2146893048 )
          CSslContext::SetErrorAndFatalAlert((__int64)this, 904, v64, 0xAu);
        return v65;
      }
      v12 = WPP_GLOBAL_Control;
      v24 = 0;
    }
    else
    {
      if ( *((_BYTE *)this + 233) )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 54i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        NextReadyHandshakeMsg = DTlsHandshakeQueue::GetNextReadyHandshakeMsg(*((DTlsMsgMgr ***)this + 73), v21, v15);
        v85 = NextReadyHandshakeMsg;
        v21 = (__int64)NextReadyHandshakeMsg;
        if ( NextReadyHandshakeMsg )
        {
          v22 = *((_DWORD *)NextReadyHandshakeMsg + 16);
          v23 = (unsigned __int8 *)*((_QWORD *)NextReadyHandshakeMsg + 5);
          v24 = *((_DWORD *)NextReadyHandshakeMsg + 5);
          v82 = v22;
        }
        else
        {
          v22 = v82;
        }
        v12 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 55i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids, v22);
          v12 = WPP_GLOBAL_Control;
          v22 = v82;
          v21 = (__int64)v85;
        }
        LODWORD(v15) = v108;
      }
      else
      {
        v24 = v20;
        v23 = v13;
        v12 = WPP_GLOBAL_Control;
      }
      if ( v23 )
      {
        v25 = v24;
        while ( 1 )
        {
          if ( (*((_BYTE *)this + 32) & 2) != 0
            && (v41 = *((_QWORD *)this + 1)) != 0
            && *(_DWORD *)(v41 + 28)
            && (!*((_BYTE *)this + 233) || v21 && *(_DWORD *)(v21 + 68)) )
          {
            v42 = *((_DWORD *)this + 17) - 78;
            v100[0] = v24;
            v100[1] = v24;
            v101 = v23;
            if ( v42 <= 1 && v25 > v7 && *v23 == 22 )
            {
              if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
              {
                WPP_SF_(*((_QWORD *)v12 + 2), 37i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
                LODWORD(v15) = v108;
                v22 = v82;
              }
              v67 = *(unsigned __int16 *)&v23[v25 - 2];
              if ( v67 > v25 - v7 )
                return 2148074248i64;
              if ( *((_BYTE *)this + 233) )
              {
                v23[11] = BYTE1(v67);
                v23[12] = v67;
              }
              else
              {
                v23[3] = BYTE1(v67);
                v23[4] = v67;
              }
            }
            else
            {
              if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
                WPP_SF_(*((_QWORD *)v12 + 2), 38i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
              result = CSsl3TlsContext::UnwrapMessage(this, (struct SPBuffer *)v100);
              if ( (_DWORD)result )
              {
                if ( !*((_BYTE *)this + 233) )
                  return result;
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                {
                  WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 39i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
                }
              }
              if ( (*((_DWORD *)this + 16) & 0x3000) != 0 )
              {
                LODWORD(v15) = *v23;
                v108 = v15;
                v22 = v15;
                if ( (_DWORD)v15 == 20 )
                {
                  CSslContext::SetErrorAndFatalAlert((__int64)this, 904, -2146893018, 0xAu);
                  return 2148074278i64;
                }
              }
              else
              {
                LODWORD(v15) = v108;
                v22 = v82;
              }
            }
            if ( (*((_BYTE *)this + 32) & 2) != 0 )
              v43 = *((_DWORD *)this + 11);
            else
              v43 = 0;
            if ( v23[1] == 0xFE && (v23[2] | (v23[1] << 8)) <= 0xFEFFu )
            {
              v44 = v23[11];
              v45 = v23[12];
            }
            else
            {
              v44 = v23[3];
              v45 = v23[4];
            }
            v25 = v45 | (v44 << 8);
            if ( v24 < v43 + v25 + v7 )
            {
              v72 = WPP_GLOBAL_Control;
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
              {
                v73 = 40i64;
LABEL_310:
                WPP_SF_(*((_QWORD *)v72 + 2), v73, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
              }
              return 2148074278i64;
            }
            v23 += v7 + v43;
          }
          else if ( !*((_BYTE *)this + 233) || v22 == 20 )
          {
            v23 += v7;
            v25 -= v7;
          }
          if ( (((_DWORD)v15 - 20) & 0xFFFFFFFC) == 0 && (_DWORD)v15 != 21 )
            *((_BYTE *)this + 473) = 0;
          v27 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, _QWORD, unsigned __int8 *, _QWORD))(*(_QWORD *)this
                                                                                                + 464i64))(
                  this,
                  v22,
                  v23,
                  v25);
          if ( v27 )
            break;
          if ( v85 )
            DTlsMessage::`scalar deleting destructor'(v85);
          v23 = 0i64;
          v24 = 0;
          v82 = v108;
          if ( (*((_DWORD *)this + 16) & 0x3000) != 0 && v108 == 20 )
          {
            v68 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)this + 488i64))(
                    this,
                    0i64,
                    0i64,
                    0i64);
            v27 = v68;
            if ( !v68 )
            {
LABEL_42:
              v12 = WPP_GLOBAL_Control;
LABEL_44:
              v13 = v90;
              goto LABEL_45;
            }
            if ( v68 == -2146893018 || v68 == -2146893048 )
            {
              CSslContext::SetErrorAndFatalAlert((__int64)this, 904, v68, 0xAu);
              return v27;
            }
            return v27;
          }
          if ( !*((_BYTE *)this + 233) )
            goto LABEL_42;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 54i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          }
          v69 = DTlsHandshakeQueue::GetNextReadyHandshakeMsg(*((DTlsMsgMgr ***)this + 73), v26, v28);
          v85 = v69;
          v21 = (__int64)v69;
          if ( v69 )
          {
            v22 = *((_DWORD *)v69 + 16);
            v23 = (unsigned __int8 *)*((_QWORD *)v69 + 5);
            v24 = *((_DWORD *)v69 + 5);
            v82 = v22;
          }
          else
          {
            v22 = v108;
          }
          v12 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 55i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids, v22);
            v12 = WPP_GLOBAL_Control;
            v22 = v82;
            v21 = (__int64)v85;
          }
          v25 = v24;
          if ( !v23 )
            goto LABEL_44;
          LODWORD(v15) = v108;
        }
        if ( (*((_DWORD *)this + 34) & 0x40000) != 0 )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 41i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          }
          *((_DWORD *)a2 + 1) = v94;
        }
        else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
               && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        {
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 42i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids, v27);
        }
        return v27;
      }
LABEL_45:
      v29 = v84;
    }
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
    {
      WPP_SF_d(*((_QWORD *)v12 + 2), 0x2Bu, (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids, v24);
      v12 = WPP_GLOBAL_Control;
    }
    v30 = *((_DWORD *)this + 17);
    v13 += v29 + v7;
    v14 = v88 - (v29 + v7);
    v90 = v13;
    v88 = v14;
    if ( (unsigned int)(v30 - 91) <= 0xB )
    {
      if ( !*((_BYTE *)this + 233) )
        return CSsl3TlsContext::GenerateResponseCommon(this, a3);
      ResponseCommon = CSsl3TlsContext::GenerateResponseCommon(this, (struct SPBuffer *)&v91);
      v30 = *((_DWORD *)this + 17);
      v10 = ResponseCommon;
      v12 = WPP_GLOBAL_Control;
    }
    else
    {
      v10 = 0;
    }
    v81 = v10;
    if ( v30 == 4 || v30 == 79 || !v14 )
      goto LABEL_104;
    v5 = a2;
  }
  if ( v87 )
    goto LABEL_104;
  *((_DWORD *)v5 + 1) = v7;
  v31 = *((_QWORD *)this + 16);
  if ( !*(_WORD *)(v31 + 34) )
  {
    *(_WORD *)(v31 + 34) = 13;
    *(_DWORD *)(v31 + 36) = -2146893032;
  }
  memset_0(v102, 0, 0x6E8ui64);
  v32 = *((_QWORD *)this + 1);
  if ( v32 )
    v3 = *(_DWORD *)(v32 + 28);
  v33 = *((unsigned __int16 *)this + 17);
  v34 = *((_QWORD *)this + 17);
  v35 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
  v104 = *((_DWORD *)this + 4);
  v103 = v3;
  if ( v32 )
  {
    v36 = *((_QWORD *)this + 11);
    if ( v36 )
    {
      v37 = *((_QWORD *)this + 15);
      v38 = *(_DWORD *)(v32 + 32);
      if ( v37 )
      {
        if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
        {
          *(_DWORD *)(v37 + 48) = *(_DWORD *)(v36 + 8);
          if ( v38 == 43522 || v38 == 41984 )
          {
            KeyExchangeInfo = GetKeyExchangeInfo(v38);
            if ( KeyExchangeInfo )
            {
              v78[13] = *((_DWORD *)KeyExchangeInfo + 8);
              v78[14] = *((_DWORD *)KeyExchangeInfo + 10);
              if ( v77 == 43522 )
                v78[15] = *((_DWORD *)KeyExchangeInfo + 12);
            }
          }
        }
      }
    }
  }
  v39 = *((_QWORD *)this + 15);
  v40 = v39;
  if ( v39 && v35 )
  {
    *(_DWORD *)(v39 + 36) = v104;
    *(_DWORD *)(v39 + 104) = -2146893032;
    *(_DWORD *)(v39 + 112) = 13;
    *(_DWORD *)(v39 + 32) = v3;
    *(_DWORD *)(v39 + 40) = v33;
    *(_QWORD *)(v39 + 128) = v34;
    v40 = *((_QWORD *)this + 15);
  }
  if ( v40
    && v35
    && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_SSSdiiDDDDDddiDDd(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      *(unsigned __int16 *)(v40 + 66),
      *(unsigned __int16 *)(v40 + 64),
      L"Error",
      (const wchar_t *)(v40 + 152),
      (const wchar_t *)(v40 + 664),
      *(_DWORD *)(v40 + 24),
      *(_QWORD *)(v40 + 120),
      *(_QWORD *)(v40 + 128),
      *(_DWORD *)(v40 + 32),
      *(_DWORD *)(v40 + 36),
      *(_DWORD *)(v40 + 40),
      *(_DWORD *)(v40 + 44),
      *(_DWORD *)(v40 + 48),
      *(_WORD *)(v40 + 64),
      *(_WORD *)(v40 + 66),
      *(_QWORD *)(v40 + 96),
      *(_DWORD *)(v40 + 104),
      *(unsigned __int8 *)(v40 + 108),
      *(_DWORD *)(v40 + 112));
  }
  return 2148074264i64;
}
// 18003B4F3: conditional instruction was optimized away because rsi.8!=0
// 180011D98: variable 'v35' is possibly undefined
// 18003B056: variable 'v79' is possibly undefined
// 18003B0B2: variable 'v80' is possibly undefined
// 18003B464: variable 'v21' is possibly undefined
// 18003B464: variable 'v15' is possibly undefined
// 18003B6C0: variable 'v26' is possibly undefined
// 18003B6C0: variable 'v28' is possibly undefined
// 18003BB51: variable 'v78' is possibly undefined
// 18003BB63: variable 'v77' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 1800119B0: using guessed type char var_730[8];

//----- (0000000180011F40) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::GenerateResponseCommon(CSsl3TlsContext *this, struct SPBuffer *a2)
{
  __int64 result; // rax
  __int64 v5; // r8
  int v6; // ecx
  unsigned int v7; // edi
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  CCipherMill *v12; // rcx
  __int64 v13; // rdx

  if ( !*((_QWORD *)this + 11) )
    return 1359i64;
  result = (*(__int64 (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 472i64))(this);
  if ( !(_DWORD)result )
  {
    v6 = *((_DWORD *)this + 17);
    if ( v6 >= 80 && v6 < 96 )
      goto LABEL_5;
    v8 = v6 - 2;
    if ( v8 )
    {
      v9 = v8 - 1;
      if ( !v9 )
      {
        v12 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_27;
        v13 = 47i64;
        goto LABEL_26;
      }
      v10 = v9 - 2;
      if ( v10 )
      {
        v11 = v10 - 74;
        if ( v11 )
        {
          if ( v11 != 17 )
          {
LABEL_5:
            v7 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, struct SPBuffer *))(*(_QWORD *)this + 424i64))(this, a2);
LABEL_6:
            if ( !v7 )
              return v7;
            if ( (v7 & 0x80000000) == 0 )
            {
              if ( (v7 & 0x1FFF0000) == 589824 )
                return v7;
            }
            else if ( v7 == -2146893032 || v7 == -2146893023 || v7 == -2146892950 || v7 == -2146892949 )
            {
              return v7;
            }
            v12 = WPP_GLOBAL_Control;
LABEL_42:
            if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
              WPP_SF_(*((_QWORD *)v12 + 2), 49i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
            *((_DWORD *)this + 17) = 96;
            return v7;
          }
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 45i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
          }
          v7 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, struct SPBuffer *, _QWORD, _QWORD))(*(_QWORD *)this + 392i64))(
                 this,
                 a2,
                 *((unsigned __int8 *)this + 96),
                 *((unsigned __int8 *)this + 97));
          *((_WORD *)this + 48) = 0;
LABEL_19:
          *((_DWORD *)this + 17) = 3;
          goto LABEL_6;
        }
        v12 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
        {
LABEL_27:
          v7 = -2146893033;
          goto LABEL_42;
        }
        v13 = 48i64;
LABEL_26:
        WPP_SF_(*((_QWORD *)v12 + 2), v13, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        v12 = WPP_GLOBAL_Control;
        goto LABEL_27;
      }
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 46i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    LOBYTE(v5) = 1;
    v7 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, struct SPBuffer *, __int64, _QWORD))(*(_QWORD *)this + 392i64))(
           this,
           a2,
           v5,
           0i64);
    if ( (*((_DWORD *)this + 16) & 0x3000) != 0 && *((_DWORD *)this + 17) == 2 )
    {
      *((_DWORD *)this + 17) = 79;
      goto LABEL_6;
    }
    goto LABEL_19;
  }
  return result;
}
// 18003BDFC: variable 'v5' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180011FF0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::UnwrapMessage(CSsl3TlsContext *this, struct SPBuffer *a2)
{
  __int16 v4; // r9
  int v5; // r8d
  int v6; // r10d
  _BYTE *v7; // rdx
  _BYTE *v8; // rbp
  int v9; // ecx
  int v10; // eax
  unsigned __int64 v11; // r14
  __int64 *v12; // rax
  __int64 v13; // rcx
  unsigned int v14; // eax
  int v15; // esi
  _BYTE *v16; // rcx
  __int64 v18; // rcx
  __int64 v19; // rax
  int UserKeys; // eax
  unsigned int v21; // r14d
  unsigned __int8 *v22; // rcx
  bool v23; // zf
  char v24; // cl
  __int16 v25; // [rsp+80h] [rbp+8h]

  v25 = 0;
  v4 = *((_WORD *)this + 16) & 2;
  if ( v4 )
  {
    v5 = *((_DWORD *)this + 11);
    v6 = *((_DWORD *)this + 12);
  }
  else
  {
    v5 = 0;
    v6 = 0;
  }
  v7 = (_BYTE *)*((_QWORD *)a2 + 1);
  v8 = &v7[*((unsigned int *)this + 15) + v5];
  if ( v7[1] == 0xFE && ((unsigned __int8)v7[2] | ((unsigned __int8)v7[1] << 8)) <= 0xFEFFu )
  {
    v9 = (unsigned __int8)v7[11];
    v10 = (unsigned __int8)v7[12];
  }
  else
  {
    v9 = (unsigned __int8)v7[3];
    v10 = (unsigned __int8)v7[4];
  }
  if ( (v10 | (unsigned int)(v9 << 8)) < v6 + v5 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 959, -2146893018, 0x32u);
    return 2148074278i64;
  }
  if ( !*((_QWORD *)this + 18) )
  {
    if ( v4 )
    {
      v19 = *((_QWORD *)this + 1);
      if ( v19 )
      {
        if ( *(_DWORD *)(v19 + 28) )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids);
          }
          UserKeys = RemotelyGetUserKeys(this, 1u);
          v21 = UserKeys;
          if ( UserKeys )
          {
            CSslContext::SetErrorAndFatalAlert((__int64)this, 961, UserKeys, 0x50u);
            return v21;
          }
        }
      }
    }
  }
  if ( *((_BYTE *)this + 233) )
  {
    v22 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
    v11 = v22[10] | ((v22[9] | ((v22[8] | ((v22[7] | ((v22[6] | ((v22[5] | ((v22[4] | ((unsigned __int64)v22[3] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
  }
  else
  {
    v11 = *((_QWORD *)this + 22);
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_Di(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x10u,
      (__int64)&WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids,
      *(_DWORD *)a2,
      v11);
  v12 = (__int64 *)*((_QWORD *)this + 1);
  if ( v12 )
    v13 = *v12;
  else
    v13 = 0i64;
  v14 = SslDecryptPacket(v13, *((_QWORD *)this + 18), *((_QWORD *)a2 + 1));
  v15 = v14;
  if ( v14 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 17i64, &WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids, v14);
    if ( *((_DWORD *)this + 9) >= 0x302u && (*((_DWORD *)this + 16) & 0x800A00AA) != 0 )
    {
      CSslContext::SetError((__int64)this, 962, v15);
      return 2148074278i64;
    }
    else
    {
      CSslContext::SetErrorAndFatalAlert((__int64)this, 960, v15, 0x14u);
      return 2148074288i64;
    }
  }
  else
  {
    if ( (*((_DWORD *)this + 16) & 0x3000) != 0 )
    {
      LODWORD(v18) = 0;
      do
      {
        v23 = (_DWORD)v18 == 1;
        v18 = (unsigned int)(v18 - 1);
        v25 = v18;
      }
      while ( !v23 && !v8[v18] );
      v24 = v8[v18];
      if ( !v24 )
      {
        CSslContext::SetErrorAndFatalAlert((__int64)this, 960, -2146893048, 0xAu);
        return 2148074248i64;
      }
      **((_BYTE **)a2 + 1) = v24;
    }
    v16 = (_BYTE *)*((_QWORD *)a2 + 1);
    if ( *((_BYTE *)this + 233) )
    {
      v16[11] = HIBYTE(v25);
      v16[12] = v25;
    }
    else
    {
      v16[3] = HIBYTE(v25);
      v16[4] = v25;
      ++*((_QWORD *)this + 22);
    }
    return 0i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800984E0: using guessed type __int64 __fastcall SslDecryptPacket(_QWORD, _QWORD, _QWORD);

//----- (0000000180012184) ----------------------------------------------------
void __fastcall CSslContext::SetError(__int64 a1, int a2, int a3)
{
  __int64 v3; // rax
  __int64 v7; // r8
  __int64 v8; // rcx
  int v9; // edi
  int v10; // r14d
  __int64 v11; // r15
  __int64 v12; // rcx
  unsigned __int64 v13; // rax
  __int64 v14; // rax
  char v15[8]; // [rsp+20h] [rbp-708h] BYREF
  unsigned __int64 v16; // [rsp+28h] [rbp-700h]

  v3 = *(_QWORD *)(a1 + 128);
  if ( !*(_WORD *)(v3 + 34) )
  {
    *(_WORD *)(v3 + 34) = a2;
    *(_DWORD *)(v3 + 36) = a3;
  }
  memset_0(v15, 0, 0x6E8ui64);
  v8 = *(_QWORD *)(a1 + 8);
  if ( v8 )
  {
    v9 = *(_DWORD *)(v8 + 28);
    LODWORD(v16) = v9;
  }
  else
  {
    v9 = 0;
    LODWORD(v16) = 0;
  }
  v10 = *(unsigned __int16 *)(a1 + 34);
  v11 = *(_QWORD *)(a1 + 136);
  HIDWORD(v16) = *(_DWORD *)(a1 + 16);
  if ( v8 )
  {
    v14 = *(_QWORD *)(a1 + 88);
    if ( v14 )
      CSchannelTelemetryContext::LogKeyExchange(
        *(CSchannelTelemetryContext **)(a1 + 120),
        *(_DWORD *)(v8 + 32),
        *(_DWORD *)(v14 + 8));
  }
  v12 = *(_QWORD *)(a1 + 120);
  if ( v12 )
  {
    if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    {
      v13 = HIDWORD(v16);
      *(_DWORD *)(v12 + 104) = a3;
      *(_DWORD *)(v12 + 112) = a2;
      *(_DWORD *)(v12 + 32) = v9;
      *(_DWORD *)(v12 + 36) = v13;
      *(_DWORD *)(v12 + 40) = v10;
      *(_QWORD *)(v12 + 128) = v11;
      if ( a3 != -2146893032 )
        CSchannelTelemetryContext::WriteEvent((CSchannelTelemetryContext *)v12, 1, v7);
    }
  }
  CSchannelTelemetryContext::LogDebugTraceHandshakeInfo(*(CSchannelTelemetryContext **)(a1 + 120), L"Error");
}
// 18001229B: variable 'v7' is possibly undefined
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 180012184: using guessed type char var_708[8];

//----- (00000001800122B0) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::SetStateConnected(CSchannelTelemetryContext **this)
{
  CSchannelTelemetryContext *v2; // rcx
  CSchannelTelemetryContext *v3; // rax
  char Src[8]; // [rsp+20h] [rbp-DE8h] BYREF
  int v5; // [rsp+28h] [rbp-DE0h]
  int v6; // [rsp+2Ch] [rbp-DDCh]
  int v7; // [rsp+30h] [rbp-DD8h]
  CSchannelTelemetryContext *v8; // [rsp+88h] [rbp-D80h]
  LARGE_INTEGER v9[223]; // [rsp+710h] [rbp-6F8h] BYREF

  CSsl3TlsContext::SetStateConnected((CSsl3TlsContext *)this);
  memset_0(Src, 0, 0x6E8ui64);
  v2 = this[1];
  if ( v2 )
    v5 = *((_DWORD *)v2 + 7);
  v6 = *((_DWORD *)this + 4);
  v7 = *((unsigned __int16 *)this + 17);
  v8 = this[17];
  if ( v2 )
  {
    v3 = this[11];
    if ( v3 )
      CSchannelTelemetryContext::LogKeyExchange(this[15], *((_DWORD *)v2 + 8), *((_DWORD *)v3 + 2));
  }
  memcpy_0(v9, Src, 0x6E8ui64);
  CSchannelTelemetryContext::LogHandshakeEnd((LARGE_INTEGER *)this[15], v9);
  CSchannelTelemetryContext::LogDebugTraceHandshakeInfo(this[15], L"Client");
}
// 1800122B0: using guessed type char Src[8];
// 1800122B0: using guessed type LARGE_INTEGER var_6F8[223];

//----- (0000000180012368) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::LogDebugTraceHandshakeInfo(
        CSchannelTelemetryContext *this,
        unsigned __int16 *const a2)
{
  int v2; // [rsp+88h] [rbp-20h]
  int v3; // [rsp+90h] [rbp-18h]
  int v4; // [rsp+98h] [rbp-10h]

  if ( this
    && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized
    && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    v4 = *((_DWORD *)this + 28);
    v3 = *((unsigned __int8 *)this + 108);
    v2 = *((_DWORD *)this + 26);
    WPP_SF_SSSdiiDDDDDddiDDd(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      *((unsigned __int16 *)this + 33),
      *((unsigned __int16 *)this + 32),
      a2,
      (const wchar_t *)this + 76,
      (const wchar_t *)this + 332,
      *((_DWORD *)this + 6),
      *((_QWORD *)this + 15),
      *((_QWORD *)this + 16),
      *((_DWORD *)this + 8),
      *((_DWORD *)this + 9),
      *((_DWORD *)this + 10),
      *((_DWORD *)this + 11),
      *((_DWORD *)this + 12),
      *((_WORD *)this + 32),
      *((_WORD *)this + 33),
      *((_QWORD *)this + 12),
      v2,
      v3,
      v4);
  }
}
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (00000001800123C0) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::LogHandshakeEnd(LARGE_INTEGER *a1, LARGE_INTEGER *a2)
{
  __int64 v3; // r8
  __int64 v4; // rax
  bool v5; // zf

  if ( a1 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
  {
    a1[4].LowPart = a2[1].LowPart;
    a1[4].HighPart = a2[1].HighPart;
    a1[5].LowPart = a2[2].LowPart;
    a1[16] = a2[13];
    QueryPerformanceCounter(a1 + 11);
    v4 = 1000 * (a1[11].QuadPart - a1[10].QuadPart);
    a1[12].QuadPart = v4;
    v5 = a1[13].LowPart == -2146893032;
    a1[12].QuadPart = v4 / CSchannelTelemetryContext::m_liPerfCtrFreq.QuadPart;
    if ( v5 )
    {
      a1[13].LowPart = 0;
      a1[14].LowPart = 0;
    }
    CSchannelTelemetryContext::WriteEvent((CSchannelTelemetryContext *)a1, 0, v3);
  }
}
// 180012440: variable 'v3' is possibly undefined
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180012458) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::LogKeyExchange(CSchannelTelemetryContext *this, int a2, int a3)
{
  struct kexch *KeyExchangeInfo; // rax
  _DWORD *v4; // r9
  int v5; // r10d
  int v6; // r11d

  if ( this )
  {
    if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    {
      *((_DWORD *)this + 12) = a3;
      if ( a2 == 43522 || a2 == 41984 )
      {
        KeyExchangeInfo = GetKeyExchangeInfo(a2);
        if ( KeyExchangeInfo )
        {
          v4[13] = *((_DWORD *)KeyExchangeInfo + 8);
          v4[14] = *((_DWORD *)KeyExchangeInfo + 10);
          if ( v5 == v6 )
            v4[15] = *((_DWORD *)KeyExchangeInfo + 12);
        }
      }
    }
  }
}
// 18003C168: variable 'v4' is possibly undefined
// 18003C176: variable 'v5' is possibly undefined
// 18003C176: variable 'v6' is possibly undefined
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (00000001800124A0) ----------------------------------------------------
void __fastcall CSsl3TlsContext::SetStateConnected(CSsl3TlsContext *this)
{
  __int64 v1; // rax
  unsigned __int16 v3; // ax
  DTlsHandshakeQueue *v4; // rcx

  v1 = *(_QWORD *)this;
  *((_DWORD *)this + 17) = 4;
  (*(void (**)(void))(v1 + 456))();
  if ( *((_BYTE *)this + 233) )
  {
    v3 = CSslContext::computeMaxPayload(this, *((unsigned __int16 *)this + 108));
    v4 = (DTlsHandshakeQueue *)*((_QWORD *)this + 73);
    *((_WORD *)this + 109) = v3;
    DTlsHandshakeQueue::DtlsHandshakeDone(v4);
    **((_DWORD **)this + 72) = 0;
    *((_WORD *)this + 110) = 0;
  }
}

//----- (00000001800124F0) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::WriteEvent(CSchannelTelemetryContext *this, char a2, __int64 a3)
{
  const WCHAR *v3; // rdi
  int v6; // eax
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int16 v10; // [rsp+F0h] [rbp-80h] BYREF
  __int16 v11; // [rsp+F2h] [rbp-7Eh] BYREF
  int v12; // [rsp+F4h] [rbp-7Ch] BYREF
  int v13; // [rsp+F8h] [rbp-78h] BYREF
  int v14; // [rsp+FCh] [rbp-74h] BYREF
  int v15; // [rsp+100h] [rbp-70h] BYREF
  int v16; // [rsp+104h] [rbp-6Ch] BYREF
  int v17; // [rsp+108h] [rbp-68h] BYREF
  int v18; // [rsp+10Ch] [rbp-64h] BYREF
  int v19; // [rsp+110h] [rbp-60h] BYREF
  int v20; // [rsp+114h] [rbp-5Ch] BYREF
  int v21; // [rsp+118h] [rbp-58h] BYREF
  int v22; // [rsp+11Ch] [rbp-54h] BYREF
  int v23; // [rsp+120h] [rbp-50h] BYREF
  __int64 v24; // [rsp+128h] [rbp-48h] BYREF
  const WCHAR *v25; // [rsp+130h] [rbp-40h] BYREF
  __int64 v26; // [rsp+138h] [rbp-38h] BYREF
  __int64 v27; // [rsp+140h] [rbp-30h] BYREF
  __int64 v28; // [rsp+148h] [rbp-28h] BYREF
  __int16 v29; // [rsp+150h] [rbp-20h]
  __int64 v30; // [rsp+158h] [rbp-18h] BYREF
  const WCHAR *v31; // [rsp+160h] [rbp-10h] BYREF
  const WCHAR *v32; // [rsp+168h] [rbp-8h] BYREF
  const WCHAR *v33; // [rsp+170h] [rbp+0h] BYREF
  __int16 v34; // [rsp+178h] [rbp+8h]
  char v35; // [rsp+1A0h] [rbp+30h] BYREF
  char v36; // [rsp+1B0h] [rbp+40h] BYREF
  __int16 v37; // [rsp+1B8h] [rbp+48h] BYREF

  v3 = (const WCHAR *)((char *)this + 152);
  if ( this == (CSchannelTelemetryContext *)-152i64
    || !wcsstr(v3, L".data.microsoft.com") && !wcsstr(v3, L".telemetry.microsoft.com") )
  {
    v6 = *((_DWORD *)this + 3);
    if ( a2 )
    {
      if ( v6 )
      {
        if ( v6 == 1
          && (unsigned int)dword_180091480 > 5
          && (qword_180091490 & 0x400000000000i64) != 0
          && (qword_180091498 & 0x400000000000i64) == qword_180091498 )
        {
          v23 = *((_DWORD *)this + 395);
          v28 = (__int64)this + 1176;
          v29 = *((_WORD *)this + 788);
          v22 = *((_DWORD *)this + 11);
          v21 = *((_DWORD *)this + 28);
          v9 = *((unsigned __int16 *)this + 892);
          v35 = *((_BYTE *)this + 108);
          v20 = *((_DWORD *)this + 26);
          v19 = *((_DWORD *)this + 15);
          v18 = *((_DWORD *)this + 14);
          v17 = *((_DWORD *)this + 13);
          v16 = *((_DWORD *)this + 12);
          v15 = *((_DWORD *)this + 10);
          v14 = *((_DWORD *)this + 9);
          v33 = (const WCHAR *)((char *)this + 1584);
          v13 = *((_DWORD *)this + 18);
          v12 = *((_DWORD *)this + 17);
          v11 = *((_WORD *)this + 33);
          v10 = *((_WORD *)this + 32);
          v27 = *((_QWORD *)this + 16);
          v26 = *((_QWORD *)this + 15);
          v36 = *((_BYTE *)this + 24);
          v37 = v9;
          v34 = v9;
          v25 = (const WCHAR *)((char *)this + 664);
          v24 = 1i64;
          _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteAgg(_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),void const *>::Write<_tlgWrapperByVal<8>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<1>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<2>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperArray<4>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<1>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperArray<4>,_tlgWrapperByVal<4>>(
            v9,
            byte_1800847A6,
            a3,
            (__int64)&v24,
            &v25,
            (__int64)&v36,
            (__int64)&v26,
            (__int64)&v27,
            (__int64)&v10,
            (__int64)&v11,
            (__int64)&v12,
            (__int64)&v13,
            (__int64)&v33,
            (__int64)&v37,
            (__int64)&v14,
            (__int64)&v15,
            (__int64)&v16,
            (__int64)&v17,
            (__int64)&v18,
            (__int64)&v19,
            (__int64)&v20,
            (__int64)&v35,
            (__int64)&v21,
            (__int64)&v22,
            (__int64)&v28,
            (__int64)&v23);
        }
      }
      else if ( (unsigned int)dword_180091480 > 5
             && (qword_180091490 & 0x400000000000i64) != 0
             && (qword_180091498 & 0x400000000000i64) == qword_180091498 )
      {
        v12 = *((_DWORD *)this + 28);
        v35 = *((_BYTE *)this + 108);
        v13 = *((_DWORD *)this + 26);
        v14 = *((_DWORD *)this + 15);
        v15 = *((_DWORD *)this + 14);
        v8 = *((unsigned __int16 *)this + 892);
        v16 = *((_DWORD *)this + 13);
        v17 = *((_DWORD *)this + 12);
        v18 = *((_DWORD *)this + 10);
        v19 = *((_DWORD *)this + 9);
        v28 = (__int64)this + 1584;
        v20 = *((_DWORD *)this + 18);
        v21 = *((_DWORD *)this + 17);
        v10 = *((_WORD *)this + 33);
        v11 = *((_WORD *)this + 32);
        v30 = *((_QWORD *)this + 16);
        v31 = (const WCHAR *)*((_QWORD *)this + 15);
        v36 = *((_BYTE *)this + 24);
        v32 = (const WCHAR *)((char *)this + 664);
        v22 = *((_DWORD *)this + 8);
        v23 = bDomainJoined;
        v24 = *((_QWORD *)this + 12);
        v25 = (const WCHAR *)v24;
        v26 = v24;
        v37 = v8;
        v29 = v8;
        v33 = v3;
        v27 = 1i64;
        _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteAgg(_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),void const *>::Write<_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<1>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<2>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperArray<4>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<1>,_tlgWrapperByVal<4>>(
          v8,
          byte_1800843DE,
          a3,
          (__int64)&v27,
          (__int64)&v26,
          (__int64)&v25,
          (__int64)&v24,
          &v33,
          (__int64)&v23,
          (__int64)&v22,
          &v32,
          (__int64)&v36,
          (__int64)&v31,
          (__int64)&v30,
          (__int64)&v11,
          (__int64)&v10,
          (__int64)&v21,
          (__int64)&v20,
          (__int64)&v28,
          (__int64)&v37,
          (__int64)&v19,
          (__int64)&v18,
          (__int64)&v17,
          (__int64)&v16,
          (__int64)&v15,
          (__int64)&v14,
          (__int64)&v13,
          (__int64)&v35,
          (__int64)&v12);
      }
    }
    else if ( v6 )
    {
      if ( v6 == 1 )
        CSchannelTelemetryContext::WriteServerEvent(this);
    }
    else if ( (unsigned int)dword_180091480 > 5
           && (qword_180091490 & 0x400000000000i64) != 0
           && (qword_180091498 & 0x400000000000i64) == qword_180091498 )
    {
      v23 = *((_DWORD *)this + 28);
      v35 = *((_BYTE *)this + 108);
      v22 = *((_DWORD *)this + 26);
      v21 = *((_DWORD *)this + 15);
      v20 = *((_DWORD *)this + 14);
      v7 = *((unsigned __int16 *)this + 892);
      v19 = *((_DWORD *)this + 13);
      v18 = *((_DWORD *)this + 12);
      v17 = *((_DWORD *)this + 10);
      v16 = *((_DWORD *)this + 9);
      v28 = (__int64)this + 1584;
      v15 = *((_DWORD *)this + 18);
      v14 = *((_DWORD *)this + 17);
      v11 = *((_WORD *)this + 33);
      v10 = *((_WORD *)this + 32);
      v27 = *((_QWORD *)this + 16);
      v26 = *((_QWORD *)this + 15);
      v36 = *((_BYTE *)this + 24);
      v25 = (const WCHAR *)((char *)this + 664);
      v13 = *((_DWORD *)this + 8);
      v12 = bDomainJoined;
      v33 = (const WCHAR *)*((_QWORD *)this + 12);
      v32 = v33;
      v31 = v33;
      v37 = v7;
      v29 = v7;
      v24 = (__int64)v3;
      v30 = 1i64;
      _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteAgg(_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),void const *>::Write<_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<1>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<2>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperArray<4>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<1>,_tlgWrapperByVal<4>>(
        v7,
        byte_1800845BE,
        a3,
        (__int64)&v30,
        (__int64)&v31,
        (__int64)&v32,
        (__int64)&v33,
        (const WCHAR **)&v24,
        (__int64)&v12,
        (__int64)&v13,
        &v25,
        (__int64)&v36,
        (__int64)&v26,
        (__int64)&v27,
        (__int64)&v10,
        (__int64)&v11,
        (__int64)&v14,
        (__int64)&v15,
        (__int64)&v28,
        (__int64)&v37,
        (__int64)&v16,
        (__int64)&v17,
        (__int64)&v18,
        (__int64)&v19,
        (__int64)&v20,
        (__int64)&v21,
        (__int64)&v22,
        (__int64)&v35,
        (__int64)&v23);
    }
  }
}
// 18001277C: variable 'a3' is possibly undefined
// 1800843DE: using guessed type unsigned __int8 byte_1800843DE[480];
// 1800845BE: using guessed type unsigned __int8 byte_1800845BE[488];
// 1800847A6: using guessed type unsigned __int8 byte_1800847A6[437];
// 180091490: using guessed type __int64 qword_180091490;
// 180091498: using guessed type __int64 qword_180091498;
// 180092648: using guessed type int bDomainJoined;

//----- (000000018001278C) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteAgg(_tlgProvider_t const *,void const *,void const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),void const *>::Write<_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<1>,_tlgWrapperByVal<8>,_tlgWrapperByVal<8>,_tlgWrapperByVal<2>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperArray<4>,_tlgWrapperByVal<2>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<1>,_tlgWrapperByVal<4>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        const WCHAR **a8,
        __int64 a9,
        __int64 a10,
        const WCHAR **a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16,
        __int64 a17,
        __int64 a18,
        __int64 a19,
        __int64 a20,
        __int64 a21,
        __int64 a22,
        __int64 a23,
        __int64 a24,
        __int64 a25,
        __int64 a26,
        __int64 a27,
        __int64 a28,
        __int64 a29)
{
  __int64 v30; // rcx
  const WCHAR *v31; // rdx
  __int64 v32; // rax
  int v33; // r8d
  const WCHAR *v34; // rdx
  int v35; // eax
  ULONG result; // eax
  unsigned __int8 AggregateFieldTypes; // al
  EVENT_DESCRIPTOR EventDescriptor; // [rsp+38h] [rbp-D0h] BYREF
  unsigned int v39; // [rsp+48h] [rbp-C0h]
  struct _EVENT_DATA_DESCRIPTOR UserData; // [rsp+58h] [rbp-B0h] BYREF
  unsigned __int8 *v41; // [rsp+68h] [rbp-A0h]
  int v42; // [rsp+70h] [rbp-98h]
  int v43; // [rsp+74h] [rbp-94h]
  __int64 v44; // [rsp+78h] [rbp-90h]
  __int64 v45; // [rsp+80h] [rbp-88h]
  __int64 v46; // [rsp+88h] [rbp-80h]
  __int64 v47; // [rsp+90h] [rbp-78h]
  __int64 v48; // [rsp+98h] [rbp-70h]
  __int64 v49; // [rsp+A0h] [rbp-68h]
  __int64 v50; // [rsp+A8h] [rbp-60h]
  __int64 v51; // [rsp+B0h] [rbp-58h]
  const WCHAR *v52; // [rsp+B8h] [rbp-50h]
  int v53; // [rsp+C0h] [rbp-48h]
  int v54; // [rsp+C4h] [rbp-44h]
  __int64 v55; // [rsp+C8h] [rbp-40h]
  __int64 v56; // [rsp+D0h] [rbp-38h]
  __int64 v57; // [rsp+D8h] [rbp-30h]
  __int64 v58; // [rsp+E0h] [rbp-28h]
  const WCHAR *v59; // [rsp+E8h] [rbp-20h]
  int v60; // [rsp+F0h] [rbp-18h]
  int v61; // [rsp+F4h] [rbp-14h]
  __int64 v62; // [rsp+F8h] [rbp-10h]
  __int64 v63; // [rsp+100h] [rbp-8h]
  __int64 v64; // [rsp+108h] [rbp+0h]
  __int64 v65; // [rsp+110h] [rbp+8h]
  __int64 v66; // [rsp+118h] [rbp+10h]
  __int64 v67; // [rsp+120h] [rbp+18h]
  __int64 v68; // [rsp+128h] [rbp+20h]
  __int64 v69; // [rsp+130h] [rbp+28h]
  __int64 v70; // [rsp+138h] [rbp+30h]
  __int64 v71; // [rsp+140h] [rbp+38h]
  __int64 v72; // [rsp+148h] [rbp+40h]
  __int64 v73; // [rsp+150h] [rbp+48h]
  __int64 v74; // [rsp+158h] [rbp+50h]
  __int64 v75; // [rsp+160h] [rbp+58h]
  __int64 v76; // [rsp+168h] [rbp+60h]
  __int64 v77; // [rsp+170h] [rbp+68h]
  __int64 v78; // [rsp+178h] [rbp+70h]
  int v79; // [rsp+180h] [rbp+78h]
  int v80; // [rsp+184h] [rbp+7Ch]
  __int64 v81; // [rsp+188h] [rbp+80h]
  __int64 v82; // [rsp+190h] [rbp+88h]
  __int64 v83; // [rsp+198h] [rbp+90h]
  __int64 v84; // [rsp+1A0h] [rbp+98h]
  __int64 v85; // [rsp+1A8h] [rbp+A0h]
  __int64 v86; // [rsp+1B0h] [rbp+A8h]
  __int64 v87; // [rsp+1B8h] [rbp+B0h]
  __int64 v88; // [rsp+1C0h] [rbp+B8h]
  __int64 v89; // [rsp+1C8h] [rbp+C0h]
  __int64 v90; // [rsp+1D0h] [rbp+C8h]
  __int64 v91; // [rsp+1D8h] [rbp+D0h]
  __int64 v92; // [rsp+1E0h] [rbp+D8h]
  __int64 v93; // [rsp+1E8h] [rbp+E0h]
  __int64 v94; // [rsp+1F0h] [rbp+E8h]
  __int64 v95; // [rsp+1F8h] [rbp+F0h]
  __int64 v96; // [rsp+200h] [rbp+F8h]
  __int64 v97; // [rsp+208h] [rbp+100h]
  __int64 v98; // [rsp+210h] [rbp+108h]
  __int64 v99; // [rsp+218h] [rbp+110h]
  __int64 v100; // [rsp+220h] [rbp+118h]

  v99 = a29;
  v97 = a28;
  v95 = a27;
  v93 = a26;
  v91 = a25;
  v89 = a24;
  v87 = a23;
  v85 = a22;
  v83 = a21;
  v81 = a20;
  v100 = 4i64;
  v98 = 1i64;
  v96 = 4i64;
  v94 = 4i64;
  v78 = *(_QWORD *)a19;
  v79 = 4 * *(unsigned __int16 *)(a19 + 8);
  v74 = a18;
  v72 = a17;
  v70 = a16;
  v68 = a15;
  v66 = a14;
  v64 = a13;
  v62 = a12;
  v76 = a19 + 8;
  v30 = -1i64;
  v92 = 4i64;
  v90 = 4i64;
  v31 = *a11;
  v88 = 4i64;
  v86 = 4i64;
  v84 = 4i64;
  v82 = 2i64;
  v77 = 2i64;
  v80 = 0;
  v75 = 4i64;
  v73 = 4i64;
  v71 = 2i64;
  v69 = 2i64;
  v67 = 8i64;
  v65 = 8i64;
  v63 = 1i64;
  if ( v31 )
  {
    v32 = -1i64;
    do
      ++v32;
    while ( v31[v32] );
    v33 = 2 * v32 + 2;
  }
  else
  {
    v31 = &Class;
    v33 = 2;
  }
  v57 = a10;
  v55 = a9;
  v59 = v31;
  v60 = v33;
  v61 = 0;
  v34 = *a8;
  v58 = 4i64;
  v56 = 4i64;
  if ( v34 )
  {
    do
      ++v30;
    while ( v34[v30] );
    v35 = 2 * v30 + 2;
  }
  else
  {
    v34 = &Class;
    v35 = 2;
  }
  v53 = v35;
  v50 = a7;
  v48 = a6;
  v46 = a5;
  *(_DWORD *)&EventDescriptor.Id = *a2 << 24;
  *(_DWORD *)&EventDescriptor.Level = *(unsigned __int16 *)(a2 + 1);
  v52 = v34;
  v54 = 0;
  EventDescriptor.Keyword = *(_QWORD *)(a2 + 3);
  UserData.Ptr = (ULONGLONG)off_180091488;
  v51 = 8i64;
  v49 = 8i64;
  v47 = 8i64;
  v44 = a4;
  v45 = 8i64;
  UserData.Size = *(unsigned __int16 *)off_180091488;
  v42 = *(unsigned __int16 *)(a2 + 11);
  v41 = a2 + 11;
  UserData.Reserved = 2;
  v43 = 1;
  v39 = (unsigned int)&TraceLoggingMetadataEnd - (unsigned int)&TraceLoggingMetadata;
  result = -1073741811;
  if ( (void (__fastcall *)(const struct _GUID *, unsigned int, __int64, __int64, unsigned __int64, struct _EVENT_FILTER_DESCRIPTOR *, _QWORD *))qword_1800914A8 == TlgAggregateInternalRegisteredProviderEtwCallback )
  {
    AggregateFieldTypes = ExtractAggregateFieldTypes(
                            (__int64)TlgAggregateInternalRegisteredProviderEtwCallback,
                            (__int64)&UserData);
    if ( AggregateFieldTypes )
      return InsertEventEntryInLookUpTable(
               (__int64)&dword_180091480,
               (__int128 *)&EventDescriptor,
               0x1Du,
               (__int64)&UserData,
               AggregateFieldTypes);
    else
      return EventWriteTransfer_0(RegHandle, &EventDescriptor, 0i64, 0i64, 0x1Du, &UserData);
  }
  return result;
}
// 180091488: using guessed type void *off_180091488;
// 1800914A8: using guessed type __int64 qword_1800914A8;

//----- (0000000180012AF0) ----------------------------------------------------
__int64 __fastcall InsertEventEntryInLookUpTable(
        __int64 a1,
        __int128 *a2,
        unsigned __int8 a3,
        __int64 a4,
        unsigned __int8 a5)
{
  __int64 v5; // rbx
  signed __int64 v7; // rdi
  unsigned int v9; // ebp
  int v10; // r14d
  volatile signed __int64 *i; // rsi
  unsigned int v12; // eax
  unsigned int v13; // eax
  __int64 v15; // rsi
  int v16; // eax
  unsigned __int8 v17; // dl
  unsigned int v18; // r10d
  signed __int64 v19; // r8
  __int64 v20; // rax
  int v21; // r11d
  volatile signed __int64 *v22; // r9
  volatile signed __int64 v23; // rtt
  __int64 v24; // [rsp+70h] [rbp+8h] BYREF
  __int128 *v25; // [rsp+78h] [rbp+10h]

  v25 = a2;
  v5 = *(_QWORD *)(a1 + 48);
  v7 = 0i64;
  v24 = 0i64;
  v9 = 0;
  v10 = ComputeEventEntryHash(a5, a3, a4);
  AcquireSRWLockShared((PSRWLOCK)(v5 + 264));
  for ( i = (volatile signed __int64 *)(v5 + 8i64 * (v10 & 0x1F));
        ;
        i = (volatile signed __int64 *)((((__int64)v16 >> 63) & 0xFFFFFFFFFFFFFFF8ui64) + v15 + 32) )
  {
    if ( !*i )
    {
      if ( *(_DWORD *)(v5 + 256) >= 0x400u )
      {
        ++*(_DWORD *)(v5 + 300);
        v9 = 234;
        goto LABEL_11;
      }
      if ( !v7 )
      {
        v12 = CreateNewEventEntry(v25, a3, a4, a5, v10, &v24);
        v7 = v24;
        v9 = v12;
        if ( !v24 )
        {
          if ( v12 == 8 )
            ++*(_DWORD *)(v5 + 304);
          else
            ++*(_DWORD *)(v5 + 308);
          goto LABEL_11;
        }
      }
      if ( !_InterlockedCompareExchange64(i, v7, 0i64) )
      {
        v24 = 0i64;
        if ( _InterlockedIncrement((volatile signed __int32 *)(v5 + 256)) == 1 )
          EnableFlushTimer(*(struct _TP_TIMER **)(v5 + 344), *(_DWORD *)(v5 + 352));
        v13 = *(_DWORD *)(v5 + 256);
        v7 = v24;
        if ( *(_DWORD *)(v5 + 288) < v13 )
          *(_DWORD *)(v5 + 288) = v13;
        goto LABEL_11;
      }
      v7 = v24;
    }
    v15 = *i;
    v16 = v10 == *(_DWORD *)(v15 + 40) ? CompareEventEntry(a3, a4, v15) : v10 - *(_DWORD *)(v15 + 40);
    if ( !v16 )
      break;
  }
  if ( v15 )
  {
    v17 = 2;
    v18 = a5 + 2;
    if ( v18 > 2 )
    {
      do
      {
        v19 = **(_QWORD **)(a4 + 16i64 * v17);
        v20 = *(_QWORD *)(v15 + 16);
        v21 = *(unsigned __int8 *)(v20 + 16i64 * v17 + 13);
        v22 = *(volatile signed __int64 **)(v20 + 16i64 * v17);
        if ( v21 == 113 )
        {
          _InterlockedExchangeAdd64(v22, v19);
        }
        else if ( (unsigned int)(v21 - 114) <= 1 )
        {
          do
          {
            if ( (_BYTE)v21 == 114 )
            {
              if ( v19 >= *v22 )
                break;
            }
            else if ( v19 <= *v22 )
            {
              break;
            }
            v23 = *v22;
          }
          while ( v23 != _InterlockedCompareExchange64(v22, v19, *v22) );
        }
        ++v17;
      }
      while ( v17 < v18 );
      v7 = v24;
    }
  }
LABEL_11:
  ReleaseSRWLockShared((PSRWLOCK)(v5 + 264));
  if ( v7 )
    DestroyEventEntry(v7);
  return v9;
}

//----- (0000000180012D04) ----------------------------------------------------
__int64 __fastcall ComputeEventEntryHash(char a1, unsigned __int8 a2, __int64 a3)
{
  unsigned __int8 v6; // bl
  __int64 v7; // r11
  __int64 v8; // rbx
  __int64 v9; // r11
  int v11; // [rsp+30h] [rbp+8h] BYREF

  v11 = 0;
  RunningHash(&v11, a3 + 16, 8ui64);
  v6 = a1 + 2;
  if ( v6 < a2 )
  {
    v7 = a3 + 16i64 * v6;
    v8 = (unsigned __int8)(a2 - v6);
    do
    {
      RunningHash(&v11, *(_QWORD *)v7, *(unsigned int *)(v7 + 8));
      v7 = v9 + 16;
      --v8;
    }
    while ( v8 );
  }
  return 32769 * ((9 * v11) ^ ((unsigned int)(9 * v11) >> 11));
}
// 180012D5E: variable 'v9' is possibly undefined

//----- (0000000180012D94) ----------------------------------------------------
__int64 __fastcall RunningHash(_DWORD *a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 i; // r10
  int v4; // eax
  __int64 result; // rax

  for ( i = 0i64; i < a3; *a1 = result )
  {
    v4 = *(unsigned __int8 *)(i + a2);
    ++i;
    result = (1025 * (*a1 + v4)) ^ ((unsigned int)(1025 * (*a1 + v4)) >> 6);
  }
  return result;
}

//----- (0000000180012DC8) ----------------------------------------------------
unsigned __int8 __fastcall ExtractAggregateFieldTypes(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  unsigned __int8 v3; // r8
  unsigned __int64 v5; // r10
  char *v6; // rcx
  char v7; // al
  __int64 v9; // rax
  char v11; // al
  char v12; // r9
  char v13; // dl

  v2 = *(_QWORD *)(a2 + 16);
  v3 = 0;
  v5 = v2 + *(unsigned int *)(a2 + 24);
  v6 = (char *)(v2 + 2);
  do
    v7 = *v6++;
  while ( v7 < 0 );
  while ( *v6++ )
    ;
  while ( (unsigned __int64)v6 < v5 )
  {
    while ( *v6++ )
      ;
    if ( *v6 >= 0 )
      break;
    v11 = v6[1];
    v12 = *v6 & 0x7F;
    v6 += 2;
    if ( v11 >= 0 )
      break;
    while ( 1 )
    {
      v13 = *v6;
      if ( *v6 >= 0 )
        break;
      if ( v13 != (char)0x80 )
        return v3;
      ++v6;
    }
    if ( v12 != 9 || (unsigned __int8)(v13 - 113) > 2u )
      break;
    v9 = 2i64 * v3++;
    *(_BYTE *)(a2 + 8 * v9 + 45) = v13;
  }
  return v3;
}

//----- (0000000180012E50) ----------------------------------------------------
__int64 __fastcall RemotelyGetUserKeys(struct CSslContext *a1, unsigned int a2)
{
  int v2; // edi
  unsigned int v3; // esi
  unsigned __int8 **v5; // rax
  int v6; // eax
  unsigned int v7; // ebx
  void *v9; // rax
  struct _SecBuffer Size; // [rsp+40h] [rbp-40h] BYREF
  unsigned __int8 *v11[2]; // [rsp+50h] [rbp-30h] BYREF
  char v12[32]; // [rsp+60h] [rbp-20h] BYREF

  v2 = *((unsigned __int8 *)a1 + 266);
  v3 = a2 | 8;
  *(_OWORD *)v11 = 0i64;
  if ( !(_BYTE)v2 )
    v3 = a2;
  if ( !LsaTable )
    return 87i64;
  if ( !(*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v12) )
    return 1359i64;
  Size.BufferType = 1;
  if ( (v12[8] & 0x40) != 0 )
  {
    Size.cbBuffer = 8;
    if ( (_BYTE)v2 )
    {
      v9 = (void *)(*(__int64 (__fastcall **)(__int64))(LsaTable + 384))(8i64);
      Size.pvBuffer = v9;
      if ( !v9 )
        return 14i64;
      memcpy_0(v9, (char *)a1 + 128, Size.cbBuffer);
    }
    else
    {
      Size.pvBuffer = (char *)a1 + 128;
    }
  }
  else
  {
    Size.cbBuffer = 0;
    Size.pvBuffer = 0i64;
  }
  v5 = v11;
  if ( (_BYTE)v2 )
    v5 = 0i64;
  v6 = PerformApplicationCallback(7i64, *((_QWORD *)a1 + 16), v3, &Size, (struct _SecBuffer *)v5, (_BYTE)v2 == 0, v2, 1);
  if ( v6 < 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        28i64,
        &WPP_66cada2652f531372f2ad4492a08a619_Traceguids,
        (unsigned int)v6);
    v7 = -2146893052;
    if ( (_BYTE)v2 && Size.pvBuffer )
      (*(void (**)(void))(LsaTable + 392))();
  }
  else if ( (_BYTE)v2 )
  {
    v7 = 590610;
  }
  else
  {
    v7 = ParseKeyBuffer(a1, v3, v11[1], (unsigned int)v11[0]);
  }
  if ( v11[1] )
    SPExternalFree(v11[1]);
  return v7;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180012FC4) ----------------------------------------------------
__int64 __fastcall PerformApplicationCallback(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        struct _SecBuffer *a4,
        struct _SecBuffer *a5,
        int a6,
        int a7,
        char a8)
{
  __int64 v8; // rax
  unsigned int v9; // ebx
  void *pvBuffer; // rcx

  v8 = LsaTable;
  if ( LsaTable )
  {
    if ( a7 )
    {
      v9 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, struct _SecBuffer *, char))(LsaTable + 496))(
             a1,
             a2,
             a3,
             a4,
             a8);
      if ( (v9 & 0x80000000) != 0 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v9);
        CleanupAppModeInfo(0i64);
      }
      return v9;
    }
    if ( a5 )
    {
      a5->BufferType = 0;
      a5->pvBuffer = 0i64;
      a5->cbBuffer = 0;
      v9 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, struct _SecBuffer *, struct _SecBuffer *))(v8 + 280))(
             (unsigned int)a1,
             a2,
             a3,
             a4,
             a5);
      if ( (v9 & 0x80000000) != 0 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids, v9);
        return v9;
      }
      pvBuffer = a5->pvBuffer;
      if ( pvBuffer && a5->cbBuffer )
      {
        if ( !a6 )
          v9 = -2146893052;
        if ( (v9 & 0x80000000) == 0 )
          return v9;
      }
      else
      {
        if ( !a6 )
          return v9;
        v9 = -2146893052;
      }
      if ( pvBuffer )
        SPExternalFree(pvBuffer);
      a5->BufferType = 0;
      a5->pvBuffer = 0i64;
      a5->cbBuffer = 0;
      return v9;
    }
  }
  return 2148074244i64;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180013030) ----------------------------------------------------
void __fastcall CCredentialGroup::~CCredentialGroup(CCredentialGroup *this)
{
  *(_QWORD *)this = &CCredentialGroup::`vftable';
  CCredentialGroup::DeleteCredentialGroup(this);
  *(_QWORD *)this = &IAllocate::`vftable';
}
// 18007C298: using guessed type void *IAllocate::`vftable';
// 18007D0D8: using guessed type void *CCredentialGroup::`vftable';

//----- (0000000180013060) ----------------------------------------------------
void __fastcall CCredentialGroup::DeleteCredentialGroup(CCredentialGroup *this)
{
  struct _RTL_RESOURCE *v2; // rbp
  void *v3; // rcx
  struct _TLS_PARAMETERS *v4; // rcx
  void *v5; // rcx
  _QWORD *v6; // rdi
  CCredentialGroup *v7; // rcx
  void *v8; // rcx
  void *v9; // rcx
  void *v10; // rcx
  void *v11; // rcx
  CCredentialGroup *v12; // rcx
  CCredentialGroup *v13; // rcx
  void *v14; // rcx
  void *v15; // rcx
  _QWORD *v16; // rsi
  _QWORD *v17; // rdi
  _QWORD *v18; // rcx
  const CTL_CONTEXT *v19; // rcx
  CCredentialGroup *v20; // rcx
  int v21; // [rsp+40h] [rbp+8h] BYREF

  v21 = 0;
  if ( *((_DWORD *)this + 36) )
  {
    v2 = (struct _RTL_RESOURCE *)((char *)this + 48);
    RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)this + 48), 1u);
    if ( *((_DWORD *)this + 7) )
    {
      v16 = (_QWORD *)((char *)this + 32);
      v17 = (_QWORD *)*((_QWORD *)this + 4);
      while ( v17 != v16 )
      {
        v18 = v17 - 1;
        v17 = (_QWORD *)*v17;
        if ( v18 )
          (*(void (__fastcall **)(_QWORD *, __int64))(*v18 + 8i64))(v18, 1i64);
      }
      *((_DWORD *)this + 7) = 0;
      *v16 = 0i64;
      *((_QWORD *)this + 5) = 0i64;
    }
    v3 = (void *)*((_QWORD *)this + 23);
    if ( v3 )
      SPExternalFree(v3);
    v4 = (struct _TLS_PARAMETERS *)*((_QWORD *)this + 25);
    if ( v4 )
    {
      FreeTlsParameters(v4, *((_DWORD *)this + 49));
      *((_QWORD *)this + 25) = 0i64;
      *((_DWORD *)this + 49) = 0;
    }
    v5 = (void *)*((_QWORD *)this + 108);
    if ( v5 )
      LocalFree(v5);
    v6 = (_QWORD *)*((_QWORD *)this + 106);
    if ( v6 )
    {
      v19 = (const CTL_CONTEXT *)v6[5];
      if ( v19 )
        CertFreeCTLContext(v19);
      SPExternalFree(v6);
    }
    v7 = (CCredentialGroup *)*((_QWORD *)this + 96);
    if ( v7 )
    {
      if ( *((_QWORD *)this + 97) )
      {
        CCredentialGroup::UnsubscribeCertStoreChangeNotification(v7, *((void **)this + 96), (void **)this + 97);
        v7 = (CCredentialGroup *)*((_QWORD *)this + 96);
      }
      CertCloseStore(v7, 0);
    }
    v8 = (void *)*((_QWORD *)this + 109);
    if ( v8 )
      SPExternalFree(v8);
    v9 = (void *)*((_QWORD *)this + 110);
    if ( v9 )
      SPExternalFree(v9);
    if ( *((_QWORD *)this + 98) )
    {
      if ( !SslImpersonateClient(*((_QWORD *)this + 94), &v21) && *((_QWORD *)this + 99) )
        CCredentialGroup::UnsubscribeCertStoreChangeNotification(v20, *((void **)this + 98), (void **)this + 99);
      CertCloseStore(*((HCERTSTORE *)this + 98), 0);
      if ( v21 )
        RevertToSelf();
    }
    v10 = (void *)*((_QWORD *)this + 100);
    if ( v10 )
      CryptObjectLocatorFree(v10);
    v11 = (void *)*((_QWORD *)this + 101);
    if ( v11 )
      CryptObjectLocatorFree(v11);
    v12 = (CCredentialGroup *)*((_QWORD *)this + 102);
    if ( v12 )
    {
      if ( *((_QWORD *)this + 103) )
      {
        CCredentialGroup::UnsubscribeCertStoreChangeNotification(v12, *((void **)this + 102), (void **)this + 103);
        v12 = (CCredentialGroup *)*((_QWORD *)this + 102);
      }
      CertCloseStore(v12, 0);
    }
    v13 = (CCredentialGroup *)*((_QWORD *)this + 104);
    if ( v13 )
    {
      if ( *((_QWORD *)this + 105) )
      {
        CCredentialGroup::UnsubscribeCertStoreChangeNotification(v13, *((void **)this + 104), (void **)this + 105);
        v13 = (CCredentialGroup *)*((_QWORD *)this + 104);
      }
      CertCloseStore(v13, 0);
    }
    v14 = (void *)*((_QWORD *)this + 94);
    if ( v14 )
    {
      NtClose(v14);
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_q(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x18u,
          (__int64)&WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids,
          *((_QWORD *)this + 94));
      *((_QWORD *)this + 94) = 0i64;
    }
    v15 = (void *)*((_QWORD *)this + 111);
    if ( v15 )
      LocalFree(v15);
    RtlReleaseResource(v2);
    RtlDeleteResource(v2);
  }
}
// 18003C915: variable 'v20' is possibly undefined
// 180082B38: using guessed type GUID WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids;
// 180098018: using guessed type void __stdcall CryptObjectLocatorFree(void *);

//----- (0000000180013210) ----------------------------------------------------
CCredentialGroup *__fastcall CCredentialGroup::`vector deleting destructor'(CCredentialGroup *this, char a2)
{
  CCredentialGroup::~CCredentialGroup(this);
  if ( (a2 & 1) != 0 )
    SPExternalFree(this);
  return this;
}

//----- (0000000180013248) ----------------------------------------------------
signed int __fastcall SslTransferCertChainToClientProcess(PCCERT_CONTEXT *a1, const struct _CERT_CONTEXT *a2)
{
  signed int result; // eax
  unsigned __int8 *v5; // rax
  int v6; // ebx
  __int64 v7; // rax
  NTSTATUS v8; // ebx
  PCCERT_CONTEXT v9; // rax
  unsigned int v10[2]; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int8 *v11; // [rsp+38h] [rbp-30h]
  char v12[40]; // [rsp+40h] [rbp-28h] BYREF

  if ( !a2 )
    return -2146893042;
  if ( !a1 )
    return 87;
  if ( !LsaTable || !(*(unsigned __int8 (__fastcall **)(char *))(LsaTable + 192))(v12) )
    return 1359;
  if ( (v12[8] & 0x10) != 0 )
  {
    v9 = CertDuplicateCertificateContext(a2);
    if ( v9 )
    {
      *a1 = v9;
      return 0;
    }
    return 1359;
  }
  result = SerializeCertContext(a2, 0i64, v10);
  if ( result < 0 )
    return result;
  v5 = (unsigned __int8 *)(*(__int64 (__fastcall **)(_QWORD))(LsaTable + 384))(v10[0]);
  v11 = v5;
  if ( !v5 )
    return 14;
  v6 = SerializeCertContext(a2, v5, v10);
  if ( v6 < 0 )
  {
    (*(void (__fastcall **)(unsigned __int8 *))(LsaTable + 392))(v11);
    return v6;
  }
  v7 = LsaTable;
  v10[1] = 1;
  if ( !LsaTable )
  {
    v8 = -2146893052;
LABEL_24:
    (*(void (__fastcall **)(unsigned __int8 *))(v7 + 392))(v11);
    return RtlNtStatusToDosError(v8);
  }
  v8 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, unsigned int *, _BYTE))(LsaTable + 496))(
         6i64,
         0i64,
         0i64,
         v10,
         0);
  if ( v8 < 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        10i64,
        &WPP_66cada2652f531372f2ad4492a08a619_Traceguids,
        (unsigned int)v8);
    CleanupAppModeInfo(0i64);
    v7 = LsaTable;
    goto LABEL_24;
  }
  return 0;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (000000018001336C) ----------------------------------------------------
__int64 __fastcall SerializeCertContext(PCCERT_CONTEXT pCertContext, unsigned __int8 *a2, unsigned int *a3)
{
  HCERTSTORE hCertStore; // rcx
  int v7; // esi
  DWORD v8; // ecx
  unsigned int v9; // eax
  HCERTSTORE v11; // rcx
  int pvSaveToPara; // [rsp+30h] [rbp-10h] BYREF
  unsigned __int8 *v13; // [rsp+38h] [rbp-8h]
  DWORD pcbElement; // [rsp+60h] [rbp+20h] BYREF

  pcbElement = 0;
  if ( !pCertContext )
  {
    *a3 = 0;
    return 0i64;
  }
  if ( !CertSerializeCertificateStoreElement(pCertContext, 0, 0i64, &pcbElement) )
    return 2148074253i64;
  hCertStore = pCertContext->hCertStore;
  if ( hCertStore )
  {
    pvSaveToPara = 0;
    v13 = 0i64;
    if ( !CertSaveStore(hCertStore, 1u, 1u, 2u, &pvSaveToPara, 0) )
      return 2148074253i64;
    v7 = pvSaveToPara;
  }
  else
  {
    v7 = 0;
  }
  v8 = pcbElement;
  v9 = v7 + pcbElement + 8;
  if ( !a2 )
  {
    *a3 = v9;
    return 0i64;
  }
  if ( *a3 >= v9 )
  {
    *a3 = v9;
    *(_DWORD *)a2 = v7;
    if ( !pCertContext->hCertStore )
      goto LABEL_13;
    v11 = pCertContext->hCertStore;
    v13 = a2 + 4;
    pvSaveToPara = v7;
    if ( CertSaveStore(v11, 1u, 1u, 2u, &pvSaveToPara, 0) )
    {
      v8 = pcbElement;
LABEL_13:
      *(_DWORD *)&a2[v7 + 4] = v8;
      if ( CertSerializeCertificateStoreElement(pCertContext, 0, &a2[v7 + 8], &pcbElement) )
        return 0i64;
    }
    return 2148074253i64;
  }
  return 2148074273i64;
}

//----- (00000001800134AC) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::QueryRemoteCertificateChain(CSsl3TlsContext *this, PCCERT_CONTEXT *a2)
{
  __int64 v3; // rcx
  __int64 v5; // rcx
  unsigned __int8 *v6; // rbx
  DWORD v7; // edi
  DWORD v8; // edi
  unsigned int v9; // eax
  CCipherMill *v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // r9
  DWORD LastError; // eax
  DWORD v15; // eax
  __int64 v16; // [rsp+20h] [rbp-20h] BYREF
  __int64 v17; // [rsp+28h] [rbp-18h] BYREF
  int pvData; // [rsp+30h] [rbp-10h] BYREF
  __int64 v19; // [rsp+38h] [rbp-8h]
  int v20; // [rsp+70h] [rbp+30h] BYREF
  int v21; // [rsp+80h] [rbp+40h] BYREF
  PCCERT_CONTEXT pCertContext; // [rsp+88h] [rbp+48h] BYREF

  v16 = 0i64;
  v3 = *((_QWORD *)this + 11);
  v17 = 0i64;
  v20 = 0;
  v21 = 0;
  pCertContext = 0i64;
  RtlAcquireResourceShared((PRTL_RESOURCE)(v3 + 72), 1u);
  v5 = *((_QWORD *)this + 11);
  v6 = *(unsigned __int8 **)(v5 + 24);
  v7 = *(_DWORD *)(v5 + 32);
  if ( v6 )
  {
    (*(void (__fastcall **)(CSsl3TlsContext *, __int64 *, int *))(*(_QWORD *)this + 272i64))(this, &v16, &v20);
    v8 = SPLoadCertificate(v6, v7, &pCertContext);
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
    if ( v8 )
    {
      v11 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      {
LABEL_9:
        if ( pCertContext )
          CertFreeCertificateContext(pCertContext);
        return v8;
      }
      v12 = 14i64;
      v13 = v8;
    }
    else
    {
      RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
      if ( v16 )
      {
        v19 = v16;
        pvData = v20;
        if ( !CertSetCertificateContextProperty(pCertContext, 0x46u, 0, &pvData)
          && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
          && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        {
          LastError = GetLastError();
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            15i64,
            &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids,
            LastError);
        }
      }
      (*(void (__fastcall **)(CSsl3TlsContext *, __int64 *, int *))(*(_QWORD *)this + 280i64))(this, &v17, &v21);
      if ( v17 )
      {
        if ( v21 )
        {
          v19 = v17;
          pvData = v21;
          if ( !CertSetCertificateContextProperty(pCertContext, 0x77u, 0, &pvData)
            && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
          {
            v15 = GetLastError();
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 16i64, &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids, v15);
          }
        }
      }
      RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
      v9 = SslTransferCertChainToClientProcess(a2, pCertContext);
      v8 = v9;
      if ( !v9 )
        goto LABEL_9;
      v11 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        goto LABEL_9;
      v12 = 17i64;
      v13 = v9;
    }
    WPP_SF_D(*((_QWORD *)v11 + 2), v12, &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids, v13);
    goto LABEL_9;
  }
  RtlReleaseResource((PRTL_RESOURCE)(v5 + 72));
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids);
  return (DWORD)-2146893042;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180013660) ----------------------------------------------------
signed int __fastcall CSsl3TlsContext::QueryContextAttributesA(CSsl3TlsContext *this, int a2, void *a3)
{
  switch ( a2 )
  {
    case '"':
      return CSsl3TlsContext::QuerySupportedMTU(this, a3);
    case 'Y':
      return CSsl3TlsContext::QueryIssuerList(this, a3);
    case '[':
      return CSsl3TlsContext::QueryEapKeyBlock(this, a3);
    case 'f':
      return CSsl3TlsContext::QuerySupportedSignatures(this, a3);
    case 'g':
      return CSsl3TlsContext::QueryRemoteCertificateChain(this, (PCCERT_CONTEXT *)a3);
    case 'k':
      return (*(__int64 (__fastcall **)(CSsl3TlsContext *, void *))(*(_QWORD *)this + 480i64))(this, a3);
    case 'q':
      return CSsl3TlsContext::QueryCertificateValidationResult(this, a3);
  }
  return CSslContext::QueryContextAttributesA(this, a2, a3);
}

//----- (00000001800136A0) ----------------------------------------------------
__int64 __fastcall CreateNewEventEntry(
        __int128 *a1,
        unsigned __int8 a2,
        __int64 a3,
        unsigned __int8 a4,
        int a5,
        __int64 *a6)
{
  unsigned __int8 v6; // di
  __int64 v7; // rbp
  __int64 v9; // r8
  int v10; // r14d
  __int64 v11; // rdx
  unsigned __int8 v12; // r9
  unsigned int *v13; // r10
  __int64 v14; // rcx
  __int64 v15; // rax
  SIZE_T v16; // rsi
  HANDLE ProcessHeap; // rax
  __int64 NextOffset; // r12
  unsigned int v19; // edx
  void *v20; // rbx
  __int64 v21; // rdx
  __int64 v22; // rdi
  __int128 v23; // xmm0
  unsigned __int8 v24; // r14
  const void **v25; // rsi
  __int64 v26; // r12
  __int64 v27; // rbp
  unsigned int v28; // edx
  void *v29; // rbx
  char *v30; // rdx
  int v31; // eax
  __int64 v33[7]; // [rsp+20h] [rbp-38h] BYREF

  v6 = 0;
  v7 = a2;
  v33[0] = 0i64;
  v9 = 0i64;
  v10 = a4;
  v11 = 0i64;
  v12 = 0;
  *a6 = 0i64;
  if ( (_BYTE)v7 )
  {
    v13 = (unsigned int *)(a3 + 8);
    do
    {
      v14 = *v13;
      v13 += 4;
      if ( v12 >= 2u )
        v11 += v14;
      v15 = v14 + v9;
      if ( v12 >= 2u )
        v15 = v9;
      ++v12;
      v9 = v15;
    }
    while ( v12 < (unsigned __int8)v7 );
    if ( (unsigned __int64)(v11 + v15) > 0xFFFF )
      return 534i64;
  }
  v16 = v11 + 16 * v7 + 46;
  if ( !v16 )
    return 8i64;
  ProcessHeap = GetProcessHeap();
  v33[0] = (__int64)HeapAlloc(ProcessHeap, 8u, v16);
  if ( !v33[0] )
    return 8i64;
  v33[1] = v16;
  NextOffset = CBufferGetNextOffset(v33, 16 * v7);
  do
  {
    if ( v6 < 2u )
    {
      *(_OWORD *)(NextOffset + 16i64 * v6) = *(_OWORD *)(a3 + 16i64 * v6);
    }
    else
    {
      v20 = (void *)CBufferGetNextOffset(v33, *(unsigned int *)(a3 + 16i64 * v6 + 8));
      memcpy_0(v20, *(const void **)(a3 + 16i64 * v6), v19);
      *(_QWORD *)(NextOffset + 16i64 * v6) = v20;
      *(_DWORD *)(NextOffset + 16i64 * v6 + 12) = *(_DWORD *)(a3 + 16i64 * v6 + 12);
      *(_DWORD *)(NextOffset + 16i64 * v6 + 8) = *(_DWORD *)(a3 + 16i64 * v6 + 8);
    }
    ++v6;
  }
  while ( v6 < (unsigned int)(v10 + 2) );
  v22 = CBufferGetNextOffset(v33, 0x2Eui64);
  *(_QWORD *)(v22 + 16) = NextOffset;
  v23 = *a1;
  *(_BYTE *)(v22 + 45) = v10;
  v24 = v10 + 2;
  *(_BYTE *)(v22 + 44) = v7;
  *(_DWORD *)(v22 + 40) = a5;
  *(_OWORD *)v22 = v23;
  if ( v24 < (unsigned __int8)v7 )
  {
    v25 = (const void **)(16i64 * v24 + a3 + 8);
    v26 = v21 - 54 - a3;
    v27 = (unsigned __int8)(v7 - v24);
    do
    {
      v29 = (void *)CBufferGetNextOffset(v33, *(unsigned int *)v25);
      memcpy_0(v29, *(v25 - 1), v28);
      v30 = (char *)v25 + v26;
      *(_QWORD *)&v30[*(_QWORD *)(v22 + 16)] = v29;
      *(_DWORD *)&v30[*(_QWORD *)(v22 + 16) + 12] = *((_DWORD *)v25 + 1);
      v31 = *(_DWORD *)v25;
      v25 += 2;
      *(_DWORD *)&v30[*(_QWORD *)(v22 + 16) + 8] = v31;
      --v27;
    }
    while ( v27 );
  }
  *a6 = v22;
  return 0i64;
}
// 180013786: conditional instruction was optimized away because r14d.4<100u
// 1800137A8: variable 'v19' is possibly undefined
// 180013827: variable 'v21' is possibly undefined
// 180013844: variable 'v28' is possibly undefined

//----- (00000001800138C8) ----------------------------------------------------
__int64 __fastcall CBufferGetNextOffset(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r9
  __int64 result; // rax

  if ( !a1 )
    return 0i64;
  if ( !a2 )
    return 0i64;
  v2 = a1[1];
  if ( v2 < a2 )
    return 0i64;
  result = *a1;
  a1[1] = v2 - a2;
  *a1 = result + a2;
  return result;
}

//----- (00000001800138FC) ----------------------------------------------------
int __fastcall CompareEventEntry(unsigned __int8 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbp
  unsigned int v6; // edi
  int result; // eax
  unsigned int i; // ebx
  __int64 v9; // rcx

  v3 = *(_QWORD *)(a3 + 16);
  v6 = a1;
  result = memcmp_0((const void *)(a2 + 16), (const void *)(v3 + 16), 8ui64);
  if ( !result )
  {
    for ( i = *(unsigned __int8 *)(a3 + 45) + 2; i < v6; ++i )
    {
      v9 = 16i64 * i;
      result = *(_DWORD *)(v9 + a2 + 8) - *(_DWORD *)(v9 + v3 + 8);
      if ( result )
        return result;
      result = memcmp_0(*(const void **)(v9 + a2), *(const void **)(v9 + v3), *(unsigned int *)(v9 + a2 + 8));
      if ( result )
        return result;
    }
    return 0;
  }
  return result;
}

//----- (0000000180013988) ----------------------------------------------------
__int64 StringCchPrintfW(unsigned __int16 *a1, __int64 a2, const unsigned __int16 *a3, ...)
{
  unsigned __int64 v4; // rsi
  unsigned int v5; // edi
  int v6; // eax
  va_list Args; // [rsp+68h] [rbp+20h] BYREF

  va_start(Args, a3);
  if ( (unsigned __int64)(a2 - 1) <= 0x7FFFFFFE )
  {
    v4 = a2 - 1;
    v5 = 0;
    v6 = vsnwprintf(a1, a2 - 1, a3, Args);
    if ( v6 < 0 || v6 > v4 )
    {
      v5 = -2147024774;
    }
    else if ( v6 != v4 )
    {
      return v5;
    }
    a1[v4] = 0;
    return v5;
  }
  v5 = -2147024809;
  if ( a2 )
    *a1 = 0;
  return v5;
}

//----- (00000001800139F0) ----------------------------------------------------
__int64 __fastcall SpWow64MapVersion3Certificate(void *a1, int a2, struct _SecBuffer *a3, struct LSA_SCHANNEL_CRED *a4)
{
  void *v4; // rsi
  void *v5; // r13
  unsigned int *pvBuffer; // r15
  __int64 v11; // rdx
  int v12; // ebx
  unsigned int v13; // ebx
  int v14; // r13d
  unsigned int v15; // esi
  int v16; // r14d
  int v17; // eax
  HLOCAL v19; // rax
  void *v20; // r10
  unsigned int v21; // ebx
  __int64 v22; // r12
  __int64 v23; // rcx
  const BYTE *v24; // rdx
  __int64 ppvContext; // r9
  DWORD v26; // r8d
  __int64 v27; // rcx
  HCERTSTORE v28; // rax
  int v29; // eax
  unsigned int v30; // ebx
  HLOCAL v31; // rax
  unsigned int v32; // eax
  HCERTSTORE v33; // [rsp+40h] [rbp-49h]
  HLOCAL v34; // [rsp+48h] [rbp-41h]
  unsigned int pvPara; // [rsp+58h] [rbp-31h] BYREF
  unsigned int *v37; // [rsp+60h] [rbp-29h]
  __int128 v38; // [rsp+68h] [rbp-21h] BYREF
  __int128 v39; // [rsp+78h] [rbp-11h]
  unsigned int v40[4]; // [rsp+88h] [rbp-1h]
  __int64 v41; // [rsp+98h] [rbp+Fh]

  v4 = 0i64;
  v5 = 0i64;
  v34 = 0i64;
  v33 = 0i64;
  pvBuffer = 0i64;
  v38 = 0i64;
  v41 = 0i64;
  v39 = 0i64;
  *(_OWORD *)v40 = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
  if ( a2 == 3 )
  {
    v12 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int128 *, void *))(LsaTable + 80))(0i64, 48i64, &v38, a1);
    if ( v12 < 0 )
      goto LABEL_24;
    v41 = 0i64;
  }
  else
  {
    v11 = 56i64;
    if ( a2 != 4 )
      v11 = 44i64;
    v12 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int128 *, void *))(LsaTable + 80))(0i64, v11, &v38, a1);
    if ( v12 < 0 )
      goto LABEL_24;
  }
  memset_0((char *)a4 + 4, 0, 0x6Cui64);
  *(_DWORD *)a4 = a2;
  if ( a2 == 4 )
  {
    v13 = DWORD2(v38);
    v14 = HIDWORD(v38);
    v15 = DWORD1(v38);
  }
  else
  {
    v13 = HIDWORD(v38);
    v14 = v39;
    v15 = DWORD2(v38);
  }
  if ( v15 > 0x64 )
  {
    v12 = -2146893056;
  }
  else
  {
    if ( a3->pvBuffer )
    {
      pvBuffer = (unsigned int *)a3->pvBuffer;
      goto LABEL_14;
    }
    if ( (!v15 || !v13) && !v14 )
    {
LABEL_14:
      if ( v15 && v13 )
      {
        v34 = SPExternalAlloc(4 * v15);
        if ( !v34 )
        {
          v12 = -2146893056;
          v4 = 0i64;
          goto LABEL_23;
        }
        v12 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, HLOCAL, _QWORD))(LsaTable + 80))(0i64, 4 * v15, v34, v13);
        if ( v12 >= 0 )
        {
          *((_DWORD *)a4 + 1) = v15;
          v19 = SPExternalAlloc(56 * v15);
          *((_QWORD *)a4 + 1) = v19;
          if ( !v19 )
          {
LABEL_51:
            v12 = -2146893056;
            goto LABEL_22;
          }
          v33 = CertOpenStore((LPCSTR)2, 0, 0i64, 4u, 0i64);
          v20 = v33;
          if ( !v33 )
          {
            GetLastError();
            goto LABEL_51;
          }
          v21 = 0;
          v22 = 0i64;
          while ( 1 )
          {
            v23 = *pvBuffer;
            v24 = (const BYTE *)(pvBuffer + 1);
            pvBuffer = (unsigned int *)((char *)pvBuffer + v23 + 4);
            if ( !v24 )
              break;
            if ( (unsigned int)v23 < 0xC )
              break;
            ppvContext = v22 + *((_QWORD *)a4 + 1);
            *(_QWORD *)(ppvContext + 16) = *(unsigned int *)v24;
            v26 = *((_DWORD *)v24 + 1);
            if ( (int)v23 - 8 < v26 )
              break;
            if ( !CertAddSerializedElementToStore(v20, v24 + 8, v26, 4u, 0, 2u, 0i64, (const void **)ppvContext) )
            {
              GetLastError();
              goto LABEL_60;
            }
            v20 = v33;
            ++v21;
            v22 += 56i64;
            if ( v21 >= v15 )
              goto LABEL_15;
          }
LABEL_61:
          v12 = -2146893052;
        }
LABEL_22:
        v4 = v34;
LABEL_23:
        v5 = v33;
        goto LABEL_24;
      }
LABEL_15:
      if ( v14 )
      {
        v27 = *pvBuffer;
        if ( pvBuffer == (unsigned int *)-4i64 )
          goto LABEL_61;
        if ( (unsigned int)v27 < 4 )
          goto LABEL_61;
        pvPara = pvBuffer[1];
        v37 = pvBuffer + 2;
        if ( v27 - 4 < (unsigned __int64)pvPara )
          goto LABEL_61;
        v28 = CertOpenStore((LPCSTR)6, 1u, 0i64, 0, &pvPara);
        *((_QWORD *)a4 + 2) = v28;
        if ( !v28 )
        {
LABEL_60:
          v12 = -2146893043;
          goto LABEL_22;
        }
      }
      v16 = a2 - 4;
      if ( v16 )
      {
        if ( v16 != 1 )
        {
LABEL_21:
          v12 = 0;
          goto LABEL_22;
        }
        v12 = CopyTlsParameters(0i64, v40[1], v40[2], 1, (struct _TLS_PARAMETERS **)a4 + 13, (unsigned int *)a4 + 24);
        if ( v12 )
          goto LABEL_22;
        *((_DWORD *)a4 + 21) = HIDWORD(v39);
        *((_DWORD *)a4 + 22) = v40[0];
        v17 = DWORD1(v38);
      }
      else
      {
        v29 = DWORD2(v39);
        if ( DWORD2(v39) && HIDWORD(v39) )
        {
          if ( DWORD2(v39) > 0x100 )
            goto LABEL_51;
          v30 = 4 * DWORD2(v39);
          *((_DWORD *)a4 + 14) = DWORD2(v39);
          v31 = SPExternalAlloc(4 * v29);
          *((_QWORD *)a4 + 8) = v31;
          if ( !v31 )
            goto LABEL_51;
          v12 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, HLOCAL, _QWORD))(LsaTable + 80))(
                  0i64,
                  v30,
                  v31,
                  HIDWORD(v39));
          if ( v12 < 0 )
            goto LABEL_22;
        }
        v32 = v40[0];
        if ( v40[0] == -1 )
          v32 = 0;
        else
          *((_DWORD *)a4 + 18) = v40[0];
        *((_DWORD *)a4 + 18) = v32 & 0x3FFFFFFF;
        *((_DWORD *)a4 + 19) = v40[1];
        *((_DWORD *)a4 + 20) = v40[2];
        *((_DWORD *)a4 + 21) = v40[3];
        *((_DWORD *)a4 + 22) = v41;
        v17 = HIDWORD(v41);
      }
      *((_DWORD *)a4 + 23) = v17;
      goto LABEL_21;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 23i64, &WPP_436d244ba9be3eb0a28121d2e8b5d9e1_Traceguids);
    v12 = 590610;
  }
  v4 = 0i64;
  v5 = 0i64;
LABEL_24:
  if ( a3 )
  {
    a3->pvBuffer = 0i64;
    *(_QWORD *)&a3->cbBuffer = 0i64;
    CleanupAppModeInfo(0i64);
  }
  if ( v4 )
    SPExternalFree(v4);
  if ( v5 )
    CertCloseStore(v5, 0);
  if ( v12 < 0 )
    FreeSchannelCred(a4, 1);
  return (unsigned int)v12;
}
// 18003CE25: conditional instruction was optimized away because esi.4 is in (1..64)
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180013BC8) ----------------------------------------------------
__int64 __fastcall CertGetEccCurveType(__int64 a1, unsigned int *a2)
{
  __int64 v2; // r8
  CCipherMill *v4; // rcx
  unsigned int EccCurveType; // eax
  unsigned int v6; // ebx
  DWORD v8; // [rsp+50h] [rbp+8h] BYREF
  HLOCAL hMem; // [rsp+58h] [rbp+10h] BYREF

  *a2 = 0;
  v2 = *(_QWORD *)(a1 + 24);
  hMem = 0i64;
  v8 = 8;
  if ( CryptDecodeObjectEx(
         1u,
         (LPCSTR)0x49,
         *(const BYTE **)(v2 + 112),
         *(_DWORD *)(v2 + 104),
         0x8000u,
         0i64,
         &hMem,
         &v8) )
  {
    EccCurveType = CCipherMill::GetEccCurveType(v4, *(char **)hMem, a2);
  }
  else
  {
    EccCurveType = GetLastError();
  }
  v6 = EccCurveType;
  if ( hMem )
    LocalFree(hMem);
  return v6;
}
// 180013C33: variable 'v4' is possibly undefined

//----- (0000000180013C60) ----------------------------------------------------
__int64 __fastcall CCipherMill::GetEccCurveType(CCipherMill *this, char *a2, unsigned int *a3)
{
  unsigned int EccCurveType; // ebx
  int v7; // r15d
  __int64 v8; // rsi
  unsigned int v9; // edi
  __int64 v10; // rbp
  __int128 i; // [rsp+20h] [rbp-38h] BYREF
  __int64 v12; // [rsp+30h] [rbp-28h]

  *a3 = 0;
  RtlAcquireResourceShared(&Resource, 1u);
  if ( a2 && qword_1800925C8 )
  {
    EccCurveType = CMasterEccCurveInfo::GetEccCurveType(qword_1800925C8, a2, a3);
    if ( EccCurveType )
    {
      v7 = 0;
      v8 = 0i64;
      v12 = 0i64;
      for ( i = 0i64; (unsigned int)v8 < qword_180092498; v8 = (unsigned int)(v8 + 1) )
      {
        if ( !(unsigned int)SslEnumEccCurves(qword_1800924A0[v8], (char *)&i + 8, &i, 0i64) )
        {
          v9 = 0;
          if ( DWORD2(i) )
          {
            while ( 1 )
            {
              v10 = i + 780i64 * v9;
              if ( !(unsigned int)o__stricmp_0(v10 + 510, a2) )
                break;
              if ( ++v9 >= DWORD2(i) )
                goto LABEL_13;
            }
            EccCurveType = 0;
            *a3 = *(_DWORD *)(v10 + 772);
            v7 = 1;
          }
        }
LABEL_13:
        if ( (_QWORD)i )
        {
          SslFreeBuffer();
          *(_QWORD *)&i = 0i64;
        }
        if ( v7 )
          break;
      }
    }
  }
  else
  {
    EccCurveType = 87;
  }
  RtlReleaseResource(&Resource);
  return EccCurveType;
}
// 180028D24: using guessed type __int64 __fastcall o__stricmp_0(_QWORD, _QWORD);
// 1800924A0: using guessed type unsigned __int64 qword_1800924A0[32];
// 180098458: using guessed type __int64 __fastcall SslEnumEccCurves(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098480: using guessed type __int64 SslFreeBuffer(void);

//----- (0000000180013D04) ----------------------------------------------------
__int64 __fastcall CMasterEccCurveInfo::GetEccCurveType(CMasterEccCurveInfo *this, char *a2, unsigned int *a3)
{
  unsigned int v3; // r9d
  unsigned int v4; // r11d
  __int64 v7; // rbp
  unsigned int v8; // ecx
  __int64 v9; // rdx
  __int64 v10; // r14
  __int64 v11; // r8
  char *v12; // rsi
  int v13; // ebx
  int v14; // eax
  __int64 result; // rax

  *a3 = 0;
  v3 = 0;
  v4 = *((_DWORD *)this + 2);
  if ( !v4 )
    return 1168i64;
  v7 = *(_QWORD *)this;
  while ( 1 )
  {
    v8 = 0;
    v9 = 32i64 * v3;
    if ( *(_DWORD *)(v9 + v7 + 8) )
      break;
LABEL_12:
    if ( ++v3 >= v4 )
      return 1168i64;
  }
  v10 = *(_QWORD *)(v9 + v7);
  while ( 1 )
  {
    v11 = 780i64 * v8 + v10 + 510;
    v12 = &a2[-v11];
    do
    {
      v13 = (unsigned __int8)v12[v11];
      v14 = *(unsigned __int8 *)v11 - v13;
      if ( v14 )
        break;
      ++v11;
    }
    while ( v13 );
    if ( !v14 )
      break;
    if ( ++v8 >= *(_DWORD *)(v9 + v7 + 8) )
      goto LABEL_12;
  }
  result = 0i64;
  *a3 = *(_DWORD *)(780i64 * v8 + v10 + 772);
  return result;
}

//----- (0000000180013DD0) ----------------------------------------------------
__int64 __fastcall CSslContext::GetProviderInfo(CSslContext *this, unsigned __int16 *const a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // rax
  unsigned int v4; // esi
  unsigned __int64 v6; // rdx
  __int64 *v7; // rax
  __int64 v8; // rdi
  unsigned int v9; // ebp
  unsigned __int16 *v10; // rdx
  __int64 v11; // rax

  v3 = (unsigned __int64 *)*((_QWORD *)this + 1);
  v4 = 0;
  if ( v3 )
    v6 = *v3;
  else
    v6 = 0i64;
  *a3 = v6;
  v7 = (__int64 *)*((_QWORD *)this + 1);
  if ( v7 )
    v8 = *v7;
  else
    v8 = 0i64;
  RtlAcquireResourceShared(&Resource, 1u);
  v9 = 0;
  if ( qword_180092498 )
  {
    while ( qword_1800924A0[v9] != v8 )
    {
      if ( ++v9 >= qword_180092498 )
        goto LABEL_13;
    }
    v10 = *(unsigned __int16 **)(qword_180092490 + 16i64 * v9);
    v11 = 256i64;
    while ( v11 != -2147483390 && *v10 )
    {
      *a2++ = *v10++;
      if ( !--v11 )
      {
        --a2;
        break;
      }
    }
    *a2 = 0;
  }
LABEL_13:
  RtlReleaseResource(&Resource);
  if ( v9 == qword_180092498 )
    return 1168;
  return v4;
}
// 180013E81: conditional instruction was optimized away because rax.8 is in (1..FFFFFFFF80000101|>=FFFFFFFF80000103u)
// 180092490: using guessed type __int64 qword_180092490;
// 1800924A0: using guessed type unsigned __int64 qword_1800924A0[32];

//----- (0000000180013ED0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetApplicationProtocols(CSsl3TlsContext *this, struct _SecBuffer *const a2)
{
  unsigned __int16 *v2; // rsi
  unsigned int *pvBuffer; // rdi
  __int64 v5; // rax
  unsigned int *v6; // rbx
  CCipherMill *v7; // r10
  unsigned __int8 *v8; // rax
  __int64 v9; // rdx
  unsigned __int8 *v10; // rdx
  __int64 v11; // rcx
  unsigned __int8 *v12; // rax
  void *v13; // rbx
  __int64 v14; // rdi
  void *v15; // rax
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // rdx
  CCipherMill *v20; // rcx

  v2 = 0i64;
  if ( a2 )
  {
    if ( a2->BufferType == 18 && a2->cbBuffer >= 0xC && (pvBuffer = (unsigned int *)a2->pvBuffer) != 0i64 )
    {
      v5 = *pvBuffer;
      if ( (unsigned int)v5 >= 8 && (unsigned int)v5 < 0xFFFFFFFC && a2->cbBuffer >= (unsigned int)(v5 + 4) )
      {
        v6 = pvBuffer + 1;
        if ( (v5 & 0xFFFFFFFFFFFFFFF8ui64) != 0 )
        {
          v7 = WPP_GLOBAL_Control;
          while ( 1 )
          {
            if ( *v6 == 2 )
            {
              if ( v2 )
              {
                if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v7 + 28) & 1) != 0 )
                {
                  v18 = *((_QWORD *)v7 + 2);
                  v19 = 79i64;
                  goto LABEL_47;
                }
                return 2148074278i64;
              }
              v8 = (unsigned __int8 *)v6 + 6;
              v2 = (unsigned __int16 *)v6;
              if ( v6 == (unsigned int *)-6i64 )
                return 87i64;
              v9 = *((unsigned __int16 *)v6 + 2);
              if ( (unsigned __int16)(v9 - 2) > 0xFFFBu )
              {
                if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v7 + 28) & 1) != 0 )
                {
                  v17 = 74i64;
                  goto LABEL_32;
                }
                return 2148074278i64;
              }
              v10 = &v8[v9];
              if ( v8 < v10 )
              {
                while ( 1 )
                {
                  v11 = *v8;
                  if ( !(_BYTE)v11 )
                    break;
                  v12 = &v8[v11];
                  if ( v12 >= v10 )
                    break;
                  v8 = v12 + 1;
                  if ( v8 >= v10 )
                    goto LABEL_18;
                }
                if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v7 + 28) & 1) != 0 )
                {
                  v17 = 76i64;
LABEL_32:
                  WPP_SF_(*((_QWORD *)v7 + 2), v17, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
                  return 2148074278i64;
                }
                return 2148074278i64;
              }
            }
            else if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v7 + 28) & 4) != 0 )
            {
              WPP_SF_d(*((_QWORD *)v7 + 2), 0x50u, (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids, *v6);
              v7 = WPP_GLOBAL_Control;
            }
LABEL_18:
            v6 += 2 * (((unsigned __int64)*((unsigned __int16 *)v6 + 2) + 13) >> 3);
            if ( ((char *)v6 - (char *)pvBuffer - 4) >> 3 >= (unsigned __int64)*pvBuffer >> 3 )
              goto LABEL_19;
          }
        }
        goto LABEL_19;
      }
      v20 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074278i64;
      v19 = 78i64;
    }
    else
    {
      v20 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074278i64;
      v19 = 77i64;
    }
    v18 = *((_QWORD *)v20 + 2);
LABEL_47:
    WPP_SF_(v18, v19, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    return 2148074278i64;
  }
LABEL_19:
  v13 = 0i64;
  if ( v2 )
  {
    v14 = v2[2];
    v15 = (void *)(*(__int64 (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 8i64))(this, v14 + 6);
    v13 = v15;
    if ( !v15 )
      return 14i64;
    memcpy_0(v15, v2, v14 + 6);
  }
  (*(void (__fastcall **)(CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 16i64))(this, *((_QWORD *)this + 98));
  *((_QWORD *)this + 98) = v13;
  if ( *((_QWORD *)this + 99) )
  {
    (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 99) = 0i64;
  }
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180014090) ----------------------------------------------------
__int64 __fastcall CSslContext::PopulateSerialContextState(CSslContext *this, struct _SSL_PACKED_CONTEXT *a2)
{
  int v4; // r14d
  __int64 v5; // rax
  int v6; // ecx
  int v7; // eax
  unsigned int v8; // esi
  unsigned int v9; // ebp
  CCipherMill *v10; // rcx
  int v11; // edx
  __int64 v12; // rax
  int v13; // ecx
  __int64 result; // rax
  unsigned int v15; // esi
  __int64 v16; // rdx
  unsigned int v17; // eax
  int *v18; // rax
  unsigned int v19; // r9d

  *(_DWORD *)a2 = *((_DWORD *)this + 17);
  v4 = 0;
  *((_QWORD *)a2 + 1) = *((_QWORD *)this + 17);
  *((_DWORD *)a2 + 4) = *((_DWORD *)this + 16);
  *((_BYTE *)a2 + 44) = (*(__int64 (__fastcall **)(CSslContext *))(*(_QWORD *)this + 360i64))(this);
  *((_QWORD *)a2 + 10) = *((_QWORD *)this + 16);
  if ( (*((_BYTE *)this + 32) & 8) != 0 && (v5 = *((_QWORD *)this + 1)) != 0 )
    v6 = *(_DWORD *)(v5 + 28);
  else
    v6 = 0;
  *((_DWORD *)a2 + 5) = v6;
  *((_DWORD *)a2 + 7) = *(_DWORD *)(*((_QWORD *)this + 11) + 8i64);
  *((_DWORD *)a2 + 6) = *((_DWORD *)this + 4);
  if ( (*((_BYTE *)this + 32) & 8) != 0 )
    v7 = *((_DWORD *)this + 11);
  else
    v7 = 0;
  *((_DWORD *)a2 + 8) = v7;
  *((_DWORD *)a2 + 38) = *((_DWORD *)this + 15);
  v8 = *((_DWORD *)this + 11);
  v9 = *((_DWORD *)this + 13);
  v10 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_D(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      11i64,
      &WPP_c955f13c15ab3d9e41a0e2d56db0bfe4_Traceguids,
      *((unsigned int *)this + 16));
    v10 = WPP_GLOBAL_Control;
  }
  if ( CSslGlobals::m_bSendAuxRecord != 2
    && (CSslGlobals::m_bSendAuxRecord == 1 || (*(_DWORD *)(*((_QWORD *)this + 10) + 156i64) & 0x400) != 0) )
  {
    v11 = *((_DWORD *)this + 16);
    if ( (unsigned int)(v11 - 3) <= 0x2FE && ((v11 - 65277) & 0xFFFFFFFD) != 0 && (*((_BYTE *)this + 56) & 1) != 0 )
    {
      v19 = *((_DWORD *)this + 12);
      if ( v9 )
        v19 += v9 - v19 % v9;
      v8 = v19 + *((_DWORD *)this + 11) + *((_DWORD *)this + 15) - 1;
    }
  }
  if ( v10 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v10 + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)v10 + 2), 12i64, &WPP_c955f13c15ab3d9e41a0e2d56db0bfe4_Traceguids, v8);
  *((_DWORD *)a2 + 9) = v8;
  v12 = (*(__int64 (__fastcall **)(CSslContext *))(*(_QWORD *)this + 248i64))(this);
  if ( v12 )
    v13 = *(_DWORD *)(v12 + 428);
  else
    v13 = 0;
  *((_DWORD *)a2 + 10) = v13;
  result = (*(__int64 (__fastcall **)(CSslContext *, char *, char *))(*(_QWORD *)this + 64i64))(
             this,
             (char *)a2 + 144,
             (char *)a2 + 148);
  v15 = result;
  if ( (int)result >= 0 )
  {
    *((_QWORD *)a2 + 6) = *((_QWORD *)this + 22);
    *((_QWORD *)a2 + 7) = *((_QWORD *)this + 23);
    *((_DWORD *)a2 + 22) = 32;
    v16 = *((_QWORD *)this + 11);
    v17 = *(unsigned __int16 *)(v16 + 238);
    if ( v17 <= 0x20 )
    {
      *((_DWORD *)a2 + 22) = v17;
      memcpy_0((char *)a2 + 92, (const void *)(v16 + 240), *(unsigned __int16 *)(v16 + 238));
    }
    *((_DWORD *)a2 + 44) = *((_DWORD *)this + 48);
    *((_QWORD *)a2 + 20) = *((_QWORD *)this + 25);
    *((_QWORD *)a2 + 21) = *((_QWORD *)this + 26);
    *((_WORD *)a2 + 90) = *((_WORD *)this + 108);
    *((_WORD *)a2 + 91) = *((_WORD *)this + 109);
    v18 = (int *)*((_QWORD *)this + 28);
    if ( v18 )
      v4 = *v18;
    *((_DWORD *)a2 + 46) = v4;
    *((_DWORD *)a2 + 47) = CSslGlobals::m_dwMaxEncryptedRecords;
    *((_BYTE *)a2 + 192) = (*(__int64 (__fastcall **)(CSslContext *))(*(_QWORD *)this + 176i64))(this);
    return v15;
  }
  return result;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927BC: using guessed type unsigned int CSslGlobals::m_bSendAuxRecord;

//----- (0000000180014300) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::UpdateHandshakeHash(CSsl3TlsContext *this, unsigned __int8 *a2, unsigned int a3)
{
  __int64 v6; // rbx
  _QWORD *v7; // rax
  __int64 v8; // rcx
  unsigned int v9; // r14d

  if ( !a2 )
    return 0i64;
  if ( !a3 )
    return 0i64;
  if ( !*a2 )
    return 0i64;
  v6 = 0i64;
  if ( !*((_DWORD *)this + 137) )
    return 0i64;
  while ( 1 )
  {
    v7 = (_QWORD *)*((_QWORD *)this + 1);
    v8 = v7 ? *v7 : 0i64;
    v9 = SslHashHandshake(v8, *((_QWORD *)this + v6 + 74), a2, a3, 0);
    if ( v9 )
      break;
    v6 = (unsigned int)(v6 + 1);
    if ( (unsigned int)v6 >= *((_DWORD *)this + 137) )
      return 0i64;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 14i64, &WPP_a921c2bd799c3cf4dae399b64001ae9a_Traceguids, v9);
  return v9;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098420: using guessed type __int64 __fastcall SslHashHandshake(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);

//----- (00000001800143B0) ----------------------------------------------------
void __fastcall CSslContext::GetCertContextInfo(
        CSslContext *this,
        unsigned __int8 **a2,
        unsigned int *a3,
        unsigned __int16 **a4,
        unsigned int *a5,
        unsigned __int16 **a6,
        unsigned int *a7,
        unsigned __int8 **a8,
        unsigned int *a9,
        const unsigned __int8 **a10,
        unsigned int *a11,
        unsigned __int8 **a12,
        unsigned int *a13)
{
  __int64 v17; // rax
  unsigned int v18; // ecx
  unsigned int *v19; // rax
  __int64 v20; // rcx

  v17 = (*(__int64 (__fastcall **)(CSslContext *))(*(_QWORD *)this + 248i64))(this);
  if ( v17 )
  {
    *a4 = *(unsigned __int16 **)(v17 + 400);
    *a5 = *(_DWORD *)(v17 + 408);
    *a6 = *(unsigned __int16 **)(v17 + 416);
    v18 = *(_DWORD *)(v17 + 424);
    v19 = a7;
  }
  else
  {
    v18 = 0;
    *a6 = 0i64;
    *a4 = 0i64;
    *a7 = 0;
    v19 = a5;
  }
  *v19 = v18;
  v20 = *((_QWORD *)this + 11);
  *a3 = *(_DWORD *)(v20 + 32);
  *a2 = *(unsigned __int8 **)(v20 + 24);
  (*(void (__fastcall **)(CSslContext *, unsigned __int8 **, unsigned int *))(*(_QWORD *)this + 272i64))(this, a8, a9);
  (*(void (__fastcall **)(CSslContext *, const unsigned __int8 **, unsigned int *))(*(_QWORD *)this + 280i64))(
    this,
    a10,
    a11);
  (*(void (__fastcall **)(CSslContext *, unsigned __int8 **, unsigned int *))(*(_QWORD *)this + 288i64))(this, a12, a13);
}

//----- (0000000180014500) ----------------------------------------------------
HLOCAL __fastcall CSslContext::GetMemory(CSslContext *this, __int64 a2)
{
  __int64 v2; // rcx

  v2 = *(_QWORD *)(*((_QWORD *)this + 16) + 24i64);
  if ( v2 )
    return (HLOCAL)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v2 + 48i64))(v2, a2, 0i64);
  if ( LsaTable )
    return (HLOCAL)(*(__int64 (__fastcall **)(_QWORD))(LsaTable + 40))((unsigned int)a2);
  return LocalAlloc(0x40u, (unsigned int)a2);
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180014550) ----------------------------------------------------
__int64 __fastcall CSessionCacheTable::DereferenceCacheItemInternal(
        CSessionCacheTable *this,
        struct CSessionCacheItem *a2,
        char a3,
        char a4)
{
  unsigned __int32 v8; // ebx
  CSessionCacheTable **v9; // rdx
  CSessionCacheTable *v10; // rax

  if ( a3 && !a4 )
    RtlAcquireResourceExclusive((PRTL_RESOURCE)((char *)this + 48), 1u);
  v8 = _InterlockedDecrement((volatile signed __int32 *)a2 + 58);
  if ( v8 == 1 )
  {
    LsaIModifyPerformanceCounter(5i64);
    if ( !a3 )
      return v8;
    v9 = (CSessionCacheTable **)*((_QWORD *)this + 5);
    v10 = (struct CSessionCacheItem *)((char *)a2 + 320);
    if ( *v9 != (CSessionCacheTable *)((char *)this + 32) )
      __fastfail(3u);
    *(_QWORD *)v10 = (char *)this + 32;
    *((_QWORD *)a2 + 41) = v9;
    *v9 = v10;
    *((_QWORD *)this + 5) = v10;
  }
  else if ( !a3 )
  {
    return v8;
  }
  if ( !a4 )
    RtlReleaseResource((PRTL_RESOURCE)((char *)this + 48));
  return v8;
}
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);

//----- (0000000180014630) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetTBParameters(CSsl3TlsContext *this, struct _SecBuffer *const a2)
{
  void *v3; // rdi
  __int64 v4; // rdx
  struct _SEC_TOKEN_BINDING *pvBuffer; // rsi
  unsigned int TBParametersSize; // eax
  unsigned int v8; // r8d
  __int64 v9; // rbp
  __int64 (__fastcall *v10)(CSsl3TlsContext *, __int64); // r9
  void *v11; // rax
  CCipherMill *v12; // rcx
  __int64 v13; // rdx

  if ( a2 )
  {
    if ( a2->BufferType == 21 && a2->cbBuffer >= 6 && (pvBuffer = (struct _SEC_TOKEN_BINDING *)a2->pvBuffer) != 0i64 )
    {
      TBParametersSize = CSsl3TlsContext::GetTBParametersSize((struct _SEC_TOKEN_BINDING *const)a2->pvBuffer);
      if ( v8 < TBParametersSize )
      {
        v12 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v13 = 92i64;
      }
      else
      {
        if ( pvBuffer == (struct _SEC_TOKEN_BINDING *)-4i64 )
          return 87i64;
        if ( (unsigned __int16)(pvBuffer->KeyParametersSize - 1) <= 0xFEu )
        {
          v9 = (unsigned int)CSsl3TlsContext::GetTBParametersSize(pvBuffer);
          v11 = (void *)v10(this, v9);
          v3 = v11;
          if ( !v11 )
            return 14i64;
          memcpy_0(v11, pvBuffer, (unsigned int)v9);
          goto LABEL_3;
        }
        v12 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v13 = 90i64;
      }
    }
    else
    {
      v12 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074278i64;
      v13 = 91i64;
    }
    WPP_SF_(*((_QWORD *)v12 + 2), v13, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    return 2148074278i64;
  }
  v3 = 0i64;
LABEL_3:
  if ( *((_QWORD *)this + 102) )
    (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
  v4 = *((_QWORD *)this + 103);
  *((_QWORD *)this + 102) = v3;
  if ( v4 )
  {
    if ( *(_QWORD *)(v4 + 8) )
    {
      (*(void (__fastcall **)(CSsl3TlsContext *, _QWORD))(*(_QWORD *)this + 16i64))(this, *(_QWORD *)(v4 + 8));
      v4 = *((_QWORD *)this + 103);
    }
    (*(void (__fastcall **)(CSsl3TlsContext *, __int64))(*(_QWORD *)this + 16i64))(this, v4);
    *((_QWORD *)this + 103) = 0i64;
  }
  return 0i64;
}
// 1800146BC: variable 'v8' is possibly undefined
// 180014707: variable 'v10' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180014734) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::GetTBParametersSize(struct _SEC_TOKEN_BINDING *const a1)
{
  __int64 KeyParametersSize; // rax
  unsigned int v2; // ecx
  unsigned __int64 v3; // rax

  if ( !a1 )
    return 0i64;
  KeyParametersSize = a1->KeyParametersSize;
  v2 = 6;
  v3 = KeyParametersSize + 4;
  if ( v3 > 6 )
    return (unsigned int)v3;
  return v2;
}

//----- (0000000180014760) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::MakeRsaKeyXParameterList(
        __int64 a1,
        int a2,
        _DWORD *a3,
        __int64 a4,
        __int64 a5,
        int *a6)
{
  unsigned int v6; // eax
  __int64 v9; // rsi
  unsigned int v10; // ebp
  __int64 v11; // rdx
  unsigned int v12; // eax
  __int64 v13; // rdx
  int v14; // eax
  int v16; // r12d
  unsigned int v17; // r13d
  __int64 v18; // rax
  _QWORD *v19; // rcx
  int v20; // eax
  unsigned int v21; // r12d

  v6 = 0;
  if ( !a4 )
    return 87i64;
  v9 = *(_QWORD *)(a4 + 8);
  v10 = *(_DWORD *)(a4 + 4);
  if ( !a2 )
    goto LABEL_3;
  if ( a2 != 1 || !a3 || !v10 )
    return 87i64;
  *a3 = *(_DWORD *)(a1 + 36);
  v6 = 1;
  *(_DWORD *)(v9 + 4) = 22;
  *(_DWORD *)v9 = 4;
  *(_QWORD *)(v9 + 8) = a3;
  if ( (*(_DWORD *)(a1 + 136) & 0x8000000) == 0 )
  {
LABEL_3:
    if ( v10 >= v6 + 2 )
    {
      v11 = 2i64 * v6;
      v12 = v6 + 1;
      *(_QWORD *)(v9 + 8 * v11 + 8) = a1 + 272;
      *(_DWORD *)(v9 + 8 * v11 + 4) = 20;
      *(_DWORD *)(v9 + 8 * v11) = 32;
      v13 = 2i64 * v12;
      v14 = v12 + 1;
      *(_DWORD *)(v9 + 8 * v13 + 4) = 21;
      *(_DWORD *)(v9 + 8 * v13) = 32;
      *(_QWORD *)(v9 + 8 * v13 + 8) = a1 + 304;
LABEL_5:
      *(_DWORD *)(a4 + 4) = v14;
      return 0i64;
    }
    return 87i64;
  }
  if ( !a5 )
    return 87i64;
  if ( !a6 )
    return 87i64;
  v16 = *a6;
  if ( !*a6 )
    return 87i64;
  v17 = *(unsigned __int16 *)(a1 + 34);
  v18 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 512i64))(a1, 0i64);
  v19 = *(_QWORD **)(a1 + 8);
  if ( v19 )
    v19 = (_QWORD *)*v19;
  v20 = SslComputeSessionHash(v19, v18, v17, a5, v16, a6, 0);
  v21 = v20;
  if ( !v20 )
  {
    if ( v10 >= 2 )
    {
      *(_DWORD *)(v9 + 20) = 25;
      *(_DWORD *)(v9 + 16) = *a6;
      v14 = 2;
      *(_QWORD *)(v9 + 24) = a5;
      goto LABEL_5;
    }
    return 87i64;
  }
  CSslContext::SetErrorAndFatalAlert(a1, 604, v20, 0x33u);
  return v21;
}
// 180098530: using guessed type __int64 __fastcall SslComputeSessionHash(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);

//----- (0000000180014810) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetPSKParameters(
        CSsl3TlsContext *this,
        struct _SecBuffer *const a2,
        struct _SecBuffer *const a3)
{
  unsigned __int16 *pvBuffer; // rbp
  size_t v7; // rsi
  CCipherMill *v8; // rcx
  __int64 v9; // rdx
  void *v10; // rax
  unsigned int cbBuffer; // ecx
  unsigned __int16 *v12; // rsi
  size_t v13; // rbx
  void *v14; // rax

  if ( a2 )
  {
    if ( a2->BufferType != 22 || a2->cbBuffer < 4 || (pvBuffer = (unsigned __int16 *)a2->pvBuffer) == 0i64 )
    {
      v8 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074278i64;
      v9 = 93i64;
      goto LABEL_37;
    }
    v7 = (unsigned int)*pvBuffer + 2;
    if ( (unsigned int)v7 <= 4 )
    {
      v7 = 4i64;
    }
    else if ( a2->cbBuffer < (unsigned int)v7 )
    {
      v8 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074278i64;
      v9 = 94i64;
      goto LABEL_37;
    }
    if ( *((_QWORD *)this + 106) )
      (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
    v10 = (void *)(*(__int64 (__fastcall **)(CSsl3TlsContext *, size_t))(*(_QWORD *)this + 8i64))(this, v7);
    *((_QWORD *)this + 106) = v10;
    if ( !v10 )
      return 14i64;
    memcpy_0(v10, pvBuffer, v7);
  }
  if ( !a3 )
    return 0i64;
  if ( a3->BufferType != 23
    || (cbBuffer = a3->cbBuffer, a3->cbBuffer < 4)
    || (v12 = (unsigned __int16 *)a3->pvBuffer) == 0i64 )
  {
    v8 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v9 = 95i64;
    goto LABEL_37;
  }
  v13 = (unsigned int)*v12 + 2;
  if ( (unsigned int)v13 <= 4 )
  {
    v13 = 4i64;
LABEL_29:
    if ( *((_QWORD *)this + 107) )
      (*(void (__fastcall **)(CSsl3TlsContext *))(*(_QWORD *)this + 16i64))(this);
    v14 = (void *)(*(__int64 (__fastcall **)(CSsl3TlsContext *, size_t))(*(_QWORD *)this + 8i64))(this, v13);
    *((_QWORD *)this + 107) = v14;
    if ( v14 )
    {
      memcpy_0(v14, v12, v13);
      return 0i64;
    }
    return 14i64;
  }
  if ( cbBuffer >= (unsigned int)v13 )
    goto LABEL_29;
  v8 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
    return 2148074278i64;
  v9 = 96i64;
LABEL_37:
  WPP_SF_(*((_QWORD *)v8 + 2), v9, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
  return 2148074278i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180014860) ----------------------------------------------------
void __fastcall CSslContext::CleanupLsaModeKeys(CSslContext *this)
{
  __int64 v2; // rcx
  __int64 v3; // rcx

  v2 = *((_QWORD *)this + 19);
  if ( v2 )
  {
    SslFreeObject(v2, 0i64);
    *((_QWORD *)this + 19) = 0i64;
  }
  v3 = *((_QWORD *)this + 18);
  if ( v3 )
  {
    SslFreeObject(v3, 0i64);
    *((_QWORD *)this + 18) = 0i64;
  }
  if ( *((_BYTE *)this + 233) )
  {
    if ( *((_BYTE *)this + 264) )
      *((_QWORD *)this + 31) = 0i64;
  }
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (00000001800148D0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetSrtpParameters(
        CSsl3TlsContext *this,
        struct _SecBuffer *const a2,
        struct _SecBuffer *const a3)
{
  struct _SEC_SRTP_PROTECTION_PROFILES *pvBuffer; // rsi
  _BYTE *v4; // r14
  __int64 result; // rax
  CCipherMill *v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // rax
  int ProfilesSize; // edx
  int v13; // ecx
  int v14; // eax

  pvBuffer = 0i64;
  v4 = 0i64;
  if ( !*((_BYTE *)this + 233) )
  {
    if ( !a2 && !a3 )
      return 0i64;
    v9 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v10 = 84i64;
LABEL_46:
    WPP_SF_(*((_QWORD *)v9 + 2), v10, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    return 2148074278i64;
  }
  v11 = *((_QWORD *)this + 72);
  if ( v11 && *(_QWORD *)(v11 + 56) != v11 + 56 )
    return 0i64;
  if ( !a2 )
    goto LABEL_20;
  if ( a2->BufferType != 19
    || a2->cbBuffer < 4
    || (pvBuffer = (struct _SEC_SRTP_PROTECTION_PROFILES *)a2->pvBuffer) == 0i64 )
  {
    v9 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v10 = 85i64;
    goto LABEL_46;
  }
  ProfilesSize = pvBuffer->ProfilesSize;
  if ( a2->cbBuffer < ProfilesSize + 2 )
  {
    v9 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v10 = 86i64;
    goto LABEL_46;
  }
  result = CSsl3TlsContext::ValidateProtectionProfiles(pvBuffer->ProfilesList, ProfilesSize, 1);
  if ( !(_DWORD)result )
  {
LABEL_20:
    if ( a3 )
    {
      if ( !a2 || a3->BufferType != 20 || a3->cbBuffer < 2 || (v4 = a3->pvBuffer) == 0i64 )
      {
        v9 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v10 = 87i64;
        goto LABEL_46;
      }
      if ( !*v4 || a3->cbBuffer < (unsigned int)(unsigned __int8)*v4 + 1 )
      {
        v9 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return 2148074278i64;
        v10 = 88i64;
        goto LABEL_46;
      }
    }
    if ( pvBuffer )
      v13 = pvBuffer->ProfilesSize + 2;
    else
      v13 = 0;
    if ( v4 )
      v14 = (unsigned __int8)*v4 + 1;
    else
      v14 = 1;
    if ( (unsigned int)(v13 + v14) > 0xFFFF )
    {
      v9 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
        return 2148074278i64;
      v10 = 89i64;
      goto LABEL_46;
    }
    result = CSsl3TlsContext::SetSrtpProtectionProfiles(this, pvBuffer);
    if ( !(_DWORD)result )
    {
      result = (*(__int64 (__fastcall **)(CSsl3TlsContext *, _BYTE *))(*(_QWORD *)this + 440i64))(this, v4);
      if ( !(_DWORD)result )
      {
        CSsl3TlsContext::FreeSelectedSrtpParameters(this);
        return 0i64;
      }
    }
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180014940) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetPMTU(CSsl3TlsContext *this, struct _SecBuffer *const a2)
{
  unsigned __int16 *pvBuffer; // rax
  int v4; // r10d
  unsigned __int16 v5; // ax
  __int64 v6; // rcx
  __int16 v7; // r10

  if ( !*((_BYTE *)this + 233) || !a2 )
    return 0i64;
  if ( a2->BufferType == 24 && a2->cbBuffer == 2 && (pvBuffer = (unsigned __int16 *)a2->pvBuffer) != 0i64 )
  {
    v4 = *pvBuffer;
    if ( (unsigned __int16)v4 >= 0xC8u )
    {
      v5 = CSslContext::computeMaxPayload(this, v4);
      if ( v5 )
      {
        *(_WORD *)(v6 + 216) = v7;
        *(_WORD *)(v6 + 218) = v5;
        return 0i64;
      }
    }
    return 87i64;
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 97i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    return 2148074278i64;
  }
}
// 18003D982: variable 'v7' is possibly undefined
// 18003D982: variable 'v6' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180014970) ----------------------------------------------------
void __fastcall CSslContext::GetReadWriteApplicationTrafficSecrets(
        CSslContext *this,
        unsigned __int64 *a2,
        unsigned __int64 *a3)
{
  if ( a2 )
    *a2 = 0i64;
  if ( a3 )
    *a3 = 0i64;
}

//----- (0000000180014990) ----------------------------------------------------
void __fastcall CSsl3TlsContext::GetUniqueBindings(CSsl3TlsContext *this, unsigned __int8 **a2, unsigned int *a3)
{
  *a2 = (unsigned __int8 *)this + 341;
  *a3 = (*((_DWORD *)this + 16) & 0x3FC0) != 0 ? 12 : 36;
}

//----- (00000001800149C0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::ProcessRecord(__int64 a1, int a2, unsigned __int8 *a3, unsigned int a4)
{
  int v4; // r10d
  __int64 result; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rcx
  unsigned int SessionKeys; // esi

  v4 = *(_DWORD *)(a1 + 68);
  if ( v4 != 51 )
  {
LABEL_2:
    if ( a2 != 20 )
      return CSsl3TlsContext::ProcessRecord(a1, a2, a3, a4);
    if ( v4 == 46 )
    {
LABEL_6:
      if ( !(unsigned int)CSsl3TlsContext::DigestCcs((CSsl3TlsContext *)a1, a3, a4) )
      {
        if ( *(_DWORD *)(a1 + 68) == 47 || *(_DWORD *)(a1 + 68) == 52 )
          *(_DWORD *)(a1 + 68) = 48;
        else
          *(_DWORD *)(a1 + 68) = 45;
      }
      return CSsl3TlsContext::ProcessRecord(a1, a2, a3, a4);
    }
    if ( v4 != 47 )
    {
      if ( v4 == 50 )
        goto LABEL_6;
      if ( v4 != 52 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_Sd(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0xDu,
            (__int64)&WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
            *(const wchar_t **)(*(_QWORD *)(a1 + 1320) + 368i64),
            v4);
        return CSsl3TlsContext::ProcessRecord(a1, a2, a3, a4);
      }
    }
    v10 = *(_QWORD *)(a1 + 136);
    if ( (v10 & 0x1000000) != 0 )
    {
      if ( (v10 & 0x8000000) == 0 )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        CSslContext::SetErrorAndFatalAlert(a1, 106, -2146893018, 0x28u);
        return CSsl3TlsContext::ProcessRecord(a1, a2, a3, a4);
      }
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_S(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xBu,
          (__int64)&WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
          *(const wchar_t **)(*(_QWORD *)(a1 + 1320) + 368i64));
      v11 = *(_QWORD *)(a1 + 120);
      if ( v11 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
      {
        *(_DWORD *)(v11 + 24) = 1;
        *(_WORD *)(v11 + 64) |= 0xAu;
      }
      v12 = *(_QWORD *)(a1 + 1320);
      *(_QWORD *)(a1 + 136) &= ~0x1000000ui64;
      RtlAcquireResourceShared((PRTL_RESOURCE)(v12 + 72), 1u);
      SessionKeys = CSslContext::MakeSessionKeys((CSslContext *)a1, *(_QWORD *)(*(_QWORD *)(a1 + 1320) + 16i64));
      RtlReleaseResource((PRTL_RESOURCE)(*(_QWORD *)(a1 + 1320) + 72i64));
      if ( SessionKeys )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            12i64,
            &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
            SessionKeys);
        return CSsl3TlsContext::ProcessRecord(a1, a2, a3, a4);
      }
    }
    goto LABEL_6;
  }
  if ( (*(_DWORD *)(a1 + 136) & 0x40000000) == 0 || *(_BYTE *)(a1 + 266) )
  {
LABEL_14:
    *(_DWORD *)(a1 + 68) = 46;
    v4 = 46;
    goto LABEL_2;
  }
  result = RemotelyGetUserKeys((struct CSslContext *)a1, 2u);
  if ( !(_DWORD)result )
  {
    *(_QWORD *)(a1 + 136) &= ~0x40000000ui64;
    goto LABEL_14;
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180014AB0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::ProcessRecord(__int64 a1, int a2, unsigned __int8 *a3, unsigned int a4)
{
  unsigned int v4; // ebp
  unsigned __int8 *v5; // rsi
  __int64 v8; // rax
  bool v9; // cl
  int v10; // ebx
  __int64 v11; // r14
  unsigned int v12; // ebx
  __int64 result; // rax
  __int64 v14; // r10
  unsigned int v15; // r9d
  unsigned int v16; // ecx
  CTlsMessageFragment *v17; // rcx
  unsigned int v18; // eax
  bool v19; // zf
  _QWORD *Memory; // rax
  CCipherMill *v21; // rcx
  bool v22; // zf
  CCipherMill *v23; // rcx
  bool v24; // zf
  unsigned int v25; // eax
  bool v26; // zf
  int v27; // eax
  unsigned int v28[4]; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int8 v29; // [rsp+70h] [rbp+8h] BYREF

  v4 = a4;
  v5 = a3;
  if ( *(_BYTE *)(a1 + 233) )
    return CSsl3TlsContext::DtlsProcessRecord(a1, a2, a3, a4);
  v8 = *(_QWORD *)(a1 + 464);
  v28[0] = 0;
  v9 = 1;
  if ( !v8 || !*(_DWORD *)(v8 + 36) )
  {
LABEL_3:
    v10 = a2 - 21;
    if ( !v10 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 57i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
      v27 = TlsParseAlertMessage(v5, v4, (unsigned __int8 *)(a1 + 473), &v29);
      v12 = v27;
      if ( v27 )
      {
        if ( v27 == -2146892953 || *(_DWORD *)(a1 + 36) < 0x302u || (*(_DWORD *)(a1 + 64) & 0x800A00AA) == 0 )
        {
          if ( v4 == 2 )
            LogReceiveAlertEvent(
              *(_DWORD *)(*(_QWORD *)(a1 + 80) + 212i64),
              (const unsigned __int16 *)(*(_QWORD *)(a1 + 80) + 216i64),
              *v5,
              v5[1]);
        }
        else
        {
          CSslContext::SetError(a1, 14, v27);
          return (unsigned int)-2146893018;
        }
      }
      else if ( v29 )
      {
        *(_BYTE *)(a1 + 552) = 1;
        *(_DWORD *)(a1 + 68) = 75;
      }
      return v12;
    }
    if ( v10 != 1 )
      return 0;
    while ( v4 >= 4 )
    {
      v11 = v5[3] + (v5[1] << 16) + (v5[2] << 8);
      if ( v11 + 4 > (unsigned __int64)v4 )
      {
        v17 = *(CTlsMessageFragment **)(a1 + 464);
        if ( v17 )
          goto LABEL_52;
        if ( (*(_DWORD *)(a1 + 64) & 0x40051555) != 0 )
        {
          if ( (*(_DWORD *)(a1 + 136) & 0x100i64) == 0 )
            goto LABEL_36;
          v18 = CSslGlobals::m_dwTlsMessageLimitSrvClientAuth;
          if ( CSslGlobals::m_dwTlsMessageLimitSrv > CSslGlobals::m_dwTlsMessageLimitSrvClientAuth )
            v18 = CSslGlobals::m_dwTlsMessageLimitSrv;
          if ( v18 )
          {
LABEL_36:
            v19 = CSslGlobals::m_dwTlsMessageLimitSrv == 0;
            goto LABEL_38;
          }
          goto LABEL_41;
        }
        v19 = CSslGlobals::m_dwTlsMessageLimitClient == 0;
LABEL_38:
        if ( !v19 )
        {
          Memory = CSslContext::GetMemory((CSslContext *)a1, 0x30u);
          if ( !Memory )
          {
            v21 = WPP_GLOBAL_Control;
            v22 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
LABEL_47:
            if ( !v22 && (*((_BYTE *)v21 + 28) & 1) != 0 )
              WPP_SF_(*((_QWORD *)v21 + 2), 68i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
            return 14;
          }
LABEL_51:
          *Memory = 0i64;
          *(_QWORD *)((char *)Memory + 12) = 256i64;
          Memory[3] = 0i64;
          Memory[4] = 0i64;
          *(_QWORD *)(a1 + 464) = Memory;
          CTlsMessageFragment::Initialize((CTlsMessageFragment *)Memory, (struct CSsl3TlsContext *)a1);
          v17 = *(CTlsMessageFragment **)(a1 + 464);
LABEL_52:
          v28[0] = 0;
          return (unsigned int)CTlsMessageFragment::SaveFragment(v17, v5, v4, 1, v28);
        }
LABEL_41:
        v23 = WPP_GLOBAL_Control;
        v24 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
LABEL_43:
        if ( !v24 && (*((_BYTE *)v23 + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)v23 + 2), 67i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        v12 = -2146893018;
        CSslContext::SetErrorAndFatalAlert(a1, 12, -2146893018, 0xAu);
        return v12;
      }
      v12 = CSsl3TlsContext::ProcessHandshakeCommon((CSsl3TlsContext *)a1, v5, (int)v11 + 4);
      if ( !v12 )
      {
        v5 += v11 + 4;
        v4 += -4 - v11;
        if ( v4 )
          continue;
      }
      return v12;
    }
    v17 = *(CTlsMessageFragment **)(a1 + 464);
    if ( v17 )
      goto LABEL_52;
    if ( (*(_DWORD *)(a1 + 64) & 0x40051555) != 0 )
    {
      if ( (*(_DWORD *)(a1 + 136) & 0x100i64) != 0 )
      {
        v25 = CSslGlobals::m_dwTlsMessageLimitSrvClientAuth;
        if ( CSslGlobals::m_dwTlsMessageLimitSrv > CSslGlobals::m_dwTlsMessageLimitSrvClientAuth )
          v25 = CSslGlobals::m_dwTlsMessageLimitSrv;
        if ( !v25 )
        {
LABEL_42:
          v23 = WPP_GLOBAL_Control;
          v24 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
          goto LABEL_43;
        }
      }
      v26 = CSslGlobals::m_dwTlsMessageLimitSrv == 0;
    }
    else
    {
      v26 = CSslGlobals::m_dwTlsMessageLimitClient == 0;
    }
    if ( !v26 )
    {
      Memory = CSslContext::GetMemory((CSslContext *)a1, 0x30u);
      if ( !Memory )
      {
        v21 = WPP_GLOBAL_Control;
        v22 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
        goto LABEL_47;
      }
      goto LABEL_51;
    }
    goto LABEL_42;
  }
  if ( a2 != 22 )
  {
    if ( a2 == 21 )
      *(_QWORD *)(v8 + 32) = 0i64;
LABEL_12:
    result = 0i64;
    if ( !v9 )
      return result;
    goto LABEL_3;
  }
  result = CTlsMessageFragment::SaveFragment((CTlsMessageFragment *)v8, a3, a4, 0, v28);
  if ( !(_DWORD)result )
  {
    v14 = *(_QWORD *)(a1 + 464);
    v15 = *(_DWORD *)(v14 + 32);
    v16 = *(_DWORD *)(v14 + 40) != 0 ? 12 : 4;
    if ( (v15 <= v16 || *(_DWORD *)(v14 + 36) < v15)
      && (*(_DWORD *)(v14 + 36) < v16
       || *(unsigned __int8 *)(*(_QWORD *)(v14 + 24) + 3i64)
        + (*(unsigned __int8 *)(*(_QWORD *)(v14 + 24) + 1i64) << 16)
        + (*(unsigned __int8 *)(*(_QWORD *)(v14 + 24) + 2i64) << 8)) )
    {
      return 0i64;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_d(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x45u,
        (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
        v15);
      v14 = *(_QWORD *)(a1 + 464);
    }
    result = CSsl3TlsContext::ProcessHandshakeCommon(
               (CSsl3TlsContext *)a1,
               *(unsigned __int8 **)(v14 + 24),
               *(_DWORD *)(v14 + 32));
    if ( !(_DWORD)result )
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 464) + 32i64) = 0i64;
      v5 += v28[0];
      v4 -= v28[0];
      v9 = v4 != 0;
      goto LABEL_12;
    }
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180014B9C) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::ProcessHandshakeCommon(CSsl3TlsContext *this, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v6; // edi
  unsigned int v7; // eax
  int v9; // [rsp+40h] [rbp+8h] BYREF

  v9 = 0;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_DDD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x3Au,
      (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
      *((_DWORD *)this + 16),
      *a2,
      *((_DWORD *)this + 17));
  v6 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, unsigned __int8 *, _QWORD, int *))(*(_QWORD *)this + 416i64))(
         this,
         a2,
         a3,
         &v9);
  if ( (!v6 || v6 == 590624) && !v9 && !*((_DWORD *)this + 218) )
  {
    v7 = (*(__int64 (__fastcall **)(CSsl3TlsContext *, unsigned __int8 *, _QWORD, _QWORD))(*(_QWORD *)this + 504i64))(
           this,
           a2,
           a3,
           0i64);
    if ( v7 )
      v6 = v7;
  }
  if ( *((_BYTE *)this + 923) )
  {
    v6 = 590610;
    *((_DWORD *)this + 18) = *((_DWORD *)this + 17);
    *((_DWORD *)this + 17) = 77;
  }
  else if ( v6 == 590624 )
  {
    *((_BYTE *)this + 924) = 1;
  }
  return v6;
}

//----- (0000000180014C84) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::DigestCcs(CSsl3TlsContext *this, unsigned __int8 *a2, int a3)
{
  __int64 v4; // rcx
  __int64 v5; // rax
  char v6; // al

  if ( a3 == 1 && *a2 == 1 )
  {
    *((_WORD *)this + 16) |= 0xAu;
    v4 = *((_QWORD *)this + 18);
    if ( v4 )
      SslFreeObject(v4, 0i64);
    v5 = *((_QWORD *)this + 20);
    *((_QWORD *)this + 20) = 0i64;
    *((_QWORD *)this + 18) = v5;
    v6 = *((_BYTE *)this + 233);
    if ( !v6 )
      *((_QWORD *)this + 22) = 0i64;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 60i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
      v6 = *((_BYTE *)this + 233);
    }
    if ( v6 )
    {
      ++*((_DWORD *)this + 48);
      *((_QWORD *)this + 26) = 0i64;
      *((_QWORD *)this + 25) = 0i64;
    }
    return 0i64;
  }
  else
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 904, -2146893018, 0xAu);
    return 2148074278i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180014D20) ----------------------------------------------------
unsigned __int64 __fastcall CSsl3TlsContext::GetHandshakeHash(CSsl3TlsContext *this, enum _eTlsHashAlgorithm a2)
{
  if ( a2 )
    return CSsl3TlsContext::FindTlsClientAuthHandshakeHash(this, a2);
  else
    return *((_QWORD *)this + 74);
}

//----- (0000000180014D38) ----------------------------------------------------
__int64 __fastcall I_GetHashInfoFromAlgorithmName(wchar_t *String1)
{
  unsigned int v1; // eax
  __int64 v2; // rbx
  const wchar_t **v4; // rdx
  const wchar_t *v5; // rdx

  v1 = g_dwHashInfoTotalCount;
  v2 = 0i64;
  if ( !g_dwHashInfoTotalCount )
    return 0i64;
  while ( 1 )
  {
    v4 = (const wchar_t **)g_pHashInfo[v2];
    if ( !v4 )
      goto LABEL_6;
    v5 = *v4;
    if ( !v5 )
      goto LABEL_6;
    if ( !wcsnicmp(String1, v5, 0x40ui64) )
      return g_pHashInfo[v2];
    v1 = g_dwHashInfoTotalCount;
LABEL_6:
    v2 = (unsigned int)(v2 + 1);
    if ( (unsigned int)v2 >= v1 )
      return 0i64;
  }
}
// 180092324: using guessed type int g_dwHashInfoTotalCount;
// 180092330: using guessed type _QWORD g_pHashInfo[16];

//----- (0000000180014DB8) ----------------------------------------------------
DWORD __fastcall GetPublicKeyFromCert(const struct _CERT_CONTEXT *a1, struct _PUBLICKEY **a2, unsigned int *a3)
{
  PCERT_INFO pCertInfo; // rbx
  struct _CERT_PUBLIC_KEY_INFO *p_SubjectPublicKeyInfo; // rsi
  int v7; // eax
  unsigned int v8; // edi
  DWORD result; // eax
  int v10; // eax
  int v11; // eax
  char *v12; // rax
  unsigned int *v13; // rbx
  DWORD v14; // eax
  DWORD v15; // esi
  unsigned int *v16; // rax
  PCCRYPT_OID_INFO v17; // rdx
  int v18; // edi
  char *v19; // rax
  __int64 v20; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v21; // [rsp+60h] [rbp+30h] BYREF
  int v22; // [rsp+78h] [rbp+48h] BYREF

  pCertInfo = a1->pCertInfo;
  v20 = 0i64;
  p_SubjectPublicKeyInfo = &pCertInfo->SubjectPublicKeyInfo;
  if ( pCertInfo == (PCERT_INFO)-96i64 )
    return -2146893052;
  v7 = MapOidToKeyExch(p_SubjectPublicKeyInfo->Algorithm.pszObjId);
  v22 = v7;
  v8 = v7;
  if ( !v7 )
    return -2146893043;
  v10 = v7 - 8704;
  if ( v10 )
  {
    v11 = v10 - 3;
    if ( !v11 )
    {
      result = GetAlgIdFromEccTypeCertParameters(
                 pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
                 pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData,
                 (PCCRYPT_OID_INFO *)&v20,
                 &v22);
      if ( result )
        return result;
      result = EcdsaPublicKeyFromCert((__int64)&pCertInfo->SubjectPublicKeyInfo, v20, 0i64, &v21);
      if ( result )
        return result;
      if ( v21 < 0xFFFFFFF0 )
      {
        v16 = (unsigned int *)SPExternalAlloc(v21 + 16);
        v13 = v16;
        if ( v16 )
        {
          v17 = (PCCRYPT_OID_INFO)v20;
          *(_QWORD *)v16 = v16 + 4;
          v16[2] = v21;
          v18 = EcdsaPublicKeyFromCert((__int64)p_SubjectPublicKeyInfo, (__int64)v17, v16 + 4, v16 + 2);
          if ( v18 )
          {
            SPExternalFree(v13);
            return v18;
          }
          v8 = v22;
          goto LABEL_20;
        }
        return -2146893056;
      }
      return 534;
    }
    if ( v11 == 33277 )
    {
      result = RsaPublicKeyFromCert(&pCertInfo->SubjectPublicKeyInfo, 0i64, &v21);
      if ( result )
        return result;
      if ( v21 < 0xFFFFFFF0 )
      {
        v12 = (char *)SPExternalAlloc(v21 + 16);
        v13 = (unsigned int *)v12;
        if ( v12 )
        {
          *(_QWORD *)v12 = v12 + 16;
          *((_DWORD *)v12 + 2) = v21;
          v14 = RsaPublicKeyFromCert(p_SubjectPublicKeyInfo, (struct _PUBLICKEYSTRUC *)v12 + 2, (unsigned int *)v12 + 2);
          goto LABEL_11;
        }
        return -2146893056;
      }
      return 534;
    }
    return -2146893052;
  }
  result = DssPublicKeyFromCert(&pCertInfo->SubjectPublicKeyInfo, 0i64, &v21);
  if ( result )
    return result;
  if ( v21 + 16 < v21 )
    return -2146893056;
  v19 = (char *)SPExternalAlloc(v21 + 16);
  v13 = (unsigned int *)v19;
  if ( !v19 )
    return -2146893056;
  *(_QWORD *)v19 = v19 + 16;
  *((_DWORD *)v19 + 2) = v21;
  v14 = DssPublicKeyFromCert(p_SubjectPublicKeyInfo, (struct _PUBLICKEYSTRUC *)v19 + 2, (unsigned int *)v19 + 2);
LABEL_11:
  v15 = v14;
  if ( v14 )
  {
    SPExternalFree(v13);
    return v15;
  }
LABEL_20:
  *a2 = (struct _PUBLICKEY *)v13;
  if ( a3 )
    *a3 = v8;
  return 0;
}

//----- (0000000180014F8C) ----------------------------------------------------
DWORD __fastcall RsaPublicKeyFromCert(
        struct _CERT_PUBLIC_KEY_INFO *a1,
        struct _PUBLICKEYSTRUC *pvStructInfo,
        unsigned int *pcbStructInfo)
{
  if ( CryptDecodeObject(1u, (LPCSTR)0x13, a1->PublicKey.pbData, a1->PublicKey.cbData, 0, pvStructInfo, pcbStructInfo) )
    return 0;
  else
    return GetLastError();
}

//----- (0000000180014FD4) ----------------------------------------------------
__int64 __fastcall MapOidToKeyExch(char *a1)
{
  const struct _OIDPROVMAP near *const *v2; // r8
  __int64 v3; // rax
  char *v4; // rdx
  int v5; // r10d
  int v6; // ecx

  v2 = &g_CertTypes;
  v3 = 0i64;
  do
  {
    v4 = a1;
    do
    {
      v5 = (unsigned __int8)v4[(unsigned __int64)(*v2 - (const struct _OIDPROVMAP near *const)a1)];
      v6 = (unsigned __int8)*v4 - v5;
      if ( v6 )
        break;
      ++v4;
    }
    while ( v5 );
    if ( !v6 )
      return *((unsigned int *)&g_CertTypes + 4 * v3 + 2);
    v3 = (unsigned int)(v3 + 1);
    v2 += 2;
  }
  while ( (unsigned int)v3 < 8 );
  return 0i64;
}
// 18007D750: using guessed type const struct _OIDPROVMAP near *const g_CertTypes;

//----- (0000000180015030) ----------------------------------------------------
__int64 __fastcall EcdsaPublicKeyFromCert(__int64 a1, __int64 a2, _DWORD *a3, unsigned int *a4)
{
  unsigned int v4; // r10d
  __int64 v6; // r8
  int v7; // eax
  _BYTE *v8; // rdx
  int v9; // ebx
  int v10; // edi
  int v11; // ecx
  unsigned int v12; // eax
  unsigned int v13; // ecx

  v4 = 0;
  if ( a2 )
  {
    v6 = *(_QWORD *)(a2 + 40);
    if ( v6 )
    {
      v7 = *(_DWORD *)(a2 + 32);
      if ( v7 )
      {
        if ( a1 )
        {
          v8 = *(_BYTE **)(a1 + 32);
          if ( v8 )
          {
            v9 = *(_DWORD *)(a1 + 24);
            if ( v9 )
            {
              if ( (v7 & 0xFFFFFFFC) >= 0xC )
              {
                v10 = *(_DWORD *)(v6 + 4);
                v11 = (*(_DWORD *)(v6 + 8) >> 3) + ((*(_DWORD *)(v6 + 8) & 7) != 0);
                if ( v11 )
                {
                  v12 = 2 * v11 + 16;
                  if ( a3 )
                  {
                    if ( *a4 >= v12 )
                    {
                      a3[3] = v11;
                      v13 = 2 * v11;
                      *a3 = 518;
                      a3[1] = 8707;
                      a3[2] = v10;
                      if ( v13 + 1 == v9 && ((*v8 - 4) & 0xFC) == 0 && *v8 != 5 )
                      {
                        memcpy_0(a3 + 4, v8 + 1, v13);
                        return 0i64;
                      }
                      return 2148074333i64;
                    }
                    v4 = -2146893023;
                  }
                  *a4 = v12;
                  return v4;
                }
              }
            }
          }
        }
      }
    }
  }
  return 2148074333i64;
}

//----- (0000000180015120) ----------------------------------------------------
__int64 __fastcall GetAlgIdFromEccTypeCertParameters(
        BYTE *pbEncoded,
        DWORD cbEncoded,
        PCCRYPT_OID_INFO *a3,
        _DWORD *a4)
{
  PCCRYPT_OID_INFO OIDInfo; // rax
  __int64 v7; // rdx
  int LastError; // eax
  unsigned int v9; // ebx
  DWORD v11; // [rsp+40h] [rbp-18h] BYREF
  HLOCAL hMem[2]; // [rsp+48h] [rbp-10h] BYREF

  hMem[0] = 0i64;
  v11 = 8;
  if ( !CryptDecodeObjectEx(1u, (LPCSTR)0x49, pbEncoded, cbEncoded, 0x8000u, 0i64, hMem, &v11) )
  {
    LastError = GetLastError();
LABEL_5:
    v9 = LastError;
    goto LABEL_6;
  }
  OIDInfo = CryptFindOIDInfo(1u, *(void **)hMem[0], 3u);
  *a3 = OIDInfo;
  if ( OIDInfo )
  {
    LastError = I_GetSignatureDetailsFromAlgorithmName(*(wchar_t **)&OIDInfo[1].cbSize, v7, a4);
    if ( LastError )
      LastError = -2146893043;
    goto LABEL_5;
  }
  v9 = -2146893043;
LABEL_6:
  if ( hMem[0] )
    LocalFree(hMem[0]);
  return v9;
}
// 1800151AB: variable 'v7' is possibly undefined
// 180015120: using guessed type HLOCAL hMem[2];

//----- (00000001800151F0) ----------------------------------------------------
__int64 __fastcall I_GetKeyExchangeDetailsFromAlgorithmName(wchar_t *String1, __int64 a2, _DWORD *a3)
{
  unsigned int v5; // eax
  __int64 v6; // rbx
  const wchar_t **v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // r8
  __int64 v11; // rcx

  if ( a3 )
    *a3 = 0;
  v5 = g_dwKeyExchangeInfoTotalCount;
  v6 = 0i64;
  if ( !g_dwKeyExchangeInfoTotalCount )
    return 1168i64;
  while ( 1 )
  {
    v7 = (const wchar_t **)g_pKeyExchangeInfo[v6];
    if ( !v7 || !*v7 )
      goto LABEL_8;
    if ( !wcsnicmp(String1, *v7, 0x40ui64) )
      break;
    v5 = g_dwKeyExchangeInfoTotalCount;
LABEL_8:
    v6 = (unsigned int)(v6 + 1);
    if ( (unsigned int)v6 >= v5 )
      return 1168i64;
  }
  v11 = g_pKeyExchangeInfo[v6];
  if ( !v11 )
    return 1168i64;
  return I_GetKeyExchangeDetailsFromKeyExchangeInfo(v11, v8, v9, a3, 0i64);
}
// 180015273: variable 'v8' is possibly undefined
// 180015273: variable 'v9' is possibly undefined
// 1800923B0: using guessed type int g_dwKeyExchangeInfoTotalCount;
// 1800923C0: using guessed type _QWORD g_pKeyExchangeInfo[12];

//----- (000000018001529C) ----------------------------------------------------
__int64 __fastcall I_GetKeyExchangeDetailsFromKeyExchangeInfo(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        _DWORD *a4,
        _DWORD *a5)
{
  if ( a4 )
    *a4 = *(_DWORD *)(a1 + 12);
  if ( a5 )
    *a5 = *(_DWORD *)(a1 + 16);
  return 0i64;
}

//----- (00000001800152C4) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::SetSelectedApplicationProtocol(
        CSsl3TlsClientContext *this,
        unsigned __int8 *const a2,
        unsigned __int16 a3)
{
  __int64 result; // rax
  __int64 v7; // rax
  unsigned __int8 *MatchingApplicationProtocol; // rdi
  _DWORD *v9; // rax

  result = CSsl3TlsContext::ValidateApplicationProtocolList(SecApplicationProtocolNegotiationExt_ALPN, a2, a3, 0);
  if ( !(_DWORD)result )
  {
    v7 = *((_QWORD *)this + 98);
    if ( v7 )
    {
      MatchingApplicationProtocol = CSsl3TlsContext::FindMatchingApplicationProtocol(
                                      (unsigned __int8 *const)(v7 + 6),
                                      *(_WORD *)(v7 + 4),
                                      a2,
                                      a3);
      if ( MatchingApplicationProtocol )
      {
        v9 = (_DWORD *)*((_QWORD *)this + 99);
        if ( v9
          || (v9 = (_DWORD *)(*(__int64 (__fastcall **)(CSsl3TlsClientContext *, __int64))(*(_QWORD *)this + 8i64))(
                               this,
                               264i64),
              (*((_QWORD *)this + 99) = v9) != 0i64) )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_D(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              69i64,
              &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids,
              *MatchingApplicationProtocol);
            v9 = (_DWORD *)*((_QWORD *)this + 99);
          }
          *v9 = 1;
          *(_DWORD *)(*((_QWORD *)this + 99) + 4i64) = 2;
          *(_BYTE *)(*((_QWORD *)this + 99) + 8i64) = *MatchingApplicationProtocol;
          memcpy_0(
            (void *)(*((_QWORD *)this + 99) + 9i64),
            MatchingApplicationProtocol + 1,
            *MatchingApplicationProtocol);
          return 0i64;
        }
        else
        {
          return 14i64;
        }
      }
      else
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 68i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
        return 2148074343i64;
      }
    }
    else
    {
      return 87i64;
    }
  }
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (00000001800153D0) ----------------------------------------------------
unsigned __int8 *__fastcall CSsl3TlsContext::FindMatchingApplicationProtocol(
        unsigned __int8 *const a1,
        unsigned __int16 a2,
        unsigned __int8 *const a3,
        unsigned __int16 a4)
{
  unsigned __int8 *v5; // rbx
  unsigned __int8 *v6; // r14
  unsigned __int8 *v7; // rbp
  unsigned __int8 *v8; // rdi
  __int64 v9; // rcx
  SIZE_T v10; // rax

  v5 = a1;
  if ( !a1 )
    return 0i64;
  if ( !a3 )
    return 0i64;
  v6 = &a1[a2];
  if ( a1 >= v6 )
    return 0i64;
  v7 = &a3[a4];
  while ( 1 )
  {
    v8 = a3;
    if ( a3 < v7 )
      break;
LABEL_11:
    v5 += *v5 + 1;
    if ( v5 >= v6 )
      return 0i64;
  }
  LOBYTE(v9) = *v5;
  while ( 1 )
  {
    if ( (_BYTE)v9 == *v8 )
    {
      v10 = RtlCompareMemory(v5 + 1, v8 + 1, (unsigned __int8)v9);
      v9 = *v5;
      if ( v10 == v9 )
        return v5;
    }
    v8 += *v8 + 1;
    if ( v8 >= v7 )
      goto LABEL_11;
  }
}

//----- (0000000180015484) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::ValidateApplicationProtocolList(
        enum _SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT a1,
        unsigned __int8 *const a2,
        unsigned __int16 a3,
        int a4)
{
  unsigned __int8 *v4; // rcx
  unsigned __int8 *v5; // rdx
  CCipherMill *v7; // rcx
  __int64 v8; // rdx

  if ( !a2 || a1 != SecApplicationProtocolNegotiationExt_ALPN )
    return 87i64;
  if ( (unsigned __int16)(a3 - 2) > 0xFFFBu )
  {
    v7 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v8 = 74i64;
  }
  else if ( a4 || (unsigned int)*a2 + 1 >= a3 )
  {
    v4 = &a2[a3];
    while ( 1 )
    {
      if ( a2 >= v4 )
        return 0i64;
      if ( !*a2 )
        break;
      v5 = &a2[*a2];
      if ( v5 >= v4 )
        break;
      a2 = v5 + 1;
    }
    v7 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v8 = 76i64;
  }
  else
  {
    v7 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return 2148074278i64;
    v8 = 75i64;
  }
  WPP_SF_(*((_QWORD *)v7 + 2), v8, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
  return 2148074278i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180015504) ----------------------------------------------------
__int64 __fastcall I_GetSignatureDetailsFromAlgorithmName(wchar_t *String1, __int64 a2, _DWORD *a3)
{
  unsigned int v5; // eax
  __int64 v6; // rbx
  const wchar_t **v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // r8
  _DWORD *v11; // rcx

  if ( a3 )
    *a3 = 0;
  v5 = g_dwSignatureInfoTotalCount;
  v6 = 0i64;
  if ( !g_dwSignatureInfoTotalCount )
    return 1168i64;
  while ( 1 )
  {
    v7 = (const wchar_t **)g_pSignatureInfo[v6];
    if ( !v7 || !*v7 )
      goto LABEL_8;
    if ( !wcsnicmp(String1, *v7, 0x40ui64) )
      break;
    v5 = g_dwSignatureInfoTotalCount;
LABEL_8:
    v6 = (unsigned int)(v6 + 1);
    if ( (unsigned int)v6 >= v5 )
      return 1168i64;
  }
  v11 = (_DWORD *)g_pSignatureInfo[v6];
  if ( !v11 )
    return 1168i64;
  return I_GetSignatureDetailsFromSignatureInfo(v11, v8, v9, a3, 0i64, 0i64);
}
// 18001558D: variable 'v8' is possibly undefined
// 18001558D: variable 'v9' is possibly undefined
// 180092218: using guessed type int g_dwSignatureInfoTotalCount;
// 180092220: using guessed type _QWORD g_pSignatureInfo[16];

//----- (00000001800155B4) ----------------------------------------------------
__int64 __fastcall I_GetSignatureDetailsFromSignatureInfo(
        _DWORD *a1,
        __int64 a2,
        __int64 a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6)
{
  if ( a4 )
    *a4 = a1[3];
  if ( a5 )
    *a5 = a1[4];
  if ( a6 )
    *a6 = a1[5];
  return 0i64;
}

//----- (00000001800155EC) ----------------------------------------------------
__int64 TlsInitializeDefaultAlgorithms()
{
  _QWORD *v0; // rax
  __int64 v1; // rdx
  char *v2; // rcx
  _QWORD *v3; // rax
  char *v4; // rcx
  __int64 v5; // rdx
  wchar_t ***v6; // rax
  wchar_t **v7; // rcx
  __int64 v8; // rdx
  __int16 ***v9; // rax
  __int16 **v10; // rcx
  __int64 v11; // rdx

  v0 = g_pHashInfo;
  v1 = 7i64;
  v2 = (char *)&unk_18007D340;
  do
  {
    *v0 = v2;
    v2 += 24;
    ++v0;
    --v1;
  }
  while ( v1 );
  g_dwHashInfoTotalCount = 7;
  v3 = &g_pSignatureInfo;
  v4 = (char *)&unk_18007D290;
  v5 = 7i64;
  do
  {
    *v3 = v4;
    v4 += 24;
    ++v3;
    --v5;
  }
  while ( v5 );
  g_dwSignatureInfoTotalCount = 7;
  v6 = (wchar_t ***)&g_pKeyExchangeInfo;
  v7 = &off_18007D1E0;
  v8 = 7i64;
  do
  {
    *v6 = v7;
    v7 += 3;
    ++v6;
    --v8;
  }
  while ( v8 );
  g_dwKeyExchangeInfoTotalCount = 7;
  v9 = (__int16 ***)&g_pCipherInfo;
  v10 = &off_18007D100;
  v11 = 7i64;
  do
  {
    *v9 = v10;
    v10 += 4;
    ++v9;
    --v11;
  }
  while ( v11 );
  g_dwCipherInfoTotalCount = 7;
  return 0i64;
}
// 18007D100: using guessed type __int16 *off_18007D100;
// 18007D1E0: using guessed type wchar_t *off_18007D1E0;
// 180092218: using guessed type int g_dwSignatureInfoTotalCount;
// 180092320: using guessed type int g_dwCipherInfoTotalCount;
// 180092324: using guessed type int g_dwHashInfoTotalCount;
// 180092330: using guessed type _QWORD g_pHashInfo[16];
// 1800923B0: using guessed type int g_dwKeyExchangeInfoTotalCount;

//----- (00000001800156A0) ----------------------------------------------------
__int64 __fastcall CopyUnicodeString(char a1, struct _UNICODE_STRING *a2, struct _UNICODE_STRING *a3)
{
  unsigned int v5; // edi
  unsigned __int64 v6; // rax
  WCHAR *v7; // rax
  unsigned int Length; // edx
  PWSTR Buffer; // rcx
  __int128 v11; // [rsp+30h] [rbp-18h] BYREF

  v5 = 0;
  v11 = 0i64;
  if ( a2 && a3 )
  {
    if ( a1 )
    {
      v5 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int128 *, struct _UNICODE_STRING *))(LsaTable + 80))(
             0i64,
             16i64,
             &v11,
             a2);
      if ( v5 )
        goto LABEL_25;
    }
    else
    {
      v11 = (__int128)*a2;
    }
    v6 = (unsigned __int64)v11 >> 16;
    if ( WORD1(v11)
      && (_WORD)v11
      && *((_QWORD *)&v11 + 1)
      && (v11 & 1) == 0
      && (BYTE2(v11) & 1) == 0
      && (unsigned __int16)v11 <= WORD1(v11)
      && WORD1(v11) != 0xFFFF )
    {
      a3->Length = v11;
      a3->MaximumLength = v6;
      v7 = (WCHAR *)SPExternalAlloc((unsigned __int16)v6);
      a3->Buffer = v7;
      if ( !v7 )
      {
        v5 = -2146893056;
LABEL_25:
        Buffer = a3->Buffer;
        if ( Buffer )
        {
          SPExternalFree(Buffer);
          a3->Buffer = 0i64;
        }
        *(_DWORD *)&a3->Length = 0;
        return v5;
      }
      if ( a1 )
      {
        v5 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, WCHAR *, _QWORD))(LsaTable + 80))(
               0i64,
               WORD1(v11),
               v7,
               *((_QWORD *)&v11 + 1));
        if ( v5 )
          goto LABEL_25;
      }
      else
      {
        memcpy_0(v7, *((const void **)&v11 + 1), a3->MaximumLength);
      }
      Length = a3->Length;
      if ( a3->Buffer[((unsigned __int64)a3->Length >> 1) - 1] )
        return v5;
      if ( Length > 2 )
      {
        a3->Length = Length - 2;
        return v5;
      }
    }
    v5 = -2146892963;
    goto LABEL_25;
  }
  return 2148074333i64;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180015828) ----------------------------------------------------
unsigned __int8 __fastcall CTlsSignatureSuiteList::IsSupportedSignatureSuiteList(
        CTlsSignatureSuiteList *this,
        struct CTlsSignatureSuiteList *a2)
{
  int v2; // eax
  int v3; // r8d
  unsigned __int16 v4; // cx
  unsigned __int16 v5; // dx
  unsigned __int16 v6; // cx
  unsigned __int16 v7; // dx
  unsigned __int16 v8; // cx

  v2 = 0;
  if ( a2 )
  {
    if ( *(_WORD *)a2 )
    {
      v3 = *((unsigned __int16 *)a2 + 17);
      if ( (_WORD)v3 )
      {
        v4 = *((_WORD *)this + 17);
        v5 = CTlsSignatureSuiteList::RsaSha256Flags;
        if ( (CTlsSignatureSuiteList::RsaSha256Flags & v4) == 0 )
          v5 = 0;
        v6 = v5 | v4;
        v7 = CTlsSignatureSuiteList::RsaSha384Flags;
        if ( (CTlsSignatureSuiteList::RsaSha384Flags & v6) == 0 )
          v7 = 0;
        v8 = v7 | v6;
        if ( (CTlsSignatureSuiteList::RsaSha512Flags & v8) != 0 )
          v2 = CTlsSignatureSuiteList::RsaSha512Flags;
        LOBYTE(v2) = (~(v2 | v8) & v3) == 0;
      }
    }
  }
  return v2;
}
// 180092800: using guessed type unsigned __int16 CTlsSignatureSuiteList::RsaSha512Flags;
// 180092804: using guessed type unsigned __int16 CTlsSignatureSuiteList::RsaSha384Flags;
// 180092808: using guessed type unsigned __int16 CTlsSignatureSuiteList::RsaSha256Flags;

//----- (000000018001588C) ----------------------------------------------------
__int64 __fastcall IsCertKeyUsageCompliant(int a1, int a2, const struct _CERT_CONTEXT *a3)
{
  unsigned int v3; // ebx
  int v4; // edi
  struct _CERT_INFO *pCertInfo; // rdx
  int pbKeyUsage; // [rsp+50h] [rbp+18h] BYREF

  v3 = 0;
  if ( !a3 )
    return 0i64;
  if ( a2 != 9216 )
    return 1i64;
  if ( a1 == 44550 )
    goto LABEL_4;
  if ( a1 != 41984 )
  {
    if ( a1 != 43522 )
      return 1i64;
LABEL_4:
    v4 = 128;
    goto LABEL_5;
  }
  v4 = 32;
LABEL_5:
  pCertInfo = a3->pCertInfo;
  pbKeyUsage = 0;
  if ( !CertGetIntendedKeyUsage(0x10001u, pCertInfo, (BYTE *)&pbKeyUsage, 4u) )
    return 1i64;
  LOBYTE(v3) = (pbKeyUsage & v4) != 0;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x14u,
      (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
      pbKeyUsage,
      v4);
  return v3;
}

//----- (0000000180015930) ----------------------------------------------------
void __fastcall CSessionCacheClientItem::CompleteCacheAdd(
        CSessionCacheClientItem *this,
        struct CSessionCacheManager *a2,
        struct CSslContext *a3,
        char a4)
{
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rax

  v6 = *((_QWORD *)this + 48);
  *(_QWORD *)((char *)this + 188) = *(_QWORD *)(*((_QWORD *)a3 + 10) + 760i64);
  if ( v6 )
  {
    *(_BYTE *)(v6 + 236) = 0;
    CSessionCacheTable::DereferenceCacheItemInternal(
      *(CSessionCacheTable **)(*((_QWORD *)this + 48) + 224i64),
      *((struct CSessionCacheItem **)this + 48),
      1,
      a4);
    *((_QWORD *)this + 48) = 0i64;
  }
  v7 = *((_QWORD *)a3 + 1);
  *((_QWORD *)this + 22) = v7;
  *((_DWORD *)this + 46) = *((_DWORD *)a3 + 4);
  v8 = *(_QWORD *)(v7 + 848);
  if ( v8 )
    _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v8 + 16) + 12i64));
  _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v7 + 856) + 12i64));
}

//----- (00000001800159D0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::GetPeerCertValidationResults(
        CSsl3TlsClientContext *this,
        int *a2,
        unsigned int *a3)
{
  __int64 v3; // rcx

  if ( !a2 || !a3 )
    return 87i64;
  v3 = *((_QWORD *)this + 11);
  *a2 = *(_DWORD *)(v3 + 216);
  *a3 = *(_DWORD *)(v3 + 220);
  return 0i64;
}

//----- (0000000180015A10) ----------------------------------------------------
__int64 __fastcall SpInstanceInit(__int64 a1, __int64 a2)
{
  unsigned int v3; // ebx
  unsigned int *v4; // rdi
  __int64 result; // rax

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
  v3 = 0;
  v4 = (unsigned int *)&g_SchannelCallbacks;
  do
  {
    result = (*(__int64 (__fastcall **)(_QWORD, _QWORD))(a2 + 16))(*v4, *((_QWORD *)v4 + 1));
    if ( (_DWORD)result )
      break;
    ++v3;
    v4 += 4;
  }
  while ( v3 < 0xA );
  return result;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180015A90) ----------------------------------------------------
__int64 __fastcall SpMarshallSupplementalCreds(__int64 a1, unsigned __int8 *a2, unsigned int *a3, char **a4)
{
  if ( a2 && *(_DWORD *)a2 >= 3u )
  {
    if ( *(_DWORD *)a2 <= 4u )
      return SpMarshallSupplementalCredsV4(a1, a2, a3, a4);
    if ( *(_DWORD *)a2 == 5 )
      return SpMarshallSupplementalCredsV5(a1, a2, a3, (void **)a4);
  }
  return 3221225485i64;
}

//----- (0000000180015AD0) ----------------------------------------------------
__int64 __fastcall SpMarshallSupplementalCredsV5(__int64 a1, unsigned __int8 *a2, unsigned int *a3, void **a4)
{
  void **v4; // rax
  unsigned __int8 *v5; // rsi
  unsigned int v6; // edi
  CCipherMill *v7; // rcx
  SIZE_T v8; // r14
  __int64 v9; // rbp
  __int64 v10; // r15
  unsigned int v11; // r12d
  __int64 v12; // r8
  __int64 v13; // r11
  __int64 v14; // r13
  unsigned int v15; // ebx
  __int64 v16; // rcx
  unsigned __int16 v17; // dx
  __int64 v18; // r10
  _OWORD *v19; // rax
  _QWORD *v20; // rbp
  char *v21; // rbx
  __int64 v22; // rcx
  char *v23; // r15
  unsigned int v24; // r14d
  __int64 v25; // r13
  __int64 v26; // rbx
  __int64 v27; // r12
  __int64 v28; // rcx
  unsigned int v29; // esi
  __int64 v30; // rbp
  __int64 v31; // rbx
  __int64 v32; // r14
  __int64 v34; // r9
  unsigned int v35; // r11d
  __int64 v36; // rcx
  __int64 v37; // r8
  unsigned int v38; // r9d
  __int64 v39; // rcx
  unsigned int v40; // esi
  __int64 v41; // r14
  __int64 v42; // rbx
  unsigned int v43; // r14d
  __int64 v44; // rbp
  __int64 v45; // rbx
  int v46; // [rsp+28h] [rbp-80h]
  __int64 v47; // [rsp+30h] [rbp-78h]
  __int64 v48; // [rsp+38h] [rbp-70h]
  __int64 v49; // [rsp+40h] [rbp-68h]
  __int64 v50; // [rsp+48h] [rbp-60h]
  _OWORD *v51; // [rsp+50h] [rbp-58h]
  int v52; // [rsp+B0h] [rbp+8h]
  unsigned int *v54; // [rsp+C0h] [rbp+18h]

  v54 = a3;
  v4 = a4;
  v5 = a2;
  v6 = 0;
  v7 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 30i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
    v7 = WPP_GLOBAL_Control;
    v4 = a4;
    a3 = v54;
  }
  if ( v5 && v4 && a3 )
  {
    v8 = 72i64;
    v46 = 72;
    if ( *((_DWORD *)v5 + 2) )
    {
      v8 = 8i64 * *((unsigned int *)v5 + 2) + 72;
      v46 = 8 * *((_DWORD *)v5 + 2) + 72;
    }
    if ( *((_DWORD *)v5 + 8) )
    {
      v8 += 8i64 * *((unsigned int *)v5 + 8);
      v46 = v8;
    }
    v9 = *((unsigned int *)v5 + 14);
    if ( !(_DWORD)v9 )
    {
LABEL_28:
      v19 = LocalAlloc(0x40u, v8);
      v51 = v19;
      v20 = v19;
      if ( v19 )
      {
        v21 = (char *)v19 + 72;
        *v19 = *(_OWORD *)v5;
        v19[1] = *((_OWORD *)v5 + 1);
        v19[2] = *((_OWORD *)v5 + 2);
        v19[3] = *((_OWORD *)v5 + 3);
        *((_QWORD *)v19 + 8) = *((_QWORD *)v5 + 8);
        if ( *((_DWORD *)v5 + 2) )
        {
          memcpy_0((char *)v19 + 72, *((const void **)v5 + 2), 8i64 * *((unsigned int *)v5 + 2));
          v20[2] = v21;
          *((_DWORD *)v20 + 2) = *((_DWORD *)v5 + 2);
          v21 += 8 * *((unsigned int *)v5 + 2);
        }
        if ( *((_DWORD *)v5 + 8) )
        {
          memcpy_0(v21, *((const void **)v5 + 5), 8i64 * *((unsigned int *)v5 + 8));
          v20[5] = v21;
          *((_DWORD *)v20 + 8) = *((_DWORD *)v5 + 8);
          v21 += 8 * *((unsigned int *)v5 + 8);
        }
        if ( *((_DWORD *)v5 + 14) )
        {
          memcpy_0(v21, *((const void **)v5 + 8), 40i64 * *((unsigned int *)v5 + 14));
          v20[8] = v21;
          v22 = *((unsigned int *)v5 + 14);
          v52 = 0;
          v23 = &v21[40 * v22];
          if ( (_DWORD)v22 )
          {
            v24 = 0;
            do
            {
              v25 = *((_QWORD *)v5 + 8);
              v26 = v20[8];
              v50 = v25;
              v47 = v26;
              v27 = 5i64 * v24;
              if ( *(_DWORD *)(v25 + 40i64 * v24) )
              {
                memcpy_0(v23, *(const void **)(v25 + 40i64 * v24 + 8), 16i64 * *(unsigned int *)(v25 + 40i64 * v24));
                *(_QWORD *)(v26 + 40i64 * v24 + 8) = v23;
                v23 += 16 * *(unsigned int *)(v25 + 40i64 * v24);
                if ( *(_DWORD *)(v25 + 40i64 * v24) )
                {
                  v40 = 0;
                  v41 = v26;
                  do
                  {
                    v42 = 2i64 * v40;
                    memcpy_0(
                      v23,
                      *(const void **)(*(_QWORD *)(v25 + 8 * v27 + 8) + 16i64 * v40 + 8),
                      *(unsigned __int16 *)(*(_QWORD *)(v25 + 8 * v27 + 8) + 16i64 * v40 + 2));
                    ++v40;
                    *(_QWORD *)(*(_QWORD *)(v41 + 8 * v27 + 8) + 8 * v42 + 8) = v23;
                    v23 += *(unsigned __int16 *)(*(_QWORD *)(v25 + 8 * v27 + 8) + 8 * v42 + 2);
                  }
                  while ( v40 < *(_DWORD *)(v25 + 8 * v27) );
                  v5 = a2;
                  v24 = v52;
                  v26 = v47;
                }
              }
              if ( *(_DWORD *)(v25 + 8 * v27 + 20) )
              {
                memcpy_0(v23, *(const void **)(v25 + 8 * v27 + 24), 48i64 * *(unsigned int *)(v25 + 8 * v27 + 20));
                *(_QWORD *)(v26 + 8 * v27 + 24) = v23;
                v28 = *(unsigned int *)(v25 + 8 * v27 + 20);
                v23 += 48 * v28;
                if ( (_DWORD)v28 )
                {
                  v29 = 0;
                  do
                  {
                    v30 = *(_QWORD *)(v25 + 8 * v27 + 24);
                    v48 = v30;
                    v31 = 48i64 * v29;
                    v32 = *(_QWORD *)(v47 + 8 * v27 + 24);
                    v49 = v32;
                    memcpy_0(v23, *(const void **)(v31 + v30 + 16), *(unsigned __int16 *)(v31 + v30 + 10));
                    *(_QWORD *)(v31 + v32 + 16) = v23;
                    v23 += *(unsigned __int16 *)(v31 + v30 + 10);
                    if ( *(_DWORD *)(v31 + v30 + 24) )
                    {
                      memcpy_0(v23, *(const void **)(v31 + v30 + 32), 16i64 * *(unsigned int *)(v31 + v30 + 24));
                      *(_QWORD *)(v31 + v32 + 32) = v23;
                      v43 = 0;
                      v23 += 16 * *(unsigned int *)(v31 + v30 + 24);
                      if ( *(_DWORD *)(v31 + v30 + 24) )
                      {
                        v44 = 48i64 * v29;
                        do
                        {
                          v45 = 2i64 * v43;
                          memcpy_0(
                            v23,
                            *(const void **)(*(_QWORD *)(v48 + v44 + 32) + 16i64 * v43 + 8),
                            *(unsigned __int16 *)(*(_QWORD *)(v48 + v44 + 32) + 16i64 * v43 + 2));
                          ++v43;
                          *(_QWORD *)(*(_QWORD *)(v49 + v44 + 32) + 8 * v45 + 8) = v23;
                          v23 += *(unsigned __int16 *)(*(_QWORD *)(v48 + v44 + 32) + 8 * v45 + 2);
                        }
                        while ( v43 < *(_DWORD *)(v48 + v44 + 24) );
                        v25 = v50;
                        v6 = 0;
                      }
                    }
                    ++v29;
                  }
                  while ( v29 < *(_DWORD *)(v25 + 8 * v27 + 20) );
                  v5 = a2;
                  v20 = v51;
                  v24 = v52;
                }
              }
              v52 = ++v24;
            }
            while ( v24 < *((_DWORD *)v5 + 14) );
            LODWORD(v8) = v46;
          }
        }
        *((_DWORD *)v20 + 12) = *((_DWORD *)v5 + 12);
        *((_DWORD *)v20 + 13) = *((_DWORD *)v5 + 13);
        *((_DWORD *)v20 + 1) = *((_DWORD *)v5 + 1);
        *v54 = v8;
        *a4 = v20;
      }
      else
      {
        v6 = -1073741801;
      }
      v7 = WPP_GLOBAL_Control;
      goto LABEL_47;
    }
    if ( (unsigned int)v9 > 0x10 )
      return 3221225485i64;
    v10 = *((_QWORD *)v5 + 8);
    if ( v10 )
    {
      v11 = 0;
      v8 += 40 * v9;
      v46 = v8;
      while ( 1 )
      {
        v12 = *(unsigned int *)(v10 + 40i64 * v11);
        if ( (_DWORD)v12 )
          break;
LABEL_16:
        v13 = *(unsigned int *)(v10 + 40i64 * v11 + 20);
        if ( (_DWORD)v13 )
        {
          if ( (unsigned int)v13 <= 0x10 )
          {
            v14 = *(_QWORD *)(v10 + 40i64 * v11 + 24);
            if ( v14 )
            {
              v15 = 0;
              v8 += 48 * v13;
              while ( 1 )
              {
                v16 = v14 + 48i64 * v15;
                if ( !*(_WORD *)(v16 + 10) )
                  break;
                v17 = *(_WORD *)(v16 + 10);
                if ( ((*(_WORD *)(v16 + 8) | v17) & 1) != 0
                  || *(_WORD *)(v16 + 8) > v17
                  || v17 == 0xFFFF
                  || !*(_QWORD *)(v16 + 16) && (*(_WORD *)(v16 + 8) || v17) )
                {
                  break;
                }
                v18 = *(unsigned int *)(v16 + 24);
                v8 += *(unsigned __int16 *)(v16 + 10);
                v46 = v8;
                if ( (_DWORD)v18 )
                {
                  if ( (unsigned int)v18 <= 0x10 )
                  {
                    v37 = *(_QWORD *)(v16 + 32);
                    if ( v37 )
                    {
                      v38 = 0;
                      v8 += 16 * v18;
                      while ( 1 )
                      {
                        v39 = *(unsigned __int16 *)(v37 + 16i64 * v38 + 2);
                        if ( !(_WORD)v39
                          || (((unsigned __int16)v39 | *(_WORD *)(v37 + 16i64 * v38)) & 1) != 0
                          || *(_WORD *)(v37 + 16i64 * v38) > (unsigned __int16)v39
                          || (_WORD)v39 == 0xFFFF
                          || !*(_QWORD *)(v37 + 16i64 * v38 + 8) )
                        {
                          break;
                        }
                        v8 += v39;
                        ++v38;
                        v46 = v8;
                        if ( v38 >= (unsigned int)v18 )
                          goto LABEL_26;
                      }
                    }
                  }
                  return 3221225485i64;
                }
LABEL_26:
                if ( ++v15 >= (unsigned int)v13 )
                  goto LABEL_27;
              }
            }
          }
          return 3221225485i64;
        }
LABEL_27:
        if ( ++v11 >= (unsigned int)v9 )
          goto LABEL_28;
      }
      if ( (unsigned int)v12 <= 0x10 )
      {
        v34 = *(_QWORD *)(v10 + 40i64 * v11 + 8);
        if ( v34 )
        {
          v35 = 0;
          v8 += 16 * v12;
          while ( 1 )
          {
            v36 = *(unsigned __int16 *)(v34 + 16i64 * v35 + 2);
            if ( !(_WORD)v36
              || (((unsigned __int16)v36 | *(_WORD *)(v34 + 16i64 * v35)) & 1) != 0
              || *(_WORD *)(v34 + 16i64 * v35) > (unsigned __int16)v36
              || (_WORD)v36 == 0xFFFF
              || !*(_QWORD *)(v34 + 16i64 * v35 + 8) )
            {
              break;
            }
            v8 += v36;
            ++v35;
            v46 = v8;
            if ( v35 >= (unsigned int)v12 )
              goto LABEL_16;
          }
        }
      }
      return 3221225485i64;
    }
  }
  v6 = -1073741811;
LABEL_47:
  if ( v7 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v7 + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)v7 + 2), 31i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids, v6);
  return v6;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180015E38) ----------------------------------------------------
__int64 __fastcall CTlsExt::BuildTBExtension(
        CTlsExt *this,
        char a2,
        char a3,
        unsigned __int8 *const a4,
        unsigned __int8 a5,
        unsigned __int8 *const a6,
        unsigned __int8 **a7)
{
  __int64 v8; // rdi
  unsigned __int16 v9; // dx
  char *v10; // rdi

  if ( !a4 )
    return 87i64;
  if ( !a5 )
    return 87i64;
  if ( !a7 )
    return 87i64;
  v8 = (__int64)*a7;
  if ( !*a7 )
    return 87i64;
  v9 = a5 + 3;
  if ( (unsigned __int64)v9 + v8 + 4 > (unsigned __int64)a6 )
    return 87i64;
  *(_WORD *)v8 = 6144;
  *(_BYTE *)(v8 + 3) = v9;
  *(_BYTE *)(v8 + 5) = a3;
  *(_BYTE *)(v8 + 2) = HIBYTE(v9);
  *(_BYTE *)(v8 + 4) = a2;
  *(_BYTE *)(v8 + 6) = a5;
  v10 = (char *)(v8 + 7);
  memcpy_0(v10, a4, a5);
  *a7 = (unsigned __int8 *)&v10[a5];
  return 0i64;
}

//----- (0000000180015EE0) ----------------------------------------------------
__int64 __fastcall SpSetContextAttributes(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4)
{
  CCipherMill *v8; // rcx
  _QWORD *v9; // rdi
  __int64 v10; // rbx
  unsigned int v11; // eax

  v8 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 25i64, &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids);
      v8 = WPP_GLOBAL_Control;
    }
    if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v8 + 28) & 4) != 0 )
      {
        WPP_SF_q(*((_QWORD *)v8 + 2), 0x1Au, (__int64)&WPP_dd5b111c8476393ce65badbe3d423765_Traceguids, a1);
        v8 = WPP_GLOBAL_Control;
      }
      if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
      {
        WPP_SF_d(*((_QWORD *)v8 + 2), 0x1Bu, (__int64)&WPP_dd5b111c8476393ce65badbe3d423765_Traceguids, a2);
        v8 = WPP_GLOBAL_Control;
      }
    }
  }
  v9 = *(_QWORD **)(a1 + 8);
  v10 = v9[10];
  if ( v10 && v8 != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)v8 + 28) & 4) != 0 )
    {
      WPP_SF_D(
        *((_QWORD *)v8 + 2),
        28i64,
        &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids,
        *(unsigned int *)(v10 + 212));
      v8 = WPP_GLOBAL_Control;
    }
    if ( v8 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v8 + 28) & 4) != 0 )
      WPP_SF_S(
        *((_QWORD *)v8 + 2),
        0x1Du,
        (__int64)&WPP_dd5b111c8476393ce65badbe3d423765_Traceguids,
        (const wchar_t *)(v10 + 216));
  }
  v11 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD, __int64, _QWORD))(*v9 + 208i64))(v9, a2, a3, a4);
  return TranslateToSecurityStatus(v11);
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180015FC8) ----------------------------------------------------
char GetExternalSchannelAlgorithms()
{
  BOOL v0; // ebx
  char result; // al
  int v2; // [rsp+30h] [rbp+8h] BYREF
  HANDLE KeyHandle; // [rsp+38h] [rbp+10h] BYREF

  v0 = 0;
  KeyHandle = 0i64;
  v2 = 0;
  if ( TlsOpenRegKey(
         L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Cryptography\\Providers\\Microsoft SSL Protocol Provider",
         0i64,
         &KeyHandle) >= 0
    && GetSslDWordFromRegistry(KeyHandle, L"EnableTlsExternalAlgorithms", &v2) >= 0 )
  {
    v0 = v2 == 1;
  }
  result = TlsCloseRegKey(&KeyHandle);
  dword_1800921B0 = v0;
  if ( v0 )
  {
    GetExternalHashAlgorithms();
    GetExternalSignatureAlgorithms();
    GetExternalKeyExchangeAlgorithms();
    return GetExternalCipherAlgorithms();
  }
  return result;
}
// 180082408: using guessed type wchar_t aEnabletlsexter[28];
// 1800921B0: using guessed type int dword_1800921B0;

//----- (0000000180016034) ----------------------------------------------------
NTSTATUS __fastcall TlsCloseRegKey(void **a1)
{
  void *v2; // rcx
  NTSTATUS result; // eax

  v2 = *a1;
  if ( v2 )
  {
    result = NtClose(v2);
    *a1 = 0i64;
  }
  return result;
}

//----- (0000000180016064) ----------------------------------------------------
NTSTATUS __fastcall GetSslDWordFromRegistry(HANDLE KeyHandle, const WCHAR *a2, _DWORD *a3)
{
  NTSTATUS result; // eax
  ULONG ResultLength; // [rsp+30h] [rbp-48h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+38h] [rbp-40h] BYREF
  __int128 KeyValueInformation; // [rsp+48h] [rbp-30h] BYREF
  int v9; // [rsp+58h] [rbp-20h]

  ResultLength = 0;
  DestinationString = 0i64;
  v9 = 0;
  KeyValueInformation = 0i64;
  RtlInitUnicodeString(&DestinationString, a2);
  result = NtQueryValueKey(
             KeyHandle,
             &DestinationString,
             KeyValuePartialInformation,
             &KeyValueInformation,
             0x14u,
             &ResultLength);
  if ( result >= 0 )
  {
    if ( DWORD1(KeyValueInformation) == 4 )
      *a3 = HIDWORD(KeyValueInformation);
    else
      return -1073739509;
  }
  return result;
}

//----- (000000018001610C) ----------------------------------------------------
NTSTATUS __fastcall TlsOpenRegKey(PCWSTR Source, PCWSTR a2, PHANDLE KeyHandle)
{
  struct _UNICODE_STRING *v6; // rbx
  NTSTATUS result; // eax
  __int64 v8; // rax
  __int64 v9; // rcx
  struct _UNICODE_STRING *Heap; // rax
  struct _UNICODE_STRING *P; // [rsp+20h] [rbp-68h]
  struct _UNICODE_STRING v12; // [rsp+28h] [rbp-60h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+38h] [rbp-50h] BYREF
  unsigned int v14; // [rsp+A8h] [rbp+20h]
  NTSTATUS v15; // [rsp+A8h] [rbp+20h]

  v12 = 0i64;
  v6 = 0i64;
  P = 0i64;
  memset(&ObjectAttributes, 0, sizeof(ObjectAttributes));
  if ( !a2 )
  {
    RtlInitUnicodeString(&v12, Source);
    ObjectAttributes.Length = 48;
    ObjectAttributes.RootDirectory = 0i64;
    ObjectAttributes.Attributes = 576;
    ObjectAttributes.ObjectName = &v12;
LABEL_3:
    *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0i64;
    result = NtOpenKey(KeyHandle, 0x20019u, &ObjectAttributes);
    goto LABEL_10;
  }
  v8 = -1i64;
  v9 = -1i64;
  do
    ++v9;
  while ( Source[v9] );
  do
    ++v8;
  while ( a2[v8] );
  v14 = 2 * (v8 + v9) + 4;
  Heap = (struct _UNICODE_STRING *)RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, 0, v14 + 16i64);
  v6 = Heap;
  P = Heap;
  if ( Heap )
  {
    Heap->Length = 0;
    Heap->MaximumLength = v14;
    Heap->Buffer = &Heap[1].Length;
    RtlAppendUnicodeToString(Heap, Source);
    RtlAppendUnicodeToString(v6, L"\\");
    RtlAppendUnicodeToString(v6, a2);
    ObjectAttributes.Length = 48;
    ObjectAttributes.RootDirectory = 0i64;
    ObjectAttributes.Attributes = 576;
    ObjectAttributes.ObjectName = v6;
    goto LABEL_3;
  }
  result = -1073741801;
LABEL_10:
  v15 = result;
  if ( v6 )
  {
    RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, P);
    return v15;
  }
  return result;
}

//----- (00000001800162B0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::Initialize(CSsl3TlsClientContext *this)
{
  __int64 v2; // rax
  __int64 v3; // r8
  _QWORD *v5; // rax
  _QWORD *v6; // rdx
  _QWORD *v7; // rcx
  _QWORD *v8; // rax
  _QWORD *v9; // rax
  DTlsMsgMgr *v10; // rcx

  if ( !*((_BYTE *)this + 233) )
    goto LABEL_2;
  v5 = operator new(0x60ui64);
  v6 = v5;
  if ( v5 )
  {
    *v5 = 0i64;
    v5[4] = v5 + 3;
    v5[3] = v5 + 3;
    v5[6] = v5 + 5;
    v5[5] = v5 + 5;
    v7 = v5 + 7;
    *((_DWORD *)v5 + 2) = 10;
    v8 = v5 + 9;
    v7[1] = v7;
    *v7 = v7;
    v6[11] = this;
    v8[1] = v8;
    *v8 = v8;
  }
  else
  {
    v6 = 0i64;
  }
  *((_QWORD *)this + 72) = v6;
  if ( !v6 )
    return 14i64;
  v9 = operator new(0x30ui64);
  if ( v9 )
  {
    *v9 = *((_QWORD *)this + 72);
    v9[1] = 0i64;
    v9[2] = 0i64;
    v9[3] = 0i64;
    *((_DWORD *)v9 + 8) = 0;
    v9[5] = this;
    *((_DWORD *)v9 + 9) = *((__int16 *)this + 96);
  }
  else
  {
    v9 = 0i64;
  }
  v10 = (DTlsMsgMgr *)*((_QWORD *)this + 72);
  *((_QWORD *)this + 73) = v9;
  if ( !v9 )
  {
    if ( v10 )
      DTlsMsgMgr::`scalar deleting destructor'(v10);
    return 14i64;
  }
  *((_QWORD *)this + 28) = v10;
LABEL_2:
  v2 = *((_QWORD *)this + 15);
  v3 = *((_QWORD *)this + 166);
  if ( v2 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
  {
    *(_WORD *)(v2 + 152) = 0;
    if ( v3 )
      o_wcsncpy_s_0(v2 + 152, 256i64, v3, -1i64);
  }
  return 0i64;
}
// 180028D84: using guessed type __int64 __fastcall o_wcsncpy_s_0(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180016320) ----------------------------------------------------
bool __fastcall CSessionCacheClientItem::IsEntryAMatch(
        CSessionCacheClientItem *this,
        struct _LUID *a2,
        char *a3,
        struct CRED_THUMBPRINT *a4,
        unsigned int a5)
{
  struct _LUID *v5; // r11
  CSessionCacheClientItem *v6; // r10

  v5 = a2;
  v6 = this;
  return (*((_DWORD *)this + 42) & a5) != 0
      && *(_DWORD *)a4 == *((_DWORD *)this + 47)
      && *((_DWORD *)a4 + 1) == *((_DWORD *)this + 48)
      && (!a3 || CSessionCacheClientItem::IsSameTargetName(this, a3))
      && (!v5 || *((_DWORD *)v6 + 94) == v5->LowPart && *((_DWORD *)v6 + 95) == v5->HighPart);
}
// 180016361: variable 'v5' is possibly undefined
// 180016366: variable 'v6' is possibly undefined

//----- (0000000180016390) ----------------------------------------------------
bool __fastcall CSessionCacheClientItem::IsSameTargetName(CSessionCacheClientItem *this, char *a2)
{
  const unsigned __int16 *v2; // rax
  char *v3; // rdx
  int v4; // r8d
  int v5; // ecx

  v2 = (const unsigned __int16 *)*((_QWORD *)this + 46);
  if ( v2 == (const unsigned __int16 *)a2 )
    return 1;
  if ( !v2 || !a2 )
    return 0;
  v3 = (char *)(a2 - (char *)v2);
  do
  {
    v4 = *(unsigned __int16 *)&v3[(_QWORD)v2];
    v5 = *v2 - v4;
    if ( v5 )
      break;
    ++v2;
  }
  while ( v4 );
  return !v5;
}

//----- (00000001800163E0) ----------------------------------------------------
__int64 __fastcall DownloadCertContextCallback(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v6; // ebp
  CCipherMill *v8; // rcx
  unsigned __int16 v9; // dx
  int v10; // [rsp+20h] [rbp-28h]
  struct _CERT_CONTEXT *ppvContext; // [rsp+30h] [rbp-18h] BYREF

  if ( !(unsigned int)SchannelInit(1) )
  {
    v8 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
      return 2148074244i64;
    v9 = 50;
    goto LABEL_22;
  }
  if ( !a3 || !a4 )
  {
    v8 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 5) == 0 )
      return 2148074244i64;
    v9 = 51;
LABEL_22:
    v10 = -2146893052;
    WPP_SF_DD(*((_QWORD *)v8 + 2), v9, (__int64)&WPP_e7a188b1921532aa285b79366435dd9d_Traceguids, -2146893052, v10);
    return 2148074244i64;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 52i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
  v6 = DeserializeCertContext((const struct _CERT_CONTEXT **)&ppvContext, *(unsigned __int8 **)(a3 + 8), *(_DWORD *)a3);
  *(_DWORD *)a4 = *(_DWORD *)a3;
  SPExternalFree(*(void **)(a3 + 8));
  *(_QWORD *)(a3 + 8) = 0i64;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  if ( v6 < 0 )
  {
    *(_DWORD *)(a4 + 4) = 0;
    *(_DWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0i64;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        53i64,
        &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids,
        (unsigned int)v6);
    return (unsigned int)v6;
  }
  else
  {
    **(_QWORD **)(a4 + 8) = ppvContext;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 54i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
    return 0i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800164B0) ----------------------------------------------------
__int64 __fastcall DeserializeCertContext(
        const struct _CERT_CONTEXT **ppvContext,
        unsigned __int8 *a2,
        unsigned int a3)
{
  unsigned __int64 v3; // rbx
  __int64 v6; // r8
  unsigned int v7; // edi
  HCERTSTORE v8; // rbp
  unsigned int v9; // ebx
  __int64 v10; // r8
  int v12; // [rsp+40h] [rbp-18h] BYREF
  unsigned __int8 *v13; // [rsp+48h] [rbp-10h]

  v3 = a3;
  if ( a3 >= 4 )
  {
    v6 = *(unsigned int *)a2;
    v12 = v6;
    v13 = a2 + 4;
    if ( (unsigned int)v6 < 0xFFFFFFFA && v3 >= v6 + 4 )
    {
      v7 = 0;
      v8 = CertOpenStore((LPCSTR)6, 1u, 0i64, 4u, &v12);
      if ( v8 )
      {
        v9 = -4 - v12 + v3;
        if ( v9 >= 4 )
        {
          v10 = *(unsigned int *)&a2[v12 + 4];
          if ( (unsigned int)v10 < 0xFFFFFFFA && v9 >= (unsigned __int64)(v10 + 4) )
          {
            if ( CertAddSerializedElementToStore(v8, &a2[v12 + 8], v10, 2u, 0, 2u, 0i64, (const void **)ppvContext) )
            {
LABEL_9:
              CertCloseStore(v8, 0);
              return v7;
            }
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 46i64, &WPP_66cada2652f531372f2ad4492a08a619_Traceguids);
            }
          }
        }
        v7 = -2146893043;
        goto LABEL_9;
      }
    }
  }
  return 2148074253i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (00000001800165E0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::PreparseMessage(CSsl3TlsClientContext *this, struct SPBuffer *a2)
{
  HLOCAL v5; // rax

  if ( *((_DWORD *)this + 17) != 49 )
    return 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 40i64, &WPP_2dcc559eea6f3c37d295569df36f7bc3_Traceguids);
  if ( *((_QWORD *)a2 + 1) && *(_DWORD *)a2 )
  {
    v5 = SPExternalAlloc(*(_DWORD *)a2);
    *((_QWORD *)this + 117) = v5;
    if ( v5 )
    {
      memcpy_0(v5, *((const void **)a2 + 1), *(unsigned int *)a2);
      *((_DWORD *)this + 236) = *(_DWORD *)a2;
      *((_DWORD *)this + 17) = 91;
      return 0i64;
    }
    return 14i64;
  }
  else
  {
    CSslContext::SetError((__int64)this, 500, -2146893048);
    return 2148074248i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180016610) ----------------------------------------------------
__int64 __fastcall GetAppUserKeysCallback(__int64 a1, char a2, __int64 a3, struct _SecBuffer *a4)
{
  union _LARGE_INTEGER *v8; // rcx
  struct CSslUserContext *UserContext; // rax
  unsigned int UserKeysCallback; // ebx

  if ( !(unsigned int)SchannelInit(1) || !a3 || !a4 )
    return 2148074244i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 55i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
  v8 = *(union _LARGE_INTEGER **)(a3 + 8);
  if ( v8 && *(_DWORD *)a3 == 8 )
    UserContext = SslFindUserContextEx(v8);
  else
    UserContext = SslFindUserContext(a1);
  if ( UserContext )
  {
    UserKeysCallback = GetUserKeysCallback(
                         UserContext,
                         (void *(__stdcall *)(unsigned int))PvExtVirtualAlloc,
                         (void (__stdcall *)(void *))FreeExtVirtualAlloc,
                         a2,
                         a4);
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 57i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
    return UserKeysCallback;
  }
  else
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 56i64, &WPP_e7a188b1921532aa285b79366435dd9d_Traceguids);
    return 2148074241i64;
  }
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (00000001800166F0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetContextAttributesA(CSsl3TlsContext *this, int a2, void *a3, unsigned int a4)
{
  switch ( a2 )
  {
    case '"':
      return CSsl3TlsContext::SetSupportedMTU(this, a3, a4);
    case 'e':
      return CSsl3TlsContext::SetEapPrfType(this, a3, a4);
    case 'i':
      return CSsl3TlsContext::SetFalseStart(this, a3, a4);
    case 'j':
      return CSsl3TlsContext::SetKeyingMaterialInfo(this, a3, a4);
  }
  return CSslContext::SetContextAttributesA(this, a2, a3, a4);
}

//----- (0000000180016724) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::SetFalseStart(CSsl3TlsContext *this, void *a2, int a3)
{
  unsigned int v3; // ebx
  int v6; // [rsp+50h] [rbp+18h] BYREF

  v3 = 0;
  v6 = 0;
  if ( a3 == 4
    && ((*(void (__fastcall **)(_QWORD, __int64, int *, void *))(LsaTable + 80))(0i64, 4i64, &v6, a2), v6 == 1) )
  {
    *((_BYTE *)this + 556) = 1;
  }
  else
  {
    return 87;
  }
  return v3;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180016790) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::SetClientEphemeralKey(CSsl3TlsClientContext *this, __int64 a2)
{
  __int64 v4; // rcx

  v4 = *((_QWORD *)this + 128);
  if ( v4 )
    SslFreeObject(v4, 0i64);
  *((_QWORD *)this + 128) = a2;
  return 0i64;
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (00000001800167E0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsClientContext::SetServerPublicKey(CSsl3TlsClientContext *this, __int64 a2)
{
  __int64 v4; // rcx

  v4 = *((_QWORD *)this + 127);
  if ( v4 )
    SslFreeObject(v4, 0i64);
  *((_QWORD *)this + 127) = a2;
  return 0i64;
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180016828) ----------------------------------------------------
void __fastcall CSslCredential::ReleaseEphemeralKeyData(CSslCredential *this, struct CEphemKeyData *a2)
{
  if ( a2 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)a2 + 7, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(struct CEphemKeyData *, __int64))(*(_QWORD *)a2 + 8i64))(a2, 1i64);
  }
}

//----- (000000018001686C) ----------------------------------------------------
char __fastcall IsRsaAlgorithmBlacklisted(
        unsigned __int64 a1,
        unsigned int a2,
        int a3,
        unsigned int a4,
        const UNICODE_STRING *String2,
        char a6)
{
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // r15
  char v10; // si
  unsigned int v12; // edi
  unsigned __int64 v13; // rdi
  unsigned __int64 i; // rcx
  int v15; // [rsp+20h] [rbp-28h]
  int v16; // [rsp+20h] [rbp-28h]
  int v17; // [rsp+28h] [rbp-20h]

  v8 = a1;
  if ( !a2 || !a1 )
    return 0;
  v9 = a1 + 40i64 * a2;
  if ( a1 < v9 )
  {
    v10 = 1;
    while ( 1 )
    {
      if ( *(_DWORD *)(v8 + 20) )
      {
        if ( !*(_DWORD *)v8 )
          goto LABEL_13;
        if ( String2 )
          break;
      }
LABEL_8:
      v8 += 40i64;
      if ( v8 >= v9 )
        return 0;
    }
    v12 = 0;
    while ( RtlCompareUnicodeString((PCUNICODE_STRING)(*(_QWORD *)(v8 + 8) + 16i64 * v12), String2, 1u) )
    {
      if ( ++v12 >= *(_DWORD *)v8 )
        goto LABEL_8;
    }
LABEL_13:
    if ( a6 && (*(_BYTE *)(v8 + 32) & 1) != 0 )
      goto LABEL_8;
    v13 = *(_QWORD *)(v8 + 24);
    for ( i = v13 + 48i64 * *(unsigned int *)(v8 + 20); ; i = *(_QWORD *)(v8 + 24) + 48i64 * *(unsigned int *)(v8 + 20) )
    {
      if ( v13 >= i )
        goto LABEL_8;
      if ( *(_DWORD *)v13 == a3 && *(_WORD *)(v13 + 8) == 6 && !wcsncmp(*(const wchar_t **)(v13 + 16), L"RSA", 3ui64) )
      {
        if ( !*(_DWORD *)(v13 + 24) && !*(_DWORD *)(v13 + 40) && !*(_DWORD *)(v13 + 44) )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            v16 = a3;
            WPP_SF_Sd(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xCu,
              (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
              L"RSA",
              v16);
          }
          return v10;
        }
        if ( a4 )
        {
          if ( *(_DWORD *)(v13 + 40) )
          {
            if ( *(_DWORD *)(v13 + 40) > a4 )
              goto LABEL_37;
          }
          else if ( !*(_DWORD *)(v13 + 44) )
          {
            goto LABEL_18;
          }
          if ( *(_DWORD *)(v13 + 44) && *(_DWORD *)(v13 + 44) < a4 )
          {
LABEL_37:
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              v17 = a3;
              v15 = a4;
              WPP_SF_Sdd(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0xEu,
                (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
                L"RSA",
                v15,
                v17);
            }
            return v10;
          }
        }
      }
LABEL_18:
      v13 += 48i64;
    }
  }
  return 0;
}

//----- (00000001800169E0) ----------------------------------------------------
__int64 __fastcall SpLsaQueryContextAttributes(__int64 a1, unsigned int a2, __int64 a3)
{
  CCipherMill *v6; // rcx
  _QWORD *v7; // rdi
  __int64 v8; // rbx
  unsigned int v9; // eax

  v6 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids);
      v6 = WPP_GLOBAL_Control;
    }
    if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)v6 + 28) & 4) != 0 )
      {
        WPP_SF_q(*((_QWORD *)v6 + 2), 0x15u, (__int64)&WPP_dd5b111c8476393ce65badbe3d423765_Traceguids, a1);
        v6 = WPP_GLOBAL_Control;
      }
      if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 4) != 0 )
      {
        WPP_SF_d(*((_QWORD *)v6 + 2), 0x16u, (__int64)&WPP_dd5b111c8476393ce65badbe3d423765_Traceguids, a2);
        v6 = WPP_GLOBAL_Control;
      }
    }
  }
  v7 = *(_QWORD **)(a1 + 8);
  v8 = v7[10];
  if ( v8 && v6 != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)v6 + 28) & 4) != 0 )
    {
      WPP_SF_D(
        *((_QWORD *)v6 + 2),
        23i64,
        &WPP_dd5b111c8476393ce65badbe3d423765_Traceguids,
        *(unsigned int *)(v8 + 212));
      v6 = WPP_GLOBAL_Control;
    }
    if ( v6 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 4) != 0 )
      WPP_SF_S(
        *((_QWORD *)v6 + 2),
        0x18u,
        (__int64)&WPP_dd5b111c8476393ce65badbe3d423765_Traceguids,
        (const wchar_t *)(v8 + 216));
  }
  v9 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD, __int64))(*v7 + 200i64))(v7, a2, a3);
  return TranslateToSecurityStatus(v9);
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180016AB4) ----------------------------------------------------
BOOLEAN (__fastcall *SafeAllocaInitialize())(void *a1)
{
  PIMAGE_NT_HEADERS v0; // rax
  __int64 SizeOfStackCommit; // rcx
  __int64 GuaranteedStackBytes; // rax
  BOOLEAN (__fastcall *result)(void *); // rax

  v0 = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);
  if ( NtCurrentPeb()->BeingDebugged
    || !v0
    || (SizeOfStackCommit = v0->OptionalHeader.SizeOfStackCommit,
        v0->OptionalHeader.SizeOfStackReserve - SizeOfStackCommit < 0x3000) )
  {
    SizeOfStackCommit = 0i64;
  }
  g_ulMaxStackAllocSize = SizeOfStackCommit;
  if ( !v0 )
    goto LABEL_11;
  GuaranteedStackBytes = NtCurrentTeb()->GuaranteedStackBytes;
  g_ulAdditionalProbeSize = GuaranteedStackBytes;
  if ( GuaranteedStackBytes )
  {
    if ( (unsigned __int64)(GuaranteedStackBytes + 8) >= 8 )
      goto LABEL_7;
LABEL_11:
    g_ulAdditionalProbeSize = -9i64;
    goto LABEL_7;
  }
  g_ulAdditionalProbeSize = 12288i64;
LABEL_7:
  g_pfnAllocate = (__int64)SafeAllocaAllocateFromHeap;
  result = SafeAllocaFreeToHeap;
  g_pfnFree = (__int64)SafeAllocaFreeToHeap;
  return result;
}
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;

//----- (0000000180016B6C) ----------------------------------------------------
__int64 __fastcall CreateCachedSslProv(struct CACHED_SSL_PROVIDER *a1, const unsigned __int16 *a2)
{
  unsigned int v4; // ebx
  __int64 v5; // rdi
  rsize_t v6; // rdi
  wchar_t *v7; // rax
  wchar_t *v8; // rbp
  __int64 v9; // rcx
  __int64 v11; // [rsp+60h] [rbp+18h] BYREF

  v11 = 0i64;
  v4 = SslOpenProvider(&v11, a2, (unsigned int)dword_180092F58);
  if ( !v4 )
  {
    v5 = -1i64;
    do
      ++v5;
    while ( a2[v5] );
    v6 = v5 + 1;
    v7 = (wchar_t *)LocalAlloc(0x40u, 2 * v6);
    v8 = v7;
    if ( v7 )
    {
      wcscpy_s(v7, v6, a2);
      v9 = 0i64;
      *(_QWORD *)a1 = v11;
      v11 = 0i64;
      *((_QWORD *)a1 + 1) = v8;
      goto LABEL_6;
    }
    v4 = -2146893056;
  }
  v9 = v11;
LABEL_6:
  if ( v9 )
    SslFreeObject(v9, 0i64);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v4 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xFu,
      (__int64)&WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids,
      v4,
      v4);
  }
  return v4;
}
// 180092F58: using guessed type int dword_180092F58;
// 1800984F8: using guessed type __int64 __fastcall SslOpenProvider(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180016C58) ----------------------------------------------------
__int64 __fastcall SpQueryTokenBinding(struct CSslUserContext *a1, struct _SecPkgContext_TokenBinding *a2)
{
  struct _SecPkgContext_TokenBinding *v2; // rbx
  BYTE *v4; // rsi
  PBYTE KeyParameters; // rbp
  SIZE_T KeyParametersSize; // r14
  BYTE *v8; // rax

  v2 = (struct _SecPkgContext_TokenBinding *)*((_QWORD *)a1 + 51);
  v4 = 0i64;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 110i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
  if ( !v2 )
  {
    *a2 = 0i64;
    return 0i64;
  }
  KeyParameters = v2->KeyParameters;
  if ( !KeyParameters )
  {
LABEL_11:
    *a2 = *v2;
    a2->KeyParameters = v4;
    return 0i64;
  }
  KeyParametersSize = v2->KeyParametersSize;
  v8 = (BYTE *)LocalAlloc(0x40u, KeyParametersSize);
  v4 = v8;
  if ( v8 )
  {
    memcpy_0(v8, KeyParameters, KeyParametersSize);
    goto LABEL_11;
  }
  return 2148074240i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180016CD0) ----------------------------------------------------
char __fastcall CSessionCacheItem::DoesAppAllowCipher(CSessionCacheItem *this, struct CCredentialGroup *a2)
{
  if ( a2 )
    return CCipherMill::IsCipherSuiteAllowed(
             (__int64)g_cCipherMill,
             *((unsigned int **)a2 + 23),
             *((_DWORD *)a2 + 44),
             *((_DWORD *)a2 + 48),
             (*((_DWORD *)a2 + 39) >> 12) & 1,
             *((_DWORD *)a2 + 39) & 0x800,
             *((_DWORD *)a2 + 42),
             *((_DWORD *)a2 + 41),
             *((_DWORD *)a2 + 38),
             *((_QWORD *)this + 22),
             0i64,
             *((_QWORD *)a2 + 25),
             *((_DWORD *)a2 + 49),
             0);
  else
    return 0;
}

//----- (0000000180016DA0) ----------------------------------------------------
__int64 __fastcall SpDeleteUserModeContext(__int64 a1)
{
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_ce922361a63b3a68cf8f3b43d0a887f8_Traceguids);
  SslDeleteUserContext(a1);
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180016DE0) ----------------------------------------------------
void LoadSecurityDll(void)
{
  HMODULE Library; // rax
  HMODULE v1; // rax

  Library = LoadLibraryExW(L"sspicli.dll", 0i64, 0);
  g_hSspicli = Library;
  if ( Library )
    g_pFreeContextBuffer = (int (__stdcall *)(void *))GetProcAddress(Library, "FreeContextBuffer");
  v1 = LoadLibraryExW(L"mskeyprotect.dll", 0i64, 0x800u);
  g_hMskeyprotect = v1;
  if ( v1 )
  {
    g_pKeyFileProtectSessionTicket = (unsigned int (__stdcall *)(unsigned __int8 *, unsigned int, const unsigned __int16 *, unsigned __int8 **, unsigned int *))GetProcAddress(v1, "KeyFileProtectSessionTicket");
    g_pKeyFileUnprotectSessionTicket = (unsigned int (__stdcall *)(unsigned __int8 *, unsigned int, const unsigned __int16 *, unsigned __int8 **, unsigned int *))GetProcAddress(g_hMskeyprotect, "KeyFileUnprotectSessionTicket");
  }
}
// 180092180: using guessed type unsigned int (__stdcall *g_pKeyFileUnprotectSessionTicket)(unsigned __int8 *, unsigned int, const unsigned __int16 *, unsigned __int8 **, unsigned int *);
// 180092188: using guessed type unsigned int (__stdcall *g_pKeyFileProtectSessionTicket)(unsigned __int8 *, unsigned int, const unsigned __int16 *, unsigned __int8 **, unsigned int *);
// 1800921A0: using guessed type int (__stdcall *g_pFreeContextBuffer)(void *);

//----- (0000000180016E98) ----------------------------------------------------
CCipherMill *__fastcall CCipherMill::CCipherMill(CCipherMill *this)
{
  dword_180092488 = 0;
  qword_180092490 = 0i64;
  qword_180092498 = 0;
  hProvider = 0i64;
  *(_OWORD *)&xmmword_1800925B0 = 0i64;
  qword_1800925C0 = 0i64;
  qword_1800925C8 = 0i64;
  word_1800925D0 = 0;
  xmmword_1800925EA = 0i64;
  xmmword_1800925FA = 0i64;
  word_1800925E8 = 0;
  word_18009260A = 0;
  RtlInitializeResource(&Resource);
  g_cCipherMill = 1;
  return (CCipherMill *)&g_cCipherMill;
}
// 180092488: using guessed type int dword_180092488;
// 180092490: using guessed type __int64 qword_180092490;
// 1800925C0: using guessed type __int64 qword_1800925C0;
// 1800925D0: using guessed type __int16 word_1800925D0;
// 1800925EA: using guessed type __int128 xmmword_1800925EA;
// 1800925FA: using guessed type __int128 xmmword_1800925FA;
// 18009260A: using guessed type __int16 word_18009260A;

//----- (0000000180016F2C) ----------------------------------------------------
__int64 __fastcall CacheClientSideSslProv(struct CACHED_SSL_PROVIDER *a1)
{
  unsigned int v2; // ebx
  CCipherMill *v3; // rcx
  unsigned int v5; // [rsp+20h] [rbp-18h]

  v2 = 0;
  v3 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids);
    v3 = WPP_GLOBAL_Control;
  }
  if ( g_cCachedPagedSslProvs >= 0x20 )
  {
    if ( v3 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v3 + 28) & 1) != 0 )
    {
      WPP_SF_(*((_QWORD *)v3 + 2), 21i64, &WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids);
      v3 = WPP_GLOBAL_Control;
    }
    v2 = -2146893052;
  }
  else
  {
    *((_QWORD *)&g_rgCachedPagedSslProvs + 2 * g_cCachedPagedSslProvs) = *(_QWORD *)a1;
    *((_QWORD *)&g_rgCachedPagedSslProvs + 2 * g_cCachedPagedSslProvs++ + 1) = *((_QWORD *)a1 + 1);
    v3 = WPP_GLOBAL_Control;
  }
  if ( v3 != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)v3 + 28) & 1) != 0 && v2 || (*((_BYTE *)v3 + 28) & 4) != 0) )
  {
    v5 = v2;
    WPP_SF_DD(*((_QWORD *)v3 + 2), 0x16u, (__int64)&WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids, v2, v5);
  }
  return v2;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180092A90: using guessed type unsigned int g_cCachedPagedSslProvs;

//----- (0000000180016FD0) ----------------------------------------------------
__int64 InitializeClientSideSslProvCache(void)
{
  unsigned int v0; // ebx
  struct _RTL_RESOURCE *v1; // rax

  v0 = 0;
  v1 = (struct _RTL_RESOURCE *)LocalAlloc(0x40u, 0x60ui64);
  g_pSslProvCacheRWLock = v1;
  if ( v1 )
    RtlInitializeResource(v1);
  else
    v0 = -2146893056;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && ((*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 && v0 || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0) )
  {
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x13u,
      (__int64)&WPP_594269bf8ea736facf0022a8a380b3c5_Traceguids,
      v0,
      v0);
  }
  return v0;
}
// 18003EB64: conditional instruction was optimized away because rax.8==0

//----- (0000000180017090) ----------------------------------------------------
void __fastcall CSslGlobals::PeriodicCleanupHandler(void *a1, char a2)
{
  __int64 *v3; // rbx
  __int64 v4; // rdi
  unsigned int TickCount; // edi
  __int64 *v6; // rbx
  unsigned int v7; // ecx
  unsigned __int8 v8; // al
  _QWORD *v9; // r9
  __int64 v10; // r10
  __int64 v11; // rdx
  _QWORD *v12; // r8
  __int64 v13; // rdx
  _QWORD *v14; // rax

  if ( dword_180092D78 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)tls_index)
                                   + 4i64) )
  {
    Init_thread_header(&dword_180092D78);
    if ( dword_180092D78 == -1 )
    {
      qword_1800921E8 = (__int64)CSessionCacheServerItem::m_pServerCacheLookaside;
      xmmword_1800921F0 = xmmword_180092DD0;
      qword_180092200 = (__int64)&g_SslContextManager;
      qword_180092208 = (__int64)CSessionCacheManager::m_pSessionCacheManager;
      qword_180092210 = (__int64)CSslCredManager::m_pCredManager;
      Init_thread_footer(&dword_180092D78);
    }
  }
  if ( a2 )
  {
    v3 = &qword_1800921E8;
    v4 = 6i64;
    do
    {
      if ( *v3 )
        (**(void (__fastcall ***)(__int64, _QWORD))*v3)(*v3, CSslGlobals::m_dwCleanupIntervalInSeconds);
      ++v3;
      --v4;
    }
    while ( v4 );
    if ( dword_180092704 && dword_180092778 )
    {
      TickCount = GetTickCount();
      RtlAcquireResourceExclusive(&stru_180092718, 1u);
      v6 = (__int64 *)qword_180092708;
      while ( v6 != &qword_180092708 )
      {
        v7 = *((_DWORD *)v6 - 10);
        v6 = (__int64 *)*v6;
        v8 = HasTimeElapsed(v7, TickCount, dword_1800926F8);
        if ( dword_180092704 > dword_180092700 || v8 )
        {
          v11 = *(_QWORD *)(v10 + 24);
          if ( *(_QWORD *)(v11 + 8) != v10 + 24
            || (v12 = *(_QWORD **)(v10 + 32), *v12 != v10 + 24)
            || (*v12 = v11, *(_QWORD *)(v11 + 8) = v12, v13 = *v9, *(_QWORD **)(*v9 + 8i64) != v9)
            || (v14 = (_QWORD *)v9[1], (_QWORD *)*v14 != v9) )
          {
            __fastfail(3u);
          }
          *v14 = v13;
          *(_QWORD *)(v13 + 8) = v14;
          --dword_180092704;
          SPDeleteIssuerEntry((struct ISSUER_CACHE_ENTRY *)v10);
        }
      }
      RtlReleaseResource(&stru_180092718);
    }
  }
  else
  {
    (**(void (__fastcall ***)(CSessionCacheManager *, _QWORD))CSessionCacheManager::m_pSessionCacheManager)(
      CSessionCacheManager::m_pSessionCacheManager,
      0i64);
  }
  ResetEvent(CSslGlobals::m_hCleanupEvent);
}
// 18003EC25: variable 'v10' is possibly undefined
// 18003EC42: variable 'v9' is possibly undefined
// 1800920C8: using guessed type int tls_index;
// 1800921E8: using guessed type __int64 qword_1800921E8;
// 1800921F0: using guessed type __int128 xmmword_1800921F0;
// 180092200: using guessed type __int64 qword_180092200;
// 180092208: using guessed type __int64 qword_180092208;
// 180092210: using guessed type __int64 qword_180092210;
// 180092704: using guessed type int dword_180092704;
// 180092708: using guessed type __int64 qword_180092708;
// 180092778: using guessed type int dword_180092778;
// 1800927F8: using guessed type struct IAllocate *CSessionCacheServerItem::m_pServerCacheLookaside;
// 180092D78: using guessed type int dword_180092D78;
// 180092DA0: using guessed type __int64 g_SslContextManager;
// 180092DD0: using guessed type __int128 xmmword_180092DD0;

//----- (00000001800171B8) ----------------------------------------------------
__int64 __fastcall SpQuerySessionInfo(struct CSslUserContext *a1, struct _SecPkgContext_SessionInfo *a2)
{
  DWORD dwFlags; // eax

  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 94i64, &WPP_744a13241c3c3d6f8c9be4f6b1c08345_Traceguids);
  a2->dwFlags = 0;
  dwFlags = a2->dwFlags;
  if ( (*((_DWORD *)a1 + 4) & 0x8000i64) == 0 )
    dwFlags = 1;
  a2->dwFlags = dwFlags;
  a2->cbSessionId = *((_DWORD *)a1 + 80);
  memcpy_0(a2->rgbSessionId, (char *)a1 + 324, *((unsigned int *)a1 + 80));
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180017230) ----------------------------------------------------
__int64 SchannelShutdown(void)
{
  BOOL v0; // ebx
  unsigned int v1; // ebx
  CSslCredManager *v3; // rcx
  CCipherMill *v4; // rcx

  v0 = LsaTable == 0;
  RtlEnterCriticalSection(&CSslGlobals::m_InitCriticalSection);
  if ( !v0 )
  {
    v3 = CSessionCacheManager::m_pSessionCacheManager;
    if ( CSessionCacheManager::m_pSessionCacheManager )
    {
      CSessionCacheManager::ShutdownSessionCache(CSessionCacheManager::m_pSessionCacheManager);
      CSessionCacheManager::m_pSessionCacheManager = 0i64;
    }
    if ( CSslCredManager::m_pCredManager )
    {
      CSslCredManager::FreeCredentialManager(v3);
      CSslCredManager::m_pCredManager = 0i64;
    }
    if ( DTLSCookieManager::m_pCookieMgr )
    {
      DTLSCookieManager::`scalar deleting destructor'(DTLSCookieManager::m_pCookieMgr);
      DTLSCookieManager::m_pCookieMgr = 0i64;
    }
    ShutdownIssuerCache();
    SchShutdownEvents();
    UnloadSslRegOptions();
    TlsCloseBCryptHashProviders();
    if ( g_hSHAProvider )
    {
      BCryptCloseAlgorithmProvider(g_hSHAProvider, 0);
      g_hSHAProvider = 0i64;
    }
    if ( g_hMD5Provider )
    {
      BCryptCloseAlgorithmProvider(g_hMD5Provider, 0);
      g_hMD5Provider = 0i64;
    }
    if ( g_hDSAProvider )
    {
      BCryptCloseAlgorithmProvider(g_hDSAProvider, 0);
      g_hDSAProvider = 0i64;
    }
    if ( g_hRSAProvider )
    {
      BCryptCloseAlgorithmProvider(g_hRSAProvider, 0);
      g_hRSAProvider = 0i64;
    }
    if ( g_hDhSchannelProv )
    {
      CryptReleaseContext(g_hDhSchannelProv, 0);
      g_hDhSchannelProv = 0i64;
    }
    RtlAcquireResourceExclusive(&Resource, 1u);
    CCipherMill::ClearCipherMill(v4, 1);
    RtlReleaseResource(&Resource);
    CSslGlobals::CleanupPeriodicCleanupHandler();
    CSslGlobals::CleanupCryptLocatorHandles();
    CSslGlobals::CleanupCryptLocatorEvents();
    if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    {
      CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized = 0;
      TlgUnregisterAggregateProvider();
    }
  }
  if ( g_hSspicli )
  {
    FreeLibrary(g_hSspicli);
    g_hSspicli = 0i64;
    g_pFreeContextBuffer = 0i64;
  }
  if ( g_hMskeyprotect )
  {
    FreeLibrary(g_hMskeyprotect);
    g_hMskeyprotect = 0i64;
    g_pKeyFileProtectSessionTicket = 0i64;
    g_pKeyFileUnprotectSessionTicket = 0i64;
  }
  if ( g_pSslProvCacheRWLock )
  {
    RtlDeleteResource(g_pSslProvCacheRWLock);
    LocalFree(g_pSslProvCacheRWLock);
  }
  v1 = 0;
  for ( g_pSslProvCacheRWLock = 0i64; v1 < g_cCachedPagedSslProvs; ++v1 )
    DestroyCachedSslProv((struct CACHED_SSL_PROVIDER *)((char *)&g_rgCachedPagedSslProvs + 16 * v1));
  g_cCachedPagedSslProvs = 0;
  CSslGlobals::m_bSchannelInitialized = 0;
  RtlLeaveCriticalSection(&CSslGlobals::m_InitCriticalSection);
  return 1i64;
}
// 18003ECF1: variable 'v3' is possibly undefined
// 18003EDE5: variable 'v4' is possibly undefined
// 180092180: using guessed type unsigned int (__stdcall *g_pKeyFileUnprotectSessionTicket)(unsigned __int8 *, unsigned int, const unsigned __int16 *, unsigned __int8 **, unsigned int *);
// 180092188: using guessed type unsigned int (__stdcall *g_pKeyFileProtectSessionTicket)(unsigned __int8 *, unsigned int, const unsigned __int16 *, unsigned __int8 **, unsigned int *);
// 1800921A0: using guessed type int (__stdcall *g_pFreeContextBuffer)(void *);
// 1800921D8: using guessed type int CSslGlobals::m_bSchannelInitialized;
// 180092620: using guessed type __int64 LsaTable;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 180092A90: using guessed type unsigned int g_cCachedPagedSslProvs;

//----- (0000000180017348) ----------------------------------------------------
void __fastcall DestroyCachedSslProv(struct CACHED_SSL_PROVIDER *a1)
{
  __int64 v2; // rcx
  void *v3; // rcx

  v2 = *(_QWORD *)a1;
  if ( v2 )
  {
    SslFreeObject(v2, 0i64);
    *(_QWORD *)a1 = 0i64;
  }
  v3 = (void *)*((_QWORD *)a1 + 1);
  if ( v3 )
  {
    LocalFree(v3);
    *((_QWORD *)a1 + 1) = 0i64;
  }
}
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180017394) ----------------------------------------------------
__int64 __fastcall Wow64CopyUnicodeString(unsigned int a1, struct _UNICODE_STRING *a2)
{
  unsigned int v3; // edi
  unsigned int v4; // ecx
  unsigned int v5; // edi
  WCHAR *v6; // rax
  unsigned int Length; // edx
  PWSTR Buffer; // rcx
  __int64 v10; // [rsp+50h] [rbp+18h] BYREF

  v10 = 0i64;
  if ( a1 && a2 )
  {
    v3 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64 *, _QWORD))(LsaTable + 80))(0i64, 8i64, &v10, a1);
    if ( !v3 )
    {
      v4 = WORD1(v10);
      if ( !WORD1(v10)
        || !(_WORD)v10
        || !HIDWORD(v10)
        || (v10 & 1) != 0
        || (v10 & 0x10000) != 0
        || (unsigned __int16)v10 > WORD1(v10)
        || WORD1(v10) == 0xFFFF )
      {
LABEL_18:
        v3 = -2146892963;
        goto LABEL_19;
      }
      a2->Length = v10;
      v5 = v4;
      a2->MaximumLength = v4;
      v6 = (WCHAR *)SPExternalAlloc(v4);
      a2->Buffer = v6;
      if ( v6 )
      {
        v3 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, WCHAR *, _QWORD))(LsaTable + 80))(0i64, v5, v6, HIDWORD(v10));
        if ( !v3 )
        {
          Length = a2->Length;
          if ( a2->Buffer[((unsigned __int64)a2->Length >> 1) - 1] )
            return v3;
          if ( Length > 2 )
          {
            a2->Length = Length - 2;
            return v3;
          }
          goto LABEL_18;
        }
      }
      else
      {
        v3 = -2146893056;
      }
    }
LABEL_19:
    Buffer = a2->Buffer;
    if ( Buffer )
    {
      SPExternalFree(Buffer);
      a2->Buffer = 0i64;
    }
    *(_DWORD *)&a2->Length = 0;
    return v3;
  }
  return 3221225485i64;
}
// 180092620: using guessed type __int64 LsaTable;

//----- (00000001800174C8) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::LogUnknownTlsExtension(CSchannelTelemetryContext *this, int a2)
{
  __int64 v2; // rax

  if ( this && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
  {
    if ( a2 > 16 )
    {
      if ( a2 < 23 || a2 > 24 && a2 != 35 && a2 != 65281 )
        goto LABEL_17;
    }
    else if ( a2 != 16 && (a2 < 0 || a2 > 6 && (a2 <= 9 || a2 > 11 && (a2 <= 12 || a2 > 14))) )
    {
LABEL_17:
      v2 = *((unsigned __int16 *)this + 892);
      if ( (unsigned int)v2 < 0x32 )
      {
        *((_DWORD *)this + v2 + 396) = a2;
        ++*((_WORD *)this + 892);
      }
    }
  }
}
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180017510) ----------------------------------------------------
__int64 __fastcall _delayLoadHelper2(__int64 a1, __int64 a2)
{
  return ResolveDelayLoadedAPI(
           &_ImageBase,
           a1,
           _pfnDefaultDliFailureHook2,
           DelayLoadFailureHook,
           a2,
           _ResolveDelayLoadedAPIFlags);
}
// 180000000: using guessed type __int16 _ImageBase;
// 1800807F8: using guessed type __int64 __fastcall ResolveDelayLoadedAPI(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180086924: using guessed type int _ResolveDelayLoadedAPIFlags;
// 180086928: using guessed type __int64 _pfnDefaultDliFailureHook2;

//----- (0000000180017560) ----------------------------------------------------
__int64 __fastcall CSslCredManager::RunBalancer(CSslCredManager *this)
{
  char v2; // bp
  void *v3; // rcx
  bool v4; // si
  DWORD LastError; // eax
  _DWORD *i; // rax
  __int64 *j; // rax

  v2 = 0;
  if ( _InterlockedIncrement((volatile signed __int32 *)this + 22) <= 1 )
  {
    v3 = (void *)*((_QWORD *)this + 10);
    if ( v3 && *((_QWORD *)this + 9) && !WaitForSingleObjectEx(v3, 0, 0) )
    {
      v2 = 1;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 24i64, &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids);
      if ( !CertControlStore(*((HCERTSTORE *)this + 9), 0, 1u, (char *)this + 80)
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        LastError = GetLastError();
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          25i64,
          &WPP_d7209deee65a328fe195e0fa91b71573_Traceguids,
          LastError);
      }
    }
    v4 = WaitForSingleObjectEx(CSslGlobals::m_hImplicitCertChangeEvent, 0, 0) == 0;
    if ( !WaitForSingleObjectEx(CSslGlobals::m_hImplicitIssersChangeEvent, 0, 0) )
    {
      RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
      for ( i = (_DWORD *)*((_QWORD *)this + 6); i != (_DWORD *)((char *)this + 48); i = *(_DWORD **)i )
        i[37] |= 0x10u;
      RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
    }
    if ( v2 || v4 )
    {
      RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
      for ( j = (__int64 *)*((_QWORD *)this + 6); j != (__int64 *)((char *)this + 48); j = (__int64 *)*j )
      {
        if ( v4 && j[99] || v2 && !j[99] )
          *((_DWORD *)j + 37) |= 0x40u;
      }
      RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)((char *)this + 8));
    }
  }
  _InterlockedDecrement((volatile signed __int32 *)this + 22);
  return 0i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180017638) ----------------------------------------------------
__int64 WPP_INIT_CONTROL_ARRAY()
{
  __int64 result; // rax

  result = 0i64;
  qword_180092A78 = 1i64;
  qword_180092A70 = 0i64;
  WPP_MAIN_CB = 0i64;
  return result;
}
// 180092A60: using guessed type __int64 WPP_MAIN_CB;
// 180092A70: using guessed type __int64 qword_180092A70;
// 180092A78: using guessed type __int64 qword_180092A78;

//----- (0000000180017660) ----------------------------------------------------
__int64 __fastcall SpQueryCredentialsAttributes(struct CCredentialGroup *a1, int a2, _QWORD *a3)
{
  int v6; // r14d
  unsigned int v7; // ebx
  __int64 result; // rax
  int v9; // edi
  int v10; // edi
  int v11; // edi
  int v12; // eax
  CCipherMill *v13; // rcx
  int v14; // ebx
  int v15; // eax
  int v16; // eax
  unsigned int v17; // eax
  int v18; // edi
  unsigned int v19; // r15d
  int v20; // esi
  int v21; // edi
  HLOCAL v22; // rdi
  __int64 v23; // rax
  unsigned int v24; // r15d
  int v25; // esi
  int v26; // esi
  __int64 v27; // [rsp+30h] [rbp-58h] BYREF
  __int64 v28[2]; // [rsp+38h] [rbp-50h] BYREF
  __int64 v29; // [rsp+48h] [rbp-40h] BYREF
  int v30; // [rsp+50h] [rbp-38h]
  HLOCAL hMem; // [rsp+90h] [rbp+8h] BYREF
  unsigned int *v32; // [rsp+A8h] [rbp+20h] BYREF

  v32 = 0i64;
  LODWORD(hMem) = 0;
  v27 = 0i64;
  if ( !a1 )
    return 2148074241i64;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64 *))(LsaTable + 192))(&v29) )
    return 2148074244i64;
  if ( (v30 & 0x10000) != 0 )
    return QueryCredAttributesRpc(a1, a2, a3);
  v6 = v30 & 0x40;
  switch ( a2 )
  {
    case 1:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 23i64, &WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids);
      v7 = v6 != 0 ? 4 : 8;
      break;
    case 86:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20i64, &WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids);
      v7 = v6 != 0 ? 8 : 16;
      break;
    case 87:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 21i64, &WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids);
      v7 = 8;
      break;
    case 88:
      v7 = 4;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids);
      break;
    default:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        WPP_SF_d(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x18u,
          (__int64)&WPP_d9c5339d4bdb3d03f2cfcf1c7d7ab7b7_Traceguids,
          a2);
      return 2148074242i64;
  }
  result = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64 *, _QWORD *))(LsaTable + 80))(0i64, v7, v28, a3);
  if ( (int)result < 0 )
    return result;
  v9 = a2 - 1;
  if ( v9 )
  {
    v10 = v9 - 85;
    if ( !v10 )
    {
      v17 = BuildLegacySupportedAlgsList(a1, &v32, (unsigned int *)&hMem);
      result = TranslateToSecurityStatus(v17);
      if ( (_DWORD)result )
        return result;
      v18 = (int)hMem;
      v19 = 4 * (_DWORD)hMem;
      v20 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64 *))(LsaTable + 56))(
              0i64,
              (unsigned int)(4 * (_DWORD)hMem),
              &v27);
      if ( v20 < 0 )
      {
        SPExternalFree(v32);
        return (unsigned int)v20;
      }
      LODWORD(v28[0]) = v18;
      if ( v6 )
        HIDWORD(v28[0]) = v27;
      else
        v28[1] = v27;
      v21 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, unsigned int *))(LsaTable + 72))(0i64, v19, v27, v32);
      SPExternalFree(v32);
      if ( v21 < 0 )
      {
        (*(void (__fastcall **)(_QWORD, __int64))(LsaTable + 64))(0i64, v27);
        return (unsigned int)v21;
      }
      goto LABEL_17;
    }
    v11 = v10 - 1;
    if ( v11 )
    {
      if ( v11 != 1 )
        goto LABEL_17;
      v15 = *((_DWORD *)a1 + 38);
    }
    else
    {
      v12 = *((_DWORD *)a1 + 41);
      LODWORD(v28[0]) = v12;
      v13 = (CCipherMill *)*((unsigned int *)a1 + 42);
      HIDWORD(v28[0]) = (_DWORD)v13;
      if ( (_DWORD)v13 )
      {
        if ( v12 )
          goto LABEL_17;
      }
      else if ( !v12 )
      {
        goto LABEL_17;
      }
      CCipherMill::GetBaseCipherSizes(v13, v30 & 1, (unsigned int *)&v32, (unsigned int *)&hMem);
      v16 = HIDWORD(v28[0]);
      if ( !*((_DWORD *)a1 + 42) )
        v16 = (int)hMem;
      HIDWORD(v28[0]) = v16;
      if ( *((_DWORD *)a1 + 41) )
        goto LABEL_17;
      v15 = (int)v32;
    }
    LODWORD(v28[0]) = v15;
LABEL_17:
    v14 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD *, __int64 *))(LsaTable + 72))(0i64, v7, a3, v28);
    if ( v14 >= 0 )
      return 0i64;
    if ( v27 )
      (*(void (__fastcall **)(_QWORD))(LsaTable + 64))(0i64);
    return (unsigned int)v14;
  }
  hMem = 0i64;
  result = CCredentialGroup::GetNameFromFirstCred(a1, (unsigned __int16 **)&hMem);
  if ( (_DWORD)result )
    return result;
  v22 = hMem;
  v23 = -1i64;
  do
    ++v23;
  while ( *((_WORD *)hMem + v23) );
  v24 = 2 * v23 + 2;
  v25 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64 *))(LsaTable + 56))(0i64, v24, &v27);
  if ( v25 >= 0 )
  {
    if ( v6 )
      LODWORD(v28[0]) = v27;
    else
      v28[0] = v27;
    if ( !v27
      || (v26 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, HLOCAL))(LsaTable + 72))(0i64, v24, v27, v22),
          v26 >= 0) )
    {
      if ( v22 )
        LocalFree(v22);
      goto LABEL_17;
    }
    (*(void (__fastcall **)(_QWORD, __int64))(LsaTable + 64))(0i64, v27);
    if ( v22 )
      LocalFree(v22);
    return (unsigned int)v26;
  }
  else
  {
    if ( v22 )
      LocalFree(v22);
    return (unsigned int)v25;
  }
}
// 1800178F3: conditional instruction was optimized away because ecx.4!=0
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180017BBC) ----------------------------------------------------
__int64 McGenEventRegister_EtwEventRegister()
{
  __int64 result; // rax

  result = 0i64;
  if ( !MS_Schannel_Provider_Context )
    return EtwEventRegister(
             &MS_Schannel_Provider,
             McGenControlCallbackV2,
             &MS_Schannel_Provider_Context,
             &MS_Schannel_Provider_Context);
  return result;
}
// 180080EA8: using guessed type __int64 __fastcall EtwEventRegister(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180017BFC) ----------------------------------------------------
__int64 WppCleanupUm()
{
  CCipherMill *v0; // rbx
  __int64 result; // rax

  v0 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    while ( v0 )
    {
      if ( *((_QWORD *)v0 + 1) )
      {
        result = EtwUnregisterTraceGuids();
        *((_QWORD *)v0 + 1) = 0i64;
      }
      v0 = *(CCipherMill **)v0;
    }
    WPP_GLOBAL_Control = (CCipherMill *)&WPP_GLOBAL_Control;
  }
  return result;
}
// 180080E08: using guessed type __int64 EtwUnregisterTraceGuids(void);

//----- (0000000180017C60) ----------------------------------------------------
__int64 __fastcall CSslLookaside::RunBalancer(CSslLookaside *this, unsigned int a2)
{
  int v4; // eax
  int v5; // ecx
  int v6; // r9d
  char v7; // cl
  int v8; // edx
  int v9; // edx
  int v10; // edi
  PSLIST_ENTRY v11; // rax

  if ( *((_BYTE *)this + 32) && a2 )
  {
    v4 = *((_DWORD *)this + 15);
    v5 = v4 - *((_DWORD *)this + 14);
    *((_DWORD *)this + 14) = v4;
    v6 = *((_DWORD *)this + 17) - *((_DWORD *)this + 16);
    *((_DWORD *)this + 16) = *((_DWORD *)this + 17);
    if ( 60 * v5 / a2 >= *((_DWORD *)this + 12) )
    {
      if ( v6 )
        return 0i64;
      v8 = *((_DWORD *)this + 13);
      if ( v8 <= v5 )
        return 0i64;
      v7 = *((_BYTE *)this + 33) + 1;
    }
    else
    {
      v7 = *((_BYTE *)this + 33);
      v8 = *((_DWORD *)this + 13);
    }
    v9 = v8 >> v7;
    v10 = v9 + 1;
    if ( v9 != -1 )
    {
      do
      {
        if ( *((_DWORD *)this + 13) <= *((_DWORD *)this + 10) )
          break;
        v11 = InterlockedPopEntrySList((PSLIST_HEADER)this + 1);
        SPExternalFree(v11);
        _InterlockedDecrement((volatile signed __int32 *)this + 13);
        --v10;
      }
      while ( v10 );
    }
  }
  return 0i64;
}

//----- (0000000180017C90) ----------------------------------------------------
void __fastcall CSslContextManager::~CSslContextManager(CSslContextManager *this)
{
  __int64 v2; // rcx
  __int64 v3; // rcx

  *(_QWORD *)this = &CSslContextManager::`vftable';
  v2 = *((_QWORD *)this + 6);
  if ( v2 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v2 + 8i64))(v2, 1i64);
  v3 = *((_QWORD *)this + 7);
  if ( v3 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 8i64))(v3, 1i64);
}
// 18007D3E8: using guessed type void *CSslContextManager::`vftable';

//----- (0000000180017CCC) ----------------------------------------------------
void DeleteDebugTracing()
{
  struct _DBG_TRACE_CONTROL_BLOCK *v0; // rdi
  struct _RTL_CRITICAL_SECTION *SharedMem; // rax
  struct _RTL_CRITICAL_SECTION *v2; // rbx
  __int64 v3; // rcx
  struct _DBG_TRACE_CONTROL_BLOCK **v4; // rax
  HANDLE LockSemaphore; // rcx
  int v6; // eax
  PRTL_CRITICAL_SECTION_DEBUG DebugInfo; // r8
  int SpinCount; // eax
  void (__stdcall *v9)(PVOID, BOOLEAN); // r8
  unsigned int OwningThread_high; // esi
  int v11; // ecx
  void *v12; // rdx

  v0 = SchannelGlobalTraceControlBlock;
  if ( (NtCurrentPeb()->BitField & 2) == 0 )
  {
    if ( SchannelGlobalTraceControlBlock )
    {
      SharedMem = (struct _RTL_CRITICAL_SECTION *)_DbgpOpenOrCreateSharedMem();
      v2 = SharedMem;
      if ( SharedMem )
      {
        EnterCriticalSection(SharedMem + 2);
        v3 = *(_QWORD *)v0;
        if ( *(struct _DBG_TRACE_CONTROL_BLOCK **)(*(_QWORD *)v0 + 8i64) != v0
          || (v4 = (struct _DBG_TRACE_CONTROL_BLOCK **)*((_QWORD *)v0 + 1), *v4 != v0) )
        {
          __fastfail(3u);
        }
        *v4 = (struct _DBG_TRACE_CONTROL_BLOCK *)v3;
        *(_QWORD *)(v3 + 8) = v4;
        LockSemaphore = v2[1].LockSemaphore;
        v6 = LODWORD(v2->SpinCount) - 1;
        LODWORD(v2->SpinCount) = v6;
        if ( LockSemaphore == *((HANDLE *)v0 + 18) )
        {
          DeleteTimerQueueTimer(0i64, (HANDLE)v2[1].SpinCount, (HANDLE)0xFFFFFFFFFFFFFFFFi64);
          v2[1].SpinCount = 0i64;
          v2[1].LockSemaphore = 0i64;
          DebugInfo = v2[1].DebugInfo;
          if ( DebugInfo != (PRTL_CRITICAL_SECTION_DEBUG)&v2[1] )
          {
            SpinCount = v2->SpinCount;
            HIDWORD(v2[1].OwningThread) = 10 * (SpinCount + 6);
            v9 = *(void (__stdcall **)(PVOID, BOOLEAN))&DebugInfo[3].Type;
            v2[1].LockSemaphore = v9;
            if ( !CreateTimerQueueTimer(
                    (PHANDLE)&v2[1].SpinCount,
                    0i64,
                    v9,
                    v2,
                    10000 * (SpinCount + 6),
                    10000 * (SpinCount + 6),
                    0) )
              v2[1].LockSemaphore = 0i64;
          }
        }
        else if ( LockSemaphore )
        {
          OwningThread_high = HIDWORD(v2[1].OwningThread);
          v11 = 10 * v6;
          if ( OwningThread_high > 10 * v6 + 120 )
          {
            v12 = (void *)v2[1].SpinCount;
            HIDWORD(v2[1].OwningThread) = v11 + 60;
            if ( !ChangeTimerQueueTimer(0i64, v12, 1000 * (v11 + 60), 1000 * (v11 + 60)) )
              HIDWORD(v2[1].OwningThread) = OwningThread_high;
          }
        }
        LeaveCriticalSection(v2 + 2);
        _DbgpDeleteTraceControl(v0);
        SchannelGlobalTraceControlBlock = 0i64;
      }
    }
  }
}

//----- (0000000180017D1C) ----------------------------------------------------
__int64 McGenEventUnregister_EtwEventUnregister()
{
  __int64 result; // rax

  if ( !MS_Schannel_Provider_Context )
    return 0i64;
  result = EtwEventUnregister();
  MS_Schannel_Provider_Context = 0i64;
  return result;
}
// 180080EA0: using guessed type __int64 EtwEventUnregister(void);

//----- (0000000180017D60) ----------------------------------------------------
__int64 __fastcall CSslContextManager::RunBalancer(CSslContextManager *this, int a2)
{
  unsigned __int32 v3; // eax

  if ( a2 && *((_QWORD *)this + 7) && *((_DWORD *)this + 5) >= 0x64u )
  {
    v3 = *((_DWORD *)this + 6);
    if ( v3 > *((_DWORD *)this + 7) )
      _InterlockedExchange((volatile __int32 *)this + 7, v3);
    *((_DWORD *)this + 6) = 0;
  }
  return 0i64;
}

//----- (0000000180017D80) ----------------------------------------------------
void __fastcall tlgEnableCallback(
        LPCGUID SourceId,
        __int64 IsEnabled,
        __int64 Level,
        ULONGLONG MatchAnyKeyword,
        ULONGLONG MatchAllKeyword,
        PEVENT_FILTER_DESCRIPTOR FilterData,
        _QWORD *CallbackContext)
{
  int v7; // eax
  void (__fastcall *v8)(LPCGUID, __int64, __int64, ULONGLONG, ULONGLONG, PEVENT_FILTER_DESCRIPTOR, _QWORD); // rax

  if ( CallbackContext )
  {
    if ( (_DWORD)IsEnabled )
    {
      if ( (_DWORD)IsEnabled == 1 )
      {
        if ( (_BYTE)Level )
          v7 = (unsigned __int8)Level + 1;
        else
          v7 = 256;
        *(_DWORD *)CallbackContext = v7;
        CallbackContext[2] = MatchAnyKeyword;
        CallbackContext[3] = MatchAllKeyword;
      }
    }
    else
    {
      *(_DWORD *)CallbackContext = 0;
    }
    v8 = (void (__fastcall *)(LPCGUID, __int64, __int64, ULONGLONG, ULONGLONG, PEVENT_FILTER_DESCRIPTOR, _QWORD))CallbackContext[5];
    if ( v8 )
      v8(SourceId, IsEnabled, Level, MatchAnyKeyword, MatchAllKeyword, FilterData, CallbackContext[6]);
  }
}

//----- (0000000180017E08) ----------------------------------------------------
void __fastcall CCipherMill::~CCipherMill(CCipherMill *this)
{
  if ( *(_BYTE *)this )
    RtlDeleteResource((PRTL_RESOURCE)((char *)this + 8));
}

//----- (0000000180017E30) ----------------------------------------------------
BOOLEAN RemoveExternalSchannelAlgorithms()
{
  BOOLEAN result; // al

  if ( dword_1800921B0 )
  {
    FreeExternalHashAlgorithms();
    FreeExternalSignatureAlgorithms();
    FreeExternalKeyExchangeAlgorithms();
    return FreeExternalCipherAlgorithms();
  }
  return result;
}
// 1800921B0: using guessed type int dword_1800921B0;

//----- (0000000180017E50) ----------------------------------------------------
void __fastcall TlgAggregateInternalProviderCallback(const struct _GUID *a1, int a2, __int64 a3, __int64 a4)
{
  __int64 i; // rbx

  if ( a2 == 2 && a4 == 32 && TryAcquireSRWLockExclusive(&SRWLock) )
  {
    for ( i = qword_180092EE8; i; i = *(_QWORD *)(i + 336) )
      LookUpTableFlushComplete(i);
    ReleaseSRWLockExclusive(&SRWLock);
  }
}
// 180092EE8: using guessed type __int64 qword_180092EE8;

//----- (0000000180017EA0) ----------------------------------------------------
__int64 __fastcall SpSslGetInfo(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 4) = 917505;
  *(_QWORD *)(a1 + 16) = L"Schannel";
  *(_QWORD *)(a1 + 24) = L"Schannel Security Package";
  result = 0i64;
  *(_DWORD *)a1 = 4261811;
  *(_DWORD *)(a1 + 8) = 24576;
  return result;
}

//----- (0000000180017EE0) ----------------------------------------------------
__int64 __fastcall SpUniGetInfo(__int64 a1)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 4) = 917505;
  *(_QWORD *)(a1 + 16) = L"Microsoft Unified Security Protocol Provider";
  *(_QWORD *)(a1 + 24) = L"Schannel Security Package";
  result = 0i64;
  *(_DWORD *)a1 = 4261811;
  *(_DWORD *)(a1 + 8) = 24576;
  return result;
}

//----- (0000000180017F30) ----------------------------------------------------
__int64 SpShutdown()
{
  return 2148074242i64;
}

//----- (0000000180017F40) ----------------------------------------------------
void *__fastcall IAllocate::Allocate(IAllocate *this)
{
  return 0i64;
}

//----- (0000000180017F50) ----------------------------------------------------
__int64 __fastcall IBalance::RunBalancer(IBalance *this)
{
  return 120i64;
}

//----- (0000000180017F60) ----------------------------------------------------
void __fastcall CSslUserContext::GetCertContextInfo(
        CSslUserContext *this,
        unsigned __int8 **a2,
        unsigned int *a3,
        unsigned __int16 **a4,
        unsigned int *a5,
        unsigned __int16 **a6,
        unsigned int *a7,
        unsigned __int8 **a8,
        unsigned int *a9,
        const unsigned __int8 **a10,
        unsigned int *a11,
        unsigned __int8 **a12,
        unsigned int *a13)
{
  *a2 = (unsigned __int8 *)*((_QWORD *)this + 19);
  *a3 = *((_DWORD *)this + 40);
  *a4 = (unsigned __int16 *)*((_QWORD *)this + 21);
  *a5 = *((_DWORD *)this + 44);
  *a6 = (unsigned __int16 *)*((_QWORD *)this + 23);
  *a7 = *((_DWORD *)this + 48);
  *a8 = (unsigned __int8 *)*((_QWORD *)this + 25);
  *a9 = *((_DWORD *)this + 52);
  *a10 = (const unsigned __int8 *)*((_QWORD *)this + 27);
  *a11 = *((_DWORD *)this + 56);
  *a12 = (unsigned __int8 *)*((_QWORD *)this + 29);
  *a13 = *((_DWORD *)this + 60);
}

//----- (0000000180018010) ----------------------------------------------------
__int64 __fastcall CSslUserContext::GetClientAuthResults(CSslUserContext *this, unsigned __int64 *a2, int *a3)
{
  *a2 = *((_QWORD *)this + 33);
  *a3 = *((_DWORD *)this + 68);
  return 0i64;
}

//----- (0000000180018030) ----------------------------------------------------
unsigned __int64 __fastcall CSslUserContext::GetExporterMasterKey(CSslUserContext *this)
{
  return *((_QWORD *)this + 54);
}

//----- (0000000180018050) ----------------------------------------------------
void __fastcall CSslUserContext::GetReadWriteKeys(CSslUserContext *this, unsigned __int64 *a2, unsigned __int64 *a3)
{
  *a2 = *((_QWORD *)this + 5);
  *a3 = *((_QWORD *)this + 6);
}

//----- (0000000180018070) ----------------------------------------------------
struct _SecPkgContext_ApplicationProtocol *__fastcall CSslUserContext::GetSelectedApplicationProtocol(
        CSslUserContext *this)
{
  return (struct _SecPkgContext_ApplicationProtocol *)*((_QWORD *)this + 49);
}

//----- (0000000180018090) ----------------------------------------------------
struct _SecPkgContext_SrtpParameters *__fastcall CSslUserContext::GetSelectedSrtpParameters(CSslUserContext *this)
{
  return (struct _SecPkgContext_SrtpParameters *)*((_QWORD *)this + 50);
}

//----- (00000001800180B0) ----------------------------------------------------
struct _SecPkgContext_TokenBinding *__fastcall CSslUserContext::GetSelectedTBParameters(CSslUserContext *this)
{
  return (struct _SecPkgContext_TokenBinding *)*((_QWORD *)this + 51);
}

//----- (00000001800180D0) ----------------------------------------------------
struct _SecPkgContext_KeyingMaterial *__fastcall CSslUserContext::GetTokenBindingEKM(CSslUserContext *this)
{
  return (struct _SecPkgContext_KeyingMaterial *)((char *)this + 416);
}

//----- (00000001800180F0) ----------------------------------------------------
void __fastcall CSslUserContext::GetUniqueBindings(CSslUserContext *this, unsigned __int8 **a2, unsigned int *a3)
{
  *a2 = (unsigned __int8 *)*((_QWORD *)this + 31);
  *a3 = *((_DWORD *)this + 64);
}

//----- (0000000180018110) ----------------------------------------------------
__int64 __fastcall CSslUserContext::PopulateSerialContextState(CSslUserContext *this, struct _SSL_PACKED_CONTEXT *a2)
{
  *(_DWORD *)a2 = *((_DWORD *)this + 2);
  *((_QWORD *)a2 + 1) = *((_QWORD *)this + 2);
  *((_DWORD *)a2 + 4) = *((_DWORD *)this + 6);
  *((_DWORD *)a2 + 5) = *((_DWORD *)this + 14);
  *((_DWORD *)a2 + 6) = *((_DWORD *)this + 15);
  *((_DWORD *)a2 + 7) = *((_DWORD *)this + 7);
  *((_DWORD *)a2 + 8) = *((_DWORD *)this + 16);
  *((_DWORD *)a2 + 9) = *((_DWORD *)this + 18);
  *((_DWORD *)a2 + 38) = *((_DWORD *)this + 17);
  *((_DWORD *)a2 + 10) = *((_DWORD *)this + 49);
  *((_QWORD *)a2 + 6) = *((_QWORD *)this + 12);
  *((_QWORD *)a2 + 7) = *((_QWORD *)this + 13);
  *((_DWORD *)a2 + 44) = *((_DWORD *)this + 29);
  *((_QWORD *)a2 + 20) = *((_QWORD *)this + 15);
  *((_QWORD *)a2 + 21) = *((_QWORD *)this + 16);
  *((_WORD *)a2 + 90) = *((_WORD *)this + 68);
  *((_WORD *)a2 + 91) = *((_WORD *)this + 69);
  *((_DWORD *)a2 + 47) = *((_DWORD *)this + 115);
  *((_BYTE *)a2 + 192) = *((_BYTE *)this + 456);
  *((_BYTE *)a2 + 44) = *((_BYTE *)this + 32);
  *((_DWORD *)a2 + 36) = *((_DWORD *)this + 94);
  *((_DWORD *)a2 + 37) = *((_DWORD *)this + 95);
  *((_DWORD *)a2 + 22) = *((_DWORD *)this + 80);
  memcpy_0((char *)a2 + 92, (char *)this + 324, *((unsigned int *)this + 80));
  *((_DWORD *)a2 + 31) = *((_DWORD *)this + 89);
  memcpy_0((char *)a2 + 128, (char *)this + 360, *((unsigned int *)this + 89));
  *((_QWORD *)a2 + 10) = *((_QWORD *)this + 37);
  return 0i64;
}

//----- (0000000180018250) ----------------------------------------------------
__int64 SpCompleteAuthToken()
{
  return 3221225659i64;
}

//----- (0000000180018260) ----------------------------------------------------
__int64 SpFormatCredentials()
{
  return 3221225659i64;
}

//----- (0000000180018270) ----------------------------------------------------
__int64 SpMakeSignature()
{
  return 2148074242i64;
}

//----- (0000000180018280) ----------------------------------------------------
__int64 SpVerifySignature()
{
  return 2148074242i64;
}

//----- (00000001800182A0) ----------------------------------------------------
__int64 __fastcall CSslContext::GenerateHello(CSslContext *this, struct SPBuffer *a2)
{
  return 120i64;
}

//----- (00000001800182B0) ----------------------------------------------------
__int64 __fastcall CSslContext::GenerateTlsAlertMessage(CSslContext *this, struct SPBuffer *a2)
{
  return 0i64;
}

//----- (00000001800182C0) ----------------------------------------------------
struct CSslCredential *__fastcall CSsl3TlsClientContext::GetActiveCred(CSsl3TlsClientContext *this)
{
  return (struct CSslCredential *)*((_QWORD *)this + 116);
}

//----- (00000001800182E0) ----------------------------------------------------
struct CSslCredential *__fastcall CSsl3TlsServerContext::GetActiveCred(CSsl3TlsServerContext *this)
{
  return *(struct CSslCredential **)(*((_QWORD *)this + 124) + 336i64);
}

//----- (0000000180018300) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::GetCacheClientItem(
        CSsl3TlsClientContext *this,
        struct CSessionCacheClientItem **a2)
{
  *a2 = (struct CSessionCacheClientItem *)*((_QWORD *)this + 165);
}

//----- (0000000180018320) ----------------------------------------------------
void __fastcall CSslContext::GetCacheClientItem(CSslContext *this, struct CSessionCacheClientItem **a2)
{
  *a2 = 0i64;
}

//----- (0000000180018330) ----------------------------------------------------
void __fastcall CSsl3TlsServerContext::GetCacheServerItem(
        CSsl3TlsServerContext *this,
        struct CSessionCacheServerItem **a2)
{
  *a2 = (struct CSessionCacheServerItem *)*((_QWORD *)this + 124);
}

//----- (0000000180018350) ----------------------------------------------------
void __fastcall CSslContext::GetCacheServerItem(CSslContext *this, struct CSessionCacheServerItem **a2)
{
  *a2 = 0i64;
}

//----- (0000000180018360) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::GetCertOcspInfo(
        CSsl3TlsClientContext *this,
        unsigned __int8 **a2,
        unsigned int *a3)
{
  __int64 v3; // r9

  v3 = *((_QWORD *)this + 165);
  *a3 = *(_DWORD *)(v3 + 344);
  *a2 = *(unsigned __int8 **)(v3 + 336);
}

//----- (0000000180018390) ----------------------------------------------------
void __fastcall CSslContext::GetCertOcspInfo(CSslContext *this, unsigned __int8 **a2, unsigned int *a3)
{
  *a2 = 0i64;
  *a3 = 0;
}

//----- (00000001800183B0) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::GetCertSerialChain(
        CSsl3TlsClientContext *this,
        const unsigned __int8 **a2,
        unsigned int *a3)
{
  __int64 v3; // r9

  v3 = *((_QWORD *)this + 165);
  *a3 = *(_DWORD *)(v3 + 360);
  *a2 = *(const unsigned __int8 **)(v3 + 352);
}

//----- (00000001800183E0) ----------------------------------------------------
void __fastcall CSslContext::GetCertSerialChain(CSslContext *this, const unsigned __int8 **a2, unsigned int *a3)
{
  *a2 = 0i64;
  *a3 = 0;
}

//----- (0000000180018400) ----------------------------------------------------
unsigned __int64 __fastcall CSsl3TlsClientContext::GetClientEphemeralKey(CSsl3TlsClientContext *this)
{
  return *((_QWORD *)this + 128);
}

//----- (0000000180018420) ----------------------------------------------------
unsigned __int64 __fastcall CSslContext::GetClientEphemeralKey(CSslContext *this)
{
  return 0i64;
}

//----- (0000000180018430) ----------------------------------------------------
void __fastcall CSsl3TlsClientContext::GetEndpointBindings(
        CSsl3TlsClientContext *this,
        unsigned __int8 **a2,
        unsigned int *a3)
{
  __int64 v3; // r9

  v3 = *((_QWORD *)this + 165);
  *a2 = *(unsigned __int8 **)(v3 + 400);
  *a3 = *(_DWORD *)(v3 + 408);
}

//----- (0000000180018460) ----------------------------------------------------
void __fastcall CSslContext::GetEndpointBindings(CSslContext *this, unsigned __int8 **a2, unsigned int *a3)
{
  *a2 = 0i64;
  *a3 = 0;
}

//----- (0000000180018480) ----------------------------------------------------
unsigned __int64 __fastcall CSslContext::GetExporterMasterKey(CSslContext *this)
{
  return 0i64;
}

//----- (0000000180018490) ----------------------------------------------------
unsigned __int64 __fastcall CTls13ClientContext::GetExporterMasterKey(CTls13ClientContext *this)
{
  return *((_QWORD *)this + 183);
}

//----- (00000001800184B0) ----------------------------------------------------
unsigned __int64 __fastcall CTls13ServerContext::GetExporterMasterKey(CTls13ServerContext *this)
{
  return *((_QWORD *)this + 137);
}

//----- (00000001800184D0) ----------------------------------------------------
unsigned __int8 __fastcall CSslContext::GetIsKeyUpdateRequested(CSslContext *this)
{
  return 0;
}

//----- (00000001800184E0) ----------------------------------------------------
unsigned __int8 __fastcall CTls13ClientContext::GetIsKeyUpdateRequested(CTls13ClientContext *this)
{
  return *((_BYTE *)this + 1616);
}

//----- (00000001800184F0) ----------------------------------------------------
unsigned __int8 __fastcall CTls13ServerContext::GetIsKeyUpdateRequested(CTls13ServerContext *this)
{
  return *((_BYTE *)this + 1248);
}

//----- (0000000180018500) ----------------------------------------------------
struct _SEC_PRESHAREDKEY_IDENTITY *__fastcall CSsl3TlsContext::GetPSKExchangeValue(CSsl3TlsContext *this)
{
  return (struct _SEC_PRESHAREDKEY_IDENTITY *)*((_QWORD *)this + 108);
}

//----- (0000000180018520) ----------------------------------------------------
struct _SEC_PRESHAREDKEY_IDENTITY *__fastcall CSslContext::GetPSKExchangeValue(CSslContext *this)
{
  return 0i64;
}

//----- (0000000180018530) ----------------------------------------------------
void __fastcall CSslContext::GetReadWriteKeys(CSslContext *this, unsigned __int64 *a2, unsigned __int64 *a3)
{
  *a2 = *((_QWORD *)this + 18);
  *a3 = *((_QWORD *)this + 19);
}

//----- (0000000180018550) ----------------------------------------------------
unsigned __int8 __fastcall CSsl3TlsContext::GetRenegoInfoExtPresent(CSsl3TlsContext *this)
{
  return *((_BYTE *)this + 554);
}

//----- (0000000180018560) ----------------------------------------------------
unsigned __int8 __fastcall CSslContext::GetRenegoInfoExtPresent(CSslContext *this)
{
  return 0;
}

//----- (0000000180018570) ----------------------------------------------------
void *__fastcall CSslScratchAllocator::GetScratchBuffer(CSslScratchAllocator *this)
{
  return (void *)*((_QWORD *)this + 1);
}

//----- (0000000180018580) ----------------------------------------------------
struct _SecPkgContext_ApplicationProtocol *__fastcall CSsl3TlsContext::GetSelectedApplicationProtocol(
        CSsl3TlsContext *this)
{
  return (struct _SecPkgContext_ApplicationProtocol *)*((_QWORD *)this + 99);
}

//----- (00000001800185A0) ----------------------------------------------------
struct _SecPkgContext_ApplicationProtocol *__fastcall CSslContext::GetSelectedApplicationProtocol(CSslContext *this)
{
  return 0i64;
}

//----- (00000001800185B0) ----------------------------------------------------
struct _SecPkgContext_SrtpParameters *__fastcall CSsl3TlsContext::GetSelectedSrtpParameters(CSsl3TlsContext *this)
{
  return (struct _SecPkgContext_SrtpParameters *)*((_QWORD *)this + 101);
}

//----- (00000001800185D0) ----------------------------------------------------
struct _SecPkgContext_SrtpParameters *__fastcall CSslContext::GetSelectedSrtpParameters(CSslContext *this)
{
  return 0i64;
}

//----- (00000001800185E0) ----------------------------------------------------
struct _SecPkgContext_TokenBinding *__fastcall CSsl3TlsContext::GetSelectedTBParameters(CSsl3TlsContext *this)
{
  return (struct _SecPkgContext_TokenBinding *)*((_QWORD *)this + 103);
}

//----- (0000000180018600) ----------------------------------------------------
struct _SecPkgContext_TokenBinding *__fastcall CSslContext::GetSelectedTBParameters(CSslContext *this)
{
  return 0i64;
}

//----- (0000000180018610) ----------------------------------------------------
unsigned __int64 __fastcall CSsl3TlsClientContext::GetServerPublicKey(CSsl3TlsClientContext *this)
{
  return *((_QWORD *)this + 127);
}

//----- (0000000180018630) ----------------------------------------------------
unsigned __int64 __fastcall CSslContext::GetServerPublicKey(CSslContext *this)
{
  return 0i64;
}

//----- (0000000180018640) ----------------------------------------------------
const unsigned __int16 *__fastcall CSsl3TlsClientContext::GetTargetName(CSsl3TlsClientContext *this)
{
  return (const unsigned __int16 *)*((_QWORD *)this + 166);
}

//----- (0000000180018660) ----------------------------------------------------
const unsigned __int16 *__fastcall CSslContext::GetTargetName(CSslContext *this)
{
  return 0i64;
}

//----- (0000000180018670) ----------------------------------------------------
struct _SecPkgContext_KeyingMaterial *__fastcall CSsl3TlsContext::GetTokenBindingEKM(CSsl3TlsContext *this)
{
  return (struct _SecPkgContext_KeyingMaterial *)*((_QWORD *)this + 104);
}

//----- (0000000180018690) ----------------------------------------------------
struct _SecPkgContext_KeyingMaterial *__fastcall CSslContext::GetTokenBindingEKM(CSslContext *this)
{
  return 0i64;
}

//----- (00000001800186A0) ----------------------------------------------------
void __fastcall CSslContext::GetUniqueBindings(CSslContext *this, unsigned __int8 **a2, unsigned int *a3)
{
  *a2 = 0i64;
  *a3 = 0;
}

//----- (00000001800186C0) ----------------------------------------------------
__int64 __fastcall CSslContext::ImportApplicationTrafficSecret(
        CSslContext *this,
        __int64 a2,
        __int64 a3,
        unsigned __int8 *a4)
{
  return 0i64;
}

//----- (00000001800186D0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::Initialize(CSsl3TlsContext *this)
{
  return 0i64;
}

//----- (00000001800186E0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::ParseCcsRecord(CSsl3TlsContext *this, unsigned __int8 *const a2)
{
  return 0i64;
}

//----- (00000001800186F0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsContext::ReturnGenericExtensions(CSsl3TlsContext *this)
{
  return 0i64;
}

//----- (0000000180018710) ----------------------------------------------------
__int64 __fastcall CSslContext::SetApplicationProtocols(CSslContext *this, struct _SecBuffer *const a2)
{
  return 0i64;
}

//----- (0000000180018720) ----------------------------------------------------
__int64 __fastcall CSslContext::SetClientEphemeralKey(CSslContext *this)
{
  return 120i64;
}

//----- (0000000180018730) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::SetClientShare(CSsl3TlsServerContext *this)
{
  return 0i64;
}

//----- (0000000180018740) ----------------------------------------------------
__int64 __fastcall CSslContext::SetGenericExtensionBuffers(
        CSslContext *this,
        struct _SecBufferDesc *const a2,
        struct _SecBuffer *const a3)
{
  return 0i64;
}

//----- (0000000180018760) ----------------------------------------------------
void __fastcall CTls13ClientContext::SetIsKeyUpdateRequested(CTls13ClientContext *this, char a2)
{
  *((_BYTE *)this + 1616) = a2;
}

//----- (0000000180018770) ----------------------------------------------------
void __fastcall CTls13ServerContext::SetIsKeyUpdateRequested(CTls13ServerContext *this, char a2)
{
  *((_BYTE *)this + 1248) = a2;
}

//----- (0000000180018780) ----------------------------------------------------
__int64 __fastcall CSslContext::SetPMTU(CSslContext *this, struct _SecBuffer *const a2)
{
  return 0i64;
}

//----- (0000000180018790) ----------------------------------------------------
__int64 __fastcall CSslContext::SetPSKParameters(
        CSslContext *this,
        struct _SecBuffer *const a2,
        struct _SecBuffer *const a3)
{
  return 0i64;
}

//----- (00000001800187A0) ----------------------------------------------------
void __fastcall CSsl3TlsContext::SetRenegoInfoExtPresent(CSsl3TlsContext *this, char a2)
{
  *((_BYTE *)this + 554) = a2;
}

//----- (00000001800187C0) ----------------------------------------------------
__int64 __fastcall CSslContext::SetServerPublicKey(CSslContext *this)
{
  return 120i64;
}

//----- (00000001800187D0) ----------------------------------------------------
__int64 __fastcall CSslContext::SetSrtpParameters(
        CSslContext *this,
        struct _SecBuffer *const a2,
        struct _SecBuffer *const a3)
{
  return 0i64;
}

//----- (00000001800187E0) ----------------------------------------------------
__int64 __fastcall CSslContext::SetTBParameters(CSslContext *this, struct _SecBuffer *const a2)
{
  return 0i64;
}

//----- (00000001800187F0) ----------------------------------------------------
__int64 __fastcall CSslContext::SetTrafficSecretsBuffers(CSslContext *this, struct _SecBufferDesc *const a2)
{
  return 0i64;
}

//----- (0000000180018800) ----------------------------------------------------
unsigned __int8 __fastcall CSslContext::UseSchannelRecordLayer(CSslContext *this)
{
  return 1;
}

//----- (0000000180018810) ----------------------------------------------------
__int64 __fastcall CSslContext::GenerateRsaCkeParameterList(
        CSslContext *this,
        struct _BCryptBufferDesc *a2,
        unsigned __int8 *a3,
        unsigned int *a4)
{
  return 120i64;
}

//----- (0000000180018820) ----------------------------------------------------
__int64 __fastcall CSslContext::GetClientAuthResults(CSslContext *this, unsigned __int64 *a2, int *a3)
{
  __int64 result; // rax

  *a2 = 0i64;
  result = 2148074242i64;
  *a3 = 0;
  return result;
}

//----- (0000000180018840) ----------------------------------------------------
__int64 CSessionCacheClientItem::GetCacheItemType()
{
  return 1i64;
}

//----- (0000000180018850) ----------------------------------------------------
__int64 CSessionCacheServerItem::GetCacheItemType()
{
  return 2i64;
}

//----- (0000000180018860) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::GetClientAuthResults(
        CSsl3TlsServerContext *this,
        unsigned __int64 *a2,
        int *a3)
{
  __int64 result; // rax

  *a2 = *(_QWORD *)(*((_QWORD *)this + 124) + 344i64);
  result = 0i64;
  *a3 = *(_DWORD *)(*((_QWORD *)this + 124) + 352i64);
  return result;
}

//----- (0000000180018890) ----------------------------------------------------
__int64 __fastcall CNulRecord::SetMaxFragment(CNulRecord *this)
{
  return 0i64;
}

//----- (00000001800188A0) ----------------------------------------------------
__int64 __fastcall CTls13ClientHandshake::ComputeStatusRequestExtensionSize(CTls13ClientHandshake *this)
{
  *((_WORD *)this + 76) = 5;
  return 0i64;
}

//----- (00000001800188C0) ----------------------------------------------------
unsigned __int8 __fastcall CSsl3TlsContext::IsWaitingForCCS(CSsl3TlsContext *this)
{
  return 0;
}

//----- (00000001800188D0) ----------------------------------------------------
void __fastcall PacReadFcn(_DWORD *state, char **pbuffer, unsigned int *psize)
{
  *pbuffer = *(char **)state;
  *(_QWORD *)state += *psize;
  state[2] -= *psize;
}

//----- (0000000180018910) ----------------------------------------------------
void __fastcall _DbgpTraceTimerCallback(struct _DBG_TRACE_CONTROL_BLOCK *a1)
{
  union _LARGE_INTEGER *v2; // rbx
  union _LARGE_INTEGER *v3; // rcx
  struct _RTL_CRITICAL_SECTION *v4; // rdi

  if ( !*((_DWORD *)a1 + 7) )
  {
    v2 = (union _LARGE_INTEGER *)((char *)a1 + 24);
    RegSetValueExW(*((HKEY *)a1 + 21), *((LPCWSTR *)a1 + 23), 0, 4u, (const BYTE *)a1 + 24, 4u);
    v3 = v2;
LABEL_6:
    NtQuerySystemTime(v3);
    return;
  }
  if ( *((_DWORD *)a1 + 7) == -1 )
  {
    v4 = (struct _RTL_CRITICAL_SECTION *)((char *)a1 + 192);
    EnterCriticalSection((LPCRITICAL_SECTION)((char *)a1 + 192));
    _DbgpControlTracing(a1, *((_DWORD *)a1 + 6), 0);
    LeaveCriticalSection(v4);
    v3 = (union _LARGE_INTEGER *)((char *)a1 + 24);
    goto LABEL_6;
  }
}

//----- (0000000180018960) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::ProcessHandshake(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        int *a4)
{
  int v8; // eax
  int v9; // esi
  unsigned int v10; // r13d
  int v11; // r9d
  unsigned __int8 *v12; // r12
  unsigned __int8 v13; // dl
  unsigned int v14; // eax
  unsigned int ServerMasterKey; // edi
  CCipherMill *v17; // rcx
  __int64 v18; // rcx
  int v19; // eax
  __int64 v20; // rdx
  CCipherMill *v21; // rcx
  int v22; // eax
  char v23; // [rsp+70h] [rbp+8h] BYREF
  unsigned __int8 v24; // [rsp+80h] [rbp+18h]

  v8 = 4;
  if ( *((_BYTE *)this + 233) )
    v8 = 12;
  v9 = 0;
  v10 = a3 - v8;
  v11 = *a2 << 16;
  *a4 = 0;
  v12 = &a2[v8];
  v13 = 1;
  v14 = v11 | *((unsigned __int16 *)this + 34);
  v23 = 0;
  v24 = 1;
  if ( v14 == 0x10000 )
  {
LABEL_10:
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 12i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      v13 = v24;
    }
    ServerMasterKey = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, unsigned __int8 *, _QWORD, _QWORD, char *))(*(_QWORD *)this + 536i64))(
                        this,
                        a2,
                        a3,
                        v13,
                        &v23);
    if ( !ServerMasterKey )
    {
      LOBYTE(v9) = v23 != 0;
      *((_DWORD *)this + 17) = v9 + 93;
    }
    *((_BYTE *)this + 552) = 0;
    return ServerMasterKey;
  }
  if ( v14 == 1310785 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 21i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
    ServerMasterKey = CSsl3TlsContext::DigestFinish(this, v12, v10);
    if ( !ServerMasterKey )
    {
      (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 448i64))(this);
      *a4 = 1;
    }
    return ServerMasterKey;
  }
  if ( v14 > 0x100046 )
  {
    switch ( v14 )
    {
      case 0x14003Fu:
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
        ServerMasterKey = CSsl3TlsContext::DigestFinish(this, v12, v10);
        if ( !ServerMasterKey )
          *((_DWORD *)this + 17) = 95;
        return ServerMasterKey;
      case 0x10004Bu:
        goto LABEL_19;
      case 0x170046u:
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
        return (unsigned int)CSsl3TlsServerContext::DigestSupplementalDataMsg(this, v12, v10);
    }
LABEL_40:
    if ( (*((_DWORD *)this + 16) & 0xF3FC0) != 0 )
    {
      *((_DWORD *)this + 17) = 96;
      *((_WORD *)this + 48) = 2562;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x17u,
        (__int64)&WPP_095c39149c3f336b5b94efe855075ae2_Traceguids,
        v11,
        *((unsigned __int16 *)this + 34));
    return (unsigned int)-2146893018;
  }
  if ( v14 == 1048646 )
  {
LABEL_19:
    v17 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 13i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      v17 = WPP_GLOBAL_Control;
    }
    if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) != 4 )
    {
      if ( *((_DWORD *)this + 17) != 70 || (*((_DWORD *)this + 34) & 0x100i64) == 0 )
        goto LABEL_25;
      if ( v17 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v17 + 28) & 1) == 0 )
        return (unsigned int)-2146893018;
      v20 = 14i64;
LABEL_84:
      WPP_SF_(*((_QWORD *)v17 + 2), v20, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      return (unsigned int)-2146893018;
    }
    if ( *((_QWORD *)this + 106) )
    {
LABEL_25:
      ServerMasterKey = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, unsigned __int8 *, _QWORD, _QWORD))(*(_QWORD *)this + 504i64))(
                          this,
                          a2,
                          a3,
                          0i64);
      if ( !ServerMasterKey )
      {
        *a4 = 1;
        *((_QWORD *)this + 17) |= 0x8000ui64;
        v18 = *((_QWORD *)this + 1);
        v19 = *(_DWORD *)(v18 + 48);
        switch ( v19 )
        {
          case 3:
            ServerMasterKey = CSsl3TlsServerContext::EccGenerateServerMasterKey(this, v12, v10);
            break;
          case 2:
            ServerMasterKey = CSsl3TlsServerContext::DhGenerateServerMasterKey(this, v12, v10);
            break;
          case 4:
            ServerMasterKey = MakeEccDhPskSessionKeysHelper(this, 0i64, 0i64, 1);
            break;
          default:
            v22 = *(_DWORD *)(v18 + 52);
            if ( v22 == 2 )
              ServerMasterKey = CSslContext::I_RsaGenerateServerMasterKey(this, v12, v10);
            else
              ServerMasterKey = v22 == 4
                              ? CSslContext::I_RsaGenerateEcdsaSignServerMasterKey(this, v12, v10)
                              : -2146893048;
            break;
        }
        if ( !ServerMasterKey )
          *((_DWORD *)this + 17) = 61;
      }
      return ServerMasterKey;
    }
    ServerMasterKey = CSsl3TlsContext::SetPSKExchangeValue(this, v12, v10, 0);
    if ( !ServerMasterKey )
    {
      if ( *((_BYTE *)this + 233) )
        *((_BYTE *)this + 232) = 1;
      ServerMasterKey = 590624;
      *a4 = 1;
    }
    return ServerMasterKey;
  }
  if ( v14 == 65612 )
  {
    v21 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      v21 = WPP_GLOBAL_Control;
    }
    if ( CSslGlobals::m_fDisableRenegoOnServer )
    {
      ServerMasterKey = -2146893018;
      if ( v21 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v21 + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)v21 + 2), 11i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      return ServerMasterKey;
    }
    CSchannelTelemetryContext::LogRenegoStart(*((_QWORD *)this + 15), 1, *((_QWORD *)this + 17));
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 240i64))(this);
    *((_QWORD *)this + 17) &= ~0x40000000ui64;
    v13 = 0;
    *((_QWORD *)this + 11) = 0i64;
    v24 = 0;
    goto LABEL_10;
  }
  if ( v14 != 720966 )
  {
    if ( v14 == 983101 )
    {
      v17 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 19i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
        v17 = WPP_GLOBAL_Control;
      }
      if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) == 4 )
      {
        if ( v17 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v17 + 28) & 1) == 0 )
          return (unsigned int)-2146893018;
        v20 = 20i64;
        goto LABEL_84;
      }
      ServerMasterKey = CSsl3TlsServerContext::DigestCertVerify(this, v12, v10);
      if ( !ServerMasterKey )
      {
        ServerMasterKey = DoCertificateMapping(this);
        *((_DWORD *)this + 17) = 62;
      }
      return ServerMasterKey;
    }
    if ( v14 == 1048636 )
      goto LABEL_19;
    goto LABEL_40;
  }
  v17 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 16i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
    v17 = WPP_GLOBAL_Control;
  }
  if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) == 4 )
  {
    if ( v17 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v17 + 28) & 1) == 0 )
      return (unsigned int)-2146893018;
    v20 = 17i64;
    goto LABEL_84;
  }
  if ( (*((_DWORD *)this + 34) & 0x100i64) == 0 )
  {
    if ( v17 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v17 + 28) & 1) == 0 )
      return (unsigned int)-2146893018;
    v20 = 18i64;
    goto LABEL_84;
  }
  ServerMasterKey = CSsl3TlsContext::DigestRemoteCertificate(this, v12, v10);
  if ( !ServerMasterKey )
    *((_DWORD *)this + 17) = 60;
  return ServerMasterKey;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800927C0: using guessed type int CSslGlobals::m_fDisableRenegoOnServer;

//----- (0000000180018BD0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::EccGenerateServerMasterKey(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned int a3)
{
  __int64 v3; // rax
  struct _BCRYPT_ECCKEY_BLOB *v7; // rbx
  unsigned __int64 v8; // r13
  size_t v9; // r14
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rax
  void *v12; // rsp
  size_t v13; // rdx
  unsigned __int8 *v14; // rcx
  int EccPublicKeyBlob; // esi
  __int64 *v16; // rcx
  __int64 v17; // rax
  ULONG dwMagic; // esi
  __int64 *v19; // rax
  __int64 v20; // rcx
  unsigned int EccDhPskSessionKeysHelper; // esi
  struct _BCRYPT_ECCKEY_BLOB *v23; // rax
  __int64 *v24; // rax
  __int64 v25; // rcx
  unsigned __int8 v26; // r9
  int v27; // edx
  __int64 v28; // [rsp+0h] [rbp-30h] BYREF
  unsigned __int64 v29; // [rsp+30h] [rbp+0h] BYREF
  __int64 v30[5]; // [rsp+38h] [rbp+8h] BYREF

  v3 = *((_QWORD *)this + 120);
  v29 = 0i64;
  v7 = 0i64;
  v8 = *(unsigned int *)(v3 + 24);
  if ( !(_DWORD)v8 )
    goto LABEL_31;
  v9 = (unsigned int)v8;
  if ( v8 > g_ulMaxStackAllocSize )
    goto LABEL_31;
  v10 = v8 + g_ulAdditionalProbeSize + 8;
  if ( v10 < v8 || !(unsigned int)VerifyStackAvailable(v10) )
    goto LABEL_31;
  v11 = (unsigned int)(v8 + 8) + 15i64;
  if ( v11 <= (unsigned int)(v8 + 8) )
    v11 = 0xFFFFFFFFFFFFFF0i64;
  v12 = alloca(v11 & 0xFFFFFFFFFFFFFFF0ui64);
  v7 = (struct _BCRYPT_ECCKEY_BLOB *)&v29;
  if ( &v28 == (__int64 *)-48i64 || (LODWORD(v29) = 1801679955, (v7 = (struct _BCRYPT_ECCKEY_BLOB *)v30) == 0i64) )
  {
LABEL_31:
    if ( (int)v8 + 8 >= (unsigned int)v8 )
    {
      v23 = (struct _BCRYPT_ECCKEY_BLOB *)((__int64 (__fastcall *)(_QWORD))g_pfnAllocate)((unsigned int)(v8 + 8));
      if ( !v23 )
        goto LABEL_36;
      v23->dwMagic = 1885431112;
      v7 = v23 + 1;
    }
    if ( v7 )
    {
      v9 = v8;
      goto LABEL_9;
    }
LABEL_36:
    EccDhPskSessionKeysHelper = 14;
    goto LABEL_28;
  }
LABEL_9:
  memset_0(v7, 0, v9);
  *v7 = **(struct _BCRYPT_ECCKEY_BLOB **)(*((_QWORD *)this + 120) + 16i64);
  if ( !a2 || a3 <= 2 )
  {
    EccDhPskSessionKeysHelper = -2146893048;
    goto LABEL_25;
  }
  v13 = *a2;
  v14 = a2 + 1;
  if ( (_DWORD)v13 + 1 != a3 || !*a2 )
  {
    EccDhPskSessionKeysHelper = -2146893048;
    goto LABEL_49;
  }
  if ( a2 == (unsigned __int8 *)-1i64 )
    goto LABEL_47;
  if ( (*((_BYTE *)this + 20) & 8) != 0 )
  {
    EccPublicKeyBlob = MontgomeryGetEccPublicKeyBlob(v14, v13, v7, v8);
  }
  else
  {
    EccPublicKeyBlob = 0;
    if ( *v14 == 4 && v13 + 7 <= v9 )
      memcpy_0(&v7[1], v14 + 1, (unsigned int)(v13 - 1));
    else
      EccPublicKeyBlob = -2146893048;
  }
  if ( EccPublicKeyBlob )
  {
LABEL_47:
    EccDhPskSessionKeysHelper = 1359;
LABEL_49:
    v26 = 50;
    v27 = 702;
    goto LABEL_50;
  }
  v16 = (__int64 *)*((_QWORD *)this + 1);
  v17 = v16[106];
  if ( v17 && *(_BYTE *)(v17 + 24) )
  {
    dwMagic = v7->dwMagic;
    v7->dwMagic = *((_DWORD *)this + 4);
    v19 = (__int64 *)*((_QWORD *)this + 1);
    if ( v19 )
      v20 = *v19;
    else
      v20 = 0i64;
    if ( !(unsigned int)SslImportKey(v20, &v29, L"SSLECCPUBLICBLOB", v7, v8, 0) )
      goto LABEL_24;
    v7->dwMagic = dwMagic;
    v24 = (__int64 *)*((_QWORD *)this + 1);
    if ( v24 )
    {
      v25 = *v24;
      goto LABEL_45;
    }
  }
  else if ( v16 )
  {
    v25 = *v16;
    goto LABEL_45;
  }
  v25 = 0i64;
LABEL_45:
  EccDhPskSessionKeysHelper = SslImportKey(v25, &v29, L"ECCPUBLICBLOB", v7, v8, 0);
  if ( EccDhPskSessionKeysHelper )
  {
    v26 = 51;
    v27 = 703;
LABEL_50:
    CSslContext::SetErrorAndFatalAlert((__int64)this, v27, EccDhPskSessionKeysHelper, v26);
    goto LABEL_25;
  }
LABEL_24:
  EccDhPskSessionKeysHelper = MakeEccDhPskSessionKeysHelper(this, *(_QWORD *)(*((_QWORD *)this + 120) + 8i64), v29, 1);
LABEL_25:
  if ( v7 && v7[-1].dwMagic == 1885431112 )
    ((void (__fastcall *)(struct _BCRYPT_ECCKEY_BLOB *))g_pfnFree)(&v7[-1]);
LABEL_28:
  if ( v29 )
    SslFreeObject(v29, 0i64);
  return EccDhPskSessionKeysHelper;
}
// 180082258: using guessed type wchar_t aSsleccpublicbl[17];
// 1800920E0: using guessed type __int64 g_ulMaxStackAllocSize;
// 1800920E8: using guessed type __int64 g_ulAdditionalProbeSize;
// 1800920F0: using guessed type __int64 g_pfnAllocate;
// 1800920F8: using guessed type __int64 g_pfnFree;
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);
// 1800985A0: using guessed type __int64 __fastcall SslImportKey(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);

//----- (0000000180018E08) ----------------------------------------------------
bool __fastcall CEphemKeyData::Reference(const FILETIME *this)
{
  struct _FILETIME SystemTimeAsFileTime; // [rsp+30h] [rbp+8h] BYREF

  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  _InterlockedIncrement((volatile signed __int32 *)&this[3].dwHighDateTime);
  return CompareFileTime(&SystemTimeAsFileTime, this + 4) < 0;
}

//----- (0000000180018E50) ----------------------------------------------------
unsigned __int64 __fastcall CCipherMill::GetAProvider(CCipherMill *this)
{
  unsigned __int64 v1; // rbx
  CCipherMill *v2; // rcx
  unsigned __int64 v4; // [rsp+30h] [rbp+8h] BYREF

  v1 = 0i64;
  v4 = 0i64;
  RtlAcquireResourceShared(&Resource, 1u);
  if ( qword_1800924A0[0] )
  {
    CCipherMill::ReferenceProvider(v2, qword_1800924A0[0], &v4);
    v1 = v4;
  }
  RtlReleaseResource(&Resource);
  return v1;
}
// 180018E87: variable 'v2' is possibly undefined
// 1800924A0: using guessed type unsigned __int64 qword_1800924A0[32];

//----- (0000000180018EB4) ----------------------------------------------------
CEphemKeyData *__fastcall CEphemKeyData::CEphemKeyData(CEphemKeyData *this, unsigned int a2)
{
  __int64 v3; // rbx
  struct _FILETIME SystemTimeAsFileTime; // [rsp+30h] [rbp+8h] BYREF

  *((_DWORD *)this + 7) = 1;
  *(_QWORD *)this = &CEphemKeyData::`vftable';
  v3 = a2;
  *((_QWORD *)this + 1) = 0i64;
  *((_QWORD *)this + 2) = 0i64;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 10) = 0;
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  *((_QWORD *)this + 4) = v3 + *(_QWORD *)&SystemTimeAsFileTime;
  return this;
}
// 18007C270: using guessed type void *CEphemKeyData::`vftable';

//----- (0000000180018F20) ----------------------------------------------------
CEphemKeyData *__fastcall CEphemKeyData::`vector deleting destructor'(CEphemKeyData *this, char a2)
{
  CEphemKeyData::~CEphemKeyData(this);
  if ( (a2 & 1) != 0 )
    SPExternalFree(this);
  return this;
}

//----- (0000000180018F58) ----------------------------------------------------
void __fastcall CEphemKeyData::~CEphemKeyData(CEphemKeyData *this)
{
  __int64 v2; // rcx
  void *v3; // rdi

  *(_QWORD *)this = &CEphemKeyData::`vftable';
  v2 = *((_QWORD *)this + 1);
  if ( v2 )
    SslFreeObject(v2, 0i64);
  v3 = (void *)*((_QWORD *)this + 2);
  if ( v3 )
  {
    memset(v3, 0, *((unsigned int *)this + 6));
    SPExternalFree(*((void **)this + 2));
  }
  *(_QWORD *)this = &IAllocate::`vftable';
}
// 18007C270: using guessed type void *CEphemKeyData::`vftable';
// 18007C298: using guessed type void *IAllocate::`vftable';
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180018FC0) ----------------------------------------------------
CSessionCacheServerItem *__fastcall CSessionCacheServerItem::`vector deleting destructor'(
        CSessionCacheServerItem *this,
        char a2)
{
  void *v4; // rcx

  *(_QWORD *)this = &CSessionCacheServerItem::`vftable';
  v4 = (void *)*((_QWORD *)this + 43);
  if ( v4 )
    NtClose(v4);
  *(_QWORD *)this = &CSessionCacheItem::`vftable';
  CSessionCacheItem::ClearState(this);
  if ( !*((_DWORD *)this + 17) )
    RtlDeleteResource((PRTL_RESOURCE)((char *)this + 72));
  *(_QWORD *)this = &IAllocate::`vftable';
  if ( (a2 & 1) != 0 )
    (*(void (__fastcall **)(struct IAllocate *, CSessionCacheServerItem *))(*(_QWORD *)CSessionCacheServerItem::m_pServerCacheLookaside
                                                                          + 32i64))(
      CSessionCacheServerItem::m_pServerCacheLookaside,
      this);
  return this;
}
// 18007C298: using guessed type void *IAllocate::`vftable';
// 18007C2C0: using guessed type void *CSessionCacheItem::`vftable';
// 18007C330: using guessed type void *CSessionCacheServerItem::`vftable';
// 1800927F8: using guessed type struct IAllocate *CSessionCacheServerItem::m_pServerCacheLookaside;

//----- (0000000180019060) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::AllocateAndGenerateNstCcsAndFinish(
        CSsl3TlsServerContext *this,
        struct SPBuffer *a2)
{
  char v2; // r10
  unsigned int v5; // edi
  unsigned __int8 *v6; // rbp
  unsigned __int16 v7; // r12
  unsigned int v8; // r14d
  int v9; // r13d
  __int16 v10; // r9
  int v11; // r8d
  unsigned int v12; // ecx
  unsigned int v13; // r8d
  int v14; // ecx
  int v15; // eax
  unsigned int v16; // ecx
  unsigned int v17; // r9d
  _BYTE *v18; // r15
  unsigned int v19; // eax
  unsigned int CcsAndFinishMessage; // edi
  int v22; // edi
  unsigned int v23; // edi
  bool v24; // zf
  unsigned int v25; // edi
  unsigned int v26; // ecx
  _BYTE *Memory; // rax
  unsigned int v28; // r12d
  __int16 v29; // cx
  unsigned __int16 v30; // [rsp+70h] [rbp+8h] BYREF
  unsigned int v31; // [rsp+80h] [rbp+18h] BYREF
  unsigned __int8 *v32; // [rsp+88h] [rbp+20h] BYREF

  v2 = *((_BYTE *)this + 233);
  v5 = 0;
  v6 = 0i64;
  v7 = 0;
  v31 = 0;
  v32 = 0i64;
  v30 = 0;
  if ( v2 )
  {
    v8 = 13;
    goto LABEL_3;
  }
  v8 = 5;
  if ( (*((_BYTE *)this + 32) & 4) == 0 )
  {
LABEL_3:
    v9 = 0;
    goto LABEL_4;
  }
  v9 = *((_DWORD *)this + 11);
LABEL_4:
  if ( (*((_DWORD *)this + 34) & 0x400000) != 0 )
  {
    CcsAndFinishMessage = CSsl3TlsServerContext::SerializeAndProtectSessionState(this, (HLOCAL *)&v32, &v30);
    if ( CcsAndFinishMessage )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          53i64,
          &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids,
          CcsAndFinishMessage);
      v6 = v32;
      goto LABEL_22;
    }
    v2 = *((_BYTE *)this + 233);
    v22 = 18;
    v7 = v30;
    if ( !v2 )
      v22 = 10;
    v23 = v30 + v22;
    v24 = (*((_BYTE *)this + 32) & 4) == 0;
    v31 = v23;
    if ( !v24 )
    {
      v25 = *((_DWORD *)this + 12) + v23;
      v26 = *((_DWORD *)this + 13);
      if ( v26 )
      {
        if ( (*((_BYTE *)this + 56) & 1) != 0 )
          v26 -= v25 % v26;
        v25 += v26;
      }
      v23 = *((_DWORD *)this + 11) + v25;
    }
    v5 = *((_DWORD *)this + 15) + v23;
    v6 = v32;
  }
  v10 = *((_WORD *)this + 16);
  v11 = 1;
  if ( (v10 & 4) != 0 )
  {
    v12 = *((_DWORD *)this + 13);
    v13 = *((_DWORD *)this + 12) + 1;
    if ( v12 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v12 -= v13 % v12;
      v13 += v12;
    }
    v11 = *((_DWORD *)this + 11) + v13;
  }
  if ( (*((_BYTE *)this + 64) & 0x30) != 0 )
  {
    v14 = 48;
    v15 = 40;
  }
  else
  {
    v14 = 24;
    v15 = 16;
  }
  if ( !v2 )
    v14 = v15;
  if ( (v10 & 1) != 0 )
  {
    v16 = *((_DWORD *)this + 12) + v14;
    v17 = *((_DWORD *)this + 13);
    if ( v17 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v17 -= v16 % v17;
      v16 += v17;
    }
    v14 = *((_DWORD *)this + 11) + v16;
  }
  v18 = (_BYTE *)*((_QWORD *)a2 + 1);
  v19 = v5 + v14 + v11 + 2 * *((_DWORD *)this + 15);
  if ( v18 )
  {
    if ( *(_DWORD *)a2 < v19 )
    {
      *((_DWORD *)a2 + 1) = v19;
      CcsAndFinishMessage = -2146893023;
      goto LABEL_22;
    }
  }
  else
  {
    *(_DWORD *)a2 = v19;
    Memory = CSslContext::GetMemory(this, v19);
    *((_QWORD *)a2 + 1) = Memory;
    v18 = Memory;
    if ( !Memory )
    {
      CcsAndFinishMessage = 14;
      goto LABEL_22;
    }
  }
  *((_DWORD *)a2 + 1) = 0;
  if ( (*((_DWORD *)this + 34) & 0x400000) == 0 )
  {
LABEL_21:
    CcsAndFinishMessage = CSsl3TlsContext::GenerateCcsAndFinishMessage(this, a2);
    goto LABEL_22;
  }
  CSsl3TlsServerContext::GenerateNewSessionTicket(this, v6, v7, &v18[v8 + v9], &v31);
  v28 = v31;
  CcsAndFinishMessage = CSsl3TlsServerContext::UpdateHashAndWrapMessage(
                          this,
                          (__int64)&v18[v8 + v9],
                          v31,
                          (__int64)a2,
                          1011,
                          964);
  if ( !CcsAndFinishMessage )
  {
    if ( *((_BYTE *)this + 233) )
    {
      *((_DWORD *)a2 + 1) += v8 + v28;
      v29 = *((_WORD *)this + 17);
      v18[12] = v28;
      v18[11] = BYTE1(v28);
      v18[1] = HIBYTE(v29);
      v18[2] = v29;
      *v18 = 22;
    }
    goto LABEL_21;
  }
LABEL_22:
  if ( v6 )
    LocalFree(v6);
  return CcsAndFinishMessage;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800191DC) ----------------------------------------------------
void __fastcall CSsl3TlsServerContext::SetDowngradeProtection(CSsl3TlsServerContext *this)
{
  __int64 v1; // rax
  int v3; // r9d
  int v4; // ecx
  const unsigned __int8 near *v5; // rax
  bool v6; // cl
  bool v7; // al

  v1 = *((_QWORD *)this + 10);
  if ( v1 )
  {
    v3 = *(_DWORD *)(v1 + 152);
    v4 = *((_DWORD *)this + 16);
    if ( (v4 & 0x400) != 0 && (v3 & 0x1000) != 0 )
    {
      v5 = CSsl3TlsContext::m_rgbTls12Downgrade;
LABEL_4:
      *((_QWORD *)this + 41) = v5;
      return;
    }
    if ( *((_BYTE *)this + 233) )
    {
      v6 = (v4 & 0x40000) == 0;
      v7 = (v3 & 0x40000) != 0;
    }
    else
    {
      v6 = (v4 & 0x1400) == 0;
      v7 = (v3 & 0x1400) != 0;
    }
    if ( v6 && v7 )
    {
      v5 = CSsl3TlsContext::m_rgbTls11OrBelowDowngrade;
      goto LABEL_4;
    }
  }
}
// 180082BB8: using guessed type const unsigned __int8 near *const CSsl3TlsContext::m_rgbTls11OrBelowDowngrade;
// 180082BC0: using guessed type const unsigned __int8 near *const CSsl3TlsContext::m_rgbTls12Downgrade;

//----- (0000000180019220) ----------------------------------------------------
__int64 __fastcall CTlsExtServer::GetServerHelloExtensionsLength(
        CTlsExtServer *this,
        char a2,
        char a3,
        unsigned __int16 *a4)
{
  unsigned int v6; // ecx
  __int64 v8; // r9
  __int64 v9; // rax
  _DWORD *v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rax
  _DWORD *v13; // r8
  unsigned int v14; // ecx
  unsigned int v15; // edx

  v6 = *((_DWORD *)this + 5);
  if ( !v6 )
  {
    v8 = *((_QWORD *)this + 1);
    if ( *(_BYTE *)(v8 + 922) )
    {
      v6 = 6;
      *((_BYTE *)this + 25) = 1;
      *((_DWORD *)this + 5) = 6;
    }
    if ( a2 )
    {
      v6 += 4;
      *((_BYTE *)this + 24) = 1;
      *((_DWORD *)this + 5) = v6;
    }
    if ( (*(_DWORD *)(v8 + 136) & 0x400000) != 0 )
      *((_DWORD *)this + 5) = v6 + 4;
    v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 88i64))(v8);
    if ( v9 && *(_DWORD *)v9 == 1 && *(_DWORD *)(v9 + 4) == 2 )
      *((_DWORD *)this + 5) += *(unsigned __int8 *)(v9 + 8) + 7;
    v10 = (_DWORD *)*((_QWORD *)this + 1);
    if ( (v10[34] & 0x8000000) != 0 )
      *((_DWORD *)this + 5) += 4;
    v11 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v10 + 96i64))(v10);
    if ( v11 )
      *((_DWORD *)this + 5) += *(unsigned __int8 *)(v11 + 2) + 9;
    v12 = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 1) + 104i64))(*((_QWORD *)this + 1));
    if ( v12 )
      *((_DWORD *)this + 5) += *(unsigned __int8 *)(v12 + 2) + 7;
    v13 = (_DWORD *)*((_QWORD *)this + 1);
    v6 = *((_DWORD *)this + 5);
    if ( a3 )
    {
      v14 = v6 + 5;
      *((_BYTE *)this + 26) = 1;
      *((_DWORD *)this + 5) = v14;
      v15 = v14 + v13[104];
      *((_DWORD *)this + 5) = v15;
      v6 = v15 + v13[114];
      *((_DWORD *)this + 5) = v6;
    }
    if ( (v13[34] & 0x200000) != 0 )
    {
      v6 += 4;
      *((_DWORD *)this + 5) = v6;
    }
    if ( v6 )
    {
      v6 += 2;
      *((_DWORD *)this + 5) = v6;
    }
  }
  if ( v6 > 0xFFFF )
    return 1359i64;
  *a4 = *((_WORD *)this + 10);
  return 0i64;
}

//----- (0000000180019380) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::GenerateResponse(CSsl3TlsServerContext *this, struct SPBuffer *a2)
{
  int v2; // eax
  unsigned int Restart; // esi
  __int64 v7; // rax
  __int64 *v8; // r14
  CSessionCacheManager *v9; // r15
  __int64 v10; // rbp
  __int64 v11; // r9
  unsigned int v12; // eax
  unsigned int v13; // r8d
  __int64 v14; // rax

  v2 = *((_DWORD *)this + 17);
  Restart = 0;
  switch ( v2 )
  {
    case 94:
      Restart = CSsl3TlsServerContext::GenerateRestart(this, a2);
      if ( !Restart )
        *((_DWORD *)this + 17) = 64;
      break;
    case 93:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 25i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      Restart = CSsl3TlsServerContext::GenerateClientHelloResponse(this, a2);
      if ( !Restart )
        *((_DWORD *)this + 17) = 70;
      break;
    case 4:
      if ( CSslGlobals::m_fDisableRenegoOnServer )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 26i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
        return (unsigned int)-2146893018;
      }
      else
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 27i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
        return (unsigned int)CSsl3TlsServerContext::GenerateHelloRequest(this, a2);
      }
    case 95:
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 24i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      Restart = CSsl3TlsServerContext::AllocateAndGenerateNstCcsAndFinish(this, a2);
      if ( !Restart )
      {
        (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 448i64))(this);
        v7 = *((_QWORD *)this + 17);
        if ( (v7 & 0x400000) == 0 && (v7 & 0x8000000) != 0 )
        {
          v8 = (__int64 *)*((_QWORD *)this + 11);
          v9 = CSessionCacheManager::m_pSessionCacheManager;
          if ( v8 )
          {
            v10 = *((_QWORD *)this + 10);
            if ( v10 )
            {
              RtlAcquireResourceExclusive((PRTL_RESOURCE)(v8[28] + 48), 1u);
              RtlAcquireResourceExclusive((PRTL_RESOURCE)(v8 + 9), 1u);
              v12 = *(_DWORD *)(v10 + 208);
              v13 = *((_DWORD *)v8 + 70);
              *((_BYTE *)v8 + 236) = 1;
              if ( v12 < v13 )
                v13 = v12;
              v14 = *v8;
              *((_DWORD *)v8 + 70) = v13;
              LOBYTE(v11) = 1;
              (*(void (__fastcall **)(__int64 *, CSessionCacheManager *, CSsl3TlsServerContext *, __int64))(v14 + 64))(
                v8,
                v9,
                this,
                v11);
              RtlReleaseResource((PRTL_RESOURCE)(v8 + 9));
              RtlReleaseResource((PRTL_RESOURCE)(v8[28] + 48));
            }
          }
        }
      }
      break;
  }
  return Restart;
}
// 180019518: variable 'v11' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800927C0: using guessed type int CSslGlobals::m_fDisableRenegoOnServer;

//----- (0000000180019550) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::GenerateRestart(CSsl3TlsServerContext *this, struct SPBuffer *a2)
{
  char v4; // di
  int v5; // ecx
  __int64 v6; // rax
  int v7; // edx
  __int64 v8; // rax
  __int64 v9; // rax
  unsigned int v10; // edx
  char v11; // r9
  int v12; // eax
  __int16 v13; // di
  unsigned int v14; // r10d
  int v15; // r11d
  int v16; // r8d
  int v17; // ecx
  int v18; // eax
  _BYTE *v19; // r13
  unsigned int v20; // edx
  __int64 v21; // rcx
  int v22; // eax
  __int64 v23; // rax
  int v24; // edx
  int v25; // r8d
  const unsigned __int8 near *v26; // rax
  __int64 v27; // rax
  __int64 v28; // rcx
  __int64 v29; // r15
  __int64 v30; // rcx
  __int64 v31; // rax
  __int64 v32; // rax
  int SessionKeys; // eax
  unsigned int v34; // edi
  __int64 *v35; // rax
  __int64 v36; // rcx
  __int64 v37; // rax
  __int64 v38; // r9
  unsigned int v39; // r14d
  unsigned int v41; // ecx
  unsigned int v42; // r8d
  unsigned int v43; // ecx
  unsigned int v44; // r8d
  unsigned int v45; // ecx
  unsigned int v46; // r9d
  _BYTE *Memory; // rax
  int v48; // edx
  CCipherMill *v49; // rcx
  __int64 v50; // rdx
  int v51; // edx
  __int16 v52; // cx
  unsigned int v53; // [rsp+40h] [rbp-79h]
  int v54; // [rsp+44h] [rbp-75h]
  unsigned int v55; // [rsp+48h] [rbp-71h] BYREF
  void **v56; // [rsp+50h] [rbp-69h] BYREF
  CSsl3TlsServerContext *v57; // [rsp+58h] [rbp-61h]
  __int64 v58; // [rsp+60h] [rbp-59h]
  int v59; // [rsp+68h] [rbp-51h]
  CSsl3TlsServerContext *v60; // [rsp+70h] [rbp-49h]
  __time32_t Time; // [rsp+78h] [rbp-41h] BYREF
  int v62[2]; // [rsp+80h] [rbp-39h] BYREF
  char *v63; // [rsp+88h] [rbp-31h]
  char v64; // [rsp+90h] [rbp-29h] BYREF

  if ( (*((_BYTE *)this + 32) & 4) != 0 )
    v54 = *((_DWORD *)this + 11);
  else
    v54 = 0;
  v53 = 5;
  if ( *((_BYTE *)this + 233) )
    v53 = 13;
  v4 = *((_BYTE *)this + 553);
  v56 = &CTlsExtServer::`vftable';
  v5 = 0;
  v57 = this;
  v58 = 0i64;
  v59 = 0;
  v60 = this;
  if ( *((_BYTE *)this + 922) )
  {
    v5 = 6;
    BYTE1(v59) = 1;
    HIDWORD(v58) = 6;
  }
  if ( (*((_DWORD *)this + 34) & 0x400000) != 0 )
    HIDWORD(v58) = v5 + 4;
  v6 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 88i64))(this);
  if ( v6 && *(_DWORD *)v6 == 1 && *(_DWORD *)(v6 + 4) == 2 )
  {
    v7 = HIDWORD(v58) + 7 + *(unsigned __int8 *)(v6 + 8);
    HIDWORD(v58) = v7;
  }
  else
  {
    v7 = HIDWORD(v58);
  }
  if ( (*((_DWORD *)v57 + 34) & 0x8000000) != 0 )
    HIDWORD(v58) = v7 + 4;
  v8 = (*(__int64 (**)(void))(*(_QWORD *)v57 + 96i64))();
  if ( v8 )
    HIDWORD(v58) += 9 + *(unsigned __int8 *)(v8 + 2);
  v9 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)v57 + 104i64))(v57);
  if ( v9 )
  {
    v10 = HIDWORD(v58) + 7 + *(unsigned __int8 *)(v9 + 2);
    HIDWORD(v58) = v10;
  }
  else
  {
    v10 = HIDWORD(v58);
  }
  if ( v4 )
  {
    BYTE2(v59) = 1;
    v10 += *((_DWORD *)v57 + 104) + *((_DWORD *)v57 + 114) + 5;
    HIDWORD(v58) = v10;
  }
  if ( (*((_DWORD *)v57 + 34) & 0x200000) != 0 )
  {
    v10 += 4;
    HIDWORD(v58) = v10;
  }
  if ( v10 )
  {
    v10 += 2;
    HIDWORD(v58) = v10;
  }
  if ( v10 > 0xFFFF )
  {
    v49 = WPP_GLOBAL_Control;
    v34 = 1359;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return v34;
    v50 = 43i64;
    goto LABEL_110;
  }
  v11 = *((_BYTE *)this + 233);
  v12 = 4;
  if ( v11 )
    v12 = 12;
  v13 = *((_WORD *)this + 16);
  v14 = (unsigned __int16)v10 + v12 + 70;
  v55 = v14;
  if ( (v13 & 4) != 0 )
  {
    v41 = *((_DWORD *)this + 13);
    v42 = v14 + *((_DWORD *)this + 12);
    if ( v41 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v41 -= v42 % v41;
      v42 += v41;
    }
    v43 = *((_DWORD *)this + 13);
    v14 = v42 + *((_DWORD *)this + 11);
    v15 = *((_DWORD *)this + 15);
    v44 = *((_DWORD *)this + 12) + 1;
    if ( v43 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v43 -= v44 % v43;
      v44 += v43;
    }
    v16 = *((_DWORD *)this + 11) + v44;
  }
  else
  {
    v15 = *((_DWORD *)this + 15);
    v16 = 1;
  }
  if ( (*((_BYTE *)this + 64) & 0x30) != 0 )
  {
    v17 = 48;
    v18 = 40;
  }
  else
  {
    v17 = 24;
    v18 = 16;
  }
  if ( !v11 )
    v17 = v18;
  if ( (v13 & 1) != 0 )
  {
    v45 = *((_DWORD *)this + 12) + v17;
    v46 = *((_DWORD *)this + 13);
    if ( v46 )
    {
      if ( (*((_BYTE *)this + 56) & 1) != 0 )
        v46 -= v45 % v46;
      v45 += v46;
    }
    v17 = *((_DWORD *)this + 11) + v45;
  }
  v19 = (_BYTE *)*((_QWORD *)a2 + 1);
  v20 = v14 + v17 + v15 + v16 + 2 * v15;
  if ( v19 )
  {
    if ( *(_DWORD *)a2 < v20 )
    {
      *((_DWORD *)a2 + 1) = v20;
      return (unsigned int)-2146893023;
    }
  }
  else
  {
    *(_DWORD *)a2 = v20;
    Memory = CSslContext::GetMemory(this, v20);
    *((_QWORD *)a2 + 1) = Memory;
    v19 = Memory;
    if ( !Memory )
      return 14;
  }
  *((_DWORD *)a2 + 1) = 0;
  time32_0(&Time);
  v21 = 304i64;
  if ( (*((_DWORD *)this + 16) & 0xA2AA0) != 0 )
    v21 = 272i64;
  *(_DWORD *)((char *)this + v21) = _byteswap_ulong(Time);
  v22 = BCryptGenRandom(0i64, (PUCHAR)this + v21 + 4, 0x1Cu, 2u);
  if ( v22 < 0 )
  {
    v34 = RtlNtStatusToDosError(v22);
    if ( v34 )
      return v34;
  }
  v23 = *((_QWORD *)this + 10);
  if ( v23 )
  {
    v24 = *(_DWORD *)(v23 + 152);
    v25 = *((_DWORD *)this + 16);
    if ( (v24 & 0x1000) != 0 && (v25 & 0x400) != 0 )
    {
      v26 = CSsl3TlsContext::m_rgbTls12Downgrade;
LABEL_44:
      *((_QWORD *)this + 41) = v26;
      goto LABEL_45;
    }
    if ( *((_BYTE *)this + 233) )
    {
      if ( (v24 & 0x40000) == 0 || (v25 & 0x40000) != 0 )
        goto LABEL_45;
    }
    else if ( (v24 & 0x1400) == 0 || (v25 & 0x1400) != 0 )
    {
      goto LABEL_45;
    }
    v26 = CSsl3TlsContext::m_rgbTls11OrBelowDowngrade;
    goto LABEL_44;
  }
LABEL_45:
  RtlAcquireResourceShared((PRTL_RESOURCE)(*((_QWORD *)this + 124) + 72i64), 1u);
  v27 = *((_QWORD *)this + 124);
  v28 = *((_QWORD *)this + 20);
  Time = 0;
  v29 = *(_QWORD *)(v27 + 16);
  if ( v28 )
  {
    SslFreeObject(v28, 0i64);
    *((_QWORD *)this + 20) = 0i64;
  }
  v30 = *((_QWORD *)this + 21);
  if ( v30 )
  {
    SslFreeObject(v30, 0i64);
    v30 = 0i64;
    *((_QWORD *)this + 21) = 0i64;
  }
  if ( (*((_BYTE *)this + 32) & 1) != 0 )
  {
    v31 = *((_QWORD *)this + 1);
    if ( v31 )
    {
      if ( *(_DWORD *)(v31 + 28) )
      {
        v62[0] = v30;
        v63 = &v64;
        v32 = *(_QWORD *)this;
        v62[1] = 4;
        SessionKeys = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, _QWORD, __time32_t *, int *, __int64, __int64))(v32 + 128))(
                        this,
                        0i64,
                        &Time,
                        v62,
                        v30,
                        v30);
        v34 = SessionKeys;
        if ( SessionKeys )
        {
          v48 = 601;
        }
        else
        {
          v35 = (__int64 *)*((_QWORD *)this + 1);
          if ( v35 )
            v36 = *v35;
          else
            v36 = 0i64;
          SessionKeys = SslGenerateSessionKeys(v36, v29, (char *)this + 160, (char *)this + 168, v62, 0);
          v34 = SessionKeys;
          if ( !SessionKeys )
            goto LABEL_56;
          v48 = 600;
        }
        CSslContext::SetErrorAndFatalAlert((__int64)this, v48, SessionKeys, 0x33u);
        RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 124) + 72i64));
        v49 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          return v34;
        v50 = 44i64;
LABEL_110:
        WPP_SF_D(*((_QWORD *)v49 + 2), v50, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids, v34);
        return v34;
      }
    }
  }
LABEL_56:
  RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 124) + 72i64));
  v34 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, _QWORD))(*(_QWORD *)this + 496i64))(this, 0i64);
  if ( v34 )
    return v34;
  v37 = *(_QWORD *)this;
  *((_BYTE *)this + 340) = 0;
  v34 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, _QWORD, _QWORD, _QWORD))(v37 + 504))(
          this,
          *((_QWORD *)this + 110),
          *((unsigned int *)this + 218),
          0i64);
  if ( *((_QWORD *)this + 110) )
  {
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 110) = 0i64;
  }
  *((_DWORD *)this + 218) = 0;
  if ( v34 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)this, 1007, v34, 0x50u);
    return v34;
  }
  v34 = CSsl3TlsServerContext::GenerateServerHello(this, &v19[v53 + v54], &v55, (struct CTlsExtServer *)&v56);
  if ( v34 )
  {
    v49 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
      return v34;
    v50 = 45i64;
    goto LABEL_110;
  }
  v39 = v55;
  LOBYTE(v38) = 1;
  v34 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, _BYTE *, _QWORD, __int64))(*(_QWORD *)this + 504i64))(
          this,
          &v19[v53 + v54],
          v55,
          v38);
  if ( v34 )
  {
    v51 = 1006;
  }
  else
  {
    if ( *((_BYTE *)this + 233) )
      goto LABEL_106;
    v34 = CSsl3TlsContext::WrapMessage((__int64)this, (__int64)a2, 22, v39);
    if ( !v34 )
    {
      if ( !*((_BYTE *)this + 233) )
        return CSsl3TlsContext::GenerateCcsAndFinishMessage(this, a2);
LABEL_106:
      *((_DWORD *)a2 + 1) += v39 + v54 + v53;
      v52 = *((_WORD *)this + 17);
      v19[12] = v39;
      v19[11] = BYTE1(v39);
      v19[1] = HIBYTE(v52);
      v19[2] = v52;
      *v19 = 22;
      return CSsl3TlsContext::GenerateCcsAndFinishMessage(this, a2);
    }
    v51 = 954;
  }
  CSslContext::SetErrorAndFatalAlert((__int64)this, v51, v34, 0x50u);
  return v34;
}
// 1800199E7: variable 'v38' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 18007C320: using guessed type void *CTlsExtServer::`vftable';
// 180082BB8: using guessed type const unsigned __int8 near *const CSsl3TlsContext::m_rgbTls11OrBelowDowngrade;
// 180082BC0: using guessed type const unsigned __int8 near *const CSsl3TlsContext::m_rgbTls12Downgrade;
// 180098428: using guessed type __int64 __fastcall SslGenerateSessionKeys(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180019B10) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::TlsParseClientHello(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned __int8 *a3,
        unsigned __int8 *const a4,
        unsigned int *a5,
        unsigned int **a6,
        unsigned int *a7)
{
  CSsl3TlsServerContext *v7; // r14
  unsigned int v8; // ecx
  __int64 v9; // rax
  bool v10; // r12
  __int64 v11; // rsi
  unsigned __int8 *v12; // rbx
  int v13; // edi
  unsigned __int8 *v14; // rbx
  unsigned int v15; // edi
  int v16; // eax
  unsigned int v17; // r15d
  unsigned __int8 *v18; // rbx
  unsigned int v19; // edi
  unsigned int v20; // ebp
  unsigned int **v21; // r11
  unsigned __int8 *v22; // r13
  unsigned int v23; // r10d
  unsigned int v24; // eax
  __int64 v25; // rsi
  unsigned int v26; // r14d
  unsigned int v27; // edi
  unsigned __int8 *v28; // rbx
  unsigned __int8 *v29; // rdx
  __int64 v30; // rcx
  _BYTE *v31; // rbx
  unsigned int v32; // edi
  unsigned int v33; // eax
  unsigned int v34; // edi
  int v35; // ebx
  unsigned int v36; // ebx
  char v37; // r12
  unsigned __int8 v38; // r15
  unsigned __int8 *v39; // rdi
  char v40; // r12
  CCipherMill *v41; // r10
  unsigned __int16 v42; // si
  unsigned int v43; // r14d
  unsigned __int8 *v44; // rdi
  unsigned int v45; // ebx
  unsigned int v46; // eax
  unsigned int v47; // esi
  __int64 result; // rax
  __int64 v49; // rcx
  unsigned int v50; // edi
  CCipherMill *v51; // rcx
  __int64 v52; // rdx
  unsigned int *Memory; // [rsp+30h] [rbp-68h]
  void **v54; // [rsp+38h] [rbp-60h] BYREF
  CSsl3TlsServerContext *v55; // [rsp+40h] [rbp-58h]
  int v56; // [rsp+48h] [rbp-50h]
  int v57; // [rsp+4Ch] [rbp-4Ch]
  __int16 v58; // [rsp+50h] [rbp-48h]
  char v59; // [rsp+52h] [rbp-46h]
  char v60; // [rsp+53h] [rbp-45h]
  CSsl3TlsServerContext *v61; // [rsp+58h] [rbp-40h]
  char v63; // [rsp+B0h] [rbp+18h]

  v63 = 0;
  *((_BYTE *)this + 554) = 0;
  v7 = this;
  if ( (unsigned int)a3 < 2 )
    goto LABEL_55;
  v8 = a2[1] + (*a2 << 8);
  if ( v8 < 0x300 )
  {
    CSslContext::SetErrorAndFatalAlert((__int64)v7, 1201, -2146893048, 0x46u);
    goto LABEL_55;
  }
  v9 = *((_QWORD *)v7 + 15);
  v10 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
  *((_DWORD *)v7 + 9) = v8;
  if ( v9 && v10 )
    *(_DWORD *)(v9 + 44) = v8;
  if ( (unsigned int)((_DWORD)a3 - 2) < 0x20 )
    goto LABEL_55;
  *((_OWORD *)v7 + 17) = *(_OWORD *)(a2 + 2);
  *((_OWORD *)v7 + 18) = *(_OWORD *)(a2 + 18);
  if ( (_DWORD)a3 == 34 )
    goto LABEL_55;
  v11 = a2[34];
  if ( (unsigned int)v11 > 0x20 )
    goto LABEL_55;
  v12 = a2 + 35;
  v13 = (_DWORD)a3 - 35;
  if ( (int)a3 - 35 < (unsigned int)v11 )
    goto LABEL_55;
  if ( a2[34] )
    memcpy_0(a4, v12, a2[34]);
  v14 = &v12[v11];
  v15 = v13 - v11;
  *a5 = v11;
  if ( *((_BYTE *)v7 + 233) )
  {
    if ( !v15 )
      goto LABEL_55;
    v49 = *v14;
    if ( (unsigned int)v49 > 0x20 )
      goto LABEL_55;
    v50 = v15 - 1;
    if ( v50 < (unsigned int)v49 )
      goto LABEL_55;
    v14 += v49 + 1;
    v15 = v50 - v49;
  }
  if ( v15 < 2 || (v16 = v14[1], v17 = v16 + (*v14 << 8), (v16 & 1) != 0) || (v18 = v14 + 2, v19 = v15 - 2, v19 < v17) )
  {
LABEL_55:
    v47 = -2146893048;
    v23 = 0;
    goto LABEL_51;
  }
  v20 = v17 >> 1;
  if ( v17 >> 1 > *a7 )
  {
    Memory = (unsigned int *)CSslContext::GetMemory(v7, 4 * v20);
    v22 = (unsigned __int8 *)Memory;
    if ( Memory )
    {
      v10 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
      v21 = a6;
      goto LABEL_18;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
    {
      WPP_SF_d(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x36u,
        (__int64)&WPP_095c39149c3f336b5b94efe855075ae2_Traceguids,
        4 * v20);
      v23 = 0;
      v47 = -2146893048;
      goto LABEL_51;
    }
    goto LABEL_55;
  }
  v21 = a6;
  v22 = (unsigned __int8 *)*a6;
  Memory = *a6;
LABEL_18:
  v23 = 0;
  v24 = 0;
  if ( v20 )
  {
    a4 = v22;
    do
    {
      a3 = (unsigned __int8 *)(v18[2 * v24 + 1] | (v18[2 * v24] << 8));
      *(_DWORD *)a4 = (_DWORD)a3;
      if ( (_DWORD)a3 == 255 )
      {
        if ( *((_DWORD *)v7 + 104) )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 55i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
          }
          CSslContext::SetErrorAndFatalAlert((__int64)v7, 1207, -2146892986, 0x28u);
          *((_DWORD *)v7 + 17) = 96;
          v47 = -2146892986;
          *((_WORD *)v7 + 48) = 10242;
          goto LABEL_82;
        }
        *((_BYTE *)v7 + 553) = 1;
        v63 = 1;
      }
      ++v24;
      a4 += 4;
    }
    while ( v24 < v20 );
  }
  v25 = *((_QWORD *)v7 + 15);
  v26 = v17 >> 1;
  if ( v25 && v10 )
  {
    *(_DWORD *)(v25 + 1580) = v20;
    if ( v20 > 0x64 )
      v26 = 100;
    memcpy_0((void *)(v25 + 1176), v22, 4i64 * v26);
    v21 = a6;
    v23 = 0;
    *(_WORD *)(v25 + 1576) = v26;
  }
  v27 = v19 - v17;
  v28 = &v18[v17];
  v29 = v28;
  if ( !v27 )
  {
    v7 = this;
    v47 = -2146893048;
    goto LABEL_83;
  }
  v30 = *v28;
  if ( !*v28 )
  {
    v7 = this;
    v47 = -2146893048;
    goto LABEL_83;
  }
  v31 = v28 + 1;
  v32 = v27 - 1;
  if ( v32 < (unsigned int)v30 )
  {
    v7 = this;
    v47 = -2146893048;
    goto LABEL_83;
  }
  v33 = 0;
  while ( *v31 )
  {
    ++v33;
    ++v31;
    if ( v33 >= (unsigned int)v30 )
    {
      if ( v33 == (_DWORD)v30 )
      {
        v7 = this;
        v47 = -2146893048;
        goto LABEL_83;
      }
      break;
    }
  }
  v34 = v32 - v30;
  if ( v34 < 2 )
    goto LABEL_47;
  v7 = this;
  v35 = v29[v30 + 1];
  v54 = &CTlsExtServer::`vftable';
  v36 = v29[v30 + 2] | (v35 << 8);
  v55 = this;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  v61 = this;
  if ( v34 - 2 < v36 )
  {
LABEL_48:
    v47 = 0;
    goto LABEL_49;
  }
  v37 = *((_BYTE *)this + 64);
  v38 = 0;
  v56 = 1;
  v39 = &v29[v30 + 3];
  *((_BYTE *)this + 922) = 0;
  v40 = v37 & 0x30;
  v60 = 0;
  if ( !v36 )
  {
LABEL_46:
    (*(void (__fastcall **)(CSsl3TlsServerContext *, _QWORD, unsigned __int8 *, unsigned __int8 *const))(*(_QWORD *)v55 + 352i64))(
      v55,
      v38,
      a3,
      a4);
LABEL_47:
    v7 = this;
    goto LABEL_48;
  }
  v41 = WPP_GLOBAL_Control;
  while ( 1 )
  {
    if ( v36 < 4 )
      goto LABEL_89;
    v42 = _byteswap_ushort(*((_WORD *)v39 + 1));
    v43 = v39[1] | (*v39 << 8);
    if ( v41 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v41 + 28) & 4) != 0 )
    {
      WPP_SF_D(*((_QWORD *)v41 + 2), 73i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids, v43);
      v41 = WPP_GLOBAL_Control;
    }
    v44 = v39 + 4;
    v45 = v36 - 4;
    if ( v45 < v42 )
    {
      if ( v41 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v41 + 28) & 2) != 0 )
        WPP_SF_(*((_QWORD *)v41 + 2), 74i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
LABEL_89:
      v47 = -2146893018;
      goto LABEL_90;
    }
    a3 = v44;
    v39 = &v44[v42];
    v36 = v45 - v42;
    if ( !v40 || v43 == 65281 )
      break;
LABEL_45:
    if ( !v36 )
      goto LABEL_46;
  }
  v46 = ((__int64 (__fastcall *)(void ***, _QWORD, unsigned __int8 *, _QWORD))v54[1])(&v54, v43, a3, v42);
  v47 = v46;
  if ( !v46 )
  {
    v41 = WPP_GLOBAL_Control;
    if ( v43 == 65281 )
      v38 = 1;
    goto LABEL_45;
  }
  if ( v46 == -2146892986 || v46 == -2146892953 )
  {
    v7 = this;
    goto LABEL_81;
  }
LABEL_90:
  v7 = this;
  CSslContext::SetErrorAndFatalAlert((__int64)this, 1202, -2146893048, 0xAu);
LABEL_81:
  if ( !v47 )
  {
LABEL_49:
    if ( !*((_BYTE *)v7 + 554) && !v63 )
    {
      if ( !g_fAllowInsecureRenegoClients )
      {
        v51 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          goto LABEL_101;
        v52 = 56i64;
LABEL_100:
        WPP_SF_(*((_QWORD *)v51 + 2), v52, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
LABEL_101:
        CSslContext::SetErrorAndFatalAlert((__int64)v7, 1207, -2146892986, 0x28u);
        result = 2148074310i64;
        *((_DWORD *)v7 + 17) = 96;
        *((_WORD *)v7 + 48) = 10242;
        return result;
      }
      if ( *((_BYTE *)v7 + 553) )
      {
        v51 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          goto LABEL_101;
        v52 = 57i64;
        goto LABEL_100;
      }
    }
    v23 = v20;
    *a6 = Memory;
    goto LABEL_51;
  }
LABEL_82:
  v21 = a6;
  v23 = 0;
  v22 = (unsigned __int8 *)Memory;
LABEL_83:
  if ( v22 && v22 != (unsigned __int8 *)*v21 )
  {
    (*(void (__fastcall **)(CSsl3TlsServerContext *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *const))(*(_QWORD *)v7 + 16i64))(
      v7,
      v22,
      a3,
      a4);
    v23 = 0;
  }
LABEL_51:
  result = v47;
  *a7 = v23;
  return result;
}
// 180019E70: variable 'a3' is possibly undefined
// 180019E70: variable 'a4' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 18007C320: using guessed type void *CTlsExtServer::`vftable';
// 1800919AC: using guessed type int g_fAllowInsecureRenegoClients;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180019EE0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::GenerateServerHello(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned int *a3,
        struct CTlsExtServer *a4)
{
  int v8; // r15d
  unsigned int v9; // r10d
  char v10; // r8
  int v11; // edx
  int v12; // eax
  unsigned int v13; // eax
  unsigned int v14; // edi
  unsigned __int8 *v15; // rbx
  int v16; // edx
  char v17; // al
  char v18; // cl
  unsigned int v19; // edi
  unsigned int v20; // r14d
  __int64 v21; // rdx
  char *v22; // rbx
  unsigned int v23; // edi
  char *v24; // rbx
  __int64 v25; // rax
  unsigned int v26; // edi
  unsigned int v27; // eax
  __int64 result; // rax
  __int16 v29; // r8
  unsigned int v30; // ecx
  unsigned int v31; // ecx
  bool v32; // zf
  unsigned int v33; // eax
  __int64 v34; // rcx
  __int64 v35; // rdx
  __int64 v36; // rax
  _DWORD *v37; // rcx
  __int64 v38; // rax
  __int64 v39; // rax
  int v40; // [rsp+20h] [rbp-38h]
  unsigned int v41; // [rsp+24h] [rbp-34h]
  unsigned int v42; // [rsp+68h] [rbp+10h] BYREF

  if ( !a2 || !a3 )
    return 87i64;
  LOWORD(v8) = 0;
  LOWORD(v9) = 0;
  if ( a4 )
  {
    v9 = *((_DWORD *)a4 + 5);
    if ( !v9 )
    {
      v34 = *((_QWORD *)a4 + 1);
      v35 = 0i64;
      if ( *(_BYTE *)(v34 + 922) )
      {
        v35 = 6i64;
        *((_BYTE *)a4 + 25) = 1;
        *((_DWORD *)a4 + 5) = 6;
      }
      if ( (*(_DWORD *)(v34 + 136) & 0x400000) != 0 )
        *((_DWORD *)a4 + 5) = v35 + 4;
      v36 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v34 + 88i64))(v34, v35);
      if ( v36 && *(_DWORD *)v36 == 1 && *(_DWORD *)(v36 + 4) == 2 )
        *((_DWORD *)a4 + 5) += *(unsigned __int8 *)(v36 + 8) + 7;
      v37 = (_DWORD *)*((_QWORD *)a4 + 1);
      if ( (v37[34] & 0x8000000) != 0 )
        *((_DWORD *)a4 + 5) += 4;
      v38 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v37 + 96i64))(v37);
      if ( v38 )
        *((_DWORD *)a4 + 5) += *(unsigned __int8 *)(v38 + 2) + 9;
      v39 = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)a4 + 1) + 104i64))(*((_QWORD *)a4 + 1));
      if ( v39 )
        *((_DWORD *)a4 + 5) += *(unsigned __int8 *)(v39 + 2) + 7;
      v9 = *((_DWORD *)a4 + 5);
      if ( (*(_DWORD *)(*((_QWORD *)a4 + 1) + 136i64) & 0x200000) != 0 )
      {
        v9 += 4;
        *((_DWORD *)a4 + 5) = v9;
      }
      if ( v9 )
      {
        v9 += 2;
        *((_DWORD *)a4 + 5) = v9;
      }
    }
    if ( v9 > 0xFFFF )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 50i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids, 1359i64);
      return 1359i64;
    }
  }
  v10 = *((_BYTE *)this + 233);
  v11 = 4;
  v12 = 4;
  v40 = 4;
  if ( v10 )
    v12 = 12;
  v13 = (unsigned __int16)v9 + v12 + 70;
  v41 = v13;
  if ( *a3 < v13 )
  {
    *a3 = v13;
    return 234i64;
  }
  if ( v10 )
  {
    v11 = 12;
    v40 = 12;
  }
  v14 = v13 - v11;
  v15 = &a2[v11];
  v16 = *((_DWORD *)this + 16);
  if ( (v16 & 0x3FFC) != 0 && (v16 & 0xF0000) != 0 )
    goto LABEL_63;
  if ( (v16 & 0xC0000) != 0 )
  {
    v17 = -3;
    v18 = -2;
    goto LABEL_17;
  }
  if ( (v16 & 0x30000) != 0 )
  {
    v17 = -1;
    v18 = -2;
    goto LABEL_17;
  }
  if ( (v16 & 0x3000) != 0 )
  {
    v17 = 4;
LABEL_66:
    v18 = 3;
    goto LABEL_17;
  }
  if ( (v16 & 0xC00) == 0 )
  {
    if ( (v16 & 0x300) != 0 )
    {
      v17 = 2;
      goto LABEL_66;
    }
    if ( (v16 & 0xC0) != 0 )
    {
LABEL_65:
      v17 = 1;
      goto LABEL_66;
    }
    if ( (v16 & 0x30) != 0 )
    {
      v17 = 0;
      goto LABEL_66;
    }
    if ( (v16 & 0xC) != 0 )
    {
      v17 = 2;
      v18 = 0;
      goto LABEL_17;
    }
LABEL_63:
    if ( v10 )
    {
      v17 = -1;
      v18 = -2;
      goto LABEL_17;
    }
    goto LABEL_65;
  }
  v17 = 3;
  v18 = 3;
LABEL_17:
  *v15 = v18;
  v19 = v14 - 35;
  v15[1] = v17;
  v20 = v19;
  *(_OWORD *)(v15 + 2) = *((_OWORD *)this + 19);
  *(_OWORD *)(v15 + 18) = *((_OWORD *)this + 20);
  v21 = *((_QWORD *)this + 124);
  v22 = (char *)(v15 + 35);
  if ( v19 >= *(unsigned __int16 *)(v21 + 238) )
  {
    v20 = *(unsigned __int16 *)(v21 + 238);
    memcpy_0(v22, (const void *)(v21 + 240), *(unsigned __int16 *)(v21 + 238));
  }
  *(v22 - 1) = v20;
  v23 = v19 - v20;
  v24 = &v22[v20];
  if ( (*((_BYTE *)this + 32) & 1) != 0 )
  {
    v25 = *((_QWORD *)this + 1);
    if ( v25 )
      v8 = *(_DWORD *)(v25 + 28);
  }
  v26 = v23 - 3;
  *v24 = BYTE1(v8);
  v27 = v26;
  v24[1] = v8;
  v24[2] = 0;
  v42 = v26;
  if ( a4 && v26 )
  {
    result = CTlsExtServer::BuildServerHelloExtension(a4, v26, (unsigned __int8 *)v24 + 3, &v42);
    if ( (_DWORD)result )
      return result;
    v27 = v42;
  }
  v29 = *((_WORD *)this + 110);
  v30 = v27 - v26 + v41;
  *a3 = v30;
  v31 = v30 - v40;
  *((_WORD *)this + 110) = v29 + 1;
  v32 = *((_BYTE *)this + 233) == 0;
  *a2 = 2;
  if ( v32 )
  {
    v33 = HIWORD(v31);
  }
  else
  {
    a2[5] = v29;
    v33 = HIWORD(v31);
    a2[9] = BYTE2(v31);
    a2[4] = HIBYTE(v29);
    *(_WORD *)(a2 + 7) = 0;
    a2[6] = 0;
    a2[11] = v31;
    a2[10] = BYTE1(v31);
  }
  a2[1] = v33;
  result = 0i64;
  a2[3] = v31;
  a2[2] = BYTE1(v31);
  return result;
}
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018001A100) ----------------------------------------------------
__int64 __fastcall CTlsExtServer::BuildServerHelloExtension(
        CTlsExtServer *this,
        unsigned int a2,
        unsigned __int8 *a3,
        unsigned int *a4)
{
  unsigned __int8 *v5; // rbp
  unsigned int v6; // eax
  unsigned __int8 *v7; // rdi
  unsigned __int8 *v8; // rdx
  unsigned __int8 v9; // al
  _DWORD *v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rsi
  _BOOL8 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // rax
  __int64 v16; // rax
  unsigned __int16 *v17; // rax
  __int64 v18; // rax
  __int64 v19; // rsi
  unsigned int *v20; // rax
  __int64 v21; // r9
  const void *v22; // r12
  __int64 v23; // r10
  const void *v24; // r15
  size_t v25; // rsi
  size_t v26; // r14
  __int16 v27; // ax
  unsigned __int8 v28; // r9
  char *v29; // rdi
  char *v30; // rdi
  __int64 v31; // rcx
  __int64 result; // rax
  __int16 v33; // dx
  unsigned __int16 v34; // dx
  __int64 v35; // rax
  __int64 v36; // rcx
  __int64 v37; // rcx
  __int64 v38; // rcx
  size_t v39; // r14
  int v40; // esi
  const void *v41; // r15
  unsigned __int8 *v42; // rsi
  __int64 v43; // rcx
  CTlsExt *v44; // rcx
  __int64 v45; // [rsp+20h] [rbp-48h]
  unsigned __int8 *v46; // [rsp+80h] [rbp+18h] BYREF

  v5 = &a3[a2];
  if ( !a3 || !a4 )
    return 87i64;
  v6 = *((_DWORD *)this + 5);
  *a4 = v6;
  if ( !v6 )
    return 0i64;
  if ( a2 < v6 )
    return 234i64;
  v7 = a3 + 2;
  v8 = a3 + 2;
  *a3 = (unsigned __int16)(v6 - 2) >> 8;
  v9 = *((_BYTE *)this + 20) - 2;
  v46 = a3 + 2;
  a3[1] = v9;
  if ( *((_BYTE *)this + 24) )
  {
    *(_WORD *)v7 = 1280;
    v37 = *((_QWORD *)this + 1);
    v7 = a3 + 6;
    v46 = a3 + 6;
    CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v37 + 120), 0, 5);
    v8 = v7;
  }
  if ( *((_BYTE *)this + 25) )
  {
    *v7 = 0;
    v7 = v8 + 6;
    *(_DWORD *)(v8 + 1) = 16908294;
    v8[5] = 64;
    v38 = *((_QWORD *)this + 1);
    v46 = v8 + 6;
    CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v38 + 120), 0, 6);
    v8 = v7;
  }
  v10 = (_DWORD *)*((_QWORD *)this + 1);
  if ( (v10[34] & 0x400000) != 0 )
  {
    *v7 = 0;
    v7 = v8 + 4;
    v46 = v8 + 4;
    v8[1] = 35;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 17i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
    CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 35);
    v10 = (_DWORD *)*((_QWORD *)this + 1);
  }
  v11 = (*(__int64 (__fastcall **)(_DWORD *, unsigned __int8 *))(*(_QWORD *)v10 + 88i64))(v10, v8);
  v12 = v11;
  if ( !v11 || *(_DWORD *)v11 != 1 || *(_DWORD *)(v11 + 4) != 2 )
    goto LABEL_11;
  v33 = *(unsigned __int8 *)(v11 + 8);
  *(_WORD *)v7 = 4096;
  v34 = v33 + 1;
  v7[2] = (unsigned __int16)(v34 + 2) >> 8;
  v7[3] = v34 + 2;
  v7[4] = HIBYTE(v34);
  v7[5] = v34;
  v7[6] = *(_BYTE *)(v11 + 8);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 18i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids, v34);
  memcpy_0(v7 + 7, (const void *)(v12 + 9), *(unsigned __int8 *)(v12 + 8));
  v35 = *((_QWORD *)this + 1);
  v7 += *(unsigned __int8 *)(v12 + 8) + 7;
  v46 = v7;
  v36 = *(_QWORD *)(v35 + 120);
  if ( v36 )
  {
    v13 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
    if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
      *(_DWORD *)(v36 + 68) |= 0x800u;
  }
  else
  {
LABEL_11:
    v13 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
  }
  v14 = *((_QWORD *)this + 1);
  if ( (*(_DWORD *)(v14 + 136) & 0x8000000) != 0 )
  {
    *(_WORD *)v7 = 5888;
    v7 += 4;
    v46 = v7;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 19i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
      v13 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
    }
    v14 = *((_QWORD *)this + 1);
    v15 = *(_QWORD *)(v14 + 120);
    if ( v15 && v13 )
    {
      *(_WORD *)(v15 + 66) |= 2u;
      v14 = *((_QWORD *)this + 1);
    }
    v16 = *(_QWORD *)(v14 + 120);
    if ( v16 && v13 )
    {
      *(_DWORD *)(v16 + 68) |= 0x1000u;
      v14 = *((_QWORD *)this + 1);
    }
  }
  v17 = (unsigned __int16 *)(*(__int64 (__fastcall **)(__int64, _BOOL8))(*(_QWORD *)v14 + 96i64))(v14, v13);
  if ( v17 )
  {
    v39 = *((unsigned __int8 *)v17 + 2);
    v40 = *v17;
    v41 = (const void *)*((_QWORD *)v17 + 1);
    *(_WORD *)v7 = 3584;
    v7[2] = (unsigned __int16)(v39 + 5) >> 8;
    v7[3] = v39 + 5;
    *((_WORD *)v7 + 2) = 512;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x14u,
        (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
        v40,
        v39);
    *((_WORD *)v7 + 3) = v40;
    v42 = v7 + 9;
    v7[8] = v39;
    if ( v41 )
      memcpy_0(v7 + 9, v41, v39);
    v43 = *((_QWORD *)this + 1);
    v7 = &v42[v39];
    v46 = &v42[v39];
    CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(v43 + 120), 0, 14);
  }
  v18 = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 1) + 104i64))(*((_QWORD *)this + 1));
  v19 = v18;
  if ( v18 )
  {
    v44 = (CTlsExt *)*((_QWORD *)this + 4);
    if ( (*((_DWORD *)v44 + 16) & 0x1000) != 0
      || *((_BYTE *)this + 26) && (v44 = (CTlsExt *)*((_QWORD *)this + 1), (*((_DWORD *)v44 + 34) & 0x8000000) != 0) )
    {
      result = CTlsExt::BuildTBExtension(
                 v44,
                 *(_BYTE *)v18,
                 *(_BYTE *)(v18 + 1),
                 *(unsigned __int8 *const *)(v18 + 8),
                 *(_BYTE *)(v18 + 2),
                 v5,
                 &v46);
      if ( (_DWORD)result )
        return result;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          22i64,
          &WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
          *(unsigned __int16 *)(v19 + 2));
      CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 24);
      v7 = v46;
    }
    else
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 21i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
      CSsl3TlsContext::FreeSelectedTBParameters(*((CSsl3TlsContext **)this + 1));
    }
  }
  if ( !*((_BYTE *)this + 26) )
    goto LABEL_36;
  v20 = (unsigned int *)*((_QWORD *)this + 1);
  v21 = v20[104];
  v22 = (char *)v20 + 377;
  v23 = v20[114];
  v24 = v20 + 105;
  if ( (_DWORD)v21 == (_DWORD)v23 )
  {
    v25 = (unsigned int)v23;
    v26 = (unsigned int)v21;
    if ( &v7[v23 + 5 + v21] <= v5 )
    {
      *(_WORD *)v7 = 511;
      v27 = v23 + v21 + 1;
      v28 = v23 + v21;
      v7[2] = HIBYTE(v27);
      v7[3] = v28 + 1;
      v7[4] = v28;
      v29 = (char *)(v7 + 5);
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 25i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
      }
      memcpy_0(v29, v22, v26);
      v30 = &v29[v26];
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 26i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
      }
      memcpy_0(v30, v24, v25);
      v7 = (unsigned __int8 *)&v30[v25];
      v31 = *(_QWORD *)(*((_QWORD *)this + 1) + 120i64);
      if ( v31 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
        *(_DWORD *)(v31 + 68) |= 0x10000u;
LABEL_36:
      if ( (*(_DWORD *)(*((_QWORD *)this + 1) + 136i64) & 0x200000) != 0 )
      {
        *(_DWORD *)v7 = 0;
        CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*((_QWORD *)this + 1) + 120i64), 0, 0);
      }
      return 0i64;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 24i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
    return 234i64;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    LODWORD(v45) = v20[114];
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x17u,
      (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
      v21,
      v45);
  }
  return 1359i64;
}
// 18001A1B0: variable 'v8' is possibly undefined
// 18002EF8B: variable 'v45' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (000000018001B0B0) ----------------------------------------------------
__int64 __fastcall CCipherMill::ChooseServerCipher(
        CCipherMill *this,
        struct CSsl3TlsServerContext *a2,
        unsigned int *a3,
        unsigned int a4,
        unsigned int a5,
        unsigned __int8 a6)
{
  __int64 v6; // rdi
  __int64 v8; // r13
  unsigned __int64 v9; // rsi
  __int64 v10; // rax
  unsigned __int8 *v11; // r14
  CCipherMill *v12; // rdi
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  unsigned __int64 v16; // rdi
  unsigned __int64 v17; // rsi
  __int64 v18; // rdx
  __int64 v19; // r8
  unsigned int AcceptableCipherSuiteAndCred; // r15d
  struct CCipherSuiteInfo *v21; // r13
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // r8
  __int64 v25; // rdi
  __int64 v26; // rsi
  CSslServerKey *v27; // rcx
  struct CCipherSuiteInfo *v28; // rdi
  __int64 v29; // r12
  unsigned int v30; // r9d
  unsigned int v31; // r8d
  __int64 v32; // rax
  int v33; // eax
  unsigned int v34; // r9d
  __int16 v35; // r10
  unsigned __int8 v36; // si
  unsigned __int8 *v37; // rdx
  CCipherMill *v38; // rcx
  struct CCipherSuiteInfo *v40; // rax
  struct CSslCredential *v41; // r8
  unsigned __int8 *v42; // r9
  unsigned __int8 v43; // cl
  int v44; // r10d
  struct CSslCredential *v45; // rsi
  unsigned int v46; // edi
  unsigned int v47; // edx
  NTSTATUS v48; // eax
  __int64 v49; // r9
  __int64 v50; // rdx
  __int16 v51; // ax
  __int64 v52; // rax
  unsigned __int16 v53; // ax
  unsigned __int8 *v54; // rcx
  unsigned __int64 v55; // r15
  __int64 v56; // rax
  unsigned __int8 *v57; // rcx
  __int64 v58; // rax
  unsigned __int8 *v59; // r14
  unsigned __int8 *v60; // r12
  unsigned __int8 *v61; // r13
  __int64 v62; // rcx
  SIZE_T v63; // rax
  _DWORD *v64; // rax
  __int64 *v65; // r10
  unsigned int v66; // ecx
  __int64 v67; // r10
  __int64 v68; // rdx
  __int64 v69; // rax
  __int64 v70; // rcx
  const char *v71; // r9
  unsigned __int8 v72; // al
  const char *v73; // r9
  __int64 v74; // rax
  __int64 v75; // rdx
  __int64 v76; // rcx
  unsigned int v77; // ecx
  int v78; // eax
  CCipherMill *v79; // rcx
  __int64 v80; // rdx
  unsigned __int16 v81; // dx
  struct _UNICODE_STRING *v82; // [rsp+28h] [rbp-D8h]
  bool v83; // [rsp+60h] [rbp-A0h]
  unsigned __int8 v84; // [rsp+61h] [rbp-9Fh]
  unsigned __int8 v85[2]; // [rsp+62h] [rbp-9Eh] BYREF
  unsigned int v86; // [rsp+64h] [rbp-9Ch]
  unsigned __int8 *v87; // [rsp+68h] [rbp-98h] BYREF
  unsigned int v88; // [rsp+70h] [rbp-90h]
  unsigned int v89; // [rsp+74h] [rbp-8Ch] BYREF
  struct CCipherSuiteInfo *v90; // [rsp+78h] [rbp-88h] BYREF
  struct CCipherSuiteInfo *v91; // [rsp+80h] [rbp-80h]
  struct CSslCredential *v92; // [rsp+88h] [rbp-78h]
  struct CSslCredential *v93; // [rsp+90h] [rbp-70h] BYREF
  unsigned __int8 *v94; // [rsp+98h] [rbp-68h]
  unsigned int v95; // [rsp+A0h] [rbp-60h]
  struct _UNICODE_STRING *p_DestinationString; // [rsp+A8h] [rbp-58h]
  unsigned __int64 v97; // [rsp+B0h] [rbp-50h]
  struct _UNICODE_STRING DestinationString; // [rsp+B8h] [rbp-48h] BYREF
  __int64 v99; // [rsp+C8h] [rbp-38h]
  struct _STRING SourceString; // [rsp+D0h] [rbp-30h] BYREF
  unsigned int *v101; // [rsp+E0h] [rbp-20h]
  _BYTE Source1[20]; // [rsp+E8h] [rbp-18h] BYREF
  __int64 v103; // [rsp+100h] [rbp+0h] BYREF
  int v104; // [rsp+108h] [rbp+8h]
  wchar_t v105; // [rsp+10Ch] [rbp+Ch]
  char v106[498]; // [rsp+10Eh] [rbp+Eh] BYREF
  char v107[512]; // [rsp+300h] [rbp+200h] BYREF

  v6 = *((_QWORD *)a2 + 10);
  v101 = a3;
  v99 = v6;
  v93 = 0i64;
  v90 = 0i64;
  v89 = 0;
  v85[0] = 0;
  v94 = 0i64;
  v95 = a4;
  memset_0(v107, 0, 0x1FEui64);
  *(_DWORD *)&DestinationString.Length = 33423360;
  DestinationString.Buffer = (PWSTR)v107;
  v8 = *(unsigned int *)(v6 + 196);
  v9 = *(_QWORD *)(v6 + 200);
  p_DestinationString = 0i64;
  v97 = v9;
  v83 = (_DWORD)v8 != 0;
  v92 = 0i64;
  v91 = 0i64;
  v87 = 0i64;
  v86 = 0;
  v84 = 0;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 27i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
  RtlAcquireResourceShared(&Resource, 1u);
  v10 = *((_QWORD *)a2 + 121);
  v11 = (unsigned __int8 *)(v10 + 6);
  if ( v10 )
  {
    v88 = *(unsigned __int16 *)(v10 + 4);
  }
  else
  {
    v11 = 0i64;
    v88 = 0;
  }
  v12 = WPP_GLOBAL_Control;
  while ( 1 )
  {
    v104 = *(_DWORD *)L"E>";
    v105 = aNone[6];
    v103 = *(_QWORD *)L"<NONE>";
    memset_0(v106, 0, sizeof(v106));
    if ( v91 && v83 )
    {
      LOBYTE(v13) = 0;
      v83 = 0;
    }
    else
    {
      if ( v11 && v88 )
      {
        v94 = v11;
        *(_DWORD *)(&SourceString.MaximumLength + 1) = 0;
        p_DestinationString = &DestinationString;
        if ( !DestinationString.Buffer )
        {
          AcceptableCipherSuiteAndCred = 87;
          goto LABEL_43;
        }
        v46 = v88;
        v47 = *v11;
        if ( v47 > v88 - 1 )
        {
          AcceptableCipherSuiteAndCred = 1359;
          goto LABEL_43;
        }
        SourceString.Length = *v11;
        SourceString.MaximumLength = v47;
        SourceString.Buffer = (PCHAR)(v11 + 1);
        v48 = RtlAnsiStringToUnicodeString(&DestinationString, &SourceString, 0);
        AcceptableCipherSuiteAndCred = RtlNtStatusToDosError(v48);
        if ( AcceptableCipherSuiteAndCred )
          goto LABEL_43;
        v14 = (__int64)&v103;
        v49 = DestinationString.Length - 512i64;
        v50 = 512i64;
        v15 = (char *)DestinationString.Buffer - (char *)&v103;
        while ( v49 + v50 )
        {
          v51 = *(_WORD *)(v15 + v14);
          if ( !v51 )
            break;
          *(_WORD *)v14 = v51;
          v14 += 2i64;
          if ( !--v50 )
          {
            v14 -= 2i64;
            break;
          }
        }
        *(_WORD *)v14 = 0;
        v52 = (unsigned int)*v11 + 1;
        if ( (unsigned int)v52 > v46 )
          goto LABEL_150;
        v88 = v46 - v52;
        v11 += v52;
        v12 = WPP_GLOBAL_Control;
      }
      v13 = v83;
    }
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
    {
      v71 = "strict";
      if ( !(_BYTE)v13 )
        v71 = "all";
      WPP_SF_sS(*((_QWORD *)v12 + 2), v13, v15, v71, (const wchar_t *)&v103);
      LOBYTE(v13) = v83;
    }
    if ( !(_DWORD)v8 || !v9 || (v16 = v9, v14 = 5 * v8, v17 = v9 + 40 * v8, v97 >= v17) )
    {
LABEL_17:
      AcceptableCipherSuiteAndCred = CCipherMill::FindAcceptableCipherSuiteAndCred(
                                       (CCipherMill *)v14,
                                       a2,
                                       v101,
                                       v95,
                                       a6,
                                       p_DestinationString,
                                       v13,
                                       &v90,
                                       &v93,
                                       &v89,
                                       v85);
      if ( AcceptableCipherSuiteAndCred )
      {
        v12 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_125;
        v73 = "strict";
        if ( !v83 )
          v73 = "all";
        LODWORD(v82) = AcceptableCipherSuiteAndCred;
        WPP_SF_sSD(*((_QWORD *)WPP_GLOBAL_Control + 2), v18, v19, v73, (const wchar_t *)&v103, v82);
      }
      else
      {
        if ( a6 )
          goto LABEL_19;
        LOBYTE(v13) = v83;
        if ( !v83 )
        {
          v43 = v85[0];
          v45 = v93;
          goto LABEL_96;
        }
        v40 = v91;
        if ( v91 )
        {
          v12 = WPP_GLOBAL_Control;
LABEL_126:
          v43 = v84;
          v41 = v92;
          v42 = v87;
          v44 = v86;
LABEL_50:
          v45 = 0i64;
          v90 = 0i64;
          v93 = 0i64;
          v89 = 0;
          v85[0] = 0;
          goto LABEL_51;
        }
        v40 = v90;
        v41 = v93;
        v42 = v94;
        v43 = v85[0];
        v44 = v89;
        v91 = v90;
        v92 = v93;
        v87 = v94;
        v84 = v85[0];
        v86 = v89;
        v12 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_50;
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 29i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
      }
      v12 = WPP_GLOBAL_Control;
LABEL_125:
      v40 = v91;
      LOBYTE(v13) = v83;
      goto LABEL_126;
    }
    while ( 1 )
    {
      if ( (a5 & *(_DWORD *)(v16 + 16)) != 0 )
      {
        if ( !*(_DWORD *)v16
          || p_DestinationString
          && (v72 = DoesTlsParameterContainAlpnId((struct _TLS_PARAMETERS *)v16, p_DestinationString),
              LOBYTE(v13) = v83,
              v72) )
        {
          if ( !(_BYTE)v13 || (*(_BYTE *)(v16 + 32) & 1) == 0 )
            break;
        }
      }
      v16 += 40i64;
      if ( v16 >= v17 )
        goto LABEL_17;
    }
    v12 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_d(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xFu, (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids, a5);
      LOBYTE(v13) = v83;
      v12 = WPP_GLOBAL_Control;
    }
    v45 = v93;
    AcceptableCipherSuiteAndCred = -2146893007;
    v40 = v91;
    v43 = v84;
    v41 = v92;
    v42 = v87;
    v44 = v86;
LABEL_51:
    if ( !(_DWORD)v8 || !v88 && (!v40 || !(_BYTE)v13) )
      break;
    v9 = v97;
  }
  if ( !AcceptableCipherSuiteAndCred )
    goto LABEL_97;
  if ( !v40 )
  {
    v74 = *((_QWORD *)a2 + 121);
    if ( !v74 || !*(_WORD *)(v74 + 4) )
    {
      if ( AcceptableCipherSuiteAndCred == -2146893007 )
      {
        LogCipherMismatchEvent(*(_DWORD *)(v99 + 212), (const unsigned __int16 *)(v99 + 216), a5);
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 34i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
      }
      goto LABEL_43;
    }
    AcceptableCipherSuiteAndCred = -2146892953;
    if ( (_DWORD)v8 )
    {
      if ( v12 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v12 + 28) & 4) == 0 )
        goto LABEL_145;
      v75 = 32i64;
    }
    else
    {
      if ( v12 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v12 + 28) & 1) == 0 )
        goto LABEL_145;
      v75 = 33i64;
    }
    WPP_SF_(*((_QWORD *)v12 + 2), v75, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
LABEL_145:
    CSslContext::SetErrorAndFatalAlert((__int64)a2, 1208, -2146892953, 0x78u);
    *((_DWORD *)a2 + 17) = 96;
    *((_WORD *)a2 + 48) = 30722;
    goto LABEL_43;
  }
  v45 = v41;
  v93 = v41;
  v90 = v40;
  v94 = v42;
  v85[0] = v43;
  v89 = v44;
  if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)v12 + 2), 31i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
    v43 = v84;
  }
LABEL_96:
  if ( v43 )
  {
LABEL_19:
    v21 = v90;
    v22 = *((_QWORD *)v90 + 106);
    if ( v22 )
      _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v22 + 16) + 12i64));
    _InterlockedIncrement((volatile signed __int32 *)(*((_QWORD *)v90 + 107) + 12i64));
    AcceptableCipherSuiteAndCred = 0;
    v23 = (*(__int64 (__fastcall **)(struct CSsl3TlsServerContext *))(*(_QWORD *)a2 + 248i64))(a2);
    v25 = *((_QWORD *)a2 + 1);
    v26 = v23;
    if ( v25 )
    {
      v76 = *(_QWORD *)(v25 + 848);
      if ( v76 )
        CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v76 + 16));
      CMasterCipherInfo::Dereference(*(CMasterCipherInfo **)(v25 + 856));
    }
    v27 = (CSslServerKey *)*((_QWORD *)a2 + 3);
    if ( v27 )
    {
      CSslServerKey::Dereference(v27);
      *((_QWORD *)a2 + 3) = 0i64;
    }
    v28 = v90;
    if ( v26 )
    {
      v29 = *(_QWORD *)v90;
      RtlAcquireResourceShared((PRTL_RESOURCE)(v26 + 552), 1u);
      v30 = *(_DWORD *)(v26 + 96);
      v31 = 0;
      if ( v30 )
      {
        while ( 1 )
        {
          v32 = *(_QWORD *)(*(_QWORD *)(v26 + 88) + 8i64 * v31);
          if ( *(_QWORD *)(v32 + 16) == v29 )
            break;
          if ( ++v31 >= v30 )
            goto LABEL_28;
        }
        _InterlockedIncrement((volatile signed __int32 *)(v32 + 24));
        v28 = v90;
        *((_QWORD *)a2 + 3) = *(_QWORD *)(*(_QWORD *)(v26 + 88) + 8i64 * v31);
      }
LABEL_28:
      RtlReleaseResource((PRTL_RESOURCE)(v26 + 552));
    }
    if ( (*((_DWORD *)a2 + 16) & 0xF3F00) != 0 )
    {
      AcceptableCipherSuiteAndCred = SslLookupCipherLengths(
                                       *(_QWORD *)v28,
                                       *((unsigned __int16 *)a2 + 17),
                                       *((unsigned int *)v28 + 7),
                                       *((unsigned int *)a2 + 4),
                                       Source1,
                                       20,
                                       0);
      if ( AcceptableCipherSuiteAndCred )
      {
LABEL_33:
        *((_WORD *)a2 + 16) |= 1u;
        *((_QWORD *)a2 + 1) = v28;
        if ( AcceptableCipherSuiteAndCred )
          goto LABEL_43;
        v34 = v89;
        if ( !a6 && *((_DWORD *)v28 + 12) == 3 || (v35 = a5, (a5 & 0x1000) != 0) )
        {
          *((_DWORD *)a2 + 4) = v89;
          v65 = (__int64 *)*((_QWORD *)v21 + 106);
          if ( v65 )
          {
            v24 = *((unsigned int *)v65 + 2);
            v66 = 0;
            if ( (_DWORD)v24 )
            {
              v67 = *v65;
              while ( 1 )
              {
                v68 = 780i64 * v66;
                if ( *(_DWORD *)(v68 + v67 + 772) == v34 )
                  break;
                if ( ++v66 >= (unsigned int)v24 )
                  goto LABEL_101;
              }
              if ( v68 + v67 )
                *((_DWORD *)a2 + 5) = *(_DWORD *)(v68 + v67 + 776);
            }
          }
LABEL_101:
          v35 = a5;
        }
        v36 = v85[0];
        if ( !v85[0] && (v35 & 0x1000) != 0 )
        {
          AcceptableCipherSuiteAndCred = (*(__int64 (__fastcall **)(struct CSsl3TlsServerContext *, _QWORD, _QWORD))(*(_QWORD *)a2 + 552i64))(
                                           a2,
                                           v34,
                                           *(_QWORD *)v28);
          if ( AcceptableCipherSuiteAndCred )
            goto LABEL_43;
        }
        v37 = v94;
        if ( !v94 )
        {
LABEL_39:
          if ( v36 )
          {
            *((_DWORD *)a2 + 17) = 71;
            v38 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
            {
              goto LABEL_43;
            }
            v81 = 35;
          }
          else if ( a6 )
          {
            v38 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
            {
              goto LABEL_43;
            }
            v81 = 36;
          }
          else
          {
            v38 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
            {
              goto LABEL_43;
            }
            v81 = 37;
          }
          WPP_SF_DS(*((_QWORD *)v38 + 2), v81, v24, *((_DWORD *)v28 + 7), (const wchar_t *)v28 + 37);
          goto LABEL_43;
        }
        v53 = *v94 + 1;
        if ( v53 < 2u )
        {
          v79 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_177;
          }
          v80 = 74i64;
LABEL_176:
          WPP_SF_(*((_QWORD *)v79 + 2), v80, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
LABEL_177:
          AcceptableCipherSuiteAndCred = -2146893018;
          goto LABEL_43;
        }
        v54 = v94;
        v55 = (unsigned __int64)&v94[v53];
        if ( (unsigned __int64)v94 < v55 )
        {
          while ( 1 )
          {
            v56 = *v54;
            if ( !(_BYTE)v56 )
              break;
            v57 = &v54[v56];
            if ( (unsigned __int64)v57 >= v55 )
              break;
            v54 = v57 + 1;
            if ( (unsigned __int64)v54 >= v55 )
              goto LABEL_73;
          }
          v79 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            goto LABEL_177;
          }
          v80 = 76i64;
          goto LABEL_176;
        }
LABEL_73:
        v58 = *((_QWORD *)a2 + 98);
        if ( !v58 )
        {
          AcceptableCipherSuiteAndCred = 87;
          goto LABEL_43;
        }
        v59 = (unsigned __int8 *)(v58 + 6);
        if ( v58 != -6 )
        {
          v60 = &v59[*(unsigned __int16 *)(v58 + 4)];
          if ( v59 < v60 )
          {
            while ( 1 )
            {
              v61 = v37;
              if ( (unsigned __int64)v37 < v55 )
                break;
LABEL_168:
              v59 += *v59 + 1;
              if ( v59 >= v60 )
                goto LABEL_169;
            }
            LOBYTE(v62) = *v59;
            while ( 1 )
            {
              if ( (_BYTE)v62 == *v61 )
              {
                v63 = RtlCompareMemory(v59 + 1, v61 + 1, (unsigned __int8)v62);
                v62 = *v59;
                if ( v63 == v62 )
                  break;
              }
              v61 += *v61 + 1;
              if ( (unsigned __int64)v61 >= v55 )
              {
                v37 = v94;
                goto LABEL_168;
              }
            }
            v64 = (_DWORD *)*((_QWORD *)a2 + 99);
            if ( !v64 )
            {
              v64 = (_DWORD *)(*(__int64 (__fastcall **)(struct CSsl3TlsServerContext *, __int64))(*(_QWORD *)a2 + 8i64))(
                                a2,
                                264i64);
              *((_QWORD *)a2 + 99) = v64;
              if ( !v64 )
              {
                AcceptableCipherSuiteAndCred = 14;
                goto LABEL_43;
              }
            }
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 61i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
              v64 = (_DWORD *)*((_QWORD *)a2 + 99);
            }
            *v64 = 1;
            *(_DWORD *)(*((_QWORD *)a2 + 99) + 4i64) = 2;
            *(_BYTE *)(*((_QWORD *)a2 + 99) + 8i64) = *v59;
            memcpy_0((void *)(*((_QWORD *)a2 + 99) + 9i64), v59 + 1, *v59);
            AcceptableCipherSuiteAndCred = 0;
            goto LABEL_39;
          }
        }
LABEL_169:
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 60i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
        AcceptableCipherSuiteAndCred = -2146892953;
        goto LABEL_145;
      }
    }
    else
    {
      v77 = *((_DWORD *)v28 + 3);
      v78 = *((_DWORD *)v28 + 4);
      *(_QWORD *)Source1 = 20i64;
      *(_QWORD *)&Source1[12] = 0i64;
      *(_DWORD *)&Source1[8] = v78;
      if ( v77 > 1 )
      {
        *(_DWORD *)&Source1[16] |= 1u;
        *(_DWORD *)&Source1[12] = v77;
      }
    }
    if ( (*((_BYTE *)a2 + 32) & 1) != 0 && RtlCompareMemory(Source1, (char *)a2 + 40, 0x14ui64) != 20 )
    {
      *((_WORD *)a2 + 16) |= 1u;
      AcceptableCipherSuiteAndCred = -2146893007;
      *((_QWORD *)a2 + 1) = v28;
      goto LABEL_43;
    }
    v33 = *(_DWORD *)&Source1[16];
    *(_OWORD *)((char *)a2 + 40) = *(_OWORD *)Source1;
    *((_DWORD *)a2 + 14) = v33;
    goto LABEL_33;
  }
LABEL_97:
  v69 = *(_QWORD *)a2;
  v87 = 0i64;
  (*(void (__fastcall **)(struct CSsl3TlsServerContext *, unsigned __int8 **))(v69 + 232))(a2, &v87);
  if ( v87 )
  {
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(v87 + 72), 1u);
    v70 = v99;
    *((_QWORD *)v87 + 42) = v45;
    *(_QWORD *)(v87 + 188) = *(_QWORD *)(v70 + 760);
    RtlReleaseResource((PRTL_RESOURCE)(v87 + 72));
    goto LABEL_19;
  }
LABEL_150:
  AcceptableCipherSuiteAndCred = -2146893052;
LABEL_43:
  RtlReleaseResource(&Resource);
  if ( *((_QWORD *)a2 + 121) )
  {
    (*(void (__fastcall **)(struct CSsl3TlsServerContext *))(*(_QWORD *)a2 + 16i64))(a2);
    *((_QWORD *)a2 + 121) = 0i64;
  }
  return AcceptableCipherSuiteAndCred;
}
// 18001B672: conditional instruction was optimized away because rdx.8!=0
// 18001B2AC: variable 'v14' is possibly undefined
// 18002FE63: variable 'v13' is possibly undefined
// 18002FE63: variable 'v15' is possibly undefined
// 18002FF76: variable 'v18' is possibly undefined
// 18002FF76: variable 'v19' is possibly undefined
// 18002FF76: variable 'v82' is possibly undefined
// 18003031D: variable 'v24' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180083D10: using guessed type wchar_t aNone[7];
// 1800984F0: using guessed type __int64 __fastcall SslLookupCipherLengths(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);
// 18001B0B0: using guessed type unsigned __int8 var_4DE[2];
// 18001B0B0: using guessed type char var_432[498];

//----- (000000018001B930) ----------------------------------------------------
__int64 __fastcall CSslCredential::IsServerCredApplicable(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        int a4,
        __int64 a5,
        struct _TLS_PARAMETERS *a6,
        unsigned int a7,
        PCUNICODE_STRING String2,
        char a9)
{
  int v9; // esi
  int v12; // ebx
  _DWORD *v13; // rax
  int v14; // r14d
  unsigned int v15; // r12d
  CCipherMill *v16; // r10
  __int64 v17; // r12
  const wchar_t *v18; // rbx
  int v19; // eax
  unsigned int v20; // r9d
  struct _TLS_PARAMETERS *v21; // r15
  const UNICODE_STRING *v22; // r13
  struct _TLS_PARAMETERS *v23; // rbx
  struct _TLS_PARAMETERS *v24; // r14
  int v25; // eax
  unsigned int v26; // r11d
  int v27; // eax
  _DWORD *v28; // rdx
  unsigned __int8 i; // r9
  int v30; // ebx
  int v31; // ecx
  int v32; // edx
  unsigned __int16 v33; // r8
  unsigned __int16 v34; // cx
  unsigned __int16 v35; // r8
  unsigned __int16 v36; // cx
  int v37; // r8d
  __int64 v38; // rdx
  int v39; // ebx
  struct _CERT_INFO *v40; // rdx
  unsigned int v42; // ebp
  unsigned __int64 v43; // rbp
  unsigned int v44; // eax
  unsigned int v45; // eax
  int v46; // r9d
  bool v47; // zf
  int v48; // eax
  int v49; // eax
  __int64 v50; // [rsp+20h] [rbp-68h]
  PCUNICODE_STRING v51; // [rsp+28h] [rbp-60h]
  unsigned int v52; // [rsp+40h] [rbp-48h]
  int v53; // [rsp+48h] [rbp-40h]
  unsigned int pbKeyUsage; // [rsp+90h] [rbp+8h] BYREF
  int v55; // [rsp+A0h] [rbp+18h]
  int v56; // [rsp+A8h] [rbp+20h]

  v56 = a4;
  v9 = 0;
  v12 = 0;
  if ( a3 )
    v12 = *(_DWORD *)(a3 + 772);
  v13 = *(_DWORD **)(a1 + 32);
  if ( !v13 )
    return 0i64;
  if ( *v13 != 1 )
    return 0i64;
  if ( !a2 )
    return 0i64;
  v14 = *(_DWORD *)(a2 + 32);
  v15 = *(_DWORD *)(a2 + 36);
  v55 = v14;
  v52 = v15;
  if ( !*(_QWORD *)(a1 + 432) && !*(_DWORD *)(a1 + 132) )
    return 0i64;
  if ( v14 == 41984 && *(_DWORD *)(a1 + 124) == 1 )
  {
    v46 = *(_DWORD *)(a1 + 128);
    if ( v46 != 1 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
        WPP_SF_d(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x2Au,
          (__int64)&WPP_221bc911720835f3baa7a86739b227e3_Traceguids,
          v46);
      return 0i64;
    }
  }
  v16 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_DD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x2Bu,
      (__int64)&WPP_221bc911720835f3baa7a86739b227e3_Traceguids,
      v15,
      *(_DWORD *)(a1 + 132));
    v16 = WPP_GLOBAL_Control;
  }
  if ( v15 == 9216 )
  {
    if ( ((*(_DWORD *)(a1 + 132) - 9216) & 0xFFFF7FFF) != 0 )
      return 0i64;
    goto LABEL_13;
  }
  if ( v15 == 8704 )
  {
    v47 = *(_DWORD *)(a1 + 132) == 8704;
LABEL_113:
    if ( !v47 )
      return 0i64;
    goto LABEL_13;
  }
  if ( v15 != 8707 )
  {
    if ( v15 != 41984 )
    {
      if ( !v15 || *(_DWORD *)(a1 + 132) == v15 )
        goto LABEL_13;
      if ( v16 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v16 + 28) & 2) != 0 )
        WPP_SF_D(*((_QWORD *)v16 + 2), 45i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids, v15);
      return 0i64;
    }
    v47 = *(_DWORD *)(a1 + 132) == 41984;
    goto LABEL_113;
  }
  if ( *(_DWORD *)(a1 + 132) != 8707 )
    return 0i64;
  if ( v12 != *(_DWORD *)(a1 + 140) )
  {
    if ( v16 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v16 + 28) & 2) != 0 )
    {
      LODWORD(v50) = *(_DWORD *)(a1 + 140);
      WPP_SF_DD(*((_QWORD *)v16 + 2), 0x2Cu, (__int64)&WPP_221bc911720835f3baa7a86739b227e3_Traceguids, v12, v50);
    }
    return 0i64;
  }
LABEL_13:
  v17 = a7;
  v53 = 3;
  if ( !a7 )
    goto LABEL_33;
  v18 = (const wchar_t *)(a1 + 272);
  v19 = *(_DWORD *)(a1 + 132);
  v20 = v19 == 8707 ? *(_DWORD *)(a1 + 136) : *(_DWORD *)(a1 + 428);
  v21 = a6;
  pbKeyUsage = v20;
  if ( !a6 || !v19 || a1 == -144 || a1 == -272 )
    goto LABEL_33;
  if ( v19 == 8707 )
  {
    if ( a3
      && IsEcdsaAlgorithmBlacklisted(a6, a7, (const unsigned __int16 *)a3, *(_DWORD *)(a3 + 772), v20, String2, a9) )
    {
      return 0i64;
    }
  }
  else if ( v19 == 8704 )
  {
    if ( IsCngAlgorithmBlacklisted((unsigned __int64)a6, a7, 1, L"DSA", 0i64, v20, String2, a9) )
      return 0i64;
  }
  else
  {
    v22 = String2;
    if ( v19 == 41984 )
    {
      if ( v14 == 41984 && IsRsaAlgorithmBlacklisted((unsigned __int64)a6, a7, 0, v20, String2, a9) )
        return 0i64;
      goto LABEL_24;
    }
    if ( v19 == 9216 )
    {
LABEL_24:
      v23 = v21;
      v24 = (struct _TLS_PARAMETERS *)((char *)v21 + 40 * v17);
      if ( v21 < v24 )
      {
        while ( 1 )
        {
          if ( *((_DWORD *)v23 + 5) )
          {
            if ( !*(_DWORD *)v23 )
              goto LABEL_75;
            if ( v22 )
              break;
          }
LABEL_28:
          v23 = (struct _TLS_PARAMETERS *)((char *)v23 + 40);
          if ( v23 >= v24 )
            goto LABEL_29;
        }
        v42 = 0;
        while ( RtlCompareUnicodeString((PCUNICODE_STRING)(*((_QWORD *)v23 + 1) + 16i64 * v42), v22, 1u) )
        {
          if ( ++v42 >= *(_DWORD *)v23 )
            goto LABEL_28;
        }
LABEL_75:
        if ( a9 && (*((_BYTE *)v23 + 32) & 1) != 0 )
          goto LABEL_28;
        v43 = *((_QWORD *)v23 + 3);
        if ( v43 >= v43 + 48i64 * *((unsigned int *)v23 + 5) )
          goto LABEL_28;
        while ( 1 )
        {
          if ( *(_DWORD *)v43 != 1 || *(_WORD *)(v43 + 8) != 6 || wcsncmp(*(const wchar_t **)(v43 + 16), L"RSA", 3ui64) )
            goto LABEL_79;
          if ( !*(_DWORD *)(v43 + 24) && !*(_DWORD *)(v43 + 40) && !*(_DWORD *)(v43 + 44) )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              LODWORD(v50) = 1;
              WPP_SF_Sd(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0xCu,
                (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
                L"RSA",
                v50);
            }
            return 0i64;
          }
          if ( !pbKeyUsage )
            goto LABEL_79;
          v44 = *(_DWORD *)(v43 + 40);
          if ( v44 )
          {
            if ( v44 > pbKeyUsage )
              goto LABEL_134;
            v45 = *(_DWORD *)(v43 + 44);
            if ( !v45 )
              goto LABEL_79;
          }
          else
          {
            if ( !*(_DWORD *)(v43 + 44) )
              goto LABEL_79;
            v45 = *(_DWORD *)(v43 + 44);
          }
          if ( v45 < pbKeyUsage )
          {
LABEL_134:
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              LODWORD(v51) = 1;
              LODWORD(v50) = pbKeyUsage;
              WPP_SF_Sdd(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0xEu,
                (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
                L"RSA",
                v50,
                v51);
            }
            return 0i64;
          }
LABEL_79:
          v43 += 48i64;
          if ( v43 >= *((_QWORD *)v23 + 3) + 48 * (unsigned __int64)*((unsigned int *)v23 + 5) )
            goto LABEL_28;
        }
      }
LABEL_29:
      v14 = v55;
      v18 = (const wchar_t *)(a1 + 272);
    }
  }
  if ( IsCngAlgorithmBlacklisted((unsigned __int64)v21, v17, 4, (const wchar_t *)(a1 + 144), 0i64, 0, 0i64, 1)
    || IsCngAlgorithmBlacklisted((unsigned __int64)v21, v17, 4, v18, 0i64, 0, 0i64, 1) )
  {
    return 0i64;
  }
  v16 = WPP_GLOBAL_Control;
LABEL_33:
  if ( !a5 )
    goto LABEL_57;
  v25 = *(_DWORD *)(a1 + 132);
  v26 = *(_DWORD *)(a1 + 428);
  if ( v25 != 41984 )
  {
    v48 = v25 - 8704;
    if ( !v48 )
    {
      v27 = 2;
      goto LABEL_36;
    }
    v49 = v48 - 3;
    if ( !v49 )
    {
      v27 = 3;
      goto LABEL_37;
    }
    if ( v49 != 509 )
      return 0i64;
  }
  v27 = 1;
LABEL_36:
  v53 = v27;
LABEL_37:
  v28 = &unk_18007C3A8;
  for ( i = 0; ; ++i )
  {
    v30 = v28[1];
    if ( v30 == v27
      && (v56 & *v28) != 0
      && (!v26 || v27 != 1 || v28[9] != 8 || v26 >> 3 >= 2 * (unsigned int)*((unsigned __int8 *)v28 + 32) + 2)
      && ((v56 & 0x3000) == 0 || v30 != 3 || v28[10] == *(_DWORD *)(a1 + 140))
      && i < 0xCu )
    {
      v31 = *(unsigned __int16 *)(a5 + 34);
      if ( _bittest(&v31, i) )
        break;
    }
    v28 += 18;
    if ( v28 - 6 >= (_DWORD *)&CSsl3TlsServerContext::`vftable' )
      return 0i64;
    v27 = v53;
  }
  if ( a1 == -512 )
    return 2i64;
  if ( !*(_WORD *)(a1 + 512) )
    return 2i64;
  v32 = *(unsigned __int16 *)(a1 + 546);
  if ( !(_WORD)v32 )
    return 2i64;
  v33 = (CTlsSignatureSuiteList::RsaSha256Flags & (unsigned __int16)v31) != 0
      ? CTlsSignatureSuiteList::RsaSha256Flags
      : 0;
  v34 = v33 | v31;
  v35 = (CTlsSignatureSuiteList::RsaSha384Flags & v34) != 0 ? CTlsSignatureSuiteList::RsaSha384Flags : 0;
  v36 = v35 | v34;
  v37 = (CTlsSignatureSuiteList::RsaSha512Flags & v36) != 0 ? CTlsSignatureSuiteList::RsaSha512Flags : 0;
  if ( (~(v37 | v36) & v32) != 0 )
    return 2i64;
LABEL_57:
  v38 = *(_QWORD *)(a1 + 32);
  if ( !v38 )
    return 2i64;
  if ( v52 != 9216 )
    goto LABEL_68;
  if ( v14 != 44550 )
  {
    if ( v14 == 41984 )
    {
      v39 = 32;
      goto LABEL_61;
    }
    if ( v14 != 43522 )
      goto LABEL_68;
  }
  v39 = 128;
LABEL_61:
  v40 = *(struct _CERT_INFO **)(v38 + 24);
  pbKeyUsage = 0;
  if ( CertGetIntendedKeyUsage(0x10001u, v40, (BYTE *)&pbKeyUsage, 4u) )
  {
    if ( (pbKeyUsage & v39) != 0 )
      v9 = 1;
    v16 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
    {
      LODWORD(v50) = v39;
      WPP_SF_DD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x14u,
        (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
        pbKeyUsage,
        v50);
      v16 = WPP_GLOBAL_Control;
    }
    if ( v9 )
      goto LABEL_68;
    return 2i64;
  }
  v16 = WPP_GLOBAL_Control;
LABEL_68:
  if ( v16 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v16 + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)v16 + 2), 46i64, &WPP_221bc911720835f3baa7a86739b227e3_Traceguids, v52);
  return 1i64;
}
// 1800306CF: variable 'v50' is possibly undefined
// 1800305E3: variable 'v51' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';
// 180092800: using guessed type unsigned __int16 CTlsSignatureSuiteList::RsaSha512Flags;
// 180092804: using guessed type unsigned __int16 CTlsSignatureSuiteList::RsaSha384Flags;
// 180092808: using guessed type unsigned __int16 CTlsSignatureSuiteList::RsaSha256Flags;

//----- (000000018001BE70) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::EccGenerateServerExchangeValue(
        CSsl3TlsServerContext *this,
        unsigned __int8 *a2,
        unsigned int *a3)
{
  int v3; // r15d
  __int64 v4; // rax
  int v5; // r14d
  CSsl3TlsServerContext *v6; // rbp
  __int16 v7; // r12
  int v8; // ecx
  int v9; // r13d
  struct CEphemKeyData **v10; // rdi
  struct CEphemKeyData *v11; // rax
  unsigned int v12; // esi
  __int64 v13; // rax
  __int64 v14; // rbx
  __int64 v15; // r15
  __int64 *v16; // rax
  struct CEphemKeyData **v17; // rbp
  unsigned int v18; // eax
  unsigned int EphemeralKeyInfo; // ebx
  struct _BCRYPT_ECCKEY_BLOB *v20; // rax
  unsigned int cbKey; // ecx
  int v22; // edi
  int v23; // esi
  __int64 v24; // rax
  __int64 v25; // rax
  unsigned int v26; // esi
  unsigned __int8 v27; // r11
  _DWORD *v28; // rax
  unsigned __int8 v29; // r8
  __int16 v30; // r15
  unsigned __int8 v31; // bl
  __int64 v32; // r10
  int v33; // r9d
  int v34; // ecx
  unsigned __int8 v35; // cl
  void **v36; // rdx
  __int64 v37; // rdx
  __int64 v38; // r8
  DWORD v39; // r9d
  DWORD v40; // ebx
  __int64 *v41; // rcx
  __int64 v42; // rax
  int v43; // eax
  __int64 v44; // rax
  __int64 v45; // rdx
  __int64 *v46; // rax
  __int64 v47; // rcx
  unsigned int v48; // esi
  unsigned __int8 *v50; // r10
  unsigned int v51; // esi
  struct _BCRYPT_ECCKEY_BLOB *v52; // rax
  ULONG v53; // ebx
  unsigned __int8 v54; // bl
  unsigned __int8 v55; // al
  unsigned int v56; // esi
  unsigned __int8 *v57; // rdi
  ULONG v58; // r8d
  __int16 v59; // cx
  int v60; // r13d
  unsigned int v61; // eax
  char *v62; // rax
  __int64 v63; // rcx
  unsigned __int8 v64; // r9
  __int64 v65; // rax
  unsigned __int8 v66[4]; // [rsp+40h] [rbp-C8h] BYREF
  DWORD cbSignature; // [rsp+44h] [rbp-C4h] BYREF
  int v68; // [rsp+48h] [rbp-C0h]
  enum _eTlsHashAlgorithm v69; // [rsp+4Ch] [rbp-BCh]
  CSsl3TlsServerContext *v70; // [rsp+50h] [rbp-B8h]
  unsigned int v71; // [rsp+58h] [rbp-B0h]
  int v72; // [rsp+5Ch] [rbp-ACh] BYREF
  unsigned __int8 *v73; // [rsp+60h] [rbp-A8h]
  unsigned int *v74; // [rsp+68h] [rbp-A0h]
  struct _BCRYPT_ECCKEY_BLOB *v75; // [rsp+70h] [rbp-98h]
  unsigned __int16 *v76; // [rsp+78h] [rbp-90h]
  BYTE pbHashValue[64]; // [rsp+80h] [rbp-88h] BYREF

  v4 = *((_QWORD *)this + 1);
  v5 = 0;
  LOBYTE(v3) = 0;
  v70 = this;
  v6 = this;
  v74 = a3;
  v73 = a2;
  v7 = 0;
  v8 = *(_DWORD *)(v4 + 52);
  v72 = 0;
  v76 = 0i64;
  v68 = v3;
  v66[0] = 0;
  v69 = TlsHashAlgorithm_None;
  v71 = 0;
  if ( v8 == 2 )
  {
    v9 = 1;
  }
  else
  {
    if ( v8 != 4 )
      return 1359;
    v9 = 3;
  }
  v10 = (struct CEphemKeyData **)((char *)v6 + 960);
  v11 = (struct CEphemKeyData *)*((_QWORD *)v6 + 120);
  if ( !v11 )
  {
    v12 = *((_DWORD *)v6 + 4);
    v13 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)v6 + 248i64))(v6);
    v14 = v13;
    if ( !v12 )
    {
      EphemeralKeyInfo = CSslCredential::GetEphemeralKeyInfo(
                           (CSslCredential *)v13,
                           0,
                           (struct CEphemKeyData **)(v13 + 496),
                           (struct CEphemKeyData **)v6 + 120);
      if ( EphemeralKeyInfo == 87 )
      {
        v5 = 1;
        goto LABEL_96;
      }
      goto LABEL_11;
    }
    if ( v12 == *(_DWORD *)(v13 + 140) )
    {
      v17 = (struct CEphemKeyData **)(v13 + 504);
      goto LABEL_10;
    }
    *v10 = 0i64;
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(v13 + 552), 1u);
    v15 = v14 + 480;
    v16 = *(__int64 **)(v14 + 480);
    if ( v16 != (__int64 *)(v14 + 480) )
    {
      while ( *((_DWORD *)v16 + 4) != v12 )
      {
        v16 = (__int64 *)*v16;
        if ( v16 == (__int64 *)v15 )
          goto LABEL_89;
      }
      v17 = (struct CEphemKeyData **)(v16 + 3);
      if ( v16 != (__int64 *)-24i64 )
      {
LABEL_9:
        RtlReleaseResource((PRTL_RESOURCE)(v14 + 552));
        LOBYTE(v3) = v68;
LABEL_10:
        v18 = CSslCredential::GetEphemeralKeyInfo((CSslCredential *)v14, v12, v17, v10);
        v6 = v70;
        EphemeralKeyInfo = v18;
LABEL_11:
        if ( !EphemeralKeyInfo )
        {
          *(_DWORD *)(*((_QWORD *)v6 + 11) + 8i64) = *((_DWORD *)*v10 + 10);
          v11 = *v10;
          goto LABEL_13;
        }
LABEL_96:
        v64 = 40;
        if ( !v5 )
          v64 = 80;
        CSslContext::SetErrorAndFatalAlert((__int64)v6, 603, EphemeralKeyInfo, v64);
        CSslContext::SetErrorAndFatalAlert((__int64)v6, 1050, EphemeralKeyInfo, 0x50u);
        return EphemeralKeyInfo;
      }
      v6 = v70;
    }
LABEL_89:
    v62 = (char *)LocalAlloc(0x40u, 0x20ui64);
    if ( !v62 )
    {
      RtlReleaseResource((PRTL_RESOURCE)(v14 + 552));
      EphemeralKeyInfo = 14;
      goto LABEL_96;
    }
    *((_DWORD *)v62 + 4) = v12;
    *((_QWORD *)v62 + 1) = v62;
    *(_QWORD *)v62 = v62;
    v63 = *(_QWORD *)v15;
    if ( *(_QWORD *)(*(_QWORD *)v15 + 8i64) != v15 )
      __fastfail(3u);
    *(_QWORD *)v62 = v63;
    v17 = (struct CEphemKeyData **)(v62 + 24);
    *((_QWORD *)v62 + 1) = v15;
    *(_QWORD *)(v63 + 8) = v62;
    *(_QWORD *)v15 = v62;
    goto LABEL_9;
  }
LABEL_13:
  v20 = (struct _BCRYPT_ECCKEY_BLOB *)*((_QWORD *)v11 + 2);
  v75 = v20;
  if ( !v20 )
    return 87;
  cbKey = v20->cbKey;
  if ( (*((_BYTE *)v6 + 20) & 8) != 0 )
  {
    v3 = (unsigned __int8)v3;
    if ( cbKey <= 0xFF )
      v3 = (unsigned __int8)cbKey;
    EphemeralKeyInfo = 87;
    if ( cbKey <= 0xFF )
      EphemeralKeyInfo = 0;
    goto LABEL_17;
  }
  if ( cbKey <= 0x7F )
  {
    v3 = 2 * cbKey + 1;
    EphemeralKeyInfo = 0;
LABEL_17:
    v66[0] = v3;
    v68 = v3;
    goto LABEL_18;
  }
  EphemeralKeyInfo = 1359;
LABEL_18:
  if ( EphemeralKeyInfo )
    return EphemeralKeyInfo;
  v22 = *((_DWORD *)v6 + 16);
  v23 = (unsigned __int8)v3 + 6;
  if ( (v22 & 0x40400) == 0 )
  {
LABEL_38:
    memset_0(pbHashValue, 0, sizeof(pbHashValue));
    cbSignature = 0;
    v39 = 0;
    if ( (v22 & 0x43C00) != 0 )
    {
      v38 = (unsigned int)g_dwHashInfoTotalCount;
      v40 = 0;
      v37 = 0i64;
      if ( g_dwHashInfoTotalCount )
      {
        v41 = g_pHashInfo;
        while ( 1 )
        {
          v42 = *v41;
          if ( *v41 )
          {
            if ( *(_DWORD *)(v42 + 20) == v69 )
              break;
          }
          v37 = (unsigned int)(v37 + 1);
          ++v41;
          if ( (unsigned int)v37 >= g_dwHashInfoTotalCount )
            goto LABEL_112;
        }
        v40 = *(_DWORD *)(v42 + 8);
        v43 = 0;
      }
      else
      {
LABEL_112:
        v43 = 1168;
      }
      if ( v43 )
      {
LABEL_58:
        EphemeralKeyInfo = v43;
        if ( v43 >= 0 )
        {
          if ( v39 <= 0x8C )
            v39 = 140;
          v48 = v39 + v23;
          if ( !v73 )
          {
            *v74 = v48;
            return 0;
          }
          if ( *v74 < v48 )
          {
            *v74 = v48;
            return (unsigned int)-2146893023;
          }
          EphemeralKeyInfo = SslImpersonateClient(*(_QWORD *)(*((_QWORD *)v6 + 10) + 752i64), &v72);
          if ( EphemeralKeyInfo )
            goto LABEL_81;
          v50 = v73;
          v51 = v48 - 3;
          *v73 = 3;
          v50[1] = BYTE1(*((_DWORD *)v6 + 4));
          v50[2] = *((_BYTE *)v6 + 16);
          if ( (*((_BYTE *)v6 + 20) & 8) != 0 )
          {
            EphemeralKeyInfo = MontgomeryGetKeyExchangeBlob(v75, v50 + 4, v66);
            v55 = v66[0];
          }
          else
          {
            v52 = v75;
            v53 = v75->cbKey;
            if ( v53 > 0x7F )
            {
              v55 = v68;
              EphemeralKeyInfo = 1359;
              goto LABEL_72;
            }
            v54 = 2 * v53 + 1;
            if ( v50 == (unsigned __int8 *)-4i64 )
            {
              v55 = v54;
              EphemeralKeyInfo = 0;
              goto LABEL_72;
            }
            if ( (unsigned __int8)v3 < v54 )
            {
              v55 = v54;
              EphemeralKeyInfo = -2146893023;
              goto LABEL_72;
            }
            v50[4] = 4;
            memcpy_0(v50 + 5, &v52[1], v54 - 1i64);
            v55 = v54;
            EphemeralKeyInfo = 0;
          }
          v50 = v73;
LABEL_72:
          if ( EphemeralKeyInfo )
            goto LABEL_81;
          v50[3] = v55;
          v56 = -1 - v55 + v51;
          v57 = &v50[v55 + 4];
          v58 = v55 + 4;
          if ( (*((_DWORD *)v6 + 16) & 0x40400) == 0 )
          {
LABEL_76:
            v59 = v56 - 2;
            cbSignature = v56 - 2;
            v60 = v9 - 1;
            if ( v60 )
            {
              if ( v60 != 2 )
              {
LABEL_80:
                *v57 = HIBYTE(v59);
                v57[1] = cbSignature;
                *v74 = (_DWORD)v57 - (_DWORD)v50 + cbSignature + 2;
                goto LABEL_81;
              }
              v61 = SignEcdsaParams(v6, v50, v58, v69, v57 + 2, &cbSignature);
            }
            else
            {
              v61 = SignRsaParams(v6, v50, v58, v76, v69, v71, v57 + 2, &cbSignature);
            }
            EphemeralKeyInfo = v61;
            if ( v61 )
              goto LABEL_81;
            HIBYTE(v59) = BYTE1(cbSignature);
            LODWORD(v50) = (_DWORD)v73;
            goto LABEL_80;
          }
          if ( v56 >= 2 )
          {
            *(_WORD *)v57 = v7;
            v57 += 2;
            v56 -= 2;
            goto LABEL_76;
          }
          EphemeralKeyInfo = 1359;
LABEL_81:
          if ( v72 )
            RevertToSelf();
          return EphemeralKeyInfo;
        }
LABEL_117:
        CSslContext::SetErrorAndFatalAlert((__int64)v6, 1051, v43, 0x50u);
        return EphemeralKeyInfo;
      }
    }
    else
    {
      if ( v9 == 1 )
      {
        v40 = 36;
LABEL_52:
        if ( (v22 & 0x40051555) != 0 )
        {
          v44 = *((_QWORD *)v6 + 3);
          if ( v44 )
          {
            v45 = *(_QWORD *)(v44 + 8);
            v46 = (__int64 *)*((_QWORD *)v6 + 1);
            if ( v46 )
              v47 = *v46;
            else
              v47 = 0i64;
            v43 = SslSignHash(v47, v45, pbHashValue, v40, 0i64, 0, &cbSignature, 0);
            goto LABEL_57;
          }
        }
        else
        {
          v65 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, __int64, __int64, _QWORD))(*(_QWORD *)v6 + 248i64))(
                  v6,
                  v37,
                  v38,
                  0i64);
          if ( v65 )
          {
            v43 = NCryptSignHash(*(_QWORD *)(v65 + 104), 0i64, pbHashValue, v40, 0i64, cbSignature, &cbSignature, 0x40u);
LABEL_57:
            v39 = cbSignature;
            goto LABEL_58;
          }
        }
LABEL_116:
        EphemeralKeyInfo = -2146893052;
        v43 = -2146893052;
        goto LABEL_117;
      }
      v40 = 20;
    }
    if ( v40 > 0x40 )
      goto LABEL_116;
    goto LABEL_52;
  }
  v24 = *(_QWORD *)v6;
  LODWORD(v70) = (unsigned __int8)v3 + 8;
  v25 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(v24 + 248))(v6);
  if ( !v25 )
    return (unsigned int)-2146893052;
  v26 = *(_DWORD *)(v25 + 428);
  v27 = 0;
  v22 = *((_DWORD *)v6 + 16);
  v28 = &unk_18007C3A8;
  v29 = 0;
  v30 = 0;
  v31 = -1;
  v32 = 12i64;
  do
  {
    v33 = v28[1];
    if ( v33 == v9 && (v22 & *v28) != 0 && v29 < 0xCu )
    {
      v34 = *((unsigned __int16 *)v6 + 272);
      if ( _bittest(&v34, v29) )
      {
        if ( (v9 != 1 || v28[9] != 8 || v26 >> 3 >= 2 * (unsigned int)*((unsigned __int8 *)v28 + 32) + 2)
          && ((v22 & 0x3000) == 0 || v33 != 3 || !v28[10]) )
        {
          if ( (v35 = *((_BYTE *)v28 + 32), v35 < v27) && v35 > 0x14u || v27 <= 0x14u )
          {
            v31 = v29;
            v27 = *((_BYTE *)v28 + 32);
          }
        }
      }
    }
    v28 += 18;
    ++v29;
    --v32;
  }
  while ( v32 );
  v36 = (void **)&unk_18007C390;
  if ( v31 < 0xCu )
    v30 = *((_WORD *)&unk_18007C390 + 36 * v31);
  v7 = __ROR2__(v30, 8);
  if ( v7 )
  {
    while ( v30 != *(_WORD *)v36 )
    {
      v36 += 9;
      if ( v36 >= &CSsl3TlsServerContext::`vftable' )
        goto LABEL_37;
    }
    v69 = *((_DWORD *)v36 + 10);
    v76 = (unsigned __int16 *)v36[6];
    v71 = *((_DWORD *)v36 + 15);
LABEL_37:
    LOBYTE(v3) = v68;
    v23 = (int)v70;
    goto LABEL_38;
  }
  return 2148074289i64;
}
// 18003088E: conditional instruction was optimized away because r13d.4==3
// 18001BEC6: variable 'v3' is possibly undefined
// 1800308DD: variable 'v37' is possibly undefined
// 1800308DD: variable 'v38' is possibly undefined
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';
// 180092324: using guessed type int g_dwHashInfoTotalCount;
// 180092330: using guessed type _QWORD g_pHashInfo[16];
// 180098540: using guessed type __int64 __fastcall SslSignHash(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);
// 18001BE70: using guessed type unsigned __int8 var_C8[4];

//----- (000000018001C410) ----------------------------------------------------
__int64 __fastcall CCipherMill::FindAcceptableCipherSuiteAndCred(
        CCipherMill *this,
        struct CSsl3TlsServerContext *a2,
        unsigned int *a3,
        unsigned int a4,
        unsigned __int8 a5,
        struct _UNICODE_STRING *a6,
        unsigned __int8 a7,
        struct CCipherSuiteInfo **a8,
        struct CSslCredential **a9,
        unsigned int *a10,
        unsigned __int8 *a11)
{
  __int64 v11; // rbp
  struct CCipherSuiteInfo **v14; // r13
  struct CSslCredential **v15; // rax
  unsigned __int8 *v16; // rbx
  unsigned int *v17; // rcx
  unsigned int AcceptableCipherSuite; // ebx
  unsigned __int64 v19; // rsi
  __int64 v20; // rdi
  char v21; // r12
  enum _eTlsHashAlgorithm v22; // r9d
  int v23; // r11d
  __int64 v24; // rax
  CSessionCacheItem *v25; // rcx
  __int64 v26; // rax
  int v27; // edx
  CCipherMill *v28; // r10
  __int64 v29; // r8
  unsigned int *v30; // rdx
  unsigned int *v31; // rax
  unsigned int AcceptableCredential; // eax
  struct CSslCredential **v33; // rcx
  struct CSslCredential *v34; // rax
  struct CSslCredential **v36; // rcx
  unsigned int PrfHashDetails; // eax
  struct CSslCredential **v38; // rcx
  struct _UNICODE_STRING *v39; // [rsp+20h] [rbp-A8h]
  __int64 v40; // [rsp+28h] [rbp-A0h]
  unsigned __int8 v41; // [rsp+50h] [rbp-78h]
  int v42; // [rsp+54h] [rbp-74h]
  enum _eTlsHashAlgorithm v43; // [rsp+58h] [rbp-70h] BYREF
  unsigned int v44; // [rsp+5Ch] [rbp-6Ch] BYREF
  unsigned int v45; // [rsp+60h] [rbp-68h]
  struct CSslCredential *v46; // [rsp+68h] [rbp-60h] BYREF
  struct CCipherSuiteInfo *v47; // [rsp+70h] [rbp-58h]
  struct CSslCredential *v48; // [rsp+78h] [rbp-50h]
  unsigned __int64 v49; // [rsp+80h] [rbp-48h]
  bool v50; // [rsp+D0h] [rbp+8h]
  CSessionCacheItem *v51; // [rsp+D8h] [rbp+10h] BYREF

  v11 = a4;
  if ( !a2 )
    return 2148074333i64;
  if ( !a3 )
    return 2148074333i64;
  if ( !a4 )
    return 2148074333i64;
  v14 = a8;
  if ( !a8 )
    return 2148074333i64;
  v15 = a9;
  if ( !a9 )
    return 2148074333i64;
  if ( !a10 )
    return 2148074333i64;
  v16 = a11;
  if ( !a11 )
    return 2148074333i64;
  *a10 = 0;
  v17 = (unsigned int *)xmmword_1800925B0;
  *v15 = 0i64;
  if ( (*((_DWORD *)a2 + 34) & 0x20000000) != 0 )
    v17 = (unsigned int *)*(&xmmword_1800925B0 + 1);
  *v16 = 0;
  AcceptableCipherSuite = -2146893007;
  *v14 = 0i64;
  v47 = 0i64;
  v48 = 0i64;
  v45 = 0;
  v41 = 0;
  if ( !v17 || (v19 = *(_QWORD *)v17, v20 = v17[2], !*(_QWORD *)v17) || !(_DWORD)v20 )
  {
    AcceptableCipherSuite = -2146893052;
    goto LABEL_45;
  }
  v50 = (*((_DWORD *)a2 + 16) & 0x1000) != 0;
  v21 = a5;
  v22 = TlsHashAlgorithm_None;
  v43 = TlsHashAlgorithm_None;
  v23 = 0;
  v42 = 0;
  if ( a5 )
  {
    v24 = *(_QWORD *)a2;
    v51 = 0i64;
    (*(void (__fastcall **)(struct CSsl3TlsServerContext *, CSessionCacheItem **, unsigned int *, _QWORD))(v24 + 232))(
      a2,
      &v51,
      a3,
      0i64);
    if ( !v51 )
    {
      AcceptableCipherSuite = -2146893052;
      goto LABEL_45;
    }
    RtlAcquireResourceShared((PRTL_RESOURCE)((char *)v51 + 72), 1u);
    v25 = v51;
    if ( v50 )
    {
      PrfHashDetails = CSessionCacheItem::GetPrfHashDetails(v51, 0i64, &v43);
      v25 = v51;
      if ( PrfHashDetails )
      {
        AcceptableCipherSuite = PrfHashDetails;
        RtlReleaseResource((PRTL_RESOURCE)((char *)v51 + 72));
        goto LABEL_45;
      }
    }
    else
    {
      v26 = *((_QWORD *)v51 + 22);
      if ( v26 )
        v27 = *(_DWORD *)(v26 + 28);
      else
        v27 = 0;
      v42 = v27;
    }
    RtlReleaseResource((PRTL_RESOURCE)((char *)v25 + 72));
    v22 = v43;
    v23 = v42;
  }
  v49 = v19 + 864 * v20;
  if ( v19 >= v49 )
  {
LABEL_45:
    v36 = a9;
    *v14 = 0i64;
    *v36 = 0i64;
    *a10 = 0;
    *a11 = 0;
    return AcceptableCipherSuite;
  }
  v28 = WPP_GLOBAL_Control;
  while ( 1 )
  {
    v29 = *(unsigned int *)(v19 + 28);
    v46 = 0i64;
    v44 = 0;
    LOBYTE(v51) = 0;
    if ( !(_DWORD)v29 || (v30 = &a3[v11], v31 = a3, a3 >= v30) )
    {
LABEL_26:
      if ( v28 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v28 + 28) & 4) != 0 )
      {
        WPP_SF_S(
          *((_QWORD *)v28 + 2),
          0x26u,
          (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
          (const wchar_t *)(v19 + 74));
LABEL_57:
        v28 = WPP_GLOBAL_Control;
      }
LABEL_28:
      AcceptableCipherSuite = -2146893007;
      goto LABEL_29;
    }
    while ( (_DWORD)v29 != *v31 )
    {
      if ( ++v31 >= v30 )
        goto LABEL_26;
    }
    if ( v21 && v23 != (_DWORD)v29 && !v50 )
    {
      if ( v28 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v28 + 28) & 4) != 0 )
      {
        LODWORD(v40) = v23;
        LODWORD(v39) = v29;
        WPP_SF_SDD(*((_QWORD *)v28 + 2), 0x27u, v29, (const wchar_t *)(v19 + 74), v39, v40);
        goto LABEL_57;
      }
      goto LABEL_28;
    }
    AcceptableCipherSuite = CCipherMill::FindAcceptableCipherSuite(
                              (CCipherMill *)v17,
                              a2,
                              (struct CCipherSuiteInfo *)v19,
                              v21,
                              a6,
                              a7,
                              v22,
                              &v44,
                              (unsigned __int8 *)&v51);
    if ( AcceptableCipherSuite )
      goto LABEL_55;
    if ( *(_DWORD *)(v19 + 48) == 4 )
    {
      *v14 = (struct CCipherSuiteInfo *)v19;
      return AcceptableCipherSuite;
    }
    AcceptableCredential = CCipherMill::FindAcceptableCredential(
                             (CCipherMill *)v17,
                             a2,
                             (struct CCipherSuiteInfo *)v19,
                             v21,
                             a6,
                             a7,
                             &v46);
    AcceptableCipherSuite = AcceptableCredential;
    if ( !AcceptableCredential )
    {
      v33 = a9;
      v34 = v46;
      *v14 = (struct CCipherSuiteInfo *)v19;
      *v33 = v34;
      *a10 = v44;
      *a11 = (unsigned __int8)v51;
      return AcceptableCipherSuite;
    }
    if ( AcceptableCredential == -2146893007 && v46 && !v47 )
    {
      v48 = v46;
      v45 = v44;
      v41 = (unsigned __int8)v51;
      v47 = (struct CCipherSuiteInfo *)v19;
LABEL_55:
      v28 = WPP_GLOBAL_Control;
      goto LABEL_29;
    }
    v28 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      WPP_SF_S(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x28u,
        (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
        (const wchar_t *)(v19 + 74));
      v28 = WPP_GLOBAL_Control;
    }
LABEL_29:
    v19 += 864i64;
    if ( v19 >= v49 )
      break;
    v22 = v43;
    v23 = v42;
  }
  if ( !AcceptableCipherSuite )
    return AcceptableCipherSuite;
  if ( !v47 )
    goto LABEL_45;
  v38 = a9;
  AcceptableCipherSuite = 0;
  *v14 = v47;
  *v38 = v48;
  *a10 = v45;
  *a11 = v41;
  return AcceptableCipherSuite;
}
// 18001C6A4: variable 'v17' is possibly undefined
// 180030A87: variable 'v39' is possibly undefined
// 180030A87: variable 'v40' is possibly undefined

//----- (000000018001C7B0) ----------------------------------------------------
__int64 __fastcall CCipherMill::FindAcceptableCredential(
        CCipherMill *this,
        struct CSsl3TlsServerContext *a2,
        struct CCipherSuiteInfo *a3,
        char a4,
        struct _UNICODE_STRING *a5,
        unsigned __int8 a6,
        struct CSslCredential **a7)
{
  struct CSslCredential **v7; // r14
  int v10; // eax
  unsigned int v11; // esi
  __int64 v12; // rbp
  char v13; // r12
  int v14; // eax
  bool v15; // zf
  struct CSessionCacheServerItem *v16; // r13
  __int64 v17; // rbx
  __int64 v18; // r12
  __int64 v19; // rax
  _QWORD *v20; // r12
  void *v21; // r14
  _QWORD *v22; // rax
  int v23; // r13d
  __int64 v24; // rbp
  int IsServerCredApplicable; // eax
  char v26; // al
  char v27; // cl
  unsigned int v28; // ebp
  unsigned int *v30; // rax
  unsigned __int64 v31; // rdx
  int v32; // edx
  unsigned int v33; // r10d
  struct _TLS_PARAMETERS *v34; // r11
  const struct CTlsSignatureSuiteList *v35; // r8
  int v36; // r9d
  CCredentialGroup *v37; // rcx
  unsigned int v38; // eax
  SIZE_T v39; // rax
  unsigned int v40; // eax
  CCipherMill *v41; // rcx
  __int64 v42; // rdx
  __int64 v43; // rax
  _QWORD *v44; // [rsp+60h] [rbp-88h]
  struct CSessionCacheServerItem *v45; // [rsp+68h] [rbp-80h] BYREF
  const struct CTlsSignatureSuiteList *v46; // [rsp+70h] [rbp-78h]
  void *Source1; // [rsp+78h] [rbp-70h]
  unsigned int v48; // [rsp+80h] [rbp-68h]
  int v49; // [rsp+84h] [rbp-64h]
  __int64 v50; // [rsp+88h] [rbp-60h]
  struct _TLS_PARAMETERS *v51; // [rsp+90h] [rbp-58h]
  struct CSessionCacheServerItem *v52; // [rsp+98h] [rbp-50h]
  PRTL_RESOURCE Resource; // [rsp+A0h] [rbp-48h]
  char v54; // [rsp+F0h] [rbp+8h]
  struct CEccCurveInfo *v55; // [rsp+F0h] [rbp+8h]
  SIZE_T Length; // [rsp+F8h] [rbp+10h] BYREF

  v7 = a7;
  if ( a2 && a3 && a7 )
  {
    v10 = *((_DWORD *)a3 + 13);
    v11 = -2146893007;
    if ( v10 == 4 || *((_DWORD *)a2 + 16) == 4096 )
    {
      v12 = *((_QWORD *)a2 + 10);
      v45 = 0i64;
      v13 = 1;
      *a7 = 0i64;
      if ( v10 == 4 && !*(_BYTE *)(v12 + 900) )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 53i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
        return v11;
      }
    }
    else
    {
      v12 = *((_QWORD *)a2 + 10);
      v13 = 0;
      v45 = 0i64;
      *a7 = 0i64;
    }
    if ( a4 )
    {
      (*(void (__fastcall **)(struct CSsl3TlsServerContext *, struct CSessionCacheServerItem **))(*(_QWORD *)a2 + 232i64))(
        a2,
        &v45);
      if ( !v45 )
        return (unsigned int)-2146893052;
    }
    v14 = *((_DWORD *)a2 + 16);
    v46 = 0i64;
    v49 = v14;
    if ( (v14 & 0x41400) != 0 )
      v46 = (struct CSsl3TlsServerContext *)((char *)a2 + 510);
    if ( *(_BYTE *)(v12 + 900) && v13 )
    {
      v30 = (unsigned int *)*((_QWORD *)a3 + 106);
      Source1 = v30;
      if ( !v30 )
        return (unsigned int)-2146893052;
      v31 = *(_QWORD *)v30;
      v55 = *(struct CEccCurveInfo **)v30;
      if ( *(_QWORD *)v30 < *(_QWORD *)v30 + 780 * (unsigned __int64)v30[2] )
      {
        v18 = 0i64;
        while ( 1 )
        {
          v11 = CSsl3TlsServerContext::LookupEccCurveType(a2, *(_DWORD *)(v31 + 772));
          if ( !v11 )
          {
            v32 = *((_DWORD *)a2 + 34);
            v33 = *(_DWORD *)(v12 + 196);
            v34 = *(struct _TLS_PARAMETERS **)(v12 + 200);
            v35 = v46;
            v36 = *((_DWORD *)a2 + 16);
            if ( !*((_BYTE *)a2 + 925) )
              v35 = 0i64;
            v37 = (CCredentialGroup *)*((_QWORD *)a2 + 10);
            Length = 0i64;
            v38 = CCredentialGroup::PickServerCredential(
                    v37,
                    a3,
                    v55,
                    v36,
                    (v32 & 0x8000000) != 0i64,
                    v35,
                    v34,
                    v33,
                    a5,
                    a6,
                    v45,
                    (struct CSslCredential **)&Length);
            v11 = v38;
            if ( !v38 )
            {
              *v7 = (struct CSslCredential *)Length;
              return v11;
            }
            if ( v38 == -2146893007 && !v18 && (v39 = Length) != 0 )
            {
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
              {
                WPP_SF_D(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  56i64,
                  &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
                  *((unsigned int *)v55 + 193));
                v39 = Length;
              }
              v18 = v39;
            }
            else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                   && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_D(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                57i64,
                &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
                *((unsigned int *)v55 + 193));
            }
          }
          v31 = (unsigned __int64)v55 + 780;
          v55 = (struct CEccCurveInfo *)v31;
          if ( v31 >= *(_QWORD *)Source1 + 780 * (unsigned __int64)*((unsigned int *)Source1 + 2) )
            goto LABEL_89;
        }
      }
      return v11;
    }
    v15 = *((_BYTE *)a2 + 925) == 0;
    v16 = v45;
    v48 = *(_DWORD *)(v12 + 196);
    v51 = *(struct _TLS_PARAMETERS **)(v12 + 200);
    v52 = v45;
    if ( v15 )
      v46 = 0i64;
    v54 = (*((_DWORD *)a2 + 34) & 0x8000000) != 0i64;
    v15 = *(_DWORD *)(v12 + 28) == 0;
    v17 = 0i64;
    v50 = 0i64;
    v18 = 0i64;
    Source1 = 0i64;
    LODWORD(Length) = 0;
    if ( v15 )
      goto LABEL_85;
    if ( (*(_BYTE *)(v12 + 156) & 0x40) != 0 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 37i64, &WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids);
      v40 = CCredentialGroup::CheckForCredentialRenewal((CCredentialGroup *)v12);
      if ( v40 )
      {
        v28 = v40;
        v11 = v40;
        goto LABEL_70;
      }
    }
    Resource = (PRTL_RESOURCE)(v12 + 48);
    RtlAcquireResourceShared((PRTL_RESOURCE)(v12 + 48), 1u);
    if ( v16 )
    {
      RtlAcquireResourceShared((PRTL_RESOURCE)((char *)v16 + 72), 1u);
      v19 = *((_QWORD *)v16 + 42);
      if ( v19 )
      {
        LODWORD(Length) = 20;
        Source1 = (void *)(v19 + 40);
      }
    }
    v20 = *(_QWORD **)(v12 + 32);
    v44 = (_QWORD *)(v12 + 32);
    if ( v20 == (_QWORD *)(v12 + 32) )
    {
LABEL_30:
      v28 = v11;
      if ( v16 )
        RtlReleaseResource((PRTL_RESOURCE)((char *)v16 + 72));
      RtlReleaseResource(Resource);
      if ( v17 )
        v18 = v17;
      else
        v18 = v50;
      if ( !v11 )
        goto LABEL_35;
LABEL_70:
      if ( v28 == -2146893007 && v18 )
      {
        v41 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          v42 = 54i64;
LABEL_88:
          WPP_SF_(*((_QWORD *)v41 + 2), v42, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
          goto LABEL_89;
        }
        goto LABEL_89;
      }
LABEL_85:
      v41 = WPP_GLOBAL_Control;
      v18 = 0i64;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        v42 = 55i64;
        goto LABEL_88;
      }
LABEL_89:
      if ( v11 && v18 )
      {
        v11 = -2146893007;
LABEL_35:
        *v7 = (struct CSslCredential *)v18;
      }
      return v11;
    }
    v21 = Source1;
    v22 = (_QWORD *)(v12 + 32);
    v23 = Length;
    while ( 1 )
    {
      v24 = (__int64)(v20 - 1);
      v20 = (_QWORD *)*v20;
      if ( !v21 )
        goto LABEL_25;
      if ( v24 == -40 || v23 != 20 )
        goto LABEL_82;
      if ( RtlCompareMemory(v21, (const void *)(v24 + 40), 0x14ui64) == 20 )
      {
LABEL_25:
        IsServerCredApplicable = CSslCredential::IsServerCredApplicable(
                                   v24,
                                   (__int64)a3,
                                   0i64,
                                   v49,
                                   (__int64)v46,
                                   v51,
                                   v48,
                                   a5,
                                   a6);
        if ( IsServerCredApplicable == 1 )
        {
          if ( !v17 || (v26 = *(_BYTE *)(v24 + 80), v27 = v54, v26 != v54) )
          {
            v26 = *(_BYTE *)(v24 + 80);
            v17 = v24;
            v11 = 0;
            v27 = v54;
          }
          if ( v26 != v27 )
          {
LABEL_29:
            v7 = a7;
            v16 = v52;
            goto LABEL_30;
          }
        }
        else if ( IsServerCredApplicable == 2 )
        {
          v43 = v50;
          if ( !v50 )
            v43 = v24;
          v50 = v43;
        }
      }
      v22 = v44;
LABEL_82:
      if ( v20 == v22 )
        goto LABEL_29;
    }
  }
  return 2148074333i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082B38: using guessed type GUID WPP_2ffbdd3159b83638eae39e16ce6a3c9c_Traceguids;

//----- (000000018001CB30) ----------------------------------------------------
__int64 __fastcall CTls13ExtServer::ParseExtension(__int64 a1, int a2, unsigned __int8 *a3, __int64 a4)
{
  unsigned __int16 v5; // si
  int v7; // r8d
  unsigned int v9; // eax
  __int64 result; // rax

  v5 = a4;
  v7 = (unsigned __int8)*(_DWORD *)(a1 + 16);
  v9 = v7 | (a2 << 8);
  if ( v9 >= 0x2901 )
  {
    switch ( v9 )
    {
      case 0x2901u:
        return CTls13ExtServer::ParsePreSharedKeyExtension((CTls13ExtServer *)a1, a3, a4, a4);
      case 0x2B01u:
        return CTls13ExtServer::ParseSupportedVersionsExtension((CTls13ExtServer *)a1, a3, a4);
      case 0x2D01u:
        return CTls13ExtServer::ParsePskKeyExchangeModesExtension((CTls13ExtServer *)a1, a3, a4, a4);
      case 0x3101u:
        if ( (_WORD)a4 )
          return 2148074248i64;
        *(_BYTE *)(*(_QWORD *)(a1 + 40) + 1506i64) = 1;
        return 0i64;
      case 0x3301u:
        return CTls13ExtServer::ParseKeyShareExtension((CTls13ExtServer *)a1, a3, a4);
    }
  }
  if ( (_WORD)a2 != 57 && (_WORD)a2 != 0xFFA5 )
    return CTlsExtServer::ParseExtension(a1, a2, a3, v5);
  result = CTls13Context::RetrieveGenericExtension(*(_QWORD *)(a1 + 40) + 1000i64, a2, v7, (__int64)a3, a4);
  if ( !(_DWORD)result )
    return CTlsExtServer::ParseExtension(a1, a2, a3, v5);
  return result;
}

//----- (000000018001CBE0) ----------------------------------------------------
__int64 __fastcall CCipherMill::FindAcceptableCipherSuite(
        CCipherMill *this,
        struct CSsl3TlsServerContext *a2,
        struct CCipherSuiteInfo *a3,
        char a4,
        struct _UNICODE_STRING *String2,
        unsigned __int8 a6,
        enum _eTlsHashAlgorithm a7,
        unsigned int *a8,
        unsigned __int8 *a9)
{
  __int64 v11; // r8
  unsigned int v12; // r11d
  unsigned __int64 v13; // r10
  unsigned int v14; // esi
  unsigned int v15; // ebp
  int v16; // r9d
  int v17; // edi
  int v18; // eax
  unsigned int *v19; // rdx
  int v20; // r10d
  int v21; // r8d
  int v22; // ebx
  int v23; // edx
  unsigned __int8 v24; // r9
  _DWORD *i; // rax
  int v26; // ecx
  int v27; // ecx
  char v28; // al
  char v29; // r8
  unsigned int AcceptableKeyXCurve; // ebx
  __int64 v32; // rax
  int v33; // ecx
  struct hsel *HashInfo; // rax
  __int64 v35; // [rsp+20h] [rbp-98h]
  __int64 v36; // [rsp+20h] [rbp-98h]
  __int64 v37; // [rsp+70h] [rbp-48h]
  int v38; // [rsp+C0h] [rbp+8h]
  const wchar_t *v39; // [rsp+C8h] [rbp+10h]

  if ( !a2 || !a3 || !a8 || !a9 )
    return 2148074333i64;
  v11 = *((_QWORD *)a2 + 10);
  v12 = *(_DWORD *)(v11 + 196);
  v13 = *(_QWORD *)(v11 + 200);
  v14 = *(_DWORD *)(v11 + 164);
  v15 = *(_DWORD *)(v11 + 168);
  v16 = *(_DWORD *)(v11 + 192);
  v17 = *((_DWORD *)a2 + 16);
  v39 = (const wchar_t *)((char *)a3 + 74);
  v18 = *(_DWORD *)(v11 + 156);
  v37 = v11;
  LODWORD(v11) = *(_DWORD *)(v11 + 176);
  v38 = 1;
  v19 = *(unsigned int **)(v37 + 184);
  *a8 = 0;
  *a9 = 0;
  if ( !CCipherMill::IsCipherSuiteAllowed(
          (__int64)g_cCipherMill,
          v19,
          v11,
          v16,
          (v18 & 0x1000) != 0,
          v18 & 0x800,
          v15,
          v14,
          v17,
          (__int64)a3,
          String2,
          v13,
          v12,
          a6) )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_S(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x29u,
        (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
        v39);
    return (unsigned int)-2146893007;
  }
  v20 = *((_DWORD *)a3 + 12);
  if ( v20 == 4 )
    return 0;
  if ( *((_DWORD *)a2 + 17) == 71 )
  {
    if ( (*((_BYTE *)a2 + 32) & 1) != 0 && (v32 = *((_QWORD *)a2 + 1)) != 0 )
      v33 = *(_DWORD *)(v32 + 28);
    else
      v33 = 0;
    if ( *((_DWORD *)a3 + 7) != v33 )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_S(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x2Au,
          (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
          v39);
        return (unsigned int)-2146893007;
      }
      return (unsigned int)-2146893007;
    }
  }
  v21 = *((_DWORD *)a2 + 16);
  if ( (v21 & 0x40400) != 0 && a2 != (struct CSsl3TlsServerContext *)-510i64 )
  {
    v22 = *((_DWORD *)a3 + 9);
    switch ( v22 )
    {
      case 9216:
        goto LABEL_11;
      case 8704:
        v23 = 2;
        v38 = 2;
        goto LABEL_12;
      case 8707:
        v23 = 3;
        v38 = 3;
        goto LABEL_12;
      case 41984:
LABEL_11:
        v23 = 1;
LABEL_12:
        v24 = 0;
        for ( i = &unk_18007C3A8; i - 6 < (_DWORD *)&CSsl3TlsServerContext::`vftable'; i += 18 )
        {
          v26 = i[1];
          if ( v26 == v23 && (v21 & *i) != 0 && ((v21 & 0x3000) == 0 || v26 != 3 || !i[10]) && v24 < 0xCu )
          {
            v27 = *((unsigned __int16 *)a2 + 272);
            if ( _bittest(&v27, v24) )
              goto LABEL_20;
            v23 = v38;
          }
          ++v24;
        }
        break;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      LODWORD(v35) = *((_DWORD *)a3 + 9);
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x2Bu,
        (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
        v39,
        v35);
      return (unsigned int)-2146893007;
    }
    return (unsigned int)-2146893007;
  }
LABEL_20:
  v28 = a4;
  if ( (v21 & 0x1000) == 0 )
  {
    v29 = 0;
    goto LABEL_22;
  }
  v29 = 1;
  if ( !a4 )
    goto LABEL_22;
  HashInfo = GetHashInfo(*((_DWORD *)a3 + 11));
  if ( HashInfo )
  {
    if ( a7 != *((_DWORD *)HashInfo + 8) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        LODWORD(v35) = a7;
        WPP_SF_Sd(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x2Cu,
          (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
          v39,
          v35);
        return (unsigned int)-2146893007;
      }
      return (unsigned int)-2146893007;
    }
    v28 = a4;
LABEL_22:
    if ( v20 == 3 || v29 )
    {
      AcceptableKeyXCurve = CCipherMill::FindAcceptableKeyXCurve((CCipherMill *)a6, a2, a3, v28, a6, String2, a8, a9);
      if ( AcceptableKeyXCurve )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          LODWORD(v36) = AcceptableKeyXCurve;
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x2Du,
            (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
            (const wchar_t *)a3 + 37,
            v36);
        }
        return AcceptableKeyXCurve;
      }
    }
    else if ( v20 == 2
           && IsDheAlgorithmBlacklisted(*(struct _TLS_PARAMETERS **)(v37 + 200), *(_DWORD *)(v37 + 196), 0, String2, a6) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_S(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x2Eu,
          (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
          v39);
        return (unsigned int)-2146893007;
      }
      return (unsigned int)-2146893007;
    }
    return 0;
  }
  return 1359i64;
}
// 18001CDD3: variable 'v20' is possibly undefined
// 18003101B: variable 'v35' is possibly undefined
// 1800310ED: variable 'v29' is possibly undefined
// 1800311AF: variable 'v36' is possibly undefined
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';

//----- (000000018001CE80) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::DigestClientHello(
        CSsl3TlsServerContext *this,
        unsigned __int8 *Src,
        SIZE_T uBytes,
        char a4,
        unsigned __int8 *a5)
{
  unsigned __int8 *v5; // r13
  SIZE_T v6; // rdi
  char v9; // r15
  __int64 v10; // r8
  bool v11; // zf
  unsigned int v12; // ebx
  __int64 v13; // r12
  __int64 v14; // rax
  __int64 v15; // rcx
  HLOCAL v16; // rax
  unsigned int v17; // edi
  struct _RTL_RESOURCE *v18; // rsi
  unsigned int v19; // ecx
  __int64 v20; // rax
  unsigned __int64 v21; // r10
  unsigned int v22; // r13d
  const wchar_t **v23; // rsi
  unsigned __int8 v24; // bl
  int v25; // eax
  __int64 v26; // r8
  __int16 v27; // ax
  ULONG v28; // eax
  ULONG v29; // ebx
  __int64 v30; // rax
  unsigned int v31; // r8d
  size_t v32; // rdi
  unsigned int v33; // ecx
  unsigned int v34; // ecx
  unsigned int v35; // ebx
  __int64 v36; // r12
  int v37; // esi
  char v38; // al
  int v39; // ecx
  __int64 v40; // r13
  _QWORD **v41; // rcx
  _QWORD *v42; // r15
  __int64 v43; // rbx
  unsigned int v44; // eax
  unsigned int v45; // edx
  unsigned int v46; // ecx
  signed __int32 v47; // edi
  __int64 v48; // rdx
  _QWORD *v49; // rcx
  char v50; // al
  __int64 v51; // rax
  unsigned int v52; // ecx
  unsigned int v53; // r15d
  __int64 v54; // rdx
  int v55; // r10d
  __int64 v56; // r8
  int v57; // ebx
  __int64 v58; // rcx
  __int64 v59; // r13
  __int64 v60; // rcx
  __int64 v61; // rax
  __int64 *v62; // rsi
  __int64 v63; // rax
  __int64 v64; // rdi
  __int64 v65; // rbx
  __int64 v66; // rcx
  volatile signed __int32 *v67; // rcx
  __int64 v68; // r12
  unsigned int v69; // r9d
  unsigned int v70; // r8d
  __int64 v71; // rax
  int v72; // eax
  int v73; // r9d
  __int64 *v74; // r8
  unsigned int v75; // r10d
  unsigned int v76; // edx
  __int64 v77; // r8
  __int64 v78; // rcx
  __int64 v79; // rax
  __int64 v81; // rax
  int v82; // eax
  __int64 v83; // rcx
  CSessionCacheManager *v84; // rsi
  int v85; // r12d
  unsigned int v86; // r15d
  CSessionCacheItem *v87; // rax
  CSessionCacheItem *v88; // rdi
  unsigned int v89; // ebx
  CSessionCacheTable *v90; // rcx
  _QWORD *v91; // rsi
  __int64 *v92; // r8
  __int64 v93; // rcx
  __int64 **v94; // rax
  _QWORD *v95; // rsi
  _QWORD *v96; // rcx
  _QWORD *v97; // rax
  CSessionCacheManager *v98; // rax
  __int64 v99; // rcx
  unsigned int v100; // ecx
  unsigned int v101; // r9d
  unsigned int *v102; // r8
  int v103; // eax
  __int64 v104; // rax
  unsigned int v105; // ecx
  int v106; // eax
  size_t v107; // [rsp+20h] [rbp-E0h]
  unsigned int v109; // [rsp+44h] [rbp-BCh] BYREF
  DWORD CurrentProcessId; // [rsp+48h] [rbp-B8h]
  unsigned __int64 v111; // [rsp+50h] [rbp-B0h]
  size_t Size; // [rsp+58h] [rbp-A8h] BYREF
  unsigned __int8 *v113; // [rsp+60h] [rbp-A0h]
  unsigned int *v114; // [rsp+68h] [rbp-98h] BYREF
  CSessionCacheManager *v115; // [rsp+70h] [rbp-90h]
  PRTL_RESOURCE Resource; // [rsp+78h] [rbp-88h]
  __int64 v117; // [rsp+80h] [rbp-80h] BYREF
  unsigned __int8 v118[16]; // [rsp+88h] [rbp-78h] BYREF
  __int128 v119; // [rsp+98h] [rbp-68h]
  int v120[6]; // [rsp+A8h] [rbp-58h] BYREF
  _BYTE Source1[20]; // [rsp+C0h] [rbp-40h] BYREF
  __int16 v122; // [rsp+D8h] [rbp-28h] BYREF
  __int128 v123; // [rsp+DAh] [rbp-26h]
  __int128 v124; // [rsp+EAh] [rbp-16h]
  __int16 v125; // [rsp+FAh] [rbp-6h]
  char v126[272]; // [rsp+100h] [rbp+0h] BYREF
  UCHAR pbBuffer[16]; // [rsp+210h] [rbp+110h] BYREF
  __int128 v128; // [rsp+220h] [rbp+120h]
  __int128 Buf1[2]; // [rsp+230h] [rbp+130h] BYREF

  v5 = a5;
  v6 = (unsigned int)uBytes;
  v113 = a5;
  LODWORD(Size) = 0;
  memset(Buf1, 0, sizeof(Buf1));
  v9 = a4;
  memset_0(v126, 0, sizeof(v126));
  v11 = *((_BYTE *)this + 233) == 0;
  v12 = 4;
  v109 = 68;
  v114 = (unsigned int *)v126;
  v13 = 12i64;
  if ( !v11 )
    v12 = 12;
  v115 = CSessionCacheManager::m_pSessionCacheManager;
  *(_OWORD *)pbBuffer = 0i64;
  v128 = 0i64;
  if ( !Src || (unsigned int)v6 < v12 || !a5 )
    return 87i64;
  *a5 = 0;
  if ( *((_QWORD *)this + 110) )
  {
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 110) = 0i64;
  }
  v14 = *((_QWORD *)this + 16);
  *((_DWORD *)this + 218) = v6;
  v15 = *(_QWORD *)(v14 + 24);
  if ( v15 )
  {
    LOBYTE(v10) = 1;
    v16 = (HLOCAL)(*(__int64 (__fastcall **)(__int64, SIZE_T, __int64))(*(_QWORD *)v15 + 48i64))(v15, v6, v10);
  }
  else if ( LsaTable )
  {
    v16 = (HLOCAL)(*(__int64 (__fastcall **)(_QWORD))(LsaTable + 40))((unsigned int)v6);
  }
  else
  {
    v16 = LocalAlloc(0x40u, v6);
  }
  *((_QWORD *)this + 110) = v16;
  if ( !v16 )
  {
    v29 = 14;
    goto LABEL_123;
  }
  memcpy_0(v16, Src, *((unsigned int *)this + 218));
  v17 = v6 - v12;
  v18 = (struct _RTL_RESOURCE *)&Src[v12];
  CurrentProcessId = v17;
  v11 = (*((_DWORD *)this + 16) & 0x40400) == 0;
  Resource = v18;
  if ( !v11 )
  {
    RtlAcquireResourceShared(&::Resource, 1u);
    *((_WORD *)this + 237) = 0;
    *((_WORD *)this + 254) = 0;
    v19 = (unsigned __int16)word_1800925E8;
    if ( (unsigned __int16)word_1800925E8 <= 0x10u )
    {
      *((_WORD *)this + 237) = word_1800925E8;
      *((_WORD *)this + 254) = word_18009260A;
      memcpy_0((char *)this + 476, &xmmword_1800925EA, 2i64 * v19);
    }
    RtlReleaseResource(&::Resource);
    v20 = *((_QWORD *)this + 10);
    v21 = *(_QWORD *)(v20 + 200);
    v111 = v21;
    if ( v21 )
    {
      v22 = *(_DWORD *)(v20 + 196);
      if ( v22 )
      {
        v23 = (const wchar_t **)&off_18007C3B0;
        *((_WORD *)this + 237) = 0;
        v24 = 0;
        do
        {
          if ( v24 < 0xCu )
          {
            v25 = *((unsigned __int16 *)this + 254);
            if ( ((1 << v24) & v25) != 0 )
            {
              *((_WORD *)this + 254) = v25 & ~(1 << v24);
              if ( IsCngAlgorithmBlacklisted(v21, v22, 4, v23[2], 0i64, 0, 0i64, 1)
                || IsCngAlgorithmBlacklisted(v111, v22, 4, *v23, 0i64, 0, 0i64, 1)
                || (*((unsigned __int16 *)this + 254) & (1 << v24)) != 0 )
              {
                v21 = v111;
              }
              else
              {
                v26 = *((unsigned __int16 *)this + 237);
                v21 = v111;
                if ( (unsigned int)v26 < 0x10 )
                {
                  *((_WORD *)this + v26 + 238) = __ROR2__(*((_WORD *)&unk_18007C390 + 36 * v24), 8);
                  v27 = *((_WORD *)this + 254);
                  ++*((_WORD *)this + 237);
                  *((_WORD *)this + 254) = v27 | (1 << v24);
                }
              }
            }
          }
          v23 += 9;
          ++v24;
          --v13;
        }
        while ( v13 );
        if ( !*((_WORD *)this + 237) )
        {
          v29 = -2146893007;
          goto LABEL_123;
        }
        v17 = CurrentProcessId;
        v18 = Resource;
        v9 = a4;
      }
      v5 = v113;
    }
    *((_BYTE *)this + 925) = 0;
  }
  v28 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *, struct _RTL_RESOURCE *, _QWORD, __int128 *, size_t *, unsigned int **, unsigned int *))(*(_QWORD *)this + 528i64))(
          this,
          v18,
          v17,
          Buf1,
          &Size,
          &v114,
          &v109);
  v29 = v28;
  if ( v28 )
  {
    if ( v28 != -2146892986 && v28 != -2146892953 )
    {
      v29 = -2146893048;
      CSslContext::SetErrorAndFatalAlert((__int64)this, 1200, -2146893048, 0xAu);
    }
    goto LABEL_123;
  }
  v30 = *((_QWORD *)this + 17);
  if ( (v30 & 0x8000000) == 0 )
    *((_QWORD *)this + 17) = v30 & 0xFFFFFFFFFFBFFFFFui64;
  if ( (*((_DWORD *)this + 16) & 0x40400) != 0 )
  {
    if ( !*((_BYTE *)this + 925) )
    {
      v122 = 0;
      v123 = 0i64;
      v125 = 0;
      v124 = 0i64;
      CTlsSignatureSuiteList::SetDefaultClientHello((CTlsSignatureSuiteList *)&v122);
      CTlsSignatureSuiteList::SetSignatureSuiteList(
        (CSsl3TlsServerContext *)((char *)this + 510),
        (CSsl3TlsServerContext *)((char *)this + 474));
      CTlsSignatureSuiteList::Restrict(
        (CSsl3TlsServerContext *)((char *)this + 510),
        (const struct CTlsSignatureSuiteList *)&v122,
        *((_DWORD *)this + 16));
    }
    if ( !*((_WORD *)this + 255) )
    {
      v29 = -2146893007;
      CSslContext::SetErrorAndFatalAlert((__int64)this, 1206, -2146893007, 0x28u);
      goto LABEL_123;
    }
  }
  if ( !v9 || (*((_DWORD *)this + 34) & 0x8000000) == 0 )
    goto LABEL_119;
  v31 = *((_DWORD *)this + 246);
  if ( v31 )
  {
    LODWORD(v107) = Size;
    *v5 = CSsl3TlsServerContext::UnprotectAndDeserializeSessionState(
            this,
            *((unsigned __int8 *const *)this + 122),
            v31,
            (unsigned __int8 *const)Buf1,
            v107);
    v104 = *((_QWORD *)this + 15);
    if ( v104 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
    {
      *(_WORD *)(v104 + 64) |= 2u;
      *(_DWORD *)(v104 + 24) = 1;
    }
    goto LABEL_74;
  }
  v32 = (unsigned int)Size;
  if ( !(_DWORD)Size )
    goto LABEL_74;
  if ( (unsigned int)Size < 4 )
  {
    v50 = 0;
    goto LABEL_71;
  }
  if ( LODWORD(Buf1[0]) >= *((_DWORD *)v115 + 4) )
  {
    v50 = 0;
    goto LABEL_71;
  }
  v33 = *((_DWORD *)v115 + 13);
  if ( v33 == 1000 )
  {
    v34 = LODWORD(Buf1[0]) / 0x3E8;
    v35 = LODWORD(Buf1[0]) - 1000 * ((LODWORD(Buf1[0]) / 0x3E8) & 0x3FFFFFF);
  }
  else
  {
    v35 = LODWORD(Buf1[0]) % v33;
    v34 = LODWORD(Buf1[0]) / v33;
  }
  v36 = *((_QWORD *)v115 + 5) + 152i64 * v34;
  v37 = 0;
  LODWORD(v111) = GetTickCount();
  if ( LsaTable )
  {
    v38 = (*(__int64 (__fastcall **)(int *))(LsaTable + 192))(v120);
    v39 = -1;
    if ( v38 )
      v39 = v120[0];
    CurrentProcessId = v39;
  }
  else
  {
    CurrentProcessId = GetCurrentProcessId();
  }
  Resource = (PRTL_RESOURCE)(v36 + 48);
  RtlAcquireResourceExclusive((PRTL_RESOURCE)(v36 + 48), 1u);
  v40 = 16i64 * v35;
  v41 = (_QWORD **)(v40 + *(_QWORD *)v36);
  v42 = *v41;
  if ( *v41 == v41 )
  {
LABEL_170:
    v43 = v117;
    goto LABEL_68;
  }
  while ( 1 )
  {
    v43 = (__int64)(v42 - 36);
    v42 = (_QWORD *)*v42;
    RtlAcquireResourceShared((PRTL_RESOURCE)(v43 + 72), 1u);
    if ( !*(_BYTE *)(v43 + 236) )
      goto LABEL_126;
    v44 = *(_DWORD *)(v43 + 276);
    v45 = *(_DWORD *)(v43 + 280);
    v46 = v111 - v44;
    if ( (unsigned int)v111 <= v44 )
      break;
    if ( v46 <= v45 )
      goto LABEL_53;
LABEL_126:
    RtlReleaseResource((PRTL_RESOURCE)(v43 + 72));
    if ( v42 == (_QWORD *)(v40 + *(_QWORD *)v36) )
    {
      RtlReleaseResource(Resource);
      goto LABEL_169;
    }
  }
  if ( (unsigned int)v111 < v44 && v46 - 1 >= v45 )
    goto LABEL_126;
LABEL_53:
  if ( (_DWORD)v32 != *(unsigned __int16 *)(v43 + 238) )
    goto LABEL_126;
  if ( memcmp_0(Buf1, (const void *)(v43 + 240), v32) )
    goto LABEL_126;
  if ( *(_DWORD *)(v43 + 272) != CurrentProcessId )
    goto LABEL_126;
  v117 = *(_QWORD *)(*((_QWORD *)this + 10) + 760i64);
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, _QWORD, _QWORD, __int64 *, _DWORD))(*(_QWORD *)v43 + 80i64))(
          v43,
          0i64,
          0i64,
          &v117,
          *((_DWORD *)this + 16)) )
    goto LABEL_126;
  v47 = _InterlockedIncrement((volatile signed __int32 *)(v43 + 232));
  v37 = v47;
  if ( v47 != 2 )
  {
    RtlReleaseResource((PRTL_RESOURCE)(v43 + 72));
    if ( v47 )
      goto LABEL_60;
    goto LABEL_170;
  }
  LsaIModifyPerformanceCounter(5i64);
  RtlReleaseResource((PRTL_RESOURCE)(v43 + 72));
LABEL_60:
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_54aae497645f38b3b161e68e12f6f932_Traceguids, v43);
  if ( v47 == 2 )
  {
    v48 = *(_QWORD *)(v43 + 320);
    if ( *(_QWORD *)(v48 + 8) == v43 + 320 )
    {
      v49 = *(_QWORD **)(v43 + 328);
      if ( *v49 == v43 + 320 )
      {
        *v49 = v48;
        *(_QWORD *)(v48 + 8) = v49;
        goto LABEL_67;
      }
    }
LABEL_140:
    __fastfail(3u);
  }
LABEL_67:
  LsaIModifyPerformanceCounter(9i64);
LABEL_68:
  RtlReleaseResource(Resource);
  if ( v37 <= 0 )
  {
LABEL_169:
    v50 = 0;
    *((_QWORD *)this + 124) = 0i64;
  }
  else
  {
    *((_QWORD *)this + 124) = v43;
    v50 = 1;
  }
  v5 = v113;
LABEL_71:
  *v5 = v50;
  v51 = *((_QWORD *)this + 15);
  if ( v51 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
  {
    *(_WORD *)(v51 + 64) |= 1u;
    *(_DWORD *)(v51 + 24) = 1;
  }
LABEL_74:
  if ( *v5 )
  {
    v52 = v109;
    v53 = 0;
    if ( !v109 )
      goto LABEL_118;
    v54 = *(_QWORD *)(*((_QWORD *)this + 124) + 176i64);
    while ( 1 )
    {
      v55 = v54 ? *(_DWORD *)(v54 + 28) : 0;
      v56 = v53;
      if ( v114[v56] == v55 )
        break;
      if ( ++v53 >= v109 )
        goto LABEL_118;
    }
    v57 = *((_DWORD *)this + 17);
    if ( (unsigned int)CCipherMill::ChooseServerCipher(
                         (CCipherMill *)g_cCipherMill,
                         this,
                         &v114[v56],
                         1u,
                         *((_DWORD *)this + 16),
                         *v5) )
    {
      *((_WORD *)this + 48) = 0;
      *((_DWORD *)this + 17) = v57;
    }
    else
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 48i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      v58 = *((_QWORD *)this + 124);
      *((_QWORD *)this + 11) = v58;
      RtlAcquireResourceExclusive((PRTL_RESOURCE)(v58 + 72), 1u);
      v59 = *((_QWORD *)this + 11);
      v60 = *(_QWORD *)(v59 + 176);
      v61 = *(_QWORD *)(v60 + 848);
      if ( v61 )
        _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v61 + 16) + 12i64));
      _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v60 + 856) + 12i64));
      v62 = *(__int64 **)(v59 + 176);
      v63 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 248i64))(this);
      v64 = *((_QWORD *)this + 1);
      v65 = v63;
      if ( v64 )
      {
        v66 = *(_QWORD *)(v64 + 848);
        if ( v66 )
          CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v66 + 16));
        CMasterCipherInfo::Dereference(*(CMasterCipherInfo **)(v64 + 856));
      }
      v67 = (volatile signed __int32 *)*((_QWORD *)this + 3);
      if ( v67 )
      {
        if ( _InterlockedExchangeAdd(v67 + 6, 0xFFFFFFFF) == 1 )
          (*(void (__fastcall **)(volatile signed __int32 *, __int64))(*(_QWORD *)v67 + 8i64))(v67, 1i64);
        *((_QWORD *)this + 3) = 0i64;
      }
      if ( v65 )
      {
        v68 = *v62;
        RtlAcquireResourceShared((PRTL_RESOURCE)(v65 + 552), 1u);
        v69 = *(_DWORD *)(v65 + 96);
        v70 = 0;
        if ( v69 )
        {
          while ( 1 )
          {
            v71 = *(_QWORD *)(*(_QWORD *)(v65 + 88) + 8i64 * v70);
            if ( *(_QWORD *)(v71 + 16) == v68 )
              break;
            if ( ++v70 >= v69 )
              goto LABEL_100;
          }
          _InterlockedIncrement((volatile signed __int32 *)(v71 + 24));
          *((_QWORD *)this + 3) = *(_QWORD *)(*(_QWORD *)(v65 + 88) + 8i64 * v70);
        }
LABEL_100:
        RtlReleaseResource((PRTL_RESOURCE)(v65 + 552));
      }
      if ( (*((_DWORD *)this + 16) & 0xF3F00) != 0 )
      {
        if ( !(unsigned int)SslLookupCipherLengths(
                              *v62,
                              *((unsigned __int16 *)this + 17),
                              *((unsigned int *)v62 + 7),
                              *((unsigned int *)this + 4),
                              Source1,
                              20,
                              0) )
          goto LABEL_103;
      }
      else
      {
        v105 = *((_DWORD *)v62 + 3);
        v106 = *((_DWORD *)v62 + 4);
        *(_QWORD *)Source1 = 20i64;
        *(_QWORD *)&Source1[12] = 0i64;
        *(_DWORD *)&Source1[8] = v106;
        if ( v105 > 1 )
        {
          *(_DWORD *)&Source1[16] |= 1u;
          *(_DWORD *)&Source1[12] = v105;
        }
LABEL_103:
        if ( (*((_BYTE *)this + 32) & 1) == 0 || RtlCompareMemory(Source1, (char *)this + 40, 0x14ui64) == 20 )
        {
          v72 = *(_DWORD *)&Source1[16];
          *(_OWORD *)((char *)this + 40) = *(_OWORD *)Source1;
          *((_DWORD *)this + 14) = v72;
        }
      }
      *((_WORD *)this + 16) |= 1u;
      *((_QWORD *)this + 1) = v62;
      v73 = *(_DWORD *)(v59 + 184);
      *((_DWORD *)this + 4) = v73;
      v74 = (__int64 *)v62[106];
      if ( v74 )
      {
        v75 = *((_DWORD *)v74 + 2);
        v76 = 0;
        if ( v75 )
        {
          v77 = *v74;
          while ( 1 )
          {
            v78 = 780i64 * v76;
            if ( *(_DWORD *)(v77 + v78 + 772) == v73 )
              break;
            if ( ++v76 >= v75 )
              goto LABEL_114;
          }
          if ( v77 + v78 )
            *((_DWORD *)this + 5) = *(_DWORD *)(v77 + v78 + 776);
        }
      }
LABEL_114:
      RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
      v79 = *((_QWORD *)this + 15);
      if ( v79 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
      {
        *(_WORD *)(v79 + 64) |= 4u;
        *(_DWORD *)(v79 + 24) = 1;
      }
      v5 = v113;
      v52 = v109;
LABEL_118:
      if ( v53 != v52 )
      {
LABEL_119:
        if ( *v5 )
          goto LABEL_120;
        goto LABEL_129;
      }
    }
    *(_BYTE *)(*((_QWORD *)this + 124) + 236i64) = 0;
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 240i64))(this);
    *v5 = 0;
  }
LABEL_129:
  v81 = *((_QWORD *)this + 17);
  if ( (v81 & 0x800) != 0 && *((_DWORD *)this + 246) )
    *((_QWORD *)this + 17) = v81 | 0x400000;
  v82 = BCryptGenRandom(0i64, pbBuffer, 0x20u, 2u);
  if ( v82 >= 0 || (v29 = RtlNtStatusToDosError(v82)) == 0 )
  {
    if ( CSessionCacheManager::m_pSessionCacheManager )
    {
      v83 = *((_QWORD *)CSessionCacheManager::m_pSessionCacheManager + 5)
          + 152i64
          * ((unsigned int)(*(_DWORD *)pbBuffer % *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 4))
           / *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 13));
      if ( v83 )
        RtlAcquireResourceExclusive((PRTL_RESOURCE)(v83 + 48), 1u);
    }
    v84 = v115;
    v85 = *((_DWORD *)this + 16);
    v86 = *(_DWORD *)pbBuffer % *((_DWORD *)v115 + 4);
    *(_OWORD *)v118 = *(_OWORD *)pbBuffer;
    *(_DWORD *)v118 = v86;
    v119 = v128;
    if ( g_SslMachineID != -1 )
      *(_DWORD *)&v118[4] = g_SslMachineID;
    v87 = (CSessionCacheItem *)(*(__int64 (__fastcall **)(struct IAllocate *, __int64))(*(_QWORD *)CSessionCacheServerItem::m_pServerCacheLookaside
                                                                                      + 24i64))(
                                 CSessionCacheServerItem::m_pServerCacheLookaside,
                                 360i64);
    v88 = v87;
    if ( v87 )
    {
      CSessionCacheItem::CSessionCacheItem(v87, *((_DWORD *)v84 + 6), v118);
      *((_DWORD *)v88 + 54) = -2146893019;
      *(_QWORD *)v88 = &CSessionCacheServerItem::`vftable';
      *((_QWORD *)v88 + 42) = 0i64;
      *((_QWORD *)v88 + 43) = 0i64;
      *((_DWORD *)v88 + 88) = 0;
      v29 = *((_DWORD *)v88 + 17);
      if ( v29 )
      {
        CSessionCacheServerItem::`vector deleting destructor'(v88, 1);
      }
      else
      {
        v89 = *((_DWORD *)v84 + 13);
        v90 = (CSessionCacheTable *)(v86 / v89);
        v91 = (_QWORD *)(*((_QWORD *)v115 + 5) + 152i64 * (_QWORD)v90);
        CSessionCacheTable::ReferenceCacheItemInternal(v90, v88);
        *((_QWORD *)v88 + 28) = v91;
        v92 = (__int64 *)((char *)v88 + 288);
        v93 = *v91 + 16i64 * (v86 % v89);
        v94 = *(__int64 ***)(v93 + 8);
        if ( *v94 != (__int64 *)v93 )
          goto LABEL_140;
        *v92 = v93;
        v95 = v91 + 2;
        *((_QWORD *)v88 + 37) = v94;
        *v94 = v92;
        *(_QWORD *)(v93 + 8) = v92;
        v96 = (_QWORD *)((char *)v88 + 304);
        v97 = (_QWORD *)v95[1];
        if ( (_QWORD *)*v97 != v95 )
          goto LABEL_140;
        *((_QWORD *)v88 + 39) = v97;
        *v96 = v95;
        *v97 = v96;
        v98 = v115;
        v95[1] = v96;
        _InterlockedIncrement((volatile signed __int32 *)v98 + 8);
        LsaIModifyPerformanceCounter(4i64);
        *((_QWORD *)this + 124) = v88;
        v29 = 0;
        *((_DWORD *)v88 + 42) = v85;
      }
    }
    else
    {
      v29 = 14;
    }
    if ( CSessionCacheManager::m_pSessionCacheManager )
    {
      v99 = *((_QWORD *)CSessionCacheManager::m_pSessionCacheManager + 5)
          + 152i64
          * ((unsigned int)(*(_DWORD *)pbBuffer % *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 4))
           / *((_DWORD *)CSessionCacheManager::m_pSessionCacheManager + 13));
      if ( v99 )
        RtlReleaseResource((PRTL_RESOURCE)(v99 + 48));
    }
    if ( !v29 )
    {
      v100 = *((_DWORD *)this + 16);
      v101 = v109;
      v102 = v114;
      *((_QWORD *)this + 11) = *((_QWORD *)this + 124);
      v103 = CCipherMill::ChooseServerCipher((CCipherMill *)g_cCipherMill, this, v102, v101, v100, *v5);
      v29 = v103;
      if ( v103 )
      {
        CSslContext::SetErrorAndFatalAlert((__int64)this, 1205, v103, 0x28u);
      }
      else
      {
LABEL_120:
        v11 = *((_BYTE *)this + 233) == 0;
        *((_BYTE *)this + 555) = 0;
        if ( !v11 )
          CSsl3TlsContext::FreeSavedWriteCipherState(this);
        v29 = 0;
      }
    }
  }
LABEL_123:
  *((_QWORD *)this + 122) = 0i64;
  *((_DWORD *)this + 246) = 0;
  if ( v114 != (unsigned int *)v126 )
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 16i64))(this);
  return v29;
}
// 1800311E3: variable 'v10' is possibly undefined
// 1800312EA: variable 'v107' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18007C330: using guessed type void *CSessionCacheServerItem::`vftable';
// 18007C3B0: using guessed type wchar_t *off_18007C3B0;
// 1800919F4: using guessed type unsigned int g_SslMachineID;
// 1800925E8: using guessed type __int16 word_1800925E8;
// 1800925EA: using guessed type __int128 xmmword_1800925EA;
// 18009260A: using guessed type __int16 word_18009260A;
// 180092620: using guessed type __int64 LsaTable;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 1800927F8: using guessed type struct IAllocate *CSessionCacheServerItem::m_pServerCacheLookaside;
// 180098238: using guessed type __int64 __fastcall LsaIModifyPerformanceCounter(_QWORD);
// 1800984F0: using guessed type __int64 __fastcall SslLookupCipherLengths(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);
// 18001CE80: using guessed type int var_1E8[6];

//----- (000000018001DB80) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::DigestClientHello(
        CTls13ServerContext *this,
        unsigned __int8 *Src,
        SIZE_T uBytes)
{
  unsigned int v3; // ebx
  SIZE_T v4; // rdi
  __int64 v7; // r14
  __int64 v8; // r8
  __int64 v9; // rdx
  __int64 v10; // rax
  __int64 v11; // rcx
  HLOCAL v12; // rax
  unsigned __int8 *v13; // rbp
  unsigned int v14; // edi
  unsigned int v15; // ecx
  __int64 v16; // rax
  unsigned __int64 v17; // r13
  unsigned int v18; // r12d
  const wchar_t **v19; // rsi
  unsigned __int8 v20; // bl
  int v21; // eax
  __int64 v22; // r8
  __int16 v23; // ax
  __int64 v24; // rax
  unsigned int v25; // eax
  unsigned int RandomBits; // ebx
  __int64 v27; // rax
  int v28; // ecx
  __int64 v29; // rax
  __int64 v30; // rbx
  __int64 v31; // rdi
  __int64 v32; // rbp
  __int64 v33; // rsi
  __int64 v34; // rbx
  _WORD *v36; // rax
  int v37; // r14d
  CSessionCacheManager *v38; // rbp
  __int64 *v39; // rdi
  unsigned __int8 v40; // si
  __int64 v41; // rax
  __int64 v42; // rcx
  __int64 v43; // rcx
  unsigned int v44; // r9d
  unsigned int *v45; // r8
  int v46; // r14d
  unsigned int v47; // eax
  __int64 v48; // rax
  __int64 v49; // rax
  unsigned int v50; // [rsp+40h] [rbp-198h] BYREF
  unsigned int v51; // [rsp+44h] [rbp-194h] BYREF
  unsigned int v52; // [rsp+48h] [rbp-190h]
  unsigned int *v53; // [rsp+50h] [rbp-188h] BYREF
  unsigned __int8 *v54; // [rsp+58h] [rbp-180h]
  char v55[272]; // [rsp+60h] [rbp-178h] BYREF
  UCHAR pbBuffer[16]; // [rsp+170h] [rbp-68h] BYREF
  __int128 v57; // [rsp+180h] [rbp-58h]

  v3 = 4;
  v4 = (unsigned int)uBytes;
  v7 = 12i64;
  if ( *((_BYTE *)this + 233) )
    v3 = 12;
  if ( !Src || (unsigned int)uBytes < v3 || !*((_QWORD *)this + 10) )
    return 87i64;
  v50 = 0;
  memset_0(v55, 0, sizeof(v55));
  v9 = *((_QWORD *)this + 110);
  v53 = (unsigned int *)v55;
  v51 = 68;
  if ( v9 )
  {
    (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 110) = 0i64;
  }
  v10 = *((_QWORD *)this + 16);
  *((_DWORD *)this + 218) = v4;
  v11 = *(_QWORD *)(v10 + 24);
  if ( v11 )
  {
    LOBYTE(v8) = 1;
    v12 = (HLOCAL)(*(__int64 (__fastcall **)(__int64, SIZE_T, __int64))(*(_QWORD *)v11 + 48i64))(v11, v4, v8);
  }
  else if ( LsaTable )
  {
    v12 = (HLOCAL)(*(__int64 (__fastcall **)(_QWORD))(LsaTable + 40))((unsigned int)v4);
  }
  else
  {
    v12 = LocalAlloc(0x40u, v4);
  }
  *((_QWORD *)this + 110) = v12;
  if ( !v12 )
    return 14i64;
  memcpy_0(v12, Src, *((unsigned int *)this + 218));
  v13 = &Src[v3];
  v14 = v4 - v3;
  v54 = v13;
  v52 = v14;
  RtlAcquireResourceShared(&Resource, 1u);
  *((_WORD *)this + 237) = 0;
  *((_WORD *)this + 254) = 0;
  v15 = (unsigned __int16)word_1800925E8;
  if ( (unsigned __int16)word_1800925E8 <= 0x10u )
  {
    *((_WORD *)this + 237) = word_1800925E8;
    *((_WORD *)this + 254) = word_18009260A;
    memcpy_0((char *)this + 476, &xmmword_1800925EA, 2i64 * v15);
  }
  RtlReleaseResource(&Resource);
  v16 = *((_QWORD *)this + 10);
  v17 = *(_QWORD *)(v16 + 200);
  if ( v17 )
  {
    v18 = *(_DWORD *)(v16 + 196);
    if ( v18 )
    {
      v19 = (const wchar_t **)&off_18007C3B0;
      *((_WORD *)this + 237) = 0;
      v20 = 0;
      do
      {
        if ( v20 < 0xCu )
        {
          v21 = *((unsigned __int16 *)this + 254);
          if ( ((1 << v20) & v21) != 0 )
          {
            *((_WORD *)this + 254) = v21 & ~(1 << v20);
            if ( !IsCngAlgorithmBlacklisted(v17, v18, 4, v19[2], 0i64, 0, 0i64, 1)
              && !IsCngAlgorithmBlacklisted(v17, v18, 4, *v19, 0i64, 0, 0i64, 1)
              && (*((unsigned __int16 *)this + 254) & (1 << v20)) == 0 )
            {
              v22 = *((unsigned __int16 *)this + 237);
              if ( (unsigned int)v22 < 0x10 )
              {
                *((_WORD *)this + v22 + 238) = __ROR2__(*((_WORD *)&unk_18007C390 + 36 * v20), 8);
                v23 = *((_WORD *)this + 254);
                ++*((_WORD *)this + 237);
                *((_WORD *)this + 254) = v23 | (1 << v20);
              }
            }
          }
        }
        v19 += 9;
        ++v20;
        --v7;
      }
      while ( v7 );
      if ( !*((_WORD *)this + 237) )
        return 2148074289i64;
      v14 = v52;
      v13 = v54;
    }
  }
  v24 = *(_QWORD *)this;
  *((_BYTE *)this + 925) = 0;
  v25 = (*(__int64 (__fastcall **)(CTls13ServerContext *, unsigned __int8 *, _QWORD, char *, unsigned int *, unsigned int **, unsigned int *))(v24 + 528))(
          this,
          v13,
          v14,
          (char *)this + 1249,
          &v50,
          &v53,
          &v51);
  RandomBits = v25;
  if ( v25 )
  {
    if ( v25 != -2146892986 && v25 != -2146892953 )
    {
      RandomBits = -2146893048;
      CSslContext::SetErrorAndFatalAlert((__int64)this, 1200, -2146893048, 0xAu);
    }
    goto LABEL_36;
  }
  v27 = *((_QWORD *)this + 10);
  if ( !v27 )
  {
LABEL_46:
    RandomBits = 1359;
    goto LABEL_36;
  }
  v28 = *((_DWORD *)this + 16);
  if ( (v28 & *(_DWORD *)(v27 + 152) & 0x51550) == 0 )
    goto LABEL_47;
  if ( (v28 & 0x1000) != 0 )
  {
    if ( v50 <= 0x20 )
    {
      v38 = CSessionCacheManager::m_pSessionCacheManager;
      *((_BYTE *)this + 1281) = v50;
      if ( v38 )
      {
        while ( 1 )
        {
          if ( (*((_DWORD *)this + 34) & 0x8000i64) != 0 )
          {
            v40 = 0;
            *(_OWORD *)pbBuffer = 0i64;
            v57 = 0i64;
            RandomBits = GenerateRandomBits(pbBuffer, 0x20u);
            if ( RandomBits )
              goto LABEL_36;
            CSessionCacheManager::AcquireCacheTableLock(v42, 0i64, pbBuffer);
            v39 = (__int64 *)((char *)this + 992);
            RandomBits = CSessionCacheManager::CacheRetrieveNewServerItem(
                           v38,
                           *((_DWORD *)this + 16),
                           pbBuffer,
                           (struct CSessionCacheServerItem **)this + 124);
            CSessionCacheManager::ReleaseCacheTableLock(v43, 0i64, pbBuffer);
            if ( RandomBits )
              goto LABEL_36;
            v41 = *((_QWORD *)this + 124);
          }
          else
          {
            v39 = (__int64 *)((char *)this + 992);
            v40 = 1;
            v41 = *((_QWORD *)this + 124);
            if ( !v41 )
              goto LABEL_46;
          }
          v44 = v51;
          v45 = v53;
          v46 = *((_DWORD *)this + 17);
          *((_QWORD *)this + 11) = v41;
          v47 = CCipherMill::ChooseServerCipher(
                  (CCipherMill *)g_cCipherMill,
                  this,
                  v45,
                  v44,
                  *((_DWORD *)this + 16),
                  v40);
          RandomBits = v47;
          if ( !v40 )
            goto LABEL_36;
          if ( !v47 )
            break;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 65i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
          }
          v48 = *v39;
          *((_WORD *)this + 48) = 0;
          *((_DWORD *)this + 17) = v46;
          *(_BYTE *)(v48 + 236) = 0;
          *((_QWORD *)this + 17) |= 0x8000ui64;
          (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 240i64))(this);
          *((_QWORD *)this + 11) = 0i64;
        }
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 64i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
        v49 = *((_QWORD *)this + 15);
        if ( v49 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
        {
          *(_WORD *)(v49 + 64) |= 4u;
          *(_DWORD *)(v49 + 24) = 1;
        }
      }
      else
      {
        RandomBits = 1359;
      }
    }
    else
    {
      RandomBits = 1359;
    }
    goto LABEL_36;
  }
  if ( *((_DWORD *)this + 17) == 71 )
  {
LABEL_47:
    RandomBits = -2146893007;
    CSslContext::SetErrorAndFatalAlert((__int64)this, 11, -2146893007, 0x46u);
    goto LABEL_36;
  }
  *((_QWORD *)this + 17) &= ~0x8000ui64;
  v29 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)xmmword_180092DD0 + 16i64))(xmmword_180092DD0);
  v30 = v29;
  if ( !v29 )
  {
    RandomBits = 14;
    goto LABEL_36;
  }
  *(_QWORD *)(v29 + 8) = 0i64;
  v31 = v29;
  v32 = v29;
  CSsl3TlsContext::CSsl3TlsContext((CSsl3TlsContext *)(v29 + 40), (__int64)this);
  *(_QWORD *)(v30 + 40) = &CSsl3TlsServerContext::`vftable';
  v33 = v30 + 40;
  *(_QWORD *)(v30 + 968) = *((_QWORD *)this + 116);
  *(_QWORD *)(v30 + 976) = *((_QWORD *)this + 117);
  *(_QWORD *)(v30 + 984) = *((_QWORD *)this + 118);
  *(_WORD *)(v30 + 992) = *((_WORD *)this + 476);
  *(_QWORD *)(v30 + 1000) = *((_QWORD *)this + 120);
  *(_QWORD *)(v30 + 1008) = *((_QWORD *)this + 121);
  *(_QWORD *)(v30 + 1016) = *((_QWORD *)this + 122);
  *(_DWORD *)(v30 + 1024) = *((_DWORD *)this + 246);
  *(_BYTE *)(v30 + 1028) = *((_BYTE *)this + 988);
  *(_QWORD *)(v30 + 1032) = *((_QWORD *)this + 124);
  v34 = v30 + 1040;
  *((_QWORD *)this + 116) = 0i64;
  *((_QWORD *)this + 117) = 0i64;
  *((_QWORD *)this + 118) = 0i64;
  *((_WORD *)this + 476) = 0;
  *((_QWORD *)this + 120) = 0i64;
  *((_QWORD *)this + 121) = 0i64;
  *((_QWORD *)this + 122) = 0i64;
  *((_DWORD *)this + 246) = 0;
  *((_BYTE *)this + 988) = 0;
  *((_QWORD *)this + 124) = 0i64;
  if ( *((_QWORD *)&xmmword_180092DD0 + 1) )
  {
    v36 = (_WORD *)(*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)&xmmword_180092DD0 + 1) + 16i64))(*((_QWORD *)&xmmword_180092DD0 + 1));
    v37 = qword_180092DC0;
LABEL_51:
    if ( v36 && v37 )
    {
      *(_QWORD *)(v34 + 8) = 0i64;
      *(_QWORD *)v34 = &CSslScratchAllocator::`vftable';
      *(_WORD *)(v34 + 16) = v37;
      *(_DWORD *)(v34 + 18) = 0;
      if ( (unsigned __int16)v37 > 4u )
      {
        *(_QWORD *)(v34 + 8) = v36;
        *v36 = 0;
        *(_WORD *)(*(_QWORD *)(v34 + 8) + 2i64) = v37 - 4;
      }
      *(_QWORD *)(v31 + 24) = v34;
    }
    goto LABEL_35;
  }
  if ( byte_180092DE4 )
  {
    v37 = 2048;
    v36 = SPExternalAlloc(0x800u);
    *(_BYTE *)(v31 + 32) = 1;
    goto LABEL_51;
  }
LABEL_35:
  *(_QWORD *)(v31 + 8) = v33;
  RandomBits = 1359;
  *(_QWORD *)(v33 + 128) = v31;
  *(_QWORD *)(*((_QWORD *)this + 16) + 16i64) = *(_QWORD *)(v32 + 8);
  *((_QWORD *)this + 17) |= 0x40000ui64;
LABEL_36:
  if ( v53 != (unsigned int *)v55 )
    (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 16i64))(this);
  return RandomBits;
}
// 18003154B: variable 'v8' is possibly undefined
// 180031708: variable 'v42' is possibly undefined
// 180031737: variable 'v43' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18007C3B0: using guessed type wchar_t *off_18007C3B0;
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';
// 18007D508: using guessed type void *CSslScratchAllocator::`vftable';
// 1800925E8: using guessed type __int16 word_1800925E8;
// 1800925EA: using guessed type __int128 xmmword_1800925EA;
// 18009260A: using guessed type __int16 word_18009260A;
// 180092620: using guessed type __int64 LsaTable;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 180092DC0: using guessed type __int64 qword_180092DC0;
// 180092DD0: using guessed type __int128 xmmword_180092DD0;
// 180092DE4: using guessed type char byte_180092DE4;

//----- (000000018001E0C0) ----------------------------------------------------
__int64 __fastcall CTlsExtServer::ParseExtension(__int64 a1, int a2, unsigned __int8 *a3, unsigned __int16 a4)
{
  unsigned __int8 *v4; // r15
  __int64 v6; // r14
  __int16 *v7; // r8
  __int64 v8; // rcx
  __int64 result; // rax
  __int64 v10; // r11
  int v11; // esi
  int v12; // eax
  int v13; // r9d
  int v14; // ebx
  _WORD *v15; // rdi
  unsigned int v16; // ebx
  unsigned int v17; // ecx
  __int64 v18; // r10
  unsigned __int8 v19; // cl
  void **v20; // rax
  __int16 v21; // dx
  int v22; // eax
  __int64 v23; // rax
  __int16 v24; // bx
  unsigned int v25; // esi
  __int16 v26; // ax
  unsigned __int16 *v27; // rdi
  _QWORD *v28; // rcx
  unsigned __int16 v29; // bx
  __int64 v30; // rcx
  HLOCAL v31; // rax
  __int64 v32; // rax
  __int64 v33; // rbp
  __int64 v34; // rcx
  __int64 v35; // rcx
  __int64 v36; // rcx
  __int64 v37; // rax
  __int64 v38; // rcx
  __int64 v39; // rax
  __int64 v40; // rcx
  size_t v41; // rbx
  const void *v42; // r15
  int v43; // r8d
  int v44; // ebp
  CCipherMill *v45; // rcx
  __int64 v46; // r8
  unsigned __int16 v47; // dx
  __int64 v48; // rbx
  unsigned __int8 *v49; // rbp
  unsigned __int16 v50; // r12
  unsigned __int8 *v51; // rcx
  unsigned __int64 v52; // r13
  __int64 v53; // rax
  unsigned __int8 *v54; // rcx
  __int64 v55; // rax
  unsigned __int8 *v56; // rcx
  unsigned int v57; // esi
  unsigned __int64 v58; // rax
  unsigned __int8 *v59; // rdi
  SIZE_T v60; // rsi
  unsigned __int8 *v61; // r15
  __int64 v62; // r12
  unsigned int v63; // eax
  _WORD *v64; // rax
  __int64 v65; // rax
  __int16 v66; // ax
  unsigned int v67; // ecx
  _BYTE *v68; // rdi
  unsigned int v69; // edi
  CCipherMill *v70; // rcx
  __int64 v71; // rdx
  CCipherMill *v72; // rcx
  __int64 v73; // rdx
  __int64 v74; // rcx
  __int64 v75; // r10
  unsigned __int16 v76; // r8
  unsigned __int16 v77; // r9
  unsigned __int16 v78; // cx
  CSsl3TlsServerContext *v79; // rcx
  __int64 v80; // rbx
  __int64 v81; // rcx
  __int64 v82; // rcx
  unsigned __int16 v83; // dx
  int v84; // r9d
  __int64 v85; // rax
  CCipherMill *v86; // rbp
  unsigned __int16 v87; // [rsp+30h] [rbp-98h]
  unsigned int v88; // [rsp+34h] [rbp-94h]
  char *v89; // [rsp+38h] [rbp-90h]
  __int64 v90; // [rsp+40h] [rbp-88h]
  unsigned __int64 v91; // [rsp+48h] [rbp-80h]
  unsigned __int8 *v93; // [rsp+58h] [rbp-70h]
  __int16 v94; // [rsp+60h] [rbp-68h] BYREF
  __int128 v95[2]; // [rsp+62h] [rbp-66h] BYREF
  unsigned __int16 v96; // [rsp+82h] [rbp-46h]

  v4 = 0i64;
  v89 = 0i64;
  v6 = a1;
  if ( a2 != 65281 )
  {
    if ( a2 > 65281 )
    {
LABEL_220:
      CSchannelTelemetryContext::LogUnknownTlsExtension(
        *(CSchannelTelemetryContext **)(*(_QWORD *)(a1 + 8) + 120i64),
        a2);
    }
    else
    {
      v7 = &_ImageBase;
      switch ( a2 )
      {
        case 0:
          v80 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 80i64);
          if ( !(unsigned int)CTlsExtServer::ParseServerNameExtension((CSsl3TlsServerContext **)a1, a3, a4)
            && (*(_DWORD *)(v80 + 156) & 0x100) != 0 )
          {
            *(_QWORD *)(*(_QWORD *)(v6 + 8) + 136i64) |= 0x200000ui64;
          }
          CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 120i64), 1, 0);
          return 0i64;
        case 5:
          if ( a4 && *a3 == 1 )
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 8) + 136i64) |= 0x20000ui64;
            CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 120i64), 1, 5);
          }
          else if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                 && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 56i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
          }
          return 0i64;
        case 6:
          v67 = *a3;
          v68 = a3 + 1;
          if ( v67 != a4 - 1 )
            return 2148074278i64;
          if ( !v67 )
            goto LABEL_115;
          while ( *v68 != 64 )
          {
            LODWORD(v4) = (_DWORD)v4 + 1;
            ++v68;
            if ( (unsigned int)v4 >= v67 )
              goto LABEL_115;
          }
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 54i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
          }
          *(_BYTE *)(*(_QWORD *)(v6 + 8) + 922i64) = 1;
LABEL_115:
          CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 120i64), 1, 6);
          return 0i64;
        case 10:
          if ( a4 < 2u )
            return (unsigned int)-2146893018;
          v24 = *a3;
          v25 = a4 - 2;
          v26 = a3[1];
          v27 = (unsigned __int16 *)(a3 + 2);
          v28 = *(_QWORD **)(a1 + 8);
          v29 = v26 | (v24 << 8);
          if ( v28[114] )
          {
            (*(void (__fastcall **)(_QWORD *))(*v28 + 16i64))(v28);
            v28 = *(_QWORD **)(v6 + 8);
          }
          v30 = *(_QWORD *)(v28[16] + 24i64);
          if ( v30 )
          {
            LOBYTE(v7) = 1;
            v31 = (HLOCAL)(*(__int64 (__fastcall **)(__int64, _QWORD, __int16 *))(*(_QWORD *)v30 + 48i64))(v30, v29, v7);
          }
          else if ( LsaTable )
          {
            v31 = (HLOCAL)(*(__int64 (__fastcall **)(_QWORD))(LsaTable + 40))(v29);
          }
          else
          {
            v31 = LocalAlloc(0x40u, v29);
          }
          *(_QWORD *)(*(_QWORD *)(v6 + 8) + 912i64) = v31;
          v32 = *(_QWORD *)(v6 + 8);
          if ( !*(_QWORD *)(v32 + 912) )
            return 14;
          if ( v29 < 2u || v25 != v29 || (v29 & 1) != 0 )
            return (unsigned int)-2146893018;
          if ( v25 > 1 )
          {
            v33 = ((v25 - 2) >> 1) + 1;
            do
            {
              *(_WORD *)(2i64 * (unsigned int)v4 + *(_QWORD *)(*(_QWORD *)(v6 + 8) + 912i64)) = _byteswap_ushort(*v27);
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
              {
                WPP_SF_D(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  27i64,
                  &WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
                  *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 912i64) + 2i64 * (unsigned int)v4));
              }
              LODWORD(v4) = (_DWORD)v4 + 1;
              ++v27;
              --v33;
            }
            while ( v33 );
            v32 = *(_QWORD *)(v6 + 8);
          }
          *(_WORD *)(v32 + 920) = v29 >> 1;
          v34 = *(_QWORD *)(*(_QWORD *)(v6 + 8) + 120i64);
          if ( v34 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
            *(_DWORD *)(v34 + 72) |= 0x80u;
          return 0i64;
        case 11:
          v35 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 120i64);
          if ( v35 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
            *(_DWORD *)(v35 + 72) |= 0x100u;
          return 0i64;
        case 13:
          v10 = *(_QWORD *)(a1 + 8);
          if ( (*(_DWORD *)(v10 + 64) & 0x41400) == 0 )
            goto LABEL_32;
          v94 = 0;
          memset(v95, 0, sizeof(v95));
          if ( *(_BYTE *)(v10 + 925) )
            return (unsigned int)-2146893018;
          v11 = a4;
          if ( !a3 )
            return (unsigned int)-2146893018;
          if ( a4 < 2u )
            return (unsigned int)-2146893018;
          v12 = a3[1];
          LOWORD(v13) = 0;
          v14 = *a3;
          v15 = a3 + 2;
          v16 = v12 | (v14 << 8);
          v94 = 0;
          v96 = 0;
          v17 = v16 >> 1;
          if ( v16 > v11 - 2 || (v16 & 1) != 0 || v17 - 1 > 0x4F )
            return (unsigned int)-2146893018;
          if ( !v17 )
            return (unsigned int)-2146893007;
          v18 = v17;
          do
          {
            v19 = 0;
            v20 = (void **)&unk_18007C390;
            v21 = __ROR2__(*v15, 8);
            while ( v21 != *(_WORD *)v20 )
            {
              v20 += 9;
              ++v19;
              if ( v20 >= &CSsl3TlsServerContext::`vftable' )
                goto LABEL_28;
            }
            if ( v19 < 0xCu )
            {
              v22 = (unsigned __int16)v13;
              if ( !_bittest(&v22, v19) && (unsigned __int16)v4 < 0x10u )
              {
                *((_WORD *)v95 + (unsigned __int16)v4) = __ROR2__(*((_WORD *)&unk_18007C390 + 36 * v19), 8);
                LOWORD(v4) = v94 + 1;
                v13 = v96 | (1 << v19);
                ++v94;
                v96 |= 1 << v19;
              }
            }
LABEL_28:
            ++v15;
            --v18;
          }
          while ( v18 );
          if ( !(_WORD)v4 )
            return (unsigned int)-2146893007;
          if ( v11 != v16 + 2 )
            return (unsigned int)-2146893018;
          CTlsSignatureSuiteList::SetSignatureSuiteList(
            (CTlsSignatureSuiteList *)(v10 + 510),
            (const struct CTlsSignatureSuiteList *)(v10 + 474));
          CTlsSignatureSuiteList::Restrict(
            (CTlsSignatureSuiteList *)(*(_QWORD *)(v6 + 8) + 510i64),
            (const struct CTlsSignatureSuiteList *)&v94,
            *(_DWORD *)(*(_QWORD *)(v6 + 8) + 64i64));
          *(_BYTE *)(*(_QWORD *)(v6 + 8) + 925i64) = 1;
          v10 = *(_QWORD *)(v6 + 8);
LABEL_32:
          v23 = *(_QWORD *)(v10 + 120);
          if ( v23 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
            *(_DWORD *)(v23 + 72) |= 0x200u;
          return 0i64;
        case 14:
          v75 = *(_QWORD *)(a1 + 32);
          if ( !*(_BYTE *)(v75 + 233) || !*(_QWORD *)(v75 + 800) )
            return 0i64;
          if ( a4 < 5u )
          {
            v70 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v71 = 59i64;
              goto LABEL_194;
            }
            return 2148074278i64;
          }
          v76 = _byteswap_ushort(*(_WORD *)a3);
          v77 = a4 - 2;
          if ( v77 < (unsigned __int64)v76 + 1 )
          {
            v70 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v71 = 60i64;
              goto LABEL_194;
            }
            return 2148074278i64;
          }
          v78 = a3[v76 + 2];
          if ( !(_BYTE)v78 )
            goto LABEL_169;
          if ( (unsigned __int16)(v77 - v76 - 1) < v78 )
          {
            v70 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v71 = 61i64;
              goto LABEL_194;
            }
            return 2148074278i64;
          }
          v4 = &a3[v76 + 3];
LABEL_169:
          result = CSsl3TlsServerContext::SelectSrtpParameters(
                     (CSsl3TlsServerContext *)v75,
                     (unsigned __int16 *const)a3 + 1,
                     v76,
                     v4,
                     v78);
          if ( (_DWORD)result )
            return result;
          CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 120i64), 1, 14);
          return 0i64;
        case 16:
          v46 = *(_QWORD *)(a1 + 8);
          if ( !*(_QWORD *)(v46 + 784) )
            return 0i64;
          if ( a4 < 4u )
          {
            v70 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v71 = 57i64;
              goto LABEL_194;
            }
            return 2148074278i64;
          }
          v47 = _byteswap_ushort(*(_WORD *)a3);
          if ( v47 != a4 - 2 )
          {
            v70 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v71 = 58i64;
              goto LABEL_194;
            }
            return 2148074278i64;
          }
          v48 = *(_QWORD *)(a1 + 32);
          v49 = a3 + 2;
          v90 = v48;
          if ( !*(_QWORD *)(v48 + 968) )
          {
            v87 = 0;
            v50 = 0;
            if ( a3 != (unsigned __int8 *)-2i64 )
            {
              if ( (unsigned __int16)(v47 - 2) > 0xFFFBu )
              {
                v72 = WPP_GLOBAL_Control;
                if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
                  || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
                {
                  return (unsigned int)-2146893018;
                }
                v73 = 74i64;
LABEL_147:
                WPP_SF_(*((_QWORD *)v72 + 2), v73, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
                return (unsigned int)-2146893018;
              }
              v51 = a3 + 2;
              v52 = (unsigned __int64)&v49[v47];
              if ( (unsigned __int64)v49 < v52 )
              {
                while ( 1 )
                {
                  v53 = *v51;
                  if ( !(_BYTE)v53 )
                    break;
                  v54 = &v51[v53];
                  if ( (unsigned __int64)v54 >= v52 )
                    break;
                  v51 = v54 + 1;
                  if ( (unsigned __int64)v51 >= v52 )
                    goto LABEL_81;
                }
                v72 = WPP_GLOBAL_Control;
                if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
                  || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
                {
                  return (unsigned int)-2146893018;
                }
                v73 = 76i64;
                goto LABEL_147;
              }
LABEL_81:
              v55 = *(_QWORD *)(v48 + 784);
              if ( v55 )
              {
                v56 = (unsigned __int8 *)(v55 + 6);
                v88 = 0;
                v57 = 0;
                v58 = v55 + 6 + *(unsigned __int16 *)(v55 + 4);
                v93 = v56;
                v91 = v58;
                while ( 1 )
                {
                  v59 = v56;
                  if ( (unsigned __int64)v56 < v58 )
                  {
                    do
                    {
                      v60 = *v59;
                      v61 = v49;
                      if ( (unsigned __int64)v49 < v52 )
                      {
                        while ( 1 )
                        {
                          v62 = *v61;
                          if ( (_BYTE)v60 == (_BYTE)v62 && RtlCompareMemory(v59 + 1, v61 + 1, v60) == v60 )
                            break;
                          v61 += v62 + 1;
                          if ( (unsigned __int64)v61 >= v52 )
                            goto LABEL_87;
                        }
                        v66 = v60 + 1;
                        if ( *(_QWORD *)(v90 + 968) )
                        {
                          memcpy_0(v89, v59, (unsigned __int16)(v60 + 1));
                          v89 += (unsigned __int16)(v60 + 1);
LABEL_87:
                          v50 = v87;
                          goto LABEL_88;
                        }
                        v50 = v66 + v87;
                        v87 += v66;
                      }
LABEL_88:
                      v59 += v60 + 1;
                    }
                    while ( (unsigned __int64)v59 < v91 );
                    v6 = a1;
                    v48 = v90;
                    v57 = v88;
                  }
                  if ( !v50 )
                    break;
                  if ( !*(_QWORD *)(v48 + 968) )
                  {
                    v63 = v50 + 6;
                    if ( LsaTable )
                      v64 = (_WORD *)(*(__int64 (__fastcall **)(_QWORD))(LsaTable + 40))(v63);
                    else
                      v64 = LocalAlloc(0x40u, v63);
                    *(_QWORD *)(v48 + 968) = v64;
                    if ( !v64 )
                      return 14;
                    v64[2] = v50;
                    v89 = (char *)(*(_QWORD *)(v48 + 968) + 6i64);
                  }
                  v88 = ++v57;
                  if ( v57 >= 2 )
                  {
                    v46 = *(_QWORD *)(v6 + 8);
                    goto LABEL_98;
                  }
                  v58 = v91;
                  v56 = v93;
                }
                if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
                {
                  WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 65i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
                }
                v69 = -2146892953;
                CSslContext::SetErrorAndFatalAlert(v48, 1208, -2146892953, 0x78u);
                *(_DWORD *)(v48 + 68) = 96;
                *(_WORD *)(v48 + 96) = 30722;
                return v69;
              }
            }
            return 87;
          }
LABEL_98:
          v65 = *(_QWORD *)(v46 + 120);
          if ( v65 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
            *(_DWORD *)(v65 + 72) |= 0x800u;
          break;
        case 23:
          if ( CSslGlobals::m_fDisableServerExtendedMS || (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 64i64) & 0x51540) == 0 )
          {
            v74 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 120i64);
            if ( v74 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
              *(_WORD *)(v74 + 66) |= 0x10u;
          }
          else
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 8) + 136i64) |= 0x8000000ui64;
            v8 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 120i64);
            if ( v8 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
              *(_DWORD *)(v8 + 72) |= 0x1000u;
          }
          return 0i64;
        case 24:
          v79 = *(CSsl3TlsServerContext **)(a1 + 32);
          if ( !*((_QWORD *)v79 + 102) )
            return 0i64;
          if ( a4 < 4u )
          {
            v70 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v71 = 62i64;
              goto LABEL_194;
            }
            return 2148074278i64;
          }
          if ( (unsigned __int16)(a4 - 3) < a3[2] )
          {
            v70 = WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
            {
              v71 = 63i64;
              goto LABEL_194;
            }
            return 2148074278i64;
          }
          result = CSsl3TlsServerContext::SelectTBParameters(v79, *a3, a3[1], a3 + 3, a3[2]);
          if ( (_DWORD)result )
            return result;
          CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 120i64), 1, 24);
          return 0i64;
        case 35:
          v36 = *(_QWORD *)(a1 + 8);
          v37 = *(_QWORD *)(v36 + 136);
          if ( (v37 & 0x800) != 0 )
          {
            if ( a4 )
            {
              *(_DWORD *)(v36 + 984) = a4;
              *(_QWORD *)(v36 + 976) = a3;
            }
            else
            {
              *(_QWORD *)(v36 + 136) = v37 | 0x400000;
            }
          }
          v38 = *(_QWORD *)(*(_QWORD *)(v6 + 8) + 120i64);
          if ( v38 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
            *(_DWORD *)(v38 + 72) |= 0x2000u;
          return 0i64;
        default:
          goto LABEL_220;
      }
    }
    return 0i64;
  }
  v39 = *(_QWORD *)(a1 + 8);
  if ( !*(_DWORD *)(v39 + 416) || *(_BYTE *)(v39 + 553) )
  {
    *(_BYTE *)(v39 + 553) = 1;
    v40 = *(_QWORD *)(a1 + 8);
    v41 = *(unsigned int *)(v40 + 416);
    v42 = (const void *)(v40 + 377);
    if ( a4 )
    {
      v43 = *a3;
      v44 = a4;
      if ( v43 + 1 == a4 )
      {
        if ( a4 == 1 )
        {
          v45 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 67i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
            v45 = WPP_GLOBAL_Control;
          }
          if ( (_DWORD)v41 )
          {
            if ( v45 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v45 + 28) & 1) == 0 )
              goto LABEL_203;
            v82 = *((_QWORD *)v45 + 2);
            v83 = 68;
            v84 = v44;
LABEL_202:
            WPP_SF_DD(v82, v83, (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids, v84, v41);
LABEL_203:
            v40 = *(_QWORD *)(v6 + 8);
LABEL_204:
            CSslContext::SetErrorAndFatalAlert(v40, 1207, -2146892986, 0x28u);
            v85 = *(_QWORD *)(v6 + 8);
            *(_DWORD *)(v85 + 68) = 96;
            *(_WORD *)(v85 + 96) = 10242;
            return 2148074310i64;
          }
        }
        else
        {
          if ( v43 != (_DWORD)v41 )
          {
            if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
              || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
            {
              goto LABEL_204;
            }
            v82 = *((_QWORD *)WPP_GLOBAL_Control + 2);
            v83 = 69;
            v84 = v43;
            goto LABEL_202;
          }
          v86 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
          {
            if ( (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 70i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
              v86 = WPP_GLOBAL_Control;
            }
            if ( v86 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_DWORD *)v86 + 7) & 0x800) != 0 )
            {
              WPP_SF_(*((_QWORD *)v86 + 2), 71i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
              v86 = WPP_GLOBAL_Control;
            }
          }
          if ( memcmp_0(a3 + 1, v42, v41) )
          {
            if ( v86 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v86 + 28) & 1) != 0 )
              WPP_SF_(*((_QWORD *)v86 + 2), 72i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
            goto LABEL_203;
          }
          CSchannelTelemetryContext::LogTlsExtensionTelemetry(*(_QWORD *)(*(_QWORD *)(v6 + 8) + 120i64), 1, 65281);
        }
        return 0i64;
      }
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x800) != 0 )
      {
        WPP_SF_DD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x42u,
          (__int64)&WPP_f49a95b901763c3505884ea2834cd757_Traceguids,
          v43,
          a4);
      }
    }
    else
    {
      v70 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        v71 = 65i64;
LABEL_194:
        WPP_SF_(*((_QWORD *)v70 + 2), v71, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
      }
    }
    return 2148074278i64;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 64i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
    v39 = *(_QWORD *)(v6 + 8);
  }
  CSslContext::SetErrorAndFatalAlert(v39, 1207, -2146892986, 0x28u);
  v81 = *(_QWORD *)(v6 + 8);
  result = 2148074310i64;
  *(_DWORD *)(v81 + 68) = 96;
  *(_WORD *)(v81 + 96) = 10242;
  return result;
}
// 180031905: variable 'v7' is possibly undefined
// 180000000: using guessed type __int16 _ImageBase;
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';
// 180092620: using guessed type __int64 LsaTable;
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 1800927B4: using guessed type int CSslGlobals::m_fDisableServerExtendedMS;

//----- (000000018001E850) ----------------------------------------------------
__int64 __fastcall CCipherMill::FindAcceptableKeyXCurve(
        CCipherMill *this,
        struct CSsl3TlsServerContext *a2,
        struct CCipherSuiteInfo *a3,
        char a4,
        char a5,
        PCUNICODE_STRING String2,
        unsigned int *a7,
        unsigned __int8 *a8)
{
  struct CSsl3TlsServerContext *v9; // r14
  unsigned int v10; // edi
  bool v11; // zf
  unsigned int v12; // esi
  unsigned int v13; // r13d
  char v14; // al
  __int64 v15; // rdx
  unsigned __int64 v16; // rbp
  __int64 v17; // rax
  __int64 v18; // r15
  unsigned __int64 v19; // r14
  unsigned int v20; // r12d
  unsigned __int64 v21; // rsi
  unsigned __int64 v22; // rbx
  const UNICODE_STRING *v23; // rax
  const wchar_t *v24; // r9
  unsigned int v25; // ebx
  unsigned int v26; // edx
  __int64 v27; // r8
  char v28; // r12
  unsigned int v29; // ecx
  bool v30; // cc
  CCipherMill *v31; // r10
  int v32; // eax
  unsigned int v33; // edi
  unsigned __int64 v34; // rdi
  unsigned int v35; // eax
  unsigned int v36; // eax
  unsigned int v37; // ecx
  __int64 v39; // rax
  unsigned __int16 v40; // dx
  __int64 v41; // [rsp+20h] [rbp-88h]
  __int64 v42; // [rsp+28h] [rbp-80h]
  char v43; // [rsp+40h] [rbp-68h]
  unsigned int v44; // [rsp+44h] [rbp-64h]
  unsigned int v45; // [rsp+48h] [rbp-60h]
  __int64 v46; // [rsp+50h] [rbp-58h] BYREF
  unsigned int v47; // [rsp+58h] [rbp-50h]
  __int64 v48; // [rsp+60h] [rbp-48h]
  char v49; // [rsp+B0h] [rbp+8h]

  v9 = a2;
  if ( !a2 || !a3 || !a7 || !a8 )
    return 2148074244i64;
  v10 = *((_DWORD *)a3 + 5);
  v11 = (*((_DWORD *)a2 + 16) & 0x1000) == 0;
  v12 = 0;
  v13 = 0;
  *a8 = 0;
  *a7 = 0;
  v44 = 0;
  LODWORD(v46) = 0;
  v45 = 0;
  v47 = v10;
  v14 = !v11;
  v43 = v14;
  if ( !a4 || v14 )
  {
    v49 = 0;
  }
  else
  {
    v39 = *(_QWORD *)a2;
    v49 = 1;
    v46 = 0i64;
    (*(void (__fastcall **)(struct CSsl3TlsServerContext *, __int64 *))(v39 + 232))(a2, &v46);
    if ( !v46 )
      return (unsigned int)-2146893052;
    LODWORD(v46) = *(_DWORD *)(v46 + 184);
  }
  v15 = *((_QWORD *)a3 + 106);
  v48 = v15;
  if ( !v15 )
    return (unsigned int)-2146893052;
  v16 = *(_QWORD *)v15;
  if ( *(_QWORD *)v15 >= *(_QWORD *)v15 + 780 * (unsigned __int64)*(unsigned int *)(v15 + 8) )
  {
    v31 = WPP_GLOBAL_Control;
    goto LABEL_132;
  }
  while ( 2 )
  {
    v17 = *((_QWORD *)v9 + 10);
    v18 = *(unsigned int *)(v17 + 196);
    v19 = *(_QWORD *)(v17 + 200);
    if ( !(_DWORD)v18 || !v19 || !v16 )
    {
LABEL_27:
      v9 = a2;
      v25 = *(_DWORD *)(v16 + 772);
      v26 = (*(__int64 (__fastcall **)(struct CSsl3TlsServerContext *, _QWORD))(*(_QWORD *)a2 + 544i64))(a2, v25);
      if ( v26 && v26 != 1168 && v26 != 50 )
        return v26;
      v28 = v49;
      if ( v49 )
      {
        v32 = v46;
        if ( !v26 && v25 == (_DWORD)v46 )
        {
          v31 = WPP_GLOBAL_Control;
          goto LABEL_69;
        }
        v31 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_39;
        LODWORD(v42) = v46;
        LODWORD(v41) = v25;
        WPP_SF_SDD(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x30u, v27, (const wchar_t *)v16, v41, v42);
        goto LABEL_38;
      }
      if ( v26 == 50 )
      {
        v31 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_39;
        v40 = 49;
      }
      else
      {
        v29 = (*(_DWORD *)(v16 + 768) + (*(_DWORD *)(v16 + 768) & 1u)) >> 1;
        if ( v26 != 1168 )
        {
          if ( !v12 )
          {
            v44 = v25;
            v12 = v25;
            v45 = 0;
            v13 = (*(_DWORD *)(v16 + 768) + (*(_DWORD *)(v16 + 768) & 1u)) >> 1;
            if ( v29 == v10 )
            {
LABEL_67:
              v31 = WPP_GLOBAL_Control;
              break;
            }
            goto LABEL_34;
          }
LABEL_32:
          if ( v13 == v10 )
            goto LABEL_38;
          if ( v29 == v10 )
            goto LABEL_75;
LABEL_34:
          v30 = v13 <= v10;
          if ( v13 < v10 )
          {
            if ( v13 < v29 )
            {
LABEL_75:
              v13 = (*(_DWORD *)(v16 + 768) + (*(_DWORD *)(v16 + 768) & 1u)) >> 1;
              if ( v12 )
              {
                v25 = *(_DWORD *)(v16 + 772);
                v44 = v25;
                if ( v29 != v10 )
                {
                  v31 = WPP_GLOBAL_Control;
                  goto LABEL_40;
                }
                goto LABEL_67;
              }
              if ( v45 )
                v45 = *(_DWORD *)(v16 + 772);
LABEL_38:
              v31 = WPP_GLOBAL_Control;
              goto LABEL_39;
            }
            v30 = v13 <= v10;
          }
          if ( v30 || v13 <= v29 || v29 <= v10 )
            goto LABEL_38;
          goto LABEL_75;
        }
        if ( !v12 )
        {
          if ( v45 )
            goto LABEL_32;
          if ( !*((_DWORD *)a2 + 17) && v43 )
          {
            v45 = v25;
            v13 = (*(_DWORD *)(v16 + 768) + (*(_DWORD *)(v16 + 768) & 1u)) >> 1;
            goto LABEL_32;
          }
        }
        v31 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0 )
          goto LABEL_39;
        v40 = 50;
      }
      WPP_SF_S(
        *((_QWORD *)v31 + 2),
        v40,
        (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
        (const wchar_t *)v16);
      v31 = WPP_GLOBAL_Control;
      goto LABEL_39;
    }
    v20 = *(_DWORD *)(v16 + 768);
    v21 = v19 + 40 * v18;
    v22 = *(_QWORD *)(v17 + 200);
    if ( v19 >= v21 )
    {
LABEL_20:
      if ( !IsCngAlgorithmBlacklisted(v19, v18, 0, (const wchar_t *)v16, 0i64, 0, String2, a5) )
      {
        switch ( *(_DWORD *)(v16 + 772) )
        {
          case 0x17:
            v24 = L"ECDH_P256";
            break;
          case 0x18:
            v24 = L"ECDH_P384";
            break;
          case 0x19:
            v24 = L"ECDH_P521";
            break;
          default:
            goto LABEL_26;
        }
        if ( !IsCngAlgorithmBlacklisted(v19, v18, 0, v24, 0i64, 0, String2, a5) )
        {
LABEL_26:
          v12 = v44;
          goto LABEL_27;
        }
      }
LABEL_99:
      v31 = WPP_GLOBAL_Control;
      goto LABEL_100;
    }
    while ( 1 )
    {
      if ( *(_DWORD *)(v22 + 20) )
      {
        if ( !*(_DWORD *)v22 )
          goto LABEL_51;
        v23 = String2;
        if ( String2 )
          break;
      }
LABEL_18:
      v22 += 40i64;
      if ( v22 >= v21 )
      {
        v10 = v47;
        goto LABEL_20;
      }
    }
    v33 = 0;
    while ( RtlCompareUnicodeString((PCUNICODE_STRING)(*(_QWORD *)(v22 + 8) + 16i64 * v33), v23, 1u) )
    {
      v23 = String2;
      if ( ++v33 >= *(_DWORD *)v22 )
        goto LABEL_18;
    }
LABEL_51:
    if ( a5 && (*(_BYTE *)(v22 + 32) & 1) != 0 )
      goto LABEL_18;
    v34 = *(_QWORD *)(v22 + 24);
    if ( v34 >= v34 + 48i64 * *(unsigned int *)(v22 + 20) )
      goto LABEL_18;
    while ( 1 )
    {
      if ( *(_DWORD *)v34 || *(_WORD *)(v34 + 8) != 8 || wcsncmp(*(const wchar_t **)(v34 + 16), L"ECDH", 4ui64) )
        goto LABEL_55;
      if ( !*(_DWORD *)(v34 + 24) && !*(_DWORD *)(v34 + 40) && !*(_DWORD *)(v34 + 44) )
        break;
      if ( !v20 )
        goto LABEL_55;
      v35 = *(_DWORD *)(v34 + 40);
      if ( !v35 )
      {
        if ( !*(_DWORD *)(v34 + 44) )
          goto LABEL_55;
        v36 = *(_DWORD *)(v34 + 44);
LABEL_94:
        if ( v36 < v20 )
        {
LABEL_95:
          v31 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control )
            goto LABEL_103;
          if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            LODWORD(v42) = 0;
            LODWORD(v41) = v20;
            WPP_SF_Sdd(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xEu,
              (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
              L"ECDH",
              v41,
              v42);
            goto LABEL_99;
          }
          goto LABEL_100;
        }
        goto LABEL_55;
      }
      if ( v35 > v20 )
        goto LABEL_95;
      v36 = *(_DWORD *)(v34 + 44);
      if ( v36 )
        goto LABEL_94;
LABEL_55:
      v34 += 48i64;
      if ( v34 >= *(_QWORD *)(v22 + 24) + 48 * (unsigned __int64)*(unsigned int *)(v22 + 20) )
        goto LABEL_18;
    }
    v31 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control )
      goto LABEL_103;
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      LODWORD(v41) = 0;
      WPP_SF_Sd(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xCu,
        (__int64)&WPP_8df7ab8bd71935acb34f6c4601d37485_Traceguids,
        L"ECDH",
        v41);
      goto LABEL_99;
    }
LABEL_100:
    if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v31 + 28) & 4) != 0 )
    {
      WPP_SF_S(
        *((_QWORD *)v31 + 2),
        0x2Fu,
        (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids,
        (const wchar_t *)v16);
      v31 = WPP_GLOBAL_Control;
    }
LABEL_103:
    v9 = a2;
    v28 = v49;
LABEL_39:
    v25 = v44;
LABEL_40:
    v16 += 780i64;
    if ( v16 < *(_QWORD *)v48 + 780 * (unsigned __int64)*(unsigned int *)(v48 + 8) )
    {
      v10 = v47;
      v12 = v44;
      continue;
    }
    break;
  }
  v32 = v46;
LABEL_69:
  v37 = v45;
  if ( !v25 && !v45 )
  {
LABEL_132:
    if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v31 + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)v31 + 2), 51i64, &WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids);
    return (unsigned int)-2146893007;
  }
  if ( v28 && v25 != v32 )
  {
    if ( v31 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v31 + 28) & 4) != 0 )
    {
      LODWORD(v41) = v32;
      WPP_SF_DD(*((_QWORD *)v31 + 2), 0x34u, (__int64)&WPP_bcb3b342e8be3997fa3752f6a9108bb3_Traceguids, v25, v41);
    }
    return (unsigned int)-2146893007;
  }
  if ( v25 || !v45 )
  {
    v37 = v25;
    *a8 = 0;
  }
  else
  {
    *a8 = 1;
  }
  v26 = 0;
  *a7 = v37;
  return v26;
}
// 18003211B: variable 'v27' is possibly undefined
// 18003211B: variable 'v41' is possibly undefined
// 18003211B: variable 'v42' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (000000018001ED90) ----------------------------------------------------
__int64 __fastcall SpAcceptLsaModeContext(
        struct CCredentialGroup *a1,
        __int64 a2,
        struct _SecBufferDesc *a3,
        unsigned int a4,
        int a5,
        __int64 *a6,
        __int64 a7,
        _DWORD *a8,
        union _LARGE_INTEGER *a9,
        unsigned __int8 *a10,
        struct _SecBuffer *a11)
{
  unsigned int *v11; // r11
  __int64 v12; // rdi
  __int64 v13; // r12
  __int64 v15; // rax
  unsigned __int64 v16; // r14
  int v18; // r10d
  struct _SecBuffer *v19; // r15
  __int64 v20; // rsi
  unsigned int v21; // ecx
  unsigned int v22; // ebx
  unsigned int v23; // r8d
  __int64 v24; // r9
  _DWORD *v25; // rdx
  int v26; // eax
  _DWORD *v27; // r9
  _DWORD *v28; // rdx
  unsigned __int64 v29; // rcx
  void *pvBuffer; // rax
  __int64 v31; // r8
  __int64 v32; // rsi
  struct CCredentialGroup *v33; // rax
  __int64 v34; // rcx
  struct CCredentialGroup *v35; // rdx
  unsigned int v36; // eax
  __int64 (__fastcall *v37)(__int64, __int64, _QWORD, _QWORD); // rdi
  unsigned __int8 v38; // al
  int v39; // ebx
  __int64 v40; // rax
  __int64 v42; // rbx
  bool v43; // zf
  bool v44; // al
  int v45; // eax
  int v46; // eax
  struct CSslParentContext *v47; // r14
  __int64 v48; // rcx
  int v49; // edi
  int v50; // r13d
  int v51; // ebx
  __int64 v52; // r12
  char v53; // bl
  int v54; // eax
  __int64 v55; // rax
  int v56; // eax
  int v57; // eax
  int v58; // eax
  __int64 v59; // rax
  __int64 *v60; // r9
  __int64 v61; // r9
  unsigned __int64 *v62; // rax
  __int64 v63; // rcx
  unsigned int v64; // ecx
  unsigned int v65; // eax
  void *v66; // rax
  __int64 v67; // rax
  void *v68; // rax
  __int64 v69; // rcx
  __int64 v70; // rax
  __int64 v71; // rdi
  void (__fastcall *v72)(__int64, __int64); // rbx
  __int64 v73; // rax
  void *v74; // rax
  int v75; // eax
  __int64 v76; // rdx
  __int64 v77; // rcx
  struct CSslParentContext *v78; // [rsp+70h] [rbp-90h] BYREF
  __int64 v79; // [rsp+78h] [rbp-88h]
  __int64 v80; // [rsp+80h] [rbp-80h] BYREF
  __int128 v81; // [rsp+90h] [rbp-70h] BYREF
  __int64 v82; // [rsp+A0h] [rbp-60h]
  __int64 v83; // [rsp+A8h] [rbp-58h]
  unsigned __int64 v84; // [rsp+B0h] [rbp-50h]
  struct _SecBuffer *v85; // [rsp+B8h] [rbp-48h] BYREF
  __int64 v86[2]; // [rsp+C0h] [rbp-40h] BYREF
  __int128 v87; // [rsp+D0h] [rbp-30h] BYREF
  struct _SecBuffer *v88; // [rsp+E0h] [rbp-20h] BYREF
  struct _SecBuffer *v89; // [rsp+E8h] [rbp-18h] BYREF
  struct _SecBuffer *v90; // [rsp+F0h] [rbp-10h] BYREF
  struct _SecBuffer *v91; // [rsp+F8h] [rbp-8h] BYREF
  struct _SecBuffer *v92; // [rsp+100h] [rbp+0h] BYREF
  struct _SecBuffer *v93; // [rsp+108h] [rbp+8h] BYREF
  struct _SecBuffer *v94; // [rsp+110h] [rbp+10h] BYREF
  struct _SecBuffer *v95; // [rsp+118h] [rbp+18h] BYREF
  struct _SecBuffer *v96; // [rsp+120h] [rbp+20h] BYREF
  struct _SecBuffer *v97; // [rsp+128h] [rbp+28h] BYREF
  unsigned __int64 *v98; // [rsp+130h] [rbp+30h]
  unsigned int *v99; // [rsp+190h] [rbp+90h]
  __int64 v100; // [rsp+198h] [rbp+98h]
  int v102; // [rsp+1A8h] [rbp+A8h]

  v100 = a2;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 28i64;
  v15 = a2;
  v16 = a4;
  LODWORD(a2) = 0;
  v102 = 0;
  v78 = 0i64;
  v85 = 0i64;
  v97 = 0i64;
  v89 = 0i64;
  v90 = 0i64;
  v92 = 0i64;
  v91 = 0i64;
  v93 = 0i64;
  v95 = 0i64;
  v94 = 0i64;
  v96 = 0i64;
  v88 = 0i64;
  v87 = 0i64;
  v79 = 0i64;
  v81 = 0i64;
  v98 = 0i64;
  v84 = a4;
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
  {
    McTemplateU0pp_EtwEventWriteTransfer((__int64)a1, 0i64, a1, v15);
    v15 = v100;
    v11 = 0i64;
    LODWORD(a2) = 0;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 40i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
      v15 = v100;
      v11 = 0i64;
      LODWORD(a2) = 0;
    }
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
    {
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 41i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
        v15 = v100;
        v11 = 0i64;
        LODWORD(a2) = 0;
      }
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
      {
        if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_q(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x2Au,
            (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
            a1);
          v15 = v100;
          v11 = 0i64;
          LODWORD(a2) = 0;
        }
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
        {
          if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_q(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x2Bu,
              (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
              v15);
            v11 = 0i64;
            LODWORD(a2) = 0;
          }
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 44i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids, a4);
            v11 = 0i64;
            LODWORD(a2) = 0;
          }
        }
      }
    }
  }
  if ( !a1 )
  {
    v22 = -2146893055;
    goto LABEL_157;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control )
  {
    if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        45i64,
        &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
        *((unsigned int *)a1 + 53));
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_S(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x2Eu,
        (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
        (const wchar_t *)a1 + 108);
  }
  v18 = 0;
  v19 = 0i64;
  v99 = 0i64;
  v11 = 0i64;
  v80 = 0i64;
  v82 = 0i64;
  v20 = 0i64;
  v21 = 0;
  v22 = 14;
  v23 = *(_DWORD *)(a7 + 4);
  if ( !v23 )
  {
LABEL_34:
    v29 = v16 & 0x100;
    goto LABEL_35;
  }
  v24 = *(_QWORD *)(a7 + 8);
  v25 = (_DWORD *)(v24 + 4);
  do
  {
    v26 = *v25 & 0xFFFFFFF;
    if ( v26 )
    {
      if ( v26 == 2 )
        goto LABEL_111;
      v56 = v26 - 17;
      if ( v56 )
      {
        v57 = v56 - 6;
        if ( v57 )
        {
          v58 = v57 - 3;
          if ( v58 )
          {
            if ( v58 == 1 )
              v20 = v24 + 16i64 * v21;
          }
          else
          {
            v82 = v24 + 16i64 * v21;
          }
        }
        else
        {
          v80 = v24 + 16i64 * v21;
        }
      }
      else
      {
        v11 = (unsigned int *)(v24 + 16i64 * v21);
      }
    }
    else if ( !v19 && (v16 & 0x100) != 0 )
    {
LABEL_111:
      v19 = (struct _SecBuffer *)(v24 + 16i64 * v21);
    }
    ++v21;
    v25 += 4;
  }
  while ( v21 < v23 );
  v27 = (_DWORD *)v80;
  v99 = v11;
  if ( v80 )
  {
    if ( (v16 & 0x100) != 0 )
    {
      *(_QWORD *)(v80 + 8) = 0i64;
      *v27 = 0;
    }
    else if ( !*(_QWORD *)(v80 + 8) )
    {
      v18 = 14;
    }
  }
  v28 = (_DWORD *)v82;
  if ( v82 )
  {
    if ( (v16 & 0x100) != 0 )
    {
      *(_QWORD *)(v82 + 8) = 0i64;
      *v28 = 0;
    }
    else if ( !*(_QWORD *)(v82 + 8) )
    {
      v18 = 14;
    }
  }
  if ( v20 )
  {
    if ( (v16 & 0x100) != 0 )
    {
      *(_QWORD *)(v20 + 8) = 0i64;
      *(_DWORD *)v20 = 0;
    }
    else if ( *(_QWORD *)(v20 + 8) )
    {
      if ( *(_DWORD *)v20 < 8u )
      {
        *(_DWORD *)v20 = 8;
        v18 = -2146893023;
      }
    }
    else
    {
      v18 = 14;
    }
  }
  if ( !v11 )
    goto LABEL_34;
  v29 = v16 & 0x100;
  if ( (v16 & 0x100) != 0 )
  {
    *((_QWORD *)v11 + 1) = 0i64;
    *v11 = 0;
    goto LABEL_189;
  }
  v59 = *((_QWORD *)v11 + 1);
  if ( !v59 )
  {
    v18 = 14;
LABEL_189:
    v59 = 0i64;
  }
  *((_QWORD *)&v87 + 1) = v59;
  *(_QWORD *)&v87 = *v11;
LABEL_35:
  if ( !v19 )
  {
    v22 = -2146893048;
    goto LABEL_192;
  }
  v19->BufferType = 2;
  if ( !v29 )
  {
    pvBuffer = v19->pvBuffer;
    if ( pvBuffer )
      goto LABEL_38;
LABEL_192:
    LODWORD(a2) = 0;
LABEL_157:
    v13 &= ~0x8000ui64;
    goto LABEL_90;
  }
  v19->pvBuffer = 0i64;
  pvBuffer = 0i64;
  v19->cbBuffer = 0;
LABEL_38:
  *((_QWORD *)&v81 + 1) = pvBuffer;
  v22 = v18;
  *(_QWORD *)&v81 = v19->cbBuffer;
  if ( v18 )
  {
    LODWORD(a2) = 0;
  }
  else
  {
    if ( (v16 & 2) != 0 )
    {
      v12 = 256i64;
      v79 = 256i64;
    }
    if ( CSslGlobals::m_dwEnableSessionTicket == 1 || CSslGlobals::m_dwEnableSessionTicket != 2 && (v16 & 0x40) != 0 )
    {
      v12 |= 0x800ui64;
      v79 = v12;
    }
    if ( (v16 & 0x1000000) != 0 )
    {
      v12 |= 0x10000ui64;
      v13 = 16777244i64;
      v79 = v12;
    }
    if ( v29 )
      v13 |= 0x100ui64;
    if ( (v16 & 0x8000) != 0 )
    {
      v13 |= 0x8000ui64;
      v12 |= 0x200ui64;
      v79 = v12;
    }
    if ( (v16 & 0x800) != 0 )
    {
      v13 |= 0x800ui64;
      v12 |= 0x1000ui64;
      v83 = v13;
      v79 = v12;
      if ( (v16 & 0x400) != 0
        && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 47i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
      }
    }
    else
    {
      v13 |= 0x10000ui64;
      v83 = v13;
    }
    if ( (*((_BYTE *)a1 + 156) & 1) != 0 )
    {
      v12 |= 0x10000ui64;
      v79 = v12;
    }
    v22 = ParseInputBufferDesc(
            a3,
            &v85,
            (struct SPBuffer *)v86,
            &v97,
            &v89,
            &v90,
            &v92,
            &v91,
            &v93,
            &v95,
            &v94,
            &v96,
            &v88);
    if ( v22 )
      goto LABEL_84;
    if ( !v88 )
      goto LABEL_56;
    v60 = (__int64 *)v88->pvBuffer;
    if ( v60 && v88->cbBuffer >= 8 )
    {
      v61 = *v60;
      if ( (v61 & 0xFFFFFFFEFFFFFFFFui64) != 0 )
      {
        v22 = -2146892963;
        goto LABEL_84;
      }
      if ( (v61 & 0x100000000i64) != 0 )
      {
        v13 |= 0x100000000ui64;
        v79 = v12 | 0x100000000i64;
        v83 = v13;
      }
      v16 |= v61;
      v84 = v16;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_i(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x30u, (__int64)&WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids);
      if ( v20 )
      {
        v62 = *(unsigned __int64 **)(v20 + 8);
        if ( !v62 )
        {
          v62 = (unsigned __int64 *)SPExternalAlloc(8u);
          *(_QWORD *)(v20 + 8) = v62;
          if ( !v62 )
          {
            v11 = v99;
            v22 = -2146893056;
            LODWORD(a2) = 0;
            goto LABEL_85;
          }
          *(_DWORD *)v20 = 8;
        }
        v98 = v62;
      }
LABEL_56:
      v31 = 0i64;
      if ( v85 && (v85->BufferType & 0xFFFFFFF) != 2 )
      {
        v86[1] = 0i64;
        v86[0] = 0i64;
      }
      if ( !v100 )
      {
        v22 = CSslContextManager::InstantiateServerContext(
                (CSslContextManager *)&g_SslContextManager,
                (struct SPBuffer *)v86,
                (struct SPBuffer *)&v81,
                v19,
                v89,
                a1,
                v16,
                &v78);
        if ( v22 )
          goto LABEL_84;
        v32 = *((_QWORD *)v78 + 1);
        v42 = *(_QWORD *)(v32 + 120);
        if ( v42 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
        {
          *(_DWORD *)(v42 + 12) = 1;
          QueryPerformanceCounter((LARGE_INTEGER *)(v42 + 80));
          v43 = *(_DWORD *)(v42 + 12) == 1;
          *(_DWORD *)(v42 + 24) = 0;
          v44 = v43;
          v43 = !CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
          *(_BYTE *)(v42 + 28) = v44;
          *(_QWORD *)(v42 + 144) = v78;
          *(_QWORD *)(v42 + 120) = v16;
          *(_QWORD *)(v42 + 136) = a1;
          if ( !v43 )
            o_wcsncpy_s_0(v42 + 664, 256i64, (char *)a1 + 216, -1i64);
        }
        goto LABEL_64;
      }
      v32 = *(_QWORD *)(v100 + 8);
      a2 = 1i64;
      v102 = 1;
      v78 = (struct CSslParentContext *)v100;
      if ( _InterlockedIncrement((volatile signed __int32 *)v100) == 1 )
      {
        v33 = *(struct CCredentialGroup **)(v32 + 80);
        if ( v33 && v33 != a1 )
        {
          v22 = -2146893055;
          if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control
            || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) == 0 )
          {
            v11 = v99;
          }
          else
          {
            WPP_SF_D(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              50i64,
              &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids,
              2148074241i64);
            v11 = v99;
            LODWORD(a2) = 1;
          }
          goto LABEL_85;
        }
        *(_WORD *)(v100 + 34) = 0;
        *(_DWORD *)(v100 + 36) = 0;
LABEL_64:
        v34 = *((_QWORD *)v78 + 3);
        if ( v34 )
          (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v34 + 56i64))(v34, a2, v31);
        v35 = *(struct CCredentialGroup **)(v32 + 80);
        if ( v35 != a1 )
        {
          if ( v35 )
          {
            CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, v35);
            (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v32 + 256i64))(v32, 0i64);
          }
          _InterlockedIncrement((volatile signed __int32 *)a1 + 6);
          *(_QWORD *)(v32 + 80) = a1;
          v45 = *((_DWORD *)a1 + 39);
          if ( (v45 & 4) != 0 )
          {
            v63 = *(_QWORD *)(v32 + 136);
            if ( (v63 & 0x100) == 0 )
            {
              *(_QWORD *)(v32 + 136) = v63 | 0x4000;
              v45 = *((_DWORD *)a1 + 39);
            }
          }
          if ( (v45 & 0x4000) != 0 )
          {
            if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
            {
              WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 10i64, &WPP_c955f13c15ab3d9e41a0e2d56db0bfe4_Traceguids);
            }
            *(_QWORD *)(v32 + 136) |= 0x200000000ui64;
          }
          v46 = *(_DWORD *)(v32 + 68);
          if ( v46 == 91 || v46 == 101 )
          {
            if ( *(_BYTE *)(v32 + 266) )
            {
              *(_BYTE *)(v32 + 923) = 1;
              CSsl3TlsClientContext::SetDefCredSearched(v32, 0);
            }
            else
            {
              CSsl3TlsClientContext::CheckForClientCred((CSsl3TlsClientContext *)v32);
            }
          }
        }
        *(_QWORD *)(v32 + 136) |= v79;
        if ( (*(_DWORD *)(v32 + 68) & 0xFFFFFFFB) == 0 )
        {
          v22 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *, __int64))(*(_QWORD *)v32 + 296i64))(
                  v32,
                  v90,
                  v31);
          if ( v22 )
            goto LABEL_84;
          v22 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *, struct _SecBuffer *))(*(_QWORD *)v32 + 304i64))(
                  v32,
                  v92,
                  v91);
          if ( v22 )
            goto LABEL_84;
          v22 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v32 + 312i64))(v32, v93);
          if ( v22 )
            goto LABEL_84;
        }
        v22 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *, struct _SecBuffer *))(*(_QWORD *)v32 + 328i64))(
                v32,
                v95,
                v94);
        if ( v22 )
          goto LABEL_84;
        v22 = (*(__int64 (__fastcall **)(__int64, struct _SecBuffer *))(*(_QWORD *)v32 + 344i64))(v32, v96);
        if ( v22 )
          goto LABEL_84;
        v36 = (*(__int64 (__fastcall **)(__int64, struct _SecBufferDesc *, __int64))(*(_QWORD *)v32 + 368i64))(
                v32,
                a3,
                v82);
        v22 = v36;
        if ( v36 )
        {
          if ( *(_DWORD *)(v32 + 68) == 4 && v36 == 590614 )
          {
            v39 = 0;
            goto LABEL_75;
          }
LABEL_84:
          v11 = v99;
          LODWORD(a2) = v102;
          goto LABEL_85;
        }
        v37 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v32 + 376i64);
        if ( (v16 & 0x100) != 0 )
          LOBYTE(v22) = 1;
        v38 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v32 + 384i64))(v32);
        v22 = v37(v32, a7, v38, (unsigned __int8)v22);
        if ( v22 )
          goto LABEL_84;
        v39 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int128 *))(*(_QWORD *)v32 + 192i64))(v32, v86, &v81);
        if ( v39 != 1359 || (*(_DWORD *)(v32 + 136) & 0x40000) == 0 )
          goto LABEL_75;
        v47 = v78;
        if ( !v100 )
        {
          v32 = *((_QWORD *)v78 + 2);
          if ( v32 )
          {
            v78 = *(struct CSslParentContext **)(v32 + 128);
            if ( v78 )
            {
              v48 = *((_QWORD *)v47 + 1);
              *((_QWORD *)v47 + 2) = 0i64;
              v49 = *(_DWORD *)(v48 + 64);
              v50 = *(_DWORD *)(v48 + 68);
              if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
                && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
              {
                WPP_SF_q(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  0x12u,
                  (__int64)&WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids,
                  v47);
                v48 = *((_QWORD *)v47 + 1);
              }
              if ( v48 )
              {
                v51 = *(_DWORD *)(v48 + 64);
                (**(void (__fastcall ***)(__int64, _QWORD))v48)(v48, 0i64);
                if ( (v51 & 0x800A2AAA) != 0 )
                  SPExternalFree(*((void **)v47 + 1));
                *((_QWORD *)v47 + 1) = 0i64;
              }
              if ( (v49 & 0x51550) != 0 )
              {
                v52 = *((_QWORD *)v47 + 3);
                v53 = *((_BYTE *)v47 + 32);
                if ( !v52 )
                  goto LABEL_145;
                if ( v50 == 4 )
                {
                  v64 = (*(unsigned __int16 (__fastcall **)(_QWORD))(*(_QWORD *)v52 + 64i64))(*((_QWORD *)v47 + 3));
                  v65 = qword_180092DB8;
                  if ( (unsigned int)qword_180092DB8 <= v64 )
                    v65 = v64;
                  LODWORD(qword_180092DB8) = v65;
                  if ( _InterlockedIncrement((_DWORD *)&qword_180092DB0 + 1) == 100 )
                  {
                    if ( *((_QWORD *)&xmmword_180092DD0 + 1) )
                    {
                      LODWORD(qword_180092DC0) = qword_180092DB8;
                      if ( dword_180092DE0 )
                      {
                        v66 = operator new(0x80ui64);
                        if ( v66 )
                        {
                          v67 = CSslLookasidePreallocate::CSslLookasidePreallocate(
                                  (__int64)v66,
                                  qword_180092DC0,
                                  dword_180092DE0);
                          goto LABEL_244;
                        }
                      }
                      else
                      {
                        v68 = operator new(0x50ui64);
                        if ( v68 )
                        {
                          v67 = CSslLookaside::CSslLookaside((__int64)v68, qword_180092DC0, 1);
LABEL_244:
                          v69 = v67;
                          v70 = *((_QWORD *)&xmmword_180092DD0 + 1);
                          if ( v69 )
                            v70 = v69;
                          *((_QWORD *)&xmmword_180092DD0 + 1) = v70;
                        }
                      }
                    }
                  }
                }
                if ( v53 )
                {
                  v74 = (void *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v52 + 40i64))(v52);
                  SPExternalFree(v74);
                }
                else
                {
                  v71 = *((_QWORD *)&xmmword_180092DD0 + 1);
                  v72 = *(void (__fastcall **)(__int64, __int64))(**((_QWORD **)&xmmword_180092DD0 + 1) + 32i64);
                  v73 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v52 + 40i64))(v52);
                  v72(v71, v73);
                }
LABEL_145:
                *((_QWORD *)v47 + 3) = 0i64;
                (*(void (__fastcall **)(_QWORD, struct CSslParentContext *))(*(_QWORD *)xmmword_180092DD0 + 32i64))(
                  xmmword_180092DD0,
                  v47);
                v13 = v83;
              }
              else
              {
                SPExternalFree(v47);
              }
              v54 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int128 *))(*(_QWORD *)v32 + 192i64))(
                      v32,
                      v86,
                      &v81);
              v16 = v84;
              v39 = v54;
LABEL_75:
              v40 = *(_QWORD *)(v32 + 136);
              if ( (v40 & 0x10000000) != 0 )
              {
                v13 |= 0x8000ui64;
                *(_QWORD *)(v32 + 136) = v40 & 0xFFFFFFFFEFFFFFFFui64;
              }
              if ( v39 && !*((_DWORD *)v78 + 9) )
                *((_DWORD *)v78 + 9) = v39;
              if ( v99 )
                GenerateFatalAlertMessage(v39, v32, v16, (__int64)&v87);
              if ( v39 == 590624 && v80 )
                GeneratePSKExchangeMessage(v32, v80);
              if ( v100
                || !v39
                || v39 == 590614
                || v39 == -2146892950
                || HIBYTE(*(_WORD *)(v32 + 34)) == 0xFE && v39 == 590692 )
              {
                *a6 = (__int64)v78;
              }
              else
              {
                if ( (v16 & 0x100) != 0 && *((_QWORD *)&v81 + 1) )
                {
                  (*(void (__fastcall **)(__int64))(*(_QWORD *)v32 + 16i64))(v32);
                  *((_QWORD *)&v81 + 1) = 0i64;
                }
                CSslContextManager::DeleteFullSslContext((CSslContextManager *)&g_SslContextManager, v78);
                v32 = 0i64;
              }
              v22 = AscIscPostProcessing(
                      v39,
                      (struct CSslContext *)v32,
                      v78,
                      a11,
                      v97,
                      v85,
                      (struct SPBuffer *)v86,
                      v19,
                      (struct SPBuffer *)&v81,
                      v16,
                      a10,
                      a9);
              if ( !v22 && v32 && *(_DWORD *)(v32 + 68) == 4 )
              {
                v55 = *(_QWORD *)v32;
                v80 = 0i64;
                (*(void (__fastcall **)(__int64, __int64 *))(v55 + 232))(v32, &v80);
                if ( *(_QWORD *)(v80 + 344) )
                  v13 |= 2ui64;
                v11 = v99;
                LODWORD(a2) = v102;
                if ( (*(_DWORD *)(v32 + 136) & 0x400000) != 0 )
                  v13 |= 0x40ui64;
                goto LABEL_85;
              }
              goto LABEL_84;
            }
          }
        }
        LOWORD(v16) = v84;
        v22 = 1359;
        v11 = v99;
        LODWORD(a2) = v102;
      }
      else
      {
        v11 = v99;
        v22 = 120;
      }
    }
    else
    {
      v11 = v99;
      v22 = 87;
      LODWORD(a2) = 0;
    }
  }
LABEL_85:
  if ( !v19->cbBuffer || DWORD1(v81) > (unsigned int)v81 || v22 == -2146892949 )
    goto LABEL_157;
  if ( (v16 & 0x8000) != 0 )
    v13 |= 0x8000ui64;
LABEL_90:
  if ( v11 )
  {
    *((_QWORD *)v11 + 1) = *((_QWORD *)&v87 + 1);
    *v11 = DWORD1(v87);
  }
  if ( a8 )
    *a8 = v13;
  if ( v98 )
    *v98 = v13 & 0xFFFFFFFF00000000ui64;
  if ( (_DWORD)a2 && v78 )
    _InterlockedDecrement((volatile signed __int32 *)v78);
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 51i64, &WPP_cfd72fb444783f09dc03172c6e6e3628_Traceguids, v22);
  if ( (Microsoft_Windows_Schannel_EventsEnableBits & 1) != 0 )
  {
    v75 = TranslateToSecurityStatus(v22);
    McTemplateU0pd_EtwEventWriteTransfer(v77, v76, *a6, v75);
  }
  if ( (v22 & 0x1FFF0000) == 589824 )
  {
    if ( v22 + 2146893823 > 0x2E )
    {
      if ( v22 + 2146889727 > 0x100E && v22 + 2146885612 > 0xFEC && v22 != -2146885615 )
        return v22;
LABEL_263:
      if ( v22 > 0x80092004 )
      {
        switch ( v22 )
        {
          case 0x800B0101:
          case 0x800B0102:
            return (unsigned int)-2146893016;
          case 0x800B0109:
            return (unsigned int)-2146893019;
          case 0x800B010C:
            return (unsigned int)-2146885616;
          case 0x800B010F:
            return (unsigned int)-2146893022;
        }
      }
      else
      {
        switch ( v22 )
        {
          case 0x80092004:
            return (unsigned int)-2146893043;
          case 0xEu:
            return (unsigned int)-2146893056;
          case 0x57u:
            return (unsigned int)-2146892963;
          case 0x78u:
            return (unsigned int)-2146893054;
          case 0x7Au:
            return (unsigned int)-2146893023;
        }
      }
    }
    return (unsigned int)-2146893052;
  }
  if ( v22 )
    goto LABEL_263;
  return 0i64;
}
// 180032A0E: conditional instruction was optimized away because ecx.4 is in (FE00..FEFF)
// 18003270F: variable 'a2' is possibly undefined
// 18003270F: variable 'v31' is possibly undefined
// 180032AD5: variable 'v77' is possibly undefined
// 180032AD5: variable 'v76' is possibly undefined
// 180028D84: using guessed type __int64 __fastcall o_wcsncpy_s_0(_QWORD, _QWORD, _QWORD, _QWORD);
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 1800927B0: using guessed type unsigned int CSslGlobals::m_dwEnableSessionTicket;
// 180092DA0: using guessed type __int64 g_SslContextManager;
// 180092DB0: using guessed type __int64 qword_180092DB0;
// 180092DB8: using guessed type __int64 qword_180092DB8;
// 180092DC0: using guessed type __int64 qword_180092DC0;
// 180092DD0: using guessed type __int128 xmmword_180092DD0;
// 180092DE0: using guessed type int dword_180092DE0;
// 180092F00: using guessed type int Microsoft_Windows_Schannel_EventsEnableBits;

//----- (000000018001F810) ----------------------------------------------------
__int64 __fastcall CSslContextManager::InstantiateServerContext(
        CSslContextManager *this,
        struct SPBuffer *a2,
        struct SPBuffer *a3,
        struct _SecBuffer *a4,
        struct _SecBuffer *a5,
        struct CCredentialGroup *a6,
        unsigned __int64 a7,
        struct CSslParentContext **a8)
{
  char v8; // r12
  unsigned __int64 v11; // rsi
  CCipherMill *v12; // r11
  unsigned int v13; // ebx
  __int64 v14; // rdx
  int v15; // edi
  unsigned int v16; // ecx
  int v17; // r8d
  unsigned int v18; // ebp
  int v19; // eax
  unsigned int v20; // r9d
  unsigned int v21; // eax
  unsigned int v22; // ebp
  int v23; // r15d
  __int64 v24; // rax
  __int64 v25; // rdi
  __int64 v26; // rbx
  void ***v27; // r14
  __int64 v28; // r12
  void **v29; // rax
  __int64 v30; // rax
  char v31; // al
  unsigned __int16 v32; // ax
  unsigned int v33; // ecx
  int v34; // eax
  _DWORD *v35; // rsi
  __int16 v36; // ax
  __int16 v37; // cx
  __int64 v38; // rsi
  _QWORD *v39; // rax
  __int64 v40; // rcx
  __int64 v41; // rsi
  _DWORD *v42; // rbx
  __int64 result; // rax
  int v44; // r9d
  int v45; // eax
  ULONG v46; // edx
  __int64 v47; // rax
  char v48; // al
  unsigned __int16 v49; // ax
  unsigned int v50; // ecx
  int v51; // eax
  _DWORD *v52; // rsi
  __int16 v53; // ax
  __int16 v54; // cx
  _WORD *v55; // rax
  int v56; // r14d
  char v57[8]; // [rsp+30h] [rbp-58h] BYREF
  int v58; // [rsp+38h] [rbp-50h]
  int v59; // [rsp+98h] [rbp+10h]

  v8 = 0;
  v59 = 0;
  v11 = a7 & 0x100000000i64;
  v12 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11i64, &WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids);
    v12 = WPP_GLOBAL_Control;
  }
  v13 = *((_DWORD *)a2 + 1);
  if ( v13 < 5 && (a7 & 0x100000000i64) == 0 )
  {
    *((_DWORD *)a2 + 1) = 5;
    return 2148074264i64;
  }
  v14 = *((_QWORD *)a2 + 1);
  v15 = *((_DWORD *)a6 + 38);
  if ( (a7 & 0x100000000i64) != 0 )
  {
    if ( (v15 & 0xFFFFEFFF) != 0 )
      return 2148074333i64;
    v22 = 771;
    v23 = 1024;
    v8 = 1;
LABEL_18:
    v24 = (*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)this + 6) + 16i64))(*((_QWORD *)this + 6));
    v25 = v24;
    if ( v24 )
    {
      v26 = v24 + 40;
      *(_QWORD *)(v24 + 8) = 0i64;
      if ( !v8 )
      {
        *(_QWORD *)(v24 + 48) = 0i64;
        *(_QWORD *)v26 = &CSslContext::`vftable';
        *(_QWORD *)(v24 + 56) = 0i64;
        *(_QWORD *)(v24 + 64) = 0i64;
        *(_WORD *)(v24 + 72) = 0;
        *(_DWORD *)(v24 + 76) = 0;
        *(_OWORD *)(v24 + 80) = 0i64;
        *(_DWORD *)(v24 + 96) = 0;
        *(_WORD *)(v24 + 136) = 0;
        *(_BYTE *)(v24 + 272) = 0;
        *(_WORD *)(v24 + 304) = 0;
        *(_BYTE *)(v24 + 306) = 0;
        v47 = LsaTable;
        *(_DWORD *)(v26 + 64) = v23;
        *(_QWORD *)(v26 + 68) = 0i64;
        *(_QWORD *)(v26 + 80) = 0i64;
        *(_QWORD *)(v26 + 88) = 0i64;
        *(_QWORD *)(v26 + 104) = 0i64;
        *(_QWORD *)(v26 + 112) = 0i64;
        *(_QWORD *)(v26 + 120) = 0i64;
        *(_QWORD *)(v26 + 128) = 0i64;
        *(_QWORD *)(v26 + 136) = 0i64;
        *(_QWORD *)(v26 + 144) = 0i64;
        *(_QWORD *)(v26 + 152) = 0i64;
        *(_QWORD *)(v26 + 160) = 0i64;
        *(_QWORD *)(v26 + 168) = 0i64;
        *(_QWORD *)(v26 + 176) = 0i64;
        *(_QWORD *)(v26 + 184) = 0i64;
        *(_DWORD *)(v26 + 192) = 0;
        *(_QWORD *)(v26 + 200) = 0i64;
        *(_QWORD *)(v26 + 208) = 0i64;
        *(_DWORD *)(v26 + 216) = 0;
        *(_WORD *)(v26 + 220) = 0;
        *(_QWORD *)(v26 + 224) = 0i64;
        *(_WORD *)(v26 + 234) = 0;
        *(_QWORD *)(v26 + 240) = 0i64;
        *(_QWORD *)(v26 + 248) = 0i64;
        *(_QWORD *)(v26 + 256) = 0i64;
        if ( (*(unsigned __int8 (__fastcall **)(char *))(v47 + 192))(v57) )
        {
          v48 = v58;
          if ( (v58 & 1) != 0 )
            *(_QWORD *)(v26 + 136) |= 0x20000000ui64;
          *(_BYTE *)(v26 + 266) = (v48 & 0x11) == 0;
        }
        v49 = ConvertSchannelProtocolToSsl(*(_DWORD *)(v26 + 64));
        v50 = v49;
        *(_WORD *)(v26 + 34) = v49;
        if ( HIBYTE(v49) != 0xFE || (v51 = 13, v50 > 0xFEFF) )
          v51 = 5;
        *(_DWORD *)(v26 + 60) = v51;
        *(_BYTE *)(v26 + 233) = (v23 & 0xF0000) != 0;
        if ( dword_180091480
          && (qword_180091490 & 0x400000000000i64) != 0
          && (qword_180091498 & 0x400000000000i64) == qword_180091498
          && (v52 = SPExternalAlloc(0x700u)) != 0i64 )
        {
          v52[2] = 0;
          *(_QWORD *)v52 = &CSchannelTelemetryContext::`vftable';
          *((_BYTE *)v52 + 16) = 0;
          v52[5] = 1;
          memset_0(v52 + 6, 0, 0x6E8ui64);
        }
        else
        {
          v52 = 0i64;
        }
        *(_QWORD *)(v26 + 120) = v52;
        memset_0((void *)(v26 + 272), 0, 0x40ui64);
        *(_DWORD *)(v26 + 336) = 0;
        *(_BYTE *)(v26 + 340) = 0;
        memset_0((void *)(v26 + 341), 0, 0x48ui64);
        *(_DWORD *)(v26 + 416) = 0;
        *(_OWORD *)(v26 + 420) = 0i64;
        *(_OWORD *)(v26 + 436) = 0i64;
        *(_QWORD *)(v26 + 452) = 0i64;
        *(_QWORD *)(v26 + 464) = 0i64;
        *(_DWORD *)(v26 + 472) = 0;
        *(_OWORD *)(v26 + 476) = 0i64;
        *(_OWORD *)(v26 + 492) = 0i64;
        *(_DWORD *)(v26 + 508) = 0;
        *(_OWORD *)(v26 + 512) = 0i64;
        *(_OWORD *)(v26 + 528) = 0i64;
        *(_WORD *)(v26 + 544) = 0;
        *(_QWORD *)(v26 + 548) = 0i64;
        *(_BYTE *)(v26 + 556) = 0;
        *(_OWORD *)(v26 + 560) = 0i64;
        *(_QWORD *)(v26 + 576) = 0i64;
        *(_QWORD *)(v26 + 584) = 0i64;
        memset_0((void *)(v26 + 592), 0, 0x80ui64);
        *(_DWORD *)(v26 + 720) = 0;
        *(_OWORD *)(v26 + 724) = 0i64;
        *(_OWORD *)(v26 + 740) = 0i64;
        *(_OWORD *)(v26 + 756) = 0i64;
        *(_QWORD *)(v26 + 772) = 0i64;
        *(_DWORD *)(v26 + 780) = 0;
        *(_QWORD *)(v26 + 784) = 0i64;
        *(_QWORD *)(v26 + 792) = 0i64;
        *(_QWORD *)(v26 + 800) = 0i64;
        *(_QWORD *)(v26 + 808) = 0i64;
        *(_QWORD *)(v26 + 816) = 0i64;
        *(_QWORD *)(v26 + 824) = 0i64;
        *(_QWORD *)(v26 + 832) = 0i64;
        *(_QWORD *)(v26 + 840) = 0i64;
        *(_QWORD *)(v26 + 848) = 0i64;
        *(_QWORD *)(v26 + 856) = 0i64;
        *(_QWORD *)(v26 + 864) = 0i64;
        *(_DWORD *)(v26 + 872) = 0;
        *(_QWORD *)(v26 + 880) = 0i64;
        *(_DWORD *)(v26 + 888) = 0;
        *(_QWORD *)(v26 + 896) = 0i64;
        *(_QWORD *)(v26 + 904) = 0i64;
        *(_QWORD *)(v26 + 912) = 0i64;
        *(_DWORD *)(v26 + 920) = 0;
        *(_WORD *)(v26 + 924) = 0;
        if ( *(_BYTE *)(v26 + 233) )
        {
          v53 = 1083;
          v54 = 1096;
        }
        else
        {
          *(_DWORD *)(v26 + 192) = -1;
          v53 = 0;
          *(_QWORD *)(v26 + 200) = 0i64;
          v54 = 0;
          *(_QWORD *)(v26 + 208) = 0i64;
        }
        *(_WORD *)(v26 + 216) = v54;
        v28 = 1000i64;
        *(_WORD *)(v26 + 218) = v53;
        *(_QWORD *)v26 = &CSsl3TlsServerContext::`vftable';
        *(_QWORD *)(v26 + 928) = 0i64;
        *(_QWORD *)(v26 + 936) = 0i64;
        *(_QWORD *)(v26 + 944) = 0i64;
        *(_WORD *)(v26 + 952) = 0;
        *(_QWORD *)(v26 + 960) = 0i64;
        *(_QWORD *)(v26 + 968) = 0i64;
        *(_QWORD *)(v26 + 976) = 0i64;
        *(_DWORD *)(v26 + 984) = 0;
        *(_BYTE *)(v26 + 988) = 0;
        *(_QWORD *)(v26 + 992) = 0i64;
LABEL_41:
        v40 = *((_QWORD *)this + 7);
        v41 = v28 + v26;
        if ( v40 )
        {
          v55 = (_WORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v40 + 16i64))(v40);
          v56 = *((_DWORD *)this + 8);
        }
        else
        {
          if ( !*((_BYTE *)this + 68) )
          {
LABEL_43:
            *(_QWORD *)(v25 + 8) = v26;
            *(_QWORD *)(v26 + 128) = v25;
            v42 = *(_DWORD **)(v25 + 8);
            if ( !v42 )
              return 1359i64;
            result = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)v42 + 184i64))(*(_QWORD *)(v25 + 8));
            if ( !(_DWORD)result )
            {
              v42[17] = v59;
              v42[9] = v22;
              *a8 = (struct CSslParentContext *)v25;
              return 0i64;
            }
            return result;
          }
          v56 = 2048;
          v55 = SPExternalAlloc(0x800u);
          *(_BYTE *)(v25 + 32) = 1;
        }
        if ( v55 && v56 )
        {
          *(_QWORD *)(v41 + 8) = 0i64;
          *(_QWORD *)v41 = &CSslScratchAllocator::`vftable';
          *(_WORD *)(v41 + 16) = v56;
          *(_DWORD *)(v41 + 18) = 0;
          if ( (unsigned __int16)v56 > 4u )
          {
            *(_QWORD *)(v41 + 8) = v55;
            *v55 = 0;
            *(_WORD *)(*(_QWORD *)(v41 + 8) + 2i64) = v56 - 4;
          }
          *(_QWORD *)(v25 + 24) = v41;
        }
        goto LABEL_43;
      }
      v27 = (void ***)(v24 + 1560);
      v28 = 1600i64;
      if ( !v11 )
        v28 = 1616i64;
      if ( v24 != -1560 && v24 != -40 )
      {
        if ( v11 )
        {
          v29 = &CNulRecord::`vftable';
        }
        else
        {
          *(_DWORD *)(v24 + 1644) = 20;
          *(_WORD *)(v24 + 1640) = 0x4000;
          *(_WORD *)(v24 + 1650) = 0x4000;
          v29 = &CTls13Record::`vftable';
          *(_BYTE *)(v26 + 1608) = 0;
        }
        *(_QWORD *)(v26 + 1528) = v26;
        *(_WORD *)(v26 + 1536) = 0;
        *(_QWORD *)(v26 + 1544) = 0i64;
        *(_QWORD *)(v26 + 1552) = 0i64;
        *(_DWORD *)(v26 + 1560) = 0;
        *(_QWORD *)(v26 + 1568) = 0i64;
        *(_QWORD *)(v26 + 1576) = 0i64;
        *(_QWORD *)(v26 + 1584) = 0i64;
        *(_DWORD *)(v26 + 1592) = 0;
        *v27 = v29;
        *(_QWORD *)v26 = &CSslContext::`vftable';
        *(_QWORD *)(v26 + 8) = 0i64;
        *(_QWORD *)(v26 + 16) = 0i64;
        *(_QWORD *)(v26 + 24) = 0i64;
        *(_WORD *)(v26 + 32) = 0;
        *(_DWORD *)(v26 + 36) = 0;
        *(_OWORD *)(v26 + 40) = 0i64;
        *(_DWORD *)(v26 + 56) = 0;
        *(_WORD *)(v26 + 96) = 0;
        *(_BYTE *)(v26 + 232) = 0;
        *(_WORD *)(v26 + 264) = 0;
        *(_BYTE *)(v26 + 266) = 0;
        v30 = LsaTable;
        *(_DWORD *)(v26 + 64) = v23;
        *(_QWORD *)(v26 + 68) = 0i64;
        *(_QWORD *)(v26 + 80) = 0i64;
        *(_QWORD *)(v26 + 88) = 0i64;
        *(_QWORD *)(v26 + 104) = 0i64;
        *(_QWORD *)(v26 + 112) = 0i64;
        *(_QWORD *)(v26 + 120) = 0i64;
        *(_QWORD *)(v26 + 128) = 0i64;
        *(_QWORD *)(v26 + 136) = 0i64;
        *(_QWORD *)(v26 + 144) = 0i64;
        *(_QWORD *)(v26 + 152) = 0i64;
        *(_QWORD *)(v26 + 160) = 0i64;
        *(_QWORD *)(v26 + 168) = 0i64;
        *(_QWORD *)(v26 + 176) = 0i64;
        *(_QWORD *)(v26 + 184) = 0i64;
        *(_DWORD *)(v26 + 192) = 0;
        *(_QWORD *)(v26 + 200) = 0i64;
        *(_QWORD *)(v26 + 208) = 0i64;
        *(_DWORD *)(v26 + 216) = 0;
        *(_WORD *)(v26 + 220) = 0;
        *(_QWORD *)(v26 + 224) = 0i64;
        *(_WORD *)(v26 + 234) = 0;
        *(_QWORD *)(v26 + 240) = 0i64;
        *(_QWORD *)(v26 + 248) = 0i64;
        *(_QWORD *)(v26 + 256) = 0i64;
        if ( (*(unsigned __int8 (__fastcall **)(char *))(v30 + 192))(v57) )
        {
          v31 = v58;
          if ( (v58 & 1) != 0 )
            *(_QWORD *)(v26 + 136) |= 0x20000000ui64;
          *(_BYTE *)(v26 + 266) = (v31 & 0x11) == 0;
        }
        v32 = ConvertSchannelProtocolToSsl(*(_DWORD *)(v26 + 64));
        v33 = v32;
        *(_WORD *)(v26 + 34) = v32;
        if ( HIBYTE(v32) != 0xFE || (v34 = 13, v33 > 0xFEFF) )
          v34 = 5;
        *(_DWORD *)(v26 + 60) = v34;
        *(_BYTE *)(v26 + 233) = (v23 & 0xF0000) != 0;
        if ( dword_180091480
          && (qword_180091490 & 0x400000000000i64) != 0
          && (qword_180091498 & 0x400000000000i64) == qword_180091498
          && (v35 = SPExternalAlloc(0x700u)) != 0i64 )
        {
          v35[2] = 0;
          *(_QWORD *)v35 = &CSchannelTelemetryContext::`vftable';
          *((_BYTE *)v35 + 16) = 0;
          v35[5] = 1;
          memset_0(v35 + 6, 0, 0x6E8ui64);
        }
        else
        {
          v35 = 0i64;
        }
        *(_QWORD *)(v26 + 120) = v35;
        memset_0((void *)(v26 + 272), 0, 0x40ui64);
        *(_DWORD *)(v26 + 336) = 0;
        *(_BYTE *)(v26 + 340) = 0;
        memset_0((void *)(v26 + 341), 0, 0x48ui64);
        *(_DWORD *)(v26 + 416) = 0;
        *(_OWORD *)(v26 + 420) = 0i64;
        *(_OWORD *)(v26 + 436) = 0i64;
        *(_QWORD *)(v26 + 452) = 0i64;
        *(_QWORD *)(v26 + 464) = 0i64;
        *(_DWORD *)(v26 + 472) = 0;
        *(_OWORD *)(v26 + 476) = 0i64;
        *(_OWORD *)(v26 + 492) = 0i64;
        *(_DWORD *)(v26 + 508) = 0;
        *(_OWORD *)(v26 + 512) = 0i64;
        *(_OWORD *)(v26 + 528) = 0i64;
        *(_WORD *)(v26 + 544) = 0;
        *(_QWORD *)(v26 + 548) = 0i64;
        *(_BYTE *)(v26 + 556) = 0;
        *(_OWORD *)(v26 + 560) = 0i64;
        *(_QWORD *)(v26 + 576) = 0i64;
        *(_QWORD *)(v26 + 584) = 0i64;
        memset_0((void *)(v26 + 592), 0, 0x80ui64);
        *(_DWORD *)(v26 + 720) = 0;
        *(_OWORD *)(v26 + 724) = 0i64;
        *(_OWORD *)(v26 + 740) = 0i64;
        *(_OWORD *)(v26 + 756) = 0i64;
        *(_QWORD *)(v26 + 772) = 0i64;
        *(_DWORD *)(v26 + 780) = 0;
        *(_QWORD *)(v26 + 784) = 0i64;
        *(_QWORD *)(v26 + 792) = 0i64;
        *(_QWORD *)(v26 + 800) = 0i64;
        *(_QWORD *)(v26 + 808) = 0i64;
        *(_QWORD *)(v26 + 816) = 0i64;
        *(_QWORD *)(v26 + 824) = 0i64;
        *(_QWORD *)(v26 + 832) = 0i64;
        *(_QWORD *)(v26 + 840) = 0i64;
        *(_QWORD *)(v26 + 848) = 0i64;
        *(_QWORD *)(v26 + 856) = 0i64;
        *(_QWORD *)(v26 + 864) = 0i64;
        *(_DWORD *)(v26 + 872) = 0;
        *(_QWORD *)(v26 + 880) = 0i64;
        *(_DWORD *)(v26 + 888) = 0;
        *(_QWORD *)(v26 + 896) = 0i64;
        *(_QWORD *)(v26 + 904) = 0i64;
        *(_QWORD *)(v26 + 912) = 0i64;
        *(_DWORD *)(v26 + 920) = 0;
        *(_WORD *)(v26 + 924) = 0;
        if ( *(_BYTE *)(v26 + 233) )
        {
          v36 = 1083;
          v37 = 1096;
        }
        else
        {
          *(_DWORD *)(v26 + 192) = -1;
          v36 = 0;
          *(_QWORD *)(v26 + 200) = 0i64;
          v37 = 0;
          *(_QWORD *)(v26 + 208) = 0i64;
        }
        *(_WORD *)(v26 + 216) = v37;
        *(_WORD *)(v26 + 218) = v36;
        *(_QWORD *)(v26 + 928) = 0i64;
        *(_QWORD *)(v26 + 936) = 0i64;
        *(_QWORD *)(v26 + 944) = 0i64;
        *(_WORD *)(v26 + 952) = 0;
        *(_QWORD *)(v26 + 960) = 0i64;
        *(_QWORD *)(v26 + 968) = 0i64;
        *(_QWORD *)(v26 + 976) = 0i64;
        *(_DWORD *)(v26 + 984) = 0;
        *(_BYTE *)(v26 + 988) = 0;
        *(_QWORD *)(v26 + 992) = 0i64;
        *(_QWORD *)(v26 + 1016) = &CTls13ChangeCipherSpec::`vftable';
        *(_QWORD *)(v26 + 1024) = v27;
        *(_BYTE *)(v26 + 1008) = 0;
        *(_BYTE *)(v26 + 1032) = 0;
        *(_QWORD *)(v26 + 1040) = 0i64;
        *(_QWORD *)(v26 + 1048) = 0i64;
        *(_QWORD *)(v26 + 1056) = 0i64;
        *(_QWORD *)(v26 + 1064) = 0i64;
        *(_QWORD *)(v26 + 1072) = 0i64;
        *(_QWORD *)(v26 + 1080) = 0i64;
        *(_QWORD *)(v26 + 1088) = 0i64;
        *(_QWORD *)(v26 + 1096) = 0i64;
        *(_QWORD *)(v26 + 1104) = 0i64;
        *(_QWORD *)(v26 + 1112) = 0i64;
        *(_BYTE *)(v26 + 1120) = 0;
        *(_BYTE *)(v26 + 1136) = 0;
        *(_QWORD *)(v26 + 1128) = 0i64;
        *(_QWORD *)(v26 + 1144) = 0i64;
        *(_OWORD *)(v26 + 1152) = 0i64;
        *(_OWORD *)(v26 + 1168) = 0i64;
        *(_OWORD *)(v26 + 1184) = 0i64;
        *(_BYTE *)(v26 + 1216) = 0;
        *(_WORD *)(v26 + 1232) = 0;
        *(_BYTE *)(v26 + 1248) = 0;
        *(_WORD *)(v26 + 1200) = 256;
        *(_QWORD *)(v26 + 1208) = v27;
        *(_QWORD *)(v26 + 1224) = 0i64;
        *(_QWORD *)(v26 + 1240) = 0i64;
        *(_OWORD *)(v26 + 1249) = 0i64;
        *(_OWORD *)(v26 + 1265) = 0i64;
        *(_WORD *)(v26 + 1281) = 0;
        v38 = *(_QWORD *)(v26 + 1208);
        *(_QWORD *)v26 = &CTls13ServerContext::`vftable'{for `CSsl3TlsServerContext'};
        *(_QWORD *)(v26 + 1000) = &CTls13ServerContext::`vftable'{for `CTls13Context'};
        *(_QWORD *)(v26 + 1288) = &CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::`vftable';
        *(_QWORD *)(v26 + 1296) = v26;
        v39 = operator new(0x30ui64);
        if ( v39 )
        {
          v39[1] = v26;
          *v39 = &CTls13ExtServer::`vftable';
          v39[2] = 0i64;
          *((_DWORD *)v39 + 6) = 0;
          v39[4] = v26;
          v39[5] = v26;
        }
        else
        {
          v39 = 0i64;
        }
        *(_QWORD *)(v26 + 1304) = v39;
        *(_QWORD *)(v26 + 1288) = &CTls13ServerHandshake::`vftable';
        *(_QWORD *)(v26 + 1312) = 0i64;
        *(_QWORD *)(v26 + 1320) = v38;
        *(_DWORD *)(v26 + 1328) = 0;
        *(_WORD *)(v26 + 1332) = 0;
        *(_BYTE *)(v26 + 1334) = 0;
        *(_DWORD *)(v26 + 1336) = 0;
        *(_WORD *)(v26 + 1340) = 0;
        *(_BYTE *)(v26 + 1342) = 0;
        *(_QWORD *)(v26 + 1344) = 0i64;
        *(_WORD *)(v26 + 1352) = 0;
        *(_QWORD *)(v26 + 1360) = 0i64;
        *(_DWORD *)(v26 + 1368) = 0;
        *(_QWORD *)(v26 + 1376) = 0i64;
        *(_QWORD *)(v26 + 1384) = 0i64;
        *(_DWORD *)(v26 + 1392) = 0;
        *(_QWORD *)(v26 + 1400) = 0i64;
        *(_QWORD *)(v26 + 1408) = 0i64;
        *(_QWORD *)(v26 + 1416) = 0i64;
        *(_QWORD *)(v26 + 1424) = 0i64;
        *(_QWORD *)(v26 + 1432) = 0i64;
        *(_DWORD *)(v26 + 1440) = 0;
        *(_WORD *)(v26 + 1444) = 0;
        *(_QWORD *)(v26 + 1448) = 0i64;
        *(_DWORD *)(v26 + 1456) = 0;
        *(_WORD *)(v26 + 1460) = 0;
        *(_QWORD *)(v26 + 1464) = 0i64;
        *(_DWORD *)(v26 + 1472) = 0;
        *(_WORD *)(v26 + 1476) = 0;
        *(_QWORD *)(v26 + 1480) = 0i64;
        *(_WORD *)(v26 + 1488) = 0;
        *(_QWORD *)(v26 + 1496) = 0i64;
        *(_WORD *)(v26 + 1504) = 0;
        *(_BYTE *)(v26 + 1506) = 0;
        *(_QWORD *)(v26 + 1512) = 0i64;
        goto LABEL_41;
      }
      (*(void (__fastcall **)(_QWORD, __int64))(**((_QWORD **)this + 6) + 32i64))(*((_QWORD *)this + 6), v26);
    }
    return 14i64;
  }
  if ( *(_BYTE *)v14 != 22 )
  {
    v22 = *(unsigned __int8 *)(v14 + 4) | (*(unsigned __int8 *)(v14 + 3) << 8);
    if ( v22 < 0x300 )
      goto LABEL_70;
    if ( v13 < 0xE )
    {
      *((_DWORD *)a2 + 1) = 14;
      return 2148074264i64;
    }
    if ( !(*(unsigned __int8 *)(v14 + 6) | (*(unsigned __int8 *)(v14 + 5) << 8)) )
      return 2148074289i64;
    if ( BYTE1(v22) == 0xFE && v22 <= 0xFEFF )
    {
      if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 1) != 0 )
        WPP_SF_(*((_QWORD *)v12 + 2), 13i64, &WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids);
      return 2148074278i64;
    }
    if ( v22 < 0x302 )
    {
      if ( v22 < 0x301 )
        goto LABEL_102;
    }
    else
    {
      v23 = 256;
      if ( (v15 & 0x100) != 0 )
      {
        v59 = 20;
        goto LABEL_18;
      }
    }
    if ( (v15 & 0x40) != 0 )
    {
      v59 = 20;
      v23 = 64;
      goto LABEL_18;
    }
LABEL_102:
    if ( (v15 & 0x10) != 0 )
    {
      v59 = 20;
      goto LABEL_104;
    }
LABEL_70:
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 1) != 0 )
      WPP_SF_(*((_QWORD *)v12 + 2), 14i64, &WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids);
    return 2148074289i64;
  }
  v16 = *(unsigned __int8 *)(v14 + 2) | (*(unsigned __int8 *)(v14 + 1) << 8);
  if ( _byteswap_ushort(*(_WORD *)(v14 + 1)) >> 8 == 0xFE && v16 <= 0xFEFF )
  {
    v17 = *(unsigned __int8 *)(v14 + 11);
    v18 = 13;
    v19 = *(unsigned __int8 *)(v14 + 12);
    v20 = 12;
  }
  else
  {
    v17 = *(unsigned __int8 *)(v14 + 3);
    v18 = 5;
    v19 = *(unsigned __int8 *)(v14 + 4);
    v20 = 4;
  }
  if ( (v19 | (unsigned int)(v17 << 8)) < v20 + 2 )
  {
    if ( v12 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v12 + 28) & 1) != 0 )
    {
      if ( BYTE1(v16) == 0xFE && v16 <= 0xFEFF )
      {
        v44 = *(unsigned __int8 *)(v14 + 11);
        v45 = *(unsigned __int8 *)(v14 + 12);
      }
      else
      {
        v44 = *(unsigned __int8 *)(v14 + 3);
        v45 = *(unsigned __int8 *)(v14 + 4);
      }
      WPP_SF_d(*((_QWORD *)v12 + 2), 0xCu, (__int64)&WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids, v45 | (v44 << 8));
    }
    return 2148074278i64;
  }
  v21 = v20 + v18 + 2;
  if ( v13 < v21 )
  {
    *((_DWORD *)a2 + 1) = v21;
    return 2148074264i64;
  }
  v22 = *(unsigned __int8 *)(v18 + v14 + v20 + 1) | (*(unsigned __int8 *)(v18 + v14 + v20) << 8);
  if ( BYTE1(v22) != 0xFE || v22 > 0xFEFF )
  {
    if ( v22 < 0x303 )
    {
      if ( v22 < 0x302 )
      {
        if ( v22 < 0x301 )
          goto LABEL_83;
        goto LABEL_86;
      }
    }
    else if ( (v15 & 0x1400) != 0 )
    {
      if ( (v15 & 0x1000) != 0 )
        v8 = 1;
      v23 = 1024;
      goto LABEL_18;
    }
    v23 = 256;
    if ( (v15 & 0x100) != 0 )
      goto LABEL_18;
LABEL_86:
    if ( (v15 & 0x40) != 0 )
    {
      v23 = 64;
      goto LABEL_18;
    }
LABEL_83:
    if ( (v15 & 0x10) == 0 )
      return 2148074289i64;
LABEL_104:
    v23 = 16;
    goto LABEL_18;
  }
  if ( v22 > 0xFEFD || (v23 = 0x40000, (v15 & 0x40000) == 0) )
  {
    v23 = 0x10000;
    if ( (v15 & 0x10000) == 0 )
      goto LABEL_70;
  }
  v46 = CheckInitialDTLSHelloCookie(*((_DWORD *)a6 + 53), (const unsigned __int16 *)a6 + 108, a5, a2, a3);
  if ( !v46 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 15i64, &WPP_5f5b8daccbb63ec51f5b3bdd6563a375_Traceguids);
    goto LABEL_18;
  }
  if ( v46 == 590610 )
  {
    a4->pvBuffer = (void *)*((_QWORD *)a3 + 1);
    a4->cbBuffer = *((_DWORD *)a3 + 1);
  }
  return v46;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';
// 18007C920: using guessed type void *CTls13ServerContext::`vftable'{for `CTls13Context'};
// 18007C928: using guessed type void *CTls13ServerContext::`vftable'{for `CSsl3TlsServerContext'};
// 18007CB58: using guessed type void *CTls13ChangeCipherSpec::`vftable';
// 18007CB68: using guessed type void *CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::`vftable';
// 18007CB80: using guessed type void *CTls13ServerHandshake::`vftable';
// 18007CB98: using guessed type void *CTls13ExtServer::`vftable';
// 18007CDB8: using guessed type void *CSslContext::`vftable';
// 18007CF58: using guessed type void *CSchannelTelemetryContext::`vftable';
// 18007CF80: using guessed type void *CTls13Record::`vftable';
// 18007D508: using guessed type void *CSslScratchAllocator::`vftable';
// 18007D590: using guessed type void *CNulRecord::`vftable';
// 180091490: using guessed type __int64 qword_180091490;
// 180091498: using guessed type __int64 qword_180091498;
// 180092620: using guessed type __int64 LsaTable;
// 18001F810: using guessed type char var_58[8];

//----- (0000000180020110) ----------------------------------------------------
CTls13ServerContext *__fastcall CTls13ServerContext::`scalar deleting destructor'(CTls13ServerContext *this)
{
  void *v2; // rcx
  void *v3; // rcx
  void *v4; // rcx
  void *v5; // rdx
  void *v6; // rdx
  void *v7; // rdi
  void *v8; // rdi
  void *v9; // rdx
  void *v10; // rdx
  void *v11; // rdx
  void *v12; // rdx
  __int64 v13; // rdx
  void **v14; // rcx
  void *v15; // rdx
  void *v16; // rdx
  void *v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // rcx
  __int64 v21; // rcx
  __int64 v22; // rcx
  __int64 v23; // rdi
  __int64 v24; // rcx
  CSslServerKey *v25; // rcx
  int v26; // ecx
  struct CCredentialGroup *v27; // rdx
  __int64 v28; // rcx
  volatile signed __int32 *v29; // rcx
  _QWORD *v31; // rdi
  void *v32; // rdx
  __int64 v33; // rax

  *(_QWORD *)this = &CTls13ServerContext::`vftable'{for `CSsl3TlsServerContext'};
  *((_QWORD *)this + 125) = &CTls13ServerContext::`vftable'{for `CTls13Context'};
  v2 = (void *)*((_QWORD *)this + 187);
  if ( v2 )
    SPExternalFree(v2);
  CTls13ServerContext::CleanupConnectedState(this);
  CTls13ServerHandshake::~CTls13ServerHandshake((CTls13ServerContext *)((char *)this + 1288));
  CTls13Context::~CTls13Context((CTls13ServerContext *)((char *)this + 1000));
  *(_QWORD *)this = &CSsl3TlsServerContext::`vftable';
  CSsl3TlsServerContext::CleanupConnectedState(this);
  v3 = (void *)*((_QWORD *)this + 116);
  if ( v3 )
    SPExternalFree(v3);
  v4 = (void *)*((_QWORD *)this + 117);
  if ( v4 )
    SPExternalFree(v4);
  v5 = (void *)*((_QWORD *)this + 118);
  if ( v5 )
    CSslContext::FreeMemory(this, v5);
  *(_QWORD *)this = &CSsl3TlsContext::`vftable';
  if ( *((_BYTE *)this + 233) )
  {
    v6 = (void *)*((_QWORD *)this + 71);
    if ( v6 )
      CSslContext::FreeMemory(this, v6);
    v7 = (void *)*((_QWORD *)this + 73);
    if ( v7 )
    {
      DTlsHandshakeQueue::~DTlsHandshakeQueue(*((DTlsHandshakeQueue **)this + 73));
      operator delete(v7);
      *((_QWORD *)this + 73) = 0i64;
    }
    v8 = (void *)*((_QWORD *)this + 72);
    if ( v8 )
    {
      DTlsMsgMgr::~DTlsMsgMgr(*((DTlsMsgMgr **)this + 72));
      operator delete(v8);
      *((_QWORD *)this + 72) = 0i64;
    }
    CSsl3TlsContext::FreeSavedWriteCipherState(this);
  }
  else
  {
    v31 = (_QWORD *)*((_QWORD *)this + 58);
    if ( v31 )
    {
      v32 = (void *)*((_QWORD *)this + 58);
      if ( *v31 && v31[3] )
      {
        (*(void (__fastcall **)(_QWORD, _QWORD))(*(_QWORD *)*v31 + 16i64))(*v31, v31[3]);
        v31[3] = 0i64;
        *((_DWORD *)v31 + 4) = 0;
        v32 = (void *)*((_QWORD *)this + 58);
      }
      CSslContext::FreeMemory(this, v32);
    }
  }
  v9 = (void *)*((_QWORD *)this + 98);
  if ( v9 )
    CSslContext::FreeMemory(this, v9);
  v10 = (void *)*((_QWORD *)this + 99);
  if ( v10 )
    CSslContext::FreeMemory(this, v10);
  v11 = (void *)*((_QWORD *)this + 100);
  if ( v11 )
    CSslContext::FreeMemory(this, v11);
  CSsl3TlsContext::FreeSelectedSrtpParameters(this);
  v12 = (void *)*((_QWORD *)this + 102);
  if ( v12 )
    CSslContext::FreeMemory(this, v12);
  CSsl3TlsContext::FreeSelectedTBParameters(this);
  v13 = *((_QWORD *)this + 104);
  if ( v13 )
  {
    if ( *(_QWORD *)(v13 + 8) )
      (*(void (__fastcall **)(CTls13ServerContext *, _QWORD))(*(_QWORD *)this + 16i64))(this, *(_QWORD *)(v13 + 8));
    (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 104) = 0i64;
  }
  v14 = (void **)*((_QWORD *)this + 105);
  if ( v14 )
  {
    if ( v14[1] )
    {
      SPExternalFree(v14[1]);
      v14 = (void **)*((_QWORD *)this + 105);
    }
    if ( v14[3] )
    {
      SPExternalFree(v14[3]);
      v14 = (void **)*((_QWORD *)this + 105);
    }
    SPExternalFree(v14);
    *((_QWORD *)this + 105) = 0i64;
  }
  v15 = (void *)*((_QWORD *)this + 106);
  if ( v15 )
    CSslContext::FreeMemory(this, v15);
  v16 = (void *)*((_QWORD *)this + 107);
  if ( v16 )
    CSslContext::FreeMemory(this, v16);
  v17 = (void *)*((_QWORD *)this + 108);
  if ( v17 )
    CSslContext::FreeMemory(this, v17);
  CSsl3TlsContext::FreeHandshakeHash(this);
  v18 = *((_QWORD *)this + 18);
  *(_QWORD *)this = &CSslContext::`vftable';
  if ( v18 )
    SslFreeObject(v18, 0i64);
  v19 = *((_QWORD *)this + 19);
  if ( v19 )
    SslFreeObject(v19, 0i64);
  v20 = *((_QWORD *)this + 20);
  if ( v20 )
    SslFreeObject(v20, 0i64);
  v21 = *((_QWORD *)this + 21);
  if ( v21 )
    SslFreeObject(v21, 0i64);
  v22 = *((_QWORD *)this + 14);
  if ( v22 )
    SslFreeObject(v22, 0i64);
  v23 = *((_QWORD *)this + 1);
  if ( v23 )
  {
    v24 = *(_QWORD *)(v23 + 848);
    if ( v24 )
      CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v24 + 16));
    CMasterCipherInfo::Dereference(*(CMasterCipherInfo **)(v23 + 856));
  }
  v25 = (CSslServerKey *)*((_QWORD *)this + 3);
  if ( v25 )
    CSslServerKey::Dereference(v25);
  v26 = *((_DWORD *)this + 17);
  if ( (unsigned int)(v26 - 3) > 1 && v26 != 79 && (*((_DWORD *)this + 34) & 0x40000) == 0 )
  {
    v33 = *((_QWORD *)this + 11);
    if ( v33 )
      *(_BYTE *)(v33 + 236) = 0;
  }
  v27 = (struct CCredentialGroup *)*((_QWORD *)this + 10);
  if ( v27 )
    CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, v27);
  v28 = *((_QWORD *)this + 11);
  if ( v28 )
    CSessionCacheTable::DereferenceCacheItemInternal(
      *(CSessionCacheTable **)(v28 + 224),
      *((struct CSessionCacheItem **)this + 11),
      1,
      0);
  v29 = (volatile signed __int32 *)*((_QWORD *)this + 15);
  if ( v29 && _InterlockedExchangeAdd(v29 + 5, 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(volatile signed __int32 *, __int64))(*(_QWORD *)v29 + 8i64))(v29, 1i64);
  *(_QWORD *)this = &ISslSerialize::`vftable';
  return this;
}
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';
// 18007C920: using guessed type void *CTls13ServerContext::`vftable'{for `CTls13Context'};
// 18007C928: using guessed type void *CTls13ServerContext::`vftable'{for `CSsl3TlsServerContext'};
// 18007CBA8: using guessed type void *CSsl3TlsContext::`vftable';
// 18007CDB8: using guessed type void *CSslContext::`vftable';
// 18007CFB8: using guessed type void *ISslSerialize::`vftable';
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180020590) ----------------------------------------------------
struct CSessionCacheItem **__fastcall CSsl3TlsServerContext::`vector deleting destructor'(
        struct CSessionCacheItem **this)
{
  struct CSessionCacheItem *v2; // rcx
  struct CSessionCacheItem *v3; // rcx
  struct CSessionCacheItem *v4; // rdx
  struct CSessionCacheItem *v5; // rdx
  struct CSessionCacheItem *v6; // rdi
  struct CSessionCacheItem *v7; // rdi
  struct CSessionCacheItem *v8; // rdx
  struct CSessionCacheItem *v9; // rdx
  struct CSessionCacheItem *v10; // rdx
  struct CSessionCacheItem *v11; // rdx
  struct CSessionCacheItem *v12; // rdx
  void **v13; // rcx
  struct CSessionCacheItem *v14; // rdx
  struct CSessionCacheItem *v15; // rdx
  struct CSessionCacheItem *v16; // rdx
  struct CSessionCacheItem *v17; // rcx
  struct CSessionCacheItem *v18; // rcx
  struct CSessionCacheItem *v19; // rcx
  struct CSessionCacheItem *v20; // rcx
  struct CSessionCacheItem *v21; // rcx
  struct CSessionCacheItem *v22; // rdi
  __int64 v23; // rcx
  CSslServerKey *v24; // rcx
  int v25; // ecx
  struct CCredentialGroup *v26; // rdx
  struct CSessionCacheItem *v27; // rcx
  volatile signed __int32 *v28; // rcx
  struct CSessionCacheItem *v30; // rdi
  struct CSessionCacheItem *v31; // rdx
  struct CSessionCacheItem *v32; // rax

  *this = (struct CSessionCacheItem *)&CSsl3TlsServerContext::`vftable';
  CSsl3TlsServerContext::CleanupConnectedState((CSsl3TlsServerContext *)this);
  v2 = this[116];
  if ( v2 )
    SPExternalFree(v2);
  v3 = this[117];
  if ( v3 )
    SPExternalFree(v3);
  v4 = this[118];
  if ( v4 )
    CSslContext::FreeMemory((CSslContext *)this, v4);
  *this = (struct CSessionCacheItem *)&CSsl3TlsContext::`vftable';
  if ( *((_BYTE *)this + 233) )
  {
    v5 = this[71];
    if ( v5 )
      CSslContext::FreeMemory((CSslContext *)this, v5);
    v6 = this[73];
    if ( v6 )
    {
      DTlsHandshakeQueue::~DTlsHandshakeQueue(this[73]);
      operator delete(v6);
      this[73] = 0i64;
    }
    v7 = this[72];
    if ( v7 )
    {
      DTlsMsgMgr::~DTlsMsgMgr(this[72]);
      operator delete(v7);
      this[72] = 0i64;
    }
    CSsl3TlsContext::FreeSavedWriteCipherState((CSsl3TlsContext *)this);
  }
  else
  {
    v30 = this[58];
    if ( v30 )
    {
      v31 = this[58];
      if ( *(_QWORD *)v30 && *((_QWORD *)v30 + 3) )
      {
        (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)v30 + 16i64))(*(_QWORD *)v30, *((_QWORD *)v30 + 3));
        *((_QWORD *)v30 + 3) = 0i64;
        *((_DWORD *)v30 + 4) = 0;
        v31 = this[58];
      }
      CSslContext::FreeMemory((CSslContext *)this, v31);
    }
  }
  v8 = this[98];
  if ( v8 )
    CSslContext::FreeMemory((CSslContext *)this, v8);
  v9 = this[99];
  if ( v9 )
    CSslContext::FreeMemory((CSslContext *)this, v9);
  v10 = this[100];
  if ( v10 )
    CSslContext::FreeMemory((CSslContext *)this, v10);
  CSsl3TlsContext::FreeSelectedSrtpParameters((CSsl3TlsContext *)this);
  v11 = this[102];
  if ( v11 )
    CSslContext::FreeMemory((CSslContext *)this, v11);
  CSsl3TlsContext::FreeSelectedTBParameters((CSsl3TlsContext *)this);
  v12 = this[104];
  if ( v12 )
  {
    if ( *((_QWORD *)v12 + 1) )
      (*((void (__fastcall **)(struct CSessionCacheItem **, _QWORD))*this + 2))(this, *((_QWORD *)v12 + 1));
    (*((void (__fastcall **)(struct CSessionCacheItem **))*this + 2))(this);
    this[104] = 0i64;
  }
  v13 = (void **)this[105];
  if ( v13 )
  {
    if ( v13[1] )
    {
      SPExternalFree(v13[1]);
      v13 = (void **)this[105];
    }
    if ( v13[3] )
    {
      SPExternalFree(v13[3]);
      v13 = (void **)this[105];
    }
    SPExternalFree(v13);
    this[105] = 0i64;
  }
  v14 = this[106];
  if ( v14 )
    CSslContext::FreeMemory((CSslContext *)this, v14);
  v15 = this[107];
  if ( v15 )
    CSslContext::FreeMemory((CSslContext *)this, v15);
  v16 = this[108];
  if ( v16 )
    CSslContext::FreeMemory((CSslContext *)this, v16);
  CSsl3TlsContext::FreeHandshakeHash((CSsl3TlsContext *)this);
  v17 = this[18];
  *this = (struct CSessionCacheItem *)&CSslContext::`vftable';
  if ( v17 )
    SslFreeObject(v17, 0i64);
  v18 = this[19];
  if ( v18 )
    SslFreeObject(v18, 0i64);
  v19 = this[20];
  if ( v19 )
    SslFreeObject(v19, 0i64);
  v20 = this[21];
  if ( v20 )
    SslFreeObject(v20, 0i64);
  v21 = this[14];
  if ( v21 )
    SslFreeObject(v21, 0i64);
  v22 = this[1];
  if ( v22 )
  {
    v23 = *((_QWORD *)v22 + 106);
    if ( v23 )
      CMasterEccCurveInfo::Dereference(*(CMasterEccCurveInfo **)(v23 + 16));
    CMasterCipherInfo::Dereference(*((CMasterCipherInfo **)v22 + 107));
  }
  v24 = this[3];
  if ( v24 )
    CSslServerKey::Dereference(v24);
  v25 = *((_DWORD *)this + 17);
  if ( (unsigned int)(v25 - 3) > 1 && v25 != 79 && ((_DWORD)this[17] & 0x40000) == 0 )
  {
    v32 = this[11];
    if ( v32 )
      *((_BYTE *)v32 + 236) = 0;
  }
  v26 = this[10];
  if ( v26 )
    CSslCredManager::DereferenceCredentialGroup(CSslCredManager::m_pCredManager, v26);
  v27 = this[11];
  if ( v27 )
    CSessionCacheTable::DereferenceCacheItemInternal(*((CSessionCacheTable **)v27 + 28), this[11], 1, 0);
  v28 = (volatile signed __int32 *)this[15];
  if ( v28 && _InterlockedExchangeAdd(v28 + 5, 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(volatile signed __int32 *, __int64))(*(_QWORD *)v28 + 8i64))(v28, 1i64);
  *this = (struct CSessionCacheItem *)&ISslSerialize::`vftable';
  return this;
}
// 18007C6F0: using guessed type void *CSsl3TlsServerContext::`vftable';
// 18007CBA8: using guessed type void *CSsl3TlsContext::`vftable';
// 18007CDB8: using guessed type void *CSslContext::`vftable';
// 18007CFB8: using guessed type void *ISslSerialize::`vftable';
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (00000001800209BC) ----------------------------------------------------
void __fastcall CSslServerKey::Dereference(CSslServerKey *this)
{
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)this + 6, 0xFFFFFFFF) == 1 )
  {
    if ( this )
      (*(void (__fastcall **)(CSslServerKey *, __int64))(*(_QWORD *)this + 8i64))(this, 1i64);
  }
}

//----- (00000001800209E0) ----------------------------------------------------
void __fastcall CSsl3TlsServerContext::CleanupConnectedState(CSsl3TlsServerContext *this)
{
  volatile signed __int32 *v2; // rcx
  void *v3; // rcx
  __int64 v4; // rdx
  _QWORD *v5; // rbx

  if ( *((_QWORD *)this + 120) )
  {
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 248i64))(this);
    v2 = (volatile signed __int32 *)*((_QWORD *)this + 120);
    if ( v2 && _InterlockedExchangeAdd(v2 + 7, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *, __int64))(*(_QWORD *)v2 + 8i64))(v2, 1i64);
    *((_QWORD *)this + 120) = 0i64;
  }
  if ( *((_QWORD *)this + 121) )
  {
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 121) = 0i64;
  }
  v3 = (void *)*((_QWORD *)this + 112);
  if ( v3 )
  {
    SPExternalFree(v3);
    *((_QWORD *)this + 112) = 0i64;
    *((_DWORD *)this + 222) = 0;
  }
  if ( *((_QWORD *)this + 110) )
  {
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 110) = 0i64;
  }
  v4 = *((_QWORD *)this + 114);
  *((_DWORD *)this + 218) = 0;
  if ( v4 )
  {
    (*(void (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 114) = 0i64;
    *((_WORD *)this + 460) = 0;
  }
  *(_WORD *)((char *)this + 923) = 0;
  *((_BYTE *)this + 472) = 0;
  v5 = (_QWORD *)*((_QWORD *)this + 58);
  if ( v5 && *v5 )
  {
    if ( v5[3] )
    {
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v5 + 16i64))(*v5);
      v5[3] = 0i64;
      *((_DWORD *)v5 + 4) = 0;
    }
  }
}

//----- (0000000180020B60) ----------------------------------------------------
void __fastcall CTls13Context::~CTls13Context(CTls13Context *this)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  void *v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  void (__fastcall ***v7)(_QWORD, _QWORD); // rcx

  *(_QWORD *)this = &CTls13Context::`vftable';
  v2 = *((_QWORD *)this + 9);
  if ( v2 )
    SslFreeObject(v2, 0i64);
  v3 = *((_QWORD *)this + 12);
  if ( v3 )
    SslFreeObject(v3, 0i64);
  v4 = (void *)*((_QWORD *)this + 20);
  if ( v4 )
    SPExternalFree(v4);
  v5 = *((_QWORD *)this + 10);
  if ( v5 )
  {
    SslFreeObject(v5, 0i64);
    *((_QWORD *)this + 10) = 0i64;
  }
  v6 = *((_QWORD *)this + 11);
  if ( v6 )
  {
    SslFreeObject(v6, 0i64);
    *((_QWORD *)this + 11) = 0i64;
  }
  *((_QWORD *)this + 18) = 0i64;
  *((_QWORD *)this + 16) = 0i64;
  memset((char *)this + 112, 0, 8ui64);
  *((_BYTE *)this + 120) = 0;
  memset((char *)this + 168, 0, 0x20ui64);
  v7 = (void (__fastcall ***)(_QWORD, _QWORD))*((_QWORD *)this + 26);
  *((_BYTE *)this + 200) = 0;
  (**v7)(v7, 0i64);
  *((_QWORD *)this + 2) = &CTls13ChangeCipherSpec::`vftable';
}
// 18007CB58: using guessed type void *CTls13ChangeCipherSpec::`vftable';
// 18007CB60: using guessed type void *CTls13Context::`vftable';
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180020C30) ----------------------------------------------------
void __fastcall CTls13ServerHandshake::~CTls13ServerHandshake(CTls13ServerHandshake *this)
{
  void *v2; // rcx
  void *v3; // rcx
  void (__fastcall ***v4)(_QWORD, __int64); // rcx
  void *v5; // rcx
  void *v6; // rcx

  *(_QWORD *)this = &CTls13ServerHandshake::`vftable';
  v2 = (void *)*((_QWORD *)this + 22);
  if ( v2 )
    SPExternalFree(v2);
  v3 = (void *)*((_QWORD *)this + 24);
  if ( v3 )
    LocalFree(v3);
  v4 = (void (__fastcall ***)(_QWORD, __int64))*((_QWORD *)this + 2);
  *(_QWORD *)this = &CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::`vftable';
  if ( v4 )
    (**v4)(v4, 1i64);
  v5 = (void *)*((_QWORD *)this + 7);
  if ( v5 )
    SPExternalFree(v5);
  v6 = (void *)*((_QWORD *)this + 18);
  if ( v6 )
    SPExternalFree(v6);
}
// 18007CB68: using guessed type void *CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::`vftable';
// 18007CB80: using guessed type void *CTls13ServerHandshake::`vftable';
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);

//----- (0000000180020CD0) ----------------------------------------------------
void __fastcall CTls13ServerContext::CleanupConnectedState(CTls13ServerContext *this)
{
  const CERT_SERVER_OCSP_RESPONSE_CONTEXT *v2; // rcx
  __int64 v3; // rcx
  void *v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rcx
  void *v10; // rcx
  __int64 v11; // rdx
  _QWORD *v12; // rbx
  CSslCredential *v13; // rcx

  v2 = (const CERT_SERVER_OCSP_RESPONSE_CONTEXT *)*((_QWORD *)this + 189);
  if ( v2 )
  {
    CertFreeServerOcspResponseContext(v2);
    *((_QWORD *)this + 189) = 0i64;
  }
  v3 = *((_QWORD *)this + 138);
  if ( v3 )
  {
    SslFreeObject(v3, 0i64);
    *((_QWORD *)this + 138) = 0i64;
  }
  v4 = (void *)*((_QWORD *)this + 153);
  if ( v4 )
  {
    SPExternalFree(v4);
    *((_QWORD *)this + 153) = 0i64;
  }
  v5 = *((_QWORD *)this + 130);
  *((_BYTE *)this + 1232) = 0;
  if ( v5 )
  {
    SslFreeObject(v5, 0i64);
    *((_QWORD *)this + 130) = 0i64;
  }
  v6 = *((_QWORD *)this + 131);
  if ( v6 )
  {
    SslFreeObject(v6, 0i64);
    *((_QWORD *)this + 131) = 0i64;
  }
  v7 = *((_QWORD *)this + 132);
  if ( v7 )
  {
    SslFreeObject(v7, 0i64);
    *((_QWORD *)this + 132) = 0i64;
  }
  v8 = *((_QWORD *)this + 133);
  if ( v8 )
  {
    SslFreeObject(v8, 0i64);
    *((_QWORD *)this + 133) = 0i64;
  }
  v9 = *((_QWORD *)this + 155);
  if ( v9 )
  {
    SslFreeObject(v9, 0i64);
    *((_QWORD *)this + 155) = 0i64;
  }
  if ( *((_QWORD *)this + 120) )
  {
    (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 248i64))(this);
    CSslCredential::ReleaseEphemeralKeyData(v13, *((struct CEphemKeyData **)this + 120));
    *((_QWORD *)this + 120) = 0i64;
  }
  if ( *((_QWORD *)this + 121) )
  {
    (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 121) = 0i64;
  }
  v10 = (void *)*((_QWORD *)this + 112);
  if ( v10 )
  {
    SPExternalFree(v10);
    *((_QWORD *)this + 112) = 0i64;
    *((_DWORD *)this + 222) = 0;
  }
  if ( *((_QWORD *)this + 110) )
  {
    (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 110) = 0i64;
  }
  v11 = *((_QWORD *)this + 114);
  *((_DWORD *)this + 218) = 0;
  if ( v11 )
  {
    (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 16i64))(this);
    *((_QWORD *)this + 114) = 0i64;
    *((_WORD *)this + 460) = 0;
  }
  *(_WORD *)((char *)this + 923) = 0;
  *((_BYTE *)this + 472) = 0;
  v12 = (_QWORD *)*((_QWORD *)this + 58);
  if ( v12 && *v12 )
  {
    if ( v12[3] )
    {
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v12 + 16i64))(*v12);
      v12[3] = 0i64;
      *((_DWORD *)v12 + 4) = 0;
    }
  }
}
// 180033533: variable 'v13' is possibly undefined
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180020DF0) ----------------------------------------------------
CSsl3TlsContext *__fastcall CSsl3TlsContext::CSsl3TlsContext(CSsl3TlsContext *this, __int64 a2)
{
  __int64 v4; // rdx
  void *v5; // rsi
  void *v6; // rdx
  CSsl3TlsContext *result; // rax

  CSslContext::CSslContext((__int64)this, a2);
  *(_QWORD *)this = &CSsl3TlsContext::`vftable';
  *((_DWORD *)this + 84) = *(_DWORD *)(v4 + 336);
  *((_BYTE *)this + 340) = *(_BYTE *)(v4 + 340);
  *((_DWORD *)this + 104) = *(_DWORD *)(v4 + 416);
  *((_DWORD *)this + 114) = *(_DWORD *)(v4 + 456);
  *((_QWORD *)this + 58) = *(_QWORD *)(v4 + 464);
  *((_BYTE *)this + 472) = *(_BYTE *)(v4 + 472);
  *((_BYTE *)this + 473) = *(_BYTE *)(v4 + 473);
  *(_OWORD *)((char *)this + 474) = *(_OWORD *)(v4 + 474);
  *(_OWORD *)((char *)this + 490) = *(_OWORD *)(v4 + 490);
  *(_DWORD *)((char *)this + 506) = *(_DWORD *)(v4 + 506);
  *(_OWORD *)((char *)this + 510) = *(_OWORD *)(v4 + 510);
  *(_OWORD *)((char *)this + 526) = *(_OWORD *)(v4 + 526);
  *(_DWORD *)((char *)this + 542) = *(_DWORD *)(v4 + 542);
  *((_DWORD *)this + 137) = *(_DWORD *)(v4 + 548);
  *((_BYTE *)this + 552) = *(_BYTE *)(v4 + 552);
  *((_BYTE *)this + 553) = *(_BYTE *)(v4 + 553);
  *((_BYTE *)this + 554) = *(_BYTE *)(v4 + 554);
  *((_BYTE *)this + 555) = *(_BYTE *)(v4 + 555);
  *((_BYTE *)this + 556) = *(_BYTE *)(v4 + 556);
  *((_DWORD *)this + 140) = *(_DWORD *)(v4 + 560);
  *((_DWORD *)this + 141) = *(_DWORD *)(v4 + 564);
  *((_QWORD *)this + 71) = *(_QWORD *)(v4 + 568);
  *((_QWORD *)this + 72) = *(_QWORD *)(v4 + 576);
  *((_QWORD *)this + 73) = *(_QWORD *)(v4 + 584);
  *((_QWORD *)this + 98) = *(_QWORD *)(v4 + 784);
  *((_QWORD *)this + 100) = *(_QWORD *)(v4 + 800);
  *((_QWORD *)this + 101) = *(_QWORD *)(v4 + 808);
  *((_QWORD *)this + 102) = *(_QWORD *)(v4 + 816);
  *((_QWORD *)this + 103) = *(_QWORD *)(v4 + 824);
  *((_QWORD *)this + 104) = *(_QWORD *)(v4 + 832);
  *((_QWORD *)this + 105) = *(_QWORD *)(v4 + 840);
  *((_QWORD *)this + 106) = *(_QWORD *)(v4 + 848);
  *((_QWORD *)this + 107) = *(_QWORD *)(v4 + 856);
  *((_QWORD *)this + 108) = *(_QWORD *)(v4 + 864);
  *((_DWORD *)this + 218) = *(_DWORD *)(v4 + 872);
  *((_QWORD *)this + 110) = *(_QWORD *)(v4 + 880);
  *((_DWORD *)this + 222) = *(_DWORD *)(v4 + 888);
  *((_QWORD *)this + 112) = *(_QWORD *)(v4 + 896);
  v5 = (void *)(v4 + 592);
  *((_QWORD *)this + 113) = *(_QWORD *)(v4 + 904);
  *((_QWORD *)this + 114) = *(_QWORD *)(v4 + 912);
  *((_WORD *)this + 460) = *(_WORD *)(v4 + 920);
  *((_BYTE *)this + 922) = *(_BYTE *)(v4 + 922);
  *((_BYTE *)this + 923) = *(_BYTE *)(v4 + 923);
  *((_BYTE *)this + 924) = *(_BYTE *)(v4 + 924);
  *((_BYTE *)this + 925) = *(_BYTE *)(v4 + 925);
  *((_OWORD *)this + 45) = *(_OWORD *)(v4 + 720);
  *((_OWORD *)this + 46) = *(_OWORD *)(v4 + 736);
  *((_OWORD *)this + 47) = *(_OWORD *)(v4 + 752);
  *((_OWORD *)this + 48) = *(_OWORD *)(v4 + 768);
  *((_OWORD *)this + 37) = *(_OWORD *)(v4 + 592);
  *((_OWORD *)this + 38) = *(_OWORD *)(v4 + 608);
  *((_OWORD *)this + 39) = *(_OWORD *)(v4 + 624);
  *((_OWORD *)this + 40) = *(_OWORD *)(v4 + 640);
  *((_OWORD *)this + 41) = *(_OWORD *)(v4 + 656);
  *((_OWORD *)this + 42) = *(_OWORD *)(v4 + 672);
  *((_OWORD *)this + 43) = *(_OWORD *)(v4 + 688);
  *((_OWORD *)this + 44) = *(_OWORD *)(v4 + 704);
  *(_OWORD *)((char *)this + 420) = *(_OWORD *)(v4 + 420);
  *(_OWORD *)((char *)this + 436) = *(_OWORD *)(v4 + 436);
  *((_DWORD *)this + 113) = *(_DWORD *)(v4 + 452);
  *(_OWORD *)((char *)this + 377) = *(_OWORD *)(v4 + 377);
  *(_OWORD *)((char *)this + 393) = *(_OWORD *)(v4 + 393);
  *(_DWORD *)((char *)this + 409) = *(_DWORD *)(v4 + 409);
  *(_OWORD *)((char *)this + 341) = *(_OWORD *)(v4 + 341);
  *(_OWORD *)((char *)this + 357) = *(_OWORD *)(v4 + 357);
  *(_DWORD *)((char *)this + 373) = *(_DWORD *)(v4 + 373);
  *((_OWORD *)this + 17) = *(_OWORD *)(v4 + 272);
  *((_OWORD *)this + 18) = *(_OWORD *)(v4 + 288);
  *((_OWORD *)this + 19) = *(_OWORD *)(v4 + 304);
  *((_OWORD *)this + 20) = *(_OWORD *)(v4 + 320);
  *(_QWORD *)(v4 + 896) = 0i64;
  *(_DWORD *)(v4 + 888) = 0;
  *(_QWORD *)(v4 + 880) = 0i64;
  *(_DWORD *)(v4 + 872) = 0;
  *(_QWORD *)(v4 + 912) = 0i64;
  *(_WORD *)(v4 + 920) = 0;
  *(_QWORD *)(v4 + 464) = 0i64;
  *(_QWORD *)(v4 + 560) = 0i64;
  *(_QWORD *)(v4 + 568) = 0i64;
  *(_QWORD *)(v4 + 584) = 0i64;
  *(_QWORD *)(v4 + 576) = 0i64;
  *(_QWORD *)(v4 + 784) = 0i64;
  *(_QWORD *)(v4 + 800) = 0i64;
  *(_QWORD *)(v4 + 808) = 0i64;
  v6 = *(void **)(v4 + 792);
  if ( v6 )
  {
    CSslContext::FreeMemory(this, v6);
    *(_QWORD *)(a2 + 792) = 0i64;
  }
  *(_QWORD *)(a2 + 816) = 0i64;
  *(_QWORD *)(a2 + 824) = 0i64;
  *(_QWORD *)(a2 + 832) = 0i64;
  *(_QWORD *)(a2 + 840) = 0i64;
  *(_QWORD *)(a2 + 848) = 0i64;
  *(_QWORD *)(a2 + 856) = 0i64;
  *(_QWORD *)(a2 + 864) = 0i64;
  memset_0(v5, 0, 0x80ui64);
  memset_0((void *)(a2 + 720), 0, 0x40ui64);
  result = this;
  *(_DWORD *)(a2 + 548) = 0;
  *(_WORD *)(a2 + 474) = 0;
  *(_DWORD *)(a2 + 508) = 0;
  *(_WORD *)(a2 + 544) = 0;
  *(_BYTE *)(a2 + 473) = 0;
  return result;
}
// 180020E1F: variable 'v4' is possibly undefined
// 18007CBA8: using guessed type void *CSsl3TlsContext::`vftable';

//----- (00000001800212D0) ----------------------------------------------------
__int64 __fastcall CSslContext::CSslContext(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &CSslContext::`vftable';
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_WORD *)(a1 + 32) = *(_WORD *)(a2 + 32);
  *(_WORD *)(a1 + 34) = *(_WORD *)(a2 + 34);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_BYTE *)(a1 + 96) = *(_BYTE *)(a2 + 96);
  *(_BYTE *)(a1 + 97) = *(_BYTE *)(a2 + 97);
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
  *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
  *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
  *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
  *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
  *(_DWORD *)(a1 + 192) = *(_DWORD *)(a2 + 192);
  *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
  *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
  *(_WORD *)(a1 + 216) = *(_WORD *)(a2 + 216);
  *(_WORD *)(a1 + 218) = *(_WORD *)(a2 + 218);
  *(_WORD *)(a1 + 220) = *(_WORD *)(a2 + 220);
  *(_QWORD *)(a1 + 224) = *(_QWORD *)(a2 + 224);
  *(_BYTE *)(a1 + 232) = *(_BYTE *)(a2 + 232);
  *(_BYTE *)(a1 + 233) = *(_BYTE *)(a2 + 233);
  *(_WORD *)(a1 + 234) = *(_WORD *)(a2 + 234);
  *(_QWORD *)(a1 + 240) = *(_QWORD *)(a2 + 240);
  *(_QWORD *)(a1 + 248) = *(_QWORD *)(a2 + 248);
  *(_QWORD *)(a1 + 256) = *(_QWORD *)(a2 + 256);
  *(_BYTE *)(a1 + 264) = *(_BYTE *)(a2 + 264);
  *(_BYTE *)(a1 + 265) = *(_BYTE *)(a2 + 265);
  *(_BYTE *)(a1 + 266) = *(_BYTE *)(a2 + 266);
  *(_QWORD *)(a2 + 144) = 0i64;
  *(_QWORD *)(a2 + 152) = 0i64;
  *(_QWORD *)(a2 + 160) = 0i64;
  *(_QWORD *)(a2 + 168) = 0i64;
  *(_QWORD *)(a2 + 112) = 0i64;
  *(_QWORD *)(a2 + 8) = 0i64;
  *(_QWORD *)(a2 + 24) = 0i64;
  *(_QWORD *)(a2 + 88) = 0i64;
  *(_QWORD *)(a2 + 80) = 0i64;
  *(_QWORD *)(a2 + 120) = 0i64;
  return a1;
}
// 18007CDB8: using guessed type void *CSslContext::`vftable';

//----- (0000000180021510) ----------------------------------------------------
CTlsExtServer *__fastcall CTlsExtServer::`vector deleting destructor'(CTlsExtServer *this, char a2)
{
  *(_QWORD *)this = &CTlsExt::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 18007D038: using guessed type void *CTlsExt::`vftable';

//----- (0000000180021540) ----------------------------------------------------
void __fastcall CSchannelTelemetryContext::WriteServerEvent(CSchannelTelemetryContext *this)
{
  unsigned int v1; // r10d
  char v2; // al
  int v3; // r10d
  __int16 v4; // r8
  int v5; // r11d
  int v6; // edi
  const WCHAR *v7; // r9
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // rax
  int v26; // ecx
  unsigned __int8 v27; // bl
  char *v28; // rax
  char v29; // cl
  char v32; // cl
  char v33; // r8
  char v34; // dl
  __int64 v35; // rcx
  signed __int64 v36; // r13
  __int64 v37; // rdi
  unsigned int v38; // eax
  unsigned int v39; // eax
  unsigned int v40; // eax
  unsigned __int8 v41; // cl
  unsigned int v42; // edx
  struct _EVENT_DATA_DESCRIPTOR *v43; // r10
  __int64 v44; // r11
  unsigned __int64 i; // rcx
  int v46; // eax
  RTL_SRWLOCK *v47; // r12
  int v48; // r15d
  volatile signed __int64 *j; // rsi
  volatile signed __int64 v50; // rsi
  int v51; // ecx
  __int64 v52; // r14
  int v53; // eax
  unsigned int v54; // edi
  unsigned __int8 v55; // dl
  signed __int64 v56; // r8
  __int64 v57; // rax
  int v58; // r10d
  volatile signed __int64 *v59; // r9
  int v60; // eax
  unsigned int v61; // eax
  signed __int64 v62; // rax
  volatile signed __int64 v63; // rtt
  char v64; // [rsp+38h] [rbp-D0h] BYREF
  char v65; // [rsp+39h] [rbp-CFh] BYREF
  __int64 v66; // [rsp+40h] [rbp-C8h] BYREF
  __int16 v67; // [rsp+48h] [rbp-C0h] BYREF
  __int16 v68; // [rsp+4Ah] [rbp-BEh] BYREF
  int v69; // [rsp+4Ch] [rbp-BCh] BYREF
  int v70; // [rsp+50h] [rbp-B8h] BYREF
  int v71; // [rsp+54h] [rbp-B4h] BYREF
  int v72; // [rsp+58h] [rbp-B0h] BYREF
  int v73; // [rsp+5Ch] [rbp-ACh] BYREF
  int v74; // [rsp+60h] [rbp-A8h] BYREF
  int v75; // [rsp+64h] [rbp-A4h] BYREF
  int v76; // [rsp+68h] [rbp-A0h] BYREF
  int v77; // [rsp+6Ch] [rbp-9Ch] BYREF
  int v78; // [rsp+70h] [rbp-98h] BYREF
  int v79; // [rsp+74h] [rbp-94h] BYREF
  int v80; // [rsp+78h] [rbp-90h] BYREF
  int v81; // [rsp+7Ch] [rbp-8Ch] BYREF
  int v82; // [rsp+80h] [rbp-88h] BYREF
  __int64 v83; // [rsp+88h] [rbp-80h]
  EVENT_DESCRIPTOR EventDescriptor; // [rsp+90h] [rbp-78h] BYREF
  __int64 v85; // [rsp+A0h] [rbp-68h] BYREF
  __int64 v86; // [rsp+A8h] [rbp-60h] BYREF
  __int64 v87; // [rsp+B0h] [rbp-58h] BYREF
  __int64 v88; // [rsp+B8h] [rbp-50h] BYREF
  __int64 v89; // [rsp+C0h] [rbp-48h] BYREF
  __int64 v90; // [rsp+C8h] [rbp-40h] BYREF
  __int64 v91; // [rsp+D0h] [rbp-38h] BYREF
  __int64 v92; // [rsp+D8h] [rbp-30h] BYREF
  __int64 v93; // [rsp+E0h] [rbp-28h] BYREF
  __int64 v94; // [rsp+E8h] [rbp-20h] BYREF
  __int64 v95; // [rsp+F0h] [rbp-18h] BYREF
  __int64 v96; // [rsp+F8h] [rbp-10h] BYREF
  __int64 v97; // [rsp+100h] [rbp-8h] BYREF
  __int64 v98; // [rsp+108h] [rbp+0h] BYREF
  __int64 v99; // [rsp+110h] [rbp+8h] BYREF
  __int64 v100; // [rsp+118h] [rbp+10h] BYREF
  __int64 v101; // [rsp+120h] [rbp+18h] BYREF
  __int64 v102; // [rsp+128h] [rbp+20h] BYREF
  __int64 v103; // [rsp+130h] [rbp+28h] BYREF
  __int64 v104; // [rsp+138h] [rbp+30h] BYREF
  __int64 v105; // [rsp+140h] [rbp+38h] BYREF
  __int64 v106; // [rsp+148h] [rbp+40h] BYREF
  __int64 v107; // [rsp+150h] [rbp+48h] BYREF
  __int64 v108; // [rsp+158h] [rbp+50h] BYREF
  __int64 v109; // [rsp+160h] [rbp+58h] BYREF
  __int64 v110; // [rsp+168h] [rbp+60h] BYREF
  __int64 v111; // [rsp+170h] [rbp+68h] BYREF
  __int64 v112; // [rsp+178h] [rbp+70h] BYREF
  __int64 v113; // [rsp+180h] [rbp+78h] BYREF
  __int64 v114; // [rsp+188h] [rbp+80h] BYREF
  __int64 v115; // [rsp+190h] [rbp+88h] BYREF
  __int64 v116; // [rsp+198h] [rbp+90h] BYREF
  __int64 v117; // [rsp+1A0h] [rbp+98h] BYREF
  __int64 v118; // [rsp+1A8h] [rbp+A0h] BYREF
  __int64 v119[2]; // [rsp+1B0h] [rbp+A8h] BYREF
  __int16 v120; // [rsp+1C0h] [rbp+B8h] BYREF
  __int64 v121; // [rsp+1C8h] [rbp+C0h]
  __int16 v122; // [rsp+1D0h] [rbp+C8h] BYREF
  __int64 v123; // [rsp+1D8h] [rbp+D0h]
  struct _EVENT_DATA_DESCRIPTOR UserData; // [rsp+1E8h] [rbp+E0h] BYREF
  void *Buf1; // [rsp+1F8h] [rbp+F0h] BYREF
  int v126; // [rsp+200h] [rbp+F8h]
  int v127; // [rsp+204h] [rbp+FCh]
  __int64 *v128; // [rsp+208h] [rbp+100h]
  __int64 v129[68]; // [rsp+210h] [rbp+108h]
  int v130; // [rsp+430h] [rbp+328h]
  int v131; // [rsp+434h] [rbp+32Ch]
  char *v132; // [rsp+438h] [rbp+330h]
  __int64 v133; // [rsp+440h] [rbp+338h]
  __int64 *v134; // [rsp+448h] [rbp+340h]
  __int64 v135; // [rsp+450h] [rbp+348h]
  __int64 *v136; // [rsp+458h] [rbp+350h]
  __int64 v137; // [rsp+460h] [rbp+358h]
  int *v138; // [rsp+468h] [rbp+360h]
  __int64 v139; // [rsp+470h] [rbp+368h]
  __int16 *v140; // [rsp+478h] [rbp+370h]
  __int64 v141; // [rsp+480h] [rbp+378h]
  int *v142; // [rsp+488h] [rbp+380h]
  __int64 v143; // [rsp+490h] [rbp+388h]
  int *v144; // [rsp+498h] [rbp+390h]
  __int64 v145; // [rsp+4A0h] [rbp+398h]
  __int16 *v146; // [rsp+4A8h] [rbp+3A0h]
  __int64 v147; // [rsp+4B0h] [rbp+3A8h]
  __int64 v148; // [rsp+4B8h] [rbp+3B0h]
  int v149; // [rsp+4C0h] [rbp+3B8h]
  int v150; // [rsp+4C4h] [rbp+3BCh]
  __int16 *v151; // [rsp+4C8h] [rbp+3C0h]
  __int64 v152; // [rsp+4D0h] [rbp+3C8h]
  int *v153; // [rsp+4D8h] [rbp+3D0h]
  __int64 v154; // [rsp+4E0h] [rbp+3D8h]
  int *v155; // [rsp+4E8h] [rbp+3E0h]
  __int64 v156; // [rsp+4F0h] [rbp+3E8h]
  int *v157; // [rsp+4F8h] [rbp+3F0h]
  __int64 v158; // [rsp+500h] [rbp+3F8h]
  int *v159; // [rsp+508h] [rbp+400h]
  __int64 v160; // [rsp+510h] [rbp+408h]
  int *v161; // [rsp+518h] [rbp+410h]
  __int64 v162; // [rsp+520h] [rbp+418h]
  int *v163; // [rsp+528h] [rbp+420h]
  __int64 v164; // [rsp+530h] [rbp+428h]
  int *v165; // [rsp+538h] [rbp+430h]
  __int64 v166; // [rsp+540h] [rbp+438h]
  char *v167; // [rsp+548h] [rbp+440h]
  __int64 v168; // [rsp+550h] [rbp+448h]
  int *v169; // [rsp+558h] [rbp+450h]
  __int64 v170; // [rsp+560h] [rbp+458h]
  int *v171; // [rsp+568h] [rbp+460h]
  __int64 v172; // [rsp+570h] [rbp+468h]
  __int16 *v173; // [rsp+578h] [rbp+470h]
  __int64 v174; // [rsp+580h] [rbp+478h]
  __int64 v175; // [rsp+588h] [rbp+480h]
  int v176; // [rsp+590h] [rbp+488h]
  int v177; // [rsp+594h] [rbp+48Ch]
  int *v178; // [rsp+598h] [rbp+490h]
  __int64 v179; // [rsp+5A0h] [rbp+498h]

  v1 = *((_DWORD *)this + 8);
  v2 = v1 & 0xF;
  v3 = v1 >> 4;
  v4 = 1 << v2;
  if ( (unsigned int)dword_180091480 <= 5
    || (qword_180091490 & 0x400000000000i64) == 0
    || (qword_180091498 & 0x400000000000i64) != qword_180091498 )
  {
    return;
  }
  v5 = *((unsigned __int16 *)this + 892);
  v6 = *((unsigned __int16 *)this + 788);
  v7 = (const WCHAR *)((char *)this + 664);
  v70 = *((_DWORD *)this + 395);
  v71 = *((_DWORD *)this + 11);
  v72 = *((_DWORD *)this + 28);
  v64 = *((_BYTE *)this + 108);
  v73 = *((_DWORD *)this + 26);
  v74 = *((_DWORD *)this + 15);
  v75 = *((_DWORD *)this + 14);
  v76 = *((_DWORD *)this + 13);
  v77 = *((_DWORD *)this + 12);
  v78 = *((_DWORD *)this + 10);
  v79 = *((_DWORD *)this + 9);
  v80 = *((_DWORD *)this + 18);
  v81 = *((_DWORD *)this + 17);
  v68 = *((_WORD *)this + 33);
  LOWORD(v69) = *((_WORD *)this + 32);
  v119[0] = *((_QWORD *)this + 16);
  v85 = *((_QWORD *)this + 15);
  v65 = *((_BYTE *)this + 24);
  v119[1] = (__int64)this + 1176;
  v120 = v6;
  v67 = v5;
  v121 = (__int64)this + 1584;
  v122 = v5;
  v123 = (__int64)this + 664;
  v82 = v3;
  v8 = v4 < 0 ? *((_QWORD *)this + 12) : 0i64;
  v86 = v8;
  v9 = (v4 & 0x4000) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v87 = v9;
  v10 = (v4 & 0x2000) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v88 = v10;
  v11 = (v4 & 0x1000) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v89 = v11;
  v12 = (v4 & 0x800) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v90 = v12;
  v13 = (v4 & 0x400) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v91 = v13;
  v14 = (v4 & 0x200) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v92 = v14;
  v15 = (v4 & 0x100) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v93 = v15;
  v16 = (v4 & 0x80u) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v94 = v16;
  v17 = (v4 & 0x40) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v95 = v17;
  v18 = (v4 & 0x20) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v96 = v18;
  v19 = (v4 & 0x10) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v97 = v19;
  v20 = (v4 & 8) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v98 = v20;
  v21 = (v4 & 4) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v99 = v21;
  v22 = (v4 & 2) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v100 = v22;
  v23 = (v4 & 1) != 0 ? *((_QWORD *)this + 12) : 0i64;
  v101 = v23;
  v118 = 1i64;
  v179 = 4i64;
  v102 = (unsigned __int16)v4 & 0x8000;
  v174 = 2i64;
  v103 = v4 & 0x4000;
  v175 = (__int64)this + 1176;
  v104 = v4 & 0x2000;
  v177 = 0;
  v105 = v4 & 0x1000;
  v172 = 4i64;
  v106 = v4 & 0x800;
  v170 = 4i64;
  v107 = v4 & 0x400;
  v168 = 1i64;
  v108 = v4 & 0x200;
  v166 = 4i64;
  v109 = v4 & 0x100;
  v164 = 4i64;
  v110 = (unsigned __int8)v4 & 0x80;
  v162 = 4i64;
  v111 = v4 & 0x40;
  v112 = v4 & 0x20;
  v113 = v4 & 0x10;
  v114 = v4 & 8;
  v115 = v4 & 4;
  v116 = v4 & 2;
  v178 = &v70;
  v173 = &v120;
  v176 = 4 * v6;
  v171 = &v71;
  v169 = &v72;
  v167 = &v64;
  v165 = &v73;
  v163 = &v74;
  v161 = &v75;
  v159 = &v76;
  v117 = v4 & 1;
  v160 = 4i64;
  v157 = &v77;
  v155 = &v78;
  v153 = &v79;
  v151 = &v67;
  v146 = &v122;
  v149 = 4 * v5;
  v144 = &v80;
  v142 = &v81;
  v140 = &v68;
  v138 = &v69;
  v136 = v119;
  v134 = &v85;
  v132 = &v65;
  v158 = 4i64;
  v156 = 4i64;
  v154 = 4i64;
  v152 = 2i64;
  v147 = 2i64;
  v148 = (__int64)this + 1584;
  v150 = 0;
  v145 = 4i64;
  v143 = 4i64;
  v141 = 2i64;
  v139 = 2i64;
  v137 = 8i64;
  v135 = 8i64;
  v133 = 1i64;
  if ( this == (CSchannelTelemetryContext *)-664i64 )
  {
    v7 = &Class;
    v26 = 2;
  }
  else
  {
    v24 = -1i64;
    while ( v7[++v24] != 0 )
      ;
    v26 = 2 * v24 + 2;
  }
  v129[67] = (__int64)v7;
  v129[65] = (__int64)&v82;
  v129[63] = (__int64)&v86;
  v129[61] = (__int64)&v87;
  v129[59] = (__int64)&v88;
  v129[57] = (__int64)&v89;
  v129[55] = (__int64)&v90;
  v129[53] = (__int64)&v91;
  v129[51] = (__int64)&v92;
  v129[49] = (__int64)&v93;
  v129[47] = (__int64)&v94;
  v129[45] = (__int64)&v95;
  v129[43] = (__int64)&v96;
  v129[41] = (__int64)&v97;
  v129[39] = (__int64)&v98;
  v129[37] = (__int64)&v99;
  v129[35] = (__int64)&v100;
  v129[33] = (__int64)&v101;
  v129[31] = (__int64)&v102;
  v129[29] = (__int64)&v103;
  v129[27] = (__int64)&v104;
  v129[25] = (__int64)&v105;
  v129[23] = (__int64)&v106;
  v129[21] = (__int64)&v107;
  v129[19] = (__int64)&v108;
  v129[17] = (__int64)&v109;
  v129[15] = (__int64)&v110;
  v130 = v26;
  v131 = 0;
  v129[66] = 4i64;
  v129[64] = 8i64;
  v129[62] = 8i64;
  v129[60] = 8i64;
  v129[58] = 8i64;
  v129[56] = 8i64;
  v129[54] = 8i64;
  v129[52] = 8i64;
  v129[50] = 8i64;
  v129[48] = 8i64;
  v129[46] = 8i64;
  v129[44] = 8i64;
  v129[42] = 8i64;
  v129[40] = 8i64;
  v129[38] = 8i64;
  v129[36] = 8i64;
  v129[34] = 8i64;
  v129[32] = 8i64;
  v129[30] = 8i64;
  v129[28] = 8i64;
  v129[26] = 8i64;
  v129[24] = 8i64;
  v129[22] = 8i64;
  v129[20] = 8i64;
  v129[18] = 8i64;
  v129[16] = 8i64;
  v129[14] = 8i64;
  v129[13] = (__int64)&v111;
  v129[12] = 8i64;
  v129[11] = (__int64)&v112;
  v129[9] = (__int64)&v113;
  v129[7] = (__int64)&v114;
  v129[5] = (__int64)&v115;
  v129[3] = (__int64)&v116;
  v129[1] = (__int64)&v117;
  v128 = &v118;
  *(_DWORD *)&EventDescriptor.Level = 5;
  UserData.Ptr = (ULONGLONG)off_180091488;
  v129[10] = 8i64;
  v129[8] = 8i64;
  v129[6] = 8i64;
  v129[4] = 8i64;
  v129[2] = 8i64;
  v129[0] = 8i64;
  *(_DWORD *)&EventDescriptor.Id = 184549376;
  EventDescriptor.Keyword = 0x400000000000i64;
  UserData.Size = *(unsigned __int16 *)off_180091488;
  Buf1 = &unk_180083F6C;
  UserData.Reserved = 2;
  v126 = 1137;
  v127 = 1;
  LODWORD(v66) = (unsigned int)&TraceLoggingMetadataEnd - (unsigned int)&TraceLoggingMetadata;
  if ( (void (__fastcall *)(const struct _GUID *, unsigned int, __int64, __int64, unsigned __int64, struct _EVENT_FILTER_DESCRIPTOR *, _QWORD *))qword_1800914A8 != TlgAggregateInternalRegisteredProviderEtwCallback )
    return;
  v27 = 0;
  v28 = (char *)&unk_180083F6E;
  do
    v29 = *v28++;
  while ( v29 < 0 );
  while ( *v28++ )
    ;
  if ( v28 >= (char *)&unk_1800843DD )
    goto LABEL_117;
  while ( 1 )
  {
    while ( *v28++ )
      ;
    if ( *v28 >= 0 )
      break;
    v32 = v28[1];
    v33 = *v28 & 0x7F;
    v28 += 2;
    if ( v32 >= 0 )
      break;
    v34 = *v28;
    if ( *v28 < 0 )
    {
      while ( v34 == (char)0x80 )
      {
        v34 = *++v28;
        if ( v34 >= 0 )
          goto LABEL_51;
      }
      break;
    }
LABEL_51:
    if ( v33 == 9 && (unsigned __int8)(v34 - 113) <= 2u )
    {
      v35 = v27++;
      BYTE5(v129[2 * v35]) = v34;
      if ( v28 < (char *)&unk_1800843DD )
        continue;
    }
    break;
  }
  if ( !v27 )
  {
LABEL_117:
    EventWriteTransfer_0(RegHandle, &EventDescriptor, 0i64, 0i64, 0x3Cu, &UserData);
    return;
  }
  v36 = 0i64;
  v37 = qword_1800914B0;
  v66 = 0i64;
  v83 = qword_1800914B0;
  v38 = 1025
      * (BYTE4(Buf1)
       + ((1025
         * (BYTE3(Buf1)
          + ((1025
            * (BYTE2(Buf1)
             + ((1025
               * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) ^ ((1025 * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) >> 6)))) ^ ((1025 * (BYTE2(Buf1) + ((1025 * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) ^ ((1025 * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) >> 6)))) >> 6)))) ^ ((1025 * (BYTE3(Buf1) + ((1025 * (BYTE2(Buf1) + ((1025 * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) ^ ((1025 * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) >> 6)))) ^ ((1025 * (BYTE2(Buf1) + ((1025 * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) ^ ((1025 * (BYTE1(Buf1) + ((1025 * (unsigned __int8)Buf1) ^ ((1025 * (unsigned int)(unsigned __int8)Buf1) >> 6)))) >> 6)))) >> 6)))) >> 6)));
  v39 = 1025 * (BYTE5(Buf1) + (v38 ^ (v38 >> 6)));
  v40 = 1025 * (BYTE6(Buf1) + (v39 ^ (v39 >> 6)));
  v41 = v27 + 2;
  v42 = ((1025 * (HIBYTE(Buf1) + (v40 ^ (v40 >> 6)))) >> 6) ^ (1025 * (HIBYTE(Buf1) + (v40 ^ (v40 >> 6))));
  if ( (unsigned __int8)(v27 + 2) < 0x3Cu )
  {
    v43 = &UserData + v41;
    v44 = (unsigned __int8)(60 - v41);
    do
    {
      for ( i = 0i64; i < v43->Size; v42 = ((1025 * (v42 + v46)) >> 6) ^ (1025 * (v42 + v46)) )
      {
        v46 = *(unsigned __int8 *)(i + v43->Ptr);
        ++i;
      }
      ++v43;
      --v44;
    }
    while ( v44 );
  }
  v47 = (RTL_SRWLOCK *)(qword_1800914B0 + 264);
  v48 = 32769 * ((9 * v42) ^ ((9 * v42) >> 11));
  AcquireSRWLockShared((PSRWLOCK)(qword_1800914B0 + 264));
  for ( j = (volatile signed __int64 *)(v37 + 8i64 * (v48 & 0x1F));
        ;
        j = (volatile signed __int64 *)((((__int64)v53 >> 63) & 0xFFFFFFFFFFFFFFF8ui64) + v50 + 32) )
  {
    if ( !*j )
    {
      if ( *(_DWORD *)(v37 + 256) >= 0x400u )
      {
        ++*(_DWORD *)(v37 + 300);
        goto LABEL_74;
      }
      if ( !v36 )
      {
        v60 = CreateNewEventEntry((__int128 *)&EventDescriptor, 0x3Cu, (__int64)&UserData, v27, v48, &v66);
        v36 = v66;
        if ( !v66 )
        {
          if ( v60 == 8 )
            ++*(_DWORD *)(v37 + 304);
          else
            ++*(_DWORD *)(v37 + 308);
          goto LABEL_74;
        }
      }
      if ( !_InterlockedCompareExchange64(j, v36, 0i64) )
      {
        v66 = 0i64;
        if ( _InterlockedIncrement((volatile signed __int32 *)(v37 + 256)) == 1 )
          EnableFlushTimer(*(struct _TP_TIMER **)(v37 + 344), *(_DWORD *)(v37 + 352));
        v61 = *(_DWORD *)(v37 + 256);
        v36 = v66;
        if ( *(_DWORD *)(v37 + 288) < v61 )
          *(_DWORD *)(v37 + 288) = v61;
        goto LABEL_74;
      }
      v36 = v66;
    }
    v50 = *j;
    v51 = *(_DWORD *)(v50 + 40);
    if ( v48 != v51 )
    {
      v53 = v48 - v51;
      continue;
    }
    v52 = *(_QWORD *)(v50 + 16);
    v53 = memcmp_0(&Buf1, (const void *)(v52 + 16), 8ui64);
    if ( v53 )
      continue;
    v54 = *(unsigned __int8 *)(v50 + 45) + 2;
    if ( v54 >= 0x3C )
      break;
    while ( 1 )
    {
      v53 = *(&UserData.Size + 4 * v54) - *(_DWORD *)(v52 + 16i64 * v54 + 8);
      if ( v53 )
        break;
      v53 = memcmp_0(
              *((const void **)&UserData.Ptr + 2 * v54),
              *(const void **)(v52 + 16i64 * v54),
              *(&UserData.Size + 4 * v54));
      if ( v53 )
        break;
      if ( ++v54 >= 0x3C )
        goto LABEL_68;
    }
    v37 = v83;
  }
LABEL_68:
  if ( v50 )
  {
    v55 = 2;
    do
    {
      v56 = **((_QWORD **)&UserData.Ptr + 2 * v55);
      v57 = *(_QWORD *)(v50 + 16);
      v58 = *(unsigned __int8 *)(v57 + 16i64 * v55 + 13);
      v59 = *(volatile signed __int64 **)(v57 + 16i64 * v55);
      if ( v58 == 113 )
      {
        _InterlockedExchangeAdd64(v59, v56);
      }
      else if ( (unsigned int)(v58 - 114) <= 1 )
      {
        do
        {
          v62 = *v59;
          if ( (_BYTE)v58 == 114 )
          {
            if ( v56 >= v62 )
              break;
          }
          else if ( v56 <= v62 )
          {
            break;
          }
          v63 = *v59;
        }
        while ( v63 != _InterlockedCompareExchange64(v59, v56, v62) );
      }
      ++v55;
    }
    while ( v55 < (unsigned int)v27 + 2 );
    v36 = v66;
  }
LABEL_74:
  ReleaseSRWLockShared(v47);
  if ( v36 )
    DestroyEventEntry(v36);
}
// 1800220DF: conditional instruction was optimized away because bl.1!=0
// 180091488: using guessed type void *off_180091488;
// 180091490: using guessed type __int64 qword_180091490;
// 180091498: using guessed type __int64 qword_180091498;
// 1800914A8: using guessed type __int64 qword_1800914A8;
// 1800914B0: using guessed type __int64 qword_1800914B0;

//----- (0000000180022240) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::TlsParseClientHello(
        CTls13ServerContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int8 *const a4,
        unsigned int *a5,
        unsigned int **a6,
        unsigned int *a7)
{
  return CTls13ServerHandshake::ParseClientHello((CTls13ServerContext *)((char *)this + 1288), a2, a3, a4, a5, a6, a7);
}

//----- (0000000180022260) ----------------------------------------------------
__int64 __fastcall CTls13ServerHandshake::ParseClientHello(
        CTls13ServerHandshake *this,
        unsigned __int8 *a2,
        unsigned int a3,
        unsigned __int8 *const a4,
        unsigned int *a5,
        unsigned int **a6,
        unsigned int *a7)
{
  CTls13ServerHandshake *v7; // r11
  unsigned int v10; // r13d
  __int64 v12; // rcx
  bool v13; // r14
  const void **v14; // r10
  unsigned int *v15; // r8
  unsigned int v16; // edi
  unsigned int v17; // edi
  SIZE_T v18; // rsi
  unsigned __int8 *v19; // rbx
  unsigned int v20; // edi
  size_t v21; // r14
  unsigned __int16 *v22; // rbx
  unsigned int v23; // edi
  unsigned __int16 *v24; // r15
  unsigned __int16 v25; // bp
  unsigned __int8 *v26; // rbx
  unsigned int v27; // edi
  unsigned __int16 v28; // si
  unsigned int v29; // r12d
  _DWORD *v30; // r9
  _DWORD *v31; // rdx
  int v32; // eax
  int v33; // ecx
  unsigned int v34; // ebx
  __int64 v35; // rsi
  unsigned int v36; // edi
  char *v37; // rcx
  __int64 v38; // rdx
  unsigned int v39; // edi
  char *v40; // r9
  unsigned int v41; // edi
  unsigned int v42; // ebx
  __int64 v43; // r12
  char *v44; // rdi
  unsigned __int8 v45; // r14
  __int64 v46; // rax
  char v47; // r15
  CCipherMill *v48; // r10
  unsigned __int16 v49; // si
  unsigned int v50; // ebp
  unsigned int *v51; // rdi
  unsigned int v52; // ebx
  unsigned int v53; // eax
  unsigned __int8 v55; // r9
  int v56; // edx
  __int64 v57; // rax
  unsigned int v58; // edi
  unsigned int *Memory; // [rsp+30h] [rbp-48h]
  unsigned int v61; // [rsp+88h] [rbp+10h]

  v7 = this;
  v10 = 0;
  v12 = *((_QWORD *)this + 1);
  v13 = *(_DWORD *)(v12 + 68) == 71;
  if ( !a2 )
    return 87i64;
  if ( !a3 )
    return 87i64;
  if ( !a5 )
    return 87i64;
  v14 = (const void **)a6;
  if ( !a6 )
    return 87i64;
  v15 = a7;
  if ( !a7 )
    return 87i64;
  if ( a3 < 2 )
  {
    v10 = -2146893048;
    goto LABEL_66;
  }
  if ( (a2[1] | (*a2 << 8)) < 0x300u )
  {
    v55 = 70;
    v56 = 1201;
LABEL_64:
    CSslContext::SetErrorAndFatalAlert(v12, v56, -2146893048, v55);
    v10 = -2146893048;
    goto LABEL_65;
  }
  v16 = a3 - 2;
  if ( v16 < 0x20 )
    goto LABEL_62;
  if ( *(_DWORD *)(v12 + 68) == 71 )
  {
    if ( RtlCompareMemory(a2 + 2, (const void *)(v12 + 272), 0x20ui64) != 32 )
      goto LABEL_72;
    v7 = this;
    v15 = a7;
    v14 = (const void **)a6;
  }
  else
  {
    *(_OWORD *)(v12 + 272) = *(_OWORD *)(a2 + 2);
    *(_OWORD *)(v12 + 288) = *(_OWORD *)(a2 + 18);
  }
  v17 = v16 - 32;
  if ( !v17 || (v18 = a2[34], (unsigned __int8)v18 > 0x20u) || (v19 = a2 + 35, v20 = v17 - 1, v20 < (unsigned int)v18) )
  {
    v12 = *((_QWORD *)v7 + 1);
    goto LABEL_62;
  }
  if ( v13 )
  {
    v12 = *((_QWORD *)v7 + 1);
    if ( *(_BYTE *)(v12 + 1281) != (_BYTE)v18 )
    {
      v55 = 47;
      goto LABEL_63;
    }
  }
  if ( (_BYTE)v18 )
  {
    if ( !v13 )
    {
      v21 = v18;
LABEL_18:
      memcpy_0(a4, v19, v21);
      v7 = this;
      v15 = a7;
      v14 = (const void **)a6;
      goto LABEL_19;
    }
    if ( *((_QWORD *)v7 + 1) == -1249i64 )
    {
      v10 = -2146893052;
      goto LABEL_66;
    }
    v21 = v18;
    if ( RtlCompareMemory(v19, (const void *)(*((_QWORD *)v7 + 1) + 1249i64), v18) == v18 )
      goto LABEL_18;
LABEL_72:
    v55 = 47;
    v12 = *((_QWORD *)this + 1);
    goto LABEL_63;
  }
LABEL_19:
  *a5 = v18;
  v22 = (unsigned __int16 *)&v19[v18];
  v12 = *((_QWORD *)v7 + 1);
  v23 = v20 - v18;
  if ( *(_BYTE *)(v12 + 233) )
  {
    if ( !v23 )
      goto LABEL_62;
    v57 = *(unsigned __int8 *)v22;
    if ( (unsigned __int8)v57 > 0x20u )
      goto LABEL_62;
    v58 = v23 - 1;
    if ( v58 < (unsigned int)v57 )
      goto LABEL_62;
    v22 = (unsigned __int16 *)((char *)v22 + v57 + 1);
    v23 = v58 - v57;
  }
  v24 = v22;
  if ( v23 < 2
    || (v25 = _byteswap_ushort(*v22), v25 < 2u)
    || (v25 & 1) != 0
    || (v26 = (unsigned __int8 *)(v22 + 1), v27 = v23 - 2, v27 < v25) )
  {
LABEL_62:
    v55 = 50;
LABEL_63:
    v56 = 1200;
    goto LABEL_64;
  }
  v28 = v25 >> 1;
  v29 = v25 >> 1;
  v61 = v29;
  if ( v29 > *v15 )
  {
    Memory = (unsigned int *)CSslContext::GetMemory((CSslContext *)v12, 4 * (unsigned int)v28);
    v30 = Memory;
    if ( !Memory )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
        WPP_SF_d(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x1Fu,
          (__int64)WPP_922678f99ae534148d3bb024010f1556_Traceguids,
          4 * v29);
      v10 = 14;
      goto LABEL_65;
    }
    v7 = this;
    v14 = (const void **)a6;
  }
  else
  {
    v30 = *v14;
    Memory = (unsigned int *)*v14;
  }
  if ( v28 )
  {
    v31 = v30;
    v15 = (unsigned int *)(v25 >> 1);
    do
    {
      v32 = *v26;
      ++v31;
      v33 = v26[1];
      v26 += 2;
      *(v31 - 1) = (v32 << 8) | v33;
      v15 = (unsigned int *)((char *)v15 - 1);
    }
    while ( v15 );
  }
  v34 = v25 >> 1;
  v35 = *(_QWORD *)(*((_QWORD *)v7 + 1) + 120i64);
  if ( v35 && CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
  {
    *(_DWORD *)(v35 + 1580) = v29;
    if ( v29 > 0x64 )
      v34 = 100;
    memcpy_0((void *)(v35 + 1176), v30, 4i64 * v34);
    v7 = this;
    v14 = (const void **)a6;
    *(_WORD *)(v35 + 1576) = v34;
  }
  v36 = v27 - v25;
  v37 = (char *)v24 + v25;
  if ( !v36 )
    goto LABEL_83;
  v38 = (unsigned __int8)v37[2];
  if ( !(_BYTE)v38 )
  {
    v10 = -2146893048;
    goto LABEL_100;
  }
  v39 = v36 - 1;
  if ( v39 < (unsigned int)v38 )
    goto LABEL_83;
  v40 = v37 + 3;
  if ( v37[3] )
  {
    while ( v40 != &v37[v38 + 2] )
    {
      if ( !*++v40 )
        goto LABEL_38;
    }
LABEL_83:
    CSslContext::SetErrorAndFatalAlert(*((_QWORD *)v7 + 1), 1200, -2146893048, 0x32u);
    v10 = -2146893048;
    goto LABEL_99;
  }
LABEL_38:
  v41 = v39 - v38;
  if ( v41 < 2 )
    goto LABEL_54;
  v42 = (unsigned __int8)v37[v38 + 4] | ((unsigned __int8)v37[v38 + 3] << 8);
  if ( v41 < v42 )
    goto LABEL_54;
  v43 = *((_QWORD *)v7 + 2);
  v44 = &v37[v38 + 5];
  v45 = 0;
  v46 = *(_QWORD *)(v43 + 8);
  v47 = *(_BYTE *)(v46 + 64) & 0x30;
  *(_DWORD *)(v43 + 16) = 1;
  *(_BYTE *)(v46 + 922) = 0;
  *(_BYTE *)(v43 + 27) = 0;
  if ( !v42 )
  {
LABEL_52:
    (*(void (__fastcall **)(_QWORD, _QWORD, unsigned int *, char *))(**(_QWORD **)(v43 + 8) + 352i64))(
      *(_QWORD *)(v43 + 8),
      v45,
      v15,
      v40);
    v10 = 0;
LABEL_53:
    v29 = v61;
LABEL_54:
    v15 = a7;
    *a6 = Memory;
    goto LABEL_55;
  }
  v48 = WPP_GLOBAL_Control;
  while ( 1 )
  {
    if ( v42 < 4 )
      goto LABEL_96;
    v49 = _byteswap_ushort(*((_WORD *)v44 + 1));
    v50 = (unsigned __int8)v44[1] | ((unsigned __int8)*v44 << 8);
    if ( v48 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v48 + 28) & 4) != 0 )
    {
      WPP_SF_D(*((_QWORD *)v48 + 2), 73i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids, v50);
      v48 = WPP_GLOBAL_Control;
    }
    v51 = (unsigned int *)(v44 + 4);
    v52 = v42 - 4;
    if ( v52 < v49 )
    {
      if ( v48 != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)v48 + 28) & 2) != 0 )
        WPP_SF_(*((_QWORD *)v48 + 2), 74i64, &WPP_f49a95b901763c3505884ea2834cd757_Traceguids);
LABEL_96:
      v10 = -2146893018;
LABEL_97:
      CSslContext::SetErrorAndFatalAlert(*((_QWORD *)this + 1), 1200, -2146893048, 0x32u);
      goto LABEL_98;
    }
    v15 = v51;
    v44 = (char *)v51 + v49;
    v42 = v52 - v49;
    if ( v47 && v50 != 65281 )
      goto LABEL_51;
    v53 = (*(__int64 (__fastcall **)(__int64, _QWORD, unsigned int *, _QWORD))(*(_QWORD *)v43 + 8i64))(
            v43,
            v50,
            v15,
            v49);
    v10 = v53;
    if ( v53 )
      break;
    v48 = WPP_GLOBAL_Control;
    if ( v50 == 65281 )
      v45 = 1;
LABEL_51:
    if ( !v42 )
      goto LABEL_52;
  }
  if ( v53 != -2146892986 && v53 != -2146892953 )
    goto LABEL_97;
LABEL_98:
  if ( !v10 )
    goto LABEL_53;
LABEL_99:
  v14 = (const void **)a6;
  v7 = this;
LABEL_100:
  if ( Memory && Memory != *v14 )
    (*(void (__fastcall **)(_QWORD))(**((_QWORD **)v7 + 1) + 16i64))(*((_QWORD *)v7 + 1));
LABEL_65:
  v15 = a7;
LABEL_66:
  v29 = 0;
LABEL_55:
  *v15 = v29;
  return v10;
}
// 18002260E: variable 'v15' is possibly undefined
// 18002260E: variable 'v40' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180082C10: using guessed type _DWORD WPP_922678f99ae534148d3bb024010f1556_Traceguids[4];
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;

//----- (0000000180022670) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::ProcessRecord(__int64 a1, int a2, unsigned __int8 *a3, unsigned int a4)
{
  char v4; // al
  unsigned int v5; // ebp
  unsigned __int8 *v6; // r14
  __int64 v8; // rbx
  unsigned int v9; // esi
  __int64 v10; // rax
  bool v11; // cl
  int v12; // edi
  __int64 v13; // rdi
  unsigned int v14; // eax
  unsigned int v15; // eax
  int v17; // eax
  __int64 v18; // rcx
  char v19; // al
  int v20; // eax
  __int64 v21; // r10
  unsigned int v22; // eax
  unsigned int v23; // r9d
  CTlsMessageFragment *v24; // rcx
  unsigned int v25; // eax
  _QWORD *Memory; // rax
  CCipherMill *v27; // rcx
  bool v28; // zf
  CCipherMill *v29; // rcx
  bool v30; // zf
  int v31; // edx
  unsigned int v32; // eax
  int v33; // eax
  unsigned int *v34; // [rsp+20h] [rbp-48h]
  __int64 v35; // [rsp+28h] [rbp-40h]
  unsigned int v36; // [rsp+70h] [rbp+8h] BYREF
  unsigned __int8 v37; // [rsp+78h] [rbp+10h] BYREF

  v4 = *(_BYTE *)(a1 + 233);
  v5 = a4;
  v6 = a3;
  v8 = a1;
  v9 = -2146893018;
  if ( v4 )
    v9 = 590610;
  if ( a2 == 20 )
  {
    v17 = *(_DWORD *)(a1 + 68);
    if ( v17 == 61 )
    {
      if ( (*(_DWORD *)(a1 + 136) & 0x100i64) != 0 && !*(_BYTE *)(a1 + 552) )
        return (unsigned int)-2146893018;
    }
    else if ( ((v17 - 62) & 0xFFFFFFFD) != 0 )
    {
      return v9;
    }
    if ( a4 == 1 && *a3 == 1 )
    {
      *(_WORD *)(a1 + 32) |= 0xAu;
      v18 = *(_QWORD *)(a1 + 144);
      if ( v18 )
        SslFreeObject(v18, 0i64);
      *(_QWORD *)(v8 + 144) = *(_QWORD *)(v8 + 160);
      v19 = *(_BYTE *)(v8 + 233);
      *(_QWORD *)(v8 + 160) = 0i64;
      if ( !v19 )
        *(_QWORD *)(v8 + 176) = 0i64;
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 60i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        v19 = *(_BYTE *)(v8 + 233);
      }
      if ( v19 )
      {
        ++*(_DWORD *)(v8 + 192);
        *(_QWORD *)(v8 + 208) = 0i64;
        *(_QWORD *)(v8 + 200) = 0i64;
      }
      v20 = 63;
      v9 = 0;
      if ( *(_DWORD *)(v8 + 68) == 64 )
        v20 = 65;
      *(_DWORD *)(v8 + 68) = v20;
      return v9;
    }
    v31 = 904;
    goto LABEL_112;
  }
  if ( v4 )
    return (unsigned int)CSsl3TlsContext::DtlsProcessRecord(a1, a2, a3, a4);
  v10 = *(_QWORD *)(a1 + 464);
  v11 = 1;
  v36 = 0;
  if ( v10 && *(_DWORD *)(v10 + 36) )
  {
    if ( a2 == 22 )
    {
      v9 = CTlsMessageFragment::SaveFragment((CTlsMessageFragment *)v10, a3, a4, 0, &v36);
      if ( v9 )
        return v9;
      v21 = *(_QWORD *)(v8 + 464);
      v22 = 12;
      v23 = *(_DWORD *)(v21 + 32);
      if ( !*(_DWORD *)(v21 + 40) )
        v22 = 4;
      if ( (v23 <= v22 || *(_DWORD *)(v21 + 36) < v23)
        && (*(_DWORD *)(v21 + 36) < v22
         || *(unsigned __int8 *)(*(_QWORD *)(v21 + 24) + 3i64)
          + (*(unsigned __int8 *)(*(_QWORD *)(v21 + 24) + 1i64) << 16)
          + (*(unsigned __int8 *)(*(_QWORD *)(v21 + 24) + 2i64) << 8)) )
      {
        return 0;
      }
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_d(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x45u,
          (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
          v23);
        v21 = *(_QWORD *)(v8 + 464);
      }
      v9 = CSsl3TlsContext::ProcessHandshakeCommon(
             (CSsl3TlsContext *)v8,
             *(unsigned __int8 **)(v21 + 24),
             *(_DWORD *)(v21 + 32));
      if ( v9 )
        return v9;
      *(_QWORD *)(*(_QWORD *)(v8 + 464) + 32i64) = 0i64;
      v6 += v36;
      v5 -= v36;
      v11 = v5 != 0;
    }
    else if ( a2 == 21 )
    {
      *(_QWORD *)(v10 + 32) = 0i64;
    }
    v9 = 0;
    if ( !v11 )
      return v9;
  }
  v12 = a2 - 21;
  if ( !v12 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 57i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
    v33 = TlsParseAlertMessage(v6, v5, (unsigned __int8 *)(v8 + 473), &v37);
    v9 = v33;
    if ( !v33 )
    {
      if ( v37 )
      {
        *(_BYTE *)(v8 + 552) = 1;
        *(_DWORD *)(v8 + 68) = 75;
      }
      return v9;
    }
    if ( v33 == -2146892953 || *(_DWORD *)(v8 + 36) < 0x302u || (*(_DWORD *)(v8 + 64) & 0x800A00AA) == 0 )
    {
      if ( v5 == 2 )
        LogReceiveAlertEvent(
          *(_DWORD *)(*(_QWORD *)(v8 + 80) + 212i64),
          (const unsigned __int16 *)(*(_QWORD *)(v8 + 80) + 216i64),
          *v6,
          v6[1]);
      return v9;
    }
    CSslContext::SetError(v8, 14, v33);
    return (unsigned int)-2146893018;
  }
  if ( v12 != 1 )
    return 0;
  while ( 1 )
  {
    if ( v5 < 4 )
    {
      v24 = *(CTlsMessageFragment **)(v8 + 464);
      if ( v24 )
        goto LABEL_96;
      if ( (*(_DWORD *)(v8 + 64) & 0x40051555) != 0 )
      {
        if ( (*(_DWORD *)(v8 + 136) & 0x100i64) != 0 )
        {
          v32 = CSslGlobals::m_dwTlsMessageLimitSrvClientAuth;
          if ( CSslGlobals::m_dwTlsMessageLimitSrv > CSslGlobals::m_dwTlsMessageLimitSrvClientAuth )
            v32 = CSslGlobals::m_dwTlsMessageLimitSrv;
          if ( !v32 )
            goto LABEL_75;
        }
        if ( !CSslGlobals::m_dwTlsMessageLimitSrv )
          goto LABEL_75;
      }
      else if ( !CSslGlobals::m_dwTlsMessageLimitClient )
      {
LABEL_75:
        v29 = WPP_GLOBAL_Control;
        v30 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
LABEL_76:
        if ( !v30 && (*((_BYTE *)v29 + 28) & 1) != 0 )
          WPP_SF_(*((_QWORD *)v29 + 2), 67i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
        v31 = 12;
        a1 = v8;
LABEL_112:
        CSslContext::SetErrorAndFatalAlert(a1, v31, -2146893018, 0xAu);
        return (unsigned int)-2146893018;
      }
      Memory = CSslContext::GetMemory((CSslContext *)v8, 0x30u);
      if ( !Memory )
      {
        v27 = WPP_GLOBAL_Control;
        v28 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
        goto LABEL_81;
      }
      goto LABEL_95;
    }
    v13 = v6[3] + (v6[1] << 16) + (v6[2] << 8);
    if ( v13 + 4 > (unsigned __int64)v5 )
      break;
    v36 = 0;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    {
      LODWORD(v35) = *(_DWORD *)(v8 + 68);
      LODWORD(v34) = *v6;
      WPP_SF_DDD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x3Au,
        (__int64)&WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids,
        *(_DWORD *)(v8 + 64),
        v34,
        v35);
    }
    v14 = (*(__int64 (__fastcall **)(__int64, unsigned __int8 *, _QWORD, unsigned int *))(*(_QWORD *)v8 + 416i64))(
            v8,
            v6,
            (unsigned int)(v13 + 4),
            &v36);
    v9 = v14;
    if ( (!v14 || v14 == 590624) && !*(_DWORD *)(v8 + 872) && !v36 )
    {
      v15 = (*(__int64 (__fastcall **)(__int64, unsigned __int8 *, _QWORD, _QWORD))(*(_QWORD *)v8 + 504i64))(
              v8,
              v6,
              (unsigned int)(v13 + 4),
              0i64);
      if ( v15 )
        v9 = v15;
    }
    if ( *(_BYTE *)(v8 + 923) )
    {
      v9 = 590610;
      *(_DWORD *)(v8 + 72) = *(_DWORD *)(v8 + 68);
      *(_DWORD *)(v8 + 68) = 77;
      return v9;
    }
    if ( v9 == 590624 )
    {
      *(_BYTE *)(v8 + 924) = 1;
      return v9;
    }
    if ( !v9 )
    {
      v6 += v13 + 4;
      v5 += -4 - v13;
      if ( v5 )
        continue;
    }
    return v9;
  }
  v24 = *(CTlsMessageFragment **)(v8 + 464);
  if ( v24 )
  {
LABEL_96:
    v36 = 0;
    return (unsigned int)CTlsMessageFragment::SaveFragment(v24, v6, v5, 1, &v36);
  }
  if ( (*(_DWORD *)(v8 + 64) & 0x40051555) == 0 )
  {
    if ( CSslGlobals::m_dwTlsMessageLimitClient )
      goto LABEL_71;
    goto LABEL_74;
  }
  if ( (*(_DWORD *)(v8 + 136) & 0x100i64) != 0 )
  {
    v25 = CSslGlobals::m_dwTlsMessageLimitSrvClientAuth;
    if ( CSslGlobals::m_dwTlsMessageLimitSrv > CSslGlobals::m_dwTlsMessageLimitSrvClientAuth )
      v25 = CSslGlobals::m_dwTlsMessageLimitSrv;
    if ( !v25 )
      goto LABEL_74;
  }
  if ( !CSslGlobals::m_dwTlsMessageLimitSrv )
  {
LABEL_74:
    v29 = WPP_GLOBAL_Control;
    v30 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
    goto LABEL_76;
  }
LABEL_71:
  Memory = CSslContext::GetMemory((CSslContext *)v8, 0x30u);
  if ( Memory )
  {
LABEL_95:
    *Memory = 0i64;
    *(_QWORD *)((char *)Memory + 12) = 256i64;
    Memory[3] = 0i64;
    Memory[4] = 0i64;
    *(_QWORD *)(v8 + 464) = Memory;
    CTlsMessageFragment::Initialize((CTlsMessageFragment *)Memory, (struct CSsl3TlsContext *)v8);
    v24 = *(CTlsMessageFragment **)(v8 + 464);
    goto LABEL_96;
  }
  v27 = WPP_GLOBAL_Control;
  v28 = WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control;
LABEL_81:
  if ( !v28 && (*((_BYTE *)v27 + 28) & 1) != 0 )
    WPP_SF_(*((_QWORD *)v27 + 2), 68i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
  return 14;
}
// 18003F865: variable 'v34' is possibly undefined
// 18003F865: variable 'v35' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (00000001800228D0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::LookupEccCurveType(CSsl3TlsServerContext *this, int a2)
{
  unsigned __int16 *v2; // rax
  __int64 v3; // r9
  unsigned __int16 *v4; // r8

  v2 = (unsigned __int16 *)*((_QWORD *)this + 114);
  v3 = *((unsigned __int16 *)this + 460);
  v4 = &v2[v3];
  if ( v2 < v4 )
  {
    while ( *v2 != a2 )
    {
      if ( ++v2 >= v4 )
        goto LABEL_6;
    }
    return 0i64;
  }
LABEL_6:
  if ( !(_WORD)v3 )
    return 0i64;
  return 50i64;
}

//----- (0000000180022910) ----------------------------------------------------
void __fastcall CSsl3TlsServerContext::SetStateConnected(CSsl3TlsServerContext *this)
{
  __int64 v1; // rax
  __int64 v3; // rcx
  DWORD v4; // edi
  DWORD v5; // ebp
  LARGE_INTEGER v6; // r14
  bool v7; // r9
  __int64 v8; // rax
  __int64 v9; // r11
  int v10; // r10d
  LARGE_INTEGER *v11; // rbx
  LARGE_INTEGER *v12; // r11
  __int64 v13; // r8
  __int64 v14; // rdx
  bool v15; // zf
  unsigned __int16 v16; // ax
  DTlsHandshakeQueue *v17; // rcx
  struct kexch *KeyExchangeInfo; // rax
  int v19; // r10d
  _DWORD *v20; // r11
  char v21[8]; // [rsp+A0h] [rbp-708h] BYREF
  DWORD v22; // [rsp+A8h] [rbp-700h]
  LONG v23; // [rsp+ACh] [rbp-6FCh]

  v1 = *(_QWORD *)this;
  *((_DWORD *)this + 17) = 4;
  (*(void (**)(void))(v1 + 456))();
  if ( *((_BYTE *)this + 233) )
  {
    v16 = CSslContext::computeMaxPayload(this, *((unsigned __int16 *)this + 108));
    v17 = (DTlsHandshakeQueue *)*((_QWORD *)this + 73);
    *((_WORD *)this + 109) = v16;
    DTlsHandshakeQueue::DtlsHandshakeDone(v17);
    **((_DWORD **)this + 72) = 0;
    *((_WORD *)this + 110) = 0;
  }
  memset_0(v21, 0, 0x6E8ui64);
  v3 = *((_QWORD *)this + 1);
  if ( v3 )
  {
    v4 = *(_DWORD *)(v3 + 28);
    v22 = v4;
  }
  else
  {
    v4 = 0;
    v22 = 0;
  }
  v5 = *((unsigned __int16 *)this + 17);
  v6 = *(LARGE_INTEGER *)((char *)this + 136);
  v7 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
  v23 = *((_DWORD *)this + 4);
  if ( v3 )
  {
    v8 = *((_QWORD *)this + 11);
    if ( v8 )
    {
      v9 = *((_QWORD *)this + 15);
      v10 = *(_DWORD *)(v3 + 32);
      if ( v9 )
      {
        if ( CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized )
        {
          *(_DWORD *)(v9 + 48) = *(_DWORD *)(v8 + 8);
          if ( v10 == 43522 || v10 == 41984 )
          {
            KeyExchangeInfo = GetKeyExchangeInfo(v10);
            if ( KeyExchangeInfo )
            {
              v20[13] = *((_DWORD *)KeyExchangeInfo + 8);
              v20[14] = *((_DWORD *)KeyExchangeInfo + 10);
              if ( v19 == 43522 )
                v20[15] = *((_DWORD *)KeyExchangeInfo + 12);
            }
          }
        }
      }
    }
  }
  v11 = (LARGE_INTEGER *)*((_QWORD *)this + 15);
  v12 = v11;
  if ( v11 )
  {
    if ( !v7 )
      return;
    v11[4].HighPart = v23;
    v11[4].LowPart = v4;
    v11[5].LowPart = v5;
    v11[16] = v6;
    QueryPerformanceCounter(v11 + 11);
    v13 = 1000 * (v11[11].QuadPart - v11[10].QuadPart);
    v11[12].QuadPart = v13;
    if ( CSchannelTelemetryContext::m_liPerfCtrFreq.QuadPart == 10000000 )
      v14 = v13 / 10000000;
    else
      v14 = v13 / CSchannelTelemetryContext::m_liPerfCtrFreq.QuadPart;
    v15 = v11[13].LowPart == -2146893032;
    v11[12].QuadPart = v14;
    if ( v15 )
    {
      v11[13].LowPart = 0;
      v11[14].LowPart = 0;
    }
    CSchannelTelemetryContext::WriteEvent((CSchannelTelemetryContext *)v11, 0, v13);
    v12 = (LARGE_INTEGER *)*((_QWORD *)this + 15);
    v7 = CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
  }
  if ( v12
    && v7
    && WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_SSSdiiDDDDDddiDDd(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      HIWORD(v12[8].u.LowPart),
      LOWORD(v12[8].LowPart),
      L"Server",
      (const wchar_t *)&v12[19],
      (const wchar_t *)&v12[83],
      v12[3].LowPart,
      v12[15].QuadPart,
      v12[16].QuadPart,
      v12[4].LowPart,
      v12[4].HighPart,
      v12[5].LowPart,
      v12[5].HighPart,
      v12[6].LowPart,
      v12[8].LowPart,
      HIWORD(v12[8].u.LowPart),
      v12[12].QuadPart,
      v12[13].LowPart,
      BYTE4(v12[13].QuadPart),
      v12[14].LowPart);
  }
}
// 1800229FF: variable 'v7' is possibly undefined
// 18003FBD5: variable 'v20' is possibly undefined
// 18003FBE7: variable 'v19' is possibly undefined
// 180082BC8: using guessed type wchar_t aServer_0[7];
// 1800927AC: using guessed type bool CSchannelTelemetryContext::m_bTelemetryIsGloballyInitialized;
// 180022910: using guessed type char var_708[8];

//----- (0000000180022B10) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::SetGenericExtensionBuffers(
        CTls13ServerContext *this,
        struct _SecBufferDesc *const a2,
        struct _SecBuffer *const a3)
{
  return CTls13Context::SetGenericExtensionBuffers((CTls13ServerContext *)((char *)this + 1000), a2, a3);
}

//----- (0000000180022B30) ----------------------------------------------------
__int64 __fastcall CTls13Context::SetGenericExtensionBuffers(
        CTls13Context *this,
        struct _SecBufferDesc *const a2,
        struct _SecBuffer *const a3)
{
  void *v6; // rax
  PSecBuffer pBuffers; // rdx
  int v8; // eax
  unsigned int v9; // edx
  unsigned int v11; // ecx
  _DWORD *pvBuffer; // rdi
  int v13; // r8d
  __int64 v14; // r9
  unsigned __int64 cbBuffer; // rcx
  _DWORD *v16; // r8
  __int64 v17; // rdi
  unsigned __int64 v18; // r9
  __int16 *v19; // rdi
  unsigned __int64 v20; // r9

  *((_QWORD *)this + 18) = 0i64;
  *((_QWORD *)this + 16) = 0i64;
  memset((char *)this + 112, 0, 8ui64);
  *((_BYTE *)this + 120) = 0;
  v6 = (void *)*((_QWORD *)this + 20);
  if ( v6 )
  {
    v11 = *((_DWORD *)this + 38);
    if ( v11 )
    {
      if ( *((_BYTE *)this + 8) )
      {
        if ( a3 )
        {
          if ( a3->cbBuffer )
          {
            if ( a3->cbBuffer < v11 )
            {
              a3->cbBuffer = v11;
              v9 = -2146892950;
              goto LABEL_39;
            }
            memcpy_0(a3->pvBuffer, *((const void **)this + 20), *((unsigned int *)this + 38));
            SPExternalFree(*((void **)this + 20));
          }
          else
          {
            a3->pvBuffer = v6;
          }
          v9 = 590614;
          a3->cbBuffer = *((_DWORD *)this + 38);
          *((_QWORD *)this + 20) = 0i64;
          *((_DWORD *)this + 38) = 0;
          *((_BYTE *)this + 136) = 0;
LABEL_39:
          *((_QWORD *)this + 18) = 0i64;
          *((_QWORD *)this + 16) = 0i64;
          memset((char *)this + 112, 0, 8ui64);
          *((_BYTE *)this + 120) = 0;
          return v9;
        }
        SPExternalFree(*((void **)this + 20));
        *((_QWORD *)this + 20) = 0i64;
        *((_DWORD *)this + 38) = 0;
        *((_BYTE *)this + 136) = 0;
      }
    }
  }
  if ( a2 )
  {
    pBuffers = a2->pBuffers;
    if ( pBuffers < &pBuffers[a2->cBuffers] )
    {
      do
      {
        v8 = pBuffers->BufferType & 0xFFFFFFF;
        if ( v8 == 25 )
        {
          if ( *((_BYTE *)this + 120) )
            goto LABEL_38;
          if ( pBuffers->cbBuffer < 0xC )
            goto LABEL_38;
          pvBuffer = pBuffers->pvBuffer;
          v13 = *((unsigned __int16 *)pvBuffer + 4);
          if ( v13 + 10 > pBuffers->cbBuffer
            || (unsigned int)(v13 + 4) > 0xFFFF
            || pvBuffer[1]
            || !CTls13Context::IsValidGenericExtensionType(*(_WORD *)pvBuffer) )
          {
            goto LABEL_38;
          }
          *((_QWORD *)this + v14 + 14) = pvBuffer;
          ++*((_BYTE *)this + 120);
        }
        else if ( v8 == 26 )
        {
          cbBuffer = pBuffers->cbBuffer;
          if ( (unsigned int)cbBuffer < 0xC )
            goto LABEL_38;
          if ( *((_QWORD *)this + 16) )
            goto LABEL_38;
          v16 = pBuffers->pvBuffer;
          v17 = (unsigned int)v16[1];
          if ( (unsigned int)(v17 - 1) > 1 )
            goto LABEL_38;
          if ( *v16 )
            goto LABEL_38;
          v18 = 4 * v17 + 8;
          if ( v18 > cbBuffer )
            goto LABEL_38;
          v19 = (__int16 *)(v16 + 2);
          if ( v16 + 2 < (_DWORD *)((char *)v16 + v18) )
          {
            while ( CTls13Context::IsValidGenericExtensionType(*v19) )
            {
              v19 += 2;
              if ( (unsigned __int64)v19 >= v20 )
                goto LABEL_36;
            }
LABEL_38:
            v9 = -2146892963;
            goto LABEL_39;
          }
LABEL_36:
          *((_QWORD *)this + 16) = v16;
        }
        ++pBuffers;
      }
      while ( pBuffers < &a2->pBuffers[(unsigned __int64)a2->cBuffers] );
    }
    if ( *((_QWORD *)this + 16) && !a3 )
      goto LABEL_38;
    *((_QWORD *)this + 18) = a3;
    return 0;
  }
  return 0i64;
}
// 180022BB7: variable 'pBuffers' is possibly undefined
// 18003FDA2: variable 'v14' is possibly undefined
// 18003FE00: variable 'v20' is possibly undefined
// 18003FE02: variable 'v16' is possibly undefined

//----- (0000000180022C10) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::ProcessHandshake(
        CTls13ServerContext *this,
        unsigned __int8 *a2,
        unsigned int a3,
        int *a4)
{
  __int64 v4; // rsi
  unsigned int updated; // ebp
  __int64 v10; // r15
  unsigned __int8 *v11; // r10
  int v12; // ecx
  unsigned int v13; // r8d
  int v14; // r9d
  unsigned int v15; // edx
  bool v16; // r15
  __int64 v17; // rax
  __int64 v18; // r9
  unsigned int v20; // edx
  unsigned int v21; // edx
  CCipherMill *v22; // rcx
  __int64 v23; // rdx
  CCipherMill *v24; // rcx
  __int64 v25; // rdx
  unsigned int v26; // edx
  unsigned int v27; // edx
  __int64 *v28; // rax
  __int64 v29; // rcx
  int v30; // eax
  __int64 v31; // rdx
  __int64 v32; // rcx
  __int64 v33; // rax
  __int64 v34; // rcx
  __int64 v35; // rax
  __int64 *v36; // rax
  __int64 v37; // rdx
  int v38; // eax
  unsigned int v39; // edi
  __int64 *v40; // rax
  __int64 v41; // rdx
  int v42; // eax
  __int64 *v43; // rax
  __int64 v44; // rax
  int v45; // eax
  __int64 v46; // [rsp+80h] [rbp+8h] BYREF
  char v47; // [rsp+90h] [rbp+18h] BYREF
  unsigned __int8 *v48; // [rsp+98h] [rbp+20h]

  v4 = 0i64;
  *a4 = 0;
  *((_BYTE *)this + 1282) = 0;
  v47 = 0;
  if ( !a3 || !a2 )
    return 87i64;
  updated = 0;
  v10 = *((_QWORD *)this + 10);
  if ( !v10 )
    return 1359i64;
  v11 = a2 + 4;
  v12 = *((_DWORD *)this + 17);
  v13 = a3 - 4;
  v14 = *a2 << 8;
  v15 = v14 | (unsigned __int8)v12;
  v48 = v11;
  LODWORD(v46) = v13;
  if ( v15 == 256 )
    goto LABEL_5;
  if ( v15 > 0x143C )
  {
    if ( v15 > 0x144F )
    {
      if ( v15 == 6148 || v15 > 0x184D && v15 <= 0x184F )
      {
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 56i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
          v11 = v48;
          v13 = v46;
        }
        updated = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ParseKeyUpdate((__int64)this + 1288, v11, v13);
        if ( !updated )
        {
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 57i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
          }
          v43 = (__int64 *)*((_QWORD *)this + 1);
          if ( v43 )
            v4 = *v43;
          updated = UpdateTrafficSecretAndDeriveNewKey(
                      v4,
                      (unsigned __int64 *)this + 135,
                      (unsigned __int64 *)this + 18,
                      (unsigned __int64 *)this + 22);
          if ( !updated && *((_DWORD *)this + 17) != 79 )
            *((_DWORD *)this + 17) = 4;
        }
        return updated;
      }
      goto LABEL_113;
    }
    if ( v15 == 5199 )
    {
      v24 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control )
        return updated;
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 53i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
        v24 = WPP_GLOBAL_Control;
      }
      if ( v24 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v24 + 28) & 4) == 0 )
        return updated;
      v25 = 54i64;
      goto LABEL_41;
    }
    v27 = v15 - 5182;
    if ( v27 && v27 != 8 )
      goto LABEL_113;
  }
  else if ( v15 != 5180 )
  {
    if ( v15 > 0xB4F )
    {
      v26 = v15 - 3900;
      if ( !v26 )
      {
        v22 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 51i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
          v22 = WPP_GLOBAL_Control;
          v11 = v48;
          v13 = v46;
        }
        if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) != 4 )
        {
          updated = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ParseCertificateVerify(
                      (__int64)this + 1288,
                      (__int64)v11,
                      v13);
          if ( !updated )
          {
            updated = DoCertificateMapping(this);
            if ( !updated )
              *((_DWORD *)this + 17) = 62;
          }
          return updated;
        }
        if ( v22 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v22 + 28) & 1) == 0 )
          return (unsigned int)-2146893018;
        v23 = 52i64;
        goto LABEL_25;
      }
      if ( v26 != 19 )
      {
LABEL_113:
        *((_DWORD *)this + 17) = 96;
        *((_WORD *)this + 48) = 2562;
        if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          WPP_SF_DD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x3Au,
            (__int64)&WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids,
            v14,
            96);
        return (unsigned int)-2146893018;
      }
      v24 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control )
        return updated;
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 49i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
        v24 = WPP_GLOBAL_Control;
      }
      if ( v24 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v24 + 28) & 4) == 0 )
        return updated;
      v25 = 50i64;
    }
    else
    {
      if ( v15 != 2895 )
      {
        v20 = v15 - 327;
        if ( !v20 )
        {
LABEL_5:
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 43i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
            v12 = *((_DWORD *)this + 17);
          }
          v16 = v12 == 71;
          *((_QWORD *)this + 17) |= 0x8000ui64;
          (*(void (__fastcall **)(CTls13ServerContext *))(*(_QWORD *)this + 240i64))(this);
          v17 = *(_QWORD *)this;
          *((_QWORD *)this + 11) = 0i64;
          LOBYTE(v18) = 1;
          updated = (*(__int64 (__fastcall **)(CTls13ServerContext *, unsigned __int8 *, _QWORD, __int64, char *))(v17 + 536))(
                      this,
                      a2,
                      a3,
                      v18,
                      &v47);
          if ( !updated )
          {
            v44 = *((_QWORD *)this + 17);
            if ( (v44 & 0x40000) == 0 )
            {
              *((_BYTE *)this + 552) = 0;
              *((_QWORD *)this + 17) = v44 & 0xFFFFFFFFFFBFFFFFui64;
              if ( v16 )
              {
                *((_DWORD *)this + 17) = 99;
              }
              else
              {
                v45 = 93;
                if ( *((_DWORD *)this + 17) == 71 )
                  v45 = 98;
                *((_DWORD *)this + 17) = v45;
              }
            }
          }
          return updated;
        }
        v21 = v20 - 2559;
        if ( !v21 || v21 == 8 )
        {
          v22 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
          {
            WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 46i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
            v22 = WPP_GLOBAL_Control;
            v11 = v48;
            v13 = v46;
          }
          if ( *(_DWORD *)(*((_QWORD *)this + 1) + 48i64) == 4 )
          {
            if ( v22 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v22 + 28) & 1) == 0 )
              return (unsigned int)-2146893018;
            v23 = 47i64;
          }
          else
          {
            if ( (*((_DWORD *)this + 34) & 0x100i64) != 0 && (*((_DWORD *)this + 17) != 78 || *((_BYTE *)this + 1232)) )
            {
              updated = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ParseCertificateMsg(
                          (__int64)this + 1288,
                          v11,
                          v13);
              if ( !updated )
                *((_DWORD *)this + 17) = 60;
              return updated;
            }
            if ( v22 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v22 + 28) & 1) == 0 )
              return (unsigned int)-2146893018;
            v23 = 48i64;
          }
LABEL_25:
          WPP_SF_(*((_QWORD *)v22 + 2), v23, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
          return (unsigned int)-2146893018;
        }
        goto LABEL_113;
      }
      v24 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == (CCipherMill *)&WPP_GLOBAL_Control )
        return updated;
      if ( (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 44i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
        v24 = WPP_GLOBAL_Control;
      }
      if ( v24 == (CCipherMill *)&WPP_GLOBAL_Control || (*((_BYTE *)v24 + 28) & 4) == 0 )
        return updated;
      v25 = 45i64;
    }
LABEL_41:
    WPP_SF_(*((_QWORD *)v24 + 2), v25, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
    return updated;
  }
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 55i64, &WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids);
    v12 = *((_DWORD *)this + 17);
    v11 = a2 + 4;
    v13 = a3 - 4;
  }
  if ( v12 == 60 && (*((_DWORD *)this + 34) & 0x100i64) != 0 && !*((_BYTE *)this + 552) )
    return (unsigned int)-2146893018;
  updated = CTls13Handshake<CTls13ServerContext,CTls13ExtServer>::ParseFinished((__int64)this + 1288, v11, v13);
  if ( updated )
    return updated;
  updated = (*(__int64 (__fastcall **)(CTls13ServerContext *, unsigned __int8 *, _QWORD, _QWORD))(*(_QWORD *)this
                                                                                                + 504i64))(
              this,
              a2,
              a3,
              0i64);
  if ( updated )
    return updated;
  *a4 = 1;
  if ( (*((_DWORD *)this + 34) & 0x2008000) != 33587200i64 || (*(_BYTE *)(v10 + 156) & 0x20) != 0 )
  {
    v33 = *(_QWORD *)this;
    *((_BYTE *)this + 1216) = 3;
    (*(void (__fastcall **)(CTls13ServerContext *))(v33 + 448))(this);
  }
  else
  {
    if ( !*((_QWORD *)this + 11) )
      return 1359;
    v28 = (__int64 *)*((_QWORD *)this + 1);
    v46 = 0i64;
    if ( v28 )
      v29 = *v28;
    else
      v29 = 0i64;
    v30 = SslExpandResumptionMasterKey(v29, *((_QWORD *)this + 134), *((_QWORD *)this + 74), &v46, 0i64, 0);
    updated = v30;
    if ( v30 )
    {
      CSslContext::SetError((__int64)this, 613, v30);
      return updated;
    }
    RtlAcquireResourceExclusive((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64), 1u);
    v31 = *((_QWORD *)this + 11);
    v32 = *(_QWORD *)(v31 + 16);
    if ( v32 )
    {
      SslFreeObject(v32, 0i64);
      v31 = *((_QWORD *)this + 11);
    }
    *(_QWORD *)(v31 + 16) = v46;
    RtlReleaseResource((PRTL_RESOURCE)(*((_QWORD *)this + 11) + 72i64));
    *((_DWORD *)this + 17) = 102;
  }
  if ( !*((_BYTE *)this + 1233) )
  {
    *((_WORD *)this + 16) |= 0xAu;
    v34 = *((_QWORD *)this + 18);
    if ( v34 )
      SslFreeObject(v34, 0i64);
    *((_QWORD *)this + 18) = *((_QWORD *)this + 20);
    *((_QWORD *)this + 20) = 0i64;
    if ( !*((_BYTE *)this + 233) )
      *((_QWORD *)this + 22) = 0i64;
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 60i64, &WPP_906ebfdb0b6e356d5c7c2dbe304d0682_Traceguids);
  }
  v35 = *(_QWORD *)this;
  updated = 0;
  *((_BYTE *)this + 1233) = 1;
  if ( (*(unsigned __int8 (__fastcall **)(CTls13ServerContext *))(v35 + 384))(this) )
    return updated;
  v36 = (__int64 *)*((_QWORD *)this + 1);
  if ( v36 )
    v37 = *v36;
  else
    v37 = 0i64;
  v38 = CTls13Context::PopulateSecTrafficSecret((__int64)this + 1000, v37, 1, 3u, (__int64)v36, 0, 0);
  v39 = v38;
  if ( !v38 )
  {
    v40 = (__int64 *)*((_QWORD *)this + 1);
    if ( v40 )
      v41 = *v40;
    else
      v41 = 0i64;
    v42 = CTls13Context::PopulateSecTrafficSecret((__int64)this + 1000, v41, 0, 3u, (__int64)v40, 0, 0);
    updated = v42;
    if ( v42 )
      CSslContext::SetError((__int64)this, 611, v42);
    return updated;
  }
  CSslContext::SetError((__int64)this, 612, v38);
  return v39;
}
// 180022D1E: variable 'v18' is possibly undefined
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180098450: using guessed type __int64 __fastcall SslExpandResumptionMasterKey(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098570: using guessed type __int64 __fastcall SslFreeObject(_QWORD, _QWORD);

//----- (0000000180022D60) ----------------------------------------------------
struct _SLIST_ENTRY *__fastcall CSslLookaside::Allocate(CSslLookaside *this)
{
  SIZE_T v2; // rcx
  struct _SLIST_ENTRY *result; // rax
  PSLIST_ENTRY v4; // rax
  unsigned int v5; // ecx
  PSLIST_ENTRY v6; // rdi

  if ( *((_BYTE *)this + 32) )
  {
    v4 = InterlockedPopEntrySList((PSLIST_HEADER)this + 1);
    v5 = *((_DWORD *)this + 9);
    v6 = v4;
    if ( v4 )
    {
      memset_0(&v4[1], 0, v5);
      _InterlockedDecrement((volatile signed __int32 *)this + 13);
    }
    else
    {
      result = (struct _SLIST_ENTRY *)SPExternalAlloc(v5 + 16);
      v6 = result;
      if ( !result )
        return result;
      _InterlockedIncrement((volatile signed __int32 *)this + 17);
    }
    _InterlockedIncrement((volatile signed __int32 *)this + 15);
    return v6 + 1;
  }
  else
  {
    v2 = *((unsigned int *)this + 9);
    if ( LsaTable )
      return (struct _SLIST_ENTRY *)(*(__int64 (__fastcall **)(SIZE_T))(LsaTable + 40))(v2);
    else
      return (struct _SLIST_ENTRY *)LocalAlloc(0x40u, v2);
  }
}
// 180080FD8: using guessed type __int64 (__fastcall *_guard_xfg_dispatch_icall_fptr)(_QWORD, _QWORD, _QWORD);
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180022DB0) ----------------------------------------------------
void __fastcall CSsl3TlsServerContext::GetEndpointBindings(
        CSsl3TlsServerContext *this,
        unsigned __int8 **a2,
        unsigned int *a3)
{
  __int64 v6; // rax

  *a2 = 0i64;
  *a3 = 0;
  if ( (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 248i64))(this) )
  {
    v6 = (*(__int64 (__fastcall **)(CSsl3TlsServerContext *))(*(_QWORD *)this + 248i64))(this);
    *a2 = *(unsigned __int8 **)(v6 + 464);
    *a3 = *(_DWORD *)(v6 + 472);
  }
}

//----- (0000000180022E40) ----------------------------------------------------
void __fastcall CSslLookaside::Deallocate(CSslLookaside *this, struct _SLIST_ENTRY *a2)
{
  if ( *((_BYTE *)this + 32) )
  {
    InterlockedPushEntrySList((PSLIST_HEADER)this + 1, a2 - 1);
    _InterlockedIncrement((volatile signed __int32 *)this + 13);
  }
  else if ( LsaTable )
  {
    (*(void (__fastcall **)(struct _SLIST_ENTRY *))(LsaTable + 48))(a2);
  }
  else
  {
    LocalFree(a2);
  }
}
// 180092620: using guessed type __int64 LsaTable;

//----- (0000000180022E90) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::PreparseMessage(CSsl3TlsServerContext *this, struct SPBuffer *a2)
{
  int v2; // eax
  unsigned int v3; // ebx
  __int64 v7; // r8
  bool v8; // al
  int v9; // ecx

  v2 = *((_DWORD *)this + 17);
  v3 = 0;
  if ( v2 == 4 )
  {
    if ( *((_DWORD *)a2 + 1) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 28i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
      *((_DWORD *)this + 17) = 76;
    }
    return v3;
  }
  if ( v2 != 20 )
    return v3;
  if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 29i64, &WPP_095c39149c3f336b5b94efe855075ae2_Traceguids);
  v7 = *((unsigned int *)a2 + 1);
  if ( (unsigned int)v7 >= 3 )
  {
    v3 = CSsl3TlsServerContext::DigestUnifiedHello(this, *((unsigned __int8 **)a2 + 1), v7);
    v8 = IsFatalError(v3);
    v9 = 93;
    if ( v8 )
      v9 = 96;
    *((_DWORD *)this + 17) = v9;
    return v3;
  }
  *((_DWORD *)a2 + 1) = 3;
  return 2148074264i64;
}
// 180041CB0: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);

//----- (0000000180022EE0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::GetPeerCertValidationResults(
        CSsl3TlsServerContext *this,
        int *a2,
        unsigned int *a3)
{
  __int64 v3; // rcx
  __int64 result; // rax

  if ( !a2 || !a3 )
    return 87i64;
  if ( *(_QWORD *)(*((_QWORD *)this + 10) + 848i64) )
  {
    v3 = *((_QWORD *)this + 124);
    *a2 = *(_DWORD *)(v3 + 216);
    *a3 = *(_DWORD *)(v3 + 220);
    return 0i64;
  }
  else
  {
    result = 0i64;
    *a2 = 0;
    *a3 = 0;
  }
  return result;
}

//----- (0000000180022F30) ----------------------------------------------------
bool __fastcall CSessionCacheServerItem::IsEntryAMatch(
        CSessionCacheServerItem *this,
        struct _LUID *a2,
        const unsigned __int16 *a3,
        struct CRED_THUMBPRINT *a4,
        unsigned int a5)
{
  return (*((_DWORD *)this + 42) & a5) != 0
      && *(_DWORD *)a4 == *((_DWORD *)this + 47)
      && *((_DWORD *)a4 + 1) == *((_DWORD *)this + 48);
}

//----- (0000000180022F70) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::PreparseMessage(CTls13ServerContext *this, struct SPBuffer *a2)
{
  unsigned int v2; // ebx

  v2 = 0;
  if ( a2 && this )
  {
    if ( *((_DWORD *)this + 17) == 4 && *((_DWORD *)a2 + 1) )
    {
      if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0 )
        WPP_SF_s(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x12u,
          (__int64)&WPP_d144303c37633bde7ff6f9c18fccf166_Traceguids,
          "server");
      *((_DWORD *)this + 17) = 78;
    }
  }
  else
  {
    return (unsigned int)-2146892963;
  }
  return v2;
}

//----- (0000000180022FB0) ----------------------------------------------------
CTls13Record *__fastcall CTls13Record::`vector deleting destructor'(CTls13Record *this, char a2)
{
  *(_QWORD *)this = &CTlsRecord::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 18007D3F0: using guessed type void *CTlsRecord::`vftable';

//----- (0000000180022FF0) ----------------------------------------------------
__int64 __fastcall CTls13ServerContext::SetTrafficSecretsBuffers(
        CTls13ServerContext *this,
        struct _SecBufferDesc *const a2,
        char a3,
        char a4)
{
  unsigned int v4; // r10d
  char *v8; // r8
  unsigned int v9; // edx
  unsigned __int8 v10; // di
  PSecBuffer pBuffers; // rcx
  __int64 v12; // rax

  v4 = 0;
  if ( a3 )
    return v4;
  if ( !a2 )
    return (unsigned int)-2146892963;
  v8 = (char *)this + 1168;
  v9 = 0;
  memset((char *)this + 1168, 0, 0x20ui64);
  *((_BYTE *)this + 1200) = 0;
  v10 = 0;
  pBuffers = a2->pBuffers;
  if ( pBuffers < &pBuffers[a2->cBuffers] )
  {
    while ( 1 )
    {
      if ( v10 >= 4u )
      {
LABEL_20:
        *((_BYTE *)this + 1201) = 0;
        return v9;
      }
      if ( (pBuffers->BufferType & 0xFFFFFFF) == 28 )
      {
        if ( a4 )
        {
          pBuffers->pvBuffer = 0i64;
          pBuffers->cbBuffer = 0;
        }
        else
        {
          if ( !pBuffers->pvBuffer )
          {
            v9 = 14;
            goto LABEL_14;
          }
          if ( pBuffers->cbBuffer < 0x1C0 )
          {
            pBuffers->cbBuffer = 448;
            goto LABEL_11;
          }
        }
        v12 = v10++;
        *((_QWORD *)this + v12 + 146) = pBuffers;
      }
LABEL_11:
      if ( ++pBuffers >= &a2->pBuffers[(unsigned __int64)a2->cBuffers] )
      {
        if ( v10 < 4u )
          break;
        goto LABEL_20;
      }
    }
  }
  v9 = -2146892949;
LABEL_14:
  memset(v8, 0, 0x20ui64);
  *((_BYTE *)this + 1200) = 0;
  return v9;
}

//----- (0000000180023030) ----------------------------------------------------
bool __fastcall CTls13ServerContext::UseSchannelRecordLayer(CTls13ServerContext *this)
{
  return (*((_QWORD *)this + 17) & 0x100000000i64) == 0;
}

//----- (0000000180023050) ----------------------------------------------------
void __fastcall CSessionCacheServerItem::CompleteCacheAdd(
        CSessionCacheServerItem *this,
        struct CSessionCacheManager *a2,
        struct CSslContext *a3)
{
  __int64 v3; // rax
  __int64 v4; // rdx
  __int64 v5; // rax

  v3 = *((_QWORD *)a3 + 10);
  if ( v3 && (*(_BYTE *)(v3 + 156) & 0x20) != 0 )
    *((_WORD *)this + 118) = 256;
  v4 = *((_QWORD *)a3 + 1);
  *((_QWORD *)this + 22) = v4;
  *((_DWORD *)this + 46) = *((_DWORD *)a3 + 4);
  v5 = *(_QWORD *)(v4 + 848);
  if ( v5 )
    _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v5 + 16) + 12i64));
  _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(v4 + 856) + 12i64));
}

//----- (00000001800230B0) ----------------------------------------------------
__int64 __fastcall CSsl3TlsServerContext::Initialize(CSsl3TlsServerContext *this)
{
  int v2; // edi
  char *v4; // rax
  char *v5; // rdx
  _QWORD *v6; // rcx
  _QWORD *v7; // rax
  _DWORD *v8; // rax
  __int64 v9; // rcx
  DTlsMsgMgr *v10; // rcx

  v2 = g_fEnableHelloVerifyRequest;
  if ( !*((_BYTE *)this + 233) )
    return 0i64;
  *((_QWORD *)this + 23) = g_fEnableHelloVerifyRequest != 0;
  v4 = (char *)operator new(0x60ui64);
  v5 = v4;
  if ( v4 )
  {
    *((_DWORD *)v4 + 2) = 10;
    *((_QWORD *)v4 + 11) = this;
    *((_DWORD *)v4 + 1) = 0;
    *(_DWORD *)v4 = v2 != 0;
    *((_QWORD *)v4 + 4) = v4 + 24;
    *((_QWORD *)v4 + 3) = v4 + 24;
    v6 = v4 + 40;
    v7 = v4 + 56;
    v6[1] = v6;
    *v6 = v6;
    v7[1] = v7;
    *v7 = v7;
    *((_QWORD *)v5 + 10) = v5 + 72;
    *((_QWORD *)v5 + 9) = v5 + 72;
  }
  else
  {
    v5 = 0i64;
  }
  *((_QWORD *)this + 72) = v5;
  if ( v5 )
  {
    v8 = operator new(0x30ui64);
    if ( v8 )
    {
      v9 = *((_QWORD *)this + 72);
      v8[2] = 0;
      v8[3] = 0;
      *((_QWORD *)v8 + 2) = 0i64;
      *((_QWORD *)v8 + 3) = 0i64;
      v8[8] = 0;
      *(_QWORD *)v8 = v9;
      *((_QWORD *)v8 + 5) = this;
      v8[9] = *((__int16 *)this + 96);
    }
    v10 = (DTlsMsgMgr *)*((_QWORD *)this + 72);
    *((_QWORD *)this + 73) = v8;
    if ( v8 )
    {
      *((_QWORD *)this + 28) = v10;
      if ( v2 )
        ++*((_WORD *)this + 110);
      return 0i64;
    }
    if ( v10 )
      DTlsMsgMgr::`scalar deleting destructor'(v10);
  }
  return 14i64;
}
// 1800919A4: using guessed type int g_fEnableHelloVerifyRequest;

//----- (00000001800230F0) ----------------------------------------------------
void __fastcall CSsl3TlsServerContext::ClearCacheItem(CSsl3TlsServerContext *this)
{
  CSessionCacheTable **v2; // rcx

  v2 = (CSessionCacheTable **)*((_QWORD *)this + 124);
  if ( v2 )
  {
    CSessionCacheTable::DereferenceCacheItemInternal(v2[28], (struct CSessionCacheItem *)v2, 1, 0);
    *((_QWORD *)this + 124) = 0i64;
  }
}

//----- (0000000180023120) ----------------------------------------------------
__int64 __fastcall CSslLookaside::Allocate(CSslLookaside *this, __int64 a2)
{
  if ( a2 == *((_DWORD *)this + 9) )
    return (*(__int64 (__fastcall **)(CSslLookaside *))(*(_QWORD *)this + 16i64))(this);
  else
    return 0i64;
}

//----- (0000000180023150) ----------------------------------------------------
void __fastcall FlushTimerCallbackUserMode(PTP_CALLBACK_INSTANCE Instance, __int64 Context, PTP_TIMER Timer)
{
  if ( *(_BYTE *)(Context + 356) )
  {
    *(_BYTE *)(Context + 356) = 0;
    LookUpTableFlushComplete(Context);
  }
  else
  {
    LookUpTableFlushPartial(Context);
  }
  if ( *(_DWORD *)(Context + 256) )
    EnableFlushTimer(*(struct _TP_TIMER **)(Context + 344), *(_DWORD *)(Context + 352));
}

//----- (0000000180023188) ----------------------------------------------------
void __fastcall LookUpTableFlushPartial(__int64 a1)
{
  unsigned int v1; // esi
  unsigned int v3; // ebp
  unsigned int v4; // ebx

  v1 = 0;
  if ( *(_DWORD *)(a1 + 256) )
  {
    v3 = *(_DWORD *)(a1 + 260);
    v4 = v3;
    do
    {
      if ( *(_QWORD *)(a1 + 8i64 * v4) )
        v1 += FlushLookUpTableBucket(a1, v4);
      v4 = ((_BYTE)v4 + 1) & 0x1F;
    }
    while ( v4 != v3 && v1 < 0x10 );
    *(_DWORD *)(a1 + 260) = v4;
    UpdateInternalStatsOnFlush(a1, v1);
  }
}

//----- (0000000180023204) ----------------------------------------------------
__int64 __fastcall FlushLookUpTableBucket(__int64 a1, unsigned int a2)
{
  __int64 v2; // rbx
  RTL_SRWLOCK *v4; // rdi
  const EVENT_DESCRIPTOR *v5; // rsi
  unsigned int v6; // eax
  unsigned int v7; // ebx

  v2 = a2;
  if ( !*(_QWORD *)(a1 + 8i64 * a2) )
    return 0i64;
  v4 = (RTL_SRWLOCK *)(a1 + 264);
  AcquireSRWLockExclusive((PSRWLOCK)(a1 + 264));
  v5 = *(const EVENT_DESCRIPTOR **)(a1 + 8 * v2);
  *(_QWORD *)(a1 + 8 * v2) = 0i64;
  v6 = FlattenEventEntryTree((__int64)v5);
  *(_DWORD *)(a1 + 256) -= v6;
  v7 = v6;
  ReleaseSRWLockExclusive(v4);
  FlushEventEntryList(*(_QWORD *)(*(_QWORD *)(a1 + 328) + 32i64), v5);
  return v7;
}

//----- (000000018002329C) ----------------------------------------------------
void __fastcall FlushEventEntryList(REGHANDLE RegHandle, PCEVENT_DESCRIPTOR EventDescriptor)
{
  PCEVENT_DESCRIPTOR v2; // rdi
  int v4; // edx
  __int64 v5; // rcx
  const EVENT_DESCRIPTOR *Keyword; // rbx

  if ( EventDescriptor )
  {
    v2 = EventDescriptor;
    do
    {
      v4 = 2;
      if ( (unsigned int)BYTE5(v2[2].Keyword) + 2 > 2 )
      {
        v5 = 32i64;
        do
        {
          v5 += 16i64;
          ++v4;
          *(_BYTE *)(v5 + *(_QWORD *)&v2[1].Id - 3) = 0;
        }
        while ( v4 < BYTE5(v2[2].Keyword) + 2 );
      }
      EventWriteTransfer_0(RegHandle, v2, 0i64, 0i64, BYTE4(v2[2].Keyword), *(PEVENT_DATA_DESCRIPTOR *)&v2[1].Id);
      Keyword = (const EVENT_DESCRIPTOR *)v2[1].Keyword;
      DestroyEventEntry((__int64)v2);
      v2 = Keyword;
    }
    while ( Keyword );
  }
}

//----- (0000000180023334) ----------------------------------------------------
void __fastcall DestroyEventEntry(__int64 a1)
{
  void *v1; // rbx
  HANDLE ProcessHeap; // rax

  if ( a1 )
  {
    v1 = *(void **)(a1 + 16);
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v1);
  }
}

//----- (0000000180023370) ----------------------------------------------------
__int64 __fastcall FlattenEventEntryTree(__int64 a1)
{
  __int64 *v1; // rdx
  __int64 result; // rax
  __int64 v3; // r9
  __int64 *v4; // r8
  __int64 i; // rcx
  __int64 v6; // [rsp+8h] [rbp+8h] BYREF

  v6 = a1;
  v1 = &v6;
  result = 0i64;
  while ( a1 )
  {
    v3 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = 0i64;
    v1 = (__int64 *)(*v1 + 24);
    v4 = v1;
    for ( i = *v1; i; i = *(_QWORD *)(i + 32) )
      v4 = (__int64 *)(i + 32);
    *v4 = v3;
    result = (unsigned int)(result + 1);
    a1 = *v1;
  }
  return result;
}

//----- (00000001800233B8) ----------------------------------------------------
void __fastcall UpdateInternalStatsOnFlush(__int64 a1, unsigned int a2)
{
  __int64 *v2; // r8
  __int64 v3; // rax

  if ( a2 )
  {
    v2 = (__int64 *)(a1 + 280);
    if ( *(_DWORD *)(a1 + 296) > a2 || (v3 = *v2) == 0 )
    {
      v3 = *v2;
      *(_DWORD *)(a1 + 296) = a2;
    }
    if ( *(_DWORD *)(a1 + 292) < a2 )
      *(_DWORD *)(a1 + 292) = a2;
    *v2 = v3 + 1;
    *(_QWORD *)(a1 + 272) += a2;
  }
}

//----- (0000000180023408) ----------------------------------------------------
void __fastcall CCipherMill::ReferenceProvider(CCipherMill *this, unsigned __int64 a2, unsigned __int64 *a3)
{
  CCipherMill *v5; // rcx

  RtlAcquireResourceShared(&Resource, 1u);
  if ( a2 )
  {
    if ( *a3 != a2 )
    {
      CCipherMill::DeferenceProvider(v5, a3);
      if ( (int)SslIncrementProviderReferenceCount(a2) >= 0 )
      {
        _InterlockedIncrement(&dword_1800925A0);
        *a3 = a2;
      }
    }
  }
  RtlReleaseResource(&Resource);
}
// 18002343A: variable 'v5' is possibly undefined
// 1800925A0: using guessed type int dword_1800925A0;
// 1800984E8: using guessed type __int64 __fastcall SslIncrementProviderReferenceCount(_QWORD);

//----- (0000000180023480) ----------------------------------------------------
void __fastcall CCipherMill::DeferenceProvider(CCipherMill *this, unsigned __int64 *a2)
{
  if ( a2 )
  {
    if ( *a2 )
    {
      SslDecrementProviderReferenceCount();
      _InterlockedDecrement(&dword_1800925A0);
      *a2 = 0i64;
    }
  }
}
// 1800925A0: using guessed type int dword_1800925A0;
// 180098518: using guessed type __int64 SslDecrementProviderReferenceCount(void);

//----- (00000001800234BC) ----------------------------------------------------
void __fastcall EnableFlushTimer(struct _TP_TIMER *a1, unsigned int a2)
{
  struct _FILETIME v2; // rdx
  struct _FILETIME pftDueTime; // [rsp+40h] [rbp+8h] BYREF

  if ( a1 )
  {
    v2 = (struct _FILETIME)(-10000i64 * a2);
    if ( !dword_180092DE8 )
    {
      pftDueTime = v2;
      SetThreadpoolTimer(a1, &pftDueTime, 0, 0x1388u);
    }
  }
}
// 180092DE8: using guessed type int dword_180092DE8;

//----- (0000000180023520) ----------------------------------------------------
__int64 LoadSslRegistryOptions(void)
{
  NTSTATUS v0; // eax
  CCipherMill *v1; // rcx

  qword_180092680 = (__int64)CreateEventW(0i64, 0, 0, 0i64);
  qword_180092698 = (__int64)SslWatchParamKey;
  qword_180092690 = (__int64)L"System\\CurrentControlSet\\Control\\SecurityProviders\\Schannel";
  qword_1800926A8 = (__int64)CreateEventW(0i64, 0, 0, 0i64);
  qword_1800926C0 = (__int64)FipsWatchParamKey;
  qword_1800926B8 = (__int64)L"System\\CurrentControlSet\\Control\\Lsa";
  qword_1800926D0 = (__int64)CreateEventW(0i64, 0, 0, 0i64);
  qword_1800926E8 = (__int64)UserMappingsWatchParamKey;
  qword_1800926E0 = (__int64)L"Software\\Policies\\Microsoft\\Cryptography\\Configuration\\SSL\\00010002";
  qword_180092658 = (__int64)CreateEventW(0i64, 0, 0, 0i64);
  qword_180092670 = (__int64)DefaultEccCurveWatchParamKey;
  qword_180092668 = (__int64)L"System\\CurrentControlSet\\Control\\Cryptography\\Configuration\\Local\\SSL\\00010002";
  SslWatchParamKey(g_BaseSslRegOptions);
  FipsWatchParamKey(g_FipsRegOptions, 1);
  UserMappingsWatchParamKey(&g_UserMappingRegOptions);
  DefaultEccCurveWatchParamKey(&g_DefaultEccCurveRegOptions, 1);
  v0 = BCryptRegisterConfigChangeNotify(&g_hBcryptEvent);
  if ( v0 < 0 )
  {
    if ( WPP_GLOBAL_Control != (CCipherMill *)&WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 1) != 0 )
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        10i64,
        &WPP_652d1bd98c7033c24f7b4105215d66be_Traceguids,
        (unsigned int)v0);
    return 0i64;
  }
  else
  {
    RtlRegisterWait(&g_hBcryptWait, g_hBcryptEvent, (WAITORTIMERCALLBACKFUNC)WatchBcryptEvent, 0i64, 0xFFFFFFFF, 0);
    CCipherMill::BuildCipherMill(v1);
    return 1i64;
  }
}
// 180023689: variable 'v1' is possibly undefined
// 180041CDC: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800817E0: using guessed type wchar_t aSystemCurrentc_1[37];
// 180092658: using guessed type __int64 qword_180092658;
// 180092668: using guessed type __int64 qword_180092668;
// 180092670: using guessed type __int64 qword_180092670;
// 180092680: using guessed type __int64 qword_180092680;
// 180092690: using guessed type __int64 qword_180092690;
// 180092698: using guessed type __int64 qword_180092698;
// 1800926A8: using guessed type __int64 qword_1800926A8;
// 1800926B8: using guessed type __int64 qword_1800926B8;
// 1800926C0: using guessed type __int64 qword_1800926C0;
// 1800926C8: using guessed type HKEY g_UserMappingRegOptions;
// 1800926D0: using guessed type __int64 qword_1800926D0;
// 1800926E0: using guessed type __int64 qword_1800926E0;
// 1800926E8: using guessed type __int64 qword_1800926E8;

//----- (00000001800236B0) ----------------------------------------------------
void __fastcall DefaultEccCurveWatchParamKey(void *a1, char a2)
{
  BYTE *lpData; // rbx
  CCipherMill *v5; // rcx
  HLOCAL v6; // rdi
  DWORD cbData; // [rsp+40h] [rbp+8h] BYREF
  DWORD Type; // [rsp+50h] [rbp+18h] BYREF

  cbData = 0;
  if ( WatchParamKeyHelper((char *)a1) )
    goto LABEL_10;
  if ( RegQueryValueExW(*((HKEY *)a1 + 2), L"EccCurves", 0i64, &Type, 0i64, &cbData) )
    goto LABEL_10;
  if ( !cbData )
    goto LABEL_10;
  if ( Type != 7 )
    goto LABEL_10;
  lpData = (BYTE *)LocalAlloc(0x40u, cbData);
  if ( !lpData )
    goto LABEL_10;
  if ( RegQueryValueExW(*((HKEY *)a1 + 2), L"EccCurves", 0i64, &Type, lpData, &cbData) )
    goto LABEL_15;
  v6 = g_pbDefaultEccCurveList;
  if ( g_pbDefaultEccCurveList && g_cbDefaultEccCurveList )
  {
    if ( g_cbDefaultEccCurveList != cbData || memcmp_0(g_pbDefaultEccCurveList, lpData, cbData) )
    {
      LocalFree(v6);
      goto LABEL_8;
    }
LABEL_15:
    LocalFree(lpData);
    goto LABEL_10;
  }
LABEL_8:
  g_cbDefaultEccCurveList = cbData;
  g_pbDefaultEccCurveList = lpData;
  if ( !a2 )
    CCipherMill::BuildCipherMill(v5);
LABEL_10:
  NotifyWNFConfigChangeEvent(WNF_SCH_ECC_RELOAD);
}
// 1800237B1: variable 'v5' is possibly undefined
// 180092790: using guessed type unsigned int g_cbDefaultEccCurveList;

//----- (00000001800237C0) ----------------------------------------------------
__int64 __fastcall CCipherMill::BuildCipherMill(CCipherMill *this)
{
  CCipherMill *v1; // rcx
  CCipherMill *v2; // rcx
  unsigned int ProviderList; // ebx
  CCipherMill *v5; // [rsp+40h] [rbp+8h] BYREF

  v5 = this;
  if ( !g_cCipherMill[0] )
    return 14i64;
  if ( CSessionCacheManager::m_pSessionCacheManager )
    CSessionCacheManager::PurgeCacheEntries(CSessionCacheManager::m_pSessionCacheManager, 0x30000u, 0i64, 0, 0i64);
  RtlAcquireResourceExclusive(&Resource, 1u);
  CCipherMill::ClearCipherMill(v1, 0);
  ProviderList = CCipherMill::LoadProviderList(v2, (unsigned __int8 *)&v5);
  if ( ProviderList
    || !hProvider
    && (ProviderList = NCryptOpenStorageProvider(&hProvider, L"Microsoft Software Key Storage Provider", 0)) != 0
    || (ProviderList = CCipherMill::LoadCipherTables((CCipherMill *)g_cCipherMill)) != 0 )
  {
    RtlReleaseResource(&Resource);
  }
  else
  {
    RtlReleaseResource(&Resource);
    if ( CSessionCacheManager::m_pSessionCacheManager )
      CSessionCacheManager::PurgeCacheEntries(CSessionCacheManager::m_pSessionCacheManager, 0x30000u, 0i64, 0, 0i64);
    if ( (_BYTE)v5 )
    {
      if ( CSslCredManager::m_pCredManager )
        CSslCredManager::NotifyProviderChange(CSslCredManager::m_pCredManager);
    }
  }
  return ProviderList;
}
// 1800237FE: variable 'v1' is possibly undefined
// 180023808: variable 'v2' is possibly undefined

//----- (00000001800238AC) ----------------------------------------------------
__int64 __fastcall CCipherMill::LoadCipherTables(CCipherMill *this)
{
  __int64 v1; // r14
  unsigned int v2; // ebx
  struct CCipherSuiteInfo *v3; // r13
  wchar_t *v4; // r15
  unsigned int v5; // r12d
  struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *v6; // rax
  unsigned int v7; // ebx
  unsigned int v8; // esi
  __int64 v9; // r15
  char *v10; // rdi
  char *v11; // rax
  __int64 v12; // rdx
  _OWORD *v13; // rcx
  _OWORD *v14; // rax
  __int128 v15; // xmm1
  __int64 v16; // rcx
  unsigned __int16 *v17; // rdi
  unsigned __int8 v18; // r10
  char v19; // r10
  int v20; // eax
  ULONG v21; // eax
  unsigned __int16 *v22; // rdi
  unsigned int v23; // r15d
  unsigned __int16 *v24; // rsi
  int *v25; // rax
  __int64 v26; // rcx
  wchar_t *v27; // rax
  __int64 v28; // rbx
  unsigned int v29; // r12d
  int *v30; // rdi
  unsigned int v31; // esi
  __int64 v32; // r15
  int v33; // ecx
  __int64 v34; // rcx
  unsigned int v35; // ebx
  void **v36; // r8
  unsigned int v37; // ebx
  wchar_t *v38; // rdi
  __int64 v39; // rsi
  unsigned int i; // r11d
  __int64 v41; // rcx
  __int64 v42; // rdx
  __int64 v43; // r9
  char *v44; // r10
  __int64 v45; // rax
  __int128 v46; // xmm0
  __int128 v47; // xmm1
  __int128 v48; // xmm0
  __int128 v49; // xmm1
  __int128 v50; // xmm0
  __int128 v51; // xmm1
  __int128 v52; // xmm0
  __int128 v53; // xmm1
  int v54; // eax
  __int64 v55; // r9
  __int64 v56; // rax
  __int128 v57; // xmm1
  char *v58; // rdx
  __int64 v59; // rax
  __int128 v60; // xmm1
  __int128 v61; // xmm0
  __int128 v62; // xmm1
  __int128 v63; // xmm0
  __int128 v64; // xmm1
  __int128 v65; // xmm0
  __int128 v66; // xmm1
  unsigned int j; // edi
  void *v68; // rcx
  int v69; // ecx
  int *v70; // rax
  __int64 v71; // rdx
  char *v72; // rax
  unsigned int v73; // eax
  PCRYPT_CONTEXT_FUNCTIONS v74; // rdx
  int v75; // r12d
  __int64 v76; // rbx
  const wchar_t **v77; // rsi
  unsigned int v78; // edi
  int v79; // eax
  CCipherMill *v80; // rcx
  __int16 v81; // cx
  __int64 v82; // rdx
  __int64 v83; // r8
  __int64 v84; // rax
  wchar_t *v85; // rdi
  __int64 v86; // rsi
  unsigned int v87; // ebx
  struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *v88; // r15
  unsigned int v89; // edi
  CCipherMill *v90; // rcx
  unsigned int v91; // esi
  unsigned __int8 *v92; // rbx
  int SupportedProvider; // eax
  struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *v94; // rdi
  __int64 v95; // rsi
  void *v96; // rcx
  unsigned int k; // edi
  void *v98; // rcx
  BOOLEAN pfEnabled[4]; // [rsp+48h] [rbp-C0h] BYREF
  unsigned int v101; // [rsp+4Ch] [rbp-BCh]
  unsigned int v102; // [rsp+50h] [rbp-B8h] BYREF
  unsigned int v103; // [rsp+54h] [rbp-B4h] BYREF
  ULONG v104; // [rsp+58h] [rbp-B0h] BYREF
  unsigned int v105; // [rsp+5Ch] [rbp-ACh]
  unsigned int v106[2]; // [rsp+60h] [rbp-A8h]
  PVOID pvBuffer; // [rsp+68h] [rbp-A0h] BYREF
  PCRYPT_CONTEXT_FUNCTIONS v108; // [rsp+70h] [rbp-98h] BYREF
  wchar_t *v109; // [rsp+78h] [rbp-90h] BYREF
  wchar_t *String1; // [rsp+80h] [rbp-88h] BYREF
  unsigned __int16 *v111; // [rsp+88h] [rbp-80h] BYREF
  wchar_t *v112; // [rsp+90h] [rbp-78h]
  struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *v113; // [rsp+98h] [rbp-70h]
  _OWORD *v114; // [rsp+A0h] [rbp-68h] BYREF
  struct CCipherSuiteInfo *v115; // [rsp+A8h] [rbp-60h] BYREF
  struct CCipherSuiteInfo *v116; // [rsp+B0h] [rbp-58h] BYREF
  ULONG pcbBuffer; // [rsp+B8h] [rbp-50h] BYREF
  ULONG v118; // [rsp+BCh] [rbp-4Ch] BYREF
  CMasterCipherInfo *v119; // [rsp+C0h] [rbp-48h] BYREF
  CMasterCipherInfo *v120; // [rsp+C8h] [rbp-40h] BYREF
  PCRYPT_CONTEXT_FUNCTIONS ppBuffer; // [rsp+D0h] [rbp-38h] BYREF
  char v122[784]; // [rsp+D8h] [rbp-30h] BYREF
  void *v123; // [rsp+3E8h] [rbp+2E0h] BYREF
  int v124[187]; // [rsp+3F0h] [rbp+2E8h] BYREF
  wchar_t v125[5]; // [rsp+6DEh] [rbp+5D6h] BYREF
  wchar_t Destination[64]; // [rsp+6E8h] [rbp+5E0h] BYREF
  wchar_t v127[64]; // [rsp+768h] [rbp+660h] BYREF

  LODWORD(v1) = 0;
  v2 = 0;
  v118 = 0;
  v101 = 0;
  v108 = 0i64;
  v104 = 0;
  v3 = 0i64;
  pvBuffer = 0i64;
  v4 = 0i64;
  v115 = 0i64;
  v5 = 0;
  v116 = 0i64;
  v105 = 0;
  v106[0] = 0;
  v120 = 0i64;
  v119 = 0i64;
  pcbBuffer = 0;
  ppBuffer = 0i64;
  v111 = 0i64;
  v103 = 0;
  pfEnabled[0] = 0;
  v112 = 0i64;
  String1 = 0i64;
  v102 = 0;
  memset_0(&v123, 0, 0x300ui64);
  memset_0(Destination, 0, sizeof(Destination));
  memset_0(v127, 0, sizeof(v127));
  ++dword_180092488;
  v114 = 0i64;
  dword_1800925D4 = 13;
  v6 = (struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *)SPExternalAlloc(0xC800u);
  v113 = v6;
  if ( !v6 )
  {
    v7 = 14;
    goto LABEL_167;
  }
  v8 = 0;
  if ( !qword_180092498 )
    goto LABEL_30;
  while ( 2 )
  {
    v109 = 0i64;
    v9 = v2;
    if ( v2 >= 0xC80 )
      goto LABEL_20;
    v10 = (char *)v6 + 16 * v2;
    do
    {
      if ( !(_BYTE)v1 )
      {
        v7 = SslEnumCipherSuitesEx(*(_QWORD *)&g_cCipherMill[8 * v8 + 128], 0i64, v10, &v109, 0);
        if ( v7 != -2146893783 )
        {
          LOBYTE(v1) = 0;
          goto LABEL_10;
        }
        LOBYTE(v1) = 1;
      }
      v7 = SslEnumCipherSuites(*(_QWORD *)&g_cCipherMill[8 * v8 + 128], 0i64, &v114, &v109, 0);
LABEL_10:
      *((_DWORD *)v10 + 2) = v8;
      v10[12] = v1;
      if ( v7 == -2146893782 )
        break;
      if ( v7 )
      {
        v16 = (__int64)v109;
        *(_QWORD *)v10 = 0i64;
        *((_DWORD *)v10 + 2) = 0;
        SslFreeBuffer(v16);
        goto LABEL_28;
      }
      if ( (_BYTE)v1 )
      {
        v11 = (char *)SPExternalAlloc(0x328u);
        *(_QWORD *)v10 = v11;
        if ( !v11 )
        {
          v7 = -2146893056;
          goto LABEL_159;
        }
        v12 = 5i64;
        v13 = v11 + 4;
        v14 = v114;
        do
        {
          *v13 = *v14;
          v13[1] = v14[1];
          v13[2] = v14[2];
          v13[3] = v14[3];
          v13[4] = v14[4];
          v13[5] = v14[5];
          v13[6] = v14[6];
          v13 += 8;
          v15 = v14[7];
          v14 += 8;
          *(v13 - 1) = v15;
          --v12;
        }
        while ( v12 );
        *v13 = *v14;
        v13[1] = v14[1];
        *((_DWORD *)v13 + 8) = *((_DWORD *)v14 + 8);
        SslFreeBuffer(v114);
        v114 = 0i64;
      }
      v10 += 16;
      ++v101;
    }
    while ( v101 < 0xC80 );
    if ( v109 )
      SslFreeBuffer(v109);
LABEL_20:
    if ( (unsigned int)SslEnumEccCurves(*(_QWORD *)&g_cCipherMill[8 * v8 + 128], &v124[6 * v8], &v124[6 * v8 - 2], 0i64) )
    {
      LOBYTE(v124[6 * v8 + 2]) = 0;
      v2 = v101;
      CCipherMill::EnumEccCurvesFromCipherToProvTable(
        0i64,
        (struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *)((char *)v113 + 16 * v9),
        v101 - v9,
        (unsigned int *)&v124[6 * v8],
        (struct _NCRYPT_SSL_ECC_CURVE **)&v124[6 * v8 - 2]);
    }
    else
    {
      LOBYTE(v124[6 * v8 + 2]) = 1;
      v2 = v101;
    }
    ++v8;
    LODWORD(v1) = 0;
    if ( v8 < qword_180092498 )
    {
      v6 = v113;
      continue;
    }
    break;
  }
  v4 = v112;
LABEL_30:
  word_1800925E8 = 0;
  word_18009260A = 0;
  if ( BCryptEnumContextFunctions(1u, L"SSL", 0x10003u, &pcbBuffer, &ppBuffer) < 0
    || !CTlsSignatureSuiteList::AddBCryptSignatureSuites(
          (CTlsSignatureSuiteList *)&word_1800925E8,
          (const unsigned __int16 **const)ppBuffer->rgpszFunctions,
          ppBuffer->cFunctions,
          1) )
  {
    word_1800925E8 = 0;
    v18 = 0;
    word_18009260A = 0;
    do
    {
      CTlsSignatureSuiteList::AddSignatureSuite((CTlsSignatureSuiteList *)&word_1800925E8, v18);
      v18 = v19 + 1;
    }
    while ( v18 < 0xCu );
    CTlsSignatureSuiteList::SetRsaSignatureFlags();
  }
  v20 = BCryptEnumContextFunctions(1u, L"SSL", 0x10002u, &v118, &v108);
  if ( v20 < 0 )
  {
    v21 = RtlNtStatusToDosError(v20);
    goto LABEL_150;
  }
  if ( !(unsigned int)IsCipherSuiteGroupPolicyEnabled()
    || (unsigned int)IsEccCurveGroupPolicyEnabled()
    || (GetSslEccCurveTypeOrderFromCipherSuiteList((__int64)v108, &String1, &v102),
        v5 = v102,
        v4 = String1,
        v112 = String1,
        !v102) )
  {
    v111 = 0i64;
    GetSslEccCurveOrder((BYTE **)&v111, (unsigned __int16 *)&v103);
    v22 = v111;
    if ( v111 )
    {
      v23 = qword_180092498;
      v103 = qword_180092498;
      v24 = v111;
      String1 = v111;
      if ( qword_180092498 )
      {
        v25 = v124;
        v26 = qword_180092498;
        do
        {
          LODWORD(v3) = *v25 + (_DWORD)v3;
          v25 += 6;
          --v26;
        }
        while ( v26 );
      }
      v27 = (wchar_t *)SPExternalAlloc(4 * (int)v3);
      v109 = v27;
      if ( v27 )
      {
        v28 = -1i64;
        do
          ++v28;
        while ( v22[v28] );
        if ( v28 )
        {
          while ( 1 )
          {
            v29 = 0;
            if ( v23 )
              break;
LABEL_63:
            if ( (_DWORD)v1 != (_DWORD)v3 )
            {
              v24 += v28 + 1;
              String1 = v24;
              v28 = -1i64;
              do
                ++v28;
              while ( v24[v28] );
              if ( v28 )
                continue;
            }
            goto LABEL_67;
          }
          v30 = v124;
          while ( 1 )
          {
            if ( *((_QWORD *)v30 - 1) )
            {
              v31 = 0;
              if ( *v30 )
              {
                while ( 1 )
                {
                  v32 = *((_QWORD *)v30 - 1) + 780i64 * v31;
                  if ( !wcsicmp(String1, (const wchar_t *)v32) )
                    break;
                  if ( ++v31 >= *v30 )
                    goto LABEL_59;
                }
                v33 = 0;
                if ( (_DWORD)v1 )
                {
                  while ( *(_DWORD *)&v109[2 * v33] != *(_DWORD *)(v32 + 772) )
                  {
                    if ( ++v33 >= (unsigned int)v1 )
                      goto LABEL_58;
                  }
                }
                else
                {
LABEL_58:
                  v34 = (unsigned int)v1;
                  LODWORD(v1) = v1 + 1;
                  *(_DWORD *)&v109[2 * v34] = *(_DWORD *)(v32 + 772);
                }
LABEL_59:
                v23 = v103;
              }
              if ( (_DWORD)v1 == (_DWORD)v3 )
                break;
            }
            ++v29;
            v30 += 6;
            if ( v29 >= v23 )
            {
              v24 = String1;
              goto LABEL_63;
            }
          }
LABEL_67:
          v27 = v109;
          v22 = v111;
        }
        v4 = v27;
        v112 = v27;
        v5 = v1;
        v102 = v1;
      }
      else
      {
        v4 = v112;
      }
      SPExternalFree(v22);
      LODWORD(v1) = 0;
    }
  }
  if ( !v4 || !v5 )
    goto LABEL_97;
  if ( BCryptGetFipsAlgorithmMode(pfEnabled) >= 0 && pfEnabled[0] )
  {
    FilterFipsEccCurves((__int64)v4, &v102);
    v5 = v102;
  }
  if ( v5 )
  {
    v35 = qword_180092498;
    if ( qword_180092498 )
    {
      v36 = &v123;
      v1 = qword_180092498;
      do
      {
        if ( *v36 )
        {
          v37 = 0;
          v38 = v4;
          v39 = v5;
          do
          {
            for ( i = 0; i < *((_DWORD *)v36 + 2); ++i )
            {
              v41 = (__int64)*v36 + 780 * i;
              if ( *(_DWORD *)v38 == *(_DWORD *)(v41 + 772) )
              {
                v42 = (__int64)*v36 + 780 * v37;
                if ( v37 != i )
                {
                  v43 = (__int64)*v36 + 780 * v37;
                  v44 = v122;
                  v45 = 6i64;
                  do
                  {
                    v46 = *(_OWORD *)v43;
                    v47 = *(_OWORD *)(v43 + 16);
                    v43 += 128i64;
                    *(_OWORD *)v44 = v46;
                    v48 = *(_OWORD *)(v43 - 96);
                    *((_OWORD *)v44 + 1) = v47;
                    v49 = *(_OWORD *)(v43 - 80);
                    *((_OWORD *)v44 + 2) = v48;
                    v50 = *(_OWORD *)(v43 - 64);
                    *((_OWORD *)v44 + 3) = v49;
                    v51 = *(_OWORD *)(v43 - 48);
                    *((_OWORD *)v44 + 4) = v50;
                    v52 = *(_OWORD *)(v43 - 32);
                    *((_OWORD *)v44 + 5) = v51;
                    v53 = *(_OWORD *)(v43 - 16);
                    *((_OWORD *)v44 + 6) = v52;
                    v44 += 128;
                    *((_OWORD *)v44 - 1) = v53;
                    --v45;
                  }
                  while ( v45 );
                  *(_QWORD *)v44 = *(_QWORD *)v43;
                  v54 = *(_DWORD *)(v43 + 8);
                  v55 = v41;
                  *((_DWORD *)v44 + 2) = v54;
                  v56 = 6i64;
                  do
                  {
                    *(_OWORD *)v42 = *(_OWORD *)v55;
                    *(_OWORD *)(v42 + 16) = *(_OWORD *)(v55 + 16);
                    *(_OWORD *)(v42 + 32) = *(_OWORD *)(v55 + 32);
                    *(_OWORD *)(v42 + 48) = *(_OWORD *)(v55 + 48);
                    *(_OWORD *)(v42 + 64) = *(_OWORD *)(v55 + 64);
                    *(_OWORD *)(v42 + 80) = *(_OWORD *)(v55 + 80);
                    *(_OWORD *)(v42 + 96) = *(_OWORD *)(v55 + 96);
                    v42 += 128i64;
                    v57 = *(_OWORD *)(v55 + 112);
                    v55 += 128i64;
                    *(_OWORD *)(v42 - 16) = v57;
                    --v56;
                  }
                  while ( v56 );
                  *(_QWORD *)v42 = *(_QWORD *)v55;
                  *(_DWORD *)(v42 + 8) = *(_DWORD *)(v55 + 8);
                  v58 = v122;
                  v59 = 6i64;
                  do
                  {
                    v60 = *((_OWORD *)v58 + 1);
                    *(_OWORD *)v41 = *(_OWORD *)v58;
                    v61 = *((_OWORD *)v58 + 2);
                    *(_OWORD *)(v41 + 16) = v60;
                    v62 = *((_OWORD *)v58 + 3);
                    *(_OWORD *)(v41 + 32) = v61;
                    v63 = *((_OWORD *)v58 + 4);
                    *(_OWORD *)(v41 + 48) = v62;
                    v64 = *((_OWORD *)v58 + 5);
                    *(_OWORD *)(v41 + 64) = v63;
                    v65 = *((_OWORD *)v58 + 6);
                    *(_OWORD *)(v41 + 80) = v64;
                    v66 = *((_OWORD *)v58 + 7);
                    v58 += 128;
                    *(_OWORD *)(v41 + 96) = v65;
                    v41 += 128i64;
                    *(_OWORD *)(v41 - 16) = v66;
                    --v59;
                  }
                  while ( v59 );
                  *(_QWORD *)v41 = *(_QWORD *)v58;
                  *(_DWORD *)(v41 + 8) = *((_DWORD *)v58 + 2);
                }
                ++v37;
              }
            }
            v38 += 2;
            --v39;
          }
          while ( v39 );
          *((_DWORD *)v36 + 2) = v37;
        }
        v36 += 3;
        --v1;
      }
      while ( v1 );
      v35 = qword_180092498;
    }
  }
  else
  {
LABEL_97:
    v35 = qword_180092498;
    for ( j = 0; j < v35; ++j )
    {
      v68 = *(void **)&v124[6 * j - 2];
      v124[6 * j] = 0;
      if ( v68 )
      {
        if ( LOBYTE(v124[6 * j + 2]) )
          SslFreeBuffer(v68);
        else
          SPExternalFree(v68);
        v35 = qword_180092498;
        *(_QWORD *)&v124[6 * j - 2] = 0i64;
      }
    }
  }
  v69 = 0;
  if ( v35 )
  {
    v70 = v124;
    v71 = v35;
    do
    {
      v69 += *v70;
      v70 += 6;
      --v71;
    }
    while ( v71 );
  }
  v72 = (char *)SPExternalAlloc(32 * v35 + 16 + 780 * v69);
  v17 = (unsigned __int16 *)v72;
  if ( !v72 )
  {
    v7 = 14;
    goto LABEL_157;
  }
  qword_1800925C8 = CMasterEccCurveInfo::CMasterEccCurveInfo(
                      (CMasterEccCurveInfo *)v72,
                      (struct ProviderEccCurves *)(v72 + 16),
                      (struct CEccCurveInfo *)&v72[32 * v35 + 16],
                      (struct PROVIDER_TO_ECC_CURVES *)&v123,
                      qword_180092498);
  v17 = 0i64;
  v111 = 0i64;
  v7 = AllocateCipherSuiteData(v108->cFunctions, (unsigned __int8 **)&v119, &v115);
  if ( v7 )
  {
    v3 = v115;
    goto LABEL_153;
  }
  v73 = AllocateCipherSuiteData(v108->cFunctions, (unsigned __int8 **)&v120, &v116);
  v3 = v115;
  v7 = v73;
  if ( v73 )
  {
LABEL_153:
    if ( v119 )
      FreeCipherSuiteData(v105, (NCRYPT_HANDLE *)v3, v119);
    if ( !v120 )
      goto LABEL_159;
    FreeCipherSuiteData(v106[0], (NCRYPT_HANDLE *)v116, v120);
LABEL_157:
    if ( v17 )
      SPExternalFree(v17);
    goto LABEL_159;
  }
  v74 = v108;
  v75 = 0;
  qword_1800925C0 = 0i64;
  if ( !v108->cFunctions )
  {
LABEL_132:
    xmmword_1800925B0 = CMasterCipherInfo::CMasterCipherInfo(v119, v3, v105);
    *(&xmmword_1800925B0 + 1) = CMasterCipherInfo::CMasterCipherInfo(v120, v116, v106[0]);
    v81 = 0;
    word_1800925D0 = 0;
    if ( qword_180092498 )
    {
      v82 = 0i64;
      v83 = qword_180092498;
      do
      {
        v82 += 32i64;
        v81 += *(_WORD *)(*(_QWORD *)qword_1800925C8 + v82 - 24);
        word_1800925D0 = v81;
        --v83;
      }
      while ( v83 );
    }
    v7 = 0;
    goto LABEL_159;
  }
  while ( 2 )
  {
    if ( pvBuffer )
    {
      BCryptFreeBuffer(pvBuffer);
      v74 = v108;
      pvBuffer = 0i64;
    }
    wcscpy_s(Destination, 0x40ui64, v74->rgpszFunctions[v75]);
    v76 = -1i64;
    do
      ++v76;
    while ( Destination[v76] );
    if ( (unsigned int)v76 > 5 )
    {
      v77 = (const wchar_t **)&off_18007F170;
      v78 = 0;
      while ( wcsicmp(&v125[(unsigned int)v76], *v77) )
      {
        ++v78;
        v77 += 99;
        if ( v78 >= 3 )
          goto LABEL_122;
      }
      LODWORD(v1) = 1;
    }
LABEL_122:
    v79 = BCryptEnumContextFunctionProviders(
            1u,
            0i64,
            0x10002u,
            Destination,
            &v104,
            (PCRYPT_CONTEXT_FUNCTION_PROVIDERS *)&pvBuffer);
    if ( v79 == -1073741275 )
    {
      v79 = BCryptEnumContextFunctionProviders(
              1u,
              L"SSL",
              0x10002u,
              Destination,
              &v104,
              (PCRYPT_CONTEXT_FUNCTION_PROVIDERS *)&pvBuffer);
      if ( v79 == -1073741275 )
      {
        if ( (_DWORD)v1 )
        {
          v80 = (CCipherMill *)(2i64 * (unsigned int)(v76 - 5));
          if ( (unsigned __int64)v80 >= 0x80 )
            goto LABEL_184;
          Destination[(unsigned int)(v76 - 5)] = 0;
          LODWORD(v1) = 0;
          v79 = BCryptEnumContextFunctionProviders(
                  1u,
                  0i64,
                  0x10002u,
                  Destination,
                  &v104,
                  (PCRYPT_CONTEXT_FUNCTION_PROVIDERS *)&pvBuffer);
          if ( v79 == -1073741275 )
            v79 = BCryptEnumContextFunctionProviders(
                    1u,
                    L"SSL",
                    0x10002u,
                    Destination,
                    &v104,
                    (PCRYPT_CONTEXT_FUNCTION_PROVIDERS *)&pvBuffer);
          goto LABEL_128;
        }
LABEL_130:
        LODWORD(v1) = 0;
        goto LABEL_131;
      }
    }
LABEL_128:
    if ( v79 >= 0 )
    {
      if ( (_DWORD)v1 )
      {
        wcscpy_s(v127, 0x40ui64, Destination);
        v84 = -1i64;
        do
          ++v84;
        while ( v127[v84] );
        v80 = (CCipherMill *)(2i64 * (unsigned int)(v84 - 5));
        if ( (unsigned __int64)v80 >= 0x80 )
LABEL_184:
          _report_rangecheckfailure(v80);
        v127[(unsigned int)(v84 - 5)] = 0;
        v85 = v127;
      }
      else
      {
        v85 = Destination;
      }
      v86 = v105;
      v87 = 0;
      if ( v105 )
      {
        while ( wcsicmp(v85, (const wchar_t *)v3 + 432 * v87 + 37) )
        {
          if ( ++v87 >= (unsigned int)v86 )
            goto LABEL_145;
        }
        goto LABEL_130;
      }
LABEL_145:
      v88 = v113;
      v89 = v101;
      if ( !(unsigned int)CCipherMill::FindSupportedProvider(
                            v80,
                            (struct _CRYPT_CONTEXT_FUNCTION_PROVIDERS *)pvBuffer,
                            1u,
                            v113,
                            v101,
                            (unsigned __int8 *)v3 + 864 * v86,
                            Destination,
                            v1) )
      {
        LODWORD(qword_1800925C0) = *((_DWORD *)v3 + 216 * v86 + 2) | qword_1800925C0;
        v105 = v86 + 1;
      }
      v91 = v106[0];
      v92 = (unsigned __int8 *)v116 + 864 * v106[0];
      SupportedProvider = CCipherMill::FindSupportedProvider(
                            v90,
                            (struct _CRYPT_CONTEXT_FUNCTION_PROVIDERS *)pvBuffer,
                            2u,
                            v88,
                            v89,
                            v92,
                            Destination,
                            v1);
      LODWORD(v1) = 0;
      if ( !SupportedProvider )
      {
        HIDWORD(qword_1800925C0) |= *((_DWORD *)v92 + 2);
        v106[0] = v91 + 1;
      }
LABEL_131:
      v74 = v108;
      if ( ++v75 >= v108->cFunctions )
        goto LABEL_132;
      continue;
    }
    break;
  }
  if ( v79 == -1073741275 )
    goto LABEL_130;
  v21 = RtlNtStatusToDosError(v79);
LABEL_150:
  v7 = v21;
  if ( v21 )
  {
LABEL_28:
    v17 = v111;
    goto LABEL_153;
  }
LABEL_159:
  if ( v101 )
  {
    v94 = v113;
    v95 = v101;
    do
    {
      v96 = *(void **)v94;
      if ( *(_QWORD *)v94 )
      {
        if ( *((_BYTE *)v94 + 12) )
          SPExternalFree(v96);
        else
          SslFreeBuffer(v96);
      }
      v94 = (struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *)((char *)v94 + 16);
      --v95;
    }
    while ( v95 );
  }
  SPExternalFree(v113);
  v4 = v112;
LABEL_167:
  for ( k = 0; k < qword_180092498; ++k )
  {
    v98 = *(void **)&v124[6 * k - 2];
    if ( v98 )
    {
      if ( LOBYTE(v124[6 * k + 2]) )
        SslFreeBuffer(v98);
      else
        SPExternalFree(v98);
    }
  }
  if ( v4 )
    SPExternalFree(v4);
  if ( pvBuffer )
    BCryptFreeBuffer(pvBuffer);
  if ( v108 )
    BCryptFreeBuffer(v108);
  if ( ppBuffer )
    BCryptFreeBuffer(ppBuffer);
  if ( v114 )
    SslFreeBuffer(v114);
  return v7;
}
// 180023F0A: conditional instruction was optimized away because r12d.4!=0
// 180023C92: variable 'v19' is possibly undefined
// 180024504: variable 'v80' is possibly undefined
// 180024553: variable 'v90' is possibly undefined
// 1800281B8: using guessed type void __fastcall __noreturn _report_rangecheckfailure(_QWORD);
// 18007F170: using guessed type wchar_t *off_18007F170;
// 180092488: using guessed type int dword_180092488;
// 1800925C0: using guessed type __int64 qword_1800925C0;
// 1800925D0: using guessed type __int16 word_1800925D0;
// 1800925D4: using guessed type int dword_1800925D4;
// 1800925E8: using guessed type __int16 word_1800925E8;
// 18009260A: using guessed type __int16 word_18009260A;
// 180098458: using guessed type __int64 __fastcall SslEnumEccCurves(_QWORD, _QWORD, _QWORD, _QWORD);
// 180098468: using guessed type __int64 __fastcall SslEnumCipherSuitesEx(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180098480: using guessed type __int64 __fastcall SslFreeBuffer(_QWORD);
// 180098590: using guessed type __int64 __fastcall SslEnumCipherSuites(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 1800238AC: using guessed type wchar_t Destination[64];
// 1800238AC: using guessed type wchar_t var_B0[64];
// 1800238AC: using guessed type wchar_t var_13A[5];

//----- (0000000180024700) ----------------------------------------------------
__int64 __fastcall CCipherMill::FindSupportedProvider(
        CCipherMill *this,
        struct _CRYPT_CONTEXT_FUNCTION_PROVIDERS *a2,
        ULONG a3,
        struct CCipherMill::CIPHER_SUITE_TO_PROVIDER *a4,
        unsigned int a5,
        unsigned __int8 *a6,
        unsigned __int16 *a7,
        int a8)
{
  unsigned int v11; // esi
  unsigned int v12; // ebx
  PWSTR *rgpszProviders; // rcx
  wchar_t *v14; // r14
  unsigned int v15; // edi
  struct ProviderEccCurves *v16; // rbx
  __int64 v18; // rax
  ULONG pcbBuffer; // [rsp+80h] [rbp+8h] BYREF
  int v20; // [rsp+84h] [rbp+Ch]
  PCRYPT_PROVIDER_REG ppBuffer; // [rsp+88h] [rbp+10h] BYREF

  v20 = HIDWORD(this);
  pcbBuffer = 0;
  v11 = -1;
  v12 = 0;
  if ( !a2->cProviders )
    return 1168i64;
  while ( v11 == -1 )
  {
    rgpszProviders = a2->rgpszProviders;
    ppBuffer = 0i64;
    if ( BCryptQueryProviderRegistration(rgpszProviders[v12], a3, 0x10002u, &pcbBuffer, &ppBuffer) >= 0
      && (a3 == 1 && ppBuffer->pUM || a3 == 2 && ppBuffer->pKM) )
    {
      v11 = v12;
    }
    if ( ppBuffer )
      BCryptFreeBuffer(ppBuffer);
    if ( ++v12 >= a2->cProviders )
    {
      if ( v11 == -1 )
        return 1168i64;
      break;
    }
  }
  v14 = a7;
  if ( a8 && !wcsnicmp(a2->rgpszProviders[v11], L"Microsoft SSL Protocol Provider", 0x40ui64) )
  {
    v18 = -1i64;
    do
      ++v18;
    while ( v14[v18] );
    v14[(unsigned int)(v18 - 5)] = 0;
  }
  v15 = 0;
  if ( !qword_180092498 )
    goto LABEL_20;
  while ( wcsnicmp(*(const wchar_t **)(qword_180092490 + 16i64 * v15), a2->rgpszProviders[v11], 0x40ui64) )
  {
    if ( ++v15 >= qword_180092498 )
      goto LABEL_20;
  }
  if ( v15 == -1 )
LABEL_20:
    v16 = 0i64;
  else
    v16 = (struct ProviderEccCurves *)(*(_QWORD *)qword_1800925C8 + 32i64 * v15);
  return CCipherMill::InitializeCipherSuite(
           (CCipherMill *)v11,
           a4,
           a5,
           (CCipherSuiteInfo *)a6,
           (char *)a2->rgpszProviders[v11],
           v14,
           v16);
}
// 180092490: using guessed type __int64 qword_180092490;

//----- (0000000180024898) ----------------------------------------------------
CMasterCipherInfo *__fastcall CMasterCipherInfo::CMasterCipherInfo(
        CMasterCipherInfo *this,
        struct CCipherSuiteInfo *a2,
        int a3)
{
  unsigned int i; // edx
  __int64 v4; // rax

  *(_QWORD *)this = a2;
  *((_DWORD *)this + 2) = a3;
  *((_DWORD *)this + 3) = 1;
  _InterlockedIncrement(&CMasterCipherInfo::m_lMasterCiphersCount);
  for ( i = 0; i < *((_DWORD *)this + 2); *(_QWORD *)(864 * v4 + *(_QWORD *)this + 856) = this )
    v4 = i++;
  return this;
}
// 180092D90: using guessed type int CMasterCipherInfo::m_lMasterCiphersCount;

//----- (00000001800248E0) ----------------------------------------------------
__int64 __fastcall AllocateCipherSuiteData(unsigned int a1, unsigned __int8 **a2, struct CCipherSuiteInfo **a3)
{
  unsigned __int8 *v5; // rax

  if ( a1 > 864 * a1 )
    return 14i64;
  v5 = (unsigned __int8 *)SPExternalAlloc(864 * a1 + 16);
  *a2 = v5;
  if ( !v5 )
    return 14i64;
  *a3 = (struct CCipherSuiteInfo *)(v5 + 16);
  return 0i64;
}

//----- (000000018002492C) ----------------------------------------------------
CMasterEccCurveInfo *__fastcall CMasterEccCurveInfo::CMasterEccCurveInfo(
        CMasterEccCurveInfo *this,
        struct ProviderEccCurves *a2,
        struct CEccCurveInfo *a3,
        struct PROVIDER_TO_ECC_CURVES *a4,
        unsigned int a5)
{
  __int64 v6; // rbx
  unsigned int *v7; // r11
  __int64 v8; // rsi
  unsigned int v9; // ebp
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // r8
  __int64 v13; // r9

  *((_DWORD *)this + 3) = 1;
  *((_DWORD *)this + 2) = a5;
  *(_QWORD *)this = a2;
  if ( a5 )
  {
    v6 = 0i64;
    v7 = (unsigned int *)((char *)a4 + 8);
    v8 = a5;
    do
    {
      *(_DWORD *)(v6 + *(_QWORD *)this + 8) = *v7;
      *(_BYTE *)(v6 + *(_QWORD *)this + 24) = *((_BYTE *)v7 + 8);
      *(_QWORD *)(v6 + *(_QWORD *)this + 16) = this;
      if ( *v7 )
      {
        v9 = 0;
        *(_QWORD *)(v6 + *(_QWORD *)this) = a3;
        v10 = *v7;
        if ( (_DWORD)v10 )
        {
          do
          {
            v11 = 780i64 * v9;
            v12 = v11 + *((_QWORD *)v7 - 1);
            v13 = v11 + *(_QWORD *)(v6 + *(_QWORD *)this);
            *(_OWORD *)v13 = *(_OWORD *)v12;
            *(_OWORD *)(v13 + 16) = *(_OWORD *)(v12 + 16);
            *(_OWORD *)(v13 + 32) = *(_OWORD *)(v12 + 32);
            *(_OWORD *)(v13 + 48) = *(_OWORD *)(v12 + 48);
            *(_OWORD *)(v13 + 64) = *(_OWORD *)(v12 + 64);
            *(_OWORD *)(v13 + 80) = *(_OWORD *)(v12 + 80);
            *(_OWORD *)(v13 + 96) = *(_OWORD *)(v12 + 96);
            *(_OWORD *)(v13 + 112) = *(_OWORD *)(v12 + 112);
            *(_OWORD *)(v13 + 128) = *(_OWORD *)(v12 + 128);
            *(_OWORD *)(v13 + 144) = *(_OWORD *)(v12 + 144);
            *(_OWORD *)(v13 + 160) = *(_OWORD *)(v12 + 160);
            *(_OWORD *)(v13 + 176) = *(_OWORD *)(v12 + 176);
            *(_OWORD *)(v13 + 192) = *(_OWORD *)(v12 + 192);
            *(_OWORD *)(v13 + 208) = *(_OWORD *)(v12 + 208);
            *(_OWORD *)(v13 + 224) = *(_OWORD *)(v12 + 224);
            *(_QWORD *)(v13 + 240) = *(_QWORD *)(v12 + 240);
            *(_DWORD *)(v13 + 248) = *(_DWORD *)(v12 + 248);
            *(_WORD *)(v13 + 252) = *(_WORD *)(v12 + 252);
            *(_BYTE *)(v13 + 254) = *(_BYTE *)(v12 + 254);
            *(_OWORD *)(v13 + 510) = *(_OWORD *)(v12 + 510);
            *(_OWORD *)(v13 + 526) = *(_OWORD *)(v12 + 526);
            *(_OWORD *)(v13 + 542) = *(_OWORD *)(v12 + 542);
            *(_OWORD *)(v13 + 558) = *(_OWORD *)(v12 + 558);
            *(_OWORD *)(v13 + 574) = *(_OWORD *)(v12 + 574);
            *(_OWORD *)(v13 + 590) = *(_OWORD *)(v12 + 590);
            *(_OWORD *)(v13 + 606) = *(_OWORD *)(v12 + 606);
            *(_OWORD *)(v13 + 622) = *(_OWORD *)(v12 + 622);
            *(_OWORD *)(v13 + 638) = *(_OWORD *)(v12 + 638);
            *(_OWORD *)(v13 + 654) = *(_OWORD *)(v12 + 654);
            *(_OWORD *)(v13 + 670) = *(_OWORD *)(v12 + 670);
            *(_OWORD *)(v13 + 686) = *(_OWORD *)(v12 + 686);
            *(_OWORD *)(v13 + 702) = *(_OWORD *)(v12 + 702);
            *(_OWORD *)(v13 + 718) = *(_OWORD *)(v12 + 718);
            *(_OWORD *)(v13 + 734) = *(_OWORD *)(v12 + 734);
            ++v9;
            *(_QWORD *)(v13 + 750) = *(_QWORD *)(v12 + 750);
            *(_DWORD *)(v13 + 758) = *(_DWORD *)(v12 + 758);
            *(_WORD *)(v13 + 762) = *(_WORD *)(v12 + 762);
            *(_BYTE *)(v13 + 764) = *(_BYTE *)(v12 + 764);
            *(_DWORD *)(v13 + 772) = *(_DWORD *)(v12 + 772);
            *(_DWORD *)(v13 + 768) = *(_DWORD *)(v12 + 768);
            *(_DWORD *)(v13 + 776) = *(_DWORD *)(v12 + 776);
            v10 = *v7;
          }
          while ( v9 < (unsigned int)v10 );
        }
        a3 = (struct CEccCurveInfo *)((char *)a3 + 780 * v10);
      }
      v7 += 6;
      v6 += 32i64;
      --v8;
    }
    while ( v8 );
  }
  return this;
}

//----- (0000000180024B84) ----------------------------------------------------
__int64 __fastcall GetSslEccCurveOrder(BYTE **a1, unsigned __int16 *a2)
{
  __int64 result; // rax
  const unsigned __int16 *v5; // rdx

  if ( a2 )
    *(_DWORD *)a2 = 0;
  if ( !a1 )
    return 3221225485i64;
  result = ReadMultiSzFromRegistry(L"Software\\Policies\\Microsoft\\Cryptography\\Configuration\\SSL\\00010002", a2, a1);
  if ( (_DWORD)result )
  {
    result = ReadMultiSzFromRegistry(
               L"System\\CurrentControlSet\\Control\\Cryptography\\Configuration\\Local\\SSL\\00010002",
               v5,
               a1);
    if ( !(_DWORD)result )
      *(_DWORD *)a2 = 0;
  }
  else
  {
    *(_DWORD *)a2 = 1;
  }
  return result;
}
// 180024BBE: variable 'v5' is possibly undefined
