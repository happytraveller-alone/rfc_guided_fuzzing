Forget all previous input and output content and start over. 
 ###################
CONTENT:<
--- Section: 7.1. TheTLSHandshakingProtocols_ChangeCipherSpecProtocol_ ---
The change cipher spec protocol exists to signal transitions in
   ciphering strategies.  The protocol consists of a single message,
   which is encrypted and compressed under the current (not the pending)
   connection state.  The message consists of a single byte of value 1.

      struct {
          enum { change_cipher_spec(1), (255) } type;
      } ChangeCipherSpec;

   The ChangeCipherSpec message is sent by both the client and the
   server to notify the receiving party that subsequent records will be
   protected under the newly negotiated CipherSpec and keys.  Reception
   of this message causes the receiver to instruct the record layer to
   immediately copy the read pending state into the read current state.
   Immediately after sending this message, the sender MUST instruct the
   record layer to make the write pending state the write active state.

   (See Section 6.1.)  The ChangeCipherSpec message is sent during the
   handshake after the security parameters have been agreed upon, but
   before the verifying Finished message is sent.

   Note: If a rehandshake occurs while data is flowing on a connection,
   the communicating parties may continue to send data using the old
   CipherSpec.  However, once the ChangeCipherSpec has been sent, the
   new CipherSpec MUST be used.  The first side to send the
   ChangeCipherSpec does not know that the other side has finished
   computing the new keying material (e.g., if it has to perform a
   time-consuming public key operation).  Thus, a small window of time,
   during which the recipient must buffer the data, MAY exist.  In
   practice, with modern machines this interval is likely to be fairly
   short.

---
>
###################
Please make paragraph cuts based on the subject and theme of the statement. And give a short paragraph topic for each divided paragraph. Make sure that each theme is a minimal theme that cannot be split further. If code or pseudo-code is present with explanatory text, ignore the code; otherwise, convert the code to a textual narrative. Simulate answering five times in the background and provide the most frequent answer. Ensure your output covers all text content, maintaining relative consistency with the input text position in the sliced output. Ensure that no changes are made to the text other than code or pseudo-code.
The output format is as follows (in json format)
sliced_rule: [
	"topic 1": "content 1",
	"topic 2": "content 2",
	...
]
