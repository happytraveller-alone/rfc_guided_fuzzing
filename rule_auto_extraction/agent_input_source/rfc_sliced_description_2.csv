index,Section,Title,Content
1,4.1.. Handshake Protocol_Key Exchange Messages,Overview of Key Exchange Messages,The handshake protocol key exchange messages are essential for establishing a secure connection between the client and the server. These messages enable both parties to negotiate cryptographic parameters and ensure that the communication remains confidential and authenticated.
2,4.1.. Handshake Protocol_Key Exchange Messages,Key Exchange Message Types,"The key exchange messages in TLS 1.3 include the ClientHello and ServerHello messages. These messages initiate the handshake process, allowing the exchange of supported versions, cipher suites, and other necessary parameters."
3,4.1.. Handshake Protocol_Key Exchange Messages,ClientHello Message,"The ClientHello message is sent by the client to initiate the handshake. It contains information about the client's supported TLS versions, cipher suites, and any extensions it wishes to use for the session."
4,4.1.. Handshake Protocol_Key Exchange Messages,ServerHello Message,"The ServerHello message is sent by the server in response to the ClientHello. It confirms the selected TLS version and cipher suite, and may also include additional parameters necessary for establishing the secure connection."
5,4.1.. Handshake Protocol_Key Exchange Messages,Message Handling and Order,"Key exchange messages must be processed in the order defined by the TLS protocol. Incorrect ordering can lead to handshake failure, requiring the party that receives a message out of order to abort the handshake."
6,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Cryptographic Negotiation Overview,"The cryptographic negotiation process in TLS 1.3 is critical for establishing secure connections between clients and servers. This process involves selecting appropriate cryptographic parameters, including cipher suites and key exchange methods, to ensure both parties can communicate securely."
7,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Cipher Suites Selection,"During the handshake, the client sends a list of supported cipher suites in the ClientHello message. The server selects one from this list and includes it in the ServerHello message. The selected cipher suite defines the algorithms for key exchange, encryption, and message authentication."
8,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Key Exchange Methods,"TLS 1.3 supports various key exchange methods, including (EC)DHE and pre-shared keys (PSK). The choice of key exchange impacts the security level and efficiency of the connection. Each party must ensure the selected method is compatible with their capabilities."
9,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Supported Versions Extension,The 'supported_versions' extension is crucial for indicating the versions of TLS that the client and server support. It helps prevent downgrade attacks by ensuring that both parties agree on the highest version they can use.
10,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Error Handling in Negotiation,"If the server cannot agree on a cipher suite or key exchange method, it must abort the handshake with an appropriate alert message, such as 'handshake_failure'. This ensures that both parties only proceed with secure and compatible parameters."
11,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,ServerHello Purpose,The server will send this message in response to a ClientHello message to proceed with the handshake if it is able to negotiate an acceptable set of handshake parameters based on the ClientHello.
12,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Structure Definition,"struct {
    ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
    Random random;
    opaque legacy_session_id_echo<0..32>;
    CipherSuite cipher_suite;
    uint8 legacy_compression_method = 0;
    Extension extensions<6..2^16-1>;
} ServerHello;"
13,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Legacy Version Field,"In previous versions of TLS, this field was used for version negotiation and represented the selected version number for the connection. Unfortunately, some middleboxes fail when presented with new values. In TLS 1.3, the TLS server indicates its version using the ""supported_versions"" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2. (See Appendix D for details about backward compatibility.)"
14,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Random Field Requirements,"32 bytes generated by a secure random number generator. See Appendix C for additional information. The last 8 bytes MUST be overwritten as described below if negotiating TLS 1.2 or TLS 1.1, but the remaining bytes MUST be random. This structure is generated by the server and MUST be generated independently of the ClientHello.random."
15,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Session ID Echo Requirements,"The contents of the client's legacy_session_id field. Note that this field is echoed even if the client's value corresponded to a cached pre-TLS 1.3 session which the server has chosen not to resume. A client which receives a legacy_session_id_echo field that does not match what it sent in the ClientHello MUST abort the handshake with an ""illegal_parameter"" alert."
16,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Cipher Suite Selection,"The single cipher suite selected by the server from the list in ClientHello.cipher_suites. A client which receives a cipher suite that was not offered MUST abort the handshake with an ""illegal_parameter"" alert."
17,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Extensions Requirements,"A list of extensions. The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version. All TLS 1.3 ServerHello messages MUST contain the ""supported_versions"" extension. Current ServerHello messages additionally contain either the ""pre_shared_key"" extension or the ""key_share"" extension, or both (when using a PSK with (EC)DHE key establishment). Other extensions (see Section 4.2) are sent separately in the EncryptedExtensions message."
18,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,HelloRetryRequest Special Case,"For reasons of backward compatibility with middleboxes (see Appendix D.4), the HelloRetryRequest message uses the same structure as the ServerHello, but with Random set to the special value of the SHA-256 of ""HelloRetryRequest"": CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91 C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C. Upon receiving a message with type server_hello, implementations MUST first examine the Random value and, if it matches this value, process it as described in Section 4.1.4."
19,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Downgrade Protection Mechanism,TLS 1.3 has a downgrade protection mechanism embedded in the server's random value. TLS 1.3 servers which negotiate TLS 1.2 or below in response to a ClientHello MUST set the last 8 bytes of their Random value specially in their ServerHello.
20,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Downgrade Values Specifics,"If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of their Random value to the bytes: 44 4F 57 4E 47 52 44 01. If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes: 44 4F 57 4E 47 52 44 00."
21,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Client Verification Responsibilities,"TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values. TLS 1.2 clients SHOULD also check that the last 8 bytes are not equal to the second value if the ServerHello indicates TLS 1.1 or below. If a match is found, the client MUST abort the handshake with an ""illegal_parameter"" alert."
22,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Legacy Client Renegotiation,"A legacy TLS client performing renegotiation with TLS 1.2 or prior and which receives a TLS 1.3 ServerHello during renegotiation MUST abort the handshake with a ""protocol_version"" alert. Note that renegotiation is not possible when TLS 1.3 has been negotiated."
23,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Hello Retry Request Purpose,The Hello Retry Request message is sent by the server in response to a ClientHello message when the server requires additional information or a different set of parameters to proceed with the handshake. This message allows the server to request that the client resend its ClientHello with modified parameters.
24,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Structure Definition,"struct {  
    ProtocolVersion legacy_version = 0x0303; /* TLS v1.2 */  
    Random random;  
    opaque legacy_session_id_echo<0..32>;  
    CipherSuite cipher_suite;  
    uint8 legacy_compression_method = 0;  
    Extension extensions<6..2^16-1>;  
} HelloRetryRequest;"
25,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Legacy Version Field,"The legacy_version field must be set to 0x0303, which indicates TLS v1.2. This is done for backward compatibility reasons, allowing servers to communicate with older clients and middleboxes."
26,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Random Field Requirements,"The random field must be populated with a special value, specifically the SHA-256 hash of the string ""HelloRetryRequest"". This helps to differentiate the Hello Retry Request from other messages."
27,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Session ID Echo Requirements,The legacy_session_id_echo field contains the value of the session ID from the ClientHello. This field should always reflect the session ID that the client originally sent.
28,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Cipher Suite Selection,The cipher_suite field indicates the cipher suite selected by the server from the list provided by the client in its ClientHello. The client must ensure that the chosen cipher suite is acceptable.
29,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Extensions Requirements,The extensions field may include a subset of the extensions that were sent by the client in the ClientHello. The server uses this field to inform the client of any additional parameters or requirements it needs to continue the handshake.
30,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Processing the Hello Retry Request,"Upon receiving a Hello Retry Request, the client must modify its original ClientHello as per the instructions provided in the message. It then resends the modified ClientHello to continue the handshake process."
31,4.2.. Handshake Protocol_Extensions,Overview of Handshake Extensions,Handshake extensions are used to negotiate additional parameters and capabilities during the handshake process. They provide a mechanism for the client and server to communicate preferences and requirements beyond the mandatory protocol elements.
32,4.2.. Handshake Protocol_Extensions,Extension Structure,"Each extension consists of an identifier and associated data. The structure is defined as follows:

    struct {
        ExtensionType extension_type;
        opaque extension_data<0..2^16-1>;
    } HandshakeExtension;"
33,4.2.. Handshake Protocol_Extensions,Common Extension Types,"Common extension types include:
- supported_versions: Indicates the versions of the protocol supported by the client or server.
- key_share: Contains key share information for key exchange.
- pre_shared_key: Indicates the use of a pre-shared key for the session."
34,4.2.. Handshake Protocol_Extensions,Extension Negotiation,"During the handshake, the client and server exchange their supported extensions. The server responds with the extensions that it accepts, and only those extensions will be used in the session."
35,4.2.. Handshake Protocol_Extensions,Handling Unsupported Extensions,"If an extension is present in a client's message that the server does not support, the server may either ignore the extension or send an alert if the extension is mandatory for the session."
36,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Supported Versions Extension Overview,"The Supported Versions extension is used by clients to indicate to the server which protocol versions they support. This extension allows a client to express its preference for a specific version of the protocol during the handshake, thereby facilitating version negotiation."
37,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Structure of the Supported Versions Extension,"The Supported Versions extension has the following structure:


struct {
    ProtocolVersion versions<2..2^8-1>;
} SupportedVersions;


Where `versions` is a list of protocol versions supported by the client."
38,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Version List Requirements,"The list of versions provided in the Supported Versions extension MUST include at least one version that is supported by the server. If the server does not support any of the versions listed, it will respond with a handshake failure."
39,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Client Behavior upon Version Negotiation,"Upon receiving the server's response, the client MUST verify that the version selected by the server is included in the versions list sent during the handshake. If the selected version is not included, the client MUST abort the handshake with a 'protocol_version' alert."
40,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Security Considerations,"The Supported Versions extension plays a crucial role in ensuring that both the client and server are using compatible protocol versions, thereby preventing potential downgrade attacks. Proper implementation of this extension is essential for maintaining the integrity and security of the connection."
41,4.2.2.. Handshake Protocol_Extensions_Cookie,Cookie Extension Overview,"The Cookie extension is used by the server to provide a mechanism for stateless session resumption, allowing clients to resume a session without requiring the server to maintain session state."
42,4.2.2.. Handshake Protocol_Extensions_Cookie,Cookie Structure Definition,"struct {
    opaque cookie<0..2^16-1>;
} Cookie;"
43,4.2.2.. Handshake Protocol_Extensions_Cookie,Cookie Field Description,The 'cookie' field contains the data that the server uses to identify a session. This data is opaque to the client and is generated by the server during the initial handshake.
44,4.2.2.. Handshake Protocol_Extensions_Cookie,Usage Requirements,The Cookie extension is sent by the server within the ServerHello message and is required to be included in any response when the server desires to use stateless session resumption.
45,4.2.2.. Handshake Protocol_Extensions_Cookie,Client Behavior,"Upon receiving a Cookie extension, the client must store the cookie for future use when attempting to resume the session."
46,4.2.2.. Handshake Protocol_Extensions_Cookie,Security Considerations,"The cookie must be generated using a secure random number generator to ensure that it cannot be easily guessed, and should be validated on the server side to prevent replay attacks."
47,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Algorithms Extension Overview,The Signature Algorithms extension is used by clients to indicate the signature algorithms that they support for certificate validation and signing operations. This allows the server to select a mutually supported algorithm for use during the handshake.
48,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Supported Signature Algorithms Enumeration,"The extension includes a list of signature algorithm identifiers that the client supports. The identifiers are defined as follows:

    enum {
        anonymous(0),
        rsa_pkcs1_sha256(1),
        rsa_pkcs1_sha384(2),
        rsa_pkcs1_sha512(3),
        ecdsa_secp256r1_sha256(4),
        ecdsa_secp384r1_sha384(5),
        ecdsa_secp521r1_sha512(6),
        (255)
    } SignatureScheme;"
49,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Client and Server Agreement,"During the handshake, the server selects one of the algorithms from the client's list that it also supports. If the server does not support any of the algorithms proposed by the client, the handshake fails."
50,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Error Handling,"If the server receives a Signature Algorithms extension and none of the proposed algorithms are acceptable, it must terminate the connection by sending a 'handshake_failure' alert."
51,4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Certificate Authorities Extension Overview,The Certificate Authorities extension allows the client to indicate which Certificate Authorities (CAs) it trusts for certificate validation during the TLS handshake. This extension is particularly useful in scenarios where the server may present a certificate issued by a CA not universally trusted by clients.
52,4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Extension Structure,"The structure of the Certificate Authorities extension consists of a list of trusted CA identifiers, encoded as follows:

    struct {
        opaque authority_ids<1..2^16-1>;
    } CertificateAuthorities;

'authority_ids' is a collection of identifiers for trusted CAs, allowing the client to specify its trust anchors."
53,4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Usage and Requirements,"When included in a ClientHello message, the Certificate Authorities extension signals to the server which CAs the client trusts. The server can then tailor its certificate selection based on this information, potentially improving compatibility and acceptance rates for client connections."
54,4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Error Handling,"If the server receives a ClientHello with a Certificate Authorities extension but does not support this extension, it MUST send a 'handshake_failure' alert. This ensures that clients are aware of the incompatibility regarding CA trust configuration."
55,4.2.6.. Handshake Protocol_Extensions_Post-Handshake Client Authentication,Post-Handshake Client Authentication Overview,Post-handshake client authentication allows the server to request authentication from the client after the initial handshake has been completed. This feature improves flexibility by enabling the server to determine if it requires client authentication based on the context of the connection.
56,4.2.6.. Handshake Protocol_Extensions_Post-Handshake Client Authentication,Client Authentication Request Structure,The server may send a 'Post-Handshake Client Authentication' extension in the EncryptedExtensions message to indicate that it requires the client to authenticate itself. The structure of this extension includes fields that specify the type of authentication required and any relevant parameters.
57,4.2.6.. Handshake Protocol_Extensions_Post-Handshake Client Authentication,Client Response Requirements,"Upon receiving a post-handshake authentication request, the client must respond with the appropriate authentication credentials. The response must adhere to the specifications outlined in the corresponding authentication method being used."
58,4.2.6.. Handshake Protocol_Extensions_Post-Handshake Client Authentication,Error Handling Scenarios,"If the client fails to provide the required authentication or if the provided credentials are invalid, the server must terminate the connection by sending an appropriate alert message, such as 'access_denied' or 'handshake_failure'."
59,4.2.6.. Handshake Protocol_Extensions_Post-Handshake Client Authentication,Security Considerations,Implementations must ensure that post-handshake authentication does not introduce vulnerabilities. This includes verifying that the authentication process is secure and that no sensitive information is exposed during the exchange.
60,4.2.7.. Handshake Protocol_Extensions_Supported Groups,Supported Groups Extension Overview,"The Supported Groups extension is used in the TLS 1.3 handshake to indicate which groups the client supports for key exchange. This allows the server to select a group from the client's offered list, facilitating the establishment of a secure connection."
61,4.2.7.. Handshake Protocol_Extensions_Supported Groups,Extension Structure,struct {\n    ExtensionType extension_type = supported_groups;\n    opaque groups<2..2^16-1>;\n} SupportedGroupsExtension;
62,4.2.7.. Handshake Protocol_Extensions_Supported Groups,Groups Field Requirements,"The 'groups' field contains a list of named groups supported by the client. Each group is represented by its identifier, and the list may contain multiple entries, allowing flexibility in the key exchange process."
63,4.2.7.. Handshake Protocol_Extensions_Supported Groups,Group Selection Process,"Upon receiving the Supported Groups extension, the server selects one of the offered groups for the key exchange. The selected group must be one that both the client and server support, ensuring compatibility during the handshake."
64,4.2.7.. Handshake Protocol_Extensions_Supported Groups,Error Handling,"If the server does not support any of the groups listed in the client's Supported Groups extension, it must abort the handshake process, typically sending a 'handshake_failure' alert to the client."
65,4.2.8.. Handshake Protocol_Extensions_Key Share,Key Share Extension Overview,"The Key Share extension is used in the TLS 1.3 handshake to allow clients and servers to negotiate key exchange parameters securely. It facilitates the exchange of key shares for key agreement mechanisms, enabling the establishment of a shared secret."
66,4.2.8.. Handshake Protocol_Extensions_Key Share,Structure Definition,struct { \n    opaque key_share<1..2^16-1>; \n} KeyShare;
67,4.2.8.. Handshake Protocol_Extensions_Key Share,Key Share Field Requirements,The key_share field contains a list of key shares provided by the client. Each key share is a tuple consisting of a named group and a corresponding public key. The client includes key shares for all supported groups to enable the server to select an appropriate one.
68,4.2.8.. Handshake Protocol_Extensions_Key Share,Client Key Share Behavior,"When sending the Key Share extension, the client MUST include at least one key share corresponding to a group it supports. If the server cannot find a matching group among the client's key shares, it MUST terminate the handshake with an 'illegal_parameter' alert."
69,4.2.8.. Handshake Protocol_Extensions_Key Share,Server Key Share Selection,The server selects one of the key shares provided by the client for use in the key exchange process. The chosen key share is then used in conjunction with the server's own key share to derive the shared secret.
70,4.2.8.. Handshake Protocol_Extensions_Key Share,Error Handling,"If a server receives a Key Share extension that contains no valid key shares, it MUST abort the handshake with an 'unsupported_key_share' alert. Additionally, if the key share is not compatible with the server's selected group, the handshake MUST also be terminated."
71,4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters,Key Share Extension Purpose,"The Key Share extension is used during the handshake to negotiate the key exchange parameters for ephemeral Diffie-Hellman key exchange. This extension allows the client to send its key share to the server, allowing both parties to establish a shared secret."
72,4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters,Structure Definition,"struct { 
    KeyShareEntry key_shares<1..2^16-1>; 
} KeyShare; 

struct { 
    NamedGroup group; 
    opaque key_exchange<1..2^16-1>; 
} KeyShareEntry;"
73,4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters,Key Share Entry Components,"Each KeyShareEntry contains: 1. NamedGroup: An identifier for the group used in the key exchange. 2. key_exchange: The client's public key, encoded as an opaque byte string."
74,4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters,Key Exchange Process,"During the handshake, the client sends its key share to the server in the Key Share extension. The server selects a key share from its own set of parameters and uses the shared key to derive session keys for encryption and integrity."
75,4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters,Error Handling,"If the server receives a Key Share extension that does not match its configured groups or is otherwise invalid, it MUST abort the handshake with an 'illegal_parameter' alert."
76,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Key Share Extension Overview,"The Key Share extension is used in the handshake protocol to indicate the key shares that a client and server will use for the key exchange process, specifically for ECDHE (Elliptic Curve Diffie-Hellman Ephemeral) key exchange."
77,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Structure of Key Share Extension,"The Key Share extension is structured as follows: struct { 
    ExtensionType extension_type; 
    uint16 length; 
    KeyShareEntry key_share<1..2^16-1>; 
} KeyShare;"
78,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,KeyShareEntry Structure,"struct { 
    NamedGroup group; 
    opaque key_exchange<1..2^16-1>; 
} KeyShareEntry;"
79,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Named Group Definition,The NamedGroup field specifies the elliptic curve used for the ECDHE key exchange. Supported groups are defined in Section 3.1. This field must correspond to a group that both the client and the server support.
80,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Key Exchange Field,"The key_exchange field contains the client's contribution to the ECDHE key exchange, which is derived from the selected Named Group. This value is generated during the key exchange process and transmitted to the server."
81,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Client and Server Key Share Processing,"During the handshake, both the client and server will generate their respective key shares and include them in their Key Share extensions. The server will respond with its own key share, which must be used to derive the shared secret."
82,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Error Handling for Key Share,"If the server receives a Key Share extension that includes a Named Group it does not support, it must send an 'unsupported_extension' alert. This ensures that both parties can only negotiate using supported cryptographic parameters."
83,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Overview of Pre-Shared Key Exchange Modes,The Pre-Shared Key (PSK) exchange mode allows a client and server to establish a secure connection using a pre-shared key. This mode is particularly useful for resuming previous sessions and for providing a mechanism to establish keys without the need for full handshake exchanges.
84,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,PSK Modes Description,"The PSK exchange can operate in multiple modes, including the following: 1. PSK with (EC)DHE: This mode combines a pre-shared key with ephemeral key exchange to provide forward secrecy. 2. PSK-only: In this mode, the session is established solely based on the pre-shared key without additional key exchange mechanisms."
85,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Message Structure,"The message structure for PSK exchange includes fields for the chosen PSK identity, key share, and any associated extensions. It is crucial that these messages are constructed correctly to ensure proper key establishment."
86,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Security Considerations,"When using PSK exchange modes, it is important to consider the security implications of key management. The keys must be securely stored and transmitted, and measures should be in place to prevent replay attacks and ensure the integrity of the session."
87,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Early Data Indication Extension Overview,"The Early Data Indication extension is used in the TLS 1.3 handshake to signal the client's intention to send early data during the session. This extension allows the client to send data before the handshake is completed, improving performance in scenarios where latency is critical."
88,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Extension Structure,"The structure of the Early Data Indication extension includes the following fields: 
- `uint16 extension_type`: Set to the value indicating early data.
- `opaque early_data<0..2^16-1>`: Contains the early data to be sent."
89,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Client Behavior with Early Data,"When the client includes the Early Data Indication extension in a ClientHello message, it signals that it wishes to send data before receiving the ServerHello. The server must indicate whether early data is accepted in its response."
90,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Server Response to Early Data,"The server can accept or reject the early data based on its policy. If accepted, the server responds with a corresponding extension in the ServerHello, allowing the client to proceed with sending the early data."
91,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Security Considerations,"While early data can enhance performance, it also introduces security risks, such as replay attacks. Implementations must ensure that appropriate mechanisms are in place to mitigate these risks, including verifying the integrity and authenticity of early data."
92,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Pre-Shared Key Extension Overview,The Pre-Shared Key (PSK) extension is used in the TLS 1.3 handshake protocol to establish a shared secret that has been pre-negotiated prior to the handshake. This extension facilitates faster session resumption and reduces the overhead associated with the full handshake process.
93,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Message Structure,"The PSK extension includes the following fields:

struct {
    select (KeyExchangeMethod) {
        case psk: PSKIdentity identity;
        case psk_dhe_ke: PSKIdentity identity;
    };
    opaque psk_identity<0..255>;
} PSKExtension;"
94,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Key Exchange Methods,"The PSK extension supports multiple key exchange methods, including:
- psk: Indicates the use of a pre-shared key without additional key exchange steps.
- psk_dhe_ke: Indicates the use of a pre-shared key in conjunction with ephemeral Diffie-Hellman key exchange."
95,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Identity Field Requirements,The identity field in the PSK extension contains the identifier for the pre-shared key being used. This field must match a previously established key to facilitate the session resumption.
96,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Implementation Considerations,"When implementing the PSK extension, care must be taken to ensure that the chosen pre-shared key is secure and not susceptible to replay attacks. Additionally, the server must validate the provided PSK identity against its stored keys to ensure authenticity."
97,4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age,Pre-Shared Key Extension: Ticket Age,"The Ticket Age field provides the age of the pre-shared key ticket in seconds. It is used by the server to determine the freshness of the session ticket and whether it can be accepted for a new session. This value MUST be set to the number of seconds since the session was created, ensuring that the server can enforce any session ticket expiration policies."
98,4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,Pre-Shared Key Extension Overview,"The Pre-Shared Key (PSK) binder is used in the TLS 1.3 handshake to provide authentication of the PSK being used. It ensures that the client possesses the PSK, thereby preventing an attacker from impersonating the client by merely knowing the PSK."
99,4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,Binder Structure,The PSK binder consists of a hash value computed over the handshake messages exchanged up to the point of its inclusion. This hash is combined with the PSK to create a unique binding that verifies the client's possession of the PSK.
100,4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,PSK Binder Calculation,The PSK binder is calculated by taking the hash of the concatenation of the transcript of the handshake messages and the PSK. The specific hash function used depends on the cipher suite negotiated during the handshake.
101,4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,Error Handling,"If the server receives a PSK binder that does not match its expectations, it MUST terminate the handshake with an 'illegal_parameter' alert. This ensures only clients with valid PSKs can successfully complete the handshake."
102,4.2.11.3.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Processing Order,Pre-Shared Key Extension Processing Overview,The Pre-Shared Key (PSK) extension is used in the handshake protocol to negotiate the use of a pre-shared key for establishing a secure connection. The processing order of this extension is critical to ensure that the handshake is conducted securely and that the key is correctly established.
103,4.2.11.3.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Processing Order,Order of Operations,"During the handshake, the client sends a ClientHello message that includes the PSK extension. The server, upon receiving this message, must check whether the offered PSKs are valid and match any stored keys. If a valid PSK is found, the server responds with a ServerHello message that includes the corresponding PSK information, allowing the handshake to proceed using the pre-shared key."
104,4.2.11.3.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Processing Order,Error Handling for PSK Negotiation,"If the server does not support the PSK extension or finds no matching PSK, it must respond with an appropriate alert message. This ensures that clients are aware of the failure to establish a secure connection with the desired parameters."
105,4.2.11.3.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Processing Order,Importance of PSK Order,"Maintaining the correct order of PSK processing during the handshake is essential for preventing security vulnerabilities. The order ensures that all keys are validated before proceeding with the connection, protecting against potential attacks that exploit misconfigurations in the handshake process."
106,4.3.. Handshake Protocol_Server Parameters,Server Parameters Overview,"The server parameters section of the handshake protocol details the configurations and settings that the server utilizes during the handshake process. This includes the selection of cipher suites, supported versions, and any necessary extensions that facilitate secure communication."
107,4.3.. Handshake Protocol_Server Parameters,Cipher Suite Selection,The server must select a cipher suite from those proposed by the client in the ClientHello message. The selected cipher suite dictates the encryption and hashing algorithms that will be used for the session.
108,4.3.. Handshake Protocol_Server Parameters,Supported Versions,The server indicates its supported protocol versions through the 'supported_versions' extension. This mechanism allows the server to communicate its capabilities to the client and facilitates version negotiation.
109,4.3.. Handshake Protocol_Server Parameters,Extension Requirements,The server's response must include only those extensions that are necessary for establishing the cryptographic context and negotiating the protocol version. Mandatory extensions such as 'supported_versions' must always be included in the ServerHello message.
110,4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,Encrypted Extensions Overview,The Encrypted Extensions message is sent by the server after the ServerHello message and carries additional parameters that are required for the session. This message is crucial for establishing the cryptographic context.
111,4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,Message Structure Definition,"The structure of the Encrypted Extensions message is defined as follows:

    struct {
        Extension extensions<0..2^16-1>;
    } EncryptedExtensions;"
112,4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,Extensions Field Requirements,The extensions field in the Encrypted Extensions message contains a list of extensions that enable the server to communicate additional parameters necessary for the connection. All extensions included must be relevant for establishing the cryptographic context and must not include unnecessary information.
113,4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,Mandatory Extensions,"All TLS 1.3 Encrypted Extensions messages MUST contain the 'supported_versions' extension to specify the version of the protocol being used. Other extensions may include 'pre_shared_key' or 'key_share', depending on the negotiated cipher suite."
114,4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,Protocol Flow and Security,"The Encrypted Extensions message is crucial in the handshake process, following the ServerHello. It helps in ensuring that both parties have a consistent understanding of the parameters agreed upon for the session and plays a role in maintaining the security properties of the protocol."
115,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Certificate Request Purpose,The Certificate Request message is sent by the server to request a certificate from the client during the handshake process. This allows the server to authenticate the client by verifying its certificate.
116,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Message Structure,"struct { 
    uint8 certificate_types<1..2^8-1>;  
    opaque certificate_authorities<0..2^16-1>;  
} CertificateRequest;"
117,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Certificate Types Field,"The certificate_types field specifies the types of certificates that the server accepts from the client. This field includes a list of certificate type values, which are defined in Section 4.2.3."
118,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Certificate Authorities Field,The certificate_authorities field contains a list of distinguished names of acceptable certificate authorities. This allows the client to choose a certificate that is valid and trusted according to the authorities specified by the server.
119,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Client Response Requirements,"Upon receiving a Certificate Request message, the client must respond with a Certificate message containing its certificate if it has one that matches the types and authorities specified by the server. If the client does not have a suitable certificate, it may send an empty Certificate message."
120,4.4.. Handshake Protocol_Authentication Messages,Overview of Authentication Messages,"Authentication messages in the TLS 1.3 handshake protocol are crucial for establishing the identity of the communicating parties. These messages ensure that both the client and server can verify each other's identities through cryptographic methods, contributing to the overall security of the connection."
121,4.4.. Handshake Protocol_Authentication Messages,Types of Authentication Messages,"The primary authentication messages in TLS 1.3 include the Certificate, CertificateRequest, CertificateVerify, and Finished messages. Each of these plays a specific role in the handshake process, facilitating the necessary exchanges for mutual authentication."
122,4.4.. Handshake Protocol_Authentication Messages,Certificate Message,"The Certificate message is sent by the server to provide its public key certificate, which the client uses to verify the server's identity. This message may also contain a chain of certificates if the server's certificate is not directly trusted by the client."
123,4.4.. Handshake Protocol_Authentication Messages,CertificateRequest Message,The CertificateRequest message can be sent by the server to request a certificate from the client. This message is optional and is used when the server requires client authentication.
124,4.4.. Handshake Protocol_Authentication Messages,CertificateVerify Message,The CertificateVerify message is sent by the client to prove ownership of the private key corresponding to the certificate provided in the Certificate message. This message includes a cryptographic signature that verifies the client’s identity.
125,4.4.. Handshake Protocol_Authentication Messages,Finished Message,"The Finished message is the final message in the handshake and signals that the authentication process has been successfully completed. It contains a hash of all previous handshake messages, ensuring that no tampering has occurred."
126,4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Transcript Hash Overview,"The transcript hash is a critical component in the authentication process of the TLS 1.3 handshake. It serves as a cumulative hash of all handshake messages exchanged up to the current point in the handshake. This hash is used to ensure the integrity and authenticity of the messages that have been exchanged, as it allows both parties to verify that they have the same view of the handshake so far."
127,4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Hash Calculation Method,"The transcript hash is calculated using a secure hash function, and it includes all handshake messages that have been sent and received. The specific hash function used is determined by the selected cipher suite. The process involves updating the hash with each handshake message, ensuring that the final hash reflects all messages exchanged prior to the current message."
128,4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Use in Authentication,"During the authentication phase, the transcript hash is used to create the signature for the authentication messages. The signature covers the transcript hash, allowing the parties to confirm that the messages were not altered and were indeed sent by the expected party."
129,4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Implications for Security,"The integrity of the transcript hash is essential for the security of the handshake. Any alteration of the handshake messages will result in a different transcript hash, leading to verification failures and the potential termination of the handshake. This mechanism provides a robust defense against man-in-the-middle attacks and ensures that both parties can trust the authenticity of the exchanged messages."
130,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate Message Purpose,The Certificate message is sent by the server to provide its public key to the client. This message is a crucial part of the authentication process that establishes the identity of the server.
131,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Structure of the Certificate Message,"struct { 
    CertificateList certificate_list; 
} Certificate;"
132,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,CertificateList Definition,"CertificateList is a sequence of certificates, where the first certificate in the list is the server's certificate, and any subsequent certificates are those from the server's certificate chain."
133,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Validation of the Certificate,The client must validate the server's certificate to ensure it is signed by a trusted certificate authority and that it matches the server's domain.
134,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate Usage Requirements,"The Certificate message MUST be sent if the server's authentication method requires a certificate, which is typical in most scenarios for secure communication."
135,4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,OCSP Status Extension Overview,The OCSP (Online Certificate Status Protocol) Status extension allows the client to request the server to provide the OCSP response for the certificate being presented. This extension is crucial for ensuring that the certificate is still valid and has not been revoked.
136,4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,SCT (Signed Certificate Timestamps) Extension Overview,"The SCT extension indicates that the certificate has been logged in a public log for transparency purposes. This is part of the Certificate Transparency framework, which aims to prevent the misuse of certificates."
137,4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,Combined Use of OCSP and SCT Extensions,"When both OCSP Status and SCT extensions are used, the client can verify not only that the certificate is valid but also that it complies with transparency policies. This combination strengthens the overall trust model in certificate validation."
138,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Server Certificate Selection Overview,The server selects its certificate to present to the client during the handshake based on the authentication requirements and the identity of the server. This selection process is crucial for establishing a secure connection.
139,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Certificate Chain Requirements,The server must send a certificate chain that includes its own certificate and any intermediate certificates that establish a chain of trust to a trusted root certificate authority (CA). This ensures the client can verify the server's identity.
140,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Certificate Presentation,"The server sends its selected certificate in the Certificate message as part of the handshake. The certificate must be valid and not expired, and it must match the server's domain name."
141,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Error Handling for Certificate Issues,"If the server cannot present a valid certificate or if the provided certificate does not match the client's expectations, the server must abort the handshake with an appropriate alert message."
142,4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection,Client Certificate Selection Overview,"In the TLS handshake, the client certificate selection process is critical for authenticating the client to the server. This involves the client presenting a certificate that the server can verify as valid and trusted."
143,4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection,Certificate Selection Criteria,The client must choose a certificate that matches the requirements specified by the server. This includes ensuring that the certificate is issued by a trusted Certificate Authority (CA) and that it is valid for the intended purpose.
144,4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection,Certificate Presentation,"Once a suitable certificate is selected, the client presents this certificate to the server as part of the handshake process. The certificate must be sent in the appropriate message type to ensure it is processed correctly by the server."
145,4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection,Validation by the Server,"The server must validate the client certificate upon receipt. This includes checking the certificate chain, verifying the certificate's signature, and ensuring that the certificate has not expired or been revoked."
146,4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection,Error Handling,"If the client fails to provide a valid certificate or if the server cannot validate the presented certificate, the server must respond with an appropriate error alert, indicating the failure in the authentication process."
147,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Certificate Message Reception,"Upon receiving a Certificate message, the recipient must validate the certificate's authenticity and ensure it is trusted. The recipient checks the certificate chain against its trusted certificate authorities (CAs) and verifies that the certificate is not expired or revoked. If the validation fails, the recipient MUST abort the handshake with an 'bad_certificate' alert."
148,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Certificate Chain Validation,"The recipient must validate the entire certificate chain. This involves checking each certificate's signature against the public key of the issuer, ensuring that the chain leads back to a trusted root CA. The validation process must also include checking certificate policies and constraints."
149,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Certificate Revocation Checks,"The recipient should perform revocation checks to ensure that the received certificate has not been revoked. This can be done using methods such as Online Certificate Status Protocol (OCSP) or Certificate Revocation Lists (CRLs). If a certificate is found to be revoked, the handshake MUST be aborted with a 'certificate_revoked' alert."
150,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Handling Invalid Certificates,"If the certificate is deemed invalid for any reason—including issues with signatures, untrusted issuers, or failed revocation checks—the recipient MUST abort the handshake with an appropriate alert, such as 'bad_certificate' or 'unknown_ca'."
151,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Post-Validation Actions,"After successfully validating the certificate, the recipient establishes the identity of the peer and may proceed with the handshake. This could involve additional steps, such as sending a CertificateVerify message if client authentication is required."
152,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Certificate Verify Purpose,The Certificate Verify message is used to provide proof of possession of the private key corresponding to the certificate presented during the handshake. It is crucial for authenticating the identity of the peer.
153,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Message Structure,struct {\n    SignatureAlgorithm algorithm;\n    opaque signature<1..2^16-1>;\n} CertificateVerify;
154,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Algorithm Field,The algorithm field specifies the signature algorithm used to create the signature. This must match one of the algorithms specified in the certificate.
155,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Field Requirements,The signature field contains the signature generated using the private key corresponding to the certificate. It is computed over a hash of the handshake messages exchanged up to this point.
156,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Error Handling,"If the signature verification fails, the recipient MUST abort the handshake with an 'decrypt_error' alert. This ensures that only valid signatures from authenticated peers are accepted."
157,4.4.4.. Handshake Protocol_Authentication Messages_Finished,Finished Message Overview,"The Finished message is the final message in the handshake protocol. It serves to confirm that the handshake was successful and that both parties have established the same cryptographic parameters. The content of the Finished message includes a message authentication code (MAC) that covers all previous handshake messages, ensuring their integrity."
158,4.4.4.. Handshake Protocol_Authentication Messages_Finished,Finished Message Structure,struct {\n    opaque verify_data[verify_data_length];\n} Finished;
159,4.4.4.. Handshake Protocol_Authentication Messages_Finished,Verify Data Calculation,"The verify_data is calculated using the PRF (Pseudo-Random Function) with the 'finished' label, the current handshake context, and the respective random values from both the client and server. This ensures that the Finished message is unique to the session and cannot be reused."
160,4.4.4.. Handshake Protocol_Authentication Messages_Finished,Sending and Receiving Finished Messages,"Upon successfully sending the Finished message, the sender awaits the response from the other party. If the other party does not receive a valid Finished message or the verify_data does not match, it must terminate the connection with an appropriate alert."
161,4.4.4.. Handshake Protocol_Authentication Messages_Finished,Error Handling,"If a Finished message is received that does not validate correctly, the receiving party MUST abort the handshake with an 'decrypt_error' alert. This mechanism helps to ensure that any tampering or failures in previous handshake messages are detected immediately."
162,4.5.. Handshake Protocol_End of Early Data,End of Early Data Overview,The End of Early Data message is sent by the server to indicate the end of the early data phase. This message is crucial for transitioning from early data to the established connection state.
163,4.5.. Handshake Protocol_End of Early Data,Message Structure,The End of Early Data message does not contain any additional fields or data; it is simply a notification that early data processing has concluded.
164,4.5.. Handshake Protocol_End of Early Data,Protocol Behavior,"Upon receiving the End of Early Data message, the client must cease processing early data and transition to the established state. This ensures that any further communication adheres to the negotiated protocol parameters."
165,4.5.. Handshake Protocol_End of Early Data,Error Handling,"If a client receives an End of Early Data message when it is not in the correct state to process it, the client MUST abort the handshake with an 'unexpected_message' alert."
166,4.6.. Handshake Protocol_Post-Handshake Messages,Post-Handshake Messages Overview,Post-handshake messages are used to manage and modify the security parameters established during the initial handshake. These messages can include updates to session parameters or other essential communications needed to maintain the security of the connection.
167,4.6.. Handshake Protocol_Post-Handshake Messages,Key Update Message,"The Key Update message allows either the client or the server to update the keys used for encryption and integrity protection. This is essential for maintaining the security of ongoing sessions, especially in long-lived connections. The Key Update message must be processed in accordance with the current state of the connection."
168,4.6.. Handshake Protocol_Post-Handshake Messages,Encrypted Extensions Message,The Encrypted Extensions message is sent by the server to convey additional extension information that was not included in the ServerHello. This message is crucial for communicating the parameters necessary to establish the secure context of the connection.
169,4.6.. Handshake Protocol_Post-Handshake Messages,Certificate Request Message,The Certificate Request message may be sent by the server to request client authentication. This message indicates that the server requires the client to present a certificate for identity verification during the ongoing session.
170,4.6.. Handshake Protocol_Post-Handshake Messages,Certificate Verify Message,The Certificate Verify message is used by the client to prove possession of the private key corresponding to the certificate presented earlier. This verification is crucial for authenticating the client's identity and ensuring that it is indeed the owner of the certificate.
171,4.6.. Handshake Protocol_Post-Handshake Messages,Finished Message,"The Finished message is sent by both parties to indicate that the handshake is complete and that all previous messages have been processed successfully. This message also includes a hash of all the handshake messages exchanged, ensuring the integrity of the handshake process."
172,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,New Session Ticket Message Overview,The New Session Ticket message is sent by the server to the client to provide the client with a new session ticket after the handshake has been completed. This message allows the client to resume a session at a later time without needing to perform a full handshake.
173,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Structure Definition,"struct {
    uint32 ticket_lifetime;
    uint32 ticket_age_add;
    opaque ticket<1..2^16-1>;
    uint16 max_early_data_size;
    Extension extensions<0..2^16-1>;
} NewSessionTicket;"
174,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Ticket Lifetime Field,"The ticket_lifetime field specifies the total duration (in seconds) for which the session ticket is valid. After this duration, the ticket will no longer be accepted for session resumption."
175,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Ticket Age Add Field,"The ticket_age_add field is an additional value added to the age of the session ticket. This allows the server to control the perceived age of the session ticket, providing flexibility in session management."
176,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Ticket Field,"The ticket field contains the session ticket itself, which is a blob of opaque data that the client will use to resume the session. The contents of this field are determined by the server and can include session state information."
177,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Max Early Data Size Field,The max_early_data_size field indicates the maximum amount of early data (in bytes) that can be sent by the client when resuming this session. This helps prevent abuse of early data in the context of session resumption.
178,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Extensions Field,The extensions field can contain additional information related to the session ticket. This may include extensions that provide further context or options for session resumption.
179,4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Post-Handshake Authentication Purpose,Post-handshake authentication is a mechanism in TLS 1.3 that allows for authentication to occur after the initial handshake has concluded. This feature is particularly useful in scenarios where the server requires additional proof of identity from the client after the handshake.
180,4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Message Flow,The post-handshake authentication messages are exchanged following the completion of the handshake. This ensures that both parties have already established a secure session before any further authentication is performed.
181,4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Client Authentication,"In scenarios requiring client authentication, the server may request a certificate from the client after the handshake. The client must respond with its certificate and a corresponding signature to prove its identity."
182,4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Server Authentication,"Similarly, the client may request the server to re-authenticate after the initial handshake, particularly if a change in session context occurs. The server must provide its certificate and a signature to confirm its identity."
183,4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Error Handling,"If any errors occur during the post-handshake authentication process, such as an invalid certificate or signature, the session must be aborted with an appropriate alert message."
184,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Post-Handshake Key and IV Update Overview,This section describes the procedures for updating the keys and initialization vectors (IVs) after the TLS handshake has been completed. Such updates are essential to maintain security throughout the session.
185,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Key Update Mechanism,"The key update mechanism allows either party to request a key update at any time during the session. This is accomplished through the transmission of a KeyUpdate message, which indicates whether the update is intended for the sender or the receiver."
186,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Initialization Vector (IV) Specifications,The initialization vector used for the encryption must be updated alongside the keys. The new IV should be generated using a secure random number generator and must adhere to the specifications outlined in the selected cipher suite.
187,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Message Format for KeyUpdate,"The KeyUpdate message comprises a single field indicating the type of update. The format is as follows:

    struct {
        enum { update_not_requested(0), update_requested(1), (255) } update_type;
    } KeyUpdate;"
188,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Error Handling for Key Updates,"If a key update is received that is unexpected or not valid according to the current state of the session, the recipient MUST abort the connection with an appropriate alert. This includes scenarios where the update does not conform to negotiated parameters."
