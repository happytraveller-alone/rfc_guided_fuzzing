index,section,content,result
1,4.. Handshake Protocol,"The handshake protocol is used to negotiate the security parameters
   of a connection.  Handshake messages are supplied to the TLS record
   layer, where they are encapsulated within one or more TLSPlaintext or
   TLSCiphertext structures which are processed and transmitted as
   specified by the current active connection state.

      enum {
          client_hello(1),
          server_hello(2),
          new_session_ticket(4),
          end_of_early_data(5),
          encrypted_extensions(8),
          certificate(11),
          certificate_request(13),
          certificate_verify(15),
          finished(20),
          key_update(24),
          message_hash(254),
          (255)
      } HandshakeType;

      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* remaining bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;
              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
          };
      } Handshake;

   Protocol messages MUST be sent in the order defined in Section 4.4.1
   and shown in the diagrams in Section 2.  A peer which receives a
   handshake message in an unexpected order MUST abort the handshake
   with an ""unexpected_message"" alert.

   New handshake message types are assigned by IANA as described in
   Section 11.","[
  {
    ""section_name"": ""4.. Handshake Protocol"",
    ""title"": ""Handshake Protocol Overview"",
    ""content"": ""The handshake protocol is used to negotiate the security parameters of a connection. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext or TLSCiphertext structures which are processed and transmitted as specified by the current active connection state.""
  },
  {
    ""section_name"": ""4.. Handshake Protocol"",
    ""title"": ""Handshake Message Types Enumeration"",
    ""content"": ""enum {\n    client_hello(1),\n    server_hello(2),\n    new_session_ticket(4),\n    end_of_early_data(5),\n    encrypted_extensions(8),\n    certificate(11),\n    certificate_request(13),\n    certificate_verify(15),\n    finished(20),\n    key_update(24),\n    message_hash(254),\n    (255)\n} HandshakeType;""
  },
  {
    ""section_name"": ""4.. Handshake Protocol"",
    ""title"": ""Handshake Message Structure"",
    ""content"": ""struct {\n    HandshakeType msg_type;    /* handshake type */\n    uint24 length;             /* remaining bytes in message */\n    select (Handshake.msg_type) {\n        case client_hello:          ClientHello;\n        case server_hello:          ServerHello;\n        case end_of_early_data:     EndOfEarlyData;\n        case encrypted_extensions:  EncryptedExtensions;\n        case certificate_request:   CertificateRequest;\n        case certificate:           Certificate;\n        case certificate_verify:    CertificateVerify;\n        case finished:              Finished;\n        case new_session_ticket:    NewSessionTicket;\n        case key_update:            KeyUpdate;\n    };\n} Handshake;""
  },
  {
    ""section_name"": ""4.. Handshake Protocol"",
    ""title"": ""Message Order and Error Handling"",
    ""content"": ""Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2. A peer which receives a handshake message in an unexpected order MUST abort the handshake with an \""unexpected_message\"" alert.""
  },
  {
    ""section_name"": ""4.. Handshake Protocol"",
    ""title"": ""IANA Message Type Assignments"",
    ""content"": ""New handshake message types are assigned by IANA as described in Section 11.""
  }
]"
2,4.1.. Handshake Protocol_Key Exchange Messages,"The key exchange messages are used to determine the security
   capabilities of the client and the server and to establish shared
   secrets, including the traffic keys used to protect the rest of the
   handshake and the data.","[
  {
    ""section_name"": ""4.1.. Handshake Protocol_Key Exchange Messages"",
    ""title"": ""Key Exchange Messages Overview"",
    ""content"": ""The key exchange messages are used to determine the security capabilities of the client and the server and to establish shared secrets, including the traffic keys used to protect the rest of the handshake and the data.""
  }
]"
3,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,"In TLS, the cryptographic negotiation proceeds by the client offering
   the following four sets of options in its ClientHello:

   -  A list of cipher suites which indicates the AEAD algorithm/HKDF
      hash pairs which the client supports.

   -  A ""supported_groups"" (Section 4.2.7) extension which indicates the
      (EC)DHE groups which the client supports and a ""key_share""
      (Section 4.2.8) extension which contains (EC)DHE shares for some
      or all of these groups.

   -  A ""signature_algorithms"" (Section 4.2.3) extension which indicates
      the signature algorithms which the client can accept.  A
      ""signature_algorithms_cert"" extension (Section 4.2.3) may also be
      added to indicate certificate-specific signature algorithms.

   -  A ""pre_shared_key"" (Section 4.2.11) extension which contains a
      list of symmetric key identities known to the client and a
      ""psk_key_exchange_modes"" (Section 4.2.9) extension which indicates
      the key exchange modes that may be used with PSKs.

   If the server does not select a PSK, then the first three of these
   options are entirely orthogonal: the server independently selects a
   cipher suite, an (EC)DHE group and key share for key establishment,
   and a signature algorithm/certificate pair to authenticate itself to
   the client.  If there is no overlap between the received
   ""supported_groups"" and the groups supported by the server, then the
   server MUST abort the handshake with a ""handshake_failure"" or an
   ""insufficient_security"" alert.

   If the server selects a PSK, then it MUST also select a key
   establishment mode from the set indicated by the client's
   ""psk_key_exchange_modes"" extension (at present, PSK alone or with
   (EC)DHE).  Note that if the PSK can be used without (EC)DHE, then
   non-overlap in the ""supported_groups"" parameters need not be fatal,
   as it is in the non-PSK case discussed in the previous paragraph.

   If the server selects an (EC)DHE group and the client did not offer a
   compatible ""key_share"" extension in the initial ClientHello, the
   server MUST respond with a HelloRetryRequest (Section 4.1.4) message.

   If the server successfully selects parameters and does not require a
   HelloRetryRequest, it indicates the selected parameters in the
   ServerHello as follows:

   -  If PSK is being used, then the server will send a ""pre_shared_key""
      extension indicating the selected key.

   -  When (EC)DHE is in use, the server will also provide a ""key_share""
      extension.  If PSK is not being used, then (EC)DHE and
      certificate-based authentication are always used.

   -  When authenticating via a certificate, the server will send the
      Certificate (Section 4.4.2) and CertificateVerify (Section 4.4.3)
      messages.  In TLS 1.3 as defined by this document, either a PSK or
      a certificate is always used, but not both.  Future documents may
      define how to use them together.

   If the server is unable to negotiate a supported set of parameters
   (i.e., there is no overlap between the client and server parameters),
   it MUST abort the handshake with either a ""handshake_failure"" or
   ""insufficient_security"" fatal alert (see Section 6).","[
  {
    ""section_name"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""Cryptographic Negotiation Overview"",
    ""content"": ""In TLS, the cryptographic negotiation proceeds by the client offering four sets of options in its ClientHello: a list of cipher suites, a 'supported_groups' extension, a 'signature_algorithms' extension, and a 'pre_shared_key' extension.""
  },
  {
    ""section_name"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""Cipher Suites"",
    ""content"": ""The client offers a list of cipher suites which indicates the AEAD algorithm/HKDF hash pairs that it supports.""
  },
  {
    ""section_name"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""Supported Groups and Key Share Extensions"",
    ""content"": ""The client includes a 'supported_groups' extension which indicates the (EC)DHE groups it supports, and a 'key_share' extension which contains (EC)DHE shares for some or all of these groups.""
  },
  {
    ""section_name"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""Signature Algorithms"",
    ""content"": ""The client can also offer a 'signature_algorithms' extension indicating the signature algorithms it can accept. Additionally, a 'signature_algorithms_cert' extension may be included for certificate-specific signature algorithms.""
  },
  {
    ""section_name"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""Pre-Shared Key Extensions"",
    ""content"": ""The client may include a 'pre_shared_key' extension containing a list of symmetric key identities known to the client, along with a 'psk_key_exchange_modes' extension indicating the key exchange modes that may be used with PSKs.""
  },
  {
    ""section_name"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""Server Parameter Selection"",
    ""content"": ""If the server does not select a PSK, it independently selects a cipher suite, an (EC)DHE group and key share, and a signature algorithm/certificate pair. If there is no overlap in 'supported_groups', the server MUST abort the handshake with a 'handshake_failure' or 'insufficient_security' alert.""
  },
  {
    ""section_name"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""PSK Selection"",
    ""content"": ""If the server selects a PSK, it MUST also select a key establishment mode from the client's 'psk_key_exchange_modes' extension. If the PSK can be used without (EC)DHE, non-overlap in 'supported_groups' is not fatal.""
  },
  {
    ""section_name"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""HelloRetryRequest Requirement"",
    ""content"": ""If the server selects an (EC)DHE group and the client did not offer a compatible 'key_share', the server MUST respond with a HelloRetryRequest message.""
  },
  {
    ""section_name"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""ServerHello Parameter Indication"",
    ""content"": ""If the server successfully selects parameters without requiring a HelloRetryRequest, it indicates the selected parameters in the ServerHello. If PSK is used, a 'pre_shared_key' extension is sent. When (EC)DHE is in use, a 'key_share' extension is also provided.""
  },
  {
    ""section_name"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""Certificate Authentication"",
    ""content"": ""When authenticating via a certificate, the server sends the Certificate and CertificateVerify messages. In TLS 1.3, either a PSK or a certificate is used, but not both.""
  },
  {
    ""section_name"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""Handshake Failure Conditions"",
    ""content"": ""If the server is unable to negotiate a supported set of parameters, it MUST abort the handshake with a 'handshake_failure' or 'insufficient_security' fatal alert.""
  }
]"
4,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,"When a client first connects to a server, it is REQUIRED to send the
   ClientHello as its first TLS message.  The client will also send a
   ClientHello when the server has responded to its ClientHello with a
   HelloRetryRequest.  In that case, the client MUST send the same
   ClientHello without modification, except as follows:

   -  If a ""key_share"" extension was supplied in the HelloRetryRequest,
      replacing the list of shares with a list containing a single
      KeyShareEntry from the indicated group.

   -  Removing the ""early_data"" extension (Section 4.2.10) if one was
      present.  Early data is not permitted after a HelloRetryRequest.

   -  Including a ""cookie"" extension if one was provided in the
      HelloRetryRequest.

   -  Updating the ""pre_shared_key"" extension if present by recomputing
      the ""obfuscated_ticket_age"" and binder values and (optionally)
      removing any PSKs which are incompatible with the server's
      indicated cipher suite.

   -  Optionally adding, removing, or changing the length of the
      ""padding"" extension [RFC7685].

   -  Other modifications that may be allowed by an extension defined in
      the future and present in the HelloRetryRequest.

   Because TLS 1.3 forbids renegotiation, if a server has negotiated
   TLS 1.3 and receives a ClientHello at any other time, it MUST
   terminate the connection with an ""unexpected_message"" alert.

   If a server established a TLS connection with a previous version of
   TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST
   retain the previous protocol version.  In particular, it MUST NOT
   negotiate TLS 1.3.

   Structure of this message:

      uint16 ProtocolVersion;
      opaque Random[32];

      uint8 CipherSuite[2];    /* Cryptographic suite selector */

      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id<0..32>;
          CipherSuite cipher_suites<2..2^16-2>;
          opaque legacy_compression_methods<1..2^8-1>;
          Extension extensions<8..2^16-1>;
      } ClientHello;

   legacy_version:  In previous versions of TLS, this field was used for
      version negotiation and represented the highest version number
      supported by the client.  Experience has shown that many servers
      do not properly implement version negotiation, leading to ""version
      intolerance"" in which the server rejects an otherwise acceptable
      ClientHello with a version number higher than it supports.  In
      TLS 1.3, the client indicates its version preferences in the
      ""supported_versions"" extension (Section 4.2.1) and the
      legacy_version field MUST be set to 0x0303, which is the version
      number for TLS 1.2.  TLS 1.3 ClientHellos are identified as having
      a legacy_version of 0x0303 and a supported_versions extension
      present with 0x0304 as the highest version indicated therein.
      (See Appendix D for details about backward compatibility.)

   random:  32 bytes generated by a secure random number generator.  See
      Appendix C for additional information.

   legacy_session_id:  Versions of TLS before TLS 1.3 supported a
      ""session resumption"" feature which has been merged with pre-shared
      keys in this version (see Section 2.2).  A client which has a
      cached session ID set by a pre-TLS 1.3 server SHOULD set this
      field to that value.  In compatibility mode (see Appendix D.4),
      this field MUST be non-empty, so a client not offering a
      pre-TLS 1.3 session MUST generate a new 32-byte value.  This value
      need not be random but SHOULD be unpredictable to avoid
      implementations fixating on a specific value (also known as
      ossification).  Otherwise, it MUST be set as a zero-length vector
      (i.e., a zero-valued single byte length field).

   cipher_suites:  A list of the symmetric cipher options supported by
      the client, specifically the record protection algorithm
      (including secret key length) and a hash to be used with HKDF, in
      descending order of client preference.  Values are defined in
      Appendix B.4.  If the list contains cipher suites that the server
      does not recognize, support, or wish to use, the server MUST
      ignore those cipher suites and process the remaining ones as
      usual.  If the client is attempting a PSK key establishment, it
      SHOULD advertise at least one cipher suite indicating a Hash
      associated with the PSK.

   legacy_compression_methods:  Versions of TLS before 1.3 supported
      compression with the list of supported compression methods being
      sent in this field.  For every TLS 1.3 ClientHello, this vector
      MUST contain exactly one byte, set to zero, which corresponds to
      the ""null"" compression method in prior versions of TLS.  If a
      TLS 1.3 ClientHello is received with any other value in this
      field, the server MUST abort the handshake with an
      ""illegal_parameter"" alert.  Note that TLS 1.3 servers might
      receive TLS 1.2 or prior ClientHellos which contain other
      compression methods and (if negotiating such a prior version) MUST
      follow the procedures for the appropriate prior version of TLS.

   extensions:  Clients request extended functionality from servers by
      sending data in the extensions field.  The actual ""Extension""
      format is defined in Section 4.2.  In TLS 1.3, the use of certain
      extensions is mandatory, as functionality has moved into
      extensions to preserve ClientHello compatibility with previous
      versions of TLS.  Servers MUST ignore unrecognized extensions.

   All versions of TLS allow an extensions field to optionally follow
   the compression_methods field.  TLS 1.3 ClientHello messages always
   contain extensions (minimally ""supported_versions"", otherwise, they
   will be interpreted as TLS 1.2 ClientHello messages).  However,
   TLS 1.3 servers might receive ClientHello messages without an
   extensions field from prior versions of TLS.  The presence of
   extensions can be detected by determining whether there are bytes
   following the compression_methods field at the end of the
   ClientHello.  Note that this method of detecting optional data
   differs from the normal TLS method of having a variable-length field,
   but it is used for compatibility with TLS before extensions were
   defined.  TLS 1.3 servers will need to perform this check first and
   only attempt to negotiate TLS 1.3 if the ""supported_versions""
   extension is present.  If negotiating a version of TLS prior to 1.3,
   a server MUST check that the message either contains no data after
   legacy_compression_methods or that it contains a valid extensions
   block with no data following.  If not, then it MUST abort the
   handshake with a ""decode_error"" alert.

   In the event that a client requests additional functionality using
   extensions and this functionality is not supplied by the server, the
   client MAY abort the handshake.

   After sending the ClientHello message, the client waits for a
   ServerHello or HelloRetryRequest message.  If early data is in use,
   the client may transmit early Application Data (Section 2.3) while
   waiting for the next handshake message.","[
  {
    ""section_name"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""ClientHello Message Overview"",
    ""content"": ""When a client first connects to a server, it is REQUIRED to send the ClientHello as its first TLS message. The client will also send a ClientHello when the server has responded to its ClientHello with a HelloRetryRequest. In that case, the client MUST send the same ClientHello without modification, except as follows: - If a \""key_share\"" extension was supplied in the HelloRetryRequest, replacing the list of shares with a list containing a single KeyShareEntry from the indicated group. - Removing the \""early_data\"" extension if one was present. Early data is not permitted after a HelloRetryRequest. - Including a \""cookie\"" extension if one was provided in the HelloRetryRequest. - Updating the \""pre_shared_key\"" extension if present by recomputing the \""obfuscated_ticket_age\"" and binder values and (optionally) removing any PSKs which are incompatible with the server's indicated cipher suite. - Optionally adding, removing, or changing the length of the \""padding\"" extension [RFC7685]. - Other modifications that may be allowed by an extension defined in the future and present in the HelloRetryRequest.""
  },
  {
    ""section_name"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""Connection Termination Rules"",
    ""content"": ""Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an \""unexpected_message\"" alert. If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version. In particular, it MUST NOT negotiate TLS 1.3.""
  },
  {
    ""section_name"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""ClientHello Message Structure"",
    ""content"": ""Structure of this message: uint16 ProtocolVersion; opaque Random[32]; uint8 CipherSuite[2]; struct { ProtocolVersion legacy_version = 0x0303; /* TLS v1.2 */ Random random; opaque legacy_session_id<0..32>; CipherSuite cipher_suites<2..2^16-2>; opaque legacy_compression_methods<1..2^8-1>; Extension extensions<8..2^16-1>; } ClientHello;""
  },
  {
    ""section_name"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""Field Descriptions"",
    ""content"": ""1. legacy_version: Set to 0x0303 (TLS v1.2) for compatibility with middleboxes. The actual version is indicated using the \""supported_versions\"" extension. 2. random: 32 bytes generated by a secure random number generator. 3. legacy_session_id: A cached session ID from a pre-TLS 1.3 server, or a new unpredictable value if none exists. 4. cipher_suites: A list of symmetric cipher options supported by the client. 5. legacy_compression_methods: Must contain exactly one byte, set to zero. 6. extensions: Clients request extended functionality from servers by sending data in the extensions field.""
  },
  {
    ""section_name"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""Extension Handling"",
    ""content"": ""Clients request extended functionality from servers by sending data in the extensions field. In TLS 1.3, the use of certain extensions is mandatory, and servers MUST ignore unrecognized extensions. TLS 1.3 ClientHello messages always contain extensions, minimally the \""supported_versions\"" extension.""
  },
  {
    ""section_name"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""Message Reception and Processing"",
    ""content"": ""After sending the ClientHello message, the client waits for a ServerHello or HelloRetryRequest message. If early data is in use, the client may transmit early Application Data while waiting for the next handshake message.""
  }
]"
5,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,"The server will send this message in response to a ClientHello
   message to proceed with the handshake if it is able to negotiate an
   acceptable set of handshake parameters based on the ClientHello.

   Structure of this message:

      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id_echo<0..32>;
          CipherSuite cipher_suite;
          uint8 legacy_compression_method = 0;
          Extension extensions<6..2^16-1>;
      } ServerHello;

   legacy_version:  In previous versions of TLS, this field was used for
      version negotiation and represented the selected version number
      for the connection.  Unfortunately, some middleboxes fail when
      presented with new values.  In TLS 1.3, the TLS server indicates
      its version using the ""supported_versions"" extension
      (Section 4.2.1), and the legacy_version field MUST be set to
      0x0303, which is the version number for TLS 1.2.  (See Appendix D
      for details about backward compatibility.)

   random:  32 bytes generated by a secure random number generator.  See
      Appendix C for additional information.  The last 8 bytes MUST be
      overwritten as described below if negotiating TLS 1.2 or TLS 1.1,
      but the remaining bytes MUST be random.  This structure is
      generated by the server and MUST be generated independently of the
      ClientHello.random.

   legacy_session_id_echo:  The contents of the client's
      legacy_session_id field.  Note that this field is echoed even if
      the client's value corresponded to a cached pre-TLS 1.3 session
      which the server has chosen not to resume.  A client which
      receives a legacy_session_id_echo field that does not match what
      it sent in the ClientHello MUST abort the handshake with an
      ""illegal_parameter"" alert.

   cipher_suite:  The single cipher suite selected by the server from
      the list in ClientHello.cipher_suites.  A client which receives a
      cipher suite that was not offered MUST abort the handshake with an
      ""illegal_parameter"" alert.

   legacy_compression_method:  A single byte which MUST have the
      value 0.

   extensions:  A list of extensions.  The ServerHello MUST only include
      extensions which are required to establish the cryptographic
      context and negotiate the protocol version.  All TLS 1.3
      ServerHello messages MUST contain the ""supported_versions""
      extension.  Current ServerHello messages additionally contain
      either the ""pre_shared_key"" extension or the ""key_share""
      extension, or both (when using a PSK with (EC)DHE key
      establishment).  Other extensions (see Section 4.2) are sent
      separately in the EncryptedExtensions message.

   For reasons of backward compatibility with middleboxes (see
   Appendix D.4), the HelloRetryRequest message uses the same structure
   as the ServerHello, but with Random set to the special value of the
   SHA-256 of ""HelloRetryRequest"":

     CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91
     C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C

   Upon receiving a message with type server_hello, implementations MUST
   first examine the Random value and, if it matches this value, process
   it as described in Section 4.1.4).

   TLS 1.3 has a downgrade protection mechanism embedded in the server's
   random value.  TLS 1.3 servers which negotiate TLS 1.2 or below in
   response to a ClientHello MUST set the last 8 bytes of their Random
   value specially in their ServerHello.

   If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of
   their Random value to the bytes:

     44 4F 57 4E 47 52 44 01

   If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2
   servers SHOULD, set the last 8 bytes of their ServerHello.Random
   value to the bytes:

     44 4F 57 4E 47 52 44 00

   TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below
   MUST check that the last 8 bytes are not equal to either of these
   values.  TLS 1.2 clients SHOULD also check that the last 8 bytes are
   not equal to the second value if the ServerHello indicates TLS 1.1 or
   below.  If a match is found, the client MUST abort the handshake with
   an ""illegal_parameter"" alert.  This mechanism provides limited
   protection against downgrade attacks over and above what is provided
   by the Finished exchange: because the ServerKeyExchange, a message
   present in TLS 1.2 and below, includes a signature over both random
   values, it is not possible for an active attacker to modify the

   random values without detection as long as ephemeral ciphers are
   used.  It does not provide downgrade protection when static RSA
   is used.

   Note: This is a change from [RFC5246], so in practice many TLS 1.2
   clients and servers will not behave as specified above.

   A legacy TLS client performing renegotiation with TLS 1.2 or prior
   and which receives a TLS 1.3 ServerHello during renegotiation MUST
   abort the handshake with a ""protocol_version"" alert.  Note that
   renegotiation is not possible when TLS 1.3 has been negotiated.","[
  {
    ""section_name"": ""4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello"",
    ""title"": ""ServerHello Message Overview"",
    ""content"": ""The server will send this message in response to a ClientHello message to proceed with the handshake if it is able to negotiate an acceptable set of handshake parameters based on the ClientHello.""
  },
  {
    ""section_name"": ""4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello"",
    ""title"": ""ServerHello Message Structure"",
    ""content"": ""struct {\n    ProtocolVersion legacy_version = 0x0303; /* TLS v1.2 */\n    Random random;\n    opaque legacy_session_id_echo<0..32>;\n    CipherSuite cipher_suite;\n    uint8 legacy_compression_method = 0;\n    Extension extensions<6..2^16-1>;\n} ServerHello;""
  },
  {
    ""section_name"": ""4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello"",
    ""title"": ""Field Descriptions"",
    ""content"": ""1. **legacy_version**: Set to 0x0303 (TLS v1.2) for compatibility with middleboxes. The actual version is indicated using the \""supported_versions\"" extension.\n\n2. **random**: 32 bytes generated by a secure random number generator. The last 8 bytes must be overwritten if negotiating TLS 1.2 or TLS 1.1, while the rest must be random.\n\n3. **legacy_session_id_echo**: Echoes the client's legacy_session_id. If this does not match the client's sent value, the handshake must abort with an \""illegal_parameter\"" alert.\n\n4. **cipher_suite**: The selected cipher suite from the ClientHello. If not offered, the handshake must abort with an \""illegal_parameter\"" alert.\n\n5. **legacy_compression_method**: Must be set to 0.\n\n6. **extensions**: Must include only those necessary for establishing the cryptographic context. All TLS 1.3 ServerHello messages must contain the \""supported_versions\"" extension.""
  },
  {
    ""section_name"": ""4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello"",
    ""title"": ""HelloRetryRequest Compatibility"",
    ""content"": ""The HelloRetryRequest message uses the same structure as the ServerHello, but with Random set to the SHA-256 of \""HelloRetryRequest\"":\n\nCF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91\nC2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C.""
  },
  {
    ""section_name"": ""4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello"",
    ""title"": ""Downgrade Protection Mechanism"",
    ""content"": ""TLS 1.3 has a downgrade protection mechanism embedded in the server's random value. If negotiating TLS 1.2, the last 8 bytes of the Random value must be set to:\n\n44 4F 57 4E 47 52 44 01\n\nIf negotiating TLS 1.1 or below, they should be set to:\n\n44 4F 57 4E 47 52 44 00.\n\nClients must check these values and abort the handshake with an \""illegal_parameter\"" alert if they match.""
  },
  {
    ""section_name"": ""4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello"",
    ""title"": ""Renegotiation Handling"",
    ""content"": ""A legacy TLS client performing renegotiation with TLS 1.2 or prior that receives a TLS 1.3 ServerHello during renegotiation must abort the handshake with a \""protocol_version\"" alert. Note that renegotiation is not possible when TLS 1.3 has been negotiated.""
  }
]"
6,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,"The server will send this message in response to a ClientHello
   message if it is able to find an acceptable set of parameters but the
   ClientHello does not contain sufficient information to proceed with
   the handshake.  As discussed in Section 4.1.3, the HelloRetryRequest
   has the same format as a ServerHello message, and the legacy_version,
   legacy_session_id_echo, cipher_suite, and legacy_compression_method
   fields have the same meaning.  However, for convenience we discuss
   ""HelloRetryRequest"" throughout this document as if it were a distinct
   message.

   The server's extensions MUST contain ""supported_versions"".
   Additionally, it SHOULD contain the minimal set of extensions
   necessary for the client to generate a correct ClientHello pair.  As
   with the ServerHello, a HelloRetryRequest MUST NOT contain any
   extensions that were not first offered by the client in its
   ClientHello, with the exception of optionally the ""cookie"" (see
   Section 4.2.2) extension.

   Upon receipt of a HelloRetryRequest, the client MUST check the
   legacy_version, legacy_session_id_echo, cipher_suite, and
   legacy_compression_method as specified in Section 4.1.3 and then
   process the extensions, starting with determining the version using
   ""supported_versions"".  Clients MUST abort the handshake with an
   ""illegal_parameter"" alert if the HelloRetryRequest would not result
   in any change in the ClientHello.  If a client receives a second
   HelloRetryRequest in the same connection (i.e., where the ClientHello
   was itself in response to a HelloRetryRequest), it MUST abort the
   handshake with an ""unexpected_message"" alert.

   Otherwise, the client MUST process all extensions in the
   HelloRetryRequest and send a second updated ClientHello.  The
   HelloRetryRequest extensions defined in this specification are:

   -  supported_versions (see Section 4.2.1)

   -  cookie (see Section 4.2.2)

   -  key_share (see Section 4.2.8)

   A client which receives a cipher suite that was not offered MUST
   abort the handshake.  Servers MUST ensure that they negotiate the
   same cipher suite when receiving a conformant updated ClientHello (if
   the server selects the cipher suite as the first step in the
   negotiation, then this will happen automatically).  Upon receiving
   the ServerHello, clients MUST check that the cipher suite supplied in
   the ServerHello is the same as that in the HelloRetryRequest and
   otherwise abort the handshake with an ""illegal_parameter"" alert.

   In addition, in its updated ClientHello, the client SHOULD NOT offer
   any pre-shared keys associated with a hash other than that of the
   selected cipher suite.  This allows the client to avoid having to
   compute partial hash transcripts for multiple hashes in the second
   ClientHello.

   The value of selected_version in the HelloRetryRequest
   ""supported_versions"" extension MUST be retained in the ServerHello,
   and a client MUST abort the handshake with an ""illegal_parameter""
   alert if the value changes.","[
  {
    ""section_name"": ""4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request"",
    ""title"": ""HelloRetryRequest Overview"",
    ""content"": ""The server will send this message in response to a ClientHello message if it is able to find an acceptable set of parameters but the ClientHello does not contain sufficient information to proceed with the handshake. The HelloRetryRequest has the same format as a ServerHello message, and the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields have the same meaning. However, for convenience, this document discusses 'HelloRetryRequest' as if it were a distinct message.""
  },
  {
    ""section_name"": ""4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request"",
    ""title"": ""Extensions Requirements"",
    ""content"": ""The server's extensions MUST contain 'supported_versions'. Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair. A HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the 'cookie' extension.""
  },
  {
    ""section_name"": ""4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request"",
    ""title"": ""Client Processing of HelloRetryRequest"",
    ""content"": ""Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using 'supported_versions'. Clients MUST abort the handshake with an 'illegal_parameter' alert if the HelloRetryRequest would not result in any change in the ClientHello. If a client receives a second HelloRetryRequest in the same connection, it MUST abort the handshake with an 'unexpected_message' alert.""
  },
  {
    ""section_name"": ""4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request"",
    ""title"": ""Extension Processing and Updated ClientHello"",
    ""content"": ""Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello. The HelloRetryRequest extensions defined in this specification are: - supported_versions (see Section 4.2.1) - cookie (see Section 4.2.2) - key_share (see Section 4.2.8). A client which receives a cipher suite that was not offered MUST abort the handshake.""
  },
  {
    ""section_name"": ""4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request"",
    ""title"": ""Cipher Suite Negotiation"",
    ""content"": ""Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello. Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an 'illegal_parameter' alert.""
  },
  {
    ""section_name"": ""4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request"",
    ""title"": ""Pre-shared Key Considerations"",
    ""content"": ""In its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite. This allows the client to avoid having to compute partial hash transcripts for multiple hashes in the second ClientHello.""
  },
  {
    ""section_name"": ""4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request"",
    ""title"": ""Version Retention in ServerHello"",
    ""content"": ""The value of selected_version in the HelloRetryRequest 'supported_versions' extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an 'illegal_parameter' alert if the value changes.""
  }
]"
7,4.2.. Handshake Protocol_Extensions,"A number of TLS messages contain tag-length-value encoded extensions
   structures.

    struct {
        ExtensionType extension_type;
        opaque extension_data<0..2^16-1>;
    } Extension;

    enum {
        server_name(0),                             /* RFC 6066 */
        max_fragment_length(1),                     /* RFC 6066 */
        status_request(5),                          /* RFC 6066 */
        supported_groups(10),                       /* RFC 8422, 7919 */
        signature_algorithms(13),                   /* RFC 8446 */
        use_srtp(14),                               /* RFC 5764 */
        heartbeat(15),                              /* RFC 6520 */
        application_layer_protocol_negotiation(16), /* RFC 7301 */
        signed_certificate_timestamp(18),           /* RFC 6962 */
        client_certificate_type(19),                /* RFC 7250 */
        server_certificate_type(20),                /* RFC 7250 */
        padding(21),                                /* RFC 7685 */
        pre_shared_key(41),                         /* RFC 8446 */
        early_data(42),                             /* RFC 8446 */
        supported_versions(43),                     /* RFC 8446 */
        cookie(44),                                 /* RFC 8446 */
        psk_key_exchange_modes(45),                 /* RFC 8446 */
        certificate_authorities(47),                /* RFC 8446 */
        oid_filters(48),                            /* RFC 8446 */
        post_handshake_auth(49),                    /* RFC 8446 */
        signature_algorithms_cert(50),              /* RFC 8446 */
        key_share(51),                              /* RFC 8446 */
        (65535)
    } ExtensionType;

   Here:

   -  ""extension_type"" identifies the particular extension type.

   -  ""extension_data"" contains information specific to the particular
      extension type.

   The list of extension types is maintained by IANA as described in
   Section 11.

   Extensions are generally structured in a request/response fashion,
   though some extensions are just indications with no corresponding
   response.  The client sends its extension requests in the ClientHello
   message, and the server sends its extension responses in the
   ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate
   messages.  The server sends extension requests in the
   CertificateRequest message which a client MAY respond to with a
   Certificate message.  The server MAY also send unsolicited extensions
   in the NewSessionTicket, though the client does not respond directly
   to these.

   Implementations MUST NOT send extension responses if the remote
   endpoint did not send the corresponding extension requests, with the
   exception of the ""cookie"" extension in the HelloRetryRequest.  Upon
   receiving such an extension, an endpoint MUST abort the handshake
   with an ""unsupported_extension"" alert.

   The table below indicates the messages where a given extension may
   appear, using the following notation: CH (ClientHello),
   SH (ServerHello), EE (EncryptedExtensions), CT (Certificate),
   CR (CertificateRequest), NST (NewSessionTicket), and
   HRR (HelloRetryRequest).  If an implementation receives an extension
   which it recognizes and which is not specified for the message in
   which it appears, it MUST abort the handshake with an
   ""illegal_parameter"" alert.

   +--------------------------------------------------+-------------+
   | Extension                                        |     TLS 1.3 |
   +--------------------------------------------------+-------------+
   | server_name [RFC6066]                            |      CH, EE |
   |                                                  |             |
   | max_fragment_length [RFC6066]                    |      CH, EE |
   |                                                  |             |
   | status_request [RFC6066]                         |  CH, CR, CT |
   |                                                  |             |
   | supported_groups [RFC7919]                       |      CH, EE |
   |                                                  |             |
   | signature_algorithms (RFC 8446)                  |      CH, CR |
   |                                                  |             |
   | use_srtp [RFC5764]                               |      CH, EE |
   |                                                  |             |
   | heartbeat [RFC6520]                              |      CH, EE |
   |                                                  |             |
   | application_layer_protocol_negotiation [RFC7301] |      CH, EE |
   |                                                  |             |
   | signed_certificate_timestamp [RFC6962]           |  CH, CR, CT |
   |                                                  |             |
   | client_certificate_type [RFC7250]                |      CH, EE |
   |                                                  |             |
   | server_certificate_type [RFC7250]                |      CH, EE |
   |                                                  |             |
   | padding [RFC7685]                                |          CH |
   |                                                  |             |
   | key_share (RFC 8446)                             | CH, SH, HRR |
   |                                                  |             |
   | pre_shared_key (RFC 8446)                        |      CH, SH |
   |                                                  |             |
   | psk_key_exchange_modes (RFC 8446)                |          CH |
   |                                                  |             |
   | early_data (RFC 8446)                            | CH, EE, NST |
   |                                                  |             |
   | cookie (RFC 8446)                                |     CH, HRR |
   |                                                  |             |
   | supported_versions (RFC 8446)                    | CH, SH, HRR |
   |                                                  |             |
   | certificate_authorities (RFC 8446)               |      CH, CR |
   |                                                  |             |
   | oid_filters (RFC 8446)                           |          CR |
   |                                                  |             |
   | post_handshake_auth (RFC 8446)                   |          CH |
   |                                                  |             |
   | signature_algorithms_cert (RFC 8446)             |      CH, CR |
   +--------------------------------------------------+-------------+

   When multiple extensions of different types are present, the
   extensions MAY appear in any order, with the exception of
   ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in
   the ClientHello (but can appear anywhere in the ServerHello
   extensions block).  There MUST NOT be more than one extension of the
   same type in a given extension block.

   In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each
   handshake even when in resumption-PSK mode.  However, 0-RTT
   parameters are those negotiated in the previous handshake; mismatches
   may require rejecting 0-RTT (see Section 4.2.10).

   There are subtle (and not so subtle) interactions that may occur in
   this protocol between new features and existing features which may
   result in a significant reduction in overall security.  The following
   considerations should be taken into account when designing new
   extensions:

   -  Some cases where a server does not agree to an extension are error
      conditions (e.g., the handshake cannot continue), and some are
      simply refusals to support particular features.  In general, error
      alerts should be used for the former and a field in the server
      extension response for the latter.

   -  Extensions should, as far as possible, be designed to prevent any
      attack that forces use (or non-use) of a particular feature by
      manipulation of handshake messages.  This principle should be
      followed regardless of whether the feature is believed to cause a
      security problem.  Often the fact that the extension fields are
      included in the inputs to the Finished message hashes will be
      sufficient, but extreme care is needed when the extension changes
      the meaning of messages sent in the handshake phase.  Designers
      and implementors should be aware of the fact that until the
      handshake has been authenticated, active attackers can modify
      messages and insert, remove, or replace extensions.","[
  {
    ""section_name"": ""4.2.. Handshake Protocol_Extensions"",
    ""title"": ""Extension Structure Overview"",
    ""content"": ""A number of TLS messages contain tag-length-value encoded extensions structures.\n\nstruct {\n    ExtensionType extension_type;\n    opaque extension_data<0..2^16-1>;\n} Extension;\n\nHere:\n- \""extension_type\"" identifies the particular extension type.\n- \""extension_data\"" contains information specific to the particular extension type.""
  },
  {
    ""section_name"": ""4.2.. Handshake Protocol_Extensions"",
    ""title"": ""ExtensionType Enumeration"",
    ""content"": ""enum {\n    server_name(0),                             /* RFC 6066 */\n    max_fragment_length(1),                     /* RFC 6066 */\n    status_request(5),                          /* RFC 6066 */\n    supported_groups(10),                       /* RFC 8422, 7919 */\n    signature_algorithms(13),                   /* RFC 8446 */\n    use_srtp(14),                               /* RFC 5764 */\n    heartbeat(15),                              /* RFC 6520 */\n    application_layer_protocol_negotiation(16), /* RFC 7301 */\n    signed_certificate_timestamp(18),           /* RFC 6962 */\n    client_certificate_type(19),                /* RFC 7250 */\n    server_certificate_type(20),                /* RFC 7250 */\n    padding(21),                                /* RFC 7685 */\n    pre_shared_key(41),                         /* RFC 8446 */\n    early_data(42),                             /* RFC 8446 */\n    supported_versions(43),                     /* RFC 8446 */\n    cookie(44),                                 /* RFC 8446 */\n    psk_key_exchange_modes(45),                 /* RFC 8446 */\n    certificate_authorities(47),                /* RFC 8446 */\n    oid_filters(48),                            /* RFC 8446 */\n    post_handshake_auth(49),                    /* RFC 8446 */\n    signature_algorithms_cert(50),              /* RFC 8446 */\n    key_share(51),                              /* RFC 8446 */\n    (65535)\n} ExtensionType;""
  },
  {
    ""section_name"": ""4.2.. Handshake Protocol_Extensions"",
    ""title"": ""Extension Negotiation Process"",
    ""content"": ""Extensions are generally structured in a request/response fashion. The client sends its extension requests in the ClientHello message, and the server sends its extension responses in the ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate messages. The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message.""
  },
  {
    ""section_name"": ""4.2.. Handshake Protocol_Extensions"",
    ""title"": ""Extension Handling Rules"",
    ""content"": ""Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the \""cookie\"" extension in the HelloRetryRequest. Upon receiving such an extension, an endpoint MUST abort the handshake with an \""unsupported_extension\"" alert.""
  },
  {
    ""section_name"": ""4.2.. Handshake Protocol_Extensions"",
    ""title"": ""Extension Message Compatibility"",
    ""content"": ""The table below indicates the messages where a given extension may appear, using the following notation: CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), and HRR (HelloRetryRequest). If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an \""illegal_parameter\"" alert.""
  },
  {
    ""section_name"": ""4.2.. Handshake Protocol_Extensions"",
    ""title"": ""Extension Order and Uniqueness"",
    ""content"": ""When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of \""pre_shared_key\"" which MUST be the last extension in the ClientHello. There MUST NOT be more than one extension of the same type in a given extension block.""
  },
  {
    ""section_name"": ""4.2.. Handshake Protocol_Extensions"",
    ""title"": ""Security Considerations for Extensions"",
    ""content"": ""There are subtle interactions that may occur in this protocol between new features and existing features which may result in a significant reduction in overall security. Extensions should be designed to prevent any attack that forces use (or non-use) of a particular feature by manipulation of handshake messages.""
  }
]"
8,4.2.1.. Handshake Protocol_Extensions_Supported Versions,"struct {
          select (Handshake.msg_type) {
              case client_hello:
                   ProtocolVersion versions<2..254>;

              case server_hello: /* and HelloRetryRequest */
                   ProtocolVersion selected_version;
          };
      } SupportedVersions;

   The ""supported_versions"" extension is used by the client to indicate
   which versions of TLS it supports and by the server to indicate which
   version it is using.  The extension contains a list of supported
   versions in preference order, with the most preferred version first.
   Implementations of this specification MUST send this extension in the
   ClientHello containing all versions of TLS which they are prepared to
   negotiate (for this specification, that means minimally 0x0304, but
   if previous versions of TLS are allowed to be negotiated, they MUST
   be present as well).

   If this extension is not present, servers which are compliant with
   this specification and which also support TLS 1.2 MUST negotiate
   TLS 1.2 or prior as specified in [RFC5246], even if
   ClientHello.legacy_version is 0x0304 or later.  Servers MAY abort the
   handshake upon receiving a ClientHello with legacy_version 0x0304 or
   later.

   If this extension is present in the ClientHello, servers MUST NOT use
   the ClientHello.legacy_version value for version negotiation and MUST
   use only the ""supported_versions"" extension to determine client
   preferences.  Servers MUST only select a version of TLS present in
   that extension and MUST ignore any unknown versions that are present
   in that extension.  Note that this mechanism makes it possible to
   negotiate a version prior to TLS 1.2 if one side supports a sparse
   range.  Implementations of TLS 1.3 which choose to support prior
   versions of TLS SHOULD support TLS 1.2.  Servers MUST be prepared to
   receive ClientHellos that include this extension but do not include
   0x0304 in the list of versions.

   A server which negotiates a version of TLS prior to TLS 1.3 MUST set
   ServerHello.version and MUST NOT send the ""supported_versions""
   extension.  A server which negotiates TLS 1.3 MUST respond by sending
   a ""supported_versions"" extension containing the selected version
   value (0x0304).  It MUST set the ServerHello.legacy_version field to
   0x0303 (TLS 1.2).  Clients MUST check for this extension prior to
   processing the rest of the ServerHello (although they will have to

   parse the ServerHello in order to read the extension).  If this
   extension is present, clients MUST ignore the
   ServerHello.legacy_version value and MUST use only the
   ""supported_versions"" extension to determine the selected version.  If
   the ""supported_versions"" extension in the ServerHello contains a
   version not offered by the client or contains a version prior to
   TLS 1.3, the client MUST abort the handshake with an
   ""illegal_parameter"" alert.","[
  {
    ""section_name"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""SupportedVersions Structure"",
    ""content"": ""struct {\r\n    select (Handshake.msg_type) {\r\n        case client_hello:\r\n            ProtocolVersion versions<2..254>;\r\n\r\n        case server_hello: /* and HelloRetryRequest */\r\n            ProtocolVersion selected_version;\r\n    };\r\n} SupportedVersions;""
  },
  {
    ""section_name"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""Purpose of the Supported Versions Extension"",
    ""content"": ""The \""supported_versions\"" extension is used by the client to indicate which versions of TLS it supports and by the server to indicate which version it is using. The extension contains a list of supported versions in preference order, with the most preferred version first.""
  },
  {
    ""section_name"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""ClientHello Requirements"",
    ""content"": ""Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which they are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, they MUST be present as well).""
  },
  {
    ""section_name"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""Server Behavior Without the Extension"",
    ""content"": ""If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.""
  },
  {
    ""section_name"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""Server Behavior With the Extension"",
    ""content"": ""If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the \""supported_versions\"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension.""
  },
  {
    ""section_name"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""Negotiation of Versions Prior to TLS 1.2"",
    ""content"": ""This mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.""
  },
  {
    ""section_name"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""ServerHello Version Negotiation"",
    ""content"": ""A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the \""supported_versions\"" extension. A server which negotiates TLS 1.3 MUST respond by sending a \""supported_versions\"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2).""
  },
  {
    ""section_name"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""Client Checks for the Supported Versions Extension"",
    ""content"": ""Clients MUST check for this extension prior to processing the rest of the ServerHello. If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the \""supported_versions\"" extension to determine the selected version. If the \""supported_versions\"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an \""illegal_parameter\"" alert.""
  }
]"
9,4.2.2.. Handshake Protocol_Extensions_Cookie,"struct {
          opaque cookie<1..2^16-1>;
      } Cookie;

   Cookies serve two primary purposes:

   -  Allowing the server to force the client to demonstrate
      reachability at their apparent network address (thus providing a
      measure of DoS protection).  This is primarily useful for
      non-connection-oriented transports (see [RFC6347] for an example
      of this).

   -  Allowing the server to offload state to the client, thus allowing
      it to send a HelloRetryRequest without storing any state.  The
      server can do this by storing the hash of the ClientHello in the
      HelloRetryRequest cookie (protected with some suitable integrity
      protection algorithm).

   When sending a HelloRetryRequest, the server MAY provide a ""cookie""
   extension to the client (this is an exception to the usual rule that
   the only extensions that may be sent are those that appear in the
   ClientHello).  When sending the new ClientHello, the client MUST copy
   the contents of the extension received in the HelloRetryRequest into
   a ""cookie"" extension in the new ClientHello.  Clients MUST NOT use
   cookies in their initial ClientHello in subsequent connections.

   When a server is operating statelessly, it may receive an unprotected
   record of type change_cipher_spec between the first and second
   ClientHello (see Section 5).  Since the server is not storing any
   state, this will appear as if it were the first message to be
   received.  Servers operating statelessly MUST ignore these records.","[
  {
    ""section_name"": ""4.2.2.. Handshake Protocol_Extensions_Cookie"",
    ""title"": ""Cookie Structure"",
    ""content"": ""struct {\n    opaque cookie<1..2^16-1>;\n} Cookie;""
  },
  {
    ""section_name"": ""4.2.2.. Handshake Protocol_Extensions_Cookie"",
    ""title"": ""Purpose of Cookies"",
    ""content"": ""Cookies serve two primary purposes:\n\n1. Allowing the server to force the client to demonstrate reachability at their apparent network address, thus providing a measure of DoS protection. This is primarily useful for non-connection-oriented transports (see [RFC6347] for an example).\n\n2. Allowing the server to offload state to the client, enabling it to send a HelloRetryRequest without storing any state. The server can achieve this by storing the hash of the ClientHello in the HelloRetryRequest cookie, protected with a suitable integrity protection algorithm.""
  },
  {
    ""section_name"": ""4.2.2.. Handshake Protocol_Extensions_Cookie"",
    ""title"": ""HelloRetryRequest Cookie Extension"",
    ""content"": ""When sending a HelloRetryRequest, the server MAY provide a \""cookie\"" extension to the client (this is an exception to the usual rule that only extensions appearing in the ClientHello may be sent). When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a \""cookie\"" extension in the new ClientHello. Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.""
  },
  {
    ""section_name"": ""4.2.2.. Handshake Protocol_Extensions_Cookie"",
    ""title"": ""Stateless Server Behavior"",
    ""content"": ""When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5). Since the server is not storing any state, this will appear as if it were the first message received. Servers operating statelessly MUST ignore these records.""
  }
]"
10,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,"TLS 1.3 provides two extensions for indicating which signature
   algorithms may be used in digital signatures.  The
   ""signature_algorithms_cert"" extension applies to signatures in
   certificates, and the ""signature_algorithms"" extension, which
   originally appeared in TLS 1.2, applies to signatures in
   CertificateVerify messages.  The keys found in certificates MUST also
   be of appropriate type for the signature algorithms they are used
   with.  This is a particular issue for RSA keys and PSS signatures, as
   described below.  If no ""signature_algorithms_cert"" extension is
   present, then the ""signature_algorithms"" extension also applies to
   signatures appearing in certificates.  Clients which desire the
   server to authenticate itself via a certificate MUST send the
   ""signature_algorithms"" extension.  If a server is authenticating via
   a certificate and the client has not sent a ""signature_algorithms""
   extension, then the server MUST abort the handshake with a
   ""missing_extension"" alert (see Section 9.2).

   The ""signature_algorithms_cert"" extension was added to allow
   implementations which supported different sets of algorithms for
   certificates and in TLS itself to clearly signal their capabilities.
   TLS 1.2 implementations SHOULD also process this extension.
   Implementations which have the same policy in both cases MAY omit the
   ""signature_algorithms_cert"" extension.

   The ""extension_data"" field of these extensions contains a
   SignatureSchemeList value:

      enum {
          /* RSASSA-PKCS1-v1_5 algorithms */
          rsa_pkcs1_sha256(0x0401),
          rsa_pkcs1_sha384(0x0501),
          rsa_pkcs1_sha512(0x0601),

          /* ECDSA algorithms */
          ecdsa_secp256r1_sha256(0x0403),
          ecdsa_secp384r1_sha384(0x0503),
          ecdsa_secp521r1_sha512(0x0603),

          /* RSASSA-PSS algorithms with public key OID rsaEncryption */
          rsa_pss_rsae_sha256(0x0804),
          rsa_pss_rsae_sha384(0x0805),
          rsa_pss_rsae_sha512(0x0806),

          /* EdDSA algorithms */
          ed25519(0x0807),
          ed448(0x0808),

          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
          rsa_pss_pss_sha256(0x0809),
          rsa_pss_pss_sha384(0x080a),
          rsa_pss_pss_sha512(0x080b),

          /* Legacy algorithms */
          rsa_pkcs1_sha1(0x0201),
          ecdsa_sha1(0x0203),

          /* Reserved Code Points */
          private_use(0xFE00..0xFFFF),
          (0xFFFF)
      } SignatureScheme;

      struct {
          SignatureScheme supported_signature_algorithms<2..2^16-2>;
      } SignatureSchemeList;

   Note: This enum is named ""SignatureScheme"" because there is already a
   ""SignatureAlgorithm"" type in TLS 1.2, which this replaces.  We use
   the term ""signature algorithm"" throughout the text.

   Each SignatureScheme value lists a single signature algorithm that
   the client is willing to verify.  The values are indicated in
   descending order of preference.  Note that a signature algorithm
   takes as input an arbitrary-length message, rather than a digest.
   Algorithms which traditionally act on a digest should be defined in
   TLS to first hash the input with a specified hash algorithm and then
   proceed as usual.  The code point groups listed above have the
   following meanings:

   RSASSA-PKCS1-v1_5 algorithms:  Indicates a signature algorithm using
      RSASSA-PKCS1-v1_5 [RFC8017] with the corresponding hash algorithm
      as defined in [SHS].  These values refer solely to signatures
      which appear in certificates (see Section 4.4.2.2) and are not
      defined for use in signed TLS handshake messages, although they
      MAY appear in ""signature_algorithms"" and
      ""signature_algorithms_cert"" for backward compatibility with
      TLS 1.2.

   ECDSA algorithms:  Indicates a signature algorithm using ECDSA
      [ECDSA], the corresponding curve as defined in ANSI X9.62 [ECDSA]
      and FIPS 186-4 [DSS], and the corresponding hash algorithm as
      defined in [SHS].  The signature is represented as a DER-encoded
      [X690] ECDSA-Sig-Value structure.

   RSASSA-PSS RSAE algorithms:  Indicates a signature algorithm using
      RSASSA-PSS [RFC8017] with mask generation function 1.  The digest
      used in the mask generation function and the digest being signed
      are both the corresponding hash algorithm as defined in [SHS].
      The length of the Salt MUST be equal to the length of the output
      of the digest algorithm.  If the public key is carried in an X.509
      certificate, it MUST use the rsaEncryption OID [RFC5280].

   EdDSA algorithms:  Indicates a signature algorithm using EdDSA as
      defined in [RFC8032] or its successors.  Note that these
      correspond to the ""PureEdDSA"" algorithms and not the ""prehash""
      variants.

   RSASSA-PSS PSS algorithms:  Indicates a signature algorithm using
      RSASSA-PSS [RFC8017] with mask generation function 1.  The digest
      used in the mask generation function and the digest being signed
      are both the corresponding hash algorithm as defined in [SHS].
      The length of the Salt MUST be equal to the length of the digest
      algorithm.  If the public key is carried in an X.509 certificate,
      it MUST use the RSASSA-PSS OID [RFC5756].  When used in
      certificate signatures, the algorithm parameters MUST be DER
      encoded.  If the corresponding public key's parameters are
      present, then the parameters in the signature MUST be identical to
      those in the public key.

   Legacy algorithms:  Indicates algorithms which are being deprecated
      because they use algorithms with known weaknesses, specifically
      SHA-1 which is used in this context with either (1) RSA using
      RSASSA-PKCS1-v1_5 or (2) ECDSA.  These values refer solely to
      signatures which appear in certificates (see Section 4.4.2.2) and
      are not defined for use in signed TLS handshake messages, although
      they MAY appear in ""signature_algorithms"" and
      ""signature_algorithms_cert"" for backward compatibility with
      TLS 1.2.  Endpoints SHOULD NOT negotiate these algorithms but are
      permitted to do so solely for backward compatibility.  Clients
      offering these values MUST list them as the lowest priority
      (listed after all other algorithms in SignatureSchemeList).
      TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless
      no valid certificate chain can be produced without it (see
      Section 4.4.2.2).

   The signatures on certificates that are self-signed or certificates
   that are trust anchors are not validated, since they begin a
   certification path (see [RFC5280], Section 3.2).  A certificate that
   begins a certification path MAY use a signature algorithm that is not
   advertised as being supported in the ""signature_algorithms""
   extension.

   Note that TLS 1.2 defines this extension differently.  TLS 1.3
   implementations willing to negotiate TLS 1.2 MUST behave in
   accordance with the requirements of [RFC5246] when negotiating that
   version.  In particular:

   -  TLS 1.2 ClientHellos MAY omit this extension.

   -  In TLS 1.2, the extension contained hash/signature pairs.  The
      pairs are encoded in two octets, so SignatureScheme values have
      been allocated to align with TLS 1.2's encoding.  Some legacy
      pairs are left unallocated.  These algorithms are deprecated as of
      TLS 1.3.  They MUST NOT be offered or negotiated by any
      implementation.  In particular, MD5 [SLOTH], SHA-224, and DSA
      MUST NOT be used.

   -  ECDSA signature schemes align with TLS 1.2's ECDSA hash/signature
      pairs.  However, the old semantics did not constrain the signing
      curve.  If TLS 1.2 is negotiated, implementations MUST be prepared
      to accept a signature that uses any curve that they advertised in
      the ""supported_groups"" extension.

   -  Implementations that advertise support for RSASSA-PSS (which is
      mandatory in TLS 1.3) MUST be prepared to accept a signature using
      that scheme even when TLS 1.2 is negotiated.  In TLS 1.2,
      RSASSA-PSS is used with RSA cipher suites.","[
  {
    ""section_name"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""Signature Algorithms Overview"",
    ""content"": ""TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures. The \""signature_algorithms_cert\"" extension applies to signatures in certificates, while the \""signature_algorithms\"" extension applies to signatures in CertificateVerify messages. If no \""signature_algorithms_cert\"" extension is present, then the \""signature_algorithms\"" extension also applies to signatures appearing in certificates.""
  },
  {
    ""section_name"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""Client Requirements for Signature Algorithms"",
    ""content"": ""Clients that desire server authentication via a certificate MUST send the \""signature_algorithms\"" extension. If the server is authenticating via a certificate and the client has not sent this extension, the server MUST abort the handshake with a \""missing_extension\"" alert.""
  },
  {
    ""section_name"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""Purpose of the Signature Algorithms Extensions"",
    ""content"": ""The \""signature_algorithms_cert\"" extension was added to allow implementations that support different sets of algorithms for certificates and in TLS to clearly signal their capabilities. TLS 1.2 implementations SHOULD also process this extension. Implementations with the same policy for both cases MAY omit this extension.""
  },
  {
    ""section_name"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""Signature Scheme Enumeration"",
    ""content"": ""The \""extension_data\"" field of these extensions contains a SignatureSchemeList value:\n\n    enum {\n        rsa_pkcs1_sha256(0x0401),\n        rsa_pkcs1_sha384(0x0501),\n        rsa_pkcs1_sha512(0x0601),\n        ecdsa_secp256r1_sha256(0x0403),\n        ecdsa_secp384r1_sha384(0x0503),\n        ecdsa_secp521r1_sha512(0x0603),\n        rsa_pss_rsae_sha256(0x0804),\n        rsa_pss_rsae_sha384(0x0805),\n        rsa_pss_rsae_sha512(0x0806),\n        ed25519(0x0807),\n        ed448(0x0808),\n        rsa_pss_pss_sha256(0x0809),\n        rsa_pss_pss_sha384(0x080a),\n        rsa_pss_pss_sha512(0x080b),\n        rsa_pkcs1_sha1(0x0201),\n        ecdsa_sha1(0x0203),\n        private_use(0xFE00..0xFFFF),\n        (0xFFFF)\n    } SignatureScheme;""
  },
  {
    ""section_name"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""Signature Scheme List Structure"",
    ""content"": ""struct {\n    SignatureScheme supported_signature_algorithms<2..2^16-2>;\n} SignatureSchemeList;""
  },
  {
    ""section_name"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""Signature Algorithm Definitions"",
    ""content"": ""Each SignatureScheme value lists a single signature algorithm that the client is willing to verify, indicated in descending order of preference. Notably, a signature algorithm takes an arbitrary-length message as input rather than a digest. Algorithms traditionally acting on a digest should hash the input with a specified hash algorithm before proceeding.""
  },
  {
    ""section_name"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""RSASSA-PKCS1-v1_5 Algorithms"",
    ""content"": ""Indicates a signature algorithm using RSASSA-PKCS1-v1_5 with the corresponding hash algorithm as defined in [SHS]. These values refer solely to signatures in certificates and are not defined for signed TLS handshake messages, although they may appear in the extensions for backward compatibility with TLS 1.2.""
  },
  {
    ""section_name"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""ECDSA Algorithms"",
    ""content"": ""Indicates a signature algorithm using ECDSA, the corresponding curve as defined in ANSI X9.62 and FIPS 186-4, and the corresponding hash algorithm as defined in [SHS]. The signature is represented as a DER-encoded ECDSA-Sig-Value structure.""
  },
  {
    ""section_name"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""RSASSA-PSS Algorithms"",
    ""content"": ""Indicates a signature algorithm using RSASSA-PSS with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST equal the output length of the digest algorithm.""
  },
  {
    ""section_name"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""EdDSA Algorithms"",
    ""content"": ""Indicates a signature algorithm using EdDSA as defined in [RFC8032] or its successors. These correspond to the \""PureEdDSA\"" algorithms, not the \""prehash\"" variants.""
  },
  {
    ""section_name"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""Legacy Algorithms"",
    ""content"": ""Indicates algorithms being deprecated due to known weaknesses, specifically SHA-1 used with RSA or ECDSA. These values refer solely to signatures in certificates and should not be negotiated unless for backward compatibility. TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it.""
  },
  {
    ""section_name"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""Signature Validation for Trust Anchors"",
    ""content"": ""Signatures on self-signed certificates or trust anchors are not validated since they begin a certification path. A certificate starting a certification path may use a signature algorithm not advertised in the \""signature_algorithms\"" extension.""
  },
  {
    ""section_name"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""TLS 1.2 Compatibility"",
    ""content"": ""TLS 1.3 implementations willing to negotiate TLS 1.2 MUST comply with the requirements of [RFC5246]. In TLS 1.2, ClientHellos may omit the signature algorithms extension, which contained hash/signature pairs encoded in two octets. Legacy pairs are deprecated and MUST NOT be offered or negotiated.""
  }
]"
11,4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,"The ""certificate_authorities"" extension is used to indicate the
   certificate authorities (CAs) which an endpoint supports and which
   SHOULD be used by the receiving endpoint to guide certificate
   selection.

   The body of the ""certificate_authorities"" extension consists of a
   CertificateAuthoritiesExtension structure.

      opaque DistinguishedName<1..2^16-1>;

      struct {
          DistinguishedName authorities<3..2^16-1>;
      } CertificateAuthoritiesExtension;

   authorities:  A list of the distinguished names [X501] of acceptable
      certificate authorities, represented in DER-encoded [X690] format.
      These distinguished names specify a desired distinguished name for
      a trust anchor or subordinate CA; thus, this message can be used
      to describe known trust anchors as well as a desired authorization
      space.

   The client MAY send the ""certificate_authorities"" extension in the
   ClientHello message.  The server MAY send it in the
   CertificateRequest message.

   The ""trusted_ca_keys"" extension [RFC6066], which serves a similar
   purpose but is more complicated, is not used in TLS 1.3 (although it
   may appear in ClientHello messages from clients which are offering
   prior versions of TLS).","[
  {
    ""section_name"": ""4.2.4.. Handshake Protocol_Extensions_Certificate Authorities"",
    ""title"": ""Certificate Authorities Extension Overview"",
    ""content"": ""The \""certificate_authorities\"" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection.""
  },
  {
    ""section_name"": ""4.2.4.. Handshake Protocol_Extensions_Certificate Authorities"",
    ""title"": ""Certificate Authorities Extension Structure"",
    ""content"": ""The body of the \""certificate_authorities\"" extension consists of a CertificateAuthoritiesExtension structure:\n\n```plaintext\nopaque DistinguishedName<1..2^16-1>;\n\nstruct {\n    DistinguishedName authorities<3..2^16-1>;\n} CertificateAuthoritiesExtension;\n```""
  },
  {
    ""section_name"": ""4.2.4.. Handshake Protocol_Extensions_Certificate Authorities"",
    ""title"": ""Authorities Field Description"",
    ""content"": ""The `authorities` field contains a list of the distinguished names [X501] of acceptable certificate authorities, represented in DER-encoded [X690] format. These distinguished names specify a desired distinguished name for a trust anchor or subordinate CA; thus, this message can be used to describe known trust anchors as well as a desired authorization space.""
  },
  {
    ""section_name"": ""4.2.4.. Handshake Protocol_Extensions_Certificate Authorities"",
    ""title"": ""Usage of the Certificate Authorities Extension"",
    ""content"": ""The client MAY send the \""certificate_authorities\"" extension in the ClientHello message. The server MAY send it in the CertificateRequest message.""
  },
  {
    ""section_name"": ""4.2.4.. Handshake Protocol_Extensions_Certificate Authorities"",
    ""title"": ""Comparison with Trusted CA Keys Extension"",
    ""content"": ""The \""trusted_ca_keys\"" extension [RFC6066], which serves a similar purpose but is more complicated, is not used in TLS 1.3 (although it may appear in ClientHello messages from clients which are offering prior versions of TLS).""
  }
]"
12,4.2.5.. Handshake Protocol_Extensions_OID Filters,"The ""oid_filters"" extension allows servers to provide a set of
   OID/value pairs which it would like the client's certificate to
   match.  This extension, if provided by the server, MUST only be sent
   in the CertificateRequest message.

      struct {
          opaque certificate_extension_oid<1..2^8-1>;
          opaque certificate_extension_values<0..2^16-1>;
      } OIDFilter;

      struct {
          OIDFilter filters<0..2^16-1>;
      } OIDFilterExtension;

   filters:  A list of certificate extension OIDs [RFC5280] with their
      allowed value(s) and represented in DER-encoded [X690] format.
      Some certificate extension OIDs allow multiple values (e.g.,
      Extended Key Usage).  If the server has included a non-empty
      filters list, the client certificate included in the response MUST
      contain all of the specified extension OIDs that the client
      recognizes.  For each extension OID recognized by the client, all
      of the specified values MUST be present in the client certificate
      (but the certificate MAY have other values as well).  However, the
      client MUST ignore and skip any unrecognized certificate extension
      OIDs.  If the client ignored some of the required certificate
      extension OIDs and supplied a certificate that does not satisfy
      the request, the server MAY at its discretion either continue the
      connection without client authentication or abort the handshake
      with an ""unsupported_certificate"" alert.  Any given OID MUST NOT
      appear more than once in the filters list.

   PKIX RFCs define a variety of certificate extension OIDs and their
   corresponding value types.  Depending on the type, matching
   certificate extension values are not necessarily bitwise-equal.  It
   is expected that TLS implementations will rely on their PKI libraries
   to perform certificate selection using certificate extension OIDs.

   This document defines matching rules for two standard certificate
   extensions defined in [RFC5280]:

   -  The Key Usage extension in a certificate matches the request when
      all key usage bits asserted in the request are also asserted in
      the Key Usage certificate extension.

   -  The Extended Key Usage extension in a certificate matches the
      request when all key purpose OIDs present in the request are also
      found in the Extended Key Usage certificate extension.  The
      special anyExtendedKeyUsage OID MUST NOT be used in the request.

   Separate specifications may define matching rules for other
   certificate extensions.","[
  {
    ""section_name"": ""4.2.5.. Handshake Protocol_Extensions_OID Filters"",
    ""title"": ""OID Filters Extension Overview"",
    ""content"": ""The \""oid_filters\"" extension allows servers to provide a set of OID/value pairs which it would like the client's certificate to match. This extension, if provided by the server, MUST only be sent in the CertificateRequest message.""
  },
  {
    ""section_name"": ""4.2.5.. Handshake Protocol_Extensions_OID Filters"",
    ""title"": ""OIDFilter Structure"",
    ""content"": ""struct {\n    opaque certificate_extension_oid<1..2^8-1>;\n    opaque certificate_extension_values<0..2^16-1>;\n} OIDFilter;""
  },
  {
    ""section_name"": ""4.2.5.. Handshake Protocol_Extensions_OID Filters"",
    ""title"": ""OIDFilterExtension Structure"",
    ""content"": ""struct {\n    OIDFilter filters<0..2^16-1>;\n} OIDFilterExtension;""
  },
  {
    ""section_name"": ""4.2.5.. Handshake Protocol_Extensions_OID Filters"",
    ""title"": ""Filters List Description"",
    ""content"": ""filters: A list of certificate extension OIDs [RFC5280] with their allowed value(s) and represented in DER-encoded [X690] format. Some certificate extension OIDs allow multiple values (e.g., Extended Key Usage). If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes.""
  },
  {
    ""section_name"": ""4.2.5.. Handshake Protocol_Extensions_OID Filters"",
    ""title"": ""Client Certificate Requirements"",
    ""content"": ""For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well). However, the client MUST ignore and skip any unrecognized certificate extension OIDs. If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an \""unsupported_certificate\"" alert.""
  },
  {
    ""section_name"": ""4.2.5.. Handshake Protocol_Extensions_OID Filters"",
    ""title"": ""OID Uniqueness and Matching Rules"",
    ""content"": ""Any given OID MUST NOT appear more than once in the filters list. PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types. Depending on the type, matching certificate extension values are not necessarily bitwise-equal. This document defines matching rules for two standard certificate extensions defined in [RFC5280]:\n\n- The Key Usage extension in a certificate matches the request when all key usage bits asserted in the request are also asserted in the Key Usage certificate extension.\n\n- The Extended Key Usage extension in a certificate matches the request when all key purpose OIDs present in the request are also found in the Extended Key Usage certificate extension. The special anyExtendedKeyUsage OID MUST NOT be used in the request.""
  }
]"
13,4.2.6.. Handshake Protocol_Extensions_Post-Handshake Client Authentication,"The ""post_handshake_auth"" extension is used to indicate that a client
   is willing to perform post-handshake authentication (Section 4.6.2).
   Servers MUST NOT send a post-handshake CertificateRequest to clients
   which do not offer this extension.  Servers MUST NOT send this
   extension.

      struct {} PostHandshakeAuth;

   The ""extension_data"" field of the ""post_handshake_auth"" extension is
   zero length.","### Output:
[
  {
    ""section_name"": ""4.2.6.. Handshake Protocol_Extensions_Post-Handshake Client Authentication"",
    ""title"": ""Post-Handshake Authentication Extension"",
    ""content"": ""The \""post_handshake_auth\"" extension is used to indicate that a client is willing to perform post-handshake authentication (Section 4.6.2). Servers MUST NOT send a post-handshake CertificateRequest to clients which do not offer this extension. Servers MUST NOT send this extension.\n\nstruct {} PostHandshakeAuth;\n\nThe \""extension_data\"" field of the \""post_handshake_auth\"" extension is zero length.""
  }
]"
14,4.2.7.. Handshake Protocol_Extensions_Supported Groups,"When sent by the client, the ""supported_groups"" extension indicates
   the named groups which the client supports for key exchange, ordered
   from most preferred to least preferred.

   Note: In versions of TLS prior to TLS 1.3, this extension was named
   ""elliptic_curves"" and only contained elliptic curve groups.  See
   [RFC8422] and [RFC7919].  This extension was also used to negotiate
   ECDSA curves.  Signature algorithms are now negotiated independently
   (see Section 4.2.3).

   The ""extension_data"" field of this extension contains a
   ""NamedGroupList"" value:

      enum {

          /* Elliptic Curve Groups (ECDHE) */
          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
          x25519(0x001D), x448(0x001E),

          /* Finite Field Groups (DHE) */
          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
          ffdhe6144(0x0103), ffdhe8192(0x0104),

          /* Reserved Code Points */
          ffdhe_private_use(0x01FC..0x01FF),
          ecdhe_private_use(0xFE00..0xFEFF),
          (0xFFFF)
      } NamedGroup;

      struct {
          NamedGroup named_group_list<2..2^16-1>;
      } NamedGroupList;

   Elliptic Curve Groups (ECDHE):  Indicates support for the
      corresponding named curve, defined in either FIPS 186-4 [DSS] or
      [RFC7748].  Values 0xFE00 through 0xFEFF are reserved for
      Private Use [RFC8126].

   Finite Field Groups (DHE):  Indicates support for the corresponding
      finite field group, defined in [RFC7919].  Values 0x01FC through
      0x01FF are reserved for Private Use.

   Items in named_group_list are ordered according to the sender's
   preferences (most preferred choice first).

   As of TLS 1.3, servers are permitted to send the ""supported_groups""
   extension to the client.  Clients MUST NOT act upon any information
   found in ""supported_groups"" prior to successful completion of the
   handshake but MAY use the information learned from a successfully
   completed handshake to change what groups they use in their
   ""key_share"" extension in subsequent connections.  If the server has a
   group it prefers to the ones in the ""key_share"" extension but is
   still willing to accept the ClientHello, it SHOULD send
   ""supported_groups"" to update the client's view of its preferences;
   this extension SHOULD contain all groups the server supports,
   regardless of whether they are currently supported by the client.","[
  {
    ""section_name"": ""4.2.7.. Handshake Protocol_Extensions_Supported Groups"",
    ""title"": ""Supported Groups Extension Overview"",
    ""content"": ""When sent by the client, the \""supported_groups\"" extension indicates the named groups which the client supports for key exchange, ordered from most preferred to least preferred. In versions of TLS prior to TLS 1.3, this extension was named \""elliptic_curves\"" and only contained elliptic curve groups. This extension was also used to negotiate ECDSA curves. Signature algorithms are now negotiated independently (see Section 4.2.3).""
  },
  {
    ""section_name"": ""4.2.7.. Handshake Protocol_Extensions_Supported Groups"",
    ""title"": ""Extension Data Structure"",
    ""content"": ""The \""extension_data\"" field of this extension contains a \""NamedGroupList\"" value:\n\n```plaintext\nenum {\n    /* Elliptic Curve Groups (ECDHE) */\n    secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),\n    x25519(0x001D), x448(0x001E),\n\n    /* Finite Field Groups (DHE) */\n    ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),\n    ffdhe6144(0x0103), ffdhe8192(0x0104),\n\n    /* Reserved Code Points */\n    ffdhe_private_use(0x01FC..0x01FF),\n    ecdhe_private_use(0xFE00..0xFEFF),\n    (0xFFFF)\n} NamedGroup;\n\nstruct {\n    NamedGroup named_group_list<2..2^16-1>;\n} NamedGroupList;\n```""
  },
  {
    ""section_name"": ""4.2.7.. Handshake Protocol_Extensions_Supported Groups"",
    ""title"": ""Group Types and Definitions"",
    ""content"": ""Elliptic Curve Groups (ECDHE): Indicates support for the corresponding named curve, defined in either FIPS 186-4 or RFC 7748. Values 0xFE00 through 0xFEFF are reserved for Private Use.\n\nFinite Field Groups (DHE): Indicates support for the corresponding finite field group, defined in RFC 7919. Values 0x01FC through 0x01FF are reserved for Private Use.""
  },
  {
    ""section_name"": ""4.2.7.. Handshake Protocol_Extensions_Supported Groups"",
    ""title"": ""Ordering of Named Groups"",
    ""content"": ""Items in named_group_list are ordered according to the sender's preferences (most preferred choice first).""
  },
  {
    ""section_name"": ""4.2.7.. Handshake Protocol_Extensions_Supported Groups"",
    ""title"": ""Server Behavior with Supported Groups"",
    ""content"": ""As of TLS 1.3, servers are permitted to send the \""supported_groups\"" extension to the client. Clients MUST NOT act upon any information found in \""supported_groups\"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their \""key_share\"" extension in subsequent connections. If the server has a group it prefers to the ones in the \""key_share\"" extension but is still willing to accept the ClientHello, it SHOULD send \""supported_groups\"" to update the client's view of its preferences; this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client.""
  }
]"
15,4.2.8.. Handshake Protocol_Extensions_Key Share,"The ""key_share"" extension contains the endpoint's cryptographic
   parameters.

   Clients MAY send an empty client_shares vector in order to request
   group selection from the server, at the cost of an additional round
   trip (see Section 4.1.4).

      struct {
          NamedGroup group;
          opaque key_exchange<1..2^16-1>;
      } KeyShareEntry;

   group:  The named group for the key being exchanged.

   key_exchange:  Key exchange information.  The contents of this field
      are determined by the specified group and its corresponding
      definition.  Finite Field Diffie-Hellman [DH76] parameters are
      described in Section 4.2.8.1; Elliptic Curve Diffie-Hellman
      parameters are described in Section 4.2.8.2.

   In the ClientHello message, the ""extension_data"" field of this
   extension contains a ""KeyShareClientHello"" value:

      struct {
          KeyShareEntry client_shares<0..2^16-1>;
      } KeyShareClientHello;

   client_shares:  A list of offered KeyShareEntry values in descending
      order of client preference.

   This vector MAY be empty if the client is requesting a
   HelloRetryRequest.  Each KeyShareEntry value MUST correspond to a
   group offered in the ""supported_groups"" extension and MUST appear in
   the same order.  However, the values MAY be a non-contiguous subset
   of the ""supported_groups"" extension and MAY omit the most preferred
   groups.  Such a situation could arise if the most preferred groups
   are new and unlikely to be supported in enough places to make
   pregenerating key shares for them efficient.

   Clients can offer as many KeyShareEntry values as the number of
   supported groups it is offering, each representing a single set of
   key exchange parameters.  For instance, a client might offer shares
   for several elliptic curves or multiple FFDHE groups.  The
   key_exchange values for each KeyShareEntry MUST be generated
   independently.  Clients MUST NOT offer multiple KeyShareEntry values
   for the same group.  Clients MUST NOT offer any KeyShareEntry values
   for groups not listed in the client's ""supported_groups"" extension.
   Servers MAY check for violations of these rules and abort the
   handshake with an ""illegal_parameter"" alert if one is violated.

   In a HelloRetryRequest message, the ""extension_data"" field of this
   extension contains a KeyShareHelloRetryRequest value:

      struct {
          NamedGroup selected_group;
      } KeyShareHelloRetryRequest;

   selected_group:  The mutually supported group the server intends to
      negotiate and is requesting a retried ClientHello/KeyShare for.

   Upon receipt of this extension in a HelloRetryRequest, the client
   MUST verify that (1) the selected_group field corresponds to a group
   which was provided in the ""supported_groups"" extension in the
   original ClientHello and (2) the selected_group field does not
   correspond to a group which was provided in the ""key_share"" extension
   in the original ClientHello.  If either of these checks fails, then
   the client MUST abort the handshake with an ""illegal_parameter""
   alert.  Otherwise, when sending the new ClientHello, the client MUST

   replace the original ""key_share"" extension with one containing only a
   new KeyShareEntry for the group indicated in the selected_group field
   of the triggering HelloRetryRequest.

   In a ServerHello message, the ""extension_data"" field of this
   extension contains a KeyShareServerHello value:

      struct {
          KeyShareEntry server_share;
      } KeyShareServerHello;

   server_share:  A single KeyShareEntry value that is in the same group
      as one of the client's shares.

   If using (EC)DHE key establishment, servers offer exactly one
   KeyShareEntry in the ServerHello.  This value MUST be in the same
   group as the KeyShareEntry value offered by the client that the
   server has selected for the negotiated key exchange.  Servers
   MUST NOT send a KeyShareEntry for any group not indicated in the
   client's ""supported_groups"" extension and MUST NOT send a
   KeyShareEntry when using the ""psk_ke"" PskKeyExchangeMode.  If using
   (EC)DHE key establishment and a HelloRetryRequest containing a
   ""key_share"" extension was received by the client, the client MUST
   verify that the selected NamedGroup in the ServerHello is the same as
   that in the HelloRetryRequest.  If this check fails, the client MUST
   abort the handshake with an ""illegal_parameter"" alert.","[
  {
    ""section_name"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""Key Share Extension Overview"",
    ""content"": ""The \""key_share\"" extension contains the endpoint's cryptographic parameters. Clients MAY send an empty client_shares vector in order to request group selection from the server, at the cost of an additional round trip (see Section 4.1.4).""
  },
  {
    ""section_name"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""KeyShareEntry Structure"",
    ""content"": ""struct {\n    NamedGroup group;\n    opaque key_exchange<1..2^16-1>;\n} KeyShareEntry;""
  },
  {
    ""section_name"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""KeyShareEntry Field Descriptions"",
    ""content"": ""1. group: The named group for the key being exchanged.\n\n2. key_exchange: Key exchange information. The contents of this field are determined by the specified group and its corresponding definition. Finite Field Diffie-Hellman [DH76] parameters are described in Section 4.2.8.1; Elliptic Curve Diffie-Hellman parameters are described in Section 4.2.8.2.""
  },
  {
    ""section_name"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""KeyShareClientHello Structure"",
    ""content"": ""In the ClientHello message, the \""extension_data\"" field of this extension contains a \""KeyShareClientHello\"" value:\n\nstruct {\n    KeyShareEntry client_shares<0..2^16-1>;\n} KeyShareClientHello;""
  },
  {
    ""section_name"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""Client Shares Description"",
    ""content"": ""client_shares: A list of offered KeyShareEntry values in descending order of client preference. This vector MAY be empty if the client is requesting a HelloRetryRequest. Each KeyShareEntry value MUST correspond to a group offered in the \""supported_groups\"" extension and MUST appear in the same order.""
  },
  {
    ""section_name"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""KeyShare Entry Rules"",
    ""content"": ""Clients can offer as many KeyShareEntry values as the number of supported groups it is offering, each representing a single set of key exchange parameters. Clients MUST NOT offer multiple KeyShareEntry values for the same group and MUST NOT offer any for groups not listed in the client's \""supported_groups\"" extension. Servers MAY check for violations of these rules and abort the handshake with an \""illegal_parameter\"" alert if one is violated.""
  },
  {
    ""section_name"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""KeyShareHelloRetryRequest Structure"",
    ""content"": ""In a HelloRetryRequest message, the \""extension_data\"" field of this extension contains a KeyShareHelloRetryRequest value:\n\nstruct {\n    NamedGroup selected_group;\n} KeyShareHelloRetryRequest;""
  },
  {
    ""section_name"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""Selected Group Verification"",
    ""content"": ""Upon receipt of this extension in a HelloRetryRequest, the client MUST verify that (1) the selected_group field corresponds to a group provided in the \""supported_groups\"" extension in the original ClientHello and (2) the selected_group field does not correspond to a group provided in the \""key_share\"" extension in the original ClientHello. If either check fails, the client MUST abort the handshake with an \""illegal_parameter\"" alert.""
  },
  {
    ""section_name"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""KeyShareServerHello Structure"",
    ""content"": ""In a ServerHello message, the \""extension_data\"" field of this extension contains a KeyShareServerHello value:\n\nstruct {\n    KeyShareEntry server_share;\n} KeyShareServerHello;""
  },
  {
    ""section_name"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""Server Share Requirements"",
    ""content"": ""If using (EC)DHE key establishment, servers offer exactly one KeyShareEntry in the ServerHello. This value MUST be in the same group as the KeyShareEntry value offered by the client that the server has selected for the negotiated key exchange. Servers MUST NOT send a KeyShareEntry for any group not indicated in the client's \""supported_groups\"" extension and MUST NOT send a KeyShareEntry when using the \""psk_ke\"" PskKeyExchangeMode.""
  },
  {
    ""section_name"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""Verification of Selected NamedGroup"",
    ""content"": ""If using (EC)DHE key establishment and a HelloRetryRequest containing a \""key_share\"" extension was received by the client, the client MUST verify that the selected NamedGroup in the ServerHello is the same as that in the HelloRetryRequest. If this check fails, the client MUST abort the handshake with an \""illegal_parameter\"" alert.""
  }
]"
16,4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters,"Diffie-Hellman [DH76] parameters for both clients and servers are
   encoded in the opaque key_exchange field of a KeyShareEntry in a
   KeyShare structure.  The opaque value contains the Diffie-Hellman
   public value (Y = g^X mod p) for the specified group (see [RFC7919]
   for group definitions) encoded as a big-endian integer and padded to
   the left with zeros to the size of p in bytes.

   Note: For a given Diffie-Hellman group, the padding results in all
   public keys having the same length.

   Peers MUST validate each other's public key Y by ensuring that 1 < Y
   < p-1.  This check ensures that the remote peer is properly behaved
   and isn't forcing the local system into a small subgroup.","[
  {
    ""section_name"": ""4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters"",
    ""title"": ""Diffie-Hellman Key Exchange Parameters"",
    ""content"": ""Diffie-Hellman (DH) parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure. The opaque value contains the Diffie-Hellman public value (Y = g^X mod p) for the specified group (see [RFC7919] for group definitions) encoded as a big-endian integer and padded to the left with zeros to the size of p in bytes.\n\nNote: For a given Diffie-Hellman group, the padding results in all public keys having the same length.""
  },
  {
    ""section_name"": ""4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters"",
    ""title"": ""Public Key Validation"",
    ""content"": ""Peers MUST validate each other's public key Y by ensuring that 1 < Y < p-1. This check ensures that the remote peer is properly behaved and isn't forcing the local system into a small subgroup.""
  }
]"
17,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,"ECDHE parameters for both clients and servers are encoded in the
   opaque key_exchange field of a KeyShareEntry in a KeyShare structure.

   For secp256r1, secp384r1, and secp521r1, the contents are the
   serialized value of the following struct:

      struct {
          uint8 legacy_form = 4;
          opaque X[coordinate_length];
          opaque Y[coordinate_length];
      } UncompressedPointRepresentation;

   X and Y, respectively, are the binary representations of the x and y
   values in network byte order.  There are no internal length markers,
   so each number representation occupies as many octets as implied by
   the curve parameters.  For P-256, this means that each of X and Y use
   32 octets, padded on the left by zeros if necessary.  For P-384, they
   take 48 octets each.  For P-521, they take 66 octets each.

   For the curves secp256r1, secp384r1, and secp521r1, peers MUST
   validate each other's public value Q by ensuring that the point is a
   valid point on the elliptic curve.  The appropriate validation
   procedures are defined in Section 4.3.7 of [ECDSA] and alternatively
   in Section 5.6.2.3 of [KEYAGREEMENT].  This process consists of three
   steps: (1) verify that Q is not the point at infinity (O), (2) verify
   that for Q = (x, y) both integers x and y are in the correct
   interval, and (3) ensure that (x, y) is a correct solution to the
   elliptic curve equation.  For these curves, implementors do not need
   to verify membership in the correct subgroup.

   For X25519 and X448, the contents of the public value are the byte
   string inputs and outputs of the corresponding functions defined in
   [RFC7748]: 32 bytes for X25519 and 56 bytes for X448.

   Note: Versions of TLS prior to 1.3 permitted point format
   negotiation; TLS 1.3 removes this feature in favor of a single point
   format for each curve.","[
  {
    ""section_name"": ""4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters"",
    ""title"": ""ECDHE Parameters Encoding"",
    ""content"": ""ECDHE parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure.""
  },
  {
    ""section_name"": ""4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters"",
    ""title"": ""Uncompressed Point Representation"",
    ""content"": ""For secp256r1, secp384r1, and secp521r1, the contents are the serialized value of the following struct:\n\nstruct {\n    uint8 legacy_form = 4;\n    opaque X[coordinate_length];\n    opaque Y[coordinate_length];\n} UncompressedPointRepresentation;""
  },
  {
    ""section_name"": ""4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters"",
    ""title"": ""Coordinate Representations"",
    ""content"": ""X and Y are the binary representations of the x and y values in network byte order. Each number representation occupies as many octets as implied by the curve parameters:\n- For P-256, each of X and Y uses 32 octets, padded on the left by zeros if necessary.\n- For P-384, they take 48 octets each.\n- For P-521, they take 66 octets each.""
  },
  {
    ""section_name"": ""4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters"",
    ""title"": ""Public Value Validation"",
    ""content"": ""For the curves secp256r1, secp384r1, and secp521r1, peers MUST validate each other's public value Q by ensuring that the point is a valid point on the elliptic curve. The validation process consists of three steps:\n1. Verify that Q is not the point at infinity (O).\n2. Verify that both integers x and y are in the correct interval for Q = (x, y).\n3. Ensure that (x, y) is a correct solution to the elliptic curve equation.\nImplementors do not need to verify membership in the correct subgroup.""
  },
  {
    ""section_name"": ""4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters"",
    ""title"": ""Public Value for X25519 and X448"",
    ""content"": ""For X25519 and X448, the contents of the public value are the byte string inputs and outputs of the corresponding functions defined in [RFC7748]: 32 bytes for X25519 and 56 bytes for X448.""
  },
  {
    ""section_name"": ""4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters"",
    ""title"": ""Point Format Negotiation Removal"",
    ""content"": ""Note: Versions of TLS prior to 1.3 permitted point format negotiation; TLS 1.3 removes this feature in favor of a single point format for each curve.""
  }
]"
18,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,"In order to use PSKs, clients MUST also send a
   ""psk_key_exchange_modes"" extension.  The semantics of this extension
   are that the client only supports the use of PSKs with these modes,
   which restricts both the use of PSKs offered in this ClientHello and
   those which the server might supply via NewSessionTicket.

   A client MUST provide a ""psk_key_exchange_modes"" extension if it
   offers a ""pre_shared_key"" extension.  If clients offer
   ""pre_shared_key"" without a ""psk_key_exchange_modes"" extension,
   servers MUST abort the handshake.  Servers MUST NOT select a key
   exchange mode that is not listed by the client.  This extension also
   restricts the modes for use with PSK resumption.  Servers SHOULD NOT
   send NewSessionTicket with tickets that are not compatible with the
   advertised modes; however, if a server does so, the impact will just
   be that the client's attempts at resumption fail.

   The server MUST NOT send a ""psk_key_exchange_modes"" extension.

      enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;

      struct {
          PskKeyExchangeMode ke_modes<1..255>;
      } PskKeyExchangeModes;

   psk_ke:  PSK-only key establishment.  In this mode, the server
      MUST NOT supply a ""key_share"" value.

   psk_dhe_ke:  PSK with (EC)DHE key establishment.  In this mode, the
      client and server MUST supply ""key_share"" values as described in
      Section 4.2.8.

   Any future values that are allocated must ensure that the transmitted
   protocol messages unambiguously identify which mode was selected by
   the server; at present, this is indicated by the presence of the
   ""key_share"" in the ServerHello.","[
  {
    ""section_name"": ""4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes"",
    ""title"": ""PSK Key Exchange Modes Extension Overview"",
    ""content"": ""In order to use PSKs, clients MUST also send a \""psk_key_exchange_modes\"" extension. The semantics of this extension are that the client only supports the use of PSKs with these modes, which restricts both the use of PSKs offered in this ClientHello and those which the server might supply via NewSessionTicket.""
  },
  {
    ""section_name"": ""4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes"",
    ""title"": ""Client Requirements for PSK Extensions"",
    ""content"": ""A client MUST provide a \""psk_key_exchange_modes\"" extension if it offers a \""pre_shared_key\"" extension. If clients offer \""pre_shared_key\"" without a \""psk_key_exchange_modes\"" extension, servers MUST abort the handshake. Servers MUST NOT select a key exchange mode that is not listed by the client. This extension also restricts the modes for use with PSK resumption. Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes; however, if a server does so, the impact will just be that the client's attempts at resumption fail.""
  },
  {
    ""section_name"": ""4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes"",
    ""title"": ""Server Restrictions on PSK Extensions"",
    ""content"": ""The server MUST NOT send a \""psk_key_exchange_modes\"" extension.""
  },
  {
    ""section_name"": ""4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes"",
    ""title"": ""PskKeyExchangeMode Enumeration"",
    ""content"": ""enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;""
  },
  {
    ""section_name"": ""4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes"",
    ""title"": ""PskKeyExchangeModes Structure"",
    ""content"": ""struct {\n    PskKeyExchangeMode ke_modes<1..255>;\n} PskKeyExchangeModes;""
  },
  {
    ""section_name"": ""4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes"",
    ""title"": ""Key Exchange Mode Descriptions"",
    ""content"": ""1. psk_ke: PSK-only key establishment. In this mode, the server MUST NOT supply a \""key_share\"" value.\n\n2. psk_dhe_ke: PSK with (EC)DHE key establishment. In this mode, the client and server MUST supply \""key_share\"" values as described in Section 4.2.8.""
  },
  {
    ""section_name"": ""4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes"",
    ""title"": ""Future Key Exchange Modes"",
    ""content"": ""Any future values that are allocated must ensure that the transmitted protocol messages unambiguously identify which mode was selected by the server; at present, this is indicated by the presence of the \""key_share\"" in the ServerHello.""
  }
]"
19,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,"When a PSK is used and early data is allowed for that PSK, the client
   can send Application Data in its first flight of messages.  If the
   client opts to do so, it MUST supply both the ""pre_shared_key"" and
   ""early_data"" extensions.

   The ""extension_data"" field of this extension contains an
   ""EarlyDataIndication"" value.

      struct {} Empty;

      struct {
          select (Handshake.msg_type) {
              case new_session_ticket:   uint32 max_early_data_size;
              case client_hello:         Empty;
              case encrypted_extensions: Empty;
          };
      } EarlyDataIndication;

   See Section 4.6.1 for details regarding the use of the
   max_early_data_size field.

   The parameters for the 0-RTT data (version, symmetric cipher suite,
   Application-Layer Protocol Negotiation (ALPN) [RFC7301] protocol,
   etc.) are those associated with the PSK in use.  For externally
   provisioned PSKs, the associated values are those provisioned along
   with the key.  For PSKs established via a NewSessionTicket message,
   the associated values are those which were negotiated in the
   connection which established the PSK.  The PSK used to encrypt the
   early data MUST be the first PSK listed in the client's
   ""pre_shared_key"" extension.

   For PSKs provisioned via NewSessionTicket, a server MUST validate
   that the ticket age for the selected PSK identity (computed by
   subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age
   modulo 2^32) is within a small tolerance of the time since the ticket
   was issued (see Section 8).  If it is not, the server SHOULD proceed
   with the handshake but reject 0-RTT, and SHOULD NOT take any other
   action that assumes that this ClientHello is fresh.

   0-RTT messages sent in the first flight have the same (encrypted)
   content types as messages of the same type sent in other flights
   (handshake and application_data) but are protected under different
   keys.  After receiving the server's Finished message, if the server
   has accepted early data, an EndOfEarlyData message will be sent to
   indicate the key change.  This message will be encrypted with the
   0-RTT traffic keys.

   A server which receives an ""early_data"" extension MUST behave in one
   of three ways:

   -  Ignore the extension and return a regular 1-RTT response.  The
      server then skips past early data by attempting to deprotect
      received records using the handshake traffic key, discarding
      records which fail deprotection (up to the configured
      max_early_data_size).  Once a record is deprotected successfully,
      it is treated as the start of the client's second flight and the
      server proceeds as with an ordinary 1-RTT handshake.

   -  Request that the client send another ClientHello by responding
      with a HelloRetryRequest.  A client MUST NOT include the
      ""early_data"" extension in its followup ClientHello.  The server
      then ignores early data by skipping all records with an external
      content type of ""application_data"" (indicating that they are
      encrypted), up to the configured max_early_data_size.

   -  Return its own ""early_data"" extension in EncryptedExtensions,
      indicating that it intends to process the early data.  It is not
      possible for the server to accept only a subset of the early data
      messages.  Even though the server sends a message accepting early
      data, the actual early data itself may already be in flight by the
      time the server generates this message.

   In order to accept early data, the server MUST have accepted a PSK
   cipher suite and selected the first key offered in the client's
   ""pre_shared_key"" extension.  In addition, it MUST verify that the
   following values are the same as those associated with the
   selected PSK:

   -  The TLS version number

   -  The selected cipher suite

   -  The selected ALPN [RFC7301] protocol, if any

   These requirements are a superset of those needed to perform a 1-RTT
   handshake using the PSK in question.  For externally established
   PSKs, the associated values are those provisioned along with the key.
   For PSKs established via a NewSessionTicket message, the associated
   values are those negotiated in the connection during which the ticket
   was established.

   Future extensions MUST define their interaction with 0-RTT.

   If any of these checks fail, the server MUST NOT respond with the
   extension and must discard all the first-flight data using one of the
   first two mechanisms listed above (thus falling back to 1-RTT or
   2-RTT).  If the client attempts a 0-RTT handshake but the server
   rejects it, the server will generally not have the 0-RTT record
   protection keys and must instead use trial decryption (either with
   the 1-RTT handshake keys or by looking for a cleartext ClientHello in
   the case of a HelloRetryRequest) to find the first non-0-RTT message.

   If the server chooses to accept the ""early_data"" extension, then it
   MUST comply with the same error-handling requirements specified for
   all records when processing early data records.  Specifically, if the
   server fails to decrypt a 0-RTT record following an accepted
   ""early_data"" extension, it MUST terminate the connection with a
   ""bad_record_mac"" alert as per Section 5.2.

   If the server rejects the ""early_data"" extension, the client
   application MAY opt to retransmit the Application Data previously
   sent in early data once the handshake has been completed.  Note that
   automatic retransmission of early data could result in incorrect
   assumptions regarding the status of the connection.  For instance,
   when the negotiated connection selects a different ALPN protocol from
   what was used for the early data, an application might need to
   construct different messages.  Similarly, if early data assumes
   anything about the connection state, it might be sent in error after
   the handshake completes.

   A TLS implementation SHOULD NOT automatically resend early data;
   applications are in a better position to decide when retransmission
   is appropriate.  A TLS implementation MUST NOT automatically resend
   early data unless the negotiated connection selects the same ALPN
   protocol.","[
  {
    ""section_name"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Early Data Indication Overview"",
    ""content"": ""When a PSK is used and early data is allowed for that PSK, the client can send Application Data in its first flight of messages. If the client opts to do so, it MUST supply both the \""pre_shared_key\"" and \""early_data\"" extensions.""
  },
  {
    ""section_name"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Early Data Indication Structure"",
    ""content"": ""The \""extension_data\"" field of this extension contains an \""EarlyDataIndication\"" value.\n\nstruct {} Empty;\n\nstruct {\n    select (Handshake.msg_type) {\n        case new_session_ticket:   uint32 max_early_data_size;\n        case client_hello:         Empty;\n        case encrypted_extensions: Empty;\n    };\n} EarlyDataIndication;""
  },
  {
    ""section_name"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Parameters for 0-RTT Data"",
    ""content"": ""The parameters for the 0-RTT data (version, symmetric cipher suite, Application-Layer Protocol Negotiation (ALPN) [RFC7301] protocol, etc.) are those associated with the PSK in use. For externally provisioned PSKs, the associated values are those provisioned along with the key. For PSKs established via a NewSessionTicket message, the associated values are those which were negotiated in the connection which established the PSK. The PSK used to encrypt the early data MUST be the first PSK listed in the client's \""pre_shared_key\"" extension.""
  },
  {
    ""section_name"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Server Validation of PSK Ticket Age"",
    ""content"": ""For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued. If it is not, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.""
  },
  {
    ""section_name"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Handling Early Data Messages"",
    ""content"": ""0-RTT messages sent in the first flight have the same (encrypted) content types as messages of the same type sent in other flights (handshake and application_data) but are protected under different keys. After receiving the server's Finished message, if the server has accepted early data, an EndOfEarlyData message will be sent to indicate the key change. This message will be encrypted with the 0-RTT traffic keys.""
  },
  {
    ""section_name"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Server Response to Early Data Extension"",
    ""content"": ""A server which receives an \""early_data\"" extension MUST behave in one of three ways:\n\n- Ignore the extension and return a regular 1-RTT response. The server then skips past early data by attempting to deprotect received records using the handshake traffic key, discarding records which fail deprotection (up to the configured max_early_data_size). Once a record is deprotected successfully, it is treated as the start of the client's second flight and the server proceeds as with an ordinary 1-RTT handshake.\n\n- Request that the client send another ClientHello by responding with a HelloRetryRequest. A client MUST NOT include the \""early_data\"" extension in its followup ClientHello. The server then ignores early data by skipping all records with an external content type of \""application_data\"" (indicating that they are encrypted), up to the configured max_early_data_size.\n\n- Return its own \""early_data\"" extension in EncryptedExtensions, indicating that it intends to process the early data. It is not possible for the server to accept only a subset of the early data messages.""
  },
  {
    ""section_name"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Requirements for Accepting Early Data"",
    ""content"": ""In order to accept early data, the server MUST have accepted a PSK cipher suite and selected the first key offered in the client's \""pre_shared_key\"" extension. In addition, it MUST verify that the following values are the same as those associated with the selected PSK:\n\n- The TLS version number\n- The selected cipher suite\n- The selected ALPN [RFC7301] protocol, if any\n\nThese requirements are a superset of those needed to perform a 1-RTT handshake using the PSK in question.""
  },
  {
    ""section_name"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Error Handling for Early Data"",
    ""content"": ""If any of the checks fail, the server MUST NOT respond with the extension and must discard all the first-flight data using one of the first two mechanisms listed above (thus falling back to 1-RTT or 2-RTT). If the client attempts a 0-RTT handshake but the server rejects it, the server will generally not have the 0-RTT record protection keys and must instead use trial decryption to find the first non-0-RTT message.""
  },
  {
    ""section_name"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Error Handling Requirements"",
    ""content"": ""If the server chooses to accept the \""early_data\"" extension, then it MUST comply with the same error-handling requirements specified for all records when processing early data records. Specifically, if the server fails to decrypt a 0-RTT record following an accepted \""early_data\"" extension, it MUST terminate the connection with a \""bad_record_mac\"" alert as per Section 5.2.""
  },
  {
    ""section_name"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Client Handling of Rejected Early Data"",
    ""content"": ""If the server rejects the \""early_data\"" extension, the client application MAY opt to retransmit the Application Data previously sent in early data once the handshake has been completed. A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.""
  }
]"
20,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,"The ""pre_shared_key"" extension is used to negotiate the identity of
   the pre-shared key to be used with a given handshake in association
   with PSK key establishment.

   The ""extension_data"" field of this extension contains a
   ""PreSharedKeyExtension"" value:

      struct {
          opaque identity<1..2^16-1>;
          uint32 obfuscated_ticket_age;
      } PskIdentity;

      opaque PskBinderEntry<32..255>;

      struct {
          PskIdentity identities<7..2^16-1>;
          PskBinderEntry binders<33..2^16-1>;
      } OfferedPsks;

      struct {
          select (Handshake.msg_type) {
              case client_hello: OfferedPsks;
              case server_hello: uint16 selected_identity;
          };
      } PreSharedKeyExtension;

   identity:  A label for a key.  For instance, a ticket (as defined in
      Appendix B.3.4) or a label for a pre-shared key established
      externally.

   obfuscated_ticket_age:  An obfuscated version of the age of the key.
      Section 4.2.11.1 describes how to form this value for identities
      established via the NewSessionTicket message.  For identities
      established externally, an obfuscated_ticket_age of 0 SHOULD be
      used, and servers MUST ignore the value.

   identities:  A list of the identities that the client is willing to
      negotiate with the server.  If sent alongside the ""early_data""
      extension (see Section 4.2.10), the first identity is the one used
      for 0-RTT data.

   binders:  A series of HMAC values, one for each value in the
      identities list and in the same order, computed as described
      below.

   selected_identity:  The server's chosen identity expressed as a
      (0-based) index into the identities in the client's list.

   Each PSK is associated with a single Hash algorithm.  For PSKs
   established via the ticket mechanism (Section 4.6.1), this is the KDF
   Hash algorithm on the connection where the ticket was established.
   For externally established PSKs, the Hash algorithm MUST be set when

   the PSK is established or default to SHA-256 if no such algorithm is
   defined.  The server MUST ensure that it selects a compatible PSK
   (if any) and cipher suite.

   In TLS versions prior to TLS 1.3, the Server Name Identification
   (SNI) value was intended to be associated with the session (Section 3
   of [RFC6066]), with the server being required to enforce that the SNI
   value associated with the session matches the one specified in the
   resumption handshake.  However, in reality the implementations were
   not consistent on which of two supplied SNI values they would use,
   leading to the consistency requirement being de facto enforced by the
   clients.  In TLS 1.3, the SNI value is always explicitly specified in
   the resumption handshake, and there is no need for the server to
   associate an SNI value with the ticket.  Clients, however, SHOULD
   store the SNI with the PSK to fulfill the requirements of
   Section 4.6.1.

   Implementor's note: When session resumption is the primary use case
   of PSKs, the most straightforward way to implement the PSK/cipher
   suite matching requirements is to negotiate the cipher suite first
   and then exclude any incompatible PSKs.  Any unknown PSKs (e.g., ones
   not in the PSK database or encrypted with an unknown key) SHOULD
   simply be ignored.  If no acceptable PSKs are found, the server
   SHOULD perform a non-PSK handshake if possible.  If backward
   compatibility is important, client-provided, externally established
   PSKs SHOULD influence cipher suite selection.

   Prior to accepting PSK key establishment, the server MUST validate
   the corresponding binder value (see Section 4.2.11.2 below).  If this
   value is not present or does not validate, the server MUST abort the
   handshake.  Servers SHOULD NOT attempt to validate multiple binders;
   rather, they SHOULD select a single PSK and validate solely the
   binder that corresponds to that PSK.  See Section 8.2 and
   Appendix E.6 for the security rationale for this requirement.  In
   order to accept PSK key establishment, the server sends a
   ""pre_shared_key"" extension indicating the selected identity.

   Clients MUST verify that the server's selected_identity is within the
   range supplied by the client, that the server selected a cipher suite
   indicating a Hash associated with the PSK, and that a server
   ""key_share"" extension is present if required by the ClientHello
   ""psk_key_exchange_modes"" extension.  If these values are not
   consistent, the client MUST abort the handshake with an
   ""illegal_parameter"" alert.

   If the server supplies an ""early_data"" extension, the client MUST
   verify that the server's selected_identity is 0.  If any other value
   is returned, the client MUST abort the handshake with an
   ""illegal_parameter"" alert.

   The ""pre_shared_key"" extension MUST be the last extension in the
   ClientHello (this facilitates implementation as described below).
   Servers MUST check that it is the last extension and otherwise fail
   the handshake with an ""illegal_parameter"" alert.","[
  {
    ""section_name"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Pre-Shared Key Extension Overview"",
    ""content"": ""The \""pre_shared_key\"" extension is used to negotiate the identity of the pre-shared key to be used with a given handshake in association with PSK key establishment.""
  },
  {
    ""section_name"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""PreSharedKeyExtension Structure"",
    ""content"": ""The \""extension_data\"" field of this extension contains a \""PreSharedKeyExtension\"" value:\n\nstruct {\n    opaque identity<1..2^16-1>;\n    uint32 obfuscated_ticket_age;\n} PskIdentity;\n\nopaque PskBinderEntry<32..255>;\n\nstruct {\n    PskIdentity identities<7..2^16-1>;\n    PskBinderEntry binders<33..2^16-1>;\n} OfferedPsks;\n\nstruct {\n    select (Handshake.msg_type) {\n        case client_hello: OfferedPsks;\n        case server_hello: uint16 selected_identity;\n    };\n} PreSharedKeyExtension;""
  },
  {
    ""section_name"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Field Descriptions"",
    ""content"": ""1. identity: A label for a key, such as a ticket or a label for a pre-shared key established externally.\n\n2. obfuscated_ticket_age: An obfuscated version of the age of the key. For identities established via the NewSessionTicket message, this is formed as described in Section 4.2.11.1. For externally established identities, an obfuscated_ticket_age of 0 SHOULD be used, and servers MUST ignore the value.\n\n3. identities: A list of identities the client is willing to negotiate with the server. If sent alongside the \""early_data\"" extension, the first identity is used for 0-RTT data.\n\n4. binders: A series of HMAC values, one for each value in the identities list, computed as described below.\n\n5. selected_identity: The server's chosen identity expressed as a (0-based) index into the identities in the client's list.""
  },
  {
    ""section_name"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""PSK Hash Algorithm"",
    ""content"": ""Each PSK is associated with a single Hash algorithm. For PSKs established via the ticket mechanism, this is the KDF Hash algorithm on the connection where the ticket was established. For externally established PSKs, the Hash algorithm MUST be set when the PSK is established or default to SHA-256 if no such algorithm is defined. The server MUST ensure that it selects a compatible PSK (if any) and cipher suite.""
  },
  {
    ""section_name"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""SNI Handling in TLS 1.3"",
    ""content"": ""In TLS versions prior to TLS 1.3, the Server Name Identification (SNI) value was associated with the session. In TLS 1.3, the SNI value is always explicitly specified in the resumption handshake, and there is no need for the server to associate an SNI value with the ticket. Clients SHOULD store the SNI with the PSK to fulfill the requirements of Section 4.6.1.""
  },
  {
    ""section_name"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""PSK and Cipher Suite Matching"",
    ""content"": ""When session resumption is the primary use case of PSKs, the most straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and then exclude any incompatible PSKs. Unknown PSKs should be ignored. If no acceptable PSKs are found, the server SHOULD perform a non-PSK handshake if possible.""
  },
  {
    ""section_name"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Binder Validation"",
    ""content"": ""Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value. If this value is not present or does not validate, the server MUST abort the handshake. Servers SHOULD select a single PSK and validate solely the binder corresponding to that PSK.""
  },
  {
    ""section_name"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Client Verification"",
    ""content"": ""Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server \""key_share\"" extension is present if required by the ClientHello \""psk_key_exchange_modes\"" extension. If these values are not consistent, the client MUST abort the handshake with an \""illegal_parameter\"" alert.""
  },
  {
    ""section_name"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Early Data Handling"",
    ""content"": ""If the server supplies an \""early_data\"" extension, the client MUST verify that the server's selected_identity is 0. If any other value is returned, the client MUST abort the handshake with an \""illegal_parameter\"" alert.""
  },
  {
    ""section_name"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Extension Positioning"",
    ""content"": ""The \""pre_shared_key\"" extension MUST be the last extension in the ClientHello. Servers MUST check that it is the last extension and otherwise fail the handshake with an \""illegal_parameter\"" alert.""
  }
]"
21,4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age,"The client's view of the age of a ticket is the time since the
   receipt of the NewSessionTicket message.  Clients MUST NOT attempt to
   use tickets which have ages greater than the ""ticket_lifetime"" value
   which was provided with the ticket.  The ""obfuscated_ticket_age""
   field of each PskIdentity contains an obfuscated version of the
   ticket age formed by taking the age in milliseconds and adding the
   ""ticket_age_add"" value that was included with the ticket (see
   Section 4.6.1), modulo 2^32.  This addition prevents passive
   observers from correlating connections unless tickets are reused.
   Note that the ""ticket_lifetime"" field in the NewSessionTicket message
   is in seconds but the ""obfuscated_ticket_age"" is in milliseconds.
   Because ticket lifetimes are restricted to a week, 32 bits is enough
   to represent any plausible age, even in milliseconds.","[
  {
    ""section_name"": ""4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age"",
    ""title"": ""Client Ticket Age Handling"",
    ""content"": ""The client's view of the age of a ticket is the time since the receipt of the NewSessionTicket message. Clients MUST NOT attempt to use tickets which have ages greater than the \""ticket_lifetime\"" value provided with the ticket.""
  },
  {
    ""section_name"": ""4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age"",
    ""title"": ""Obfuscated Ticket Age Calculation"",
    ""content"": ""The \""obfuscated_ticket_age\"" field of each PskIdentity contains an obfuscated version of the ticket age. This is formed by taking the age in milliseconds and adding the \""ticket_age_add\"" value included with the ticket (see Section 4.6.1), modulo 2^32. This addition prevents passive observers from correlating connections unless tickets are reused.""
  },
  {
    ""section_name"": ""4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age"",
    ""title"": ""Ticket Lifetime and Age Representation"",
    ""content"": ""Note that the \""ticket_lifetime\"" field in the NewSessionTicket message is in seconds, while the \""obfuscated_ticket_age\"" is in milliseconds. Because ticket lifetimes are restricted to a week, 32 bits is sufficient to represent any plausible age, even in milliseconds.""
  }
]"
22,4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,"The PSK binder value forms a binding between a PSK and the current
   handshake, as well as a binding between the handshake in which the
   PSK was generated (if via a NewSessionTicket message) and the current
   handshake.  Each entry in the binders list is computed as an HMAC
   over a transcript hash (see Section 4.4.1) containing a partial
   ClientHello up to and including the PreSharedKeyExtension.identities
   field.  That is, it includes all of the ClientHello but not the
   binders list itself.  The length fields for the message (including
   the overall length, the length of the extensions block, and the
   length of the ""pre_shared_key"" extension) are all set as if binders
   of the correct lengths were present.

   The PskBinderEntry is computed in the same way as the Finished
   message (Section 4.4.4) but with the BaseKey being the binder_key
   derived via the key schedule from the corresponding PSK which is
   being offered (see Section 7.1).

   If the handshake includes a HelloRetryRequest, the initial
   ClientHello and HelloRetryRequest are included in the transcript
   along with the new ClientHello.  For instance, if the client sends
   ClientHello1, its binder will be computed over:

      Transcript-Hash(Truncate(ClientHello1))

   Where Truncate() removes the binders list from the ClientHello.

   If the server responds with a HelloRetryRequest and the client then
   sends ClientHello2, its binder will be computed over:

      Transcript-Hash(ClientHello1,
                      HelloRetryRequest,
                      Truncate(ClientHello2))

   The full ClientHello1/ClientHello2 is included in all other handshake
   hash computations.  Note that in the first flight,
   Truncate(ClientHello1) is hashed directly, but in the second flight,
   ClientHello1 is hashed and then reinjected as a ""message_hash""
   message, as described in Section 4.4.1.","[
  {
    ""section_name"": ""4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder"",
    ""title"": ""PSK Binder Overview"",
    ""content"": ""The PSK binder value forms a binding between a PSK and the current handshake, as well as a binding between the handshake in which the PSK was generated (if via a NewSessionTicket message) and the current handshake.""
  },
  {
    ""section_name"": ""4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder"",
    ""title"": ""Binder Computation"",
    ""content"": ""Each entry in the binders list is computed as an HMAC over a transcript hash containing a partial ClientHello up to and including the PreSharedKeyExtension.identities field. This includes all of the ClientHello but not the binders list itself. The length fields for the message (including the overall length, the length of the extensions block, and the length of the 'pre_shared_key' extension) are all set as if binders of the correct lengths were present.""
  },
  {
    ""section_name"": ""4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder"",
    ""title"": ""PskBinderEntry Calculation"",
    ""content"": ""The PskBinderEntry is computed in the same way as the Finished message but with the BaseKey being the binder_key derived via the key schedule from the corresponding PSK being offered.""
  },
  {
    ""section_name"": ""4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder"",
    ""title"": ""Handling HelloRetryRequest"",
    ""content"": ""If the handshake includes a HelloRetryRequest, the initial ClientHello and HelloRetryRequest are included in the transcript along with the new ClientHello. For instance, if the client sends ClientHello1, its binder will be computed over: Transcript-Hash(Truncate(ClientHello1)), where Truncate() removes the binders list from the ClientHello.""
  },
  {
    ""section_name"": ""4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder"",
    ""title"": ""Binder Computation with HelloRetryRequest"",
    ""content"": ""If the server responds with a HelloRetryRequest and the client then sends ClientHello2, its binder will be computed over: Transcript-Hash(ClientHello1, HelloRetryRequest, Truncate(ClientHello2)). The full ClientHello1/ClientHello2 is included in all other handshake hash computations.""
  },
  {
    ""section_name"": ""4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder"",
    ""title"": ""Hashing Process"",
    ""content"": ""In the first flight, Truncate(ClientHello1) is hashed directly, but in the second flight, ClientHello1 is hashed and then reinjected as a 'message_hash' message, as described in Section 4.4.1.""
  }
]"
23,4.2.11.3.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Processing Order,"Clients are permitted to ""stream"" 0-RTT data until they receive the
   server's Finished, only then sending the EndOfEarlyData message,
   followed by the rest of the handshake.  In order to avoid deadlocks,
   when accepting ""early_data"", servers MUST process the client's
   ClientHello and then immediately send their flight of messages,
   rather than waiting for the client's EndOfEarlyData message before
   sending its ServerHello.","[
  {
    ""section_name"": ""4.2.11.3.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Processing Order"",
    ""title"": ""0-RTT Data Streaming and Processing Order"",
    ""content"": ""Clients are permitted to \""stream\"" 0-RTT data until they receive the server's Finished message. Only after this should they send the EndOfEarlyData message, followed by the remainder of the handshake. To avoid deadlocks, when accepting early data, servers MUST process the client's ClientHello and then immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending its ServerHello.""
  }
]"
24,4.3.. Handshake Protocol_Server Parameters,"The next two messages from the server, EncryptedExtensions and
   CertificateRequest, contain information from the server that
   determines the rest of the handshake.  These messages are encrypted
   with keys derived from the server_handshake_traffic_secret.","[
  {
    ""section_name"": ""4.3.. Handshake Protocol_Server Parameters"",
    ""title"": ""Server Handshake Messages Overview"",
    ""content"": ""The next two messages from the server, EncryptedExtensions and CertificateRequest, contain information from the server that determines the rest of the handshake. These messages are encrypted with keys derived from the server_handshake_traffic_secret.""
  }
]"
25,4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,"In all handshakes, the server MUST send the EncryptedExtensions
   message immediately after the ServerHello message.  This is the first
   message that is encrypted under keys derived from the
   server_handshake_traffic_secret.

   The EncryptedExtensions message contains extensions that can be
   protected, i.e., any which are not needed to establish the
   cryptographic context but which are not associated with individual
   certificates.  The client MUST check EncryptedExtensions for the
   presence of any forbidden extensions and if any are found MUST abort
   the handshake with an ""illegal_parameter"" alert.

   Structure of this message:

      struct {
          Extension extensions<0..2^16-1>;
      } EncryptedExtensions;

   extensions:  A list of extensions.  For more information, see the
      table in Section 4.2.","[
  {
    ""section_name"": ""4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions"",
    ""title"": ""EncryptedExtensions Message Overview"",
    ""content"": ""In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message. This is the first message that is encrypted under keys derived from the server_handshake_traffic_secret.""
  },
  {
    ""section_name"": ""4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions"",
    ""title"": ""Purpose of EncryptedExtensions"",
    ""content"": ""The EncryptedExtensions message contains extensions that can be protected, i.e., any which are not needed to establish the cryptographic context but which are not associated with individual certificates. The client MUST check EncryptedExtensions for the presence of any forbidden extensions and if any are found MUST abort the handshake with an \""illegal_parameter\"" alert.""
  },
  {
    ""section_name"": ""4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions"",
    ""title"": ""EncryptedExtensions Message Structure"",
    ""content"": ""struct {\n    Extension extensions<0..2^16-1>;\n} EncryptedExtensions;""
  },
  {
    ""section_name"": ""4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions"",
    ""title"": ""Extensions Field Description"",
    ""content"": ""extensions: A list of extensions. For more information, see the table in Section 4.2.""
  }
]"
26,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,"A server which is authenticating with a certificate MAY optionally
   request a certificate from the client.  This message, if sent, MUST
   follow EncryptedExtensions.

   Structure of this message:

      struct {
          opaque certificate_request_context<0..2^8-1>;
          Extension extensions<2..2^16-1>;
      } CertificateRequest;

   certificate_request_context:  An opaque string which identifies the
      certificate request and which will be echoed in the client's
      Certificate message.  The certificate_request_context MUST be
      unique within the scope of this connection (thus preventing replay
      of client CertificateVerify messages).  This field SHALL be zero
      length unless used for the post-handshake authentication exchanges
      described in Section 4.6.2.  When requesting post-handshake
      authentication, the server SHOULD make the context unpredictable
      to the client (e.g., by randomly generating it) in order to
      prevent an attacker who has temporary access to the client's
      private key from pre-computing valid CertificateVerify messages.

   extensions:  A set of extensions describing the parameters of the
      certificate being requested.  The ""signature_algorithms"" extension
      MUST be specified, and other extensions may optionally be included
      if defined for this message.  Clients MUST ignore unrecognized
      extensions.

   In prior versions of TLS, the CertificateRequest message carried a
   list of signature algorithms and certificate authorities which the
   server would accept.  In TLS 1.3, the former is expressed by sending
   the ""signature_algorithms"" and optionally ""signature_algorithms_cert""
   extensions.  The latter is expressed by sending the
   ""certificate_authorities"" extension (see Section 4.2.4).

   Servers which are authenticating with a PSK MUST NOT send the
   CertificateRequest message in the main handshake, though they MAY
   send it in post-handshake authentication (see Section 4.6.2) provided
   that the client has sent the ""post_handshake_auth"" extension (see
   Section 4.2.6).","[
  {
    ""section_name"": ""4.3.2.. Handshake Protocol_Server Parameters_Certificate Request"",
    ""title"": ""CertificateRequest Message Overview"",
    ""content"": ""A server which is authenticating with a certificate MAY optionally request a certificate from the client. This message, if sent, MUST follow EncryptedExtensions.""
  },
  {
    ""section_name"": ""4.3.2.. Handshake Protocol_Server Parameters_Certificate Request"",
    ""title"": ""CertificateRequest Message Structure"",
    ""content"": ""struct {\n    opaque certificate_request_context<0..2^8-1>;\n    Extension extensions<2..2^16-1>;\n} CertificateRequest;""
  },
  {
    ""section_name"": ""4.3.2.. Handshake Protocol_Server Parameters_Certificate Request"",
    ""title"": ""Field Descriptions"",
    ""content"": ""1. certificate_request_context: An opaque string which identifies the certificate request and will be echoed in the client's Certificate message. This context MUST be unique within the scope of the connection to prevent replay of client CertificateVerify messages. This field SHALL be zero length unless used for post-handshake authentication exchanges described in Section 4.6.2. When requesting post-handshake authentication, the server SHOULD make the context unpredictable to the client to prevent pre-computation of valid CertificateVerify messages by an attacker.\n\n2. extensions: A set of extensions describing the parameters of the certificate being requested. The \""signature_algorithms\"" extension MUST be specified, and other extensions may optionally be included if defined for this message. Clients MUST ignore unrecognized extensions.""
  },
  {
    ""section_name"": ""4.3.2.. Handshake Protocol_Server Parameters_Certificate Request"",
    ""title"": ""Signature Algorithms and Certificate Authorities"",
    ""content"": ""In prior versions of TLS, the CertificateRequest message carried a list of signature algorithms and certificate authorities which the server would accept. In TLS 1.3, the former is expressed by sending the \""signature_algorithms\"" and optionally \""signature_algorithms_cert\"" extensions. The latter is expressed by sending the \""certificate_authorities\"" extension (see Section 4.2.4).""
  },
  {
    ""section_name"": ""4.3.2.. Handshake Protocol_Server Parameters_Certificate Request"",
    ""title"": ""Restrictions for PSK Authentication"",
    ""content"": ""Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the \""post_handshake_auth\"" extension (see Section 4.2.6).""
  }
]"
27,4.4.. Handshake Protocol_Authentication Messages,"As discussed in Section 2, TLS generally uses a common set of
   messages for authentication, key confirmation, and handshake
   integrity: Certificate, CertificateVerify, and Finished.  (The PSK
   binders also perform key confirmation, in a similar fashion.)  These
   three messages are always sent as the last messages in their
   handshake flight.  The Certificate and CertificateVerify messages are
   only sent under certain circumstances, as defined below.  The
   Finished message is always sent as part of the Authentication Block.
   These messages are encrypted under keys derived from the
   [sender]_handshake_traffic_secret.

   The computations for the Authentication messages all uniformly take
   the following inputs:

   -  The certificate and signing key to be used.

   -  A Handshake Context consisting of the set of messages to be
      included in the transcript hash.

   -  A Base Key to be used to compute a MAC key.

   Based on these inputs, the messages then contain:

   Certificate:  The certificate to be used for authentication, and any
      supporting certificates in the chain.  Note that certificate-based
      client authentication is not available in PSK handshake flows
      (including 0-RTT).

   CertificateVerify:  A signature over the value
      Transcript-Hash(Handshake Context, Certificate).

   Finished:  A MAC over the value Transcript-Hash(Handshake Context,
      Certificate, CertificateVerify) using a MAC key derived from the
      Base Key.

   The following table defines the Handshake Context and MAC Base Key
   for each scenario:

   +-----------+-------------------------+-----------------------------+
   | Mode      | Handshake Context       | Base Key                    |
   +-----------+-------------------------+-----------------------------+
   | Server    | ClientHello ... later   | server_handshake_traffic_   |
   |           | of EncryptedExtensions/ | secret                      |
   |           | CertificateRequest      |                             |
   |           |                         |                             |
   | Client    | ClientHello ... later   | client_handshake_traffic_   |
   |           | of server               | secret                      |
   |           | Finished/EndOfEarlyData |                             |
   |           |                         |                             |
   | Post-     | ClientHello ... client  | client_application_traffic_ |
   | Handshake | Finished +              | secret_N                    |
   |           | CertificateRequest      |                             |
   +-----------+-------------------------+-----------------------------+","[
  {
    ""section_name"": ""4.4.. Handshake Protocol_Authentication Messages"",
    ""title"": ""Overview of Authentication Messages"",
    ""content"": ""TLS generally uses a common set of messages for authentication, key confirmation, and handshake integrity: Certificate, CertificateVerify, and Finished. These three messages are always sent as the last messages in their handshake flight. The Certificate and CertificateVerify messages are only sent under certain circumstances, as defined below. The Finished message is always sent as part of the Authentication Block. These messages are encrypted under keys derived from the [sender]_handshake_traffic_secret.""
  },
  {
    ""section_name"": ""4.4.. Handshake Protocol_Authentication Messages"",
    ""title"": ""Inputs for Authentication Messages"",
    ""content"": ""The computations for the Authentication messages all uniformly take the following inputs:\n\n- The certificate and signing key to be used.\n- A Handshake Context consisting of the set of messages to be included in the transcript hash.\n- A Base Key to be used to compute a MAC key.""
  },
  {
    ""section_name"": ""4.4.. Handshake Protocol_Authentication Messages"",
    ""title"": ""Message Definitions"",
    ""content"": ""1. **Certificate**: The certificate to be used for authentication, and any supporting certificates in the chain. Note that certificate-based client authentication is not available in PSK handshake flows (including 0-RTT).\n\n2. **CertificateVerify**: A signature over the value Transcript-Hash(Handshake Context, Certificate).\n\n3. **Finished**: A MAC over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using a MAC key derived from the Base Key.""
  },
  {
    ""section_name"": ""4.4.. Handshake Protocol_Authentication Messages"",
    ""title"": ""Handshake Context and MAC Base Key"",
    ""content"": ""The following table defines the Handshake Context and MAC Base Key for each scenario:\n\n| Mode      | Handshake Context       | Base Key                    |\n|-----------|-------------------------|-----------------------------|\n| Server    | ClientHello ... later   | server_handshake_traffic_   |\n|           | of EncryptedExtensions/ | secret                      |\n|           | CertificateRequest      |                             |\n| Client    | ClientHello ... later   | client_handshake_traffic_   |\n|           | of server               | secret                      |\n|           | Finished/EndOfEarlyData |                             |\n| Post-     | ClientHello ... client  | client_application_traffic_ |\n| Handshake | Finished +              | secret_N                    |\n|           | CertificateRequest      |                             |""
  }
]"
28,4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,"Many of the cryptographic computations in TLS make use of a
   transcript hash.  This value is computed by hashing the concatenation
   of each included handshake message, including the handshake message
   header carrying the handshake message type and length fields, but not
   including record layer headers.  I.e.,

    Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)

   As an exception to this general rule, when the server responds to a
   ClientHello with a HelloRetryRequest, the value of ClientHello1 is
   replaced with a special synthetic handshake message of handshake type
   ""message_hash"" containing Hash(ClientHello1).  I.e.,

  Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =
      Hash(message_hash ||        /* Handshake type */
           00 00 Hash.length  ||  /* Handshake message length (bytes) */
           Hash(ClientHello1) ||  /* Hash of ClientHello1 */
           HelloRetryRequest  || ... || Mn)

   The reason for this construction is to allow the server to do a
   stateless HelloRetryRequest by storing just the hash of ClientHello1
   in the cookie, rather than requiring it to export the entire
   intermediate hash state (see Section 4.2.2).

   For concreteness, the transcript hash is always taken from the
   following sequence of handshake messages, starting at the first
   ClientHello and including only those messages that were sent:
   ClientHello, HelloRetryRequest, ClientHello, ServerHello,
   EncryptedExtensions, server CertificateRequest, server Certificate,
   server CertificateVerify, server Finished, EndOfEarlyData, client
   Certificate, client CertificateVerify, client Finished.

   In general, implementations can implement the transcript by keeping a
   running transcript hash value based on the negotiated hash.  Note,
   however, that subsequent post-handshake authentications do not
   include each other, just the messages through the end of the main
   handshake.","[
  {
    ""section_name"": ""4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash"",
    ""title"": ""Transcript Hash Overview"",
    ""content"": ""Many of the cryptographic computations in TLS make use of a transcript hash. This value is computed by hashing the concatenation of each included handshake message, including the handshake message header carrying the handshake message type and length fields, but not including record layer headers. I.e.,\n\nTranscript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)""
  },
  {
    ""section_name"": ""4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash"",
    ""title"": ""Special Case for HelloRetryRequest"",
    ""content"": ""As an exception to this general rule, when the server responds to a ClientHello with a HelloRetryRequest, the value of ClientHello1 is replaced with a special synthetic handshake message of handshake type \""message_hash\"" containing Hash(ClientHello1). I.e.,\n\nTranscript-Hash(ClientHello1, HelloRetryRequest, ... Mn) = Hash(message_hash || /* Handshake type */\n00 00 Hash.length || /* Handshake message length (bytes) */\nHash(ClientHello1) || /* Hash of ClientHello1 */\nHelloRetryRequest || ... || Mn)""
  },
  {
    ""section_name"": ""4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash"",
    ""title"": ""Purpose of the Synthetic Message"",
    ""content"": ""The reason for this construction is to allow the server to do a stateless HelloRetryRequest by storing just the hash of ClientHello1 in the cookie, rather than requiring it to export the entire intermediate hash state (see Section 4.2.2).""
  },
  {
    ""section_name"": ""4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash"",
    ""title"": ""Sequence of Handshake Messages for Transcript Hash"",
    ""content"": ""For concreteness, the transcript hash is always taken from the following sequence of handshake messages, starting at the first ClientHello and including only those messages that were sent: ClientHello, HelloRetryRequest, ClientHello, ServerHello, EncryptedExtensions, server CertificateRequest, server Certificate, server CertificateVerify, server Finished, EndOfEarlyData, client Certificate, client CertificateVerify, client Finished.""
  },
  {
    ""section_name"": ""4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash"",
    ""title"": ""Implementation of the Transcript Hash"",
    ""content"": ""In general, implementations can implement the transcript by keeping a running transcript hash value based on the negotiated hash. Note, however, that subsequent post-handshake authentications do not include each other, just the messages through the end of the main handshake.""
  }
]"
29,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,"This message conveys the endpoint's certificate chain to the peer.

   The server MUST send a Certificate message whenever the agreed-upon
   key exchange method uses certificates for authentication (this
   includes all key exchange methods defined in this document
   except PSK).

   The client MUST send a Certificate message if and only if the server
   has requested client authentication via a CertificateRequest message
   (Section 4.3.2).  If the server requests client authentication but no
   suitable certificate is available, the client MUST send a Certificate
   message containing no certificates (i.e., with the ""certificate_list""
   field having length 0).  A Finished message MUST be sent regardless
   of whether the Certificate message is empty.

   Structure of this message:

      enum {
          X509(0),
          RawPublicKey(2),
          (255)
      } CertificateType;

      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;

              case X509:
                opaque cert_data<1..2^24-1>;
          };
          Extension extensions<0..2^16-1>;
      } CertificateEntry;

      struct {
          opaque certificate_request_context<0..2^8-1>;
          CertificateEntry certificate_list<0..2^24-1>;
      } Certificate;

   certificate_request_context:  If this message is in response to a
      CertificateRequest, the value of certificate_request_context in
      that message.  Otherwise (in the case of server authentication),
      this field SHALL be zero length.

   certificate_list:  A sequence (chain) of CertificateEntry structures,
      each containing a single certificate and set of extensions.

   extensions:  A set of extension values for the CertificateEntry.  The
      ""Extension"" format is defined in Section 4.2.  Valid extensions
      for server certificates at present include the OCSP Status
      extension [RFC6066] and the SignedCertificateTimestamp extension
      [RFC6962]; future extensions may be defined for this message as
      well.  Extensions in the Certificate message from the server MUST
      correspond to ones from the ClientHello message.  Extensions in
      the Certificate message from the client MUST correspond to
      extensions in the CertificateRequest message from the server.  If
      an extension applies to the entire chain, it SHOULD be included in
      the first CertificateEntry.

   If the corresponding certificate type extension
   (""server_certificate_type"" or ""client_certificate_type"") was not
   negotiated in EncryptedExtensions, or the X.509 certificate type was
   negotiated, then each CertificateEntry contains a DER-encoded X.509
   certificate.  The sender's certificate MUST come in the first
   CertificateEntry in the list.  Each following certificate SHOULD
   directly certify the one immediately preceding it.  Because
   certificate validation requires that trust anchors be distributed
   independently, a certificate that specifies a trust anchor MAY be
   omitted from the chain, provided that supported peers are known to
   possess any omitted certificates.

   Note: Prior to TLS 1.3, ""certificate_list"" ordering required each
   certificate to certify the one immediately preceding it; however,
   some implementations allowed some flexibility.  Servers sometimes
   send both a current and deprecated intermediate for transitional
   purposes, and others are simply configured incorrectly, but these
   cases can nonetheless be validated properly.  For maximum
   compatibility, all implementations SHOULD be prepared to handle
   potentially extraneous certificates and arbitrary orderings from any
   TLS version, with the exception of the end-entity certificate which
   MUST be first.

   If the RawPublicKey certificate type was negotiated, then the
   certificate_list MUST contain no more than one CertificateEntry,
   which contains an ASN1_subjectPublicKeyInfo value as defined in
   [RFC7250], Section 3.

   The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.

   The server's certificate_list MUST always be non-empty.  A client
   will send an empty certificate_list if it does not have an
   appropriate certificate to send in response to the server's
   authentication request.","[
  {
    ""section_name"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Certificate Message Overview"",
    ""content"": ""This message conveys the endpoint's certificate chain to the peer. The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK). The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2). If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the \""certificate_list\"" field having length 0). A Finished message MUST be sent regardless of whether the Certificate message is empty.""
  },
  {
    ""section_name"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Certificate Message Structure"",
    ""content"": ""enum {\n    X509(0),\n    RawPublicKey(2),\n    (255)\n} CertificateType;\n\nstruct {\n    select (certificate_type) {\n        case RawPublicKey:\n            /* From RFC 7250 ASN.1_subjectPublicKeyInfo */\n            opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;\n\n        case X509:\n            opaque cert_data<1..2^24-1>;\n    };\n    Extension extensions<0..2^16-1>;\n} CertificateEntry;\n\nstruct {\n    opaque certificate_request_context<0..2^8-1>;\n    CertificateEntry certificate_list<0..2^24-1>;\n} Certificate;""
  },
  {
    ""section_name"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Field Descriptions"",
    ""content"": ""1. **certificate_request_context**: If this message is in response to a CertificateRequest, the value of certificate_request_context in that message. Otherwise (in the case of server authentication), this field SHALL be zero length.\n\n2. **certificate_list**: A sequence (chain) of CertificateEntry structures, each containing a single certificate and set of extensions.\n\n3. **extensions**: A set of extension values for the CertificateEntry. Valid extensions for server certificates include the OCSP Status extension [RFC6066] and the SignedCertificateTimestamp extension [RFC6962]. Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message, and those from the client MUST correspond to the CertificateRequest message from the server.""
  },
  {
    ""section_name"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Certificate Chain Requirements"",
    ""content"": ""If the corresponding certificate type extension (\""server_certificate_type\"" or \""client_certificate_type\"") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate. The sender's certificate MUST come in the first CertificateEntry in the list. Each following certificate SHOULD directly certify the one immediately preceding it. A certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates.""
  },
  {
    ""section_name"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Handling Certificate List Ordering"",
    ""content"": ""Prior to TLS 1.3, \""certificate_list\"" ordering required each certificate to certify the one immediately preceding it; however, some implementations allowed flexibility. For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first.""
  },
  {
    ""section_name"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""RawPublicKey Certificate Type"",
    ""content"": ""If the RawPublicKey certificate type was negotiated, then the certificate_list MUST contain no more than one CertificateEntry, which contains an ASN1_subjectPublicKeyInfo value as defined in [RFC7250], Section 3.""
  },
  {
    ""section_name"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""OpenPGP Certificate Type"",
    ""content"": ""The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.""
  },
  {
    ""section_name"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Server Certificate List Requirement"",
    ""content"": ""The server's certificate_list MUST always be non-empty. A client will send an empty certificate_list if it does not have an appropriate certificate to send in response to the server's authentication request.""
  }
]"
30,4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,"[RFC6066] and [RFC6961] provide extensions to negotiate the server
   sending OCSP responses to the client.  In TLS 1.2 and below, the
   server replies with an empty extension to indicate negotiation of
   this extension and the OCSP information is carried in a
   CertificateStatus message.  In TLS 1.3, the server's OCSP information
   is carried in an extension in the CertificateEntry containing the
   associated certificate.  Specifically, the body of the
   ""status_request"" extension from the server MUST be a
   CertificateStatus structure as defined in [RFC6066], which is
   interpreted as defined in [RFC6960].

   Note: The status_request_v2 extension [RFC6961] is deprecated.
   TLS 1.3 servers MUST NOT act upon its presence or information in it
   when processing ClientHello messages; in particular, they MUST NOT
   send the status_request_v2 extension in the EncryptedExtensions,
   CertificateRequest, or Certificate messages.  TLS 1.3 servers MUST be
   able to process ClientHello messages that include it, as it MAY be
   sent by clients that wish to use it in earlier protocol versions.

   A server MAY request that a client present an OCSP response with its
   certificate by sending an empty ""status_request"" extension in its
   CertificateRequest message.  If the client opts to send an OCSP
   response, the body of its ""status_request"" extension MUST be a
   CertificateStatus structure as defined in [RFC6066].

   Similarly, [RFC6962] provides a mechanism for a server to send a
   Signed Certificate Timestamp (SCT) as an extension in the ServerHello
   in TLS 1.2 and below.  In TLS 1.3, the server's SCT information is
   carried in an extension in the CertificateEntry.","[
  {
    ""section_name"": ""4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions"",
    ""title"": ""OCSP Status Extension in TLS 1.3"",
    ""content"": ""In TLS 1.3, the server's OCSP information is carried in an extension within the CertificateEntry that contains the associated certificate. The body of the 'status_request' extension from the server MUST be a CertificateStatus structure as defined in [RFC6066], which is interpreted according to [RFC6960].""
  },
  {
    ""section_name"": ""4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions"",
    ""title"": ""Deprecation of status_request_v2 Extension"",
    ""content"": ""The status_request_v2 extension [RFC6961] is deprecated. TLS 1.3 servers MUST NOT act upon its presence or the information contained within it when processing ClientHello messages. Specifically, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. However, TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients wishing to use it in earlier protocol versions.""
  },
  {
    ""section_name"": ""4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions"",
    ""title"": ""Client OCSP Response Request"",
    ""content"": ""A server MAY request that a client present an OCSP response with its certificate by sending an empty 'status_request' extension in its CertificateRequest message. If the client opts to send an OCSP response, the body of its 'status_request' extension MUST be a CertificateStatus structure as defined in [RFC6066].""
  },
  {
    ""section_name"": ""4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions"",
    ""title"": ""Signed Certificate Timestamp (SCT) Extension"",
    ""content"": ""Similarly, [RFC6962] provides a mechanism for a server to send a Signed Certificate Timestamp (SCT) as an extension in the ServerHello in TLS 1.2 and below. In TLS 1.3, the server's SCT information is carried in an extension within the CertificateEntry.""
  }
]"
31,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,"The following rules apply to the certificates sent by the server:

   -  The certificate type MUST be X.509v3 [RFC5280], unless explicitly
      negotiated otherwise (e.g., [RFC7250]).

   -  The server's end-entity certificate's public key (and associated
      restrictions) MUST be compatible with the selected authentication
      algorithm from the client's ""signature_algorithms"" extension
      (currently RSA, ECDSA, or EdDSA).

   -  The certificate MUST allow the key to be used for signing (i.e.,
      the digitalSignature bit MUST be set if the Key Usage extension is
      present) with a signature scheme indicated in the client's
      ""signature_algorithms""/""signature_algorithms_cert"" extensions (see
      Section 4.2.3).

   -  The ""server_name"" [RFC6066] and ""certificate_authorities""
      extensions are used to guide certificate selection.  As servers
      MAY require the presence of the ""server_name"" extension, clients
      SHOULD send this extension, when applicable.

   All certificates provided by the server MUST be signed by a signature
   algorithm advertised by the client if it is able to provide such a
   chain (see Section 4.2.3).  Certificates that are self-signed or
   certificates that are expected to be trust anchors are not validated
   as part of the chain and therefore MAY be signed with any algorithm.

   If the server cannot produce a certificate chain that is signed only
   via the indicated supported algorithms, then it SHOULD continue the
   handshake by sending the client a certificate chain of its choice
   that may include algorithms that are not known to be supported by the
   client.  This fallback chain SHOULD NOT use the deprecated SHA-1 hash
   algorithm in general, but MAY do so if the client's advertisement
   permits it, and MUST NOT do so otherwise.

   If the client cannot construct an acceptable chain using the provided
   certificates and decides to abort the handshake, then it MUST abort
   the handshake with an appropriate certificate-related alert (by
   default, ""unsupported_certificate""; see Section 6.2 for more
   information).

   If the server has multiple certificates, it chooses one of them based
   on the above-mentioned criteria (in addition to other criteria, such
   as transport-layer endpoint, local configuration, and preferences).","[
  {
    ""section_name"": ""4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection"",
    ""title"": ""Certificate Selection Rules"",
    ""content"": ""The following rules apply to the certificates sent by the server:\n\n- The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).\n\n- The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's \""signature_algorithms\"" extension (currently RSA, ECDSA, or EdDSA).\n\n- The certificate MUST allow the key to be used for signing (i.e., the digitalSignature bit MUST be set if the Key Usage extension is present) with a signature scheme indicated in the client's \""signature_algorithms\""/\""signature_algorithms_cert\"" extensions (see Section 4.2.3).\n\n- The \""server_name\"" [RFC6066] and \""certificate_authorities\"" extensions are used to guide certificate selection. As servers MAY require the presence of the \""server_name\"" extension, clients SHOULD send this extension when applicable.""
  },
  {
    ""section_name"": ""4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection"",
    ""title"": ""Certificate Chain Signing Requirements"",
    ""content"": ""All certificates provided by the server MUST be signed by a signature algorithm advertised by the client if it is able to provide such a chain (see Section 4.2.3). Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.""
  },
  {
    ""section_name"": ""4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection"",
    ""title"": ""Fallback Certificate Chain Handling"",
    ""content"": ""If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then it SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms that are not known to be supported by the client. This fallback chain SHOULD NOT use the deprecated SHA-1 hash algorithm in general, but MAY do so if the client's advertisement permits it, and MUST NOT do so otherwise.""
  },
  {
    ""section_name"": ""4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection"",
    ""title"": ""Client Handling of Certificate Chains"",
    ""content"": ""If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then it MUST abort the handshake with an appropriate certificate-related alert (by default, \""unsupported_certificate\""; see Section 6.2 for more information).""
  },
  {
    ""section_name"": ""4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection"",
    ""title"": ""Certificate Selection Criteria"",
    ""content"": ""If the server has multiple certificates, it chooses one of them based on the above-mentioned criteria (in addition to other criteria, such as transport-layer endpoint, local configuration, and preferences).""
  }
]"
32,4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection,"The following rules apply to certificates sent by the client:

   -  The certificate type MUST be X.509v3 [RFC5280], unless explicitly
      negotiated otherwise (e.g., [RFC7250]).

   -  If the ""certificate_authorities"" extension in the
      CertificateRequest message was present, at least one of the
      certificates in the certificate chain SHOULD be issued by one of
      the listed CAs.

   -  The certificates MUST be signed using an acceptable signature
      algorithm, as described in Section 4.3.2.  Note that this relaxes
      the constraints on certificate-signing algorithms found in prior
      versions of TLS.

   -  If the CertificateRequest message contained a non-empty
      ""oid_filters"" extension, the end-entity certificate MUST match the
      extension OIDs that are recognized by the client, as described in
      Section 4.2.5.","[
  {
    ""section_name"": ""4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection"",
    ""title"": ""Client Certificate Selection Rules"",
    ""content"": ""The following rules apply to certificates sent by the client:\n\n- The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).\n\n- If the \""certificate_authorities\"" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.\n\n- The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2. Note that this relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.\n\n- If the CertificateRequest message contained a non-empty \""oid_filters\"" extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client, as described in Section 4.2.5.""
  }
]"
33,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,"In general, detailed certificate validation procedures are out of
   scope for TLS (see [RFC5280]).  This section provides TLS-specific
   requirements.

   If the server supplies an empty Certificate message, the client MUST
   abort the handshake with a ""decode_error"" alert.

   If the client does not send any certificates (i.e., it sends an empty
   Certificate message), the server MAY at its discretion either
   continue the handshake without client authentication or abort the
   handshake with a ""certificate_required"" alert.  Also, if some aspect
   of the certificate chain was unacceptable (e.g., it was not signed by
   a known, trusted CA), the server MAY at its discretion either
   continue the handshake (considering the client unauthenticated) or
   abort the handshake.

   Any endpoint receiving any certificate which it would need to
   validate using any signature algorithm using an MD5 hash MUST abort
   the handshake with a ""bad_certificate"" alert.  SHA-1 is deprecated,
   and it is RECOMMENDED that any endpoint receiving any certificate
   which it would need to validate using any signature algorithm using a
   SHA-1 hash abort the handshake with a ""bad_certificate"" alert.  For
   clarity, this means that endpoints can accept these algorithms for
   certificates that are self-signed or are trust anchors.

   All endpoints are RECOMMENDED to transition to SHA-256 or better as
   soon as possible to maintain interoperability with implementations
   currently in the process of phasing out SHA-1 support.

   Note that a certificate containing a key for one signature algorithm
   MAY be signed using a different signature algorithm (for instance, an
   RSA key signed with an ECDSA key).","[
  {
    ""section_name"": ""4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message"",
    ""title"": ""Certificate Validation Requirements"",
    ""content"": ""In general, detailed certificate validation procedures are out of scope for TLS (see [RFC5280]). This section provides TLS-specific requirements.""
  },
  {
    ""section_name"": ""4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message"",
    ""title"": ""Server Certificate Handling"",
    ""content"": ""If the server supplies an empty Certificate message, the client MUST abort the handshake with a \""decode_error\"" alert.""
  },
  {
    ""section_name"": ""4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message"",
    ""title"": ""Client Certificate Handling"",
    ""content"": ""If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a \""certificate_required\"" alert. Additionally, if some aspect of the certificate chain was unacceptable (e.g., it was not signed by a known, trusted CA), the server MAY at its discretion either continue the handshake (considering the client unauthenticated) or abort the handshake.""
  },
  {
    ""section_name"": ""4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message"",
    ""title"": ""Signature Algorithm Restrictions"",
    ""content"": ""Any endpoint receiving any certificate which it would need to validate using any signature algorithm using an MD5 hash MUST abort the handshake with a \""bad_certificate\"" alert. SHA-1 is deprecated, and it is RECOMMENDED that any endpoint receiving any certificate which it would need to validate using any signature algorithm using a SHA-1 hash abort the handshake with a \""bad_certificate\"" alert. For clarity, this means that endpoints can accept these algorithms for certificates that are self-signed or are trust anchors.""
  },
  {
    ""section_name"": ""4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message"",
    ""title"": ""Transition to Stronger Algorithms"",
    ""content"": ""All endpoints are RECOMMENDED to transition to SHA-256 or better as soon as possible to maintain interoperability with implementations currently in the process of phasing out SHA-1 support.""
  },
  {
    ""section_name"": ""4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message"",
    ""title"": ""Signature Algorithm Flexibility"",
    ""content"": ""Note that a certificate containing a key for one signature algorithm MAY be signed using a different signature algorithm (for instance, an RSA key signed with an ECDSA key).""
  }
]"
34,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,"This message is used to provide explicit proof that an endpoint
   possesses the private key corresponding to its certificate.  The
   CertificateVerify message also provides integrity for the handshake
   up to this point.  Servers MUST send this message when authenticating
   via a certificate.  Clients MUST send this message whenever
   authenticating via a certificate (i.e., when the Certificate message
   is non-empty).  When sent, this message MUST appear immediately after
   the Certificate message and immediately prior to the Finished
   message.

   Structure of this message:

      struct {
          SignatureScheme algorithm;
          opaque signature<0..2^16-1>;
      } CertificateVerify;

   The algorithm field specifies the signature algorithm used (see
   Section 4.2.3 for the definition of this type).  The signature is a
   digital signature using that algorithm.  The content that is covered
   under the signature is the hash output as described in Section 4.4.1,
   namely:

      Transcript-Hash(Handshake Context, Certificate)

   The digital signature is then computed over the concatenation of:

   -  A string that consists of octet 32 (0x20) repeated 64 times

   -  The context string

   -  A single 0 byte which serves as the separator

   -  The content to be signed

   This structure is intended to prevent an attack on previous versions
   of TLS in which the ServerKeyExchange format meant that attackers
   could obtain a signature of a message with a chosen 32-byte prefix
   (ClientHello.random).  The initial 64-byte pad clears that prefix
   along with the server-controlled ServerHello.random.

   The context string for a server signature is
   ""TLS 1.3, server CertificateVerify"".  The context string for a
   client signature is ""TLS 1.3, client CertificateVerify"".  It is
   used to provide separation between signatures made in different
   contexts, helping against potential cross-protocol attacks.

   For example, if the transcript hash was 32 bytes of 01 (this length
   would make sense for SHA-256), the content covered by the digital
   signature for a server CertificateVerify would be:

      2020202020202020202020202020202020202020202020202020202020202020
      2020202020202020202020202020202020202020202020202020202020202020
      544c5320312e332c207365727665722043657274696669636174655665726966
      79
      00
      0101010101010101010101010101010101010101010101010101010101010101

   On the sender side, the process for computing the signature field of
   the CertificateVerify message takes as input:

   -  The content covered by the digital signature

   -  The private signing key corresponding to the certificate sent in
      the previous message

   If the CertificateVerify message is sent by a server, the signature
   algorithm MUST be one offered in the client's ""signature_algorithms""
   extension unless no valid certificate chain can be produced without
   unsupported algorithms (see Section 4.2.3).

   If sent by a client, the signature algorithm used in the signature
   MUST be one of those present in the supported_signature_algorithms
   field of the ""signature_algorithms"" extension in the
   CertificateRequest message.

   In addition, the signature algorithm MUST be compatible with the key
   in the sender's end-entity certificate.  RSA signatures MUST use an
   RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5
   algorithms appear in ""signature_algorithms"".  The SHA-1 algorithm
   MUST NOT be used in any signatures of CertificateVerify messages.

   All SHA-1 signature algorithms in this specification are defined
   solely for use in legacy certificates and are not valid for
   CertificateVerify signatures.

   The receiver of a CertificateVerify message MUST verify the signature
   field.  The verification process takes as input:

   -  The content covered by the digital signature

   -  The public key contained in the end-entity certificate found in
      the associated Certificate message

   -  The digital signature received in the signature field of the
      CertificateVerify message

   If the verification fails, the receiver MUST terminate the handshake
   with a ""decrypt_error"" alert.","[
  {
    ""section_name"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""CertificateVerify Message Overview"",
    ""content"": ""This message is used to provide explicit proof that an endpoint possesses the private key corresponding to its certificate. The CertificateVerify message also provides integrity for the handshake up to this point. Servers MUST send this message when authenticating via a certificate. Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty). When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.""
  },
  {
    ""section_name"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""CertificateVerify Message Structure"",
    ""content"": ""struct {\n    SignatureScheme algorithm;\n    opaque signature<0..2^16-1>;\n} CertificateVerify;""
  },
  {
    ""section_name"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""Signature Algorithm and Content"",
    ""content"": ""The algorithm field specifies the signature algorithm used (see Section 4.2.3 for the definition of this type). The signature is a digital signature using that algorithm. The content that is covered under the signature is the hash output as described in Section 4.4.1, namely:\n\n    Transcript-Hash(Handshake Context, Certificate)\n\nThe digital signature is computed over the concatenation of:\n\n- A string that consists of octet 32 (0x20) repeated 64 times\n- The context string\n- A single 0 byte which serves as the separator\n- The content to be signed.""
  },
  {
    ""section_name"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""Context Strings"",
    ""content"": ""The context string for a server signature is \""TLS 1.3, server CertificateVerify\"". The context string for a client signature is \""TLS 1.3, client CertificateVerify\"". This separation helps against potential cross-protocol attacks.""
  },
  {
    ""section_name"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""Signature Calculation Example"",
    ""content"": ""For example, if the transcript hash was 32 bytes of 01 (this length would make sense for SHA-256), the content covered by the digital signature for a server CertificateVerify would be:\n\n    2020202020202020202020202020202020202020202020202020202020202020\n    2020202020202020202020202020202020202020202020202020202020202020\n    544c5320312e332c207365727665722043657274696669636174655665726966\n    79\n    00\n    0101010101010101010101010101010101010101010101010101010101010101""
  },
  {
    ""section_name"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""Signature Generation Process"",
    ""content"": ""On the sender side, the process for computing the signature field of the CertificateVerify message takes as input:\n\n- The content covered by the digital signature\n- The private signing key corresponding to the certificate sent in the previous message.""
  },
  {
    ""section_name"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""Signature Algorithm Requirements"",
    ""content"": ""If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's \""signature_algorithms\"" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3). If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the \""signature_algorithms\"" extension in the CertificateRequest message.""
  },
  {
    ""section_name"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""Signature Algorithm Compatibility"",
    ""content"": ""The signature algorithm MUST be compatible with the key in the sender's end-entity certificate. RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in \""signature_algorithms\"". The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.""
  },
  {
    ""section_name"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""Signature Verification Process"",
    ""content"": ""The receiver of a CertificateVerify message MUST verify the signature field. The verification process takes as input:\n\n- The content covered by the digital signature\n- The public key contained in the end-entity certificate found in the associated Certificate message\n- The digital signature received in the signature field of the CertificateVerify message.""
  },
  {
    ""section_name"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""Error Handling"",
    ""content"": ""If the verification fails, the receiver MUST terminate the handshake with a \""decrypt_error\"" alert.""
  }
]"
35,4.4.4.. Handshake Protocol_Authentication Messages_Finished,"The Finished message is the final message in the Authentication
   Block.  It is essential for providing authentication of the handshake
   and of the computed keys.

   Recipients of Finished messages MUST verify that the contents are
   correct and if incorrect MUST terminate the connection with a
   ""decrypt_error"" alert.

   Once a side has sent its Finished message and has received and
   validated the Finished message from its peer, it may begin to send
   and receive Application Data over the connection.  There are two
   settings in which it is permitted to send data prior to receiving the
   peer's Finished:

   1.  Clients sending 0-RTT data as described in Section 4.2.10.

   2.  Servers MAY send data after sending their first flight, but
       because the handshake is not yet complete, they have no assurance
       of either the peer's identity or its liveness (i.e., the
       ClientHello might have been replayed).

   The key used to compute the Finished message is computed from the
   Base Key defined in Section 4.4 using HKDF (see Section 7.1).
   Specifically:

   finished_key =
       HKDF-Expand-Label(BaseKey, ""finished"", """", Hash.length)

   Structure of this message:

      struct {
          opaque verify_data[Hash.length];
      } Finished;

   The verify_data value is computed as follows:

      verify_data =
          HMAC(finished_key,
               Transcript-Hash(Handshake Context,
                               Certificate*, CertificateVerify*))

      * Only included if present.

   HMAC [RFC2104] uses the Hash algorithm for the handshake.  As noted
   above, the HMAC input can generally be implemented by a running hash,
   i.e., just the handshake hash at this point.

   In previous versions of TLS, the verify_data was always 12 octets
   long.  In TLS 1.3, it is the size of the HMAC output for the Hash
   used for the handshake.

   Note: Alerts and any other non-handshake record types are not
   handshake messages and are not included in the hash computations.

   Any records following a Finished message MUST be encrypted under the
   appropriate application traffic key as described in Section 7.2.  In
   particular, this includes any alerts sent by the server in response
   to client Certificate and CertificateVerify messages.","[
  {
    ""section_name"": ""4.4.4.. Handshake Protocol_Authentication Messages_Finished"",
    ""title"": ""Finished Message Overview"",
    ""content"": ""The Finished message is the final message in the Authentication Block. It is essential for providing authentication of the handshake and of the computed keys. Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a \""decrypt_error\"" alert.""
  },
  {
    ""section_name"": ""4.4.4.. Handshake Protocol_Authentication Messages_Finished"",
    ""title"": ""Sending Application Data"",
    ""content"": ""Once a side has sent its Finished message and has received and validated the Finished message from its peer, it may begin to send and receive Application Data over the connection. There are two settings in which it is permitted to send data prior to receiving the peer's Finished: 1. Clients sending 0-RTT data as described in Section 4.2.10. 2. Servers MAY send data after sending their first flight, but because the handshake is not yet complete, they have no assurance of either the peer's identity or its liveness (i.e., the ClientHello might have been replayed).""
  },
  {
    ""section_name"": ""4.4.4.. Handshake Protocol_Authentication Messages_Finished"",
    ""title"": ""Finished Message Key Computation"",
    ""content"": ""The key used to compute the Finished message is computed from the Base Key defined in Section 4.4 using HKDF (see Section 7.1). Specifically: finished_key = HKDF-Expand-Label(BaseKey, \""finished\"", \""\"", Hash.length).""
  },
  {
    ""section_name"": ""4.4.4.. Handshake Protocol_Authentication Messages_Finished"",
    ""title"": ""Finished Message Structure"",
    ""content"": ""struct { opaque verify_data[Hash.length]; } Finished;""
  },
  {
    ""section_name"": ""4.4.4.. Handshake Protocol_Authentication Messages_Finished"",
    ""title"": ""Verify Data Calculation"",
    ""content"": ""The verify_data value is computed as follows: verify_data = HMAC(finished_key, Transcript-Hash(Handshake Context, Certificate*, CertificateVerify*)). * Only included if present. HMAC [RFC2104] uses the Hash algorithm for the handshake. As noted above, the HMAC input can generally be implemented by a running hash, i.e., just the handshake hash at this point.""
  },
  {
    ""section_name"": ""4.4.4.. Handshake Protocol_Authentication Messages_Finished"",
    ""title"": ""HMAC Output Size"",
    ""content"": ""In previous versions of TLS, the verify_data was always 12 octets long. In TLS 1.3, it is the size of the HMAC output for the Hash used for the handshake.""
  },
  {
    ""section_name"": ""4.4.4.. Handshake Protocol_Authentication Messages_Finished"",
    ""title"": ""Post-Finished Message Requirements"",
    ""content"": ""Any records following a Finished message MUST be encrypted under the appropriate application traffic key as described in Section 7.2. In particular, this includes any alerts sent by the server in response to client Certificate and CertificateVerify messages.""
  }
]"
36,4.5.. Handshake Protocol_End of Early Data,"struct {} EndOfEarlyData;

   If the server sent an ""early_data"" extension in EncryptedExtensions,
   the client MUST send an EndOfEarlyData message after receiving the
   server Finished.  If the server does not send an ""early_data""
   extension in EncryptedExtensions, then the client MUST NOT send an
   EndOfEarlyData message.  This message indicates that all 0-RTT
   application_data messages, if any, have been transmitted and that the

   following records are protected under handshake traffic keys.
   Servers MUST NOT send this message, and clients receiving it MUST
   terminate the connection with an ""unexpected_message"" alert.  This
   message is encrypted under keys derived from the
   client_early_traffic_secret.","[
  {
    ""section_name"": ""4.5.. Handshake Protocol_End of Early Data"",
    ""title"": ""EndOfEarlyData Message Overview"",
    ""content"": ""struct {} EndOfEarlyData;\n\nIf the server sent an \""early_data\"" extension in EncryptedExtensions, the client MUST send an EndOfEarlyData message after receiving the server Finished. If the server does not send an \""early_data\"" extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message. This message indicates that all 0-RTT application_data messages, if any, have been transmitted and that the following records are protected under handshake traffic keys.""
  },
  {
    ""section_name"": ""4.5.. Handshake Protocol_End of Early Data"",
    ""title"": ""Message Handling Requirements"",
    ""content"": ""Servers MUST NOT send this message, and clients receiving it MUST terminate the connection with an \""unexpected_message\"" alert. This message is encrypted under keys derived from the client_early_traffic_secret.""
  }
]"
37,4.6.. Handshake Protocol_Post-Handshake Messages,"TLS also allows other messages to be sent after the main handshake.
   These messages use a handshake content type and are encrypted under
   the appropriate application traffic key.","[
  {
    ""section_name"": ""4.6.. Handshake Protocol_Post-Handshake Messages"",
    ""title"": ""Post-Handshake Message Overview"",
    ""content"": ""TLS also allows other messages to be sent after the main handshake. These messages use a handshake content type and are encrypted under the appropriate application traffic key.""
  }
]"
38,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,"At any time after the server has received the client Finished
   message, it MAY send a NewSessionTicket message.  This message
   creates a unique association between the ticket value and a secret
   PSK derived from the resumption master secret (see Section 7).

   The client MAY use this PSK for future handshakes by including the
   ticket value in the ""pre_shared_key"" extension in its ClientHello
   (Section 4.2.11).  Servers MAY send multiple tickets on a single
   connection, either immediately after each other or after specific
   events (see Appendix C.4).  For instance, the server might send a new
   ticket after post-handshake authentication in order to encapsulate
   the additional client authentication state.  Multiple tickets are
   useful for clients for a variety of purposes, including:

   -  Opening multiple parallel HTTP connections.

   -  Performing connection racing across interfaces and address
      families via (for example) Happy Eyeballs [RFC8305] or related
      techniques.

   Any ticket MUST only be resumed with a cipher suite that has the same
   KDF hash algorithm as that used to establish the original connection.

   Clients MUST only resume if the new SNI value is valid for the server
   certificate presented in the original session and SHOULD only resume
   if the SNI value matches the one used in the original session.  The
   latter is a performance optimization: normally, there is no reason to
   expect that different servers covered by a single certificate would
   be able to accept each other's tickets; hence, attempting resumption
   in that case would waste a single-use ticket.  If such an indication
   is provided (externally or by any other means), clients MAY resume
   with a different SNI value.

   On resumption, if reporting an SNI value to the calling application,
   implementations MUST use the value sent in the resumption ClientHello
   rather than the value sent in the previous session.  Note that if a
   server implementation declines all PSK identities with different SNI
   values, these two values are always the same.

   Note: Although the resumption master secret depends on the client's
   second flight, a server which does not request client authentication
   MAY compute the remainder of the transcript independently and then
   send a NewSessionTicket immediately upon sending its Finished rather
   than waiting for the client Finished.  This might be appropriate in
   cases where the client is expected to open multiple TLS connections
   in parallel and would benefit from the reduced overhead of a
   resumption handshake, for example.

      struct {
          uint32 ticket_lifetime;
          uint32 ticket_age_add;
          opaque ticket_nonce<0..255>;
          opaque ticket<1..2^16-1>;
          Extension extensions<0..2^16-2>;
      } NewSessionTicket;

   ticket_lifetime:  Indicates the lifetime in seconds as a 32-bit
      unsigned integer in network byte order from the time of ticket
      issuance.  Servers MUST NOT use any value greater than
      604800 seconds (7 days).  The value of zero indicates that the
      ticket should be discarded immediately.  Clients MUST NOT cache
      tickets for longer than 7 days, regardless of the ticket_lifetime,
      and MAY delete tickets earlier based on local policy.  A server
      MAY treat a ticket as valid for a shorter period of time than what
      is stated in the ticket_lifetime.

   ticket_age_add:  A securely generated, random 32-bit value that is
      used to obscure the age of the ticket that the client includes in
      the ""pre_shared_key"" extension.  The client-side ticket age is
      added to this value modulo 2^32 to obtain the value that is
      transmitted by the client.  The server MUST generate a fresh value
      for each ticket it sends.

   ticket_nonce:  A per-ticket value that is unique across all tickets
      issued on this connection.

   ticket:  The value of the ticket to be used as the PSK identity.  The
      ticket itself is an opaque label.  It MAY be either a database
      lookup key or a self-encrypted and self-authenticated value.

   extensions:  A set of extension values for the ticket.  The
      ""Extension"" format is defined in Section 4.2.  Clients MUST ignore
      unrecognized extensions.

   The sole extension currently defined for NewSessionTicket is
   ""early_data"", indicating that the ticket may be used to send 0-RTT
   data (Section 4.2.10).  It contains the following value:

   max_early_data_size:  The maximum amount of 0-RTT data that the
      client is allowed to send when using this ticket, in bytes.  Only
      Application Data payload (i.e., plaintext but not padding or the
      inner content type byte) is counted.  A server receiving more than
      max_early_data_size bytes of 0-RTT data SHOULD terminate the
      connection with an ""unexpected_message"" alert.  Note that servers
      that reject early data due to lack of cryptographic material will
      be unable to differentiate padding from content, so clients
      SHOULD NOT depend on being able to send large quantities of
      padding in early data records.

   The PSK associated with the ticket is computed as:

       HKDF-Expand-Label(resumption_master_secret,
                        ""resumption"", ticket_nonce, Hash.length)

   Because the ticket_nonce value is distinct for each NewSessionTicket
   message, a different PSK will be derived for each ticket.

   Note that in principle it is possible to continue issuing new tickets
   which indefinitely extend the lifetime of the keying material
   originally derived from an initial non-PSK handshake (which was most
   likely tied to the peer's certificate).  It is RECOMMENDED that
   implementations place limits on the total lifetime of such keying
   material; these limits should take into account the lifetime of the
   peer's certificate, the likelihood of intervening revocation, and the
   time since the peer's online CertificateVerify signature.","[
  {
    ""section_name"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""NewSessionTicket Message Overview"",
    ""content"": ""At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message. This message creates a unique association between the ticket value and a secret PSK derived from the resumption master secret (see Section 7). The client MAY use this PSK for future handshakes by including the ticket value in the \""pre_shared_key\"" extension in its ClientHello (Section 4.2.11). Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events (see Appendix C.4).""
  },
  {
    ""section_name"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""Purpose of Multiple Tickets"",
    ""content"": ""Multiple tickets are useful for clients for a variety of purposes, including:\n\n- Opening multiple parallel HTTP connections.\n- Performing connection racing across interfaces and address families via (for example) Happy Eyeballs [RFC8305] or related techniques.""
  },
  {
    ""section_name"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""Ticket Resumption Requirements"",
    ""content"": ""Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection. Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session. If such an indication is provided (externally or by any other means), clients MAY resume with a different SNI value.""
  },
  {
    ""section_name"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""SNI Value Reporting"",
    ""content"": ""On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session. Note that if a server implementation declines all PSK identities with different SNI values, these two values are always the same.""
  },
  {
    ""section_name"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""NewSessionTicket Structure"",
    ""content"": ""struct {\n    uint32 ticket_lifetime;\n    uint32 ticket_age_add;\n    opaque ticket_nonce<0..255>;\n    opaque ticket<1..2^16-1>;\n    Extension extensions<0..2^16-2>;\n} NewSessionTicket;""
  },
  {
    ""section_name"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""Field Descriptions"",
    ""content"": ""1. ticket_lifetime: Indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance. Servers MUST NOT use any value greater than 604800 seconds (7 days). The value of zero indicates that the ticket should be discarded immediately.\n\n2. ticket_age_add: A securely generated, random 32-bit value that obscures the age of the ticket included in the \""pre_shared_key\"" extension. The server MUST generate a fresh value for each ticket it sends.\n\n3. ticket_nonce: A per-ticket value that is unique across all tickets issued on this connection.\n\n4. ticket: The value of the ticket to be used as the PSK identity. It MAY be either a database lookup key or a self-encrypted and self-authenticated value.\n\n5. extensions: A set of extension values for the ticket. Clients MUST ignore unrecognized extensions.""
  },
  {
    ""section_name"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""Early Data Extension"",
    ""content"": ""The sole extension currently defined for NewSessionTicket is \""early_data\"", indicating that the ticket may be used to send 0-RTT data (Section 4.2.10). It contains the value max_early_data_size, which is the maximum amount of 0-RTT data that the client is allowed to send when using this ticket, in bytes.""
  },
  {
    ""section_name"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""PSK Derivation"",
    ""content"": ""The PSK associated with the ticket is computed as:\n\n    HKDF-Expand-Label(resumption_master_secret, \""resumption\"", ticket_nonce, Hash.length)\n\nBecause the ticket_nonce value is distinct for each NewSessionTicket message, a different PSK will be derived for each ticket.""
  },
  {
    ""section_name"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""Keying Material Lifetime"",
    ""content"": ""It is RECOMMENDED that implementations place limits on the total lifetime of keying material derived from an initial non-PSK handshake. These limits should consider the lifetime of the peer's certificate, the likelihood of intervening revocation, and the time since the peer's online CertificateVerify signature.""
  }
]"
39,4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,"When the client has sent the ""post_handshake_auth"" extension (see
   Section 4.2.6), a server MAY request client authentication at any
   time after the handshake has completed by sending a
   CertificateRequest message.  The client MUST respond with the
   appropriate Authentication messages (see Section 4.4).  If the client
   chooses to authenticate, it MUST send Certificate, CertificateVerify,

   and Finished.  If it declines, it MUST send a Certificate message
   containing no certificates followed by Finished.  All of the client's
   messages for a given response MUST appear consecutively on the wire
   with no intervening messages of other types.

   A client that receives a CertificateRequest message without having
   sent the ""post_handshake_auth"" extension MUST send an
   ""unexpected_message"" fatal alert.

   Note: Because client authentication could involve prompting the user,
   servers MUST be prepared for some delay, including receiving an
   arbitrary number of other messages between sending the
   CertificateRequest and receiving a response.  In addition, clients
   which receive multiple CertificateRequests in close succession MAY
   respond to them in a different order than they were received (the
   certificate_request_context value allows the server to disambiguate
   the responses).","[
  {
    ""section_name"": ""4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication"",
    ""title"": ""Post-Handshake Authentication Overview"",
    ""content"": ""When the client has sent the \""post_handshake_auth\"" extension, a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message. The client MUST respond with the appropriate Authentication messages. If the client chooses to authenticate, it MUST send Certificate, CertificateVerify, and Finished. If it declines, it MUST send a Certificate message containing no certificates followed by Finished. All of the client's messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.""
  },
  {
    ""section_name"": ""4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication"",
    ""title"": ""CertificateRequest Handling"",
    ""content"": ""A client that receives a CertificateRequest message without having sent the \""post_handshake_auth\"" extension MUST send an \""unexpected_message\"" fatal alert.""
  },
  {
    ""section_name"": ""4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication"",
    ""title"": ""Client Response Timing Considerations"",
    ""content"": ""Because client authentication could involve prompting the user, servers MUST be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response. In addition, clients which receive multiple CertificateRequests in close succession MAY respond to them in a different order than they were received, as the certificate_request_context value allows the server to disambiguate the responses.""
  }
]"
40,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,"The KeyUpdate handshake message is used to indicate that the sender
   is updating its sending cryptographic keys.  This message can be sent
   by either peer after it has sent a Finished message.  Implementations
   that receive a KeyUpdate message prior to receiving a Finished
   message MUST terminate the connection with an ""unexpected_message""
   alert.  After sending a KeyUpdate message, the sender SHALL send all
   its traffic using the next generation of keys, computed as described
   in Section 7.2.  Upon receiving a KeyUpdate, the receiver MUST update
   its receiving keys.

      enum {
          update_not_requested(0), update_requested(1), (255)
      } KeyUpdateRequest;

      struct {
          KeyUpdateRequest request_update;
      } KeyUpdate;

   request_update:  Indicates whether the recipient of the KeyUpdate
      should respond with its own KeyUpdate.  If an implementation
      receives any other value, it MUST terminate the connection with an
      ""illegal_parameter"" alert.

   If the request_update field is set to ""update_requested"", then the
   receiver MUST send a KeyUpdate of its own with request_update set to
   ""update_not_requested"" prior to sending its next Application Data
   record.  This mechanism allows either side to force an update to the
   entire connection, but causes an implementation which receives

   multiple KeyUpdates while it is silent to respond with a single
   update.  Note that implementations may receive an arbitrary number of
   messages between sending a KeyUpdate with request_update set to
   ""update_requested"" and receiving the peer's KeyUpdate, because those
   messages may already be in flight.  However, because send and receive
   keys are derived from independent traffic secrets, retaining the
   receive traffic secret does not threaten the forward secrecy of data
   sent before the sender changed keys.

   If implementations independently send their own KeyUpdates with
   request_update set to ""update_requested"" and they cross in flight,
   then each side will also send a response, with the result that each
   side increments by two generations.

   Both sender and receiver MUST encrypt their KeyUpdate messages with
   the old keys.  Additionally, both sides MUST enforce that a KeyUpdate
   with the old key is received before accepting any messages encrypted
   with the new key.  Failure to do so may allow message truncation
   attacks.","[
  {
    ""section_name"": ""4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"",
    ""title"": ""KeyUpdate Message Overview"",
    ""content"": ""The KeyUpdate handshake message is used to indicate that the sender is updating its sending cryptographic keys. This message can be sent by either peer after it has sent a Finished message. Implementations that receive a KeyUpdate message prior to receiving a Finished message MUST terminate the connection with an 'unexpected_message' alert. After sending a KeyUpdate message, the sender SHALL send all its traffic using the next generation of keys, computed as described in Section 7.2. Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.""
  },
  {
    ""section_name"": ""4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"",
    ""title"": ""KeyUpdateRequest Enumeration"",
    ""content"": ""enum {\n    update_not_requested(0), update_requested(1), (255)\n} KeyUpdateRequest;""
  },
  {
    ""section_name"": ""4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"",
    ""title"": ""KeyUpdate Structure"",
    ""content"": ""struct {\n    KeyUpdateRequest request_update;\n} KeyUpdate;""
  },
  {
    ""section_name"": ""4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"",
    ""title"": ""request_update Field Description"",
    ""content"": ""The request_update field indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate. If an implementation receives any other value, it MUST terminate the connection with an 'illegal_parameter' alert.""
  },
  {
    ""section_name"": ""4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"",
    ""title"": ""KeyUpdate Response Mechanism"",
    ""content"": ""If the request_update field is set to 'update_requested', then the receiver MUST send a KeyUpdate of its own with request_update set to 'update_not_requested' prior to sending its next Application Data record. This mechanism allows either side to force an update to the entire connection, but causes an implementation which receives multiple KeyUpdates while it is silent to respond with a single update.""
  },
  {
    ""section_name"": ""4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"",
    ""title"": ""Handling Multiple KeyUpdates"",
    ""content"": ""Implementations may receive an arbitrary number of messages between sending a KeyUpdate with request_update set to 'update_requested' and receiving the peer's KeyUpdate, because those messages may already be in flight. However, because send and receive keys are derived from independent traffic secrets, retaining the receive traffic secret does not threaten the forward secrecy of data sent before the sender changed keys.""
  },
  {
    ""section_name"": ""4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"",
    ""title"": ""Crossing KeyUpdates"",
    ""content"": ""If implementations independently send their own KeyUpdates with request_update set to 'update_requested' and they cross in flight, then each side will also send a response, resulting in each side incrementing by two generations.""
  },
  {
    ""section_name"": ""4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"",
    ""title"": ""Encryption and KeyUpdate Order"",
    ""content"": ""Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys. Additionally, both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key. Failure to do so may allow message truncation attacks.""
  }
]"
