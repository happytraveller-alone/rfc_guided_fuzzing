ID,Section,Title,Content,RuleMatch,ExtractedRule
1,Section: 4.. Handshake Protocol,Handshake Protocol Overview,"The handshake protocol is used to negotiate the security parameters of a connection. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext or TLSCiphertext structures which are processed and transmitted as specified by the current active connection state.",0,Skip
2,Section: 4.. Handshake Protocol,Handshake Message Types Enumeration,"enum {
    client_hello(1),
    server_hello(2),
    new_session_ticket(4),
    end_of_early_data(5),
    encrypted_extensions(8),
    certificate(11),
    certificate_request(13),
    certificate_verify(15),
    finished(20),
    key_update(24),
    message_hash(254),
    (255)
",0,Skip
3,Section: 4.. Handshake Protocol,Handshake Message Structure,"struct {
    HandshakeType msg_type;    /* handshake type */
    uint24 length;             /* remaining bytes in message */
    select (Handshake.msg_type) {
        case client_hello:          ClientHello;
        case server_hello:          ServerHello;
        case end_of_early_data:     EndOfEarlyData;
        case encrypted_extensions:  EncryptedExtensions;
        case certificate_request:   CertificateRequest;
        case certificate:           Certificate;
        case certificate_verify:    CertificateVerify;
        case finished:              Finished;
        case new_session_ticket:    NewSessionTicket;
        case key_update:            KeyUpdate;
    ",0,Skip
4,Section: 4.. Handshake Protocol,Message Order Requirements,"Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2. A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert. New handshake message types are assigned by IANA as described in Section 11.",1,"### OUTPUT
<CLI-MSG-CONST> <1> (Clients MUST send protocol messages in the order defined in Section 4.4.1 and illustrated in Section 2) + <SRV-MSG-PROC> <1> (Servers MUST verify that received handshake messages are in the expected order as per Section 4.4.1)  
<CLI-MSG-PROC> <1> (If a handshake message is received in an unexpected order, clients MUST abort the handshake with an ""unexpected_message"" alert) + <SRV-MSG-PROC> <1> (If a server receives a handshake message in an unexpected order, it MUST also abort the handshake with an ""unexpected_message"" alert)"
5,Section: 4.1.. Handshake Protocol_Key Exchange Messages,Key Exchange Purpose,"The key exchange messages are used to determine the security capabilities of the client and the server and to establish shared secrets, including the traffic keys used to protect the rest of the handshake and the data.",0,Skip
6,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Cryptographic Negotiation Overview,"In TLS, the cryptographic negotiation proceeds by the client offering the following four sets of options in its ClientHello:",0,Skip
7,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Cipher Suites,A list of cipher suites which indicates the AEAD algorithm/HKDF hash pairs which the client supports.,0,Skip
8,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Supported Groups and Key Shares,"A ""supported_groups"" (Section 4.2.7) extension which indicates the (EC)DHE groups which the client supports and a ""key_share"" (Section 4.2.8) extension which contains (EC)DHE shares for some or all of these groups.",0,Skip
9,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Signature Algorithms,"A ""signature_algorithms"" (Section 4.2.3) extension which indicates the signature algorithms which the client can accept. A ""signature_algorithms_cert"" extension (Section 4.2.3) may also be added to indicate certificate-specific signature algorithms.",0,Skip
10,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Pre-Shared Key Options,"A ""pre_shared_key"" (Section 4.2.11) extension which contains a list of symmetric key identities known to the client and a ""psk_key_exchange_modes"" (Section 4.2.9) extension which indicates the key exchange modes that may be used with PSKs.",0,Skip
11,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Server Parameter Selection,"If the server does not select a PSK, then the first three options are entirely orthogonal: the server independently selects a cipher suite, an (EC)DHE group and key share for key establishment, and a signature algorithm/certificate pair to authenticate itself to the client. If there is no overlap between the received ""supported_groups"" and the groups supported by the server, then the server MUST abort the handshake with a ""handshake_failure"" or an ""insufficient_security"" alert.",1,"<SRV-MSG-CONST> <1> (Servers MUST independently select a cipher suite, (EC)DHE group, key share, and signature algorithm/certificate pair if no PSK is selected) + <SRV-MSG-PROC> <1> (Servers MUST abort the handshake with a ""handshake_failure"" or ""insufficient_security"" alert if there is no overlap between the received ""supported_groups"" and the server's supported groups)"
12,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,PSK Selection and Key Establishment,"If the server selects a PSK, then it MUST also select a key establishment mode from the set indicated by the client's ""psk_key_exchange_modes"" extension (at present, PSK alone or with (EC)DHE).",1,"<SRV-MSG-CONST> <1> (If the server selects a PSK, it MUST select a key establishment mode from the client's ""psk_key_exchange_modes"" extension) + <CLI-MSG-PROC> <0> (Clients MUST provide the supported key exchange modes in the ""psk_key_exchange_modes"" extension)"
13,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,HelloRetryRequest Requirement,"If the server selects an (EC)DHE group and the client did not offer a compatible ""key_share"" extension in the initial ClientHello, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message.",1,"<SRV-MSG-CONST> <1> (Servers MUST send a HelloRetryRequest if they select an (EC)DHE group and the client did not offer a compatible ""key_share"" extension) + <CLI-MSG-PROC> <0> (Clients MUST be prepared to receive a HelloRetryRequest message from the server)"
14,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Parameter Indication in ServerHello,"If the server successfully selects parameters and does not require a HelloRetryRequest, it indicates the selected parameters in the ServerHello as follows: If PSK is being used, then the server will send a ""pre_shared_key"" extension indicating the selected key. When (EC)DHE is in use, the server will also provide a ""key_share"" extension.",0,Skip
15,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Certificate Authentication,"When authenticating via a certificate, the server will send the Certificate (Section 4.4.2) and CertificateVerify (Section 4.4.3) messages. In TLS 1.3 as defined by this document, either a PSK or a certificate is always used, but not both.",0,Skip
16,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Failure to Negotiate Parameters,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).",1,"<SRV-MSG-PROC> <1> (Servers MUST abort the handshake if they cannot negotiate a supported set of parameters, issuing either a ""handshake_failure"" or ""insufficient_security"" fatal alert) + <CLI-MSG-PROC> <0> (Clients MUST be prepared to handle a ""handshake_failure"" or ""insufficient_security"" alert from the server)"
17,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,ClientHello Transmission Rules,"When a client first connects to a server, it is REQUIRED to send the ClientHello as its first TLS message. The client will also send a ClientHello when the server has responded to its ClientHello with a HelloRetryRequest. In that case, the client MUST send the same ClientHello without modification, except as follows:
- If a ""key_share"" extension was supplied in the HelloRetryRequest, replacing the list of shares with a list containing a single KeyShareEntry from the indicated group.
- Removing the ""early_data"" extension if one was present. Early data is not permitted after a HelloRetryRequest.
- Including a ""cookie"" extension if one was provided in the HelloRetryRequest.
- Updating the ""pre_shared_key"" extension if present by recomputing the ""obfuscated_ticket_age"" and binder values and (optionally) removing any PSKs which are incompatible with the server's indicated cipher suite.
- Optionally adding, removing, or changing the length of the ""padding"" extension [RFC7685].
- Other modifications that may be allowed by an extension defined in the future and present in the HelloRetryRequest.",1,"<CLI-MSG-CONST> <1> (Clients MUST send ClientHello as the first TLS message upon connection and also after receiving a HelloRetryRequest) + <SRV-MSG-PROC> <0> (Servers MUST validate that the initial ClientHello is sent as the first message and that subsequent ClientHello messages comply with the specified modifications)
<CLI-MSG-CONST> <1> (After receiving a HelloRetryRequest, clients MUST replace the ""key_share"" extension with a single KeyShareEntry for the indicated group if requested) + <SRV-MSG-PROC> <0> (Servers MUST verify the ""key_share"" extension is correctly modified in the new ClientHello)
<CLI-MSG-CONST> <1> (Clients MUST remove the ""early_data"" extension if it was present when sending a new ClientHello after a HelloRetryRequest) + <SRV-MSG-PROC> <0> (Servers MUST reject ClientHello messages that still include the ""early_data"" extension after a HelloRetryRequest)
<CLI-MSG-CONST> <1> (Clients MUST include a ""cookie"" extension if provided in the HelloRetryRequest) + <SRV-MSG-PROC> <0> (Servers MUST check for the presence of the ""cookie"" extension in the new ClientHello)
<CLI-MSG-CONST> <1> (Clients MUST update the ""pre_shared_key"" extension by recalculating the ""obfuscated_ticket_age"" and binder values, and MAY remove incompatible PSKs) + <SRV-MSG-PROC> <0> (Servers MUST verify the updated ""pre_shared_key"" values in the new ClientHello)
<CLI-MSG-CONST> <1> (Clients MAY add, remove, or change the length of the ""padding"" extension as necessary) + <SRV-MSG-PROC> <0> (Servers MUST accept optional modifications to the ""padding"" extension in the new ClientHello)"
18,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Renegotiation Rules,"Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an ""unexpected_message"" alert. If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version. In particular, it MUST NOT negotiate TLS 1.3.",1,"<SRV-MSG-PROC> <1> (Servers MUST terminate the connection with an ""unexpected_message"" alert if they receive a ClientHello after negotiating TLS 1.3) + <SRV-MSG-PROC> <1> (Servers MUST retain the previous protocol version and MUST NOT negotiate TLS 1.3 if they receive a TLS 1.3 ClientHello while previously established with an earlier version of TLS)"
19,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,ClientHello Structure,"Structure of this message:
```
      uint16 ProtocolVersion;
      opaque Random[32];

      uint8 CipherSuite[2];    /* Cryptographic suite selector */

      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id<0..32>;
          CipherSuite cipher_suites<2..2^16-2>;
          opaque legacy_compression_methods<1..2^8-1>;
          Extension extensions<8..2^16-1>;
      ",0,Skip
20,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Legacy Version Field,"In previous versions of TLS, this field was used for version negotiation and represented the highest version number supported by the client. Experience has shown that many servers do not properly implement version negotiation, leading to ""version intolerance"" in which the server rejects an otherwise acceptable ClientHello with a version number higher than it supports. In TLS 1.3, the client indicates its version preferences in the ""supported_versions"" extension (Section 4.2.1) and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2. TLS 1.3 ClientHellos are identified as having a legacy_version of 0x0303 and a supported_versions extension present with 0x0304 as the highest version indicated therein. (See Appendix D for details about backward compatibility.)",1,"<CLI-MSG-CONST> <1> (Clients MUST set the legacy_version field to 0x0303 in TLS 1.3 ClientHellos) + <SRV-MSG-PROC> <1> (Servers MUST recognize ClientHellos with a legacy_version of 0x0303 and a supported_versions extension containing 0x0304 as valid)
<CLI-MSG-CONST> <1> (Clients MUST include the ""supported_versions"" extension in TLS 1.3 ClientHellos) + <SRV-MSG-PROC> <1> (Servers MUST verify the presence of the ""supported_versions"" extension in ClientHellos)"
21,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Random Field Requirements,32 bytes generated by a secure random number generator. See Appendix C for additional information.,0,Skip
22,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Session ID Field,"Versions of TLS before TLS 1.3 supported a ""session resumption"" feature which has been merged with pre-shared keys in this version (see Section 2.2). A client which has a cached session ID set by a pre-TLS 1.3 server SHOULD set this field to that value. In compatibility mode (see Appendix D.4), this field MUST be non-empty, so a client not offering a pre-TLS 1.3 session MUST generate a new 32-byte value. This value need not be random but SHOULD be unpredictable to avoid implementations fixating on a specific value (also known as ossification). Otherwise, it MUST be set as a zero-length vector (i.e., a zero-valued single byte length field).",1,"<CLI-MSG-CONST> <1> (Clients MUST set the session ID field to a cached session ID from a pre-TLS 1.3 server if available) + <SRV-MSG-PROC> <0> (Servers MUST accept the session ID field when set to a valid cached value)
<CLI-MSG-CONST> <1> (In compatibility mode, clients MUST generate a new non-empty 32-byte session ID if not offering a pre-TLS 1.3 session) + <SRV-MSG-PROC> <0> (Servers MUST verify that the session ID is non-empty in compatibility mode)
<CLI-MSG-CONST> <1> (Clients SHOULD ensure the generated session ID is unpredictable to avoid ossification) + <SRV-MSG-PROC> <0> (Servers SHOULD reject session IDs that are predictable or fixed) 
<CLI-MSG-CONST> <1> (If no valid session ID is available, clients MUST set the session ID field as a zero-length vector) + <SRV-MSG-PROC> <0> (Servers MUST accept a zero-length session ID vector when appropriate)"
23,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Cipher Suites,"A list of the symmetric cipher options supported by the client, specifically the record protection algorithm (including secret key length) and a hash to be used with HKDF, in descending order of client preference. Values are defined in Appendix B.4. If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual. If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.",1,"<CLI-MSG-CONST> <1> (Clients MUST provide a list of supported cipher suites in descending order of preference) + <SRV-MSG-PROC> <1> (Servers MUST ignore unrecognized or unsupported cipher suites in the client's list and process the remaining ones)
<CLI-MSG-CONST> <0> (Clients SHOULD advertise at least one PSK-related cipher suite if attempting PSK key establishment) + <SRV-MSG-PROC> <0> (Servers MAY prioritize processing of cipher suites associated with PSK if indicated by the client)"
24,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Legacy Compression Methods,"Versions of TLS before 1.3 supported compression with the list of supported compression methods being sent in this field. For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS. If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an ""illegal_parameter"" alert. Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and (if negotiating such a prior version) MUST follow the procedures for the appropriate prior version of TLS.",1,"<CLI-MSG-CONST> <1> (TLS 1.3 ClientHello MUST contain exactly one byte set to zero for the ""null"" compression method) + <SRV-MSG-PROC> <1> (Servers MUST abort the handshake with an ""illegal_parameter"" alert if the ClientHello contains any value other than zero in the compression methods field)  
<SRV-MSG-PROC> <0> (Servers MUST follow procedures for prior TLS versions if receiving a ClientHello from TLS 1.2 or earlier that contains other compression methods)"
25,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Extensions,"Clients request extended functionality from servers by sending data in the extensions field. The actual ""Extension"" format is defined in Section 4.2. In TLS 1.3, the use of certain extensions is mandatory, as functionality has moved into extensions to preserve ClientHello compatibility with previous versions of TLS. Servers MUST ignore unrecognized extensions.",1,"<CLI-MSG-CONST> <1> (Clients MUST send data in the extensions field to request extended functionality from servers) + <SRV-MSG-PROC> <1> (Servers MUST ignore unrecognized extensions in the ClientHello)
<CLI-MSG-CONST> <1> (Clients MUST include mandatory extensions in the ClientHello to ensure compatibility with previous TLS versions) + <SRV-MSG-PROC> <0> (Servers MAY log the presence of unrecognized extensions for analysis)"
26,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,ClientHello Processing Rules,"After sending the ClientHello message, the client waits for a ServerHello or HelloRetryRequest message. If early data is in use, the client may transmit early Application Data (Section 2.3) while waiting for the next handshake message.",0,Skip
27,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,ServerHello Purpose,The server will send this message in response to a ClientHello message to proceed with the handshake if it is able to negotiate an acceptable set of handshake parameters based on the ClientHello.,0,Skip
28,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,ServerHello Structure," 
    struct {
        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
        Random random;
        opaque legacy_session_id_echo<0..32>;
        CipherSuite cipher_suite;
        uint8 legacy_compression_method = 0;
        Extension extensions<6..2^16-1>;
    ",0,Skip
29,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Legacy Version Field,"In previous versions of TLS, this field was used for version negotiation and represented the selected version number for the connection. Unfortunately, some middleboxes fail when presented with new values. In TLS 1.3, the TLS server indicates its version using the ""supported_versions"" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2. (See Appendix D for details about backward compatibility.)",1,"<SRV-MSG-CONST> <1> (Servers MUST set the legacy_version field to 0x0303 in ServerHello, indicating TLS 1.2 compatibility) + <SRV-MSG-PROC> <0> (Servers MUST use the ""supported_versions"" extension for version negotiation instead of the legacy_version field)"
30,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Random Field Requirements,"32 bytes generated by a secure random number generator. See Appendix C for additional information. The last 8 bytes MUST be overwritten as described below if negotiating TLS 1.2 or TLS 1.1, but the remaining bytes MUST be random. This structure is generated by the server and MUST be generated independently of the ClientHello.random.",1,"<SRV-MSG-CONST> <1> (Servers MUST generate the Random field as 32 bytes using a secure random number generator) + <SRV-MSG-CONST> <1> (Servers MUST ensure the last 8 bytes of the Random field are overwritten when negotiating TLS 1.2 or TLS 1.1)  
<SRV-MSG-CONST> <1> (Servers MUST generate the Random field independently of the ClientHello.random value) + <SRV-MSG-CONST> <0> (The first 24 bytes of the Random field MUST remain random)"
31,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Session ID Echo Requirements,"The contents of the client's legacy_session_id field. Note that this field is echoed even if the client's value corresponded to a cached pre-TLS 1.3 session which the server has chosen not to resume. A client which receives a legacy_session_id_echo field that does not match what it sent in the ClientHello MUST abort the handshake with an ""illegal_parameter"" alert.",1,"<SRV-MSG-CONST> <1> (Servers MUST echo the client's legacy_session_id field in the ServerHello, regardless of session resumption) + <CLI-MSG-PROC> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the legacy_session_id_echo does not match the value sent in ClientHello)"
32,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Cipher Suite Selection,"The single cipher suite selected by the server from the list in ClientHello.cipher_suites. A client which receives a cipher suite that was not offered MUST abort the handshake with an ""illegal_parameter"" alert.",1,"<SRV-MSG-CONST> <1> (Servers MUST select a single cipher suite from ClientHello.cipher_suites) + <CLI-MSG-PROC> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the cipher suite received was not offered)"
33,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Compression Method Requirement,A single byte which MUST have the value 0.,1,<SRV-MSG-CONST> <1> (Servers MUST include a single byte with the value 0 for the compression method in the ServerHello message) + <CLI-MSG-PROC> <1> (Clients MUST accept only ServerHello messages that contain a compression method byte with the value 0)
34,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Extensions Requirements,"A list of extensions. The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version. All TLS 1.3 ServerHello messages MUST contain the ""supported_versions"" extension. Current ServerHello messages additionally contain either the ""pre_shared_key"" extension or the ""key_share"" extension, or both (when using a PSK with (EC)DHE key establishment). Other extensions (see Section 4.2) are sent separately in the EncryptedExtensions message.",1,"<SRV-MSG-CONST> <1> (Servers MUST include the ""supported_versions"" extension in all TLS 1.3 ServerHello messages) + <SRV-MSG-CONST> <1> (Servers MUST include either the ""pre_shared_key"" extension or the ""key_share"" extension, or both, when using a PSK with (EC)DHE key establishment)  
<SRV-MSG-CONST> <1> (Servers MUST only include extensions in ServerHello that are required to establish the cryptographic context and negotiate the protocol version) + <SRV-MSG-CONST> <0> (Other extensions are sent separately in the EncryptedExtensions message)"
35,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,HelloRetryRequest Special Case,"For reasons of backward compatibility with middleboxes (see Appendix D.4), the HelloRetryRequest message uses the same structure as the ServerHello, but with Random set to the special value of the SHA-256 of ""HelloRetryRequest"": CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91 C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C. Upon receiving a message with type server_hello, implementations MUST first examine the Random value and, if it matches this value, process it as described in Section 4.1.4).",1,"<SRV-MSG-CONST> <1> (Servers MUST set the Random value in the HelloRetryRequest to the specific SHA-256 value of ""HelloRetryRequest"") + <SRV-MSG-PROC> <1> (Upon receiving a server_hello, servers MUST check the Random value and, if it matches the specified value, process it as a HelloRetryRequest according to Section 4.1.4)"
36,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Downgrade Protection Mechanism,"TLS 1.3 has a downgrade protection mechanism embedded in the server's random value. TLS 1.3 servers which negotiate TLS 1.2 or below in response to a ClientHello MUST set the last 8 bytes of their Random value specially in their ServerHello. If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of their Random value to the bytes: 44 4F 57 4E 47 52 44 01. If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes: 44 4F 57 4E 47 52 44 00.",1,"<SRV-MSG-CONST> <1> (TLS 1.3 servers MUST set the last 8 bytes of their Random value to 44 4F 57 4E 47 52 44 01 when negotiating TLS 1.2) + <SRV-MSG-CONST> <1> (TLS 1.3 servers MUST set the last 8 bytes of their Random value to 44 4F 57 4E 47 52 44 00 when negotiating TLS 1.1 or below, and TLS 1.2 servers SHOULD do the same)
<SRV-MSG-PROC> <1> (Servers MUST implement downgrade protection by modifying the Random value in the ServerHello according to the specified conditions) + <SRV-MSG-PROC> <1> (Servers MUST verify the appropriate Random value is set based on the negotiated TLS version)"
37,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Client Verification Process,"TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values. TLS 1.2 clients SHOULD also check that the last 8 bytes are not equal to the second value if the ServerHello indicates TLS 1.1 or below. If a match is found, the client MUST abort the handshake with an ""illegal_parameter"" alert. This mechanism provides limited protection against downgrade attacks over and above what is provided by the Finished exchange.",1,"<CLI-MSG-PROC> <1> (Clients MUST check that the last 8 bytes of ServerHello are not equal to specified values when receiving a ServerHello indicating TLS 1.2 or below) + <CLI-MSG-PROC> <1> (Clients SHOULD check that the last 8 bytes do not equal the second value if the ServerHello indicates TLS 1.1 or below)  
<CLI-MSG-PROC> <1> (If a match is found, clients MUST abort the handshake with an ""illegal_parameter"" alert) + <SRV-MSG-CONST> <0> (This mechanism provides limited protection against downgrade attacks)"
38,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Renegotiation Handling,"A legacy TLS client performing renegotiation with TLS 1.2 or prior and which receives a TLS 1.3 ServerHello during renegotiation MUST abort the handshake with a ""protocol_version"" alert. Note that renegotiation is not possible when TLS 1.3 has been negotiated.",1,"<CLI-MSG-PROC> <1> (Legacy TLS clients performing renegotiation MUST abort the handshake with a ""protocol_version"" alert upon receiving a TLS 1.3 ServerHello) + <SRV-MSG-PROC> <1> (Servers MUST NOT allow renegotiation once TLS 1.3 has been negotiated)"
39,Section: 4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Hello Retry Request Purpose,"The server will send this message in response to a ClientHello message if it is able to find an acceptable set of parameters but the ClientHello does not contain sufficient information to proceed with the handshake. As discussed in Section 4.1.3, the HelloRetryRequest has the same format as a ServerHello message, and the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields have the same meaning. However, for convenience, we discuss ""HelloRetryRequest"" throughout this document as if it were a distinct message.",0,Skip
40,Section: 4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Extensions Requirements,"The server's extensions MUST contain ""supported_versions"". Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair. A HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the ""cookie"" (see Section 4.2.2) extension.",1,"<SRV-MSG-CONST> <1> (Servers MUST include ""supported_versions"" in their HelloRetryRequest extensions) + <SRV-MSG-CONST> <0> (Servers SHOULD include the minimal set of extensions necessary for the client to generate a correct ClientHello pair)  
<SRV-MSG-CONST> <1> (HelloRetryRequest MUST NOT contain any extensions not offered by the client in its ClientHello, except optionally the ""cookie"" extension) + <SRV-MSG-PROC> <1> (Servers MUST verify that all extensions in HelloRetryRequest were offered by the client, allowing ""cookie"" as an exception)"
41,Section: 4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Client Processing Rules,"Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using ""supported_versions"". Clients MUST abort the handshake with an ""illegal_parameter"" alert if the HelloRetryRequest would not result in any change in the ClientHello. If a client receives a second HelloRetryRequest in the same connection, it MUST abort the handshake with an ""unexpected_message"" alert.",1,"### OUTPUT
<CLI-MSG-PROC> <1> (Upon receipt of HelloRetryRequest, clients MUST check legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3) + <CLI-MSG-PROC> <1> (Clients MUST process extensions starting with determining the version using ""supported_versions"")
<CLI-MSG-PROC> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the HelloRetryRequest would not result in any change in the ClientHello) + <CLI-MSG-PROC> <1> (Clients MUST abort the handshake with an ""unexpected_message"" alert if a second HelloRetryRequest is received in the same connection)"
42,Section: 4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,HelloRetryRequest Extensions,"The HelloRetryRequest extensions defined in this specification are:
- supported_versions (see Section 4.2.1)
- cookie (see Section 4.2.2)
- key_share (see Section 4.2.8)",0,Skip
43,Section: 4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Cipher Suite Negotiation,"A client which receives a cipher suite that was not offered MUST abort the handshake. Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello. Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an ""illegal_parameter"" alert.",1,"<CLI-MSG-PROC> <1> (Clients MUST abort the handshake if they receive a cipher suite not offered) + <SRV-MSG-PROC> <1> (Servers MUST negotiate the same cipher suite upon receiving a conformant updated ClientHello)  
<CLI-MSG-PROC> <1> (Clients MUST check that the cipher suite in the ServerHello matches the one in the HelloRetryRequest) + <CLI-MSG-PROC> <1> (If the cipher suites do not match, clients MUST abort the handshake with an ""illegal_parameter"" alert)"
44,Section: 4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Updated ClientHello Recommendations,"In its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite. This allows the client to avoid having to compute partial hash transcripts for multiple hashes in the second ClientHello.",0,Skip
45,Section: 4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Version Retention Requirement,"The value of selected_version in the HelloRetryRequest ""supported_versions"" extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an ""illegal_parameter"" alert if the value changes.",1,"<SRV-MSG-CONST> <1> (Servers MUST retain the value of selected_version from the HelloRetryRequest in the ServerHello) + <CLI-MSG-PROC> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the value of selected_version changes)"
46,Section: 4.2.. Handshake Protocol_Extensions,Extension Structure Definition,"A number of TLS messages contain tag-length-value encoded extensions structures.

    struct {
        ExtensionType extension_type;
        opaque extension_data<0..2^16-1>;
    ",0,Skip
47,Section: 4.2.. Handshake Protocol_Extensions,Extension Types Enumeration,"enum {
    server_name(0),                             /* RFC 6066 */
    max_fragment_length(1),                     /* RFC 6066 */
    status_request(5),                          /* RFC 6066 */
    supported_groups(10),                       /* RFC 8422, 7919 */
    signature_algorithms(13),                   /* RFC 8446 */
    use_srtp(14),                               /* RFC 5764 */
    heartbeat(15),                              /* RFC 6520 */
    application_layer_protocol_negotiation(16), /* RFC 7301 */
    signed_certificate_timestamp(18),           /* RFC 6962 */
    client_certificate_type(19),                /* RFC 7250 */
    server_certificate_type(20),                /* RFC 7250 */
    padding(21),                                /* RFC 7685 */
    pre_shared_key(41),                         /* RFC 8446 */
    early_data(42),                             /* RFC 8446 */
    supported_versions(43),                     /* RFC 8446 */
    cookie(44),                                 /* RFC 8446 */
    psk_key_exchange_modes(45),                 /* RFC 8446 */
    certificate_authorities(47),                /* RFC 8446 */
    oid_filters(48),                            /* RFC 8446 */
    post_handshake_auth(49),                    /* RFC 8446 */
    signature_algorithms_cert(50),              /* RFC 8446 */
    key_share(51),                              /* RFC 8446 */
    (65535)
",0,Skip
48,Section: 4.2.. Handshake Protocol_Extensions,Extension Request/Response Structure,"Extensions are generally structured in a request/response fashion, though some extensions are just indications with no corresponding response. The client sends its extension requests in the ClientHello message, and the server sends its extension responses in the ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate messages. The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message. The server MAY also send unsolicited extensions in the NewSessionTicket, though the client does not respond directly to these.",0,Skip
49,Section: 4.2.. Handshake Protocol_Extensions,Extension Response Rules,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest. Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert.",1,"<CLI-MSG-PROC> <1> (Clients MUST NOT send extension responses unless the corresponding extension requests were received from the remote endpoint, except for the ""cookie"" extension in HelloRetryRequest) + <SRV-MSG-PROC> <1> (Servers MUST abort the handshake with an ""unsupported_extension"" alert upon receiving an unexpected extension response)"
50,Section: 4.2.. Handshake Protocol_Extensions,Extension Message Compatibility,"If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an ""illegal_parameter"" alert.",1,"<CLI-MSG-PROC> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if they receive an unrecognized extension in a message) + <SRV-MSG-PROC> <1> (Servers MUST abort the handshake with an ""illegal_parameter"" alert if they receive an extension not specified for the message)"
51,Section: 4.2.. Handshake Protocol_Extensions,Extension Message Table,"The table below indicates the messages where a given extension may appear, using the following notation: CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), and HRR (HelloRetryRequest).

+--------------------------------------------------+-------------+
| Extension                                        |     TLS 1.3 |
+--------------------------------------------------+-------------+
| server_name [RFC6066]                            |      CH, EE |
| max_fragment_length [RFC6066]                    |      CH, EE |
| status_request [RFC6066]                         |  CH, CR, CT |
| supported_groups [RFC7919]                       |      CH, EE |
| signature_algorithms (RFC 8446)                  |      CH, CR |
| use_srtp [RFC5764]                               |      CH, EE |
| heartbeat [RFC6520]                              |      CH, EE |
| application_layer_protocol_negotiation [RFC7301] |      CH, EE |
| signed_certificate_timestamp [RFC6962]           |  CH, CR, CT |
| client_certificate_type [RFC7250]                |      CH, EE |
| server_certificate_type [RFC7250]                |      CH, EE |
| padding [RFC7685]                                |          CH |
| key_share (RFC 8446)                             | CH, SH, HRR |
| pre_shared_key (RFC 8446)                        |      CH, SH |
| psk_key_exchange_modes (RFC 8446)                |          CH |
| early_data (RFC 8446)                            | CH, EE, NST |
| cookie (RFC 8446)                                |     CH, HRR |
| supported_versions (RFC 8446)                    | CH, SH, HRR |
| certificate_authorities (RFC 8446)               |      CH, CR |
| oid_filters (RFC 8446)                           |          CR |
| post_handshake_auth (RFC 8446)                   |          CH |
| signature_algorithms_cert (RFC 8446)             |      CH, CR |
+--------------------------------------------------+-------------+",0,Skip
52,Section: 4.2.. Handshake Protocol_Extensions,Extension Ordering Rules,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block). There MUST NOT be more than one extension of the same type in a given extension block.",1,"<CLI-MSG-CONST> <1> (Clients MUST place the ""pre_shared_key"" extension last in ClientHello, while other extensions MAY appear in any order) + <SRV-MSG-PROC> <1> (Servers MUST verify that the ""pre_shared_key"" is the last extension in ClientHello)
<CLI-MSG-CONST> <1> (Clients MUST NOT include multiple extensions of the same type in any extension block) + <SRV-MSG-PROC> <1> (Servers MUST reject ClientHello messages containing duplicate extension types)"
53,Section: 4.2.. Handshake Protocol_Extensions,Negotiation and Resumption,"In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each handshake even when in resumption-PSK mode. However, 0-RTT parameters are those negotiated in the previous handshake; mismatches may require rejecting 0-RTT (see Section 4.2.10).",0,Skip
54,Section: 4.2.. Handshake Protocol_Extensions,Extension Security Considerations,"There are subtle (and not so subtle) interactions that may occur in this protocol between new features and existing features which may result in a significant reduction in overall security. The following considerations should be taken into account when designing new extensions:

- Some cases where a server does not agree to an extension are error conditions (e.g., the handshake cannot continue), and some are simply refusals to support particular features. In general, error alerts should be used for the former and a field in the server extension response for the latter.

- Extensions should, as far as possible, be designed to prevent any attack that forces use (or non-use) of a particular feature by manipulation of handshake messages. This principle should be followed regardless of whether the feature is believed to cause a security problem. Often the fact that the extension fields are included in the inputs to the Finished message hashes will be sufficient, but extreme care is needed when the extension changes the meaning of messages sent in the handshake phase. Designers and implementors should be aware of the fact that until the handshake has been authenticated, active attackers can modify messages and insert, remove, or replace extensions.",0,Skip
55,Section: 4.2.1.. Handshake Protocol_Extensions_Supported Versions,SupportedVersions Structure,"  
struct {  
    select (Handshake.msg_type) {  
        case client_hello:  
            ProtocolVersion versions<2..254>;  

        case server_hello: /* and HelloRetryRequest */  
            ProtocolVersion selected_version;  
    ",0,Skip
56,Section: 4.2.1.. Handshake Protocol_Extensions_Supported Versions,Extension Purpose,"  
The ""supported_versions"" extension is used by the client to indicate which versions of TLS it supports and by the server to indicate which version it is using. The extension contains a list of supported versions in preference order, with the most preferred version first.  
",0,Skip
57,Section: 4.2.1.. Handshake Protocol_Extensions_Supported Versions,ClientHello Requirements,"  
Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which they are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, they MUST be present as well).  
",1,"<CLI-MSG-CONST> <1> (Clients MUST include the ""supported_versions"" extension in ClientHello, listing all TLS versions they are prepared to negotiate, including 0x0304 and any previous versions if allowed) + <SRV-MSG-PROC> <1> (Servers MUST verify the presence of the ""supported_versions"" extension in ClientHello and check that it contains valid TLS versions)"
58,Section: 4.2.1.. Handshake Protocol_Extensions_Supported Versions,Server Behavior without Extension,"  
If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.  
",1,"<SRV-MSG-PROC> <1> (Servers MUST negotiate TLS 1.2 or prior if the Supported Versions extension is not present and they support TLS 1.2, even if ClientHello.legacy_version is 0x0304 or later) + <SRV-MSG-PROC> <0> (Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later)"
59,Section: 4.2.1.. Handshake Protocol_Extensions_Supported Versions,Server Version Negotiation,"  
If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension.  
",1,"<CLI-MSG-CONST> <1> (Clients MUST include the ""supported_versions"" extension in ClientHello for version negotiation) + <SRV-MSG-PROC> <1> (Servers MUST use the ""supported_versions"" extension for determining client preferences, ignoring the ClientHello.legacy_version value)

<SRV-MSG-CONST> <1> (Servers MUST select a TLS version only from those present in the ""supported_versions"" extension) + <SRV-MSG-PROC> <1> (Servers MUST ignore any unknown versions present in the ""supported_versions"" extension)"
60,Section: 4.2.1.. Handshake Protocol_Extensions_Supported Versions,ServerHello Requirements,"  
A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2).  
",1,"<SRV-MSG-CONST> <1> (Servers negotiating TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension) + <SRV-MSG-CONST> <1> (Servers negotiating TLS 1.3 MUST send a ""supported_versions"" extension containing the selected version value 0x0304)  
<SRV-MSG-CONST> <1> (Servers negotiating TLS 1.3 MUST set the ServerHello.legacy_version field to 0x0303)"
61,Section: 4.2.1.. Handshake Protocol_Extensions_Supported Versions,Client Processing of ServerHello,"  
Clients MUST check for this extension prior to processing the rest of the ServerHello. If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version. If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert.  
",1,"<CLI-MSG-PROC> <1> (Clients MUST check for the ""supported_versions"" extension before processing the rest of the ServerHello) + <SRV-MSG-PROC> <1> (Servers MUST include the ""supported_versions"" extension in ServerHello for clients to evaluate the selected version)  
<CLI-MSG-PROC> <1> (If ""supported_versions"" contains a version not offered or a version prior to TLS 1.3, clients MUST abort the handshake) + <SRV-MSG-PROC> <1> (Servers MUST ensure that the ""supported_versions"" extension contains only versions offered by the client and at least TLS 1.3)"
62,Section: 4.2.2.. Handshake Protocol_Extensions_Cookie,Cookie Structure,"  
struct {  
    opaque cookie<1..2^16-1>;  
",0,Skip
63,Section: 4.2.2.. Handshake Protocol_Extensions_Cookie,Cookie Purposes,"  
Cookies serve two primary purposes:  
- **Reachability Demonstration**: Allowing the server to force the client to demonstrate reachability at their apparent network address, providing a measure of DoS protection. This is particularly useful for non-connection-oriented transports (see [RFC6347] for an example of this).  
- **State Offloading**: Allowing the server to offload state to the client, thus enabling it to send a HelloRetryRequest without storing any state. The server can achieve this by storing the hash of the ClientHello in the HelloRetryRequest cookie, protected with a suitable integrity protection algorithm.  
",0,Skip
64,Section: 4.2.2.. Handshake Protocol_Extensions_Cookie,HelloRetryRequest Cookie Usage,"  
When sending a HelloRetryRequest, the server MAY provide a ""cookie"" extension to the client (this is an exception to the usual rule that only extensions appearing in the ClientHello may be sent). When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a ""cookie"" extension in the new ClientHello. Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.  
",1,"<SRV-MSG-CONST> <0> (Servers MAY include a ""cookie"" extension in a HelloRetryRequest, which is an exception to the usual extension rules) + <CLI-MSG-CONST> <1> (Clients MUST copy the ""cookie"" extension received in the HelloRetryRequest into the new ClientHello)  
<CLI-MSG-CONST> <1> (Clients MUST NOT use cookies in their initial ClientHello during subsequent connections) + <SRV-MSG-PROC> <0> (Servers MUST ensure clients do not include cookies in their initial ClientHello on new connections)"
65,Section: 4.2.2.. Handshake Protocol_Extensions_Cookie,Stateless Server Behavior,"  
When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5). Since the server is not storing any state, this will appear as if it were the first message received. Servers operating statelessly MUST ignore these records.  
",1,<SRV-MSG-PROC> <1> (Servers operating statelessly MUST ignore unprotected change_cipher_spec records received between the first and second ClientHello) + <CLI-MSG-CONST> <0> (Clients SHOULD be aware that servers operating statelessly will not process change_cipher_spec records)
66,Section: 4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Algorithms Overview,"TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures. The ""signature_algorithms_cert"" extension applies to signatures in certificates, while the ""signature_algorithms"" extension applies to signatures in CertificateVerify messages. If no ""signature_algorithms_cert"" extension is present, the ""signature_algorithms"" extension also applies to signatures in certificates. Clients must send the ""signature_algorithms"" extension for the server to authenticate via a certificate; if not sent, the server must abort the handshake with a ""missing_extension"" alert.",1,"<CLI-MSG-CONST> <1> (Clients MUST send the ""signature_algorithms"" extension for server authentication via a certificate) + <SRV-MSG-PROC> <1> (Servers MUST abort the handshake with a ""missing_extension"" alert if the ""signature_algorithms"" extension is not present)  
<SRV-MSG-CONST> <0> (Servers MAY apply the ""signature_algorithms"" extension to signatures in certificates if no ""signature_algorithms_cert"" extension is present) + <CLI-MSG-PROC> <0> (Clients MUST understand that if ""signature_algorithms_cert"" is absent, ""signature_algorithms"" applies to certificate signatures)"
67,Section: 4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Extension Purpose and Compatibility,"The ""signature_algorithms_cert"" extension allows implementations to signal their capabilities for certificates and TLS separately. TLS 1.2 implementations should also process this extension, but those with the same policy may omit it.",0,Skip
68,Section: 4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,SignatureSchemeList Structure,"The ""extension_data"" field of these extensions contains a SignatureSchemeList value, which enumerates supported signature algorithms in descending order of preference. Each SignatureScheme value indicates a single algorithm the client is willing to verify.",0,Skip
69,Section: 4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Algorithms Defined,"The following signature schemes are defined:

- **RSASSA-PKCS1-v1_5 algorithms** (e.g., rsa_pkcs1_sha256, rsa_pkcs1_sha384, rsa_pkcs1_sha512)
- **ECDSA algorithms** (e.g., ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384, ecdsa_secp521r1_sha512)
- **RSASSA-PSS algorithms** (e.g., rsa_pss_rsae_sha256, rsa_pss_pss_sha256)
- **EdDSA algorithms** (e.g., ed25519, ed448)
- **Legacy algorithms** (e.g., rsa_pkcs1_sha1, ecdsa_sha1)

Legacy algorithms are deprecated due to known weaknesses and should only be negotiated for backward compatibility.",0,Skip
70,Section: 4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Algorithm Usage Guidelines,"Endpoints should avoid negotiating deprecated algorithms like SHA-1, which TLS 1.3 servers must not offer unless no valid certificate chain can be produced without it. Self-signed certificates may use unsupported algorithms.",1,"<CLI-MSG-CONST> <1> (Clients SHOULD avoid negotiating deprecated algorithms like SHA-1) + <SRV-MSG-CONST> <1> (Servers MUST NOT offer SHA-1 unless no valid certificate chain can be produced without it)  
<CLI-MSG-CONST> <0> (Clients MAY accept self-signed certificates that use unsupported algorithms) + <SRV-MSG-PROC> <0> (Servers MAY issue self-signed certificates with unsupported algorithms)"
71,Section: 4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,TLS 1.2 Compatibility,"In TLS 1.2, this extension is defined differently, allowing clients to omit it. TLS 1.2's extension contained hash/signature pairs encoded in two octets, and implementations must accept signatures from any curve advertised in the ""supported_groups"" extension. RSASSA-PSS is mandatory in TLS 1.3, and implementations must accept it even when negotiating TLS 1.2.",1,"<CLI-MSG-CONST> <1> (Clients MUST include the ""signature_algorithms"" extension in TLS 1.3) + <SRV-MSG-PROC> <0> (Servers MUST accept the ""signature_algorithms"" extension even if negotiating with TLS 1.2)  
<SRV-MSG-PROC> <1> (Servers MUST accept RSASSA-PSS signatures during TLS 1.3 negotiations) + <CLI-MSG-PROC> <0> (Clients MUST provide RSASSA-PSS signatures when negotiating TLS 1.3)"
72,Section: 4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Certificate Authorities Extension Purpose,"The ""certificate_authorities"" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection.",0,Skip
73,Section: 4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Certificate Authorities Extension Structure,"The body of the ""certificate_authorities"" extension consists of a CertificateAuthoritiesExtension structure:  
```  
opaque DistinguishedName<1..2^16-1>;  
struct {  
    DistinguishedName authorities<3..2^16-1>;  
",0,Skip
74,Section: 4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Authorities Field Description,"`authorities`: A list of the distinguished names [X501] of acceptable certificate authorities, represented in DER-encoded [X690] format. These distinguished names specify a desired distinguished name for a trust anchor or subordinate CA; thus, this message can be used to describe known trust anchors as well as a desired authorization space.",0,Skip
75,Section: 4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Extension Usage,"The client MAY send the ""certificate_authorities"" extension in the ClientHello message. The server MAY send it in the CertificateRequest message.",0,Skip
76,Section: 4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Deprecation of Trusted CA Keys Extension,"The ""trusted_ca_keys"" extension [RFC6066], which serves a similar purpose but is more complicated, is not used in TLS 1.3 (although it may appear in ClientHello messages from clients which are offering prior versions of TLS).",0,Skip
77,Section: 4.2.5.. Handshake Protocol_Extensions_OID Filters,OID Filters Extension Purpose,"The ""oid_filters"" extension allows servers to provide a set of OID/value pairs which it would like the client's certificate to match. This extension, if provided by the server, MUST only be sent in the CertificateRequest message.",1,"<SRV-MSG-CONST> <1> (Servers MUST include the ""oid_filters"" extension only in the CertificateRequest message) + <CLI-MSG-PROC> <0> (Clients MUST check for the presence of the ""oid_filters"" extension in the CertificateRequest message)"
78,Section: 4.2.5.. Handshake Protocol_Extensions_OID Filters,Structure Definitions," 
  Definition: 
  ```c
  struct {
      opaque certificate_extension_oid<1..2^8-1>;
      opaque certificate_extension_values<0..2^16-1>;
  ",0,Skip
79,Section: 4.2.5.. Handshake Protocol_Extensions_OID Filters,Certificate Extension Matching Rules,"PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types. Depending on the type, matching certificate extension values are not necessarily bitwise-equal. It is expected that TLS implementations will rely on their PKI libraries to perform certificate selection using certificate extension OIDs. This document defines matching rules for two standard certificate extensions defined in [RFC5280]:
- The Key Usage extension in a certificate matches the request when all key usage bits asserted in the request are also asserted in the Key Usage certificate extension.
- The Extended Key Usage extension in a certificate matches the request when all key purpose OIDs present in the request are also found in the Extended Key Usage certificate extension. The special anyExtendedKeyUsage OID MUST NOT be used in the request. 
Separate specifications may define matching rules for other certificate extensions.",1,"<SRV-MSG-PROC> <1> (Servers MUST rely on their PKI libraries to perform certificate selection using certificate extension OIDs) + <CLI-MSG-CONST> <1> (Clients MUST ensure that all key usage bits asserted in the request are also asserted in the Key Usage certificate extension for a match)
<SRV-MSG-PROC> <1> (Servers MUST verify that all key purpose OIDs present in the request are found in the Extended Key Usage certificate extension for a match) + <CLI-MSG-CONST> <1> (Clients MUST NOT use the special anyExtendedKeyUsage OID in the request)"
80,Section: 4.2.6.. Handshake Protocol_Extensions_Post-Handshake Client Authentication,Post-Handshake Authentication Extension,"The ""post_handshake_auth"" extension is used to indicate that a client is willing to perform post-handshake authentication (Section 4.6.2). Servers MUST NOT send a post-handshake CertificateRequest to clients which do not offer this extension. Servers MUST NOT send this extension.",1,"<CLI-MSG-CONST> <1> (Clients MUST include the ""post_handshake_auth"" extension to indicate willingness for post-handshake authentication) + <SRV-MSG-PROC> <1> (Servers MUST NOT send a CertificateRequest to clients that do not offer the ""post_handshake_auth"" extension)  
<SRV-MSG-CONST> <1> (Servers MUST NOT send the ""post_handshake_auth"" extension)"
81,Section: 4.2.6.. Handshake Protocol_Extensions_Post-Handshake Client Authentication,Post-Handshake Auth Structure,"The structure of this extension is defined as follows:

```
struct {",0,Skip
82,Section: 4.2.7.. Handshake Protocol_Extensions_Supported Groups,Supported Groups Extension Purpose,"When sent by the client, the ""supported_groups"" extension indicates the named groups which the client supports for key exchange, ordered from most preferred to least preferred.",0,Skip
83,Section: 4.2.7.. Handshake Protocol_Extensions_Supported Groups,Historical Context,"In versions of TLS prior to TLS 1.3, this extension was named ""elliptic_curves"" and only contained elliptic curve groups. See [RFC8422] and [RFC7919]. This extension was also used to negotiate ECDSA curves. Signature algorithms are now negotiated independently (see Section 4.2.3).",0,Skip
84,Section: 4.2.7.. Handshake Protocol_Extensions_Supported Groups,Extension Data Structure,"The ""extension_data"" field of this extension contains a ""NamedGroupList"" value:
```
enum {
    /* Elliptic Curve Groups (ECDHE) */
    secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
    x25519(0x001D), x448(0x001E),

    /* Finite Field Groups (DHE) */
    ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
    ffdhe6144(0x0103), ffdhe8192(0x0104),

    /* Reserved Code Points */
    ffdhe_private_use(0x01FC..0x01FF),
    ecdhe_private_use(0xFE00..0xFEFF),
    (0xFFFF)
",0,Skip
85,Section: 4.2.7.. Handshake Protocol_Extensions_Supported Groups,Group Types Description,"Elliptic Curve Groups (ECDHE): Indicates support for the corresponding named curve, defined in either FIPS 186-4 [DSS] or [RFC7748]. Values 0xFE00 through 0xFEFF are reserved for Private Use [RFC8126]. Finite Field Groups (DHE): Indicates support for the corresponding finite field group, defined in [RFC7919]. Values 0x01FC through 0x01FF are reserved for Private Use.",0,Skip
86,Section: 4.2.7.. Handshake Protocol_Extensions_Supported Groups,Preference Ordering,Items in named_group_list are ordered according to the sender's preferences (most preferred choice first).,0,Skip
87,Section: 4.2.7.. Handshake Protocol_Extensions_Supported Groups,Server Behavior,"As of TLS 1.3, servers are permitted to send the ""supported_groups"" extension to the client. Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections. If the server has a group it prefers to the ones in the ""key_share"" extension but is still willing to accept the ClientHello, it SHOULD send ""supported_groups"" to update the client's view of its preferences; this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client.",1,"<SRV-MSG-CONST> <1> (Servers are permitted to send the ""supported_groups"" extension to clients) + <CLI-MSG-PROC> <0> (Clients MUST NOT act upon information in ""supported_groups"" until after the handshake is successfully completed)

<CLI-MSG-CONST> <1> (Clients MAY use information from a successfully completed handshake to adjust their ""key_share"" extension in future connections) + <SRV-MSG-PROC> <1> (Servers SHOULD send ""supported_groups"" to indicate preferred groups if they prefer a group not in the ""key_share"" extension)

<SRV-MSG-CONST> <1> (The ""supported_groups"" extension SHOULD contain all groups supported by the server, regardless of client support)"
88,Section: 4.2.8.. Handshake Protocol_Extensions_Key Share,Key Share Extension Overview,"The ""key_share"" extension contains the endpoint's cryptographic parameters. Clients MAY send an empty client_shares vector in order to request group selection from the server, at the cost of an additional round trip (see Section 4.1.4).",0,Skip
89,Section: 4.2.8.. Handshake Protocol_Extensions_Key Share,KeyShareEntry Structure,"The structure of this message is defined as follows:
```
struct {
    NamedGroup group;
    opaque key_exchange<1..2^16-1>;
",0,Skip
90,Section: 4.2.8.. Handshake Protocol_Extensions_Key Share,ClientHello Key Share,"In the ClientHello message, the ""extension_data"" field of this extension contains a ""KeyShareClientHello"" value:
```
struct {
    KeyShareEntry client_shares<0..2^16-1>;
",0,Skip
91,Section: 4.2.8.. Handshake Protocol_Extensions_Key Share,HelloRetryRequest Key Share,"In a HelloRetryRequest message, the ""extension_data"" field contains a KeyShareHelloRetryRequest value:
```
struct {
    NamedGroup selected_group;
",0,Skip
92,Section: 4.2.8.. Handshake Protocol_Extensions_Key Share,ServerHello Key Share,"In a ServerHello message, the ""extension_data"" field contains a KeyShareServerHello value:
```
struct {
    KeyShareEntry server_share;
",0,Skip
93,Section: 4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters,Diffie-Hellman Key Share Encoding,"Diffie-Hellman parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure. The opaque value contains the Diffie-Hellman public value (Y = g^X mod p) for the specified group (see [RFC7919] for group definitions) encoded as a big-endian integer and padded to the left with zeros to the size of p in bytes. Note: For a given Diffie-Hellman group, the padding results in all public keys having the same length.",0,Skip
94,Section: 4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters,Public Key Validation,Peers MUST validate each other's public key Y by ensuring that 1 < Y < p-1. This check ensures that the remote peer is properly behaved and isn't forcing the local system into a small subgroup.,1,"<CLI-MSG-PROC> <1> (Clients MUST validate the public key Y received from the server, ensuring that 1 < Y < p-1) + <SRV-MSG-PROC> <1> (Servers MUST validate the public key Y received from the client, ensuring that 1 < Y < p-1)"
95,Section: 4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,KeyShareEntry Structure,"ECDHE parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure. For secp256r1, secp384r1, and secp521r1, the contents are the serialized value of the following struct:

```c
struct {
    uint8 legacy_form = 4;
    opaque X[coordinate_length];
    opaque Y[coordinate_length];
",0,Skip
96,Section: 4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Public Value Validation,"For the curves secp256r1, secp384r1, and secp521r1, peers MUST validate each other's public value Q by ensuring that the point is a valid point on the elliptic curve. The appropriate validation procedures are defined in Section 4.3.7 of [ECDSA] and alternatively in Section 5.6.2.3 of [KEYAGREEMENT]. This process consists of three steps: (1) verify that Q is not the point at infinity (O), (2) verify that for Q = (x, y) both integers x and y are in the correct interval, and (3) ensure that (x, y) is a correct solution to the elliptic curve equation. For these curves, implementors do not need to verify membership in the correct subgroup.",1,"<CLI-MSG-PROC> <1> (Clients MUST validate the public value Q by ensuring it is a valid point on the elliptic curve for secp256r1, secp384r1, and secp521r1) + <SRV-MSG-PROC> <1> (Servers MUST validate the public value Q by ensuring it is a valid point on the elliptic curve for secp256r1, secp384r1, and secp521r1)

<CLI-MSG-PROC> <1> (Validation of Q consists of verifying that Q is not the point at infinity, that both x and y are in the correct interval, and that (x, y) satisfies the elliptic curve equation) + <SRV-MSG-PROC> <1> (Servers MUST perform the same validation steps for Q as clients) 

<CLI-MSG-PROC> <0> (Implementors do not need to verify membership in the correct subgroup for these curves) + <SRV-MSG-PROC> <0> (Servers do not need to verify membership in the correct subgroup for these curves)"
97,Section: 4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,X25519 and X448 Public Values,"For X25519 and X448, the contents of the public value are the byte string inputs and outputs of the corresponding functions defined in [RFC7748]: 32 bytes for X25519 and 56 bytes for X448.",0,Skip
98,Section: 4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Point Format Negotiation Removal,Note: Versions of TLS prior to 1.3 permitted point format negotiation; TLS 1.3 removes this feature in favor of a single point format for each curve.,0,Skip
99,Section: 4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,PSK Key Exchange Modes Extension,"In order to use PSKs, clients MUST also send a ""psk_key_exchange_modes"" extension. The semantics of this extension are that the client only supports the use of PSKs with these modes, which restricts both the use of PSKs offered in this ClientHello and those which the server might supply via NewSessionTicket. A client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension. If clients offer ""pre_shared_key"" without a ""psk_key_exchange_modes"" extension, servers MUST abort the handshake. Servers MUST NOT select a key exchange mode that is not listed by the client. This extension also restricts the modes for use with PSK resumption. Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes; however, if a server does so, the impact will just be that the client's attempts at resumption fail. The server MUST NOT send a ""psk_key_exchange_modes"" extension.",1,"<CLI-MSG-CONST> <1> (Clients MUST send a ""psk_key_exchange_modes"" extension if they offer a ""pre_shared_key"" extension) + <SRV-MSG-PROC> <1> (Servers MUST abort the handshake if ""pre_shared_key"" is offered without a ""psk_key_exchange_modes"" extension)  
<CLI-MSG-CONST> <1> (Clients MUST restrict PSK usage to modes listed in the ""psk_key_exchange_modes"" extension) + <SRV-MSG-PROC> <1> (Servers MUST NOT select a key exchange mode not listed by the client)  
<SRV-MSG-PROC> <0> (Servers SHOULD NOT send NewSessionTicket with incompatible tickets, but if they do, only resumption attempts will fail) + <SRV-MSG-CONST> <0> (Servers MUST NOT send a ""psk_key_exchange_modes"" extension)"
100,Section: 4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,PskKeyExchangeMode Enumeration,"enum { psk_ke(0), psk_dhe_ke(1), (255) ",0,Skip
101,Section: 4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,PskKeyExchangeModes Structure,struct { PskKeyExchangeMode ke_modes<1..255>; ,0,Skip
102,Section: 4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Key Establishment Modes,"psk_ke: PSK-only key establishment. In this mode, the server MUST NOT supply a ""key_share"" value. psk_dhe_ke: PSK with (EC)DHE key establishment. In this mode, the client and server MUST supply ""key_share"" values as described in Section 4.2.8. Any future values that are allocated must ensure that the transmitted protocol messages unambiguously identify which mode was selected by the server; at present, this is indicated by the presence of the ""key_share"" in the ServerHello.",1,"<SRV-MSG-CONST> <1> (Servers MUST NOT supply a ""key_share"" value in the psk_ke mode) + <CLI-MSG-PROC> <1> (Clients MUST recognize that psk_ke mode does not include ""key_share"" values)
<SRV-MSG-CONST> <1> (Servers MUST supply ""key_share"" values in the psk_dhe_ke mode as described in Section 4.2.8) + <CLI-MSG-PROC> <1> (Clients MUST provide ""key_share"" values when using psk_dhe_ke mode)
<SRV-MSG-CONST> <1> (Servers MUST ensure protocol messages clearly indicate the selected key establishment mode) + <CLI-MSG-PROC> <0> (Clients MUST interpret the presence of ""key_share"" in ServerHello as an indication of the selected mode)"
103,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Early Data Use with PSK,"When a PSK is used and early data is allowed for that PSK, the client can send Application Data in its first flight of messages. If the client opts to do so, it MUST supply both the ""pre_shared_key"" and ""early_data"" extensions. The ""extension_data"" field of this extension contains an ""EarlyDataIndication"" value.",1,"<CLI-MSG-CONST> <1> (Clients MUST supply both ""pre_shared_key"" and ""early_data"" extensions when using early data with a PSK) + <SRV-MSG-PROC> <1> (Servers MUST verify the presence of both ""pre_shared_key"" and ""early_data"" extensions in the client's first flight of messages)  
<CLI-MSG-CONST> <1> (Clients MUST include ""EarlyDataIndication"" value in the ""extension_data"" field of the ""early_data"" extension) + <SRV-MSG-PROC> <0> (Servers MAY inspect the ""EarlyDataIndication"" value for compliance with protocol requirements)"
104,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Early Data Indication Structure,"The structure for EarlyDataIndication is defined as follows:

```c
struct {",0,Skip
105,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Parameters for 0-RTT Data,"The parameters for the 0-RTT data (version, symmetric cipher suite, Application-Layer Protocol Negotiation (ALPN) protocol, etc.) are those associated with the PSK in use. For externally provisioned PSKs, the associated values are those provisioned along with the key. For PSKs established via a NewSessionTicket message, the associated values are those which were negotiated in the connection which established the PSK. The PSK used to encrypt the early data MUST be the first PSK listed in the client's ""pre_shared_key"" extension.",1,"<CLI-MSG-CONST> <1> (Clients MUST use the first PSK listed in the ""pre_shared_key"" extension to encrypt early data) + <SRV-MSG-PROC> <1> (Servers MUST verify that the PSK used for early data is the first PSK in the client's ""pre_shared_key"" extension)  
<CLI-MSG-CONST> <1> (Parameters for 0-RTT data are those associated with the PSK in use, including version, cipher suite, and ALPN protocol) + <SRV-MSG-PROC> <0> (Servers MUST accept parameters associated with the PSK as provisioned or negotiated)"
106,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Server Validation of PSK Ticket,"For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued (see Section 8). If it is not, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.",1,"<SRV-MSG-PROC> <1> (Servers MUST validate that the ticket age for the selected PSK identity is within a small tolerance of the time since the ticket was issued) + <SRV-MSG-PROC> <1> (If the ticket age validation fails, servers SHOULD reject 0-RTT and SHOULD NOT assume the ClientHello is fresh)"
107,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,0-RTT Message Handling,"0-RTT messages sent in the first flight have the same (encrypted) content types as messages of the same type sent in other flights (handshake and application_data) but are protected under different keys. After receiving the server's Finished message, if the server has accepted early data, an EndOfEarlyData message will be sent to indicate the key change. This message will be encrypted with the 0-RTT traffic keys.",0,Skip
108,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Server Response Options,"A server which receives an ""early_data"" extension MUST behave in one of three ways:
- Ignore the extension and return a regular 1-RTT response.
- Request the client to send another ClientHello by responding with a HelloRetryRequest.
- Return its own ""early_data"" extension in EncryptedExtensions, indicating it intends to process the early data.",1,"<SRV-MSG-PROC> <1> (Servers MUST choose one of three behaviors upon receiving an ""early_data"" extension: ignore it and return a regular 1-RTT response, request a new ClientHello via HelloRetryRequest, or return their own ""early_data"" extension in EncryptedExtensions) + <CLI-MSG-CONST> <0> (Clients MAY expect one of these three server responses when including an ""early_data"" extension)"
109,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Requirements for Early Data Acceptance,"In order to accept early data, the server MUST have accepted a PSK cipher suite and selected the first key offered in the client's ""pre_shared_key"" extension. It MUST also verify that the TLS version number, selected cipher suite, and selected ALPN protocol (if any) are the same as those associated with the selected PSK.",1,"<SRV-MSG-CONST> <1> (Servers MUST accept early data only if a PSK cipher suite is selected and the first key in the client's ""pre_shared_key"" extension is chosen) + <SRV-MSG-PROC> <1> (Servers MUST verify that the TLS version, selected cipher suite, and selected ALPN protocol (if any) match those associated with the selected PSK)"
110,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Error Handling for Early Data,"If any of these checks fail, the server MUST NOT respond with the extension and must discard all the first-flight data using one of the mechanisms listed above. If the server accepts the ""early_data"" extension, it MUST comply with error-handling requirements specified for all records when processing early data records.",1,"<SRV-MSG-PROC> <1> (If checks fail, the server MUST discard all first-flight data and MUST NOT respond with the ""early_data"" extension) + <SRV-MSG-PROC> <1> (If the ""early_data"" extension is accepted, the server MUST comply with error-handling requirements for all records when processing early data records)"
111,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Client Handling of Rejected Early Data,"If the server rejects the ""early_data"" extension, the client application MAY opt to retransmit the Application Data previously sent in early data once the handshake has been completed. However, automatic retransmission of early data could lead to incorrect assumptions about the connection state.",0,Skip
112,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Guidance for TLS Implementations,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate. A TLS implementation MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol.,1,<CLI-MSG-PROC> <1> (TLS implementations MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol) + <CLI-MSG-PROC> <0> (TLS implementations SHOULD NOT automatically resend early data; applications should decide when retransmission is appropriate)
113,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Pre-Shared Key Extension Purpose,"The ""pre_shared_key"" extension is used to negotiate the identity of the pre-shared key to be used with a given handshake in association with PSK key establishment.",0,Skip
114,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,PreSharedKeyExtension Structure,"The ""extension_data"" field of this extension contains a ""PreSharedKeyExtension"" value:

```plaintext
struct {
    opaque identity<1..2^16-1>;
    uint32 obfuscated_ticket_age;
",0,Skip
115,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Identity Field Description,"identity:  A label for a key. For instance, a ticket (as defined in Appendix B.3.4) or a label for a pre-shared key established externally.",0,Skip
116,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Obfuscated Ticket Age Description,"obfuscated_ticket_age:  An obfuscated version of the age of the key. Section 4.2.11.1 describes how to form this value for identities established via the NewSessionTicket message. For identities established externally, an obfuscated_ticket_age of 0 SHOULD be used, and servers MUST ignore the value.",1,"<CLI-MSG-CONST> <1> (For identities established externally, clients SHOULD set the obfuscated_ticket_age to 0) + <SRV-MSG-PROC> <1> (Servers MUST ignore the obfuscated_ticket_age value when it is 0)  
<CLI-MSG-CONST> <0> (For identities established via NewSessionTicket, clients MUST follow the instructions in Section 4.2.11.1 to form the obfuscated_ticket_age) + <SRV-MSG-PROC> <0> (Servers MUST process obfuscated_ticket_age according to Section 4.2.11.1 for identities established via NewSessionTicket)"
117,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Identities Field Description,"identities:  A list of the identities that the client is willing to negotiate with the server. If sent alongside the ""early_data"" extension (see Section 4.2.10), the first identity is the one used for 0-RTT data.",0,Skip
118,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Binders Field Description,"binders:  A series of HMAC values, one for each value in the identities list and in the same order, computed as described below.",0,Skip
119,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Selected Identity Description,selected_identity:  The server's chosen identity expressed as a (0-based) index into the identities in the client's list.,0,Skip
120,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,PSK Hash Algorithm Requirements,"Each PSK is associated with a single Hash algorithm. For PSKs established via the ticket mechanism (Section 4.6.1), this is the KDF Hash algorithm on the connection where the ticket was established. For externally established PSKs, the Hash algorithm MUST be set when the PSK is established or default to SHA-256 if no such algorithm is defined. The server MUST ensure that it selects a compatible PSK (if any) and cipher suite.",1,"<SRV-MSG-CONST> <1> (Servers MUST select a compatible PSK and cipher suite based on the Hash algorithm associated with the PSK) + <SRV-MSG-CONST> <1> (For externally established PSKs, the Hash algorithm MUST be defined at the time of establishment or default to SHA-256 if not specified)  
<CLI-MSG-CONST> <1> (Clients MUST ensure that the Hash algorithm is set when establishing externally defined PSKs) + <SRV-MSG-PROC> <0> (Servers MUST verify the Hash algorithm compatibility when selecting a PSK)"
121,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Server Name Identification Note,"In TLS versions prior to TLS 1.3, the Server Name Identification (SNI) value was intended to be associated with the session (Section 3 of [RFC6066]). In TLS 1.3, the SNI value is always explicitly specified in the resumption handshake. Clients, however, SHOULD store the SNI with the PSK to fulfill the requirements of Section 4.6.1.",0,Skip
122,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Implementation Notes,"Implementor's note: When session resumption is the primary use case of PSKs, the most straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and then exclude any incompatible PSKs. Any unknown PSKs should simply be ignored. If no acceptable PSKs are found, the server SHOULD perform a non-PSK handshake if possible.",0,Skip
123,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Binder Validation Requirements,"Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value. If this value is not present or does not validate, the server MUST abort the handshake. Servers SHOULD NOT attempt to validate multiple binders; rather, they SHOULD select a single PSK and validate solely the binder that corresponds to that PSK.",1,"<SRV-MSG-PROC> <1> (Servers MUST validate the corresponding binder value before accepting PSK key establishment) + <SRV-MSG-PROC> <1> (If the binder value is absent or does not validate, servers MUST abort the handshake)  
<SRV-MSG-PROC> <0> (Servers SHOULD select a single PSK and validate only the corresponding binder) + <SRV-MSG-PROC> <0> (Servers SHOULD NOT attempt to validate multiple binders)"
124,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Client Verification Requirements,"Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server ""key_share"" extension is present if required by the ClientHello ""psk_key_exchange_modes"" extension. If these values are not consistent, the client MUST abort the handshake with an ""illegal_parameter"" alert.",1,"<CLI-MSG-PROC> <1> (Clients MUST verify that the server's selected_identity is within the range supplied by the client) + <CLI-MSG-PROC> <1> (Clients MUST verify that the server selected a cipher suite indicating a Hash associated with the PSK)  
<CLI-MSG-PROC> <1> (Clients MUST verify that a server ""key_share"" extension is present if required by the ClientHello ""psk_key_exchange_modes"" extension) + <CLI-MSG-PROC> <1> (If any verification fails, clients MUST abort the handshake with an ""illegal_parameter"" alert)"
125,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Early Data Verification,"If the server supplies an ""early_data"" extension, the client MUST verify that the server's selected_identity is 0. If any other value is returned, the client MUST abort the handshake with an ""illegal_parameter"" alert.",1,"<CLI-MSG-PROC> <1> (Clients MUST verify that the server's selected_identity is 0 when an ""early_data"" extension is supplied) + <CLI-MSG-PROC> <1> (If the selected_identity is not 0, clients MUST abort the handshake with an ""illegal_parameter"" alert)"
126,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Extension Position Requirement,"The ""pre_shared_key"" extension MUST be the last extension in the ClientHello. Servers MUST check that it is the last extension and otherwise fail the handshake with an ""illegal_parameter"" alert.",1,"<CLI-MSG-CONST> <1> (Clients MUST place the ""pre_shared_key"" extension as the last extension in the ClientHello) + <SRV-MSG-PROC> <1> (Servers MUST verify that the ""pre_shared_key"" extension is the last extension in ClientHello and fail the handshake with an ""illegal_parameter"" alert if it is not)"
127,Section: 4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age,Ticket Age Overview,"The client's view of the age of a ticket is the time since the receipt of the NewSessionTicket message. Clients MUST NOT attempt to use tickets which have ages greater than the ""ticket_lifetime"" value which was provided with the ticket.",1,"<CLI-MSG-PROC> <1> (Clients MUST NOT use tickets that have ages greater than the ""ticket_lifetime"" value provided with the ticket) + <SRV-MSG-PROC> <0> (Servers MUST verify ticket age against the ""ticket_lifetime"" during session resumption)"
128,Section: 4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age,Obfuscated Ticket Age Calculation,"The ""obfuscated_ticket_age"" field of each PskIdentity contains an obfuscated version of the ticket age formed by taking the age in milliseconds and adding the ""ticket_age_add"" value that was included with the ticket (see Section 4.6.1), modulo 2^32. This addition prevents passive observers from correlating connections unless tickets are reused.",0,Skip
129,Section: 4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age,Field Units and Limits,"Note that the ""ticket_lifetime"" field in the NewSessionTicket message is in seconds but the ""obfuscated_ticket_age"" is in milliseconds. Because ticket lifetimes are restricted to a week, 32 bits is enough to represent any plausible age, even in milliseconds.",0,Skip
130,Section: 4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,PSK Binder Overview,"The PSK binder value forms a binding between a PSK and the current handshake, as well as a binding between the handshake in which the PSK was generated (if via a NewSessionTicket message) and the current handshake. Each entry in the binders list is computed as an HMAC over a transcript hash (see Section 4.4.1) containing a partial ClientHello up to and including the PreSharedKeyExtension.identities field. That is, it includes all of the ClientHello but not the binders list itself. The length fields for the message (including the overall length, the length of the extensions block, and the length of the ""pre_shared_key"" extension) are all set as if binders of the correct lengths were present.",0,Skip
131,Section: 4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,PskBinderEntry Calculation,The PskBinderEntry is computed in the same way as the Finished message (Section 4.4.4) but with the BaseKey being the binder_key derived via the key schedule from the corresponding PSK which is being offered (see Section 7.1).,0,Skip
132,Section: 4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,Handling HelloRetryRequest,"If the handshake includes a HelloRetryRequest, the initial ClientHello and HelloRetryRequest are included in the transcript along with the new ClientHello. For instance, if the client sends ClientHello1, its binder will be computed over: Transcript-Hash(Truncate(ClientHello1)) Where Truncate() removes the binders list from the ClientHello.",0,Skip
133,Section: 4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,Binder Calculation After HelloRetryRequest,"If the server responds with a HelloRetryRequest and the client then sends ClientHello2, its binder will be computed over: Transcript-Hash(ClientHello1, HelloRetryRequest, Truncate(ClientHello2)) The full ClientHello1/ClientHello2 is included in all other handshake hash computations. Note that in the first flight, Truncate(ClientHello1) is hashed directly, but in the second flight, ClientHello1 is hashed and then reinjected as a ""message_hash"" message, as described in Section 4.4.1.",0,Skip
134,Section: 4.2.11.3.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Processing Order,0-RTT Data Streaming,"Clients are permitted to ""stream"" 0-RTT data until they receive the server's Finished, only then sending the EndOfEarlyData message, followed by the rest of the handshake.",0,Skip
135,Section: 4.2.11.3.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Processing Order,Early Data Processing Rules,"In order to avoid deadlocks, when accepting ""early_data"", servers MUST process the client's ClientHello and then immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending its ServerHello.",1,"<SRV-MSG-PROC> <1> (Servers MUST process the ClientHello before sending their flight of messages when accepting ""early_data"") + <SRV-MSG-PROC> <0> (Servers MUST NOT wait for the client's EndOfEarlyData message before sending the ServerHello)"
136,Section: 4.3.. Handshake Protocol_Server Parameters,Server Messages Overview,"The next two messages from the server, EncryptedExtensions and CertificateRequest, contain information from the server that determines the rest of the handshake. These messages are encrypted with keys derived from the server_handshake_traffic_secret.",0,Skip
137,Section: 4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,EncryptedExtensions Purpose,"In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message. This is the first message that is encrypted under keys derived from the server_handshake_traffic_secret.",1,<SRV-MSG-CONST> <1> (Servers MUST send the EncryptedExtensions message immediately after the ServerHello message in all handshakes) + <SRV-MSG-PROC> <1> (Servers MUST ensure that the EncryptedExtensions message is the first message encrypted under keys derived from the server_handshake_traffic_secret)
138,Section: 4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,Extension Requirements,"The EncryptedExtensions message contains extensions that can be protected, i.e., any which are not needed to establish the cryptographic context but which are not associated with individual certificates. The client MUST check EncryptedExtensions for the presence of any forbidden extensions and if any are found MUST abort the handshake with an ""illegal_parameter"" alert.",1,"<CLI-MSG-PROC> <1> (Clients MUST check the EncryptedExtensions message for any forbidden extensions) + <CLI-MSG-PROC> <1> (If forbidden extensions are found, clients MUST abort the handshake with an ""illegal_parameter"" alert)"
139,Section: 4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,Message Structure,"Structure of this message:

```plaintext
struct {
    Extension extensions<0..2^16-1>;
",0,Skip
140,Section: 4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,Extensions Field Details,"extensions: A list of extensions. For more information, see the table in Section 4.2.",0,Skip
141,Section: 4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Certificate Request Purpose,"A server which is authenticating with a certificate MAY optionally request a certificate from the client. This message, if sent, MUST follow EncryptedExtensions.",1,"<SRV-MSG-CONST><1>(Servers MAY optionally request a certificate from the client when authenticating with a certificate) + <SRV-MSG-CONST><1>(If a server requests a certificate, this message MUST follow EncryptedExtensions)"
142,Section: 4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,CertificateRequest Structure,"Structure of this message:

```plaintext
struct {
    opaque certificate_request_context<0..2^8-1>;
    Extension extensions<2..2^16-1>;
",0,Skip
143,Section: 4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Certificate Request Context,"certificate_request_context: An opaque string which identifies the certificate request and which will be echoed in the client's Certificate message. The certificate_request_context MUST be unique within the scope of this connection, thus preventing replay of client CertificateVerify messages. This field SHALL be zero length unless used for the post-handshake authentication exchanges described in Section 4.6.2. When requesting post-handshake authentication, the server SHOULD make the context unpredictable to the client (e.g., by randomly generating it) to prevent an attacker who has temporary access to the client's private key from pre-computing valid CertificateVerify messages.",1,"<SRV-MSG-CONST> <1> (The server MUST ensure the certificate_request_context is unique within the scope of the connection to prevent replay of client CertificateVerify messages) + <CLI-MSG-PROC> <1> (Clients MUST echo the unique certificate_request_context in their Certificate message)

<SRV-MSG-CONST> <0> (The server SHALL keep the certificate_request_context zero length unless used for post-handshake authentication exchanges) + <CLI-MSG-CONST> <0> (Clients MUST accept a zero length certificate_request_context unless post-handshake authentication is being requested)

<SRV-MSG-CONST> <1> (When requesting post-handshake authentication, the server SHOULD generate a random certificate_request_context to ensure unpredictability) + <CLI-MSG-PROC> <0> (Clients SHOULD prepare for an unpredictable certificate_request_context when post-handshake authentication is involved)"
144,Section: 4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Extensions Requirements,"extensions: A set of extensions describing the parameters of the certificate being requested. The ""signature_algorithms"" extension MUST be specified, and other extensions may optionally be included if defined for this message. Clients MUST ignore unrecognized extensions.",1,"<SRV-MSG-CONST> <1> (Servers MUST include the ""signature_algorithms"" extension in the Certificate Request) + <SRV-MSG-CONST> <0> (Servers MAY include other optional extensions in the Certificate Request if defined for this message)

<CLI-MSG-PROC> <1> (Clients MUST ignore any unrecognized extensions in the Certificate Request)"
145,Section: 4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,TLS 1.3 Differences,"In prior versions of TLS, the CertificateRequest message carried a list of signature algorithms and certificate authorities which the server would accept. In TLS 1.3, the former is expressed by sending the ""signature_algorithms"" and optionally ""signature_algorithms_cert"" extensions. The latter is expressed by sending the ""certificate_authorities"" extension (see Section 4.2.4).",0,Skip
146,Section: 4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,PSK Authentication Restriction,"Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6).",1,"<SRV-MSG-CONST> <1> (Servers MUST NOT send the CertificateRequest message during the main handshake when authenticating with a PSK) + <SRV-MSG-CONST> <1> (Servers MAY send the CertificateRequest message in post-handshake authentication if the client has sent the ""post_handshake_auth"" extension)"
147,Section: 4.4.. Handshake Protocol_Authentication Messages,Authentication Messages Overview,"TLS generally uses a common set of messages for authentication, key confirmation, and handshake integrity: Certificate, CertificateVerify, and Finished. These three messages are always sent as the last messages in their handshake flight. The Certificate and CertificateVerify messages are only sent under certain circumstances, as defined below. The Finished message is always sent as part of the Authentication Block. These messages are encrypted under keys derived from the [sender]_handshake_traffic_secret.",0,Skip
148,Section: 4.4.. Handshake Protocol_Authentication Messages,Inputs for Authentication Messages,"The computations for the Authentication messages all uniformly take the following inputs:
- The certificate and signing key to be used.
- A Handshake Context consisting of the set of messages to be included in the transcript hash.
- A Base Key to be used to compute a MAC key.",0,Skip
149,Section: 4.4.. Handshake Protocol_Authentication Messages,Message Definitions,"Based on these inputs, the messages then contain:
- **Certificate**: The certificate to be used for authentication, and any supporting certificates in the chain. Note that certificate-based client authentication is not available in PSK handshake flows (including 0-RTT).
- **CertificateVerify**: A signature over the value Transcript-Hash(Handshake Context, Certificate).
- **Finished**: A MAC over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using a MAC key derived from the Base Key.",0,Skip
150,Section: 4.4.. Handshake Protocol_Authentication Messages,Handshake Context and MAC Base Key Table,"The following table defines the Handshake Context and MAC Base Key for each scenario:

| Mode        | Handshake Context                  | Base Key                      |
|-------------|------------------------------------|-------------------------------|
| Server      | ClientHello ... later of          | server_handshake_traffic_     |
|             | EncryptedExtensions/               | secret                        |
|             | CertificateRequest                 |                               |
| Client      | ClientHello ... later of          | client_handshake_traffic_     |
|             | server Finished/EndOfEarlyData    | secret                        |
| Post-Handshake | ClientHello ... client Finished +| client_application_traffic_    |
|             | CertificateRequest                 | secret_N                      |",0,Skip
151,Section: 4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Transcript Hash Overview,"Many of the cryptographic computations in TLS make use of a transcript hash. This value is computed by hashing the concatenation of each included handshake message, including the handshake message header carrying the handshake message type and length fields, but not including record layer headers.",0,Skip
152,Section: 4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Transcript Hash Calculation,"I.e.,  
Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)",0,Skip
153,Section: 4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,HelloRetryRequest Exception,"As an exception to this general rule, when the server responds to a ClientHello with a HelloRetryRequest, the value of ClientHello1 is replaced with a special synthetic handshake message of handshake type ""message_hash"" containing Hash(ClientHello1). I.e.,  
Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) = Hash(message_hash || 00 00 Hash.length || Hash(ClientHello1) || HelloRetryRequest || ... || Mn)",0,Skip
154,Section: 4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Purpose of Synthetic Message,"The reason for this construction is to allow the server to do a stateless HelloRetryRequest by storing just the hash of ClientHello1 in the cookie, rather than requiring it to export the entire intermediate hash state (see Section 4.2.2).",0,Skip
155,Section: 4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Message Sequence for Transcript Hash,"For concreteness, the transcript hash is always taken from the following sequence of handshake messages, starting at the first ClientHello and including only those messages that were sent:  
ClientHello, HelloRetryRequest, ClientHello, ServerHello, EncryptedExtensions, server CertificateRequest, server Certificate, server CertificateVerify, server Finished, EndOfEarlyData, client Certificate, client CertificateVerify, client Finished.",0,Skip
156,Section: 4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Implementation Notes,"In general, implementations can implement the transcript by keeping a running transcript hash value based on the negotiated hash. Note, however, that subsequent post-handshake authentications do not include each other, just the messages through the end of the main handshake.",0,Skip
157,Section: 4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate Message Purpose,"This message conveys the endpoint's certificate chain to the peer. The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK). The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2). If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the ""certificate_list"" field having length 0). A Finished message MUST be sent regardless of whether the Certificate message is empty.",1,"<SRV-MSG-CONST><1>(Servers MUST send a Certificate message when using certificate-based key exchange methods) + <CLI-MSG-PROC><1>(Clients MUST send a Certificate message only if requested by the server via a CertificateRequest message)

<CLI-MSG-CONST><1>(Clients MUST send an empty Certificate message if no suitable certificate is available when client authentication is requested) + <SRV-MSG-PROC><1>(Servers MUST accept an empty Certificate message with a ""certificate_list"" field of length 0)

<SRV-MSG-PROC><1>(A Finished message MUST be sent after the Certificate message, regardless of its content) + <CLI-MSG-PROC><1>(Clients MUST also send a Finished message following their Certificate message)"
158,Section: 4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Message Structure,"The structure of this message is as follows:

```plaintext
enum {
    X509(0),
    RawPublicKey(2),
    (255)
",0,Skip
159,Section: 4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Field Descriptions,"The fields are defined as follows:

- **certificate_request_context**: If this message is in response to a CertificateRequest, this field contains the value of certificate_request_context from that message. Otherwise, it SHALL be zero length for server authentication.
  
- **certificate_list**: A sequence (chain) of CertificateEntry structures, each containing a single certificate and set of extensions.

- **extensions**: A set of extension values for the CertificateEntry. Valid extensions for server certificates currently include the OCSP Status extension [RFC6066] and the SignedCertificateTimestamp extension [RFC6962]. Extensions in the Certificate message from the server MUST correspond to those in the ClientHello message, and those in the clients Certificate message MUST correspond to extensions in the CertificateRequest from the server. If an extension applies to the entire chain, it SHOULD be included in the first CertificateEntry.
",1,"<SRV-MSG-CONST> <1> (Servers MUST include the **certificate_request_context** from the CertificateRequest if applicable; otherwise, it SHALL be zero length for server authentication) + <CLI-MSG-PROC> <1> (Clients MUST ensure the **certificate_request_context** is zero length when not in response to a CertificateRequest)

<SRV-MSG-CONST> <1> (Servers MUST provide a **certificate_list** containing a sequence of CertificateEntry structures) + <CLI-MSG-PROC> <1> (Clients MUST process the **certificate_list** as a chain of certificates)

<SRV-MSG-CONST> <1> (Servers MUST include extensions in the Certificate message that correspond to those in the ClientHello message) + <CLI-MSG-PROC> <1> (Clients MUST ensure their Certificate message extensions correspond to those in the CertificateRequest from the server)

<SRV-MSG-CONST> <1> (If an extension applies to the entire certificate chain, it SHOULD be included in the first CertificateEntry) + <CLI-MSG-PROC> <0> (Clients MAY expect the first CertificateEntry to contain chain-wide extensions if applicable)"
160,Section: 4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate Type Handling,"If the corresponding certificate type extension (""server_certificate_type"" or ""client_certificate_type"") was not negotiated in EncryptedExtensions, or if the X.509 certificate type was negotiated, each CertificateEntry contains a DER-encoded X.509 certificate. The sender's certificate MUST come first in the list, with each subsequent certificate SHOULD directly certify the one preceding it. A certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers possess any omitted certificates. The RawPublicKey certificate type allows only one CertificateEntry, containing an ASN1_subjectPublicKeyInfo value as defined in [RFC7250], Section 3. The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3. The server's certificate_list MUST always be non-empty.",1,"<SRV-MSG-CONST> <1> (Servers' certificate list MUST contain a DER-encoded X.509 certificate, with the sender's certificate first) + <CLI-MSG-PROC> <1> (Clients MUST ensure the first certificate in the list is the sender's certificate)
<SRV-MSG-CONST> <1> (Subsequent certificates in the list SHOULD directly certify the preceding certificate) + <CLI-MSG-PROC> <1> (Clients SHOULD verify that each certificate directly certifies the one before it)
<SRV-MSG-CONST> <1> (Servers MAY omit a trust anchor certificate from the chain if supported peers possess any omitted certificates) + <CLI-MSG-PROC> <1> (Clients MUST be able to handle omitted trust anchor certificates, provided they are supported)
<SRV-MSG-CONST> <1> (The RawPublicKey certificate type allows only one CertificateEntry containing an ASN1_subjectPublicKeyInfo value) + <CLI-MSG-PROC> <1> (Clients MUST accept only one CertificateEntry for RawPublicKey certificates)
<SRV-MSG-CONST> <1> (The OpenPGP certificate type MUST NOT be used with TLS 1.3) + <CLI-MSG-PROC> <1> (Clients MUST reject any certificate list containing OpenPGP certificate types)
<SRV-MSG-CONST> <1> (Servers' certificate_list MUST always be non-empty) + <CLI-MSG-PROC> <1> (Clients MUST expect a non-empty certificate list from servers)"
161,Section: 4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,OCSP and SCT Extensions Overview,"RFC6066 and RFC6961 provide extensions to negotiate the server sending OCSP responses to the client. In TLS 1.2 and below, the server replies with an empty extension to indicate negotiation of this extension, and the OCSP information is carried in a CertificateStatus message. In TLS 1.3, the server's OCSP information is carried in an extension in the CertificateEntry containing the associated certificate. Specifically, the body of the ""status_request"" extension from the server MUST be a CertificateStatus structure as defined in RFC6066, which is interpreted as defined in RFC6960.",1,"<SRV-MSG-CONST> <1> (Servers MUST include the OCSP information in the ""status_request"" extension within the CertificateEntry) + <SRV-MSG-PROC> <1> (Servers MUST ensure that the body of the ""status_request"" extension is a CertificateStatus structure as defined in RFC6066 and interpreted according to RFC6960)"
162,Section: 4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,Deprecated Status Request v2,"The status_request_v2 extension (RFC6961) is deprecated. TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients that wish to use it in earlier protocol versions.",1,"<SRV-MSG-PROC> <1> (Servers MUST NOT act upon the presence of the status_request_v2 extension in ClientHello messages) + <SRV-MSG-PROC> <1> (Servers MUST NOT send the status_request_v2 extension in EncryptedExtensions, CertificateRequest, or Certificate messages)  
<SRV-MSG-PROC> <0> (Servers MUST be able to process ClientHello messages that include the deprecated status_request_v2 extension) + <CLI-MSG-CONST> <0> (Clients MAY send the status_request_v2 extension in ClientHello messages for earlier protocol versions)"
163,Section: 4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,Client OCSP Response,"A server MAY request that a client present an OCSP response with its certificate by sending an empty ""status_request"" extension in its CertificateRequest message. If the client opts to send an OCSP response, the body of its ""status_request"" extension MUST be a CertificateStatus structure as defined in RFC6066.",1,"<SRV-MSG-CONST> <0> (Servers MAY request an OCSP response from clients by including an empty ""status_request"" extension in the CertificateRequest message) + <CLI-MSG-CONST> <1> (If a client decides to send an OCSP response, the ""status_request"" extension body MUST contain a CertificateStatus structure as defined in RFC6066)"
164,Section: 4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,SCT Information Handling,"Similarly, RFC6962 provides a mechanism for a server to send a Signed Certificate Timestamp (SCT) as an extension in the ServerHello in TLS 1.2 and below. In TLS 1.3, the server's SCT information is carried in an extension in the CertificateEntry.",0,Skip
165,Section: 4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Certificate Selection Rules,The following rules apply to the certificates sent by the server:,0,Skip
166,Section: 4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection,Client Certificate Rules,"The following rules apply to certificates sent by the client:

- The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).
- If the ""certificate_authorities"" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.
- The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2. Note that this relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.
- If the CertificateRequest message contained a non-empty ""oid_filters"" extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client, as described in Section 4.2.5.",1,"<CLI-MSG-CONST> <1> (Clients MUST use X.509v3 certificates unless negotiated otherwise) + <SRV-MSG-PROC> <1> (Servers MUST verify that the certificate type is X.509v3 or as negotiated)

<CLI-MSG-CONST> <0> (Clients SHOULD include at least one certificate issued by a CA listed in the ""certificate_authorities"" extension if present) + <SRV-MSG-PROC> <0> (Servers SHOULD check that at least one certificate in the chain is from the listed CAs)

<CLI-MSG-CONST> <1> (Clients MUST sign certificates using an acceptable signature algorithm) + <SRV-MSG-PROC> <1> (Servers MUST verify that the certificate's signature algorithm is acceptable)

<CLI-MSG-CONST> <1> (Clients MUST ensure that the end-entity certificate matches the OIDs specified in the ""oid_filters"" extension, if present) + <SRV-MSG-PROC> <1> (Servers MUST verify the end-entity certificate against the recognized OIDs in the ""oid_filters"" extension)"
167,Section: 4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Certificate Validation Requirements,"
In general, detailed certificate validation procedures are out of scope for TLS (see [RFC5280]). This section provides TLS-specific requirements.

1. If the server supplies an empty Certificate message, the client MUST abort the handshake with a ""decode_error"" alert.

2. If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either:
   - Continue the handshake without client authentication, or
   - Abort the handshake with a ""certificate_required"" alert.

3. If any aspect of the certificate chain is unacceptable (e.g., not signed by a known, trusted CA), the server MAY either:
   - Continue the handshake (considering the client unauthenticated), or
   - Abort the handshake.

4. Any endpoint receiving a certificate that requires validation using any signature algorithm with an MD5 hash MUST abort the handshake with a ""bad_certificate"" alert.

5. SHA-1 is deprecated, and it is RECOMMENDED that any endpoint receiving a certificate requiring validation using any signature algorithm with a SHA-1 hash abort the handshake with a ""bad_certificate"" alert. This means endpoints can accept these algorithms for self-signed certificates or trust anchors.

6. All endpoints are RECOMMENDED to transition to SHA-256 or better as soon as possible to maintain interoperability with implementations phasing out SHA-1 support.

7. A certificate containing a key for one signature algorithm MAY be signed using a different signature algorithm (for example, an RSA key signed with an ECDSA key).
",1,"<CLI-MSG-PROC> <1> (Clients MUST abort the handshake with a ""decode_error"" alert if the server supplies an empty Certificate message) + <SRV-MSG-PROC> <0> (Servers MAY choose to continue the handshake or abort with a ""certificate_required"" alert if the client sends an empty Certificate message)
<SRV-MSG-PROC> <0> (Servers MAY continue the handshake if the certificate chain is unacceptable, considering the client unauthenticated) + <SRV-MSG-PROC> <1> (Servers MUST abort the handshake if any certificate requires validation using an MD5 hash with a ""bad_certificate"" alert)
<CLI-MSG-PROC> <0> (Clients MUST abort the handshake with a ""bad_certificate"" alert if any certificate requires validation using an MD5 hash) + <SRV-MSG-PROC> <1> (Servers MUST abort the handshake with a ""bad_certificate"" alert if any certificate requires validation using an MD5 hash)
<CLI-MSG-PROC> <0> (Clients are RECOMMENDED to abort the handshake with a ""bad_certificate"" alert for certificates using a SHA-1 hash) + <SRV-MSG-PROC> <1> (Servers are RECOMMENDED to abort the handshake with a ""bad_certificate"" alert for certificates using a SHA-1 hash)
<CLI-MSG-PROC> <0> (Clients are RECOMMENDED to transition to SHA-256 or better for certificate validation) + <SRV-MSG-PROC> <0> (Servers are RECOMMENDED to transition to SHA-256 or better for certificate validation)
<CLI-MSG-CONST> <0> (Clients MAY accept a certificate signed with a different signature algorithm than the key's algorithm) + <SRV-MSG-CONST> <0> (Servers MAY accept a certificate signed with a different signature algorithm than the key's algorithm)"
168,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,CertificateVerify Purpose,"This message is used to provide explicit proof that an endpoint possesses the private key corresponding to its certificate. The CertificateVerify message also provides integrity for the handshake up to this point. Servers MUST send this message when authenticating via a certificate. Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty). When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.",1,"<SRV-MSG-CONST> <1> (Servers MUST send the CertificateVerify message when authenticating via a certificate) + <CLI-MSG-CONST> <1> (Clients MUST send the CertificateVerify message whenever the Certificate message is non-empty)  
<CLI-MSG-CONST> <1> (The CertificateVerify message MUST appear immediately after the Certificate message and immediately prior to the Finished message) + <SRV-MSG-CONST> <1> (The CertificateVerify message MUST appear immediately after the Certificate message and immediately prior to the Finished message)"
169,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Structure of CertificateVerify,"Structure of this message:
```c
struct {
    SignatureScheme algorithm;
    opaque signature<0..2^16-1>;
",0,Skip
170,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Content,"The content that is covered under the signature is the hash output as described in Section 4.4.1, namely:
```
Transcript-Hash(Handshake Context, Certificate)
```
The digital signature is computed over the concatenation of:
- A string that consists of octet 32 (0x20) repeated 64 times
- The context string
- A single 0 byte which serves as the separator
- The content to be signed",0,Skip
171,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Context Strings,"The context string for a server signature is ""TLS 1.3, server CertificateVerify"". The context string for a client signature is ""TLS 1.3, client CertificateVerify"". This separation helps prevent potential cross-protocol attacks.",0,Skip
172,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Calculation Example,"For example, if the transcript hash was 32 bytes of 01 (this length would make sense for SHA-256), the content covered by the digital signature for a server CertificateVerify would be:
```
2020202020202020202020202020202020202020202020202020202020202020
2020202020202020202020202020202020202020202020202020202020202020
544c5320312e332c207365727665722043657274696669636174655665726966
79
00
0101010101010101010101010101010101010101010101010101010101010101
```",0,Skip
173,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Field Calculation,"On the sender side, the process for computing the signature field of the CertificateVerify message takes as input:
- The content covered by the digital signature
- The private signing key corresponding to the certificate sent in the previous message.",0,Skip
174,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Algorithm Requirements,"If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's ""signature_algorithms"" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3). If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the ""signature_algorithms"" extension in the CertificateRequest message. The signature algorithm MUST also be compatible with the key in the sender's end-entity certificate.",1,"<SRV-MSG-CONST> <1> (If a server sends the CertificateVerify message, the signature algorithm MUST be one from the client's ""signature_algorithms"" extension unless unsupported algorithms are necessary to produce a valid certificate chain) + <CLI-MSG-PROC> <1> (Clients MUST ensure the signature algorithm in the CertificateVerify message is among those in the ""signature_algorithms"" extension in the CertificateRequest message)

<CLI-MSG-CONST> <1> (Clients MUST use a signature algorithm that is present in the supported_signature_algorithms field of the ""signature_algorithms"" extension in the CertificateRequest message for the CertificateVerify message) + <SRV-MSG-PROC> <1> (Servers MUST verify that the signature algorithm used in the CertificateVerify message is compatible with the key in the sender's end-entity certificate)"
175,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,RSA Signature Requirements,"RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in ""signature_algorithms"". The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages. All SHA-1 signature algorithms in this specification are defined solely for use in legacy certificates and are not valid for CertificateVerify signatures.",1,"<CLI-MSG-CONST> <1> (Clients MUST use RSASSA-PSS algorithm for RSA signatures in CertificateVerify messages) + <SRV-MSG-PROC> <1> (Servers MUST verify that RSA signatures in CertificateVerify messages use RSASSA-PSS algorithm)

<CLI-MSG-CONST> <1> (Clients MUST NOT use SHA-1 algorithm in signatures of CertificateVerify messages) + <SRV-MSG-PROC> <1> (Servers MUST reject CertificateVerify messages containing SHA-1 signatures)"
176,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Verification Process,"The receiver of a CertificateVerify message MUST verify the signature field. The verification process takes as input:
- The content covered by the digital signature
- The public key contained in the end-entity certificate found in the associated Certificate message
- The digital signature received in the signature field of the CertificateVerify message. If the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert.",1,"<SRV-MSG-PROC> <1> (Receivers MUST verify the signature field of the CertificateVerify message using the content it covers, the public key from the end-entity certificate, and the digital signature) + <SRV-MSG-PROC> <1> (If the signature verification fails, receivers MUST terminate the handshake with a ""decrypt_error"" alert)"
177,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Finished Message Overview,The Finished message is the final message in the Authentication Block. It is essential for providing authentication of the handshake and of the computed keys.,0,Skip
178,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Verification Requirement,"Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a ""decrypt_error"" alert.",1,"<CLI-MSG-PROC> <1> (Clients MUST verify the correctness of the contents of Finished messages) + <SRV-MSG-PROC> <1> (Servers MUST verify the correctness of the contents of Finished messages)  
<CLI-MSG-PROC> <1> (If the Finished message contents are incorrect, clients MUST terminate the connection with a ""decrypt_error"" alert) + <SRV-MSG-PROC> <1> (If the Finished message contents are incorrect, servers MUST terminate the connection with a ""decrypt_error"" alert)"
179,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Post-Finished Data Transmission,"Once a side has sent its Finished message and has received and validated the Finished message from its peer, it may begin to send and receive Application Data over the connection. There are two settings in which it is permitted to send data prior to receiving the peer's Finished:
1. Clients sending 0-RTT data as described in Section 4.2.10.
2. Servers MAY send data after sending their first flight, but because the handshake is not yet complete, they have no assurance of either the peer's identity or its liveness (i.e., the ClientHello might have been replayed).",0,Skip
180,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Finished Key Computation,"The key used to compute the Finished message is computed from the Base Key defined in Section 4.4 using HKDF (see Section 7.1). Specifically:
```
finished_key =
    HKDF-Expand-Label(BaseKey, ""finished"", """", Hash.length)
``` ",0,Skip
181,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Message Structure,"Structure of this message:
```
struct {
    opaque verify_data[Hash.length];
",0,Skip
182,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Verify Data Computation,"The verify_data value is computed as follows:
```
verify_data =
    HMAC(finished_key,
         Transcript-Hash(Handshake Context,
                         Certificate*, CertificateVerify*))
```
* Only included if present.",0,Skip
183,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,HMAC and Hashing,"HMAC [RFC2104] uses the Hash algorithm for the handshake. As noted above, the HMAC input can generally be implemented by a running hash, i.e., just the handshake hash at this point.",0,Skip
184,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Verify Data Length,"In previous versions of TLS, the verify_data was always 12 octets long. In TLS 1.3, it is the size of the HMAC output for the Hash used for the handshake.",0,Skip
185,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Record Encryption Requirement,"Any records following a Finished message MUST be encrypted under the appropriate application traffic key as described in Section 7.2. In particular, this includes any alerts sent by the server in response to client Certificate and CertificateVerify messages.",1,<SRV-MSG-CONST> <1> (Servers MUST encrypt any records following a Finished message under the appropriate application traffic key) + <SRV-MSG-PROC> <1> (Servers MUST ensure that alerts sent in response to client Certificate and CertificateVerify messages are encrypted accordingly)
186,Section: 4.5.. Handshake Protocol_End of Early Data,EndOfEarlyData Structure,struct {,0,Skip
187,Section: 4.5.. Handshake Protocol_End of Early Data,Message Sending Rules,"If the server sent an ""early_data"" extension in EncryptedExtensions, the client MUST send an EndOfEarlyData message after receiving the server Finished. If the server does not send an ""early_data"" extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message. This message indicates that all 0-RTT application_data messages, if any, have been transmitted and that the following records are protected under handshake traffic keys.",1,"<CLI-MSG-CONST> <1> (Clients MUST send an EndOfEarlyData message after receiving the server's Finished if the server sent an ""early_data"" extension in EncryptedExtensions) + <SRV-MSG-PROC> <1> (Servers MUST verify that clients send an EndOfEarlyData message when the ""early_data"" extension is present)

<CLI-MSG-CONST> <1> (Clients MUST NOT send an EndOfEarlyData message if the server did not send an ""early_data"" extension in EncryptedExtensions) + <SRV-MSG-PROC> <1> (Servers MUST reject messages if clients send an EndOfEarlyData message without the ""early_data"" extension being present)"
188,Section: 4.5.. Handshake Protocol_End of Early Data,Server Restrictions,"Servers MUST NOT send this message, and clients receiving it MUST terminate the connection with an ""unexpected_message"" alert.",1,"<SRV-MSG-CONST> <1> (Servers MUST NOT send the End of Early Data message) + <CLI-MSG-PROC> <1> (Clients receiving an End of Early Data message MUST terminate the connection with an ""unexpected_message"" alert)"
189,Section: 4.5.. Handshake Protocol_End of Early Data,Encryption Details,This message is encrypted under keys derived from the client_early_traffic_secret.,0,Skip
190,Section: 4.6.. Handshake Protocol_Post-Handshake Messages,Post-Handshake Message Overview,TLS also allows other messages to be sent after the main handshake. These messages use a handshake content type and are encrypted under the appropriate application traffic key.,0,Skip
191,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,New Session Ticket Purpose,"At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message. This message creates a unique association between the ticket value and a secret PSK derived from the resumption master secret (see Section 7). The client MAY use this PSK for future handshakes by including the ticket value in the ""pre_shared_key"" extension in its ClientHello (Section 4.2.11).",0,Skip
192,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Multiple Ticket Transmission,"Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events (see Appendix C.4). For instance, the server might send a new ticket after post-handshake authentication in order to encapsulate the additional client authentication state. Multiple tickets are useful for clients for a variety of purposes, including:
- Opening multiple parallel HTTP connections.
- Performing connection racing across interfaces and address families via (for example) Happy Eyeballs [RFC8305] or related techniques.",0,Skip
193,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Ticket Resumption Conditions,"Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection. Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session. If such an indication is provided (externally or by any other means), clients MAY resume with a different SNI value.",1,"<CLI-MSG-CONST> <1> (Clients MUST only resume a ticket with a cipher suite that has the same KDF hash algorithm as the original connection) + <SRV-MSG-PROC> <1> (Servers MUST verify that the cipher suite used for ticket resumption matches the original KDF hash algorithm)

<CLI-MSG-PROC> <1> (Clients MUST verify that the new SNI value is valid for the server certificate presented in the original session) + <SRV-MSG-PROC> <1> (Servers MUST validate the new SNI value against the original session's server certificate)

<CLI-MSG-PROC> <0> (Clients SHOULD only resume if the new SNI value matches the one used in the original session) + <SRV-MSG-PROC> <0> (Servers SHOULD prefer resumption with matching SNI values for optimal security)

<CLI-MSG-PROC> <0> (Clients MAY resume with a different SNI value if indicated) + <SRV-MSG-PROC> <0> (Servers MAY accept resumption with a different SNI value if indicated externally)"
194,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,SNI Reporting,"On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session. Note that if a server implementation declines all PSK identities with different SNI values, these two values are always the same.",1,"<CLI-MSG-CONST> <1> (On resumption, clients MUST use the SNI value from the resumption ClientHello when reporting to the calling application) + <SRV-MSG-PROC> <0> (Servers MUST ensure that SNI values are consistent when declining all PSK identities)"
195,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,New Session Ticket Structure,"The structure of the NewSessionTicket is defined as follows:
```
struct {
    uint32 ticket_lifetime;
    uint32 ticket_age_add;
    opaque ticket_nonce<0..255>;
    opaque ticket<1..2^16-1>;
    Extension extensions<0..2^16-2>;
",0,Skip
196,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Ticket Lifetime,`ticket_lifetime`: Indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance. Servers MUST NOT use any value greater than 604800 seconds (7 days). The value of zero indicates that the ticket should be discarded immediately. Clients MUST NOT cache tickets for longer than 7 days and MAY delete tickets earlier based on local policy.,1,"<SRV-MSG-CONST> <1> (Servers MUST set the `ticket_lifetime` value to no greater than 604800 seconds (7 days)) + <CLI-MSG-CONST> <1> (Clients MUST NOT cache tickets for longer than 604800 seconds (7 days))
<SRV-MSG-CONST> <1> (Servers MUST interpret a `ticket_lifetime` value of zero as an instruction to discard the ticket immediately) + <CLI-MSG-CONST> <0> (Clients MAY delete tickets earlier based on local policy)"
197,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Ticket Age Obfuscation,"`ticket_age_add`: A securely generated, random 32-bit value used to obscure the age of the ticket that the client includes in the ""pre_shared_key"" extension. The client-side ticket age is added to this value modulo 2^32 to obtain the transmitted value. The server MUST generate a fresh value for each ticket it sends.",1,"<CLI-MSG-CONST> <1> (Clients MUST include a `ticket_age_add` value to obscure the age of the ticket in the ""pre_shared_key"" extension) + <SRV-MSG-CONST> <1> (Servers MUST generate a fresh `ticket_age_add` value for each new session ticket sent)  
<CLI-MSG-PROC> <1> (Clients MUST compute the transmitted ticket age by adding the client-side ticket age to `ticket_age_add` modulo 2^32) + <SRV-MSG-PROC> <0> (Servers MUST use the fresh `ticket_age_add` value for the ticket age computation)"
198,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Unique Ticket Nonce,`ticket_nonce`: A per-ticket value that is unique across all tickets issued on this connection.,0,Skip
199,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Ticket Value,`ticket`: The value of the ticket to be used as the PSK identity. The ticket itself is an opaque label and MAY be either a database lookup key or a self-encrypted and self-authenticated value.,0,Skip
200,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Ticket Extensions,"`extensions`: A set of extension values for the ticket. Clients MUST ignore unrecognized extensions. The sole extension currently defined for NewSessionTicket is ""early_data"", indicating that the ticket may be used to send 0-RTT data (Section 4.2.10).",1,"<CLI-MSG-CONST> <1> (Clients MUST ignore unrecognized extensions in the NewSessionTicket message) + <SRV-MSG-CONST> <1> (Servers MUST include the ""early_data"" extension in the NewSessionTicket to indicate 0-RTT data usage)"
201,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Early Data Extension,"The ""early_data"" extension contains the following value:
- `max_early_data_size`: The maximum amount of 0-RTT data that the client is allowed to send when using this ticket, in bytes. Only Application Data payload is counted. A server receiving more than `max_early_data_size` bytes of 0-RTT data SHOULD terminate the connection with an ""unexpected_message"" alert.",0,Skip
202,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,PSK Derivation,"The PSK associated with the ticket is computed as:
```
HKDF-Expand-Label(resumption_master_secret, ""resumption"", ticket_nonce, Hash.length)
```
A different PSK will be derived for each ticket due to the distinct `ticket_nonce` value.",0,Skip
203,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Keying Material Lifetime Recommendation,"It is RECOMMENDED that implementations place limits on the total lifetime of keying material derived from an initial non-PSK handshake, considering the lifetime of the peer's certificate, the likelihood of intervening revocation, and the time since the peer's online CertificateVerify signature.",0,Skip
204,Section: 4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Post-Handshake Authentication Overview,"When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message. The client MUST respond with the appropriate Authentication messages (see Section 4.4).",1,"<SRV-MSG-CONST> <0> (Servers MAY request client authentication by sending a CertificateRequest message after the handshake has completed if the client has sent the ""post_handshake_auth"" extension) + <CLI-MSG-PROC> <1> (Clients MUST respond with the appropriate Authentication messages upon receiving a CertificateRequest)"
205,Section: 4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Client Authentication Requirements,"If the client chooses to authenticate, it MUST send Certificate, CertificateVerify, and Finished. If it declines, it MUST send a Certificate message containing no certificates followed by Finished. All of the client's messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.",1,"<CLI-MSG-CONST> <1> (Clients MUST send Certificate, CertificateVerify, and Finished messages if they choose to authenticate) + <SRV-MSG-PROC> <1> (Servers MUST expect these messages consecutively without intervening message types when client authentication is chosen)  
<CLI-MSG-CONST> <1> (Clients MUST send a Certificate message containing no certificates followed by Finished if they decline to authenticate) + <SRV-MSG-PROC> <1> (Servers MUST expect the decline messages consecutively without intervening message types)  
<CLI-MSG-PROC> <1> (Clients MUST ensure all messages for a given response appear consecutively on the wire) + <SRV-MSG-PROC> <1> (Servers MUST reject any response with intervening message types between client messages)"
206,Section: 4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Unexpected Message Handling,"A client that receives a CertificateRequest message without having sent the ""post_handshake_auth"" extension MUST send an ""unexpected_message"" fatal alert.",1,"<CLI-MSG-PROC> <1> (Clients MUST send an ""unexpected_message"" fatal alert upon receiving a CertificateRequest message without having sent the ""post_handshake_auth"" extension) + <SRV-MSG-PROC> <1> (Servers MUST ensure that clients sending a CertificateRequest have previously included the ""post_handshake_auth"" extension)"
207,Section: 4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Server Preparedness for Delays,"Because client authentication could involve prompting the user, servers MUST be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response.",1,"<SRV-MSG-PROC> <1> (Servers MUST be prepared for delays in client authentication, including handling an arbitrary number of messages between sending the CertificateRequest and receiving a response)"
208,Section: 4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Handling Multiple Certificate Requests,Clients which receive multiple CertificateRequests in close succession MAY respond to them in a different order than they were received (the certificate_request_context value allows the server to disambiguate the responses).,0,Skip
209,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,KeyUpdate Message Purpose,"The KeyUpdate handshake message is used to indicate that the sender is updating its sending cryptographic keys. This message can be sent by either peer after it has sent a Finished message. Implementations that receive a KeyUpdate message prior to receiving a Finished message MUST terminate the connection with an ""unexpected_message"" alert. After sending a KeyUpdate message, the sender SHALL send all its traffic using the next generation of keys, computed as described in Section 7.2. Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.",1,"<CLI-MSG-PROC><1>(Clients and servers MUST terminate the connection with an ""unexpected_message"" alert if a KeyUpdate message is received before a Finished message) +  
<SRV-MSG-PROC><1>(Servers MUST update receiving keys upon receiving a KeyUpdate message)

<CLI-MSG-CONST><1>(After sending a KeyUpdate message, the sender SHALL use the next generation of keys for all subsequent traffic) +  
<SRV-MSG-CONST><1>(Upon sending a KeyUpdate, the sender MUST ensure that all traffic is encrypted with the newly computed keys as described in Section 7.2)"
210,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,KeyUpdate Request Enumeration,"```enum {
    update_not_requested(0), 
    update_requested(1), 
    (255)
",0,Skip
211,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,KeyUpdate Structure,"```struct {
    KeyUpdateRequest request_update;
",0,Skip
212,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Request Update Field,"The request_update field indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate. If an implementation receives any other value, it MUST terminate the connection with an ""illegal_parameter"" alert.",1,"<CLI-MSG-CONST> <1> (Clients MUST set the request_update field to indicate whether a KeyUpdate response is required) + <SRV-MSG-PROC> <1> (Servers MUST terminate the connection with an ""illegal_parameter"" alert if an invalid request_update value is received)"
213,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Update Mechanism,"If the request_update field is set to ""update_requested"", then the receiver MUST send a KeyUpdate of its own with request_update set to ""update_not_requested"" prior to sending its next Application Data record. This mechanism allows either side to force an update to the entire connection, but causes an implementation which receives multiple KeyUpdates while it is silent to respond with a single update.",1,"<CLI-MSG-PROC> <1> (If a client sets request_update to ""update_requested"", it MUST send a KeyUpdate with request_update set to ""update_not_requested"" before sending the next Application Data record) + <SRV-MSG-PROC> <1> (If a server receives a KeyUpdate with request_update set to ""update_requested"", it MUST respond with its own KeyUpdate set to ""update_not_requested"" before sending its next Application Data record)  
<CLI-MSG-PROC> <0> (Implementations receiving multiple KeyUpdates while silent MUST respond with a single update) + <SRV-MSG-PROC> <0> (Servers MUST treat multiple silent KeyUpdates from clients as a single update)"
214,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Message Handling Between KeyUpdates,"Implementations may receive an arbitrary number of messages between sending a KeyUpdate with request_update set to ""update_requested"" and receiving the peer's KeyUpdate, because those messages may already be in flight. However, because send and receive keys are derived from independent traffic secrets, retaining the receive traffic secret does not threaten the forward secrecy of data sent before the sender changed keys.",0,Skip
215,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Crossing KeyUpdates,"If implementations independently send their own KeyUpdates with request_update set to ""update_requested"" and they cross in flight, then each side will also send a response, resulting in each side incrementing by two generations.",0,Skip
216,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Encryption Requirements,"Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys. Additionally, both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key. Failure to do so may allow message truncation attacks.",1,"<CLI-MSG-CONST> <1> (Clients MUST encrypt their KeyUpdate messages with the old keys) + <SRV-MSG-PROC> <1> (Servers MUST enforce that a KeyUpdate with the old key is received before accepting messages encrypted with the new key)  
<SRV-MSG-PROC> <1> (Servers MUST reject any messages encrypted with the new key until the KeyUpdate with the old key is verified) + <CLI-MSG-PROC> <1> (Clients MUST ensure that receiving the KeyUpdate with the old key occurs before processing messages encrypted with the new key)"
