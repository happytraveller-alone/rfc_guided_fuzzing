ID,Title,Content,RuleMatch,ExtractedRule,SlicedRule,Violation
1,Handshake Protocol Overview,"The handshake protocol is used to negotiate the security parameters of a connection. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext or TLSCiphertext structures which are processed and transmitted as specified by the current active connection state.",0,Skip,Skip,Skip
2,Handshake Message Types,"The enum defines various handshake message types, including client_hello, server_hello, new_session_ticket, end_of_early_data, encrypted_extensions, certificate, certificate_request, certificate_verify, finished, key_update, and message_hash.",0,Skip,Skip,Skip
3,Structure of Handshake Messages,"The struct describes the format of handshake messages, which includes a message type, length, and a selection of message-specific structures based on the message type.",0,Skip,Skip,Skip
4,Order of Protocol Messages,Protocol messages must be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2.,1,<CMC> <1> (Clients MUST send protocol messages in the order defined in Section 4.4.1.) + <SMP> <1> (Servers MUST process protocol messages in the order defined in Section 4.4.1.),<CMC> <1> (Clients MUST send protocol messages in the order defined in Section 4.4.1.) + <SMP> <1> (Servers MUST process protocol messages in the order defined in Section 4.4.1.),"```markdown
{CMC} (Send a ClientHello message after a Finished message, violating the required order of protocol messages.)

{CMC} (Include a Certificate message before the ClientHello message in the handshake sequence.)

{CMC} (Send multiple ClientHello messages in succession without waiting for a ServerHello response.)
```"
5,Handling Unexpected Message Orders,"A peer that receives a handshake message in an unexpected order must abort the handshake with an ""unexpected_message"" alert.",1,"<CMC> <1> (Clients MUST abort the handshake with an ""unexpected_message"" alert if they receive a handshake message in an unexpected order.) + <SMP> <1> (Servers MUST abort the handshake with an ""unexpected_message"" alert if they receive a handshake message in an unexpected order.)","<CMC> <1> (Clients MUST abort the handshake with an ""unexpected_message"" alert if they receive a handshake message in an unexpected order.) + <SMP> <1> (Servers MUST abort the handshake with an ""unexpected_message"" alert if they receive a handshake message in an unexpected order.)","```markdown
{CMC} (Send a ClientHello message after an unexpected message type, such as EncryptedExtensions, violating the expected order of handshake messages.)

{CMC} (Send a malformed ClientHello message that omits the mandatory ""cipher_suites"" field, which should trigger an unexpected message response from the server.)

{CMC} (Send a ClientHello message with an invalid session ID, which is not recognized by the server, thus creating an unexpected message scenario.)
```"
6,Assignment of New Message Types,New handshake message types are assigned by IANA as described in Section 11.,0,Skip,Skip,Skip
7,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip,Skip
8,ClientHello Options,"In TLS, the cryptographic negotiation proceeds by the client offering four sets of options in its ClientHello: a list of cipher suites, a ""supported_groups"" extension indicating (EC)DHE groups, a ""signature_algorithms"" extension, and a ""pre_shared_key"" extension with symmetric key identities.",0,Skip,Skip,Skip
9,Server Parameter Selection,"If the server does not select a PSK, it independently selects a cipher suite, (EC)DHE group, key share, and signature algorithm/certificate pair. If there's no overlap in ""supported_groups,"" the handshake must abort with a ""handshake_failure"" or ""insufficient_security"" alert.",1,"<SMC> <1> (Servers MUST independently select a cipher suite, (EC)DHE group, key share, and signature algorithm/certificate pair if no PSK is selected.) + <CMP> <1> (Clients MUST abort the handshake with a ""handshake_failure"" or ""insufficient_security"" alert if there's no overlap in ""supported_groups."")","<SMC> <1> (Servers MUST independently select a cipher suite, (EC)DHE group, key share, and signature algorithm/certificate pair if no PSK is selected.) + <CMP> <1> (Clients MUST abort the handshake with a ""handshake_failure"" or ""insufficient_security"" alert if there's no overlap in ""supported_groups."")","```markdown
{CMC} (Send a ClientHello that includes a cipher suite not supported by the server, causing a lack of overlap in ""supported_groups"".)

{CMC} (Omit the ""supported_groups"" field entirely from the ClientHello message, violating the requirement for the client to specify its supported groups.)

{CMC} (Include an empty ""key_share"" field in the ClientHello message, which is invalid as it must contain at least one key share entry.)
```"
10,PSK and Key Exchange Modes,"If the server selects a PSK, it must also choose a key establishment mode from the client's ""psk_key_exchange_modes"" extension. Non-overlap in ""supported_groups"" is not fatal if PSK can be used without (EC)DHE.",1,"<SMC> <1> (Servers MUST choose a key establishment mode from the client's ""psk_key_exchange_modes"" extension if a PSK is selected.) + <CMP> <0> (Clients MUST allow PSK to be used without (EC)DHE even if there is non-overlap in ""supported_groups"".)","<SMC> <1> (Servers MUST choose a key establishment mode from the client's ""psk_key_exchange_modes"" extension if a PSK is selected.) + <CMP> <0> (Clients MUST allow PSK to be used without (EC)","```markdown
{CMC} (Send a ClientHello without the ""psk_key_exchange_modes"" extension when requesting PSK usage.)

{CMC} (Include an invalid or unsupported value in the ""psk_key_exchange_modes"" extension in the ClientHello.)

{CMC} (Send a ClientHello indicating support for PSK but with a mismatched cipher suite that does not support PSK.)
```"
11,HelloRetryRequest Requirement,"If the server selects an (EC)DHE group without a compatible ""key_share"" from the client, it must respond with a HelloRetryRequest message.",1,"<SMC> <1> (Servers MUST respond with a HelloRetryRequest if an (EC)DHE group is selected without a compatible ""key_share"" from the client.) + <CMP> <0> (Clients MUST handle a HelloRetryRequest from the server when a compatible ""key_share"" is not provided.)","<SMC> <1> (Servers MUST respond with a HelloRetryRequest if an (EC)DHE group is selected without a compatible ""key_share"" from the client.) + <CMP> <0> (Clients MUST handle a HelloRetryRequest from the server when a compatible ""key_share"" is not provided.)","```markdown
{CMC} (Send a ClientHello message with an unsupported (EC)DHE group and omit the key_share extension entirely.)

{CMC} (Send a ClientHello message with a malformed key_share extension that does not conform to the expected format.)

{CMC} (Send a ClientHello message that includes a key_share extension but uses an invalid key length for the selected (EC)DHE group.)
```"
12,ServerHello Parameter Indication,"Upon successful parameter selection, the server indicates the selected parameters in the ServerHello, sending a ""pre_shared_key"" extension if PSK is used, and a ""key_share"" extension when (EC)DHE is in use. Authentication via certificate involves sending Certificate and CertificateVerify messages.",0,Skip,Skip,Skip
13,Handshake Abortion Conditions,"If the server fails to negotiate a supported set of parameters, it must abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert.",1,"<SMC> <1> (Servers MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert if they fail to negotiate a supported set of parameters.) + <CMP> <0> (Clients MUST be prepared to handle a ""handshake_failure"" or ""insufficient_security"" fatal alert during the handshake.)","<SMC> <1> (Servers MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert if they fail to negotiate a supported set of parameters.) + <CMP> <0> (Clients MUST be prepared to handle a ""handshake_failure"" or ""insufficient_security"" fatal alert during the handshake.)","```markdown
{CMC} (Send a ClientHello message with an unsupported cipher suite that the server does not recognize.)

{CMC} (Omit the Server Name Indication (SNI) extension from the ClientHello when the server requires it for negotiation.)

{CMC} (Include an invalid or malformed signature algorithm in the ClientHello, causing the server to reject the parameters.)
```"
14,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip,Skip
15,Server Hello Response,The server sends the ServerHello message in response to a ClientHello message to proceed with the handshake if it can negotiate acceptable handshake parameters.,0,Skip,Skip,Skip
16,Structure of ServerHello Message,"The ServerHello message structure includes fields for legacy_version, random, legacy_session_id_echo, cipher_suite, legacy_compression_method, and extensions.",0,Skip,Skip,Skip
17,Legacy Version Explanation,"The legacy_version field was previously used for version negotiation but is now set to 0x0303 for TLS 1.2. TLS 1.3 servers indicate their version using the ""supported_versions"" extension.",0,Skip,Skip,Skip
18,Random Value Generation,"The random field consists of 32 bytes generated by a secure random number generator, with specific requirements on the last 8 bytes based on the negotiated TLS version.",0,Skip,Skip,Skip
19,Session ID Echo,"legacy_session_id_echo contains the client's session ID, which must match the client's sent value; otherwise, the handshake is aborted with an ""illegal_parameter"" alert.",1,"<CMC> <1> (Clients' session ID in legacy_session_id_echo MUST match the sent value.) + <SMP> <1> (Servers MUST abort the handshake with an ""illegal_parameter"" alert if the session ID does not match.)","<CMC> <1> (Clients' session ID in legacy_session_id_echo MUST match the sent value.) + <SMP> <1> (Servers MUST abort the handshake with an ""illegal_parameter"" alert if the session ID does not match.)","```markdown
{CMC} (Send a ClientHello with a legacy_session_id_echo that does not match any previously established session ID.)

{CMC} (Include a legacy_session_id_echo field with an invalid length, exceeding the maximum allowed size for session IDs.)

{CMC} (Omit the legacy_session_id_echo field entirely from the ClientHello message, violating the requirement to include it when applicable.)
```"
20,Cipher Suite Selection,"The cipher_suite field contains the single cipher suite selected by the server from the client's offered list, and a mismatch results in an ""illegal_parameter"" alert.",0,Skip,Skip,Skip
21,Compression Method,The legacy_compression_method field must always have the value 0.,1,<CMC> <1> (Clients MUST set the legacy_compression_method field to 0.) + <SMP> <0> (Servers MUST accept the legacy_compression_method field with the value 0.),<CMC> <1> (Clients MUST set the legacy_compression_method field to 0.) + <SMP> <0> (Servers MUST accept the legacy_compression_method field with the value 0.),"```markdown
{CMC} (Set the legacy_compression_method field to an invalid value, such as 255, which is not defined in the specification.)

{CMC} (Omit the legacy_compression_method field entirely from the ClientHello message.)

{CMC} (Send the legacy_compression_method field with a value that should not be present in TLS 1.3, such as a negative number.)
```"
22,Extensions Requirements,"The extensions field must include only those necessary for establishing the cryptographic context and must contain the ""supported_versions"" extension in all TLS 1.3 messages.",1,"```
<CMC> <1> (Clients MUST include only necessary extensions for establishing the cryptographic context and MUST contain the ""supported_versions"" extension in all TLS 1.3 messages.) + <SMP> <1> (Servers MUST process only necessary extensions for establishing the cryptographic context and MUST expect the ""supported_versions"" extension in all TLS 1.3 messages.)
```","<CMC> <1> (Clients MUST include only necessary extensions for establishing the cryptographic context and MUST contain the ""supported_versions"" extension in all TLS 1.3 messages.) + <SMP> <1> (Servers MUST process only necessary extensions for establishing the cryptographic context and MUST expect the ""supported_versions"" extension in all TLS 1.3 messages.)","```markdown
{CMC} (Send a ClientHello message without the ""supported_versions"" extension.)

{CMC} (Include an extension in the ClientHello that is not defined in RFC 8446.)

{CMC} (Send a ClientHello with multiple unnecessary extensions that do not contribute to the cryptographic context.)
```"
23,HelloRetryRequest Structure,The HelloRetryRequest message uses the same structure as ServerHello but sets the Random value to a predefined SHA-256 hash for backward compatibility with middleboxes.,0,Skip,Skip,Skip
24,Random Value Check,"Upon receiving a server_hello message, implementations must check if the Random value matches specific criteria related to downgrade protection.",1,<SMC> <1> (Servers MUST check if the Random value in the server_hello message matches specific criteria related to downgrade protection.) + <CMP> <0> (Clients MUST verify the Random value in the server_hello message for downgrade protection compliance.),<SMC> <1> (Servers MUST check if the Random value in the server_hello message matches specific criteria related to downgrade protection.) + <CMP> <0> (Clients MUST verify the Random value in the server_hello message for downgrade protection compliance.),"```markdown
{CMC} (Send a ClientHello message with a Random value that does not meet downgrade protection criteria, such as using a predictable or reused value.)

{CMC} (Omit the Random value entirely from the ClientHello message, violating the requirement for uniqueness and randomness.)

{CMC} (Include an invalid or malformed value in the Random field of the ClientHello, such as exceeding the expected size of 32 bytes.)
```"
25,Downgrade Protection Mechanism,TLS 1.3 servers negotiating TLS 1.2 or below must set the last 8 bytes of the Random value to specific values to provide downgrade protection against attacks.,1,<SMC> <1> (Servers negotiating TLS 1.2 or below MUST set the last 8 bytes of the Random value to specific values for downgrade protection.) + <CMP> <0> (Clients MUST verify that the last 8 bytes of the Random value are set to the specific values for downgrade protection.),<SMC> <1> (Servers negotiating TLS 1.2 or below MUST set the last 8 bytes of the Random value to specific values for downgrade protection.) + <CMP> <0> (Clients MUST verify that the last 8 bytes of the Random value are set to the specific values for downgrade protection.),"```markdown
{CMC} (Send a ClientHello with the last 8 bytes of the Random value set to arbitrary values that do not match the required downgrade protection values.)

{CMC} (Send a ClientHello omitting the Random value entirely, violating the requirement to include it for negotiation.)

{CMC} (Send a ClientHello with a malformed Random value that is shorter than 32 bytes, thus violating the expected message structure.)
```"
26,Client Checks for Downgrade,"TLS 1.3 clients must verify the last 8 bytes of the Random value to prevent downgrade attacks, and if a match is found, they must abort the handshake with an ""illegal_parameter"" alert.",1,"<CMC> <1> (Clients MUST verify the last 8 bytes of the Random value to prevent downgrade attacks.) + <SMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if a match is found.)","<CMC> <1> (Clients MUST verify the last 8 bytes of the Random value to prevent downgrade attacks.) + <SMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if a match is found.)","```markdown
{CMC} (Send a ClientHello with a Random value where the last 8 bytes are all zeros, failing to verify against downgrade attack criteria.)

{CMC} (Include an invalid length for the Random value field in the ClientHello, such as less than 32 bytes.)

{CMC} (Send a ClientHello where the Random value contains non-random predictable bytes, undermining security expectations.)
```"
27,Renegotiation Handling,"A legacy TLS client receiving a TLS 1.3 ServerHello during renegotiation must abort the handshake with a ""protocol_version"" alert, as renegotiation is not possible in TLS 1.3.",1,"<CMC> <1> (A legacy TLS client MUST abort the handshake with a ""protocol_version"" alert upon receiving a TLS 1.3 ServerHello during renegotiation.) + <SMP> <0> (Servers MUST not expect renegotiation in TLS 1.3.)","<CMC> <1> (A legacy TLS client MUST abort the handshake with a ""protocol_version"" alert upon receiving a TLS 1.3 ServerHello during renegotiation.) + <SMP> <0> (Servers MUST not expect renegotiation in TLS 1.3.)","```markdown
{CMC} (Send a ClientHello message with an unsupported legacy protocol version, such as TLS 1.0, when initiating a TLS 1.3 handshake.)

{CMC} (Include an invalid ""cipher_suites"" list in the ClientHello that contains ciphers not compatible with TLS 1.3.)

{CMC} (Omit the mandatory ""extensions"" field in the ClientHello message, violating the requirement for extension presence in TLS 1.3.)
```"
28,Hello Retry Request Purpose,The server sends a HelloRetryRequest in response to a ClientHello message when it finds acceptable parameters but requires more information to proceed with the handshake. This message has the same format as a ServerHello message.,0,Skip,Skip,Skip
29,Extensions in Hello Retry Request,"The server's extensions must include ""supported_versions"" and may optionally include the ""cookie"" extension. It must not contain any extensions not first offered by the client, except for ""cookie.""",1,"<SMC> <1> (Servers MUST include the ""supported_versions"" extension in their extensions.) + <CMP> <1> (Clients MUST offer the ""supported_versions"" extension in their ClientHello.)
<SMC> <1> (Servers MAY optionally include the ""cookie"" extension in their extensions.) + <CMP> <1> (Clients MAY include the ""cookie"" extension in their ClientHello.)
<SMC> <1> (Servers MUST NOT include any extensions not first offered by the client, except for ""cookie."") + <CMP> <1> (Clients MUST offer extensions that the server can include.)","<SMC> <1> (Servers MUST include the ""supported_versions"" extension in their extensions.) + <CMP> <1> (Clients MUST offer the ""supported_versions"" extension in their ClientHello.)","```markdown
{CMC} (Send a ClientHello without the ""supported_versions"" extension included, violating the requirement to offer this extension.)
{CMC} (Send a ClientHello with an invalid format for the ""supported_versions"" extension, such as a version not defined in the specification.)
{CMC} (Send a ClientHello that includes multiple ""supported_versions"" extensions, which is not allowed per the specification.)
```"
,,,,,"<SMC> <1> (Servers MAY optionally include the ""cookie"" extension in their extensions.) + <CMP> <1> (Clients MAY include the ""cookie"" extension in their ClientHello.)","```markdown
{CMC} (Send a ClientHello without any extensions when a ""cookie"" extension is expected by the server.)

{CMC} (Include an invalid ""cookie"" extension in the ClientHello that does not conform to the expected format.)

{CMC} (Send a ClientHello with duplicate ""cookie"" extensions, violating the uniqueness requirement for extensions.)
```"
,,,,,"<SMC> <1> (Servers MUST NOT include any extensions not first offered by the client, except for ""cookie."") + <CMP> <1> (Clients MUST offer extensions that the server can include.)","```markdown
{CMC} (Send a ClientHello that includes an extension not supported by the server, violating the requirement to only offer compatible extensions.)

{CMC} (Send a ClientHello with an empty extensions field, omitting all offered extensions.)

{CMC} (Send a ClientHello that includes a critical extension marked as unsupported by the server, which should not be included in the server's response.)
```"
30,Client Actions on Hello Retry Request,"Upon receiving a HelloRetryRequest, the client must check specific fields and process the extensions, starting with ""supported_versions."" It must abort the handshake with an ""illegal_parameter"" alert if no changes result from the HelloRetryRequest.",1,"<CMC> <1> (Clients MUST check specific fields and process the extensions upon receiving a HelloRetryRequest, starting with ""supported_versions."") + <CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if no changes result from the HelloRetryRequest.)","<CMC> <1> (Clients MUST check specific fields and process the extensions upon receiving a HelloRetryRequest, starting with ""supported_versions."") + <CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if no changes result from the HelloRetryRequest.)","```markdown
{CMC} (Send a ClientHello without the ""supported_versions"" field after receiving a HelloRetryRequest.)

{CMC} (Send a ClientHello with an invalid ""supported_versions"" field that does not match any supported versions.)

{CMC} (Omit the ""extensions"" field entirely in the ClientHello after receiving a HelloRetryRequest.)
```"
31,Handling Multiple Hello Retry Requests,"If a client receives a second HelloRetryRequest in the same connection, it must abort the handshake with an ""unexpected_message"" alert.",1,"<CMC> <1> (Clients MUST abort the handshake with an ""unexpected_message"" alert upon receiving a second HelloRetryRequest in the same connection.) + <SMP> <0> (Servers MUST not send a second HelloRetryRequest in the same connection.)","<CMC> <1> (Clients MUST abort the handshake with an ""unexpected_message"" alert upon receiving a second HelloRetryRequest in the same connection.) + <SMP> <0> (Servers MUST not send a second HelloRetryRequest in the same connection.)","```markdown
{CMC} (Send a ClientHello message after receiving a second HelloRetryRequest instead of aborting the handshake with an ""unexpected_message"" alert.)

{CMC} (Send a malformed ClientHello message that includes an invalid or unsupported cipher suite after receiving a HelloRetryRequest.)

{CMC} (Omit the required ""random"" field from the ClientHello message following a HelloRetryRequest.)
```"
32,Cipher Suite Negotiation,A client must abort the handshake if it receives a cipher suite not offered earlier. Servers must negotiate the same cipher suite when receiving an updated ClientHello.,1,<CMC> <1> (Clients MUST abort the handshake if they receive a cipher suite not offered earlier.) + <SMP> <1> (Servers MUST negotiate the same cipher suite when receiving an updated ClientHello.),<CMC> <1> (Clients MUST abort the handshake if they receive a cipher suite not offered earlier.) + <SMP> <1> (Servers MUST negotiate the same cipher suite when receiving an updated ClientHello.),"```markdown
{CMC} (Send a ClientHello that includes an unsupported cipher suite that was not offered in the initial negotiation.)

{CMC} (Send a ClientHello with the cipher suites list omitted entirely, violating the requirement to specify available options.)

{CMC} (Send a ClientHello with a malformed cipher suite entry that does not conform to the expected format or range.)
```"
33,Selected Version Consistency,"The selected_version in the HelloRetryRequest must be retained in the ServerHello; otherwise, the client must abort the handshake with an ""illegal_parameter"" alert.",1,"<SMC> <1> (Servers MUST retain the selected_version from the HelloRetryRequest in the ServerHello.) + <CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the selected_version is not retained in the ServerHello.)","<SMC> <1> (Servers MUST retain the selected_version from the HelloRetryRequest in the ServerHello.) + <CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the selected_version is not retained in the ServerHello.)","```markdown
{CMC} (Send a ClientHello with a version that is not supported by the server, forcing an unexpected response without waiting for a ServerHello.)

{CMC} (Send a ClientHello that includes an unsupported extension, causing the server to potentially drop the handshake prematurely.)

{CMC} (Send a ClientHello with the `random` field set to all zeros, which should trigger an error due to invalid randomness.)
```"
34,ClientHello Update Guidelines,"In its updated ClientHello, the client should avoid offering pre-shared keys associated with different hashes than that of the selected cipher suite to prevent unnecessary computations.",0,Skip,Skip,Skip
35,TLS Extensions Structure,"A number of TLS messages contain tag-length-value encoded extensions structures. The structure includes an ""extension_type"" to identify the extension and ""extension_data"" for specific information related to the extension type.",0,Skip,Skip,Skip
36,Extension Types,"The list of extension types, including server_name, max_fragment_length, and others, is maintained by IANA as described in Section 11.",0,Skip,Skip,Skip
37,Request/Response Model,Extensions are generally structured in a request/response manner. The client sends extension requests in the ClientHello message while the server responds in various messages such as ServerHello and Certificate.,0,Skip,Skip,Skip
38,Unsolicited Extensions,"The server may send unsolicited extensions in the NewSessionTicket, which the client does not respond to directly.",0,Skip,Skip,Skip
39,Handling Extension Responses,"Implementations must not send extension responses if the corresponding requests were not received, except for the ""cookie"" extension in HelloRetryRequest, which may lead to an ""unsupported_extension"" alert if violated.",1,"<SMC> <1> (Servers MUST not send extension responses if the corresponding requests were not received, except for the ""cookie"" extension in HelloRetryRequest.) + <CMP> <1> (Clients MAY receive an ""unsupported_extension"" alert if the server violates the rule regarding extension responses.)","<SMC> <1> (Servers MUST not send extension responses if the corresponding requests were not received, except for the ""cookie"" extension in HelloRetryRequest.) + <CMP> <1> (Clients MAY receive an ""unsupported_extension"" alert if the server violates the rule regarding extension responses.)","```markdown
{CMC} (Include an unsupported extension in the ClientHello message that the server has not been requested to respond to.)

{CMC} (Omit the required ""client_version"" field from the ClientHello message, which is necessary for extension processing.)

{CMC} (Send a ClientHello message with an invalid ""cipher_suites"" list that contains unsupported or malformed cipher suites.)
```"
40,Extension Message Restrictions,"If an implementation receives an extension not specified for the message, it must abort the handshake with an ""illegal_parameter"" alert.",1,"<CMC> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if an extension not specified for the message is received.) + <SMP> <0> (Servers MUST not accept extensions not specified for the message and must trigger an abort with an ""illegal_parameter"" alert.)","<CMC> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if an extension not specified for the message is received.) + <SMP> <0> (Servers MUST not accept extensions not specified for the message and must trigger an abort with an ""illegal_parameter"" alert.)","```markdown
{CMC} (Include an unknown extension in the ClientHello message that is not defined in RFC 8446.)

{CMC} (Send a ClientHello message without the mandatory supported_versions extension.)

{CMC} (Construct a ClientHello that specifies an invalid cipher suite not listed in the supported cipher suites.)
```"
41,Extension Message Availability,"A table indicates where each extension may appear, using notations like CH (ClientHello) and SH (ServerHello).",0,Skip,Skip,Skip
42,Order of Extensions,"When multiple extensions are present, they may appear in any order, except for ""pre_shared_key,"" which must be last in ClientHello. No more than one extension of the same type may exist in a block.",1,"<CMC> <1> (Clients MAY include multiple extensions in any order, except for ""pre_shared_key,"" which MUST be last in the ClientHello.) + <SMP> <1> (Servers MUST process multiple extensions in any order, except for ""pre_shared_key,"" which MUST be last in the ClientHello.)
<CMC> <1> (Clients MUST not include more than one extension of the same type in a block.) + <SMP> <1> (Servers MUST reject multiple extensions of the same type in a block.)","<CMC> <1> (Clients MAY include multiple extensions in any order, except for ""pre_shared_key,"" which MUST be last in the ClientHello.) + <SMP> <1> (Servers MUST process multiple extensions in any order, except for ""pre_shared_key,"" which MUST be last in the ClientHello.)","```markdown
{CMC} (Include the ""pre_shared_key"" extension before other extensions in the ClientHello message.)

{CMC} (Send a ClientHello with an unsupported extension type that is not defined in RFC 8446.)

{CMC} (Omit the mandatory ""client_version"" field from the ClientHello message.)
```"
,,,,,<CMC> <1> (Clients MUST not include more than one extension of the same type in a block.) + <SMP> <1> (Servers MUST reject multiple extensions of the same type in a block.),"```markdown
{CMC} (Include multiple instances of the same extension type in the ClientHello, such as multiple ""server_name"" extensions.)

{CMC} (Include duplicate ""supported_versions"" extensions within the ClientHello message.)

{CMC} (Send a ClientHello with multiple ""key_share"" extensions, each containing different key shares.)
```"
43,Negotiation in TLS 1.3,"In TLS 1.3, extensions are negotiated for each handshake, even in resumption-PSK mode, differing from TLS 1.2.",0,Skip,Skip,Skip
44,Security Considerations,Designers should consider security implications when introducing new extensions to prevent attacks that manipulate handshake messages.,0,Skip,Skip,Skip
45,Error Handling in Extensions,"Error conditions and refusals to support features should be handled properly, using appropriate alerts for errors and fields in responses for refusals.",0,Skip,Skip,Skip
46,Integrity of Handshake Phase,"Designers must ensure that extensions do not compromise security, especially since active attackers can modify messages until the handshake is authenticated.",1,<CMC> <1> (Designers MUST ensure that extensions do not compromise security during the handshake.) + <SMP> <0> (Servers MUST handle extensions in a way that maintains security integrity until the handshake is authenticated.),<CMC> <1> (Designers MUST ensure that extensions do not compromise security during the handshake.) + <SMP> <0> (Servers MUST handle extensions in a way that maintains security integrity until the handshake is authenticated.),"```markdown
{CMC} (Include an extension that contains a value larger than the maximum allowed size, potentially leading to buffer overflow vulnerabilities.)

{CMC} (Send a ClientHello that contains an extension with invalid or unsupported values that could disrupt the handshake process.)

{CMC} (Omit mandatory extensions from the ClientHello, such as the supported groups extension, which is essential for key exchange.)
```"
47,Supported Versions Extension Purpose,"The ""supported_versions"" extension is used by the client to indicate which versions of TLS it supports and by the server to indicate the version it is using. The extension contains a list of supported versions in preference order, with the most preferred version first.",0,Skip,Skip,Skip
48,ClientHello Requirements,"Implementations of this specification must send the ""supported_versions"" extension in the ClientHello, containing all versions of TLS they are prepared to negotiate, minimally including 0x0304. Previous versions of TLS must also be included if allowed.",1,"<CMC> <1> (Clients MUST send the ""supported_versions"" extension in the ClientHello, containing all versions of TLS they are prepared to negotiate, minimally including 0x0304.) + <SMP> <0> (Servers MUST accept the ""supported_versions"" extension in the ClientHello, containing all versions of TLS prepared for negotiation.)  
<CMC> <1> (Clients MUST include previous versions of TLS if allowed.) + <SMP> <0> (Servers MUST accept previous versions of TLS included in the ""supported_versions"" extension if allowed.)","<CMC> <1> (Clients MUST send the ""supported_versions"" extension in the ClientHello, containing all versions of TLS they are prepared to negotiate, minimally including 0x0304.) + <SMP> <0> (Servers MUST accept the ""supported_versions"" extension in the ClientHello, containing all versions of TLS prepared for negotiation.)","```markdown
{CMC} (Send a ClientHello without the ""supported_versions"" extension)

{CMC} (Send a ClientHello with an invalid ""supported_versions"" extension value, such as 0x9999)

{CMC} (Send a ClientHello with the ""supported_versions"" extension containing only outdated TLS versions, excluding 0x0304)
```"
,,,,,"<CMC> <1> (Clients MUST include previous versions of TLS if allowed.) + <SMP> <0> (Servers MUST accept previous versions of TLS included in the ""supported_versions"" extension if allowed.)","```markdown
{CMC} (Send a ClientHello that includes an unsupported TLS version in the ""supported_versions"" extension.)

{CMC} (Omit the ""supported_versions"" extension entirely from the ClientHello message.)

{CMC} (Include multiple ""supported_versions"" extensions with conflicting version numbers in the ClientHello message.)
```"
49,Server Behavior Without Extension,"If the ""supported_versions"" extension is not present, compliant servers supporting TLS 1.2 must negotiate TLS 1.2 or prior, regardless of the ClientHello.legacy_version value. Servers may abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.",1,"<SMC> <1> (Servers MUST negotiate TLS 1.2 or prior if the ""supported_versions"" extension is not present, regardless of the ClientHello.legacy_version value.) + <CMP> <1> (Clients MAY include legacy_version 0x0304 or later in the ClientHello, but servers may abort the handshake upon receiving such a value.)  
<SMC> <1> (Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.) + <CMP> <1> (Clients MUST be aware that their legacy_version could lead to handshake abortion if it is 0x0304 or later.)","<SMC> <1> (Servers MUST negotiate TLS 1.2 or prior if the ""supported_versions"" extension is not present, regardless of the ClientHello.legacy_version value.) + <CMP> <1> (Clients MAY include legacy_version 0x0304 or later in the ClientHello, but servers may abort the handshake upon receiving such a value.)","```markdown
{CMC} (Send a ClientHello without the ""supported_versions"" extension while including a legacy_version of 0x0304, which should trigger an abort from the server but violates the expected negotiation behavior.)

{CMC} (Include an unsupported legacy_version value (e.g., 0x0305) in the ClientHello, which is invalid and should result in a handshake failure.)

{CMC} (Send a ClientHello with the ""supported_versions"" extension but include a malformed version list that contains non-existent versions, violating the format requirement.)
```"
,,,,,<SMC> <1> (Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.) + <CMP> <1> (Clients MUST be aware that their legacy_version could lead to handshake abortion if it is 0x0304 or later.),"```markdown
{CMC} (Send a ClientHello message with legacy_version set to 0x0304, which should trigger an abort from the server.)

{CMC} (Send a ClientHello message with legacy_version set to an invalid value, such as 0xFFFF, which is not defined in the RFC.)

{CMC} (Send a ClientHello message omitting the legacy_version field entirely, violating the required structure of the message.)
```"
50,Version Negotiation with Extension,"If the extension is present in the ClientHello, servers must not use the ClientHello.legacy_version for version negotiation and must rely solely on the ""supported_versions"" extension. They must select only a version present in this extension and ignore any unknown versions.",1,"<CMC> <1> (Clients MUST include the ""supported_versions"" extension for version negotiation.) + <SMP> <1> (Servers MUST rely solely on the ""supported_versions"" extension and must not use ClientHello.legacy_version for version negotiation.)  
<SMC> <1> (Servers MUST select only a version present in the ""supported_versions"" extension.) + <CMP> <1> (Clients MUST ensure only known versions are included in the ""supported_versions"" extension.)","<CMC> <1> (Clients MUST include the ""supported_versions"" extension for version negotiation.) + <SMP> <1> (Servers MUST rely solely on the ""supported_versions"" extension and must not use ClientHello.legacy_version for version negotiation.)","```markdown
{CMC} (Send a ClientHello message without the ""supported_versions"" extension.)

{CMC} (Send a ClientHello message with an invalid ""supported_versions"" extension containing unsupported or malformed version numbers.)

{CMC} (Send a ClientHello message with multiple ""supported_versions"" extensions, violating the one-extension rule for version negotiation.)
```"
,,,,,"<SMC> <1> (Servers MUST select only a version present in the ""supported_versions"" extension.) + <CMP> <1> (Clients MUST ensure only known versions are included in the ""supported_versions"" extension.)","```markdown
{CMC} (Include an unsupported TLS version in the ""supported_versions"" extension, such as TLS 1.2, when initiating the ClientHello message.)
{CMC} (Omit the ""supported_versions"" extension entirely from the ClientHello message.)
{CMC} (Send a ""supported_versions"" extension that includes a duplicate version number, violating the uniqueness requirement.)
```"
51,Server Response Based on Negotiated Version,"A server negotiating a version prior to TLS 1.3 must set ServerHello.version and not send the ""supported_versions"" extension. If negotiating TLS 1.3, the server must send a ""supported_versions"" extension with the selected version value (0x0304) and set ServerHello.legacy_version to 0x0303 (TLS 1.2). Clients must check for this extension before processing the rest of the ServerHello.",1,"```
<SMC> <1> (Servers MUST set ServerHello.version to a version prior to TLS 1.3 and not send the ""supported_versions"" extension when negotiating that version.) + <CMP> <1> (Clients MUST check for the ""supported_versions"" extension before processing the rest of the ServerHello.)
<SMC> <1> (Servers MUST send a ""supported_versions"" extension with the selected version value (0x0304) when negotiating TLS 1.3.) + <CMP> <1> (Clients MUST check for the ""supported_versions"" extension before processing the rest of the ServerHello.)
<SMC> <1> (Servers MUST set ServerHello.legacy_version to 0x0303 (TLS 1.2) when negotiating TLS 1.3.) + <CMP> <1> (Clients MUST check for the ""supported_versions"" extension before processing the rest of the ServerHello.)
```","<SMC> <1> (Servers MUST set ServerHello.version to a version prior to TLS 1.3 and not send the ""supported_versions"" extension when negotiating that version.) + <CMP> <1> (Clients MUST check for the ""supported_versions"" extension before processing the rest of the ServerHello.)","```markdown
{CMC} (Send a ClientHello message with a ""supported_versions"" extension that includes versions not supported by the server.)

{CMC} (Send a ClientHello message with an empty ""supported_versions"" extension.)

{CMC} (Send a ClientHello message with the version set to TLS 1.2 when negotiating with a server that only supports TLS 1.3.)
```"
,,,,,"<SMC> <1> (Servers MUST send a ""supported_versions"" extension with the selected version value (0x0304) when negotiating TLS 1.3.) + <CMP> <1> (Clients MUST check for the ""supported_versions"" extension before processing the rest of the ServerHello.)","```markdown
{CMC} (Send a ClientHello message without the ""supported_versions"" extension, violating the expected format for TLS 1.3 negotiation.)
{CMC} (Include an invalid version value (e.g., 0x0302) in the ""supported_versions"" extension of the ClientHello message.)
{CMC} (Send a malformed ""supported_versions"" extension that contains a length field greater than the actual number of versions provided.)
```"
,,,,,"<SMC> <1> (Servers MUST set ServerHello.legacy_version to 0x0303 (TLS 1.2) when negotiating TLS 1.3.) + <CMP> <1> (Clients MUST check for the ""supported_versions"" extension before processing the rest of the ServerHello.)","```markdown
{CMC} (Send a ClientHello without the ""supported_versions"" extension, thereby failing to adhere to the required negotiation process for TLS 1.3.)

{CMC} (Include an unsupported version in the ""supported_versions"" extension, such as 0x0302 (TLS 1.1), violating the specification that only TLS 1.3 versions should be listed.)

{CMC} (Send an invalid ""client_version"" field in the ClientHello, such as 0x0000, which is not a valid version for TLS 1.3.)
```"
52,Client Validation of Selected Version,"If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or a version prior to TLS 1.3, the client must abort the handshake with an ""illegal_parameter"" alert.",1,"<CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the ""supported_versions"" extension in the ServerHello contains a version not offered by the client.) + <SMC> <1> (Servers MUST include only versions offered by the client in the ""supported_versions"" extension in the ServerHello.)  
<CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the ""supported_versions"" extension contains a version prior to TLS 1.3.) + <SMC> <1> (Servers MUST NOT include versions prior to TLS 1.3 in the ""supported_versions"" extension in the ServerHello.)","<CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the ""supported_versions"" extension in the ServerHello contains a version not offered by the client.) + <SMC> <1> (Servers MUST include only versions offered by the client in the ""supported_versions"" extension in the ServerHello.)","```markdown
{CMC} (Send a ClientHello with an empty ""supported_versions"" extension, violating the requirement to offer at least one version.)

{CMC} (Send a ClientHello with a ""supported_versions"" extension that includes a version not supported by the server.)

{CMC} (Send a ClientHello with malformed syntax in the ""supported_versions"" extension (e.g., incorrect length field).)
```"
,,,,,"<CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the ""supported_versions"" extension contains a version prior to TLS 1.3.) + <SMC> <1> (Servers MUST NOT include versions prior to TLS 1.3 in the ""supported_versions"" extension in the ServerHello.)","```markdown
{CMC} (Send a ClientHello with the ""supported_versions"" extension containing a version prior to TLS 1.3, without aborting the handshake.)
{CMC} (Include an invalid ""supported_versions"" extension format in the ClientHello that does not conform to the expected structure.)
{CMC} (Send a ClientHello with the ""supported_versions"" extension containing duplicate entries for the same version.)
```"
53,Cookie Structure Definition,The cookie structure is defined as an opaque value of size between 1 and 65535 bytes.,0,Skip,Skip,Skip
54,Purpose of Cookies,"Cookies serve two primary purposes: enabling the server to require the client to demonstrate reachability for DoS protection and allowing the server to offload state to the client, facilitating a HelloRetryRequest without storing state.",0,Skip,Skip,Skip
55,HelloRetryRequest and Cookie Extension,"When sending a HelloRetryRequest, the server may provide a ""cookie"" extension, deviating from the usual rule that only ClientHello extensions may be sent.",0,Skip,Skip,Skip
56,ClientHello Cookie Requirement,The client must include the cookie extension received in the HelloRetryRequest in the new ClientHello. Clients must not use cookies in their initial ClientHello for subsequent connections.,1,"<CMC> <1> (Clients MUST include the cookie extension received in the HelloRetryRequest in the new ClientHello.) + <SMP> <1> (Servers MUST accept the cookie extension included in the new ClientHello.)  
<CMC> <1> (Clients MUST NOT use cookies in their initial ClientHello for subsequent connections.) + <SMP> <0> (Servers MUST not expect cookies in the initial ClientHello for subsequent connections.)",<CMC> <1> (Clients MUST include the cookie extension received in the HelloRetryRequest in the new ClientHello.) + <SMP> <1> (Servers MUST accept the cookie extension included in the new ClientHello.),"```markdown
{CMC} (Send a ClientHello that omits the cookie extension received in the HelloRetryRequest, violating the requirement to include it.)

{CMC} (Send a ClientHello with an invalid format for the cookie extension, such as a non-hexadecimal string.)

{CMC} (Send a ClientHello with multiple cookie extensions, which contradicts the specification that only one cookie extension should be present.)
```"
,,,,,<CMC> <1> (Clients MUST NOT use cookies in their initial ClientHello for subsequent connections.) + <SMP> <0> (Servers MUST not expect cookies in the initial ClientHello for subsequent connections.),"```markdown
{CMC} (Include a session cookie in the initial ClientHello message for a new connection, violating the spec that disallows cookies in this context.)
{CMC} (Send a ClientHello message with an invalid or malformed cookie format, which is not acceptable according to the RFC.)
{CMC} (Omit the mandatory `client_version` field in the ClientHello message while including a cookie, violating the requirement for proper message structure.)
```"
57,Stateless Server Behavior,"A stateless server may receive an unprotected record of type change_cipher_spec between ClientHello messages and must ignore these records, as it does not retain any state.",1,"<SMC> <1> (Servers MUST ignore unprotected change_cipher_spec records received between ClientHello messages, as they do not retain state.) + <CMP> <0> (Clients MAY send unprotected change_cipher_spec records between ClientHello messages, but servers MUST ignore them.)","<SMC> <1> (Servers MUST ignore unprotected change_cipher_spec records received between ClientHello messages, as they do not retain state.) + <CMP> <0> (Clients MAY send unprotected change_cipher_spec records between ClientHello messages, but servers MUST ignore them.)","```markdown
{CMC} (Send an unprotected change_cipher_spec record as a first message, violating the expectation of a ClientHello.)
{CMC} (Send multiple ClientHello messages without waiting for a server response, violating proper state management.)
{CMC} (Send a ClientHello message with an invalid or unsupported cipher suite that is not listed in the supported groups.)
```"
58,Signature Algorithm Extensions in TLS 1.3,"TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures: ""signature_algorithms_cert"" for certificate signatures and ""signature_algorithms"" for CertificateVerify messages.",0,Skip,Skip,Skip
59,Key Compatibility Requirement,"The keys found in certificates must be of appropriate type for the signature algorithms used, particularly concerning RSA keys and PSS signatures.",1,"<SMC> <1> (Servers MUST ensure that the keys found in certificates are of appropriate type for the signature algorithms used.) + <CMP> <0> (Clients MUST use appropriate key types that match the signature algorithms, particularly for RSA keys and PSS signatures.)","<SMC> <1> (Servers MUST ensure that the keys found in certificates are of appropriate type for the signature algorithms used.) + <CMP> <0> (Clients MUST use appropriate key types that match the signature algorithms, particularly for RSA keys and PSS signatures.)","```markdown
{CMC} (Send a ClientHello with an RSA key but use a signature algorithm that requires ECDSA keys.)

{CMC} (Include a key type in the ClientHello that is not supported by the server's offered cipher suites.)

{CMC} (Send a ClientHello with an invalid key type that does not match any of the signature algorithms in the server's Certificate.)
```"
60,Client Authentication Requirement,"Clients desiring server authentication via a certificate must send the ""signature_algorithms"" extension; otherwise, the server must abort the handshake with a ""missing_extension"" alert.",1,"<CMC> <1> (Clients MUST send the ""signature_algorithms"" extension for server authentication via a certificate.) + <SMP> <1> (Servers MUST abort the handshake with a ""missing_extension"" alert if the ""signature_algorithms"" extension is not present.)","<CMC> <1> (Clients MUST send the ""signature_algorithms"" extension for server authentication via a certificate.) + <SMP> <1> (Servers MUST abort the handshake with a ""missing_extension"" alert if the ""signature_algorithms"" extension is not present.)","```markdown
{CMC} (Send a ClientHello message without the ""signature_algorithms"" extension to violate the requirement for server authentication.)

{CMC} (Include an empty ""signature_algorithms"" extension in the ClientHello message to incorrectly signal the absence of supported algorithms.)

{CMC} (Send a ClientHello message with an invalidly formatted ""signature_algorithms"" extension that does not conform to the expected structure.)
```"
61,"Purpose of ""signature_algorithms_cert""","The ""signature_algorithms_cert"" extension allows implementations to clearly signal their capabilities regarding different sets of algorithms for certificates and TLS.",0,Skip,Skip,Skip
62,SignatureScheme List Structure,"The ""extension_data"" field of these extensions contains a SignatureSchemeList value, which lists supported signature algorithms in descending order of preference.",0,Skip,Skip,Skip
63,Signature Algorithm Types and Descriptions,"Various signature algorithms are defined, including RSASSA-PKCS1-v1_5, ECDSA, and EdDSA, each with specific requirements regarding their use and parameters.",0,Skip,Skip,Skip
64,Deprecation of Legacy Algorithms,"Legacy algorithms using SHA-1 are being deprecated; clients must list these as lower priority, and TLS 1.3 servers must not offer SHA-1 signed certificates unless unavoidable.",1,<CMC> <1> (Clients MUST list SHA-1 algorithms as lower priority.) + <SMP> <1> (Servers MUST NOT offer SHA-1 signed certificates unless unavoidable.),<CMC> <1> (Clients MUST list SHA-1 algorithms as lower priority.) + <SMP> <1> (Servers MUST NOT offer SHA-1 signed certificates unless unavoidable.),"```markdown
{CMC} (Include SHA-1 algorithms as the highest priority in the ClientHello message.)

{CMC} (Send a ClientHello message that omits all supported signature algorithms, including SHA-1.)

{CMC} (Send a ClientHello message with an invalid list of signature algorithms, such as repeating the same algorithm multiple times.)
```"
65,Self-Signed Certificate Validation,"Signatures on self-signed certificates or trust anchors are not validated, as they initiate a certification path and may use unsupported signature algorithms.",0,Skip,Skip,Skip
66,Compatibility with TLS 1.2,"TLS 1.3 implementations negotiating TLS 1.2 must adhere to its requirements, including the ability to negotiate without the ""signature_algorithms"" extension and accept legacy signature pairs.",1,"<SMC> <1> (Servers negotiating TLS 1.2 MUST adhere to its requirements, including the ability to accept legacy signature pairs.) + <CMP> <1> (Clients negotiating TLS 1.2 MUST adhere to its requirements, including the ability to negotiate without the ""signature_algorithms"" extension.)","<SMC> <1> (Servers negotiating TLS 1.2 MUST adhere to its requirements, including the ability to accept legacy signature pairs.) + <CMP> <1> (Clients negotiating TLS 1.2 MUST adhere to its requirements, including the ability to negotiate without the ""signature_algorithms"" extension.)","```markdown
{CMC} (Send a ClientHello message without the required ""supported_versions"" field for TLS 1.3.)

{CMC} (Send a ClientHello message with an invalid ""cipher_suites"" list that includes cipher suites not defined for TLS 1.3.)

{CMC} (Send a ClientHello message that omits the mandatory ""extensions"" field entirely.)
```"
67,Certificate Authorities Extension Purpose,"The ""certificate_authorities"" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which should guide certificate selection by the receiving endpoint.",0,Skip,Skip,Skip
68,Certificate Authorities Extension Structure,"The body of the ""certificate_authorities"" extension consists of a CertificateAuthoritiesExtension structure, which includes a list of distinguished names of acceptable certificate authorities.",0,Skip,Skip,Skip
69,Distinguished Name Representation,"The authorities are represented in DER-encoded format and specify desired distinguished names for trust anchors or subordinate CAs, helping to describe known trust anchors and authorization spaces.",0,Skip,Skip,Skip
70,Client and Server Usage,"The client may send the ""certificate_authorities"" extension in the ClientHello message, while the server may send it in the CertificateRequest message.",0,Skip,Skip,Skip
71,Non-usage of Trusted CA Keys Extension,"The ""trusted_ca_keys"" extension, which serves a similar purpose but is more complicated, is not used in TLS 1.3, although it may appear in ClientHello messages from clients offering prior versions of TLS.",0,Skip,Skip,Skip
72,OID Filters Purpose,"The ""oid_filters"" extension allows servers to provide a set of OID/value pairs that the client's certificate should match. This extension must only be sent in the CertificateRequest message if provided by the server.",1,"<SMC> <1> (Servers MUST send the ""oid_filters"" extension in the CertificateRequest message only if provided.) + <CMP> <1> (Clients MUST match their certificate against the OID/value pairs provided in the ""oid_filters"" extension.)","<SMC> <1> (Servers MUST send the ""oid_filters"" extension in the CertificateRequest message only if provided.) + <CMP> <1> (Clients MUST match their certificate against the OID/value pairs provided in the ""oid_filters"" extension.)","```markdown
{CMC} (Send a ClientHello message without any certificate, even when the server expects a certificate based on the ""oid_filters"" extension.)

{CMC} (Include an ""oid_filters"" extension in the ClientHello with invalid OID values that do not match any known certificate.)

{CMC} (Omit the ""Client Certificate"" field entirely while the server specifies that a certificate is required based on the ""oid_filters"" extension.)
```"
73,OIDFilter Structure,"The OIDFilter structure consists of two fields: `certificate_extension_oid` and `certificate_extension_values`, which represent the OID and its corresponding values.",0,Skip,Skip,Skip
74,Filters List Requirement,"Filters must be a list of certificate extension OIDs with their allowed values in DER-encoded format. If the server includes a non-empty filters list, the client certificate must contain all specified extension OIDs that the client recognizes.",1,<SMC> <1> (Servers MUST include a non-empty filters list of certificate extension OIDs with allowed values in DER-encoded format.) + <CMP> <1> (Clients MUST ensure that the client certificate contains all specified extension OIDs that they recognize.),<SMC> <1> (Servers MUST include a non-empty filters list of certificate extension OIDs with allowed values in DER-encoded format.) + <CMP> <1> (Clients MUST ensure that the client certificate contains all specified extension OIDs that they recognize.),"```markdown
{CMC} (Send a ClientHello message that includes an empty certificate extension OIDs list, violating the requirement for a non-empty filters list.)

{CMC} (Send a ClientHello message with certificate extensions that contain OIDs not recognized by the server, thus failing the requirement to ensure all specified OIDs are recognized.)

{CMC} (Send a ClientHello message that completely omits the certificate extension field, violating the explicit requirement for including recognized OIDs.)
```"
75,Client Certificate Validation,"For each recognized extension OID, all specified values must be present in the client certificate. The client may include additional values but must ignore unrecognized OIDs.",1,<CMC> <1> (Clients MUST include all specified values for recognized extension OIDs in the client certificate.) + <SMP> <0> (Servers MUST accept client certificates that include additional values but ignore unrecognized OIDs.),<CMC> <1> (Clients MUST include all specified values for recognized extension OIDs in the client certificate.) + <SMP> <0> (Servers MUST accept client certificates that include additional values but ignore unrecognized OIDs.),"```markdown
{CMC} (Include an unrecognized extension OID in the client certificate that exceeds the maximum allowed length according to RFC 8446.)

{CMC} (Omit the required ""signature"" field in the client certificate when sending the ClientHello.)

{CMC} (Send a ClientHello with a client certificate that has an invalid or malformed public key structure.)
```"
76,Server Actions on Mismatch,"If the client ignores required extension OIDs and provides a non-compliant certificate, the server may either continue without client authentication or abort the handshake with an ""unsupported_certificate"" alert.",1,"<CMC> <1> (Clients MUST NOT ignore required extension OIDs and MUST provide a compliant certificate.) + <SMP> <1> (Servers MAY continue without client authentication if required extensions are ignored.)  
<CMC> <1> (Clients MUST NOT provide a non-compliant certificate.) + <SMP> <1> (Servers MAY abort the handshake with an ""unsupported_certificate"" alert if a non-compliant certificate is provided.)",<CMC> <1> (Clients MUST NOT ignore required extension OIDs and MUST provide a compliant certificate.) + <SMP> <1> (Servers MAY continue without client authentication if required extensions are ignored.),"```markdown
{CMC} (Send a ClientHello message with missing required extension OIDs, such as not including the supported_versions extension.)

{CMC} (Construct a ClientHello message that includes an invalid or malformed certificate extension that does not conform to expected formats.)

{CMC} (Send a ClientHello where the certificate presented contains unsupported algorithms or key types, violating compliance with the server's expectations.)
```"
,,,,,"<CMC> <1> (Clients MUST NOT provide a non-compliant certificate.) + <SMP> <1> (Servers MAY abort the handshake with an ""unsupported_certificate"" alert if a non-compliant certificate is provided.)","```markdown
{CMC} (Provide a self-signed certificate that lacks the required extensions specified in RFC 8446.)

{CMC} (Send a certificate with an unsupported signature algorithm that is explicitly disallowed by the TLS 1.3 specification.)

{CMC} (Include a certificate chain that contains certificates with invalid expiration dates, making them non-compliant with the certificate validation requirements.)
```"
77,Unique OID Requirement,Each OID must not appear more than once in the filters list.,1,<CMC> <1> (Clients MUST ensure that each OID appears only once in the filters list.) + <SMP> <0> (Servers MUST reject the filters list if an OID appears more than once.),<CMC> <1> (Clients MUST ensure that each OID appears only once in the filters list.) + <SMP> <0> (Servers MUST reject the filters list if an OID appears more than once.),"```markdown
{CMC} (Include multiple identical OIDs in the filters list of the ClientHello message.)

{CMC} (Omit the filters list entirely from the ClientHello message, violating the requirement to include it when necessary.)

{CMC} (Send a ClientHello where the filters list contains invalid OIDs that are not recognized or supported.)
```"
78,PKI Library Dependency,TLS implementations are expected to rely on their PKI libraries to perform certificate selection using the defined OID filters.,0,Skip,Skip,Skip
79,Matching Rules for Key Usages,"The document defines matching rules for the Key Usage and Extended Key Usage extensions, requiring that all asserted bits or OIDs in the request be present in the corresponding certificate extensions.",0,Skip,Skip,Skip
80,Exclusion of anyExtendedKeyUsage,The special anyExtendedKeyUsage OID must not be used in the request for Extended Key Usage.,1,<CMC> <1> (Clients MUST NOT use the special anyExtendedKeyUsage OID in the request for Extended Key Usage.) + <SMP> <0> (Servers MUST reject requests that include the anyExtendedKeyUsage OID in Extended Key Usage.),<CMC> <1> (Clients MUST NOT use the special anyExtendedKeyUsage OID in the request for Extended Key Usage.) + <SMP> <0> (Servers MUST reject requests that include the anyExtendedKeyUsage OID in Extended Key Usage.),"```markdown
{CMC} (Include the anyExtendedKeyUsage OID in the Extended Key Usage extension of the ClientHello message)

{CMC} (Send a ClientHello message that contains an invalid or malformed Extended Key Usage extension)

{CMC} (Omit the mandatory Server Name Indication (SNI) extension from the ClientHello message while including anyExtendedKeyUsage OID)
```"
81,Potential for Additional Specifications,Separate specifications may define matching rules for other certificate extensions.,0,Skip,Skip,Skip
82,Post-Handshake Authentication Extension Purpose,"The ""post_handshake_auth"" extension indicates that a client is willing to perform post-handshake authentication (Section 4.6.2).",0,Skip,Skip,Skip
83,Server Requirements for Post-Handshake Authentication,Servers must not send a post-handshake CertificateRequest to clients that do not offer this extension.,1,<SMC> <1> (Servers MUST NOT send a post-handshake CertificateRequest to clients that do not offer this extension.) + <CMP> <0> (Clients MUST offer the extension to receive a post-handshake CertificateRequest.),<SMC> <1> (Servers MUST NOT send a post-handshake CertificateRequest to clients that do not offer this extension.) + <CMP> <0> (Clients MUST offer the extension to receive a post-handshake CertificateRequest.),"```markdown
{CMC} (Send a ClientHello without the expected post-handshake CertificateRequest extension when the server is configured to request it.)

{CMC} (Send a ClientHello that includes an invalid value for the post-handshake CertificateRequest extension.)

{CMC} (Send a ClientHello with an unsupported cipher suite that the server cannot accept, leading to a CertificateRequest being sent.)
```"
84,Prohibition of Extension by Servers,Servers must not send this extension.,1,<SMC> <1> (Servers MUST NOT send this extension.) + <CMP> <0> (Clients MUST ignore this extension if received.),<SMC> <1> (Servers MUST NOT send this extension.) + <CMP> <0> (Clients MUST ignore this extension if received.),"```markdown
{CMC} (Send a ClientHello message containing a prohibited extension that the server must not send, violating the server's constraints.)

{CMC} (Send a ClientHello message with an invalid or malformed format for an allowed extension that the server is required to ignore.)

{CMC} (Send a ClientHello without mandatory fields that should correlate with the prohibited extension, causing protocol confusion.)
```"
85,Post-Handshake Auth Structure,"The ""extension_data"" field of the ""post_handshake_auth"" extension is zero length.",0,Skip,Skip,Skip
86,Supported Groups Extension,"When sent by the client, the ""supported_groups"" extension indicates the named groups which the client supports for key exchange, ordered from most preferred to least preferred.",0,Skip,Skip,Skip
87,Historical Context,"In versions of TLS prior to TLS 1.3, this extension was named ""elliptic_curves"" and only contained elliptic curve groups.",0,Skip,Skip,Skip
88,Signature Algorithms Negotiation,"Signature algorithms are now negotiated independently, as described in Section 4.2.3.",0,Skip,Skip,Skip
89,NamedGroupList Structure,"The ""extension_data"" field of this extension contains a ""NamedGroupList"" value, which includes elliptic curve groups (ECDHE) and finite field groups (DHE).",0,Skip,Skip,Skip
90,Elliptic Curve Groups,Elliptic Curve Groups (ECDHE) indicate support for named curves defined in FIPS 186-4 or RFC 7748.,0,Skip,Skip,Skip
91,Finite Field Groups,Finite Field Groups (DHE) indicate support for finite field groups defined in RFC 7919.,0,Skip,Skip,Skip
92,Order of Preferences,"Items in named_group_list are ordered according to the sender's preferences, with the most preferred choice first.",0,Skip,Skip,Skip
93,Server Behavior in TLS 1.3,"As of TLS 1.3, servers may send the ""supported_groups"" extension to the client, and clients must not act on this information until the handshake is complete.",1,"<SMC> <1> (Servers MAY send the ""supported_groups"" extension to the client.) + <CMP> <1> (Clients MUST NOT act on the ""supported_groups"" information until the handshake is complete.)","<SMC> <1> (Servers MAY send the ""supported_groups"" extension to the client.) + <CMP> <1> (Clients MUST NOT act on the ""supported_groups"" information until the handshake is complete.)","```markdown
{CMC} (Send a ClientHello message with a malformed ""supported_groups"" extension that includes an unsupported group identifier.)

{CMC} (Omit the ""supported_groups"" extension entirely from the ClientHello message, even though the server has sent it.)

{CMC} (Include multiple ""supported_groups"" extensions in the ClientHello message, which violates the protocol's constraints on extension uniqueness.)
```"
94,Updating Client Preferences,"If the server has a preferred group not in the client's ""key_share"" extension but is still willing to accept the ClientHello, it should send ""supported_groups"" to update the client’s view of its preferences.",0,Skip,Skip,Skip
95,Key Share Extension Overview,"The ""key_share"" extension contains the endpoint's cryptographic parameters and allows clients to send an empty client_shares vector to request group selection from the server, incurring an additional round trip.",0,Skip,Skip,Skip
96,KeyShareEntry Structure,The KeyShareEntry structure includes a named group for the key being exchanged and key exchange information determined by the specified group.,0,Skip,Skip,Skip
97,ClientHello Key Share Data,"In the ClientHello message, the ""extension_data"" field contains a ""KeyShareClientHello"" value, which includes a list of offered KeyShareEntry values in descending order of client preference.",0,Skip,Skip,Skip
98,Empty Client Shares for HelloRetryRequest,"The client_shares vector may be empty if the client is requesting a HelloRetryRequest, but each KeyShareEntry must correspond to a group in the ""supported_groups"" extension.",1,"<CMC> <1> (Clients MAY have an empty client_shares vector when requesting a HelloRetryRequest.) + <SMP> <1> (Servers MUST ensure that each KeyShareEntry corresponds to a group in the ""supported_groups"" extension.)","<CMC> <1> (Clients MAY have an empty client_shares vector when requesting a HelloRetryRequest.) + <SMP> <1> (Servers MUST ensure that each KeyShareEntry corresponds to a group in the ""supported_groups"" extension.)","```markdown
{CMC} (Send a ClientHello with a non-empty client_shares vector when requesting a HelloRetryRequest, contradicting the allowance for an empty vector.)

{CMC} (Include an unsupported group in the client_shares vector, violating the requirement for corresponding groups in the ""supported_groups"" extension.)
```"
99,Offering Multiple KeyShareEntries,"Clients can offer multiple KeyShareEntry values for supported groups, but each value must be generated independently, and clients must not offer duplicates or invalid groups.",1,"<CMC> <1> (Clients MAY offer multiple KeyShareEntry values for supported groups, but each value MUST be generated independently.) + <SMP> <0> (Servers MUST verify that KeyShareEntry values are not duplicates or invalid groups.)  
<CMC> <1> (Clients MUST NOT offer duplicates or invalid groups in KeyShareEntry values.) + <SMP> <0> (Servers MUST reject KeyShareEntry values that are duplicates or invalid groups.)","<CMC> <1> (Clients MAY offer multiple KeyShareEntry values for supported groups, but each value MUST be generated independently.) + <SMP> <0> (Servers MUST verify that KeyShareEntry values are not duplicates or invalid groups.)","```markdown
{CMC} (Send a ClientHello with multiple KeyShareEntry values that are identical, violating the requirement for independent generation.)

{CMC} (Send a ClientHello with a KeyShareEntry that uses an unsupported group, which the server cannot verify.)

{CMC} (Send a ClientHello where the KeyShareEntry values are out of order, which disrupts the expected structure of the message.)
```"
,,,,,<CMC> <1> (Clients MUST NOT offer duplicates or invalid groups in KeyShareEntry values.) + <SMP> <0> (Servers MUST reject KeyShareEntry values that are duplicates or invalid groups.),"```markdown
{CMC} (Include multiple identical KeyShareEntry values in the ClientHello message.)

{CMC} (Offer a KeyShareEntry with a group value that is not supported by the server, such as a non-existent group ID.)

{CMC} (Send a ClientHello with an empty KeyShareExtension, violating the requirement to provide at least one KeyShareEntry.)
```"
100,HelloRetryRequest Handling,"In a HelloRetryRequest, the ""extension_data"" contains a KeyShareHelloRetryRequest value indicating the mutually supported group for negotiation. The client must verify that the selected group is valid before retrying.",1,<CMC> <1> (Clients MUST verify that the selected group in the KeyShareHelloRetryRequest is valid before retrying.) + <SMP> <0> (Servers MUST accept the KeyShareHelloRetryRequest containing a valid group for negotiation.),<CMC> <1> (Clients MUST verify that the selected group in the KeyShareHelloRetryRequest is valid before retrying.) + <SMP> <0> (Servers MUST accept the KeyShareHelloRetryRequest containing a valid group for negotiation.),"```markdown
{CMC} (Send a KeyShareHelloRetryRequest with an invalid group that the client has not verified.)

{CMC} (Omit the KeyShareHelloRetryRequest entirely after receiving a HelloRetryRequest from the server.)

{CMC} (Alter the KeyShareHelloRetryRequest to include a group not supported by the client's algorithm preferences.)
```"
101,ServerHello Key Share Data,"In a ServerHello message, the ""extension_data"" includes a KeyShareServerHello value, which consists of a single KeyShareEntry that matches the client's selected group.",0,Skip,Skip,Skip
102,Validation of Key Share in ServerHello,Servers must verify that the KeyShareEntry aligns with the client's supported groups and must not send entries for unsupported groups or in incompatible modes.,1,"<SMC> <1> (Servers MUST verify that the KeyShareEntry aligns with the client's supported groups.) + <CMP> <1> (Clients MUST ensure that supported groups are included in the KeyShareEntry.)  
<SMC> <1> (Servers MUST NOT send KeyShareEntry for unsupported groups.) + <CMP> <0> (Clients MUST process only KeyShareEntries that are for supported groups.)  
<SMC> <1> (Servers MUST NOT send KeyShareEntry in incompatible modes.) + <CMP> <0> (Clients MUST reject any KeyShareEntry that is in an incompatible mode.)  ",<SMC> <1> (Servers MUST verify that the KeyShareEntry aligns with the client's supported groups.) + <CMP> <1> (Clients MUST ensure that supported groups are included in the KeyShareEntry.),"```markdown
{CMC} (Send a ClientHello with a KeyShareEntry that includes a group not listed in the supported groups.)
{CMC} (Send a ClientHello with an empty KeyShareEntry, violating the requirement to include supported groups.)
{CMC} (Send a ClientHello with multiple KeyShareEntries including duplicates of unsupported groups.)
```"
,,,,,<SMC> <1> (Servers MUST NOT send KeyShareEntry for unsupported groups.) + <CMP> <0> (Clients MUST process only KeyShareEntries that are for supported groups.),"```markdown
{CMC} (Send a ClientHello that includes a KeyShareEntry for an unsupported group, violating the server's requirement to not send such entries.)
{CMC} (Send a ClientHello with multiple KeyShareEntries, where one entry has an invalid format, violating the specification for KeyShare construction.)
```"
,,,,,<SMC> <1> (Servers MUST NOT send KeyShareEntry in incompatible modes.) + <CMP> <0> (Clients MUST reject any KeyShareEntry that is in an incompatible mode.),"```markdown
{CMC} (Send a KeyShareEntry with a group that is not supported by the server, thereby violating compatibility rules.)

{CMC} (Include multiple KeyShareEntries for the same group in the ClientHello, which is not permitted.)

{CMC} (Send a KeyShareEntry that uses an invalid key format, failing to adhere to the expected structure defined in RFC 8446.)
```"
103,Diffie-Hellman Parameter Encoding,"Diffie-Hellman parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure. The opaque value contains the Diffie-Hellman public value (Y = g^X mod p) for the specified group, encoded as a big-endian integer and padded to the left with zeros to the size of p in bytes.",0,Skip,Skip,Skip
104,Public Key Padding,"For a given Diffie-Hellman group, the padding results in all public keys having the same length.",0,Skip,Skip,Skip
105,Public Key Validation,Peers must validate each other's public key Y by ensuring that 1 < Y < p-1. This check ensures that the remote peer is properly behaved and isn't forcing the local system into a small subgroup.,1,<CMC> <1> (Clients MUST validate the public key Y by ensuring that 1 < Y < p-1.) + <SMP> <0> (Servers MUST be properly behaved and not force the local system into a small subgroup.),<CMC> <1> (Clients MUST validate the public key Y by ensuring that 1 < Y < p-1.) + <SMP> <0> (Servers MUST be properly behaved and not force the local system into a small subgroup.),"```markdown
{CMC} (Send a ClientHello message with a public key Y that is less than or equal to 1 or greater than or equal to p-1, violating the key validation requirement.)

{CMC} (Include a public key Y that is randomly generated but does not correspond to a valid group, resulting in an invalid key structure.)

{CMC} (Omit the public key Y from the ClientHello message entirely, violating the requirement to include a valid key.)
```"
106,Key Share ECDHE Parameters,ECDHE parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure.,0,Skip,Skip,Skip
107,Uncompressed Point Representation Structure,"For secp256r1, secp384r1, and secp521r1, the contents are the serialized value of the UncompressedPointRepresentation struct, which includes a legacy_form and the binary representations of the x and y values.",0,Skip,Skip,Skip
108,Binary Representation Details,"X and Y are the binary representations of the x and y values in network byte order, with each representation occupying octets as specified by the curve parameters. For P-256, each uses 32 octets; for P-384, 48 octets; and for P-521, 66 octets.",0,Skip,Skip,Skip
109,Validation of Public Values,"Peers must validate each other's public value Q by ensuring it is a valid point on the elliptic curve, following the procedures outlined in Section 4.3.7 of [ECDSA] and Section 5.6.2.3 of [KEYAGREEMENT]. This includes verifying that Q is not the point at infinity, that x and y are in the correct interval, and that (x, y) satisfies the elliptic curve equation.",1,"```markdown
<CMP> <1> (Clients MUST validate each other's public value Q is a valid point on the elliptic curve according to specified procedures.) + <SMP> <1> (Servers MUST ensure that the public value Q is a valid point on the elliptic curve following the same procedures.)
```",<CMP> <1> (Clients MUST validate each other's public value Q is a valid point on the elliptic curve according to specified procedures.) + <SMP> <1> (Servers MUST ensure that the public value Q is a valid point on the elliptic curve following the same procedures.),"```markdown
{CMC} (Send a ClientHello with an invalid public value Q that does not correspond to any point on the specified elliptic curve.)

{CMC} (Send a ClientHello where the public value Q is a randomly generated byte string that does not adhere to the expected format of the elliptic curve point.)

{CMC} (Send a ClientHello with the public value Q omitted entirely, violating the requirement to send a valid public key.)
```"
110,Public Values for X25519 and X448,"For X25519 and X448, the public value consists of the byte string inputs and outputs defined in [RFC7748]: 32 bytes for X25519 and 56 bytes for X448.",0,Skip,Skip,Skip
111,Point Format Negotiation in TLS,"TLS versions prior to 1.3 allowed point format negotiation, but TLS 1.3 removes this feature, specifying a single point format for each curve.",0,Skip,Skip,Skip
112,PSK Key Exchange Modes Requirement,"In order to use PSKs, clients must send a ""psk_key_exchange_modes"" extension, indicating the supported modes. This restricts both the PSKs offered in the ClientHello and those the server might supply via NewSessionTicket.",1,"<CMC> <1> (Clients MUST send a ""psk_key_exchange_modes"" extension indicating supported modes to use PSKs.) + <SMP> <1> (Servers MUST restrict PSKs offered in the ClientHello and those supplied via NewSessionTicket based on the modes indicated by the client.)","<CMC> <1> (Clients MUST send a ""psk_key_exchange_modes"" extension indicating supported modes to use PSKs.) + <SMP> <1> (Servers MUST restrict PSKs offered in the ClientHello and those supplied via NewSessionTicket based on the modes indicated by the client.)","```markdown
{CMC} (Send a ClientHello without the ""psk_key_exchange_modes"" extension, violating the requirement to indicate supported modes for PSKs.)

{CMC} (Include an invalid or unsupported value in the ""psk_key_exchange_modes"" extension, violating the specification on supported modes.)

{CMC} (Send a ClientHello with multiple conflicting ""psk_key_exchange_modes"" extensions, which creates ambiguity in the supported modes.)
```"
113,Mandatory Extension for Pre-Shared Key,"A client must provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension. If a client offers ""pre_shared_key"" without this extension, servers must abort the handshake.",1,"<CMC> <1> (Clients MUST provide a ""psk_key_exchange_modes"" extension if offering a ""pre_shared_key"" extension.) + <SMP> <1> (Servers MUST abort the handshake if a client offers ""pre_shared_key"" without the ""psk_key_exchange_modes"" extension.)","<CMC> <1> (Clients MUST provide a ""psk_key_exchange_modes"" extension if offering a ""pre_shared_key"" extension.) + <SMP> <1> (Servers MUST abort the handshake if a client offers ""pre_shared_key"" without the ""psk_key_exchange_modes"" extension.)","```markdown
{CMC} (Send a ClientHello message with a ""pre_shared_key"" extension but omit the required ""psk_key_exchange_modes"" extension.)

{CMC} (Send a ClientHello message with an invalid or unrecognized ""psk_key_exchange_modes"" extension while including the ""pre_shared_key"" extension.)

{CMC} (Send a ClientHello message with multiple ""psk_key_exchange_modes"" extensions that conflict with each other while including the ""pre_shared_key"" extension.)
```"
114,Server Mode Selection Restriction,"Servers must not select a key exchange mode not listed by the client. This extension also restricts modes for PSK resumption, and servers should not send NewSessionTicket with incompatible tickets, or else client resumption attempts will fail.",1,"<SMC> <1> (Servers MUST NOT select a key exchange mode not listed by the client.) + <CMP> <1> (Clients MUST ensure that the selected key exchange mode is listed by the server.)  
<SMC> <1> (Servers SHOULD NOT send NewSessionTicket with incompatible tickets.) + <CMP> <1> (Clients MUST verify that the NewSessionTicket received is compatible for successful resumption.)",<SMC> <1> (Servers MUST NOT select a key exchange mode not listed by the client.) + <CMP> <1> (Clients MUST ensure that the selected key exchange mode is listed by the server.),"```markdown
{CMC} (Send a ClientHello message that requests a key exchange mode not supported by the server, violating the requirement that clients must select from offered modes.)

{CMC} (Send a ClientHello message with an empty ""supported key exchange modes"" list, which does not conform to the specification requiring at least one mode.)

{CMC} (Send a ClientHello message that includes a key exchange mode with an invalid format or value, violating RFC 8446's specification on valid key exchanges.)
```"
,,,,,<SMC> <1> (Servers SHOULD NOT send NewSessionTicket with incompatible tickets.) + <CMP> <1> (Clients MUST verify that the NewSessionTicket received is compatible for successful resumption.),"```markdown
{CMC} (Send a NewSessionTicket message with an incompatible ticket, violating the expectation of compatibility for session resumption.)
{CMC} (Omit the ticket length field in the NewSessionTicket message, leading to ambiguity in processing.)
{CMC} (Include an invalid session ID in the NewSessionTicket message, which clients will fail to verify against their stored sessions.)
```"
115,"Prohibition of Server ""psk_key_exchange_modes""","The server must not send a ""psk_key_exchange_modes"" extension.",1,"<SMC> <1> (Servers MUST NOT send a ""psk_key_exchange_modes"" extension.) + <CMP> <0> (Clients MUST accept that the server does not send a ""psk_key_exchange_modes"" extension.)","<SMC> <1> (Servers MUST NOT send a ""psk_key_exchange_modes"" extension.) + <CMP> <0> (Clients MUST accept that the server does not send a ""psk_key_exchange_modes"" extension.)","```markdown
{CMC} (Send a ClientHello message that includes a ""psk_key_exchange_modes"" extension but is incompatible with the server's supported modes.)

{CMC} (Send a ClientHello message with an excessively long ""psk_key_exchange_modes"" extension that exceeds the maximum length defined in the RFC.)

{CMC} (Send a ClientHello message with invalid data types in the ""psk_key_exchange_modes"" extension, such as strings instead of the required numerical values.)
```"
116,Definition of PSK Key Exchange Modes,"The enum defines two modes: psk_ke for PSK-only key establishment, where the server must not supply a ""key_share"" value, and psk_dhe_ke for PSK with (EC)DHE key establishment, where both parties must supply ""key_share"" values.",1,"<SMC> <1> (Servers MUST NOT supply a ""key_share"" value in psk_ke mode.) + <CMP> <1> (Clients MUST supply a ""key_share"" value in psk_dhe_ke mode.)  
<SMC> <1> (Servers MUST supply a ""key_share"" value in psk_dhe_ke mode.) + <CMP> <1> (Clients MUST supply a ""key_share"" value in psk_dhe_ke mode.)  ","<SMC> <1> (Servers MUST NOT supply a ""key_share"" value in psk_ke mode.) + <CMP> <1> (Clients MUST supply a ""key_share"" value in psk_dhe_ke mode.)","```markdown
{CMC} (Send a ClientHello without a ""key_share"" value while using psk_dhe_ke mode.)
{CMC} (Include multiple ""key_share"" values in the ClientHello when only one is expected in psk_dhe_ke mode.)
{CMC} (Send a ClientHello with an invalid ""key_share"" value that does not match any supported group in psk_dhe_ke mode.)
```"
,,,,,"<SMC> <1> (Servers MUST supply a ""key_share"" value in psk_dhe_ke mode.) + <CMP> <1> (Clients MUST supply a ""key_share"" value in psk_dhe_ke mode.)","```markdown
{CMC} (Send a ClientHello without a ""key_share"" value in psk_dhe_ke mode.)  
{CMC} (Send a ClientHello with an invalid ""key_share"" value that does not match any of the supported groups.)  
{CMC} (Send a ClientHello with multiple ""key_share"" values for the same group, violating the uniqueness constraint.)  
```"
117,Future Protocol Indications,"Future values must ensure that protocol messages unambiguously identify the selected mode by the presence of ""key_share"" in the ServerHello.",1,"<SMC> <1> (Servers MUST ensure that protocol messages unambiguously identify the selected mode by including ""key_share"" in the ServerHello.) + <CMP> <0> (Clients MUST verify the presence of ""key_share"" in the ServerHello to identify the selected mode.)","<SMC> <1> (Servers MUST ensure that protocol messages unambiguously identify the selected mode by including ""key_share"" in the ServerHello.) + <CMP> <0> (Clients MUST verify the presence of ""key_share"" in the ServerHello to identify the selected mode.)","```markdown
{CMC} (Send a ClientHello without including the ""key_share"" extension, violating the requirement for mode identification in the ServerHello.)

{CMC} (Send a ClientHello with an invalid ""key_share"" extension format, which does not conform to the expected structure.)

{CMC} (Send a ClientHello that includes multiple ""key_share"" extensions with conflicting values, leading to ambiguity in mode selection.)
```"
118,Early Data with PSK,"When a PSK is used and early data is allowed, the client can send Application Data in its first flight of messages, supplying both the ""pre_shared_key"" and ""early_data"" extensions.",0,Skip,Skip,Skip
119,Early Data Indication Structure,"The ""extension_data"" field contains an ""EarlyDataIndication"" value, with a specific structure dependent on the handshake message type.",0,Skip,Skip,Skip
120,Max Early Data Size,Details regarding the use of the max_early_data_size field are specified in Section 4.6.1.,0,Skip,Skip,Skip
121,PSK and Associated Parameters,"The parameters for 0-RTT data, such as version and cipher suite, are linked to the PSK in use, either provisioned or negotiated during the connection.",0,Skip,Skip,Skip
122,Ticket Age Validation,"For PSKs from NewSessionTicket, the server must validate the ticket age against the time since issuance, rejecting 0-RTT if it fails.",1,<SMC> <1> (Servers MUST validate the ticket age against the time since issuance for PSKs from NewSessionTicket.) + <CMP> <1> (Clients MUST abort 0-RTT if the ticket age validation fails.),<SMC> <1> (Servers MUST validate the ticket age against the time since issuance for PSKs from NewSessionTicket.) + <CMP> <1> (Clients MUST abort 0-RTT if the ticket age validation fails.),"```markdown
{CMC} (Send a ClientHello with a 0-RTT request using a pre-shared key (PSK) that has an invalid ticket age, bypassing the validation check.)

{CMC} (Include a 0-RTT message in the ClientHello without first sending a valid NewSessionTicket.)

{CMC} (Send a ClientHello that specifies a PSK but omits the ticket age, thereby failing to provide necessary information for validation.)
```"
123,0-RTT Message Structure,"0-RTT messages share encrypted content types with other message types but use different keys, with an EndOfEarlyData message indicating key change.",0,Skip,Skip,Skip
124,Server Response to Early Data,"A server receiving an ""early_data"" extension may ignore it, request a new ClientHello, or accept it and process early data.",0,Skip,Skip,Skip
125,Requirements for Accepting Early Data,"To accept early data, the server must verify the TLS version, cipher suite, and ALPN protocol match those associated with the selected PSK.",1,"<SMC> <1> (Servers MUST verify the TLS version, cipher suite, and ALPN protocol to accept early data associated with the selected PSK.) + <CMP> <0> (Clients MUST ensure that the TLS version, cipher suite, and ALPN protocol match those associated with the selected PSK for early data acceptance.)","<SMC> <1> (Servers MUST verify the TLS version, cipher suite, and ALPN protocol to accept early data associated with the selected PSK.) + <CMP> <0> (Clients MUST ensure that the TLS version, cipher suite, and ALPN protocol match those associated with the selected PSK for early data acceptance.)","```markdown
{CMC} (Send a ClientHello with an unsupported TLS version that does not match the server's acceptable version for early data.)

{CMC} (Include a cipher suite in the ClientHello that is not compatible with the selected PSK, violating the requirement for matching cipher suites.)

{CMC} (Omit the ALPN extension from the ClientHello when early data is intended, thus failing to provide the necessary protocol information.)
```"
126,Handling Failed Checks,"If checks fail, the server must discard first-flight data and revert to 1-RTT or 2-RTT.",1,<SMC> <1> (Servers MUST discard first-flight data if checks fail.) + <CMP> <0> (Clients MUST revert to 1-RTT or 2-RTT if the server discards first-flight data.),<SMC> <1> (Servers MUST discard first-flight data if checks fail.) + <CMP> <0> (Clients MUST revert to 1-RTT or 2-RTT if the server discards first-flight data.),"```markdown
{CMC} (Send a ClientHello message with an invalid signature algorithm that the server does not support, which should cause the server to discard the message.)

{CMC} (Send a ClientHello message without the mandatory ""supported_versions"" extension, leading to potential ambiguity in the protocol version.)

{CMC} (Send a ClientHello message with an incorrectly formatted ""cipher_suites"" field that violates the expected structure, causing the server to reject the handshake.)
```"
127,Error Handling for Early Data,"If the server accepts early data but fails to decrypt records, it must terminate the connection with a ""bad_record_mac"" alert.",1,"<SMC> <1> (Servers MUST terminate the connection with a ""bad_record_mac"" alert if they accept early data but fail to decrypt records.) + <SMP> <1> (Servers MUST accept early data before attempting to decrypt records.)","<SMC> <1> (Servers MUST terminate the connection with a ""bad_record_mac"" alert if they accept early data but fail to decrypt records.) + <SMP> <1> (Servers MUST accept early data before attempting to decrypt records.)","```markdown
{CMC} (Send a ClientHello with an unsupported early data extension that the server cannot process.)
{CMC} (Send a ClientHello containing an invalid ""early_data"" flag that violates the expected format.)
{CMC} (Send a ClientHello with an empty ""early_data"" field, which must contain valid data according to the specifications.)
```"
128,Client Behavior on Rejection,"If the server rejects the ""early_data"" extension, the client may retransmit Application Data after the handshake, but must consider the connection state.",1,"<CMC> <1> (Clients may retransmit Application Data after the handshake if the server rejects the ""early_data"" extension.) + <SMP> <0> (Servers must reject the ""early_data"" extension if not allowed, impacting the client's connection state considerations.)","<CMC> <1> (Clients may retransmit Application Data after the handshake if the server rejects the ""early_data"" extension.) + <SMP> <0> (Servers must reject the ""early_data"" extension if not allowed, impacting the client's connection state considerations.)","```markdown
{CMC} (Send a ClientHello with the ""early_data"" extension set to a value outside the defined range, violating the expected format.)

{CMC} (Include the ""early_data"" extension in the ClientHello without the necessary preceding ""SupportedVersion"" negotiation steps.)

{CMC} (Omit the required ""CipherSuites"" field from the ClientHello while including the ""early_data"" extension.)
```"
129,Guidance for TLS Implementations,A TLS implementation should not automatically resend early data; applications should decide when retransmission is appropriate.,0,Skip,Skip,Skip
130,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip,Skip
131,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip,Skip
132,PSK Binder Purpose,"The PSK binder value forms a binding between a PSK and the current handshake, as well as a binding between the handshake in which the PSK was generated and the current handshake.",0,Skip,Skip,Skip
133,Binder Computation Method,"Each entry in the binders list is computed as an HMAC over a transcript hash containing a partial ClientHello up to and including the PreSharedKeyExtension.identities field, excluding the binders list itself.",0,Skip,Skip,Skip
134,Message Length Fields,"The length fields for the message are set as if binders of the correct lengths were present, including overall length, extensions block length, and the ""pre_shared_key"" extension length.",0,Skip,Skip,Skip
135,PskBinderEntry Computation,"The PskBinderEntry is computed similarly to the Finished message, using the binder_key derived from the corresponding PSK offered.",0,Skip,Skip,Skip
136,Handling HelloRetryRequest,"If the handshake includes a HelloRetryRequest, the initial ClientHello and HelloRetryRequest are included in the transcript along with the new ClientHello, affecting binder computation.",0,Skip,Skip,Skip
137,Transcript Hash Examples,"For ClientHello1, its binder is computed over the truncated ClientHello; for ClientHello2 after a HelloRetryRequest, the binder includes the initial ClientHello, HelloRetryRequest, and the truncated new ClientHello.",0,Skip,Skip,Skip
138,Hash Computation Details,"In the first flight, Truncate(ClientHello1) is hashed directly, while in the second flight, ClientHello1 is hashed and reinjected as a ""message_hash"" message.",0,Skip,Skip,Skip
139,0-RTT Data Streaming,"Clients are permitted to ""stream"" 0-RTT data until they receive the server's Finished, only then sending the EndOfEarlyData message, followed by the rest of the handshake.",0,Skip,Skip,Skip
140,Server Processing of Early Data,"To avoid deadlocks, when accepting ""early_data"", servers must process the client's ClientHello and then immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending its ServerHello.",1,"<SMC> <1> (Servers MUST process the client's ClientHello and then immediately send their flight of messages when accepting ""early_data"".) + <CMP> <1> (Clients MUST send an EndOfEarlyData message after sending early data.)","<SMC> <1> (Servers MUST process the client's ClientHello and then immediately send their flight of messages when accepting ""early_data"".) + <CMP> <1> (Clients MUST send an EndOfEarlyData message after sending early data.)","```markdown
{CMC} (Send a ClientHello without the ""early_data"" flag when early data is expected by the server.)  
{CMC} (Omit the EndOfEarlyData message entirely after sending early data, violating the expected sequence.)  
{CMC} (Include multiple ClientHello messages in a single handshake, disrupting the expected processing flow of the server.)  
```"
141,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip,Skip
142,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip,Skip
143,Certificate Request Purpose,"A server which is authenticating with a certificate may optionally request a certificate from the client. This message, if sent, must follow EncryptedExtensions.",1,"<SMC> <1> (Servers MAY optionally request a certificate from the client if they are authenticating with a certificate.) + <CMP> <1> (Clients MUST respond with their certificate if requested by the server, and this message MUST follow EncryptedExtensions.)","<SMC> <1> (Servers MAY optionally request a certificate from the client if they are authenticating with a certificate.) + <CMP> <1> (Clients MUST respond with their certificate if requested by the server, and this message MUST follow EncryptedExtensions.)","```markdown
{CMC} (Send a ClientHello message that does not include the ""encrypted_extensions"" field, thus violating the expected order of the handshake.)

{CMC} (Include an invalid certificate format in the Certificate message that follows EncryptedExtensions, thus violating the certificate requirements.)

{CMC} (Omit the Certificate message entirely when the server has requested it, violating the mandatory response requirement.)
```"
144,CertificateRequest Structure,The structure of this message includes a certificate_request_context and a set of extensions.,0,Skip,Skip,Skip
145,certificate_request_context Details,"The certificate_request_context is an opaque string identifying the certificate request, which must be unique within the scope of the connection to prevent replay of client CertificateVerify messages. It shall be zero length unless used for post-handshake authentication, where it should be made unpredictable to prevent pre-computation of valid CertificateVerify messages.",1,"<CMP> <1> (Clients MUST ensure the certificate_request_context is unique within the scope of the connection to prevent replay of CertificateVerify messages.) + <SMC> <0> (Servers MUST validate that the certificate_request_context is unique within the connection to prevent replay of CertificateVerify messages.)
<CMP> <1> (Clients SHALL use a zero-length certificate_request_context unless it's for post-handshake authentication.) + <SMC> <0> (Servers MUST accept a zero-length certificate_request_context unless it's for post-handshake authentication.)
<CMP> <1> (Clients MUST make the certificate_request_context unpredictable for post-handshake authentication.) + <SMC> <0> (Servers MUST verify the unpredictability of the certificate_request_context during post-handshake authentication.)",<CMP> <1> (Clients MUST ensure the certificate_request_context is unique within the scope of the connection to prevent replay of CertificateVerify messages.) + <SMC> <0> (Servers MUST validate that the certificate_request_context is unique within the connection to prevent replay of CertificateVerify messages.),"```markdown
{CMC} (Send a ClientHello with a certificate_request_context that is a duplicate of a previously used value within the same connection.)

{CMC} (Omit the certificate_request_context field entirely from the ClientHello message, violating the uniqueness requirement.)

{CMC} (Send a ClientHello with a malformed certificate_request_context that exceeds the maximum length specified in the TLS 1.3 RFC.)
```"
,,,,,<CMP> <1> (Clients SHALL use a zero-length certificate_request_context unless it's for post-handshake authentication.) + <SMC> <0> (Servers MUST accept a zero-length certificate_request_context unless it's for post-handshake authentication.),"```markdown
{CMC} (Send a ClientHello with a non-zero-length certificate_request_context when no post-handshake authentication is requested)

{CMC} (Send a ClientHello with an invalid or malformed certificate_request_context field)

{CMC} (Omit the certificate_request_context field entirely from the ClientHello message when it is expected)
```"
,,,,,<CMP> <1> (Clients MUST make the certificate_request_context unpredictable for post-handshake authentication.) + <SMC> <0> (Servers MUST verify the unpredictability of the certificate_request_context during post-handshake authentication.),"```markdown
{CMC} (Send a fixed, predictable certificate_request_context value in the ClientHello, violating the unpredictability requirement.)

{CMC} (Omit the certificate_request_context field entirely from the ClientHello, making it impossible for the server to verify unpredictability.)
```"
146,Extensions Specification,"The extensions describe the parameters of the requested certificate, with the ""signature_algorithms"" extension being mandatory. Clients must ignore unrecognized extensions.",1,"<CMC> <1> (Clients MUST include the ""signature_algorithms"" extension as it is mandatory.) + <SMP> <0> (Servers MUST accept the ""signature_algorithms"" extension as it is mandatory.)
<CMC> <1> (Clients MUST ignore unrecognized extensions.) + <SMP> <0> (Servers MUST not process unrecognized extensions sent by clients.)","<CMC> <1> (Clients MUST include the ""signature_algorithms"" extension as it is mandatory.) + <SMP> <0> (Servers MUST accept the ""signature_algorithms"" extension as it is mandatory.)","```markdown
{CMC} (Send a ClientHello message without the ""signature_algorithms"" extension.)

{CMC} (Include an invalid ""signature_algorithms"" extension value that does not conform to the supported algorithms.)

{CMC} (Send a ClientHello with the ""signature_algorithms"" extension but with a length field that is incorrectly set, causing the value to be truncated.)
```"
,,,,,<CMC> <1> (Clients MUST ignore unrecognized extensions.) + <SMP> <0> (Servers MUST not process unrecognized extensions sent by clients.),"```markdown
{CMC} (Include an unrecognized extension in the ClientHello message that exceeds the maximum allowed length specified in RFC 8446.)

{CMC} (Omit the mandatory ""Supported Versions"" extension from the ClientHello message to test server response to missing critical extensions.)

{CMC} (Send a ClientHello message with an invalid format for the ""Cipher Suites"" field, such as non-existent or malformed cipher identifiers.)
```"
147,Changes in TLS 1.3,"In TLS 1.3, the CertificateRequest message expresses acceptable signature algorithms and certificate authorities through specific extensions, differing from prior versions.",0,Skip,Skip,Skip
148,PSK Authentication Constraints,"Servers authenticating with a PSK must not send the CertificateRequest message in the main handshake but may do so in post-handshake authentication if the client has sent the ""post_handshake_auth"" extension.",1,"<SMC> <1> (Servers MUST NOT send the CertificateRequest message in the main handshake when authenticating with a PSK.) + <CMP> <1> (Clients MAY receive a CertificateRequest message during post-handshake authentication if the ""post_handshake_auth"" extension was sent.)","<SMC> <1> (Servers MUST NOT send the CertificateRequest message in the main handshake when authenticating with a PSK.) + <CMP> <1> (Clients MAY receive a CertificateRequest message during post-handshake authentication if the ""post_handshake_auth"" extension was sent.)","```markdown
{CMC} (Send a ClientHello message without the required ""psk_key_exchange_modes"" extension when a PSK is expected.)

{CMC} (Include unsupported cipher suites in the ClientHello message while a CertificateRequest is anticipated.)

{CMC} (Send a ClientHello message with an invalid ""post_handshake_auth"" extension that does not conform to the expected format.)
```"
149,Authentication Messages Overview,"TLS generally uses a common set of messages for authentication, key confirmation, and handshake integrity: Certificate, CertificateVerify, and Finished. These messages are always sent as the last messages in their handshake flight.",0,Skip,Skip,Skip
150,Message Encryption,These messages are encrypted under keys derived from the sender's handshake traffic secret.,0,Skip,Skip,Skip
151,Input Computations for Authentication Messages,"The computations for the Authentication messages take the certificate and signing key, a Handshake Context consisting of the set of messages for the transcript hash, and a Base Key for computing a MAC key.",0,Skip,Skip,Skip
152,Certificate Message Details,The Certificate message includes the certificate for authentication and any supporting certificates in the chain. Note that certificate-based client authentication is not available in PSK handshake flows (including 0-RTT).,0,Skip,Skip,Skip
153,CertificateVerify Message Details,"The CertificateVerify message contains a signature over the value Transcript-Hash(Handshake Context, Certificate).",0,Skip,Skip,Skip
154,Finished Message Details,"The Finished message includes a MAC over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using a MAC key derived from the Base Key.",0,Skip,Skip,Skip
155,Handshake Context and MAC Base Key Definitions,"The table defines the Handshake Context and MAC Base Key for each scenario, including modes for Server, Client, and Post-Handshake.",0,Skip,Skip,Skip
156,Transcript Hash Purpose,"Many of the cryptographic computations in TLS make use of a transcript hash, computed by hashing the concatenation of each included handshake message, including the message header but not record layer headers.",0,Skip,Skip,Skip
157,Transcript Hash Computation,"The transcript hash is computed as Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn).",0,Skip,Skip,Skip
158,Handling HelloRetryRequest,"When the server responds to a ClientHello with a HelloRetryRequest, ClientHello1 is replaced with a synthetic handshake message of type ""message_hash"" containing Hash(ClientHello1).",0,Skip,Skip,Skip
159,Stateless HelloRetryRequest Explanation,"This construction allows the server to perform a stateless HelloRetryRequest by storing just the hash of ClientHello1 in the cookie, avoiding the need to export the entire intermediate hash state.",0,Skip,Skip,Skip
160,Sequence of Handshake Messages,"The transcript hash is taken from a specific sequence of handshake messages, starting at the first ClientHello and including messages such as ServerHello and client Finished.",0,Skip,Skip,Skip
161,Implementation Note,"Implementations can keep a running transcript hash value based on the negotiated hash, noting that post-handshake authentications do not include each other.",0,Skip,Skip,Skip
162,Error,Error: Sending request HandleBotLandingPageQuery failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip,Skip
163,OCSP Response Negotiation,"RFC6066 and RFC6961 provide extensions to negotiate the server sending OCSP responses to the client. In TLS 1.2 and below, the server replies with an empty extension to indicate negotiation of this extension, and the OCSP information is carried in a CertificateStatus message. In TLS 1.3, the server's OCSP information is carried in an extension in the CertificateEntry containing the associated certificate.",0,Skip,Skip,Skip
164,CertificateStatus Structure,"Specifically, the body of the ""status_request"" extension from the server MUST be a CertificateStatus structure as defined in RFC6066, which is interpreted as defined in RFC6960.",1,"<SMC> <1> (Servers MUST include a CertificateStatus structure in the body of the ""status_request"" extension.) + <CMP> <1> (Clients MUST interpret the CertificateStatus structure as defined in RFC6960.)","<SMC> <1> (Servers MUST include a CertificateStatus structure in the body of the ""status_request"" extension.) + <CMP> <1> (Clients MUST interpret the CertificateStatus structure as defined in RFC6960.)","```markdown
{CMC} (Send a ClientHello without the ""status_request"" extension, which is required for CertificateStatus inclusion.)
{CMC} (Include a malformed ""status_request"" extension in the ClientHello that does not conform to the expected structure defined in RFC 8446.)
{CMC} (Send a ClientHello with an empty or null CertificateStatus structure in the ""status_request"" extension.)
```"
165,Deprecation of status_request_v2,"The status_request_v2 extension [RFC6961] is deprecated. TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients that wish to use it in earlier protocol versions.",1,"<SMC> <1> (Servers MUST NOT act upon the presence of the status_request_v2 extension in ClientHello messages.) + <CMP> <1> (Clients MAY send the status_request_v2 extension in ClientHello messages for earlier protocol versions.)  
<SMC> <1> (Servers MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.) + <CMP> <1> (Clients MAY include the status_request_v2 extension in ClientHello messages.)  
<SMC> <1> (Servers MUST be able to process ClientHello messages that include the status_request_v2 extension.) + <CMP> <1> (Clients MAY send the status_request_v2 extension in ClientHello messages for earlier protocol versions.)  ",<SMC> <1> (Servers MUST NOT act upon the presence of the status_request_v2 extension in ClientHello messages.) + <CMP> <1> (Clients MAY send the status_request_v2 extension in ClientHello messages for earlier protocol versions.),"```markdown
{CMC} (Send a ClientHello message with a malformed status_request_v2 extension that includes an invalid or unexpected format.)

{CMC} (Send a ClientHello message that contains multiple conflicting status_request_v2 extensions.)

{CMC} (Send a ClientHello message with the status_request_v2 extension but omit the required extension data field.)
```"
,,,,,"<SMC> <1> (Servers MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.) + <CMP> <1> (Clients MAY include the status_request_v2 extension in ClientHello messages.)","```markdown
{CMC} (Include the status_request_v2 extension in the ClientHello message while omitting the required ""extensions"" length field.)
{CMC} (Send a ClientHello message with the status_request_v2 extension containing invalid data types for the extension fields.)
{CMC} (Construct a ClientHello message where the status_request_v2 extension is repeated multiple times, violating the uniqueness requirement of extensions.)
```"
,,,,,<SMC> <1> (Servers MUST be able to process ClientHello messages that include the status_request_v2 extension.) + <CMP> <1> (Clients MAY send the status_request_v2 extension in ClientHello messages for earlier protocol versions.),"```markdown
{CMC} (Send a ClientHello message without the status_request_v2 extension, despite it being present in the server's supported extensions list.)

{CMC} (Send a malformed status_request_v2 extension in the ClientHello, containing invalid data that does not conform to the expected structure.)

{CMC} (Send a ClientHello message with the status_request_v2 extension but set to an unsupported version that the server cannot process.)
```"
166,Client OCSP Response Request,"A server MAY request that a client present an OCSP response with its certificate by sending an empty ""status_request"" extension in its CertificateRequest message. If the client opts to send an OCSP response, the body of its ""status_request"" extension MUST be a CertificateStatus structure as defined in RFC6066.",1,"<SMC> <1> (Servers MAY request that a client present an OCSP response by sending an empty ""status_request"" extension in the CertificateRequest message.) + <CMP> <1> (Clients MUST send a CertificateStatus structure in the body of its ""status_request"" extension if opting to send an OCSP response.)","<SMC> <1> (Servers MAY request that a client present an OCSP response by sending an empty ""status_request"" extension in the CertificateRequest message.) + <CMP> <1> (Clients MUST send a CertificateStatus structure in the body of its ""status_request"" extension if opting to send an OCSP response.)","```markdown
{CMC} (Send a CertificateStatus structure with an invalid format or size in the ""status_request"" extension, violating the expected structure.)

{CMC} (Omit the ""status_request"" extension entirely while still indicating an intent to provide an OCSP response in the Certificate message.)

{CMC} (Send a ""status_request"" extension with a non-existent or unsupported status type, contradicting the specification.)
```"
167,Signed Certificate Timestamp Mechanism,"Similarly, RFC6962 provides a mechanism for a server to send a Signed Certificate Timestamp (SCT) as an extension in the ServerHello in TLS 1.2 and below. In TLS 1.3, the server's SCT information is carried in an extension in the CertificateEntry.",0,Skip,Skip,Skip
168,Certificate Type Requirement,"The certificate type must be X.509v3, unless explicitly negotiated otherwise.",1,"<CMC> <1> (Clients MUST use X.509v3 certificate type, unless explicitly negotiated otherwise.) + <SMP> <0> (Servers MUST accept X.509v3 certificate type, unless explicitly negotiated otherwise.)","<CMC> <1> (Clients MUST use X.509v3 certificate type, unless explicitly negotiated otherwise.) + <SMP> <0> (Servers MUST accept X.509v3 certificate type, unless explicitly negotiated otherwise.)","```markdown
{CMC} (Send a ClientHello with an unsupported certificate type instead of X.509v3, such as a self-signed certificate.)

{CMC} (Omit the CertificateRequest message when the server has indicated it requires client authentication.)

{CMC} (Include a malformed certificate extension that exceeds the maximum allowed length, violating the structure specified in RFC 8446.)
```"
169,Key Compatibility,"The server's end-entity certificate's public key must be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension.",1,"<SMC> <1> (Servers' end-entity certificate's public key MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension.) + <CMP> <0> (Clients MUST select an authentication algorithm that is compatible with the server's end-entity certificate's public key.)","<SMC> <1> (Servers' end-entity certificate's public key MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension.) + <CMP> <0> (Clients MUST select an authentication algorithm that is compatible with the server's end-entity certificate's public key.)","```markdown
{CMC} (Send a ClientHello with a ""signature_algorithms"" extension that specifies an algorithm incompatible with the server's end-entity certificate public key.)

{CMC} (Omit the ""signature_algorithms"" extension from the ClientHello, leaving the server unable to determine a compatible authentication algorithm.)

{CMC} (Include a ""signature_algorithms"" extension with an empty list in the ClientHello, violating the requirement to select at least one algorithm.)
```"
170,Signing Capability,"The certificate must allow the key to be used for signing, indicated by the digitalSignature bit in the Key Usage extension.",1,"<CMC> <1> (Clients MUST ensure the certificate allows the key to be used for signing, indicated by the digitalSignature bit in the Key Usage extension.) + <SMP> <0> (Servers MUST verify that the certificate's key usage allows for signing as indicated by the digitalSignature bit.)","<CMC> <1> (Clients MUST ensure the certificate allows the key to be used for signing, indicated by the digitalSignature bit in the Key Usage extension.) + <SMP> <0> (Servers MUST verify that the certificate's key usage allows for signing as indicated by the digitalSignature bit.)","```markdown
{CMC} (Send a ClientHello with a certificate that has the digitalSignature bit set to 0 in the Key Usage extension.)

{CMC} (Send a ClientHello without a Key Usage extension in the certificate.)

{CMC} (Send a ClientHello with a certificate that includes an invalid or unsupported Key Usage extension.)
```"
171,Certificate Selection Guidance,"The ""server_name"" and ""certificate_authorities"" extensions guide certificate selection, with clients encouraged to send the ""server_name"" extension when applicable.",0,Skip,Skip,Skip
172,Signature Algorithm Validation,All certificates provided by the server must be signed by a signature algorithm advertised by the client if the client can provide such a chain.,1,<SMC> <1> (Servers MUST provide certificates signed by a signature algorithm advertised by the client if the client can provide such a chain.) + <CMP> <1> (Clients MUST ensure that the server's certificates are signed by an algorithm they have advertised.),<SMC> <1> (Servers MUST provide certificates signed by a signature algorithm advertised by the client if the client can provide such a chain.) + <CMP> <1> (Clients MUST ensure that the server's certificates are signed by an algorithm they have advertised.),"```markdown
{CMC} (Send a ClientHello that advertises unsupported signature algorithms, ensuring the server cannot match any during the certificate exchange.)

{CMC} (Omit the ""signature_algorithms"" field from the ClientHello, violating the requirement to advertise supported algorithms.)

{CMC} (Send a ClientHello with a malformed ""signature_algorithms"" extension that contains invalid or corrupted data.)
```"
173,Fallback Certificate Chain,"If the server cannot produce a valid certificate chain, it should send a fallback chain that may include unsupported algorithms, avoiding deprecated SHA-1 unless permitted by the client.",0,Skip,Skip,Skip
174,Client Response to Invalid Chain,"If the client cannot construct an acceptable chain and aborts the handshake, it must do so with an appropriate certificate-related alert.",1,<CMC> <1> (Clients MUST abort the handshake with an appropriate certificate-related alert if they cannot construct an acceptable chain.) + <SMP> <0> (Servers MUST be prepared to handle a certificate-related alert if the client aborts the handshake.),<CMC> <1> (Clients MUST abort the handshake with an appropriate certificate-related alert if they cannot construct an acceptable chain.) + <SMP> <0> (Servers MUST be prepared to handle a certificate-related alert if the client aborts the handshake.),"```markdown
{CMC} (Send a ClientHello message without including the required `supported_versions` extension, violating handshake requirements for acceptable version negotiation.)

{CMC} (Include a `certificate` field in the ClientHello but provide an unsupported or malformed certificate format, which cannot be processed correctly.)

{CMC} (Construct a ClientHello message that omits the `key_share` extension when using a cipher suite that requires it, leading to an incomplete handshake.)
```"
175,Multiple Certificate Selection,"If the server has multiple certificates, it selects one based on the defined criteria and additional factors like local configuration.",0,Skip,Skip,Skip
176,Client Certificate Type Requirement,"The certificate type must be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).",1,<CMC> <1> (Clients MUST use X.509v3 certificates unless explicitly negotiated otherwise.) + <SMP> <0> (Servers MUST accept X.509v3 certificates unless explicitly negotiated otherwise.),<CMC> <1> (Clients MUST use X.509v3 certificates unless explicitly negotiated otherwise.) + <SMP> <0> (Servers MUST accept X.509v3 certificates unless explicitly negotiated otherwise.),"```markdown
{CMC} (Send a ClientHello that includes a certificate of an unsupported format, such as a self-signed PEM certificate instead of an X.509v3 certificate.)

{CMC} (Include an empty certificate list in the ClientHello, violating the requirement to provide at least one valid X.509v3 certificate.)

{CMC} (Send a ClientHello with a malformed X.509v3 certificate that contains invalid fields or is incorrectly encoded.)
```"
177,Certificate Authority Issuance,"If the ""certificate_authorities"" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain should be issued by one of the listed CAs.",0,Skip,Skip,Skip
178,Signature Algorithm Compliance,"The certificates must be signed using an acceptable signature algorithm, as described in Section 4.3.2, which relaxes constraints on certificate-signing algorithms found in prior versions of TLS.",1,<SMC> <1> (Servers MUST ensure that certificates are signed using an acceptable signature algorithm as specified in Section 4.3.2.) + <CMP> <0> (Clients MUST send certificates signed with acceptable signature algorithms.),<SMC> <1> (Servers MUST ensure that certificates are signed using an acceptable signature algorithm as specified in Section 4.3.2.) + <CMP> <0> (Clients MUST send certificates signed with acceptable signature algorithms.),"```markdown
{CMC} (Send a ClientHello message with a certificate that is signed using an unsupported signature algorithm.)

{CMC} (Omit the certificate from the ClientHello message when one is required by the server.)

{CMC} (Send a ClientHello message where the certificate chain includes a self-signed certificate that is not trusted by the server.)
```"
179,OID Filters Matching,"If the CertificateRequest message contained a non-empty ""oid_filters"" extension, the end-entity certificate must match the extension OIDs recognized by the client, as described in Section 4.2.5.",1,"<CMC> <1> (Clients MUST ensure that the end-entity certificate matches the OIDs recognized by them if the ""oid_filters"" extension is non-empty in the CertificateRequest message.) + <SMP> <0> (Servers MUST include the ""oid_filters"" extension in the CertificateRequest message when applicable.)","<CMC> <1> (Clients MUST ensure that the end-entity certificate matches the OIDs recognized by them if the ""oid_filters"" extension is non-empty in the CertificateRequest message.) + <SMP> <0> (Servers MUST include the ""oid_filters"" extension in the CertificateRequest message when applicable.)","```markdown
{CMC} (Send a ClientHello without including any certificate despite the presence of a non-empty ""oid_filters"" extension in the CertificateRequest message.)

{CMC} (Send a ClientHello with an end-entity certificate that contains OIDs not recognized by the client, even when the ""oid_filters"" extension is non-empty.)

{CMC} (Send a ClientHello that includes an invalid or malformed ""oid_filters"" extension in the CertificateRequest message.)
```"
180,Certificate Validation Scope,"In general, detailed certificate validation procedures are out of scope for TLS. This section provides TLS-specific requirements.",0,Skip,Skip,Skip
181,Handling Empty Certificate Messages,"If the server supplies an empty Certificate message, the client must abort the handshake with a ""decode_error"" alert. If the client sends an empty Certificate message, the server may either continue the handshake or abort it with a ""certificate_required"" alert.",1,"<CMC> <1> (Clients MUST abort the handshake with a ""decode_error"" alert if the server supplies an empty Certificate message.) + <SMP> <1> (Servers MAY continue the handshake or abort it with a ""certificate_required"" alert if the client sends an empty Certificate message.)","<CMC> <1> (Clients MUST abort the handshake with a ""decode_error"" alert if the server supplies an empty Certificate message.) + <SMP> <1> (Servers MAY continue the handshake or abort it with a ""certificate_required"" alert if the client sends an empty Certificate message.)","```markdown
{CMC} (Send a ClientHello message that includes an invalid Cipher Suite not supported by TLS 1.3.)

{CMC} (Send a ClientHello message with an empty extensions field, violating the requirement for at least one valid extension.)

{CMC} (Send a ClientHello message without the mandatory supported_versions field, which is essential for a TLS 1.3 handshake.)
```"
182,Unacceptable Certificate Chains,"If any aspect of the certificate chain is unacceptable, the server may choose to continue the handshake as unauthenticated or abort it.",0,Skip,Skip,Skip
183,Aborting for MD5 and SHA-1 Certificates,"Any endpoint receiving a certificate that requires validation using MD5 must abort the handshake with a ""bad_certificate"" alert. SHA-1 is deprecated, and endpoints should also abort the handshake for SHA-1 validation.",1,"<CMC> <1> (Clients MUST abort the handshake with a ""bad_certificate"" alert if receiving a certificate requiring MD5 validation.) + <SMP> <1> (Servers MUST abort the handshake with a ""bad_certificate"" alert if receiving a certificate requiring MD5 validation.)  
<CMC> <1> (Clients MUST abort the handshake if receiving a certificate requiring SHA-1 validation.) + <SMP> <1> (Servers MUST abort the handshake if receiving a certificate requiring SHA-1 validation.)","<CMC> <1> (Clients MUST abort the handshake with a ""bad_certificate"" alert if receiving a certificate requiring MD5 validation.) + <SMP> <1> (Servers MUST abort the handshake with a ""bad_certificate"" alert if receiving a certificate requiring MD5 validation.)","```markdown
{CMC} (Send a ClientHello message with an MD5 hash function explicitly requested in the supported_signature_algorithms extension, which is invalid as per TLS 1.3 specifications.)

{CMC} (Include a certificate in the ClientHello that requires MD5 validation, deliberately ignoring the requirement to abort the handshake.)

{CMC} (Omit the ""supported_signature_algorithms"" extension from the ClientHello, despite it being mandatory for negotiation and validation.)
```"
,,,,,<CMC> <1> (Clients MUST abort the handshake if receiving a certificate requiring SHA-1 validation.) + <SMP> <1> (Servers MUST abort the handshake if receiving a certificate requiring SHA-1 validation.),"```markdown
{CMC} (Send a ClientHello message that includes a signature algorithm list that only supports SHA-1, violating the requirement to abort the handshake.)

{CMC} (Include an invalid certificate in the ClientHello message that explicitly requires SHA-1 validation, despite the handshake's security requirements.)

{CMC} (Omit the Server Name Indication (SNI) extension in the ClientHello message when SHA-1 certificates are expected, leading to a potential mismatch.)
```"
184,Recommendation for SHA-256 Transition,All endpoints are recommended to transition to SHA-256 or better to maintain interoperability with implementations phasing out SHA-1 support.,0,Skip,Skip,Skip
185,Signature Algorithm Variability,A certificate containing a key for one signature algorithm may be signed using a different signature algorithm.,0,Skip,Skip,Skip
186,Purpose of CertificateVerify Message,This message is used to provide explicit proof that an endpoint possesses the private key corresponding to its certificate and ensures integrity for the handshake up to this point. Servers and clients must send this message when authenticating via a certificate.,1,"```markdown
<CMC> <1> (Clients MUST send a message to provide proof of possession of the private key corresponding to its certificate.) + <SMP> <1> (Servers MUST send a message to provide proof of possession of the private key corresponding to its certificate.)
<CMC> <1> (Clients MUST ensure integrity for the handshake up to this point.) + <SMP> <1> (Servers MUST ensure integrity for the handshake up to this point.)
```",<CMC> <1> (Clients MUST send a message to provide proof of possession of the private key corresponding to its certificate.) + <SMP> <1> (Servers MUST send a message to provide proof of possession of the private key corresponding to its certificate.),"```markdown
{CMC} (Send a ClientHello message without the required key share indicating proof of possession of the private key.)

{CMC} (Include an invalid key share in the ClientHello that does not match the corresponding public key.)

{CMC} (Send a ClientHello message with a key share that is of an unsupported elliptic curve, violating the negotiation process.)
```"
,,,,,<CMC> <1> (Clients MUST ensure integrity for the handshake up to this point.) + <SMP> <1> (Servers MUST ensure integrity for the handshake up to this point.),"```markdown
{CMC} (Send a ClientHello message with a malformed handshake hash that does not correspond to the actual handshake messages exchanged so far.)

{CMC} (Omit the Handshake Hash extension from the ClientHello, violating integrity checks required by the server.)

{CMC} (Include a ClientHello with a deliberately corrupted version of previously exchanged handshake messages, making it impossible to verify integrity.)
```"
187,Message Structure,"The CertificateVerify message has a defined structure including a signature scheme algorithm and an opaque signature. The algorithm field specifies the signature algorithm used, while the signature is a digital signature over a specific content.",0,Skip,Skip,Skip
188,Content Covered by Signature,The content covered under the signature includes the hash output derived from the handshake context and the certificate. This is crucial for ensuring the integrity of the handshake process.,0,Skip,Skip,Skip
189,Signature Calculation Process,"The digital signature is computed over a concatenation of a 64-byte padding, a context string, a separator byte, and the content to be signed. This structure mitigates potential attacks on previous TLS versions.",0,Skip,Skip,Skip
190,Context Strings for Signatures,"For server signatures, the context string is ""TLS 1.3, server CertificateVerify"", while for client signatures, it is ""TLS 1.3, client CertificateVerify"". This separation helps prevent cross-protocol attacks.",0,Skip,Skip,Skip
191,Signature Algorithm Requirements,"The signature algorithm used must be compatible with the client's ""signature_algorithms"" extension if sent by a server and must align with the supported algorithms in the CertificateRequest message if sent by a client. RSA signatures must use RSASSA-PSS, and SHA-1 is not permitted.",1,"<SMC> <1> (Servers MUST use a signature algorithm compatible with the client's ""signature_algorithms"" extension.) + <CMP> <1> (Clients MUST ensure the signature algorithm aligns with the supported algorithms in the CertificateRequest message.)
<SMC> <1> (Servers MUST use RSA signatures with RSASSA-PSS.) + <CMP> <1> (Clients MUST NOT use SHA-1 as a signature algorithm.)","<SMC> <1> (Servers MUST use a signature algorithm compatible with the client's ""signature_algorithms"" extension.) + <CMP> <1> (Clients MUST ensure the signature algorithm aligns with the supported algorithms in the CertificateRequest message.)","```markdown
{CMC} (Send a ClientHello with a ""signature_algorithms"" extension that includes unsupported algorithms for the server's certificate.)

{CMC} (Omit the ""signature_algorithms"" extension entirely from the ClientHello message, violating the handshake requirements.)

{CMC} (Send a ClientHello with a malformed ""signature_algorithms"" extension, such as an empty list or incorrectly formatted algorithm identifiers.)
```"
,,,,,<SMC> <1> (Servers MUST use RSA signatures with RSASSA-PSS.) + <CMP> <1> (Clients MUST NOT use SHA-1 as a signature algorithm.),"```markdown
{CMC} (Send a ClientHello message requesting SHA-1 as a signature algorithm despite the server requiring RSA signatures with RSASSA-PSS.)

{CMC} (Include a signature in the ClientHello that is generated using RSA but does not comply with RSASSA-PSS.)

{CMC} (Omit the signature algorithm list in the ClientHello, which is required for negotiation with the server.)
```"
192,Verification Process,"The receiver of a CertificateVerify message must verify the signature using the public key from the end-entity certificate and terminate the handshake with a ""decrypt_error"" alert if the verification fails.",1,"<CMC> <1> (Clients MUST verify the signature in the CertificateVerify message using the public key from the end-entity certificate.) + <SMP> <1> (Servers MUST terminate the handshake with a ""decrypt_error"" alert if the signature verification fails.)","<CMC> <1> (Clients MUST verify the signature in the CertificateVerify message using the public key from the end-entity certificate.) + <SMP> <1> (Servers MUST terminate the handshake with a ""decrypt_error"" alert if the signature verification fails.)","```markdown
{CMC} (Send a CertificateVerify message with an invalid signature that does not match the public key from the end-entity certificate.)

{CMC} (Send a CertificateVerify message that includes an additional malformed field, altering the expected structure of the message.)

{CMC} (Omit the CertificateVerify message entirely, violating the requirement to send it after the ClientFinish message.)
```"
193,Finished Message Purpose,"The Finished message is the final message in the Authentication Block, essential for providing authentication of the handshake and the computed keys.",0,Skip,Skip,Skip
194,Verification Requirement,"Recipients of Finished messages must verify their contents; if incorrect, they must terminate the connection with a ""decrypt_error"" alert.",1,"<CMC> <1> (Clients MUST verify the contents of Finished messages; if incorrect, they MUST terminate the connection with a ""decrypt_error"" alert.) + <SMP> <1> (Servers MUST verify the contents of Finished messages; if incorrect, they MUST terminate the connection with a ""decrypt_error"" alert.)","<CMC> <1> (Clients MUST verify the contents of Finished messages; if incorrect, they MUST terminate the connection with a ""decrypt_error"" alert.) + <SMP> <1> (Servers MUST verify the contents of Finished messages; if incorrect, they MUST terminate the connection with a ""decrypt_error"" alert.)","```markdown
{CMC} (Send a Finished message with an incorrect MAC, deliberately violating the cryptographic integrity check.)

{CMC} (Send a Finished message without the required length field, causing ambiguity in message parsing.)

{CMC} (Send a Finished message while omitting the mandatory previous handshake messages, breaking the expected flow of the handshake.)
```"
195,Transition to Application Data,"Once a side has sent its Finished message and validated the peer's Finished message, it may begin to send and receive Application Data over the connection.",0,Skip,Skip,Skip
196,Early Data Sending Conditions,"Clients may send 0-RTT data as described in Section 4.2.10. Servers may send data after their first flight, but without assurance of the peer's identity or liveness.",0,Skip,Skip,Skip
197,Finished Message Key Computation,"The key used to compute the Finished message is derived from the Base Key using HKDF, specifically `finished_key = HKDF-Expand-Label(BaseKey, ""finished"", """", Hash.length)`.",0,Skip,Skip,Skip
198,Finished Message Structure,The structure of this message includes `struct { opaque verify_data[Hash.length]; ,0,Skip,Skip,Skip
199,Verify Data Calculation,The verify_data value is computed using HMAC with the finished_key and the transcript hash of the handshake context.,0,Skip,Skip,Skip
200,Length of Verify Data,"In TLS 1.3, the verify_data length is the size of the HMAC output for the Hash used for the handshake, differing from previous versions where it was always 12 octets long.",0,Skip,Skip,Skip
201,Post-Finished Message Records,"Any records following a Finished message must be encrypted under the appropriate application traffic key, including alerts sent by the server in response to client messages.",1,"<SMC> <1> (Servers MUST encrypt any records following a Finished message under the application traffic key, including alerts in response to client messages.) + <CMP> <1> (Clients MUST expect that any records following a Finished message will be encrypted under the appropriate application traffic key.)","<SMC> <1> (Servers MUST encrypt any records following a Finished message under the application traffic key, including alerts in response to client messages.) + <CMP> <1> (Clients MUST expect that any records following a Finished message will be encrypted under the appropriate application traffic key.)","```markdown
{CMC} (Send a ClientHello followed by an unencrypted record after a Finished message, violating the encryption requirement for subsequent messages.)
{CMC} (Include an alert message in plaintext immediately after the ClientHello, contrary to the requirement for encryption after the Finished message.)
{CMC} (Send a ClientHello that does not include the necessary cryptographic parameters, leading to undefined encryption behavior after the Finished message.)
```"
202,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip,Skip
203,Post-Handshake Messages,TLS allows other messages to be sent after the main handshake. These messages use a handshake content type and are encrypted under the appropriate application traffic key.,0,Skip,Skip,Skip
204,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip,Skip
205,Post-Handshake Authentication Extension,"When the client has sent the ""post_handshake_auth"" extension, a server may request client authentication at any time after the handshake has completed by sending a CertificateRequest message.",0,Skip,Skip,Skip
206,Client Response Requirements,"The client must respond with the appropriate Authentication messages. If the client chooses to authenticate, it must send Certificate, CertificateVerify, and Finished. If it declines, it must send a Certificate message containing no certificates followed by Finished.",1,"<CMC> <1> (Clients MUST send Certificate, CertificateVerify, and Finished if choosing to authenticate.) + <SMP> <0> (Servers MUST process the Certificate, CertificateVerify, and Finished messages if they are sent by the client for authentication.)
<CMC> <1> (Clients MUST send a Certificate message containing no certificates followed by Finished if they decline to authenticate.) + <SMP> <0> (Servers MUST process the Certificate message containing no certificates and the Finished message if they are sent by the client.)","<CMC> <1> (Clients MUST send Certificate, CertificateVerify, and Finished if choosing to authenticate.) + <SMP> <0> (Servers MUST process the Certificate, CertificateVerify, and Finished messages if they are sent by the client for authentication.)","```markdown
{CMC} (Send a ClientHello message without including the Certificate, CertificateVerify, and Finished messages when authentication is chosen)

{CMC} (Send a ClientHello message with an invalid or malformed Certificate message format)

{CMC} (Send a Certificate message that includes an unsupported or invalid signature algorithm)
```"
,,,,,<CMC> <1> (Clients MUST send a Certificate message containing no certificates followed by Finished if they decline to authenticate.) + <SMP> <0> (Servers MUST process the Certificate message containing no certificates and the Finished message if they are sent by the client.),"```markdown
{CMC} (Send a Certificate message with an invalid format, such as an empty payload instead of a valid ASN.1 structure.)

{CMC} (Send a Finished message immediately after the ClientHello, omitting the Certificate message entirely.)

{CMC} (Send a Certificate message with a length field indicating more certificates than are actually present.)
```"
207,Message Order for Client Responses,All of the client's messages for a given response must appear consecutively on the wire with no intervening messages of other types.,1,<CMC> <1> (Clients' messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.) + <SMP> <0> (Servers MUST process clients' messages only when they appear consecutively without intervening messages of other types.),<CMC> <1> (Clients' messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.) + <SMP> <0> (Servers MUST process clients' messages only when they appear consecutively without intervening messages of other types.),"```markdown
{CMC} (Send multiple ClientHello messages interspersed with non-TLS messages, violating the requirement for consecutive messages.)

{CMC} (Send a ClientHello message followed by a non-ClientHello message, then send another ClientHello, breaking the consecutiveness rule.)

{CMC} (Send a ClientHello with a malformed structure that includes unexpected padding or null fields, disrupting the expected message sequence.)
```"
208,Handling Unexpected Certificate Requests,"A client that receives a CertificateRequest message without having sent the ""post_handshake_auth"" extension must send an ""unexpected_message"" fatal alert.",1,"<CMC> <1> (Clients MUST send an ""unexpected_message"" fatal alert if they receive a CertificateRequest message without having sent the ""post_handshake_auth"" extension.) + <SMP> <0> (Servers MUST not expect a CertificateRequest message if the ""post_handshake_auth"" extension was not sent by the client.)","<CMC> <1> (Clients MUST send an ""unexpected_message"" fatal alert if they receive a CertificateRequest message without having sent the ""post_handshake_auth"" extension.) + <SMP> <0> (Servers MUST not expect a CertificateRequest message if the ""post_handshake_auth"" extension was not sent by the client.)","```markdown
{CMC} (Send a ClientHello message that includes a CertificateRequest without the ""post_handshake_auth"" extension, violating the expectation for alert handling.)

{CMC} (Send a ClientHello message that contains an invalid ""extensions"" field, causing confusion about the required ""post_handshake_auth"" extension presence.)

{CMC} (Send a ClientHello with a malformed ""extensions"" structure that misrepresents the negotiation state, leading to a fatal alert when a CertificateRequest is received.)
```"
209,Server Readiness for Delays,"Because client authentication could involve prompting the user, servers must be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response.",1,"<SMC> <1> (Servers MUST be prepared for some delay in client authentication, including receiving other messages between sending the CertificateRequest and receiving a response.) + <CMP> <0> (Clients MAY take time to respond to a CertificateRequest due to user prompting.)","<SMC> <1> (Servers MUST be prepared for some delay in client authentication, including receiving other messages between sending the CertificateRequest and receiving a response.) + <CMP> <0> (Clients MAY take time to respond to a CertificateRequest due to user prompting.)","```markdown
{CMC} (Send a ClientHello message without the required supported_versions field, violating the handshake structure.)
{CMC} (Include an unsupported or invalid cipher suite in the ClientHello, which is not listed in the server's supported cipher suites.)
{CMC} (Send a ClientHello with an empty extensions field, omitting essential extension information such as server_name or supported_groups.)
```"
210,Response Order for Multiple Requests,"Clients which receive multiple CertificateRequests in close succession may respond to them in a different order than they were received, as the certificate_request_context value allows the server to disambiguate the responses.",0,Skip,Skip,Skip
211,KeyUpdate Message Purpose,The KeyUpdate handshake message indicates that the sender is updating its sending cryptographic keys. This message can be sent by either peer after it has sent a Finished message.,0,Skip,Skip,Skip
212,Handling Unexpected KeyUpdate,"Implementations that receive a KeyUpdate message prior to receiving a Finished message must terminate the connection with an ""unexpected_message"" alert.",1,"<CMC> <1> (Clients MUST terminate the connection with an ""unexpected_message"" alert if they receive a KeyUpdate message before the Finished message.) + <SMP> <1> (Servers MUST terminate the connection with an ""unexpected_message"" alert if they receive a KeyUpdate message before the Finished message.)","<CMC> <1> (Clients MUST terminate the connection with an ""unexpected_message"" alert if they receive a KeyUpdate message before the Finished message.) + <SMP> <1> (Servers MUST terminate the connection with an ""unexpected_message"" alert if they receive a KeyUpdate message before the Finished message.)","```markdown
{CMC} (Send a KeyUpdate message from the client before sending the Finished message, violating the expected order of messages.)

{CMC} (Send a ClientHello with an invalid KeyUpdate message included in its extensions.)

{CMC} (Omit the Finished message entirely and send only a KeyUpdate message in response to server messages.)
```"
213,KeyUpdate Message Protocol,"After sending a KeyUpdate message, the sender shall use the next generation of keys. Upon receiving a KeyUpdate, the receiver must update its receiving keys.",1,<CMC> <1> (Senders SHALL use the next generation of keys after sending a KeyUpdate message.) + <SMP> <1> (Receivers MUST update their receiving keys upon receiving a KeyUpdate.),<CMC> <1> (Senders SHALL use the next generation of keys after sending a KeyUpdate message.) + <SMP> <1> (Receivers MUST update their receiving keys upon receiving a KeyUpdate.),"```markdown
{CMC} (Send a KeyUpdate message without a prior handshake message or ClientHello, violating the expected message sequence.)
{CMC} (Send a KeyUpdate message that contains keys marked as invalid or unsupported by the server, violating key validation.)
{CMC} (Send a KeyUpdate message with an incorrect key usage value, indicating a misuse of the key update mechanism.)
```"
214,KeyUpdateRequest Enumeration,"The KeyUpdateRequest enum indicates whether the recipient should respond with its own KeyUpdate, with values for update_not_requested and update_requested.",0,Skip,Skip,Skip
215,Response Mechanism for KeyUpdate,"If request_update is set to ""update_requested,"" the receiver must send a KeyUpdate of its own with request_update set to ""update_not_requested"" before sending its next Application Data record.",1,"<CMC> <1> (Clients MUST send a KeyUpdate with request_update set to ""update_not_requested"" before sending the next Application Data record if request_update is set to ""update_requested."") + <SMP> <0> (Servers MUST process the KeyUpdate with request_update set to ""update_not_requested"" before sending the next Application Data record.)","<CMC> <1> (Clients MUST send a KeyUpdate with request_update set to ""update_not_requested"" before sending the next Application Data record if request_update is set to ""update_requested."") + <SMP> <0> (Servers MUST process the KeyUpdate with request_update set to ""update_not_requested"" before sending the next Application Data record.)","```markdown
{CMC} (Send a KeyUpdate with request_update set to ""update_requested"" without having sent an Application Data record first.)

{CMC} (Send a KeyUpdate with malformed request_update field that contains an unsupported value.)

{CMC} (Send a KeyUpdate message with the length field incorrectly set to a value greater than the actual KeyUpdate payload size.)
```"
216,Handling Multiple KeyUpdates,"Implementations may receive multiple messages between sending a KeyUpdate and receiving the peer's KeyUpdate, but retaining the receive traffic secret ensures forward secrecy.",0,Skip,Skip,Skip
217,Crossing KeyUpdates,"If both sides send their own KeyUpdates with request_update set to ""update_requested"" and they cross in flight, each side will send a response, incrementing by two generations.",0,Skip,Skip,Skip
218,Encryption Requirement for KeyUpdate,Both sender and receiver must encrypt KeyUpdate messages with the old keys and ensure that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key to prevent message truncation attacks.,1,<CMC> <1> (Clients MUST encrypt KeyUpdate messages with the old keys.) + <SMP> <1> (Servers MUST ensure that a KeyUpdate with the old key is received before accepting messages encrypted with the new key to prevent message truncation attacks.),<CMC> <1> (Clients MUST encrypt KeyUpdate messages with the old keys.) + <SMP> <1> (Servers MUST ensure that a KeyUpdate with the old key is received before accepting messages encrypted with the new key to prevent message truncation attacks.),"```markdown
{CMC} (Send a KeyUpdate message encrypted with a new key instead of the old key)

{CMC} (Send a KeyUpdate message with an invalid key length, violating the expected key size)

{CMC} (Send a KeyUpdate message without the necessary sequence number field present)
```"
