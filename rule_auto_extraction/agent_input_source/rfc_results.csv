ID,Title,Content
1,Handshake Protocol Overview,"The handshake protocol is used to negotiate the security parameters of a connection. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext or TLSCiphertext structures which are processed and transmitted as specified by the current active connection state."
2,Handshake Message Types,"The enum defines various handshake message types, including client_hello, server_hello, new_session_ticket, end_of_early_data, encrypted_extensions, certificate, certificate_request, certificate_verify, finished, key_update, and message_hash."
3,Structure of Handshake Messages,"The struct describes the format of handshake messages, which includes a message type, length, and a selection of message-specific structures based on the message type."
4,Order of Protocol Messages,Protocol messages must be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2.
5,Handling Unexpected Message Orders,"A peer that receives a handshake message in an unexpected order must abort the handshake with an ""unexpected_message"" alert."
6,Assignment of New Message Types,New handshake message types are assigned by IANA as described in Section 11.
7,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected')
8,ClientHello Options,"In TLS, the cryptographic negotiation proceeds by the client offering four sets of options in its ClientHello: a list of cipher suites, a ""supported_groups"" extension indicating (EC)DHE groups, a ""signature_algorithms"" extension, and a ""pre_shared_key"" extension with symmetric key identities."
9,Server Parameter Selection,"If the server does not select a PSK, it independently selects a cipher suite, (EC)DHE group, key share, and signature algorithm/certificate pair. If there's no overlap in ""supported_groups,"" the handshake must abort with a ""handshake_failure"" or ""insufficient_security"" alert."
10,PSK and Key Exchange Modes,"If the server selects a PSK, it must also choose a key establishment mode from the client's ""psk_key_exchange_modes"" extension. Non-overlap in ""supported_groups"" is not fatal if PSK can be used without (EC)DHE."
11,HelloRetryRequest Requirement,"If the server selects an (EC)DHE group without a compatible ""key_share"" from the client, it must respond with a HelloRetryRequest message."
12,ServerHello Parameter Indication,"Upon successful parameter selection, the server indicates the selected parameters in the ServerHello, sending a ""pre_shared_key"" extension if PSK is used, and a ""key_share"" extension when (EC)DHE is in use. Authentication via certificate involves sending Certificate and CertificateVerify messages."
13,Handshake Abortion Conditions,"If the server fails to negotiate a supported set of parameters, it must abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert."
14,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected')
15,Server Hello Response,The server sends the ServerHello message in response to a ClientHello message to proceed with the handshake if it can negotiate acceptable handshake parameters.
16,Structure of ServerHello Message,"The ServerHello message structure includes fields for legacy_version, random, legacy_session_id_echo, cipher_suite, legacy_compression_method, and extensions."
17,Legacy Version Explanation,"The legacy_version field was previously used for version negotiation but is now set to 0x0303 for TLS 1.2. TLS 1.3 servers indicate their version using the ""supported_versions"" extension."
18,Random Value Generation,"The random field consists of 32 bytes generated by a secure random number generator, with specific requirements on the last 8 bytes based on the negotiated TLS version."
19,Session ID Echo,"legacy_session_id_echo contains the client's session ID, which must match the client's sent value; otherwise, the handshake is aborted with an ""illegal_parameter"" alert."
20,Cipher Suite Selection,"The cipher_suite field contains the single cipher suite selected by the server from the client's offered list, and a mismatch results in an ""illegal_parameter"" alert."
21,Compression Method,The legacy_compression_method field must always have the value 0.
22,Extensions Requirements,"The extensions field must include only those necessary for establishing the cryptographic context and must contain the ""supported_versions"" extension in all TLS 1.3 messages."
23,HelloRetryRequest Structure,The HelloRetryRequest message uses the same structure as ServerHello but sets the Random value to a predefined SHA-256 hash for backward compatibility with middleboxes.
24,Random Value Check,"Upon receiving a server_hello message, implementations must check if the Random value matches specific criteria related to downgrade protection."
25,Downgrade Protection Mechanism,TLS 1.3 servers negotiating TLS 1.2 or below must set the last 8 bytes of the Random value to specific values to provide downgrade protection against attacks.
26,Client Checks for Downgrade,"TLS 1.3 clients must verify the last 8 bytes of the Random value to prevent downgrade attacks, and if a match is found, they must abort the handshake with an ""illegal_parameter"" alert."
27,Renegotiation Handling,"A legacy TLS client receiving a TLS 1.3 ServerHello during renegotiation must abort the handshake with a ""protocol_version"" alert, as renegotiation is not possible in TLS 1.3."
28,Hello Retry Request Purpose,The server sends a HelloRetryRequest in response to a ClientHello message when it finds acceptable parameters but requires more information to proceed with the handshake. This message has the same format as a ServerHello message.
29,Extensions in Hello Retry Request,"The server's extensions must include ""supported_versions"" and may optionally include the ""cookie"" extension. It must not contain any extensions not first offered by the client, except for ""cookie."""
30,Client Actions on Hello Retry Request,"Upon receiving a HelloRetryRequest, the client must check specific fields and process the extensions, starting with ""supported_versions."" It must abort the handshake with an ""illegal_parameter"" alert if no changes result from the HelloRetryRequest."
31,Handling Multiple Hello Retry Requests,"If a client receives a second HelloRetryRequest in the same connection, it must abort the handshake with an ""unexpected_message"" alert."
32,Cipher Suite Negotiation,A client must abort the handshake if it receives a cipher suite not offered earlier. Servers must negotiate the same cipher suite when receiving an updated ClientHello.
33,Selected Version Consistency,"The selected_version in the HelloRetryRequest must be retained in the ServerHello; otherwise, the client must abort the handshake with an ""illegal_parameter"" alert."
34,ClientHello Update Guidelines,"In its updated ClientHello, the client should avoid offering pre-shared keys associated with different hashes than that of the selected cipher suite to prevent unnecessary computations."
35,TLS Extensions Structure,"A number of TLS messages contain tag-length-value encoded extensions structures. The structure includes an ""extension_type"" to identify the extension and ""extension_data"" for specific information related to the extension type."
36,Extension Types,"The list of extension types, including server_name, max_fragment_length, and others, is maintained by IANA as described in Section 11."
37,Request/Response Model,Extensions are generally structured in a request/response manner. The client sends extension requests in the ClientHello message while the server responds in various messages such as ServerHello and Certificate.
38,Unsolicited Extensions,"The server may send unsolicited extensions in the NewSessionTicket, which the client does not respond to directly."
39,Handling Extension Responses,"Implementations must not send extension responses if the corresponding requests were not received, except for the ""cookie"" extension in HelloRetryRequest, which may lead to an ""unsupported_extension"" alert if violated."
40,Extension Message Restrictions,"If an implementation receives an extension not specified for the message, it must abort the handshake with an ""illegal_parameter"" alert."
41,Extension Message Availability,"A table indicates where each extension may appear, using notations like CH (ClientHello) and SH (ServerHello)."
42,Order of Extensions,"When multiple extensions are present, they may appear in any order, except for ""pre_shared_key,"" which must be last in ClientHello. No more than one extension of the same type may exist in a block."
43,Negotiation in TLS 1.3,"In TLS 1.3, extensions are negotiated for each handshake, even in resumption-PSK mode, differing from TLS 1.2."
44,Security Considerations,Designers should consider security implications when introducing new extensions to prevent attacks that manipulate handshake messages.
45,Error Handling in Extensions,"Error conditions and refusals to support features should be handled properly, using appropriate alerts for errors and fields in responses for refusals."
46,Integrity of Handshake Phase,"Designers must ensure that extensions do not compromise security, especially since active attackers can modify messages until the handshake is authenticated."
47,Supported Versions Extension Purpose,"The ""supported_versions"" extension is used by the client to indicate which versions of TLS it supports and by the server to indicate the version it is using. The extension contains a list of supported versions in preference order, with the most preferred version first."
48,ClientHello Requirements,"Implementations of this specification must send the ""supported_versions"" extension in the ClientHello, containing all versions of TLS they are prepared to negotiate, minimally including 0x0304. Previous versions of TLS must also be included if allowed."
49,Server Behavior Without Extension,"If the ""supported_versions"" extension is not present, compliant servers supporting TLS 1.2 must negotiate TLS 1.2 or prior, regardless of the ClientHello.legacy_version value. Servers may abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later."
50,Version Negotiation with Extension,"If the extension is present in the ClientHello, servers must not use the ClientHello.legacy_version for version negotiation and must rely solely on the ""supported_versions"" extension. They must select only a version present in this extension and ignore any unknown versions."
51,Server Response Based on Negotiated Version,"A server negotiating a version prior to TLS 1.3 must set ServerHello.version and not send the ""supported_versions"" extension. If negotiating TLS 1.3, the server must send a ""supported_versions"" extension with the selected version value (0x0304) and set ServerHello.legacy_version to 0x0303 (TLS 1.2). Clients must check for this extension before processing the rest of the ServerHello."
52,Client Validation of Selected Version,"If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or a version prior to TLS 1.3, the client must abort the handshake with an ""illegal_parameter"" alert."
53,Cookie Structure Definition,The cookie structure is defined as an opaque value of size between 1 and 65535 bytes.
54,Purpose of Cookies,"Cookies serve two primary purposes: enabling the server to require the client to demonstrate reachability for DoS protection and allowing the server to offload state to the client, facilitating a HelloRetryRequest without storing state."
55,HelloRetryRequest and Cookie Extension,"When sending a HelloRetryRequest, the server may provide a ""cookie"" extension, deviating from the usual rule that only ClientHello extensions may be sent."
56,ClientHello Cookie Requirement,The client must include the cookie extension received in the HelloRetryRequest in the new ClientHello. Clients must not use cookies in their initial ClientHello for subsequent connections.
57,Stateless Server Behavior,"A stateless server may receive an unprotected record of type change_cipher_spec between ClientHello messages and must ignore these records, as it does not retain any state."
58,Signature Algorithm Extensions in TLS 1.3,"TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures: ""signature_algorithms_cert"" for certificate signatures and ""signature_algorithms"" for CertificateVerify messages."
59,Key Compatibility Requirement,"The keys found in certificates must be of appropriate type for the signature algorithms used, particularly concerning RSA keys and PSS signatures."
60,Client Authentication Requirement,"Clients desiring server authentication via a certificate must send the ""signature_algorithms"" extension; otherwise, the server must abort the handshake with a ""missing_extension"" alert."
61,"Purpose of ""signature_algorithms_cert""","The ""signature_algorithms_cert"" extension allows implementations to clearly signal their capabilities regarding different sets of algorithms for certificates and TLS."
62,SignatureScheme List Structure,"The ""extension_data"" field of these extensions contains a SignatureSchemeList value, which lists supported signature algorithms in descending order of preference."
63,Signature Algorithm Types and Descriptions,"Various signature algorithms are defined, including RSASSA-PKCS1-v1_5, ECDSA, and EdDSA, each with specific requirements regarding their use and parameters."
64,Deprecation of Legacy Algorithms,"Legacy algorithms using SHA-1 are being deprecated; clients must list these as lower priority, and TLS 1.3 servers must not offer SHA-1 signed certificates unless unavoidable."
65,Self-Signed Certificate Validation,"Signatures on self-signed certificates or trust anchors are not validated, as they initiate a certification path and may use unsupported signature algorithms."
66,Compatibility with TLS 1.2,"TLS 1.3 implementations negotiating TLS 1.2 must adhere to its requirements, including the ability to negotiate without the ""signature_algorithms"" extension and accept legacy signature pairs."
67,Certificate Authorities Extension Purpose,"The ""certificate_authorities"" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which should guide certificate selection by the receiving endpoint."
68,Certificate Authorities Extension Structure,"The body of the ""certificate_authorities"" extension consists of a CertificateAuthoritiesExtension structure, which includes a list of distinguished names of acceptable certificate authorities."
69,Distinguished Name Representation,"The authorities are represented in DER-encoded format and specify desired distinguished names for trust anchors or subordinate CAs, helping to describe known trust anchors and authorization spaces."
70,Client and Server Usage,"The client may send the ""certificate_authorities"" extension in the ClientHello message, while the server may send it in the CertificateRequest message."
71,Non-usage of Trusted CA Keys Extension,"The ""trusted_ca_keys"" extension, which serves a similar purpose but is more complicated, is not used in TLS 1.3, although it may appear in ClientHello messages from clients offering prior versions of TLS."
72,OID Filters Purpose,"The ""oid_filters"" extension allows servers to provide a set of OID/value pairs that the client's certificate should match. This extension must only be sent in the CertificateRequest message if provided by the server."
73,OIDFilter Structure,"The OIDFilter structure consists of two fields: `certificate_extension_oid` and `certificate_extension_values`, which represent the OID and its corresponding values."
74,Filters List Requirement,"Filters must be a list of certificate extension OIDs with their allowed values in DER-encoded format. If the server includes a non-empty filters list, the client certificate must contain all specified extension OIDs that the client recognizes."
75,Client Certificate Validation,"For each recognized extension OID, all specified values must be present in the client certificate. The client may include additional values but must ignore unrecognized OIDs."
76,Server Actions on Mismatch,"If the client ignores required extension OIDs and provides a non-compliant certificate, the server may either continue without client authentication or abort the handshake with an ""unsupported_certificate"" alert."
77,Unique OID Requirement,Each OID must not appear more than once in the filters list.
78,PKI Library Dependency,TLS implementations are expected to rely on their PKI libraries to perform certificate selection using the defined OID filters.
79,Matching Rules for Key Usages,"The document defines matching rules for the Key Usage and Extended Key Usage extensions, requiring that all asserted bits or OIDs in the request be present in the corresponding certificate extensions."
80,Exclusion of anyExtendedKeyUsage,The special anyExtendedKeyUsage OID must not be used in the request for Extended Key Usage.
81,Potential for Additional Specifications,Separate specifications may define matching rules for other certificate extensions.
82,Post-Handshake Authentication Extension Purpose,"The ""post_handshake_auth"" extension indicates that a client is willing to perform post-handshake authentication (Section 4.6.2)."
83,Server Requirements for Post-Handshake Authentication,Servers must not send a post-handshake CertificateRequest to clients that do not offer this extension.
84,Prohibition of Extension by Servers,Servers must not send this extension.
85,Post-Handshake Auth Structure,"The ""extension_data"" field of the ""post_handshake_auth"" extension is zero length."
86,Supported Groups Extension,"When sent by the client, the ""supported_groups"" extension indicates the named groups which the client supports for key exchange, ordered from most preferred to least preferred."
87,Historical Context,"In versions of TLS prior to TLS 1.3, this extension was named ""elliptic_curves"" and only contained elliptic curve groups."
88,Signature Algorithms Negotiation,"Signature algorithms are now negotiated independently, as described in Section 4.2.3."
89,NamedGroupList Structure,"The ""extension_data"" field of this extension contains a ""NamedGroupList"" value, which includes elliptic curve groups (ECDHE) and finite field groups (DHE)."
90,Elliptic Curve Groups,Elliptic Curve Groups (ECDHE) indicate support for named curves defined in FIPS 186-4 or RFC 7748.
91,Finite Field Groups,Finite Field Groups (DHE) indicate support for finite field groups defined in RFC 7919.
92,Order of Preferences,"Items in named_group_list are ordered according to the sender's preferences, with the most preferred choice first."
93,Server Behavior in TLS 1.3,"As of TLS 1.3, servers may send the ""supported_groups"" extension to the client, and clients must not act on this information until the handshake is complete."
94,Updating Client Preferences,"If the server has a preferred group not in the client's ""key_share"" extension but is still willing to accept the ClientHello, it should send ""supported_groups"" to update the clientâ€™s view of its preferences."
95,Key Share Extension Overview,"The ""key_share"" extension contains the endpoint's cryptographic parameters and allows clients to send an empty client_shares vector to request group selection from the server, incurring an additional round trip."
96,KeyShareEntry Structure,The KeyShareEntry structure includes a named group for the key being exchanged and key exchange information determined by the specified group.
97,ClientHello Key Share Data,"In the ClientHello message, the ""extension_data"" field contains a ""KeyShareClientHello"" value, which includes a list of offered KeyShareEntry values in descending order of client preference."
98,Empty Client Shares for HelloRetryRequest,"The client_shares vector may be empty if the client is requesting a HelloRetryRequest, but each KeyShareEntry must correspond to a group in the ""supported_groups"" extension."
99,Offering Multiple KeyShareEntries,"Clients can offer multiple KeyShareEntry values for supported groups, but each value must be generated independently, and clients must not offer duplicates or invalid groups."
100,HelloRetryRequest Handling,"In a HelloRetryRequest, the ""extension_data"" contains a KeyShareHelloRetryRequest value indicating the mutually supported group for negotiation. The client must verify that the selected group is valid before retrying."
101,ServerHello Key Share Data,"In a ServerHello message, the ""extension_data"" includes a KeyShareServerHello value, which consists of a single KeyShareEntry that matches the client's selected group."
102,Validation of Key Share in ServerHello,Servers must verify that the KeyShareEntry aligns with the client's supported groups and must not send entries for unsupported groups or in incompatible modes.
103,Diffie-Hellman Parameter Encoding,"Diffie-Hellman parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure. The opaque value contains the Diffie-Hellman public value (Y = g^X mod p) for the specified group, encoded as a big-endian integer and padded to the left with zeros to the size of p in bytes."
104,Public Key Padding,"For a given Diffie-Hellman group, the padding results in all public keys having the same length."
105,Public Key Validation,Peers must validate each other's public key Y by ensuring that 1 < Y < p-1. This check ensures that the remote peer is properly behaved and isn't forcing the local system into a small subgroup.
106,Key Share ECDHE Parameters,ECDHE parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure.
107,Uncompressed Point Representation Structure,"For secp256r1, secp384r1, and secp521r1, the contents are the serialized value of the UncompressedPointRepresentation struct, which includes a legacy_form and the binary representations of the x and y values."
108,Binary Representation Details,"X and Y are the binary representations of the x and y values in network byte order, with each representation occupying octets as specified by the curve parameters. For P-256, each uses 32 octets; for P-384, 48 octets; and for P-521, 66 octets."
109,Validation of Public Values,"Peers must validate each other's public value Q by ensuring it is a valid point on the elliptic curve, following the procedures outlined in Section 4.3.7 of [ECDSA] and Section 5.6.2.3 of [KEYAGREEMENT]. This includes verifying that Q is not the point at infinity, that x and y are in the correct interval, and that (x, y) satisfies the elliptic curve equation."
110,Public Values for X25519 and X448,"For X25519 and X448, the public value consists of the byte string inputs and outputs defined in [RFC7748]: 32 bytes for X25519 and 56 bytes for X448."
111,Point Format Negotiation in TLS,"TLS versions prior to 1.3 allowed point format negotiation, but TLS 1.3 removes this feature, specifying a single point format for each curve."
112,PSK Key Exchange Modes Requirement,"In order to use PSKs, clients must send a ""psk_key_exchange_modes"" extension, indicating the supported modes. This restricts both the PSKs offered in the ClientHello and those the server might supply via NewSessionTicket."
113,Mandatory Extension for Pre-Shared Key,"A client must provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension. If a client offers ""pre_shared_key"" without this extension, servers must abort the handshake."
114,Server Mode Selection Restriction,"Servers must not select a key exchange mode not listed by the client. This extension also restricts modes for PSK resumption, and servers should not send NewSessionTicket with incompatible tickets, or else client resumption attempts will fail."
115,"Prohibition of Server ""psk_key_exchange_modes""","The server must not send a ""psk_key_exchange_modes"" extension."
116,Definition of PSK Key Exchange Modes,"The enum defines two modes: psk_ke for PSK-only key establishment, where the server must not supply a ""key_share"" value, and psk_dhe_ke for PSK with (EC)DHE key establishment, where both parties must supply ""key_share"" values."
117,Future Protocol Indications,"Future values must ensure that protocol messages unambiguously identify the selected mode by the presence of ""key_share"" in the ServerHello."
118,Early Data with PSK,"When a PSK is used and early data is allowed, the client can send Application Data in its first flight of messages, supplying both the ""pre_shared_key"" and ""early_data"" extensions."
119,Early Data Indication Structure,"The ""extension_data"" field contains an ""EarlyDataIndication"" value, with a specific structure dependent on the handshake message type."
120,Max Early Data Size,Details regarding the use of the max_early_data_size field are specified in Section 4.6.1.
121,PSK and Associated Parameters,"The parameters for 0-RTT data, such as version and cipher suite, are linked to the PSK in use, either provisioned or negotiated during the connection."
122,Ticket Age Validation,"For PSKs from NewSessionTicket, the server must validate the ticket age against the time since issuance, rejecting 0-RTT if it fails."
123,0-RTT Message Structure,"0-RTT messages share encrypted content types with other message types but use different keys, with an EndOfEarlyData message indicating key change."
124,Server Response to Early Data,"A server receiving an ""early_data"" extension may ignore it, request a new ClientHello, or accept it and process early data."
125,Requirements for Accepting Early Data,"To accept early data, the server must verify the TLS version, cipher suite, and ALPN protocol match those associated with the selected PSK."
126,Handling Failed Checks,"If checks fail, the server must discard first-flight data and revert to 1-RTT or 2-RTT."
127,Error Handling for Early Data,"If the server accepts early data but fails to decrypt records, it must terminate the connection with a ""bad_record_mac"" alert."
128,Client Behavior on Rejection,"If the server rejects the ""early_data"" extension, the client may retransmit Application Data after the handshake, but must consider the connection state."
129,Guidance for TLS Implementations,A TLS implementation should not automatically resend early data; applications should decide when retransmission is appropriate.
130,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected')
131,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected')
132,PSK Binder Purpose,"The PSK binder value forms a binding between a PSK and the current handshake, as well as a binding between the handshake in which the PSK was generated and the current handshake."
133,Binder Computation Method,"Each entry in the binders list is computed as an HMAC over a transcript hash containing a partial ClientHello up to and including the PreSharedKeyExtension.identities field, excluding the binders list itself."
134,Message Length Fields,"The length fields for the message are set as if binders of the correct lengths were present, including overall length, extensions block length, and the ""pre_shared_key"" extension length."
135,PskBinderEntry Computation,"The PskBinderEntry is computed similarly to the Finished message, using the binder_key derived from the corresponding PSK offered."
136,Handling HelloRetryRequest,"If the handshake includes a HelloRetryRequest, the initial ClientHello and HelloRetryRequest are included in the transcript along with the new ClientHello, affecting binder computation."
137,Transcript Hash Examples,"For ClientHello1, its binder is computed over the truncated ClientHello; for ClientHello2 after a HelloRetryRequest, the binder includes the initial ClientHello, HelloRetryRequest, and the truncated new ClientHello."
138,Hash Computation Details,"In the first flight, Truncate(ClientHello1) is hashed directly, while in the second flight, ClientHello1 is hashed and reinjected as a ""message_hash"" message."
139,0-RTT Data Streaming,"Clients are permitted to ""stream"" 0-RTT data until they receive the server's Finished, only then sending the EndOfEarlyData message, followed by the rest of the handshake."
140,Server Processing of Early Data,"To avoid deadlocks, when accepting ""early_data"", servers must process the client's ClientHello and then immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending its ServerHello."
141,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected')
142,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected')
143,Certificate Request Purpose,"A server which is authenticating with a certificate may optionally request a certificate from the client. This message, if sent, must follow EncryptedExtensions."
144,CertificateRequest Structure,The structure of this message includes a certificate_request_context and a set of extensions.
145,certificate_request_context Details,"The certificate_request_context is an opaque string identifying the certificate request, which must be unique within the scope of the connection to prevent replay of client CertificateVerify messages. It shall be zero length unless used for post-handshake authentication, where it should be made unpredictable to prevent pre-computation of valid CertificateVerify messages."
146,Extensions Specification,"The extensions describe the parameters of the requested certificate, with the ""signature_algorithms"" extension being mandatory. Clients must ignore unrecognized extensions."
147,Changes in TLS 1.3,"In TLS 1.3, the CertificateRequest message expresses acceptable signature algorithms and certificate authorities through specific extensions, differing from prior versions."
148,PSK Authentication Constraints,"Servers authenticating with a PSK must not send the CertificateRequest message in the main handshake but may do so in post-handshake authentication if the client has sent the ""post_handshake_auth"" extension."
149,Authentication Messages Overview,"TLS generally uses a common set of messages for authentication, key confirmation, and handshake integrity: Certificate, CertificateVerify, and Finished. These messages are always sent as the last messages in their handshake flight."
150,Message Encryption,These messages are encrypted under keys derived from the sender's handshake traffic secret.
151,Input Computations for Authentication Messages,"The computations for the Authentication messages take the certificate and signing key, a Handshake Context consisting of the set of messages for the transcript hash, and a Base Key for computing a MAC key."
152,Certificate Message Details,The Certificate message includes the certificate for authentication and any supporting certificates in the chain. Note that certificate-based client authentication is not available in PSK handshake flows (including 0-RTT).
153,CertificateVerify Message Details,"The CertificateVerify message contains a signature over the value Transcript-Hash(Handshake Context, Certificate)."
154,Finished Message Details,"The Finished message includes a MAC over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using a MAC key derived from the Base Key."
155,Handshake Context and MAC Base Key Definitions,"The table defines the Handshake Context and MAC Base Key for each scenario, including modes for Server, Client, and Post-Handshake."
156,Transcript Hash Purpose,"Many of the cryptographic computations in TLS make use of a transcript hash, computed by hashing the concatenation of each included handshake message, including the message header but not record layer headers."
157,Transcript Hash Computation,"The transcript hash is computed as Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)."
158,Handling HelloRetryRequest,"When the server responds to a ClientHello with a HelloRetryRequest, ClientHello1 is replaced with a synthetic handshake message of type ""message_hash"" containing Hash(ClientHello1)."
159,Stateless HelloRetryRequest Explanation,"This construction allows the server to perform a stateless HelloRetryRequest by storing just the hash of ClientHello1 in the cookie, avoiding the need to export the entire intermediate hash state."
160,Sequence of Handshake Messages,"The transcript hash is taken from a specific sequence of handshake messages, starting at the first ClientHello and including messages such as ServerHello and client Finished."
161,Implementation Note,"Implementations can keep a running transcript hash value based on the negotiated hash, noting that post-handshake authentications do not include each other."
162,Error,Error: Sending request HandleBotLandingPageQuery failed.  Error log: RemoteProtocolError('Server disconnected')
163,OCSP Response Negotiation,"RFC6066 and RFC6961 provide extensions to negotiate the server sending OCSP responses to the client. In TLS 1.2 and below, the server replies with an empty extension to indicate negotiation of this extension, and the OCSP information is carried in a CertificateStatus message. In TLS 1.3, the server's OCSP information is carried in an extension in the CertificateEntry containing the associated certificate."
164,CertificateStatus Structure,"Specifically, the body of the ""status_request"" extension from the server MUST be a CertificateStatus structure as defined in RFC6066, which is interpreted as defined in RFC6960."
165,Deprecation of status_request_v2,"The status_request_v2 extension [RFC6961] is deprecated. TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients that wish to use it in earlier protocol versions."
166,Client OCSP Response Request,"A server MAY request that a client present an OCSP response with its certificate by sending an empty ""status_request"" extension in its CertificateRequest message. If the client opts to send an OCSP response, the body of its ""status_request"" extension MUST be a CertificateStatus structure as defined in RFC6066."
167,Signed Certificate Timestamp Mechanism,"Similarly, RFC6962 provides a mechanism for a server to send a Signed Certificate Timestamp (SCT) as an extension in the ServerHello in TLS 1.2 and below. In TLS 1.3, the server's SCT information is carried in an extension in the CertificateEntry."
168,Certificate Type Requirement,"The certificate type must be X.509v3, unless explicitly negotiated otherwise."
169,Key Compatibility,"The server's end-entity certificate's public key must be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension."
170,Signing Capability,"The certificate must allow the key to be used for signing, indicated by the digitalSignature bit in the Key Usage extension."
171,Certificate Selection Guidance,"The ""server_name"" and ""certificate_authorities"" extensions guide certificate selection, with clients encouraged to send the ""server_name"" extension when applicable."
172,Signature Algorithm Validation,All certificates provided by the server must be signed by a signature algorithm advertised by the client if the client can provide such a chain.
173,Fallback Certificate Chain,"If the server cannot produce a valid certificate chain, it should send a fallback chain that may include unsupported algorithms, avoiding deprecated SHA-1 unless permitted by the client."
174,Client Response to Invalid Chain,"If the client cannot construct an acceptable chain and aborts the handshake, it must do so with an appropriate certificate-related alert."
175,Multiple Certificate Selection,"If the server has multiple certificates, it selects one based on the defined criteria and additional factors like local configuration."
176,Client Certificate Type Requirement,"The certificate type must be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250])."
177,Certificate Authority Issuance,"If the ""certificate_authorities"" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain should be issued by one of the listed CAs."
178,Signature Algorithm Compliance,"The certificates must be signed using an acceptable signature algorithm, as described in Section 4.3.2, which relaxes constraints on certificate-signing algorithms found in prior versions of TLS."
179,OID Filters Matching,"If the CertificateRequest message contained a non-empty ""oid_filters"" extension, the end-entity certificate must match the extension OIDs recognized by the client, as described in Section 4.2.5."
180,Certificate Validation Scope,"In general, detailed certificate validation procedures are out of scope for TLS. This section provides TLS-specific requirements."
181,Handling Empty Certificate Messages,"If the server supplies an empty Certificate message, the client must abort the handshake with a ""decode_error"" alert. If the client sends an empty Certificate message, the server may either continue the handshake or abort it with a ""certificate_required"" alert."
182,Unacceptable Certificate Chains,"If any aspect of the certificate chain is unacceptable, the server may choose to continue the handshake as unauthenticated or abort it."
183,Aborting for MD5 and SHA-1 Certificates,"Any endpoint receiving a certificate that requires validation using MD5 must abort the handshake with a ""bad_certificate"" alert. SHA-1 is deprecated, and endpoints should also abort the handshake for SHA-1 validation."
184,Recommendation for SHA-256 Transition,All endpoints are recommended to transition to SHA-256 or better to maintain interoperability with implementations phasing out SHA-1 support.
185,Signature Algorithm Variability,A certificate containing a key for one signature algorithm may be signed using a different signature algorithm.
186,Purpose of CertificateVerify Message,This message is used to provide explicit proof that an endpoint possesses the private key corresponding to its certificate and ensures integrity for the handshake up to this point. Servers and clients must send this message when authenticating via a certificate.
187,Message Structure,"The CertificateVerify message has a defined structure including a signature scheme algorithm and an opaque signature. The algorithm field specifies the signature algorithm used, while the signature is a digital signature over a specific content."
188,Content Covered by Signature,The content covered under the signature includes the hash output derived from the handshake context and the certificate. This is crucial for ensuring the integrity of the handshake process.
189,Signature Calculation Process,"The digital signature is computed over a concatenation of a 64-byte padding, a context string, a separator byte, and the content to be signed. This structure mitigates potential attacks on previous TLS versions."
190,Context Strings for Signatures,"For server signatures, the context string is ""TLS 1.3, server CertificateVerify"", while for client signatures, it is ""TLS 1.3, client CertificateVerify"". This separation helps prevent cross-protocol attacks."
191,Signature Algorithm Requirements,"The signature algorithm used must be compatible with the client's ""signature_algorithms"" extension if sent by a server and must align with the supported algorithms in the CertificateRequest message if sent by a client. RSA signatures must use RSASSA-PSS, and SHA-1 is not permitted."
192,Verification Process,"The receiver of a CertificateVerify message must verify the signature using the public key from the end-entity certificate and terminate the handshake with a ""decrypt_error"" alert if the verification fails."
193,Finished Message Purpose,"The Finished message is the final message in the Authentication Block, essential for providing authentication of the handshake and the computed keys."
194,Verification Requirement,"Recipients of Finished messages must verify their contents; if incorrect, they must terminate the connection with a ""decrypt_error"" alert."
195,Transition to Application Data,"Once a side has sent its Finished message and validated the peer's Finished message, it may begin to send and receive Application Data over the connection."
196,Early Data Sending Conditions,"Clients may send 0-RTT data as described in Section 4.2.10. Servers may send data after their first flight, but without assurance of the peer's identity or liveness."
197,Finished Message Key Computation,"The key used to compute the Finished message is derived from the Base Key using HKDF, specifically `finished_key = HKDF-Expand-Label(BaseKey, ""finished"", """", Hash.length)`."
198,Finished Message Structure,The structure of this message includes `struct { opaque verify_data[Hash.length]; 
199,Verify Data Calculation,The verify_data value is computed using HMAC with the finished_key and the transcript hash of the handshake context.
200,Length of Verify Data,"In TLS 1.3, the verify_data length is the size of the HMAC output for the Hash used for the handshake, differing from previous versions where it was always 12 octets long."
201,Post-Finished Message Records,"Any records following a Finished message must be encrypted under the appropriate application traffic key, including alerts sent by the server in response to client messages."
202,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected')
203,Post-Handshake Messages,TLS allows other messages to be sent after the main handshake. These messages use a handshake content type and are encrypted under the appropriate application traffic key.
204,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected')
205,Post-Handshake Authentication Extension,"When the client has sent the ""post_handshake_auth"" extension, a server may request client authentication at any time after the handshake has completed by sending a CertificateRequest message."
206,Client Response Requirements,"The client must respond with the appropriate Authentication messages. If the client chooses to authenticate, it must send Certificate, CertificateVerify, and Finished. If it declines, it must send a Certificate message containing no certificates followed by Finished."
207,Message Order for Client Responses,All of the client's messages for a given response must appear consecutively on the wire with no intervening messages of other types.
208,Handling Unexpected Certificate Requests,"A client that receives a CertificateRequest message without having sent the ""post_handshake_auth"" extension must send an ""unexpected_message"" fatal alert."
209,Server Readiness for Delays,"Because client authentication could involve prompting the user, servers must be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response."
210,Response Order for Multiple Requests,"Clients which receive multiple CertificateRequests in close succession may respond to them in a different order than they were received, as the certificate_request_context value allows the server to disambiguate the responses."
211,KeyUpdate Message Purpose,The KeyUpdate handshake message indicates that the sender is updating its sending cryptographic keys. This message can be sent by either peer after it has sent a Finished message.
212,Handling Unexpected KeyUpdate,"Implementations that receive a KeyUpdate message prior to receiving a Finished message must terminate the connection with an ""unexpected_message"" alert."
213,KeyUpdate Message Protocol,"After sending a KeyUpdate message, the sender shall use the next generation of keys. Upon receiving a KeyUpdate, the receiver must update its receiving keys."
214,KeyUpdateRequest Enumeration,"The KeyUpdateRequest enum indicates whether the recipient should respond with its own KeyUpdate, with values for update_not_requested and update_requested."
215,Response Mechanism for KeyUpdate,"If request_update is set to ""update_requested,"" the receiver must send a KeyUpdate of its own with request_update set to ""update_not_requested"" before sending its next Application Data record."
216,Handling Multiple KeyUpdates,"Implementations may receive multiple messages between sending a KeyUpdate and receiving the peer's KeyUpdate, but retaining the receive traffic secret ensures forward secrecy."
217,Crossing KeyUpdates,"If both sides send their own KeyUpdates with request_update set to ""update_requested"" and they cross in flight, each side will send a response, incrementing by two generations."
218,Encryption Requirement for KeyUpdate,Both sender and receiver must encrypt KeyUpdate messages with the old keys and ensure that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key to prevent message truncation attacks.
