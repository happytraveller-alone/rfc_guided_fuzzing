ID,Title,Content,RuleMatch,ExtractedRule,SlicedRule
1,Handshake Protocol Overview,"The handshake protocol is used to negotiate the security parameters of a connection. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext or TLSCiphertext structures which are processed and transmitted as specified by the current active connection state.",0,Skip,Skip
2,Handshake Message Types,"The enum defines various handshake message types, including client_hello, server_hello, new_session_ticket, end_of_early_data, encrypted_extensions, certificate, certificate_request, certificate_verify, finished, key_update, and message_hash.",0,Skip,Skip
3,Structure of Handshake Messages,"The struct describes the format of handshake messages, which includes a message type, length, and a selection of message-specific structures based on the message type.",0,Skip,Skip
4,Order of Protocol Messages,Protocol messages must be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2.,1,<CMC> <1> (Clients MUST send protocol messages in the order defined in Section 4.4.1.) + <SMP> <1> (Servers MUST process protocol messages in the order defined in Section 4.4.1.),<CMC> <1> (Clients MUST send protocol messages in the order defined in Section 4.4.1.) + <SMP> <1> (Servers MUST process protocol messages in the order defined in Section 4.4.1.)
5,Handling Unexpected Message Orders,"A peer that receives a handshake message in an unexpected order must abort the handshake with an ""unexpected_message"" alert.",1,"<CMC> <1> (Clients MUST abort the handshake with an ""unexpected_message"" alert if they receive a handshake message in an unexpected order.) + <SMP> <1> (Servers MUST abort the handshake with an ""unexpected_message"" alert if they receive a handshake message in an unexpected order.)","<CMC> <1> (Clients MUST abort the handshake with an ""unexpected_message"" alert if they receive a handshake message in an unexpected order.) + <SMP> <1> (Servers MUST abort the handshake with an ""unexpected_message"" alert if they receive a handshake message in an unexpected order.)"
6,Assignment of New Message Types,New handshake message types are assigned by IANA as described in Section 11.,0,Skip,Skip
7,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip
8,ClientHello Options,"In TLS, the cryptographic negotiation proceeds by the client offering four sets of options in its ClientHello: a list of cipher suites, a ""supported_groups"" extension indicating (EC)DHE groups, a ""signature_algorithms"" extension, and a ""pre_shared_key"" extension with symmetric key identities.",0,Skip,Skip
9,Server Parameter Selection,"If the server does not select a PSK, it independently selects a cipher suite, (EC)DHE group, key share, and signature algorithm/certificate pair. If there's no overlap in ""supported_groups,"" the handshake must abort with a ""handshake_failure"" or ""insufficient_security"" alert.",1,"<SMC> <1> (Servers MUST independently select a cipher suite, (EC)DHE group, key share, and signature algorithm/certificate pair if no PSK is selected.) + <CMP> <1> (Clients MUST abort the handshake with a ""handshake_failure"" or ""insufficient_security"" alert if there's no overlap in ""supported_groups."")","<SMC> <1> (Servers MUST independently select a cipher suite, (EC)DHE group, key share, and signature algorithm/certificate pair if no PSK is selected.) + <CMP> <1> (Clients MUST abort the handshake with a ""handshake_failure"" or ""insufficient_security"" alert if there's no overlap in ""supported_groups."")"
10,PSK and Key Exchange Modes,"If the server selects a PSK, it must also choose a key establishment mode from the client's ""psk_key_exchange_modes"" extension. Non-overlap in ""supported_groups"" is not fatal if PSK can be used without (EC)DHE.",1,"<SMC> <1> (Servers MUST choose a key establishment mode from the client's ""psk_key_exchange_modes"" extension if a PSK is selected.) + <CMP> <0> (Clients MUST allow PSK to be used without (EC)DHE even if there is non-overlap in ""supported_groups"".)","<SMC> <1> (Servers MUST choose a key establishment mode from the client's ""psk_key_exchange_modes"" extension if a PSK is selected.) + <CMP> <0> (Clients MUST allow PSK to be used without (EC)"
11,HelloRetryRequest Requirement,"If the server selects an (EC)DHE group without a compatible ""key_share"" from the client, it must respond with a HelloRetryRequest message.",1,"<SMC> <1> (Servers MUST respond with a HelloRetryRequest if an (EC)DHE group is selected without a compatible ""key_share"" from the client.) + <CMP> <0> (Clients MUST handle a HelloRetryRequest from the server when a compatible ""key_share"" is not provided.)","<SMC> <1> (Servers MUST respond with a HelloRetryRequest if an (EC)DHE group is selected without a compatible ""key_share"" from the client.) + <CMP> <0> (Clients MUST handle a HelloRetryRequest from the server when a compatible ""key_share"" is not provided.)"
12,ServerHello Parameter Indication,"Upon successful parameter selection, the server indicates the selected parameters in the ServerHello, sending a ""pre_shared_key"" extension if PSK is used, and a ""key_share"" extension when (EC)DHE is in use. Authentication via certificate involves sending Certificate and CertificateVerify messages.",0,Skip,Skip
13,Handshake Abortion Conditions,"If the server fails to negotiate a supported set of parameters, it must abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert.",1,"<SMC> <1> (Servers MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert if they fail to negotiate a supported set of parameters.) + <CMP> <0> (Clients MUST be prepared to handle a ""handshake_failure"" or ""insufficient_security"" fatal alert during the handshake.)","<SMC> <1> (Servers MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert if they fail to negotiate a supported set of parameters.) + <CMP> <0> (Clients MUST be prepared to handle a ""handshake_failure"" or ""insufficient_security"" fatal alert during the handshake.)"
14,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip
15,Server Hello Response,The server sends the ServerHello message in response to a ClientHello message to proceed with the handshake if it can negotiate acceptable handshake parameters.,0,Skip,Skip
16,Structure of ServerHello Message,"The ServerHello message structure includes fields for legacy_version, random, legacy_session_id_echo, cipher_suite, legacy_compression_method, and extensions.",0,Skip,Skip
17,Legacy Version Explanation,"The legacy_version field was previously used for version negotiation but is now set to 0x0303 for TLS 1.2. TLS 1.3 servers indicate their version using the ""supported_versions"" extension.",0,Skip,Skip
18,Random Value Generation,"The random field consists of 32 bytes generated by a secure random number generator, with specific requirements on the last 8 bytes based on the negotiated TLS version.",0,Skip,Skip
19,Session ID Echo,"legacy_session_id_echo contains the client's session ID, which must match the client's sent value; otherwise, the handshake is aborted with an ""illegal_parameter"" alert.",1,"<CMC> <1> (Clients' session ID in legacy_session_id_echo MUST match the sent value.) + <SMP> <1> (Servers MUST abort the handshake with an ""illegal_parameter"" alert if the session ID does not match.)","<CMC> <1> (Clients' session ID in legacy_session_id_echo MUST match the sent value.) + <SMP> <1> (Servers MUST abort the handshake with an ""illegal_parameter"" alert if the session ID does not match.)"
20,Cipher Suite Selection,"The cipher_suite field contains the single cipher suite selected by the server from the client's offered list, and a mismatch results in an ""illegal_parameter"" alert.",0,Skip,Skip
21,Compression Method,The legacy_compression_method field must always have the value 0.,1,<CMC> <1> (Clients MUST set the legacy_compression_method field to 0.) + <SMP> <0> (Servers MUST accept the legacy_compression_method field with the value 0.),<CMC> <1> (Clients MUST set the legacy_compression_method field to 0.) + <SMP> <0> (Servers MUST accept the legacy_compression_method field with the value 0.)
22,Extensions Requirements,"The extensions field must include only those necessary for establishing the cryptographic context and must contain the ""supported_versions"" extension in all TLS 1.3 messages.",1,"```
<CMC> <1> (Clients MUST include only necessary extensions for establishing the cryptographic context and MUST contain the ""supported_versions"" extension in all TLS 1.3 messages.) + <SMP> <1> (Servers MUST process only necessary extensions for establishing the cryptographic context and MUST expect the ""supported_versions"" extension in all TLS 1.3 messages.)
```","<CMC> <1> (Clients MUST include only necessary extensions for establishing the cryptographic context and MUST contain the ""supported_versions"" extension in all TLS 1.3 messages.) + <SMP> <1> (Servers MUST process only necessary extensions for establishing the cryptographic context and MUST expect the ""supported_versions"" extension in all TLS 1.3 messages.)"
23,HelloRetryRequest Structure,The HelloRetryRequest message uses the same structure as ServerHello but sets the Random value to a predefined SHA-256 hash for backward compatibility with middleboxes.,0,Skip,Skip
24,Random Value Check,"Upon receiving a server_hello message, implementations must check if the Random value matches specific criteria related to downgrade protection.",1,<SMC> <1> (Servers MUST check if the Random value in the server_hello message matches specific criteria related to downgrade protection.) + <CMP> <0> (Clients MUST verify the Random value in the server_hello message for downgrade protection compliance.),<SMC> <1> (Servers MUST check if the Random value in the server_hello message matches specific criteria related to downgrade protection.) + <CMP> <0> (Clients MUST verify the Random value in the server_hello message for downgrade protection compliance.)
25,Downgrade Protection Mechanism,TLS 1.3 servers negotiating TLS 1.2 or below must set the last 8 bytes of the Random value to specific values to provide downgrade protection against attacks.,1,<SMC> <1> (Servers negotiating TLS 1.2 or below MUST set the last 8 bytes of the Random value to specific values for downgrade protection.) + <CMP> <0> (Clients MUST verify that the last 8 bytes of the Random value are set to the specific values for downgrade protection.),<SMC> <1> (Servers negotiating TLS 1.2 or below MUST set the last 8 bytes of the Random value to specific values for downgrade protection.) + <CMP> <0> (Clients MUST verify that the last 8 bytes of the Random value are set to the specific values for downgrade protection.)
26,Client Checks for Downgrade,"TLS 1.3 clients must verify the last 8 bytes of the Random value to prevent downgrade attacks, and if a match is found, they must abort the handshake with an ""illegal_parameter"" alert.",1,"<CMC> <1> (Clients MUST verify the last 8 bytes of the Random value to prevent downgrade attacks.) + <SMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if a match is found.)","<CMC> <1> (Clients MUST verify the last 8 bytes of the Random value to prevent downgrade attacks.) + <SMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if a match is found.)"
27,Renegotiation Handling,"A legacy TLS client receiving a TLS 1.3 ServerHello during renegotiation must abort the handshake with a ""protocol_version"" alert, as renegotiation is not possible in TLS 1.3.",1,"<CMC> <1> (A legacy TLS client MUST abort the handshake with a ""protocol_version"" alert upon receiving a TLS 1.3 ServerHello during renegotiation.) + <SMP> <0> (Servers MUST not expect renegotiation in TLS 1.3.)","<CMC> <1> (A legacy TLS client MUST abort the handshake with a ""protocol_version"" alert upon receiving a TLS 1.3 ServerHello during renegotiation.) + <SMP> <0> (Servers MUST not expect renegotiation in TLS 1.3.)"
28,Hello Retry Request Purpose,The server sends a HelloRetryRequest in response to a ClientHello message when it finds acceptable parameters but requires more information to proceed with the handshake. This message has the same format as a ServerHello message.,0,Skip,Skip
29,Extensions in Hello Retry Request,"The server's extensions must include ""supported_versions"" and may optionally include the ""cookie"" extension. It must not contain any extensions not first offered by the client, except for ""cookie.""",1,"<SMC> <1> (Servers MUST include the ""supported_versions"" extension in their extensions.) + <CMP> <1> (Clients MUST offer the ""supported_versions"" extension in their ClientHello.)
<SMC> <1> (Servers MAY optionally include the ""cookie"" extension in their extensions.) + <CMP> <1> (Clients MAY include the ""cookie"" extension in their ClientHello.)
<SMC> <1> (Servers MUST NOT include any extensions not first offered by the client, except for ""cookie."") + <CMP> <1> (Clients MUST offer extensions that the server can include.)","<SMC> <1> (Servers MUST include the ""supported_versions"" extension in their extensions.) + <CMP> <1> (Clients MUST offer the ""supported_versions"" extension in their ClientHello.)"
,,,,,"<SMC> <1> (Servers MAY optionally include the ""cookie"" extension in their extensions.) + <CMP> <1> (Clients MAY include the ""cookie"" extension in their ClientHello.)"
,,,,,"<SMC> <1> (Servers MUST NOT include any extensions not first offered by the client, except for ""cookie."") + <CMP> <1> (Clients MUST offer extensions that the server can include.)"
30,Client Actions on Hello Retry Request,"Upon receiving a HelloRetryRequest, the client must check specific fields and process the extensions, starting with ""supported_versions."" It must abort the handshake with an ""illegal_parameter"" alert if no changes result from the HelloRetryRequest.",1,"<CMC> <1> (Clients MUST check specific fields and process the extensions upon receiving a HelloRetryRequest, starting with ""supported_versions."") + <CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if no changes result from the HelloRetryRequest.)","<CMC> <1> (Clients MUST check specific fields and process the extensions upon receiving a HelloRetryRequest, starting with ""supported_versions."") + <CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if no changes result from the HelloRetryRequest.)"
31,Handling Multiple Hello Retry Requests,"If a client receives a second HelloRetryRequest in the same connection, it must abort the handshake with an ""unexpected_message"" alert.",1,"<CMC> <1> (Clients MUST abort the handshake with an ""unexpected_message"" alert upon receiving a second HelloRetryRequest in the same connection.) + <SMP> <0> (Servers MUST not send a second HelloRetryRequest in the same connection.)","<CMC> <1> (Clients MUST abort the handshake with an ""unexpected_message"" alert upon receiving a second HelloRetryRequest in the same connection.) + <SMP> <0> (Servers MUST not send a second HelloRetryRequest in the same connection.)"
32,Cipher Suite Negotiation,A client must abort the handshake if it receives a cipher suite not offered earlier. Servers must negotiate the same cipher suite when receiving an updated ClientHello.,1,<CMC> <1> (Clients MUST abort the handshake if they receive a cipher suite not offered earlier.) + <SMP> <1> (Servers MUST negotiate the same cipher suite when receiving an updated ClientHello.),<CMC> <1> (Clients MUST abort the handshake if they receive a cipher suite not offered earlier.) + <SMP> <1> (Servers MUST negotiate the same cipher suite when receiving an updated ClientHello.)
33,Selected Version Consistency,"The selected_version in the HelloRetryRequest must be retained in the ServerHello; otherwise, the client must abort the handshake with an ""illegal_parameter"" alert.",1,"<SMC> <1> (Servers MUST retain the selected_version from the HelloRetryRequest in the ServerHello.) + <CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the selected_version is not retained in the ServerHello.)","<SMC> <1> (Servers MUST retain the selected_version from the HelloRetryRequest in the ServerHello.) + <CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the selected_version is not retained in the ServerHello.)"
34,ClientHello Update Guidelines,"In its updated ClientHello, the client should avoid offering pre-shared keys associated with different hashes than that of the selected cipher suite to prevent unnecessary computations.",0,Skip,Skip
35,TLS Extensions Structure,"A number of TLS messages contain tag-length-value encoded extensions structures. The structure includes an ""extension_type"" to identify the extension and ""extension_data"" for specific information related to the extension type.",0,Skip,Skip
36,Extension Types,"The list of extension types, including server_name, max_fragment_length, and others, is maintained by IANA as described in Section 11.",0,Skip,Skip
37,Request/Response Model,Extensions are generally structured in a request/response manner. The client sends extension requests in the ClientHello message while the server responds in various messages such as ServerHello and Certificate.,0,Skip,Skip
38,Unsolicited Extensions,"The server may send unsolicited extensions in the NewSessionTicket, which the client does not respond to directly.",0,Skip,Skip
39,Handling Extension Responses,"Implementations must not send extension responses if the corresponding requests were not received, except for the ""cookie"" extension in HelloRetryRequest, which may lead to an ""unsupported_extension"" alert if violated.",1,"<SMC> <1> (Servers MUST not send extension responses if the corresponding requests were not received, except for the ""cookie"" extension in HelloRetryRequest.) + <CMP> <1> (Clients MAY receive an ""unsupported_extension"" alert if the server violates the rule regarding extension responses.)","<SMC> <1> (Servers MUST not send extension responses if the corresponding requests were not received, except for the ""cookie"" extension in HelloRetryRequest.) + <CMP> <1> (Clients MAY receive an ""unsupported_extension"" alert if the server violates the rule regarding extension responses.)"
40,Extension Message Restrictions,"If an implementation receives an extension not specified for the message, it must abort the handshake with an ""illegal_parameter"" alert.",1,"<CMC> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if an extension not specified for the message is received.) + <SMP> <0> (Servers MUST not accept extensions not specified for the message and must trigger an abort with an ""illegal_parameter"" alert.)","<CMC> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if an extension not specified for the message is received.) + <SMP> <0> (Servers MUST not accept extensions not specified for the message and must trigger an abort with an ""illegal_parameter"" alert.)"
41,Extension Message Availability,"A table indicates where each extension may appear, using notations like CH (ClientHello) and SH (ServerHello).",0,Skip,Skip
42,Order of Extensions,"When multiple extensions are present, they may appear in any order, except for ""pre_shared_key,"" which must be last in ClientHello. No more than one extension of the same type may exist in a block.",1,"<CMC> <1> (Clients MAY include multiple extensions in any order, except for ""pre_shared_key,"" which MUST be last in the ClientHello.) + <SMP> <1> (Servers MUST process multiple extensions in any order, except for ""pre_shared_key,"" which MUST be last in the ClientHello.)
<CMC> <1> (Clients MUST not include more than one extension of the same type in a block.) + <SMP> <1> (Servers MUST reject multiple extensions of the same type in a block.)","<CMC> <1> (Clients MAY include multiple extensions in any order, except for ""pre_shared_key,"" which MUST be last in the ClientHello.) + <SMP> <1> (Servers MUST process multiple extensions in any order, except for ""pre_shared_key,"" which MUST be last in the ClientHello.)"
,,,,,<CMC> <1> (Clients MUST not include more than one extension of the same type in a block.) + <SMP> <1> (Servers MUST reject multiple extensions of the same type in a block.)
43,Negotiation in TLS 1.3,"In TLS 1.3, extensions are negotiated for each handshake, even in resumption-PSK mode, differing from TLS 1.2.",0,Skip,Skip
44,Security Considerations,Designers should consider security implications when introducing new extensions to prevent attacks that manipulate handshake messages.,0,Skip,Skip
45,Error Handling in Extensions,"Error conditions and refusals to support features should be handled properly, using appropriate alerts for errors and fields in responses for refusals.",0,Skip,Skip
46,Integrity of Handshake Phase,"Designers must ensure that extensions do not compromise security, especially since active attackers can modify messages until the handshake is authenticated.",1,<CMC> <1> (Designers MUST ensure that extensions do not compromise security during the handshake.) + <SMP> <0> (Servers MUST handle extensions in a way that maintains security integrity until the handshake is authenticated.),<CMC> <1> (Designers MUST ensure that extensions do not compromise security during the handshake.) + <SMP> <0> (Servers MUST handle extensions in a way that maintains security integrity until the handshake is authenticated.)
47,Supported Versions Extension Purpose,"The ""supported_versions"" extension is used by the client to indicate which versions of TLS it supports and by the server to indicate the version it is using. The extension contains a list of supported versions in preference order, with the most preferred version first.",0,Skip,Skip
48,ClientHello Requirements,"Implementations of this specification must send the ""supported_versions"" extension in the ClientHello, containing all versions of TLS they are prepared to negotiate, minimally including 0x0304. Previous versions of TLS must also be included if allowed.",1,"<CMC> <1> (Clients MUST send the ""supported_versions"" extension in the ClientHello, containing all versions of TLS they are prepared to negotiate, minimally including 0x0304.) + <SMP> <0> (Servers MUST accept the ""supported_versions"" extension in the ClientHello, containing all versions of TLS prepared for negotiation.)  
<CMC> <1> (Clients MUST include previous versions of TLS if allowed.) + <SMP> <0> (Servers MUST accept previous versions of TLS included in the ""supported_versions"" extension if allowed.)","<CMC> <1> (Clients MUST send the ""supported_versions"" extension in the ClientHello, containing all versions of TLS they are prepared to negotiate, minimally including 0x0304.) + <SMP> <0> (Servers MUST accept the ""supported_versions"" extension in the ClientHello, containing all versions of TLS prepared for negotiation.)"
,,,,,"<CMC> <1> (Clients MUST include previous versions of TLS if allowed.) + <SMP> <0> (Servers MUST accept previous versions of TLS included in the ""supported_versions"" extension if allowed.)"
49,Server Behavior Without Extension,"If the ""supported_versions"" extension is not present, compliant servers supporting TLS 1.2 must negotiate TLS 1.2 or prior, regardless of the ClientHello.legacy_version value. Servers may abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.",1,"<SMC> <1> (Servers MUST negotiate TLS 1.2 or prior if the ""supported_versions"" extension is not present, regardless of the ClientHello.legacy_version value.) + <CMP> <1> (Clients MAY include legacy_version 0x0304 or later in the ClientHello, but servers may abort the handshake upon receiving such a value.)  
<SMC> <1> (Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.) + <CMP> <1> (Clients MUST be aware that their legacy_version could lead to handshake abortion if it is 0x0304 or later.)","<SMC> <1> (Servers MUST negotiate TLS 1.2 or prior if the ""supported_versions"" extension is not present, regardless of the ClientHello.legacy_version value.) + <CMP> <1> (Clients MAY include legacy_version 0x0304 or later in the ClientHello, but servers may abort the handshake upon receiving such a value.)"
,,,,,<SMC> <1> (Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.) + <CMP> <1> (Clients MUST be aware that their legacy_version could lead to handshake abortion if it is 0x0304 or later.)
50,Version Negotiation with Extension,"If the extension is present in the ClientHello, servers must not use the ClientHello.legacy_version for version negotiation and must rely solely on the ""supported_versions"" extension. They must select only a version present in this extension and ignore any unknown versions.",1,"<CMC> <1> (Clients MUST include the ""supported_versions"" extension for version negotiation.) + <SMP> <1> (Servers MUST rely solely on the ""supported_versions"" extension and must not use ClientHello.legacy_version for version negotiation.)  
<SMC> <1> (Servers MUST select only a version present in the ""supported_versions"" extension.) + <CMP> <1> (Clients MUST ensure only known versions are included in the ""supported_versions"" extension.)","<CMC> <1> (Clients MUST include the ""supported_versions"" extension for version negotiation.) + <SMP> <1> (Servers MUST rely solely on the ""supported_versions"" extension and must not use ClientHello.legacy_version for version negotiation.)"
,,,,,"<SMC> <1> (Servers MUST select only a version present in the ""supported_versions"" extension.) + <CMP> <1> (Clients MUST ensure only known versions are included in the ""supported_versions"" extension.)"
51,Server Response Based on Negotiated Version,"A server negotiating a version prior to TLS 1.3 must set ServerHello.version and not send the ""supported_versions"" extension. If negotiating TLS 1.3, the server must send a ""supported_versions"" extension with the selected version value (0x0304) and set ServerHello.legacy_version to 0x0303 (TLS 1.2). Clients must check for this extension before processing the rest of the ServerHello.",1,"```
<SMC> <1> (Servers MUST set ServerHello.version to a version prior to TLS 1.3 and not send the ""supported_versions"" extension when negotiating that version.) + <CMP> <1> (Clients MUST check for the ""supported_versions"" extension before processing the rest of the ServerHello.)
<SMC> <1> (Servers MUST send a ""supported_versions"" extension with the selected version value (0x0304) when negotiating TLS 1.3.) + <CMP> <1> (Clients MUST check for the ""supported_versions"" extension before processing the rest of the ServerHello.)
<SMC> <1> (Servers MUST set ServerHello.legacy_version to 0x0303 (TLS 1.2) when negotiating TLS 1.3.) + <CMP> <1> (Clients MUST check for the ""supported_versions"" extension before processing the rest of the ServerHello.)
```","<SMC> <1> (Servers MUST set ServerHello.version to a version prior to TLS 1.3 and not send the ""supported_versions"" extension when negotiating that version.) + <CMP> <1> (Clients MUST check for the ""supported_versions"" extension before processing the rest of the ServerHello.)"
,,,,,"<SMC> <1> (Servers MUST send a ""supported_versions"" extension with the selected version value (0x0304) when negotiating TLS 1.3.) + <CMP> <1> (Clients MUST check for the ""supported_versions"" extension before processing the rest of the ServerHello.)"
,,,,,"<SMC> <1> (Servers MUST set ServerHello.legacy_version to 0x0303 (TLS 1.2) when negotiating TLS 1.3.) + <CMP> <1> (Clients MUST check for the ""supported_versions"" extension before processing the rest of the ServerHello.)"
52,Client Validation of Selected Version,"If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or a version prior to TLS 1.3, the client must abort the handshake with an ""illegal_parameter"" alert.",1,"<CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the ""supported_versions"" extension in the ServerHello contains a version not offered by the client.) + <SMC> <1> (Servers MUST include only versions offered by the client in the ""supported_versions"" extension in the ServerHello.)  
<CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the ""supported_versions"" extension contains a version prior to TLS 1.3.) + <SMC> <1> (Servers MUST NOT include versions prior to TLS 1.3 in the ""supported_versions"" extension in the ServerHello.)","<CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the ""supported_versions"" extension in the ServerHello contains a version not offered by the client.) + <SMC> <1> (Servers MUST include only versions offered by the client in the ""supported_versions"" extension in the ServerHello.)"
,,,,,"<CMP> <1> (Clients MUST abort the handshake with an ""illegal_parameter"" alert if the ""supported_versions"" extension contains a version prior to TLS 1.3.) + <SMC> <1> (Servers MUST NOT include versions prior to TLS 1.3 in the ""supported_versions"" extension in the ServerHello.)"
53,Cookie Structure Definition,The cookie structure is defined as an opaque value of size between 1 and 65535 bytes.,0,Skip,Skip
54,Purpose of Cookies,"Cookies serve two primary purposes: enabling the server to require the client to demonstrate reachability for DoS protection and allowing the server to offload state to the client, facilitating a HelloRetryRequest without storing state.",0,Skip,Skip
55,HelloRetryRequest and Cookie Extension,"When sending a HelloRetryRequest, the server may provide a ""cookie"" extension, deviating from the usual rule that only ClientHello extensions may be sent.",0,Skip,Skip
56,ClientHello Cookie Requirement,The client must include the cookie extension received in the HelloRetryRequest in the new ClientHello. Clients must not use cookies in their initial ClientHello for subsequent connections.,1,"<CMC> <1> (Clients MUST include the cookie extension received in the HelloRetryRequest in the new ClientHello.) + <SMP> <1> (Servers MUST accept the cookie extension included in the new ClientHello.)  
<CMC> <1> (Clients MUST NOT use cookies in their initial ClientHello for subsequent connections.) + <SMP> <0> (Servers MUST not expect cookies in the initial ClientHello for subsequent connections.)",<CMC> <1> (Clients MUST include the cookie extension received in the HelloRetryRequest in the new ClientHello.) + <SMP> <1> (Servers MUST accept the cookie extension included in the new ClientHello.)
,,,,,<CMC> <1> (Clients MUST NOT use cookies in their initial ClientHello for subsequent connections.) + <SMP> <0> (Servers MUST not expect cookies in the initial ClientHello for subsequent connections.)
57,Stateless Server Behavior,"A stateless server may receive an unprotected record of type change_cipher_spec between ClientHello messages and must ignore these records, as it does not retain any state.",1,"<SMC> <1> (Servers MUST ignore unprotected change_cipher_spec records received between ClientHello messages, as they do not retain state.) + <CMP> <0> (Clients MAY send unprotected change_cipher_spec records between ClientHello messages, but servers MUST ignore them.)","<SMC> <1> (Servers MUST ignore unprotected change_cipher_spec records received between ClientHello messages, as they do not retain state.) + <CMP> <0> (Clients MAY send unprotected change_cipher_spec records between ClientHello messages, but servers MUST ignore them.)"
58,Signature Algorithm Extensions in TLS 1.3,"TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures: ""signature_algorithms_cert"" for certificate signatures and ""signature_algorithms"" for CertificateVerify messages.",0,Skip,Skip
59,Key Compatibility Requirement,"The keys found in certificates must be of appropriate type for the signature algorithms used, particularly concerning RSA keys and PSS signatures.",1,"<SMC> <1> (Servers MUST ensure that the keys found in certificates are of appropriate type for the signature algorithms used.) + <CMP> <0> (Clients MUST use appropriate key types that match the signature algorithms, particularly for RSA keys and PSS signatures.)","<SMC> <1> (Servers MUST ensure that the keys found in certificates are of appropriate type for the signature algorithms used.) + <CMP> <0> (Clients MUST use appropriate key types that match the signature algorithms, particularly for RSA keys and PSS signatures.)"
60,Client Authentication Requirement,"Clients desiring server authentication via a certificate must send the ""signature_algorithms"" extension; otherwise, the server must abort the handshake with a ""missing_extension"" alert.",1,"<CMC> <1> (Clients MUST send the ""signature_algorithms"" extension for server authentication via a certificate.) + <SMP> <1> (Servers MUST abort the handshake with a ""missing_extension"" alert if the ""signature_algorithms"" extension is not present.)","<CMC> <1> (Clients MUST send the ""signature_algorithms"" extension for server authentication via a certificate.) + <SMP> <1> (Servers MUST abort the handshake with a ""missing_extension"" alert if the ""signature_algorithms"" extension is not present.)"
61,"Purpose of ""signature_algorithms_cert""","The ""signature_algorithms_cert"" extension allows implementations to clearly signal their capabilities regarding different sets of algorithms for certificates and TLS.",0,Skip,Skip
62,SignatureScheme List Structure,"The ""extension_data"" field of these extensions contains a SignatureSchemeList value, which lists supported signature algorithms in descending order of preference.",0,Skip,Skip
63,Signature Algorithm Types and Descriptions,"Various signature algorithms are defined, including RSASSA-PKCS1-v1_5, ECDSA, and EdDSA, each with specific requirements regarding their use and parameters.",0,Skip,Skip
64,Deprecation of Legacy Algorithms,"Legacy algorithms using SHA-1 are being deprecated; clients must list these as lower priority, and TLS 1.3 servers must not offer SHA-1 signed certificates unless unavoidable.",1,<CMC> <1> (Clients MUST list SHA-1 algorithms as lower priority.) + <SMP> <1> (Servers MUST NOT offer SHA-1 signed certificates unless unavoidable.),<CMC> <1> (Clients MUST list SHA-1 algorithms as lower priority.) + <SMP> <1> (Servers MUST NOT offer SHA-1 signed certificates unless unavoidable.)
65,Self-Signed Certificate Validation,"Signatures on self-signed certificates or trust anchors are not validated, as they initiate a certification path and may use unsupported signature algorithms.",0,Skip,Skip
66,Compatibility with TLS 1.2,"TLS 1.3 implementations negotiating TLS 1.2 must adhere to its requirements, including the ability to negotiate without the ""signature_algorithms"" extension and accept legacy signature pairs.",1,"<SMC> <1> (Servers negotiating TLS 1.2 MUST adhere to its requirements, including the ability to accept legacy signature pairs.) + <CMP> <1> (Clients negotiating TLS 1.2 MUST adhere to its requirements, including the ability to negotiate without the ""signature_algorithms"" extension.)","<SMC> <1> (Servers negotiating TLS 1.2 MUST adhere to its requirements, including the ability to accept legacy signature pairs.) + <CMP> <1> (Clients negotiating TLS 1.2 MUST adhere to its requirements, including the ability to negotiate without the ""signature_algorithms"" extension.)"
67,Certificate Authorities Extension Purpose,"The ""certificate_authorities"" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which should guide certificate selection by the receiving endpoint.",0,Skip,Skip
68,Certificate Authorities Extension Structure,"The body of the ""certificate_authorities"" extension consists of a CertificateAuthoritiesExtension structure, which includes a list of distinguished names of acceptable certificate authorities.",0,Skip,Skip
69,Distinguished Name Representation,"The authorities are represented in DER-encoded format and specify desired distinguished names for trust anchors or subordinate CAs, helping to describe known trust anchors and authorization spaces.",0,Skip,Skip
70,Client and Server Usage,"The client may send the ""certificate_authorities"" extension in the ClientHello message, while the server may send it in the CertificateRequest message.",0,Skip,Skip
71,Non-usage of Trusted CA Keys Extension,"The ""trusted_ca_keys"" extension, which serves a similar purpose but is more complicated, is not used in TLS 1.3, although it may appear in ClientHello messages from clients offering prior versions of TLS.",0,Skip,Skip
72,OID Filters Purpose,"The ""oid_filters"" extension allows servers to provide a set of OID/value pairs that the client's certificate should match. This extension must only be sent in the CertificateRequest message if provided by the server.",1,"<SMC> <1> (Servers MUST send the ""oid_filters"" extension in the CertificateRequest message only if provided.) + <CMP> <1> (Clients MUST match their certificate against the OID/value pairs provided in the ""oid_filters"" extension.)","<SMC> <1> (Servers MUST send the ""oid_filters"" extension in the CertificateRequest message only if provided.) + <CMP> <1> (Clients MUST match their certificate against the OID/value pairs provided in the ""oid_filters"" extension.)"
73,OIDFilter Structure,"The OIDFilter structure consists of two fields: `certificate_extension_oid` and `certificate_extension_values`, which represent the OID and its corresponding values.",0,Skip,Skip
74,Filters List Requirement,"Filters must be a list of certificate extension OIDs with their allowed values in DER-encoded format. If the server includes a non-empty filters list, the client certificate must contain all specified extension OIDs that the client recognizes.",1,<SMC> <1> (Servers MUST include a non-empty filters list of certificate extension OIDs with allowed values in DER-encoded format.) + <CMP> <1> (Clients MUST ensure that the client certificate contains all specified extension OIDs that they recognize.),<SMC> <1> (Servers MUST include a non-empty filters list of certificate extension OIDs with allowed values in DER-encoded format.) + <CMP> <1> (Clients MUST ensure that the client certificate contains all specified extension OIDs that they recognize.)
75,Client Certificate Validation,"For each recognized extension OID, all specified values must be present in the client certificate. The client may include additional values but must ignore unrecognized OIDs.",1,<CMC> <1> (Clients MUST include all specified values for recognized extension OIDs in the client certificate.) + <SMP> <0> (Servers MUST accept client certificates that include additional values but ignore unrecognized OIDs.),<CMC> <1> (Clients MUST include all specified values for recognized extension OIDs in the client certificate.) + <SMP> <0> (Servers MUST accept client certificates that include additional values but ignore unrecognized OIDs.)
76,Server Actions on Mismatch,"If the client ignores required extension OIDs and provides a non-compliant certificate, the server may either continue without client authentication or abort the handshake with an ""unsupported_certificate"" alert.",1,"<CMC> <1> (Clients MUST NOT ignore required extension OIDs and MUST provide a compliant certificate.) + <SMP> <1> (Servers MAY continue without client authentication if required extensions are ignored.)  
<CMC> <1> (Clients MUST NOT provide a non-compliant certificate.) + <SMP> <1> (Servers MAY abort the handshake with an ""unsupported_certificate"" alert if a non-compliant certificate is provided.)",<CMC> <1> (Clients MUST NOT ignore required extension OIDs and MUST provide a compliant certificate.) + <SMP> <1> (Servers MAY continue without client authentication if required extensions are ignored.)
,,,,,"<CMC> <1> (Clients MUST NOT provide a non-compliant certificate.) + <SMP> <1> (Servers MAY abort the handshake with an ""unsupported_certificate"" alert if a non-compliant certificate is provided.)"
77,Unique OID Requirement,Each OID must not appear more than once in the filters list.,1,<CMC> <1> (Clients MUST ensure that each OID appears only once in the filters list.) + <SMP> <0> (Servers MUST reject the filters list if an OID appears more than once.),<CMC> <1> (Clients MUST ensure that each OID appears only once in the filters list.) + <SMP> <0> (Servers MUST reject the filters list if an OID appears more than once.)
78,PKI Library Dependency,TLS implementations are expected to rely on their PKI libraries to perform certificate selection using the defined OID filters.,0,Skip,Skip
79,Matching Rules for Key Usages,"The document defines matching rules for the Key Usage and Extended Key Usage extensions, requiring that all asserted bits or OIDs in the request be present in the corresponding certificate extensions.",0,Skip,Skip
80,Exclusion of anyExtendedKeyUsage,The special anyExtendedKeyUsage OID must not be used in the request for Extended Key Usage.,1,<CMC> <1> (Clients MUST NOT use the special anyExtendedKeyUsage OID in the request for Extended Key Usage.) + <SMP> <0> (Servers MUST reject requests that include the anyExtendedKeyUsage OID in Extended Key Usage.),<CMC> <1> (Clients MUST NOT use the special anyExtendedKeyUsage OID in the request for Extended Key Usage.) + <SMP> <0> (Servers MUST reject requests that include the anyExtendedKeyUsage OID in Extended Key Usage.)
81,Potential for Additional Specifications,Separate specifications may define matching rules for other certificate extensions.,0,Skip,Skip
82,Post-Handshake Authentication Extension Purpose,"The ""post_handshake_auth"" extension indicates that a client is willing to perform post-handshake authentication (Section 4.6.2).",0,Skip,Skip
83,Server Requirements for Post-Handshake Authentication,Servers must not send a post-handshake CertificateRequest to clients that do not offer this extension.,1,<SMC> <1> (Servers MUST NOT send a post-handshake CertificateRequest to clients that do not offer this extension.) + <CMP> <0> (Clients MUST offer the extension to receive a post-handshake CertificateRequest.),<SMC> <1> (Servers MUST NOT send a post-handshake CertificateRequest to clients that do not offer this extension.) + <CMP> <0> (Clients MUST offer the extension to receive a post-handshake CertificateRequest.)
84,Prohibition of Extension by Servers,Servers must not send this extension.,1,<SMC> <1> (Servers MUST NOT send this extension.) + <CMP> <0> (Clients MUST ignore this extension if received.),<SMC> <1> (Servers MUST NOT send this extension.) + <CMP> <0> (Clients MUST ignore this extension if received.)
85,Post-Handshake Auth Structure,"The ""extension_data"" field of the ""post_handshake_auth"" extension is zero length.",0,Skip,Skip
86,Supported Groups Extension,"When sent by the client, the ""supported_groups"" extension indicates the named groups which the client supports for key exchange, ordered from most preferred to least preferred.",0,Skip,Skip
87,Historical Context,"In versions of TLS prior to TLS 1.3, this extension was named ""elliptic_curves"" and only contained elliptic curve groups.",0,Skip,Skip
88,Signature Algorithms Negotiation,"Signature algorithms are now negotiated independently, as described in Section 4.2.3.",0,Skip,Skip
89,NamedGroupList Structure,"The ""extension_data"" field of this extension contains a ""NamedGroupList"" value, which includes elliptic curve groups (ECDHE) and finite field groups (DHE).",0,Skip,Skip
90,Elliptic Curve Groups,Elliptic Curve Groups (ECDHE) indicate support for named curves defined in FIPS 186-4 or RFC 7748.,0,Skip,Skip
91,Finite Field Groups,Finite Field Groups (DHE) indicate support for finite field groups defined in RFC 7919.,0,Skip,Skip
92,Order of Preferences,"Items in named_group_list are ordered according to the sender's preferences, with the most preferred choice first.",0,Skip,Skip
93,Server Behavior in TLS 1.3,"As of TLS 1.3, servers may send the ""supported_groups"" extension to the client, and clients must not act on this information until the handshake is complete.",1,"<SMC> <1> (Servers MAY send the ""supported_groups"" extension to the client.) + <CMP> <1> (Clients MUST NOT act on the ""supported_groups"" information until the handshake is complete.)","<SMC> <1> (Servers MAY send the ""supported_groups"" extension to the client.) + <CMP> <1> (Clients MUST NOT act on the ""supported_groups"" information until the handshake is complete.)"
94,Updating Client Preferences,"If the server has a preferred group not in the client's ""key_share"" extension but is still willing to accept the ClientHello, it should send ""supported_groups"" to update the clientâ€™s view of its preferences.",0,Skip,Skip
95,Key Share Extension Overview,"The ""key_share"" extension contains the endpoint's cryptographic parameters and allows clients to send an empty client_shares vector to request group selection from the server, incurring an additional round trip.",0,Skip,Skip
96,KeyShareEntry Structure,The KeyShareEntry structure includes a named group for the key being exchanged and key exchange information determined by the specified group.,0,Skip,Skip
97,ClientHello Key Share Data,"In the ClientHello message, the ""extension_data"" field contains a ""KeyShareClientHello"" value, which includes a list of offered KeyShareEntry values in descending order of client preference.",0,Skip,Skip
98,Empty Client Shares for HelloRetryRequest,"The client_shares vector may be empty if the client is requesting a HelloRetryRequest, but each KeyShareEntry must correspond to a group in the ""supported_groups"" extension.",1,"<CMC> <1> (Clients MAY have an empty client_shares vector when requesting a HelloRetryRequest.) + <SMP> <1> (Servers MUST ensure that each KeyShareEntry corresponds to a group in the ""supported_groups"" extension.)","<CMC> <1> (Clients MAY have an empty client_shares vector when requesting a HelloRetryRequest.) + <SMP> <1> (Servers MUST ensure that each KeyShareEntry corresponds to a group in the ""supported_groups"" extension.)"
99,Offering Multiple KeyShareEntries,"Clients can offer multiple KeyShareEntry values for supported groups, but each value must be generated independently, and clients must not offer duplicates or invalid groups.",1,"<CMC> <1> (Clients MAY offer multiple KeyShareEntry values for supported groups, but each value MUST be generated independently.) + <SMP> <0> (Servers MUST verify that KeyShareEntry values are not duplicates or invalid groups.)  
<CMC> <1> (Clients MUST NOT offer duplicates or invalid groups in KeyShareEntry values.) + <SMP> <0> (Servers MUST reject KeyShareEntry values that are duplicates or invalid groups.)","<CMC> <1> (Clients MAY offer multiple KeyShareEntry values for supported groups, but each value MUST be generated independently.) + <SMP> <0> (Servers MUST verify that KeyShareEntry values are not duplicates or invalid groups.)"
,,,,,<CMC> <1> (Clients MUST NOT offer duplicates or invalid groups in KeyShareEntry values.) + <SMP> <0> (Servers MUST reject KeyShareEntry values that are duplicates or invalid groups.)
100,HelloRetryRequest Handling,"In a HelloRetryRequest, the ""extension_data"" contains a KeyShareHelloRetryRequest value indicating the mutually supported group for negotiation. The client must verify that the selected group is valid before retrying.",1,<CMC> <1> (Clients MUST verify that the selected group in the KeyShareHelloRetryRequest is valid before retrying.) + <SMP> <0> (Servers MUST accept the KeyShareHelloRetryRequest containing a valid group for negotiation.),<CMC> <1> (Clients MUST verify that the selected group in the KeyShareHelloRetryRequest is valid before retrying.) + <SMP> <0> (Servers MUST accept the KeyShareHelloRetryRequest containing a valid group for negotiation.)
101,ServerHello Key Share Data,"In a ServerHello message, the ""extension_data"" includes a KeyShareServerHello value, which consists of a single KeyShareEntry that matches the client's selected group.",0,Skip,Skip
102,Validation of Key Share in ServerHello,Servers must verify that the KeyShareEntry aligns with the client's supported groups and must not send entries for unsupported groups or in incompatible modes.,1,"<SMC> <1> (Servers MUST verify that the KeyShareEntry aligns with the client's supported groups.) + <CMP> <1> (Clients MUST ensure that supported groups are included in the KeyShareEntry.)  
<SMC> <1> (Servers MUST NOT send KeyShareEntry for unsupported groups.) + <CMP> <0> (Clients MUST process only KeyShareEntries that are for supported groups.)  
<SMC> <1> (Servers MUST NOT send KeyShareEntry in incompatible modes.) + <CMP> <0> (Clients MUST reject any KeyShareEntry that is in an incompatible mode.)  ",<SMC> <1> (Servers MUST verify that the KeyShareEntry aligns with the client's supported groups.) + <CMP> <1> (Clients MUST ensure that supported groups are included in the KeyShareEntry.)
,,,,,<SMC> <1> (Servers MUST NOT send KeyShareEntry for unsupported groups.) + <CMP> <0> (Clients MUST process only KeyShareEntries that are for supported groups.)
,,,,,<SMC> <1> (Servers MUST NOT send KeyShareEntry in incompatible modes.) + <CMP> <0> (Clients MUST reject any KeyShareEntry that is in an incompatible mode.)
103,Diffie-Hellman Parameter Encoding,"Diffie-Hellman parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure. The opaque value contains the Diffie-Hellman public value (Y = g^X mod p) for the specified group, encoded as a big-endian integer and padded to the left with zeros to the size of p in bytes.",0,Skip,Skip
104,Public Key Padding,"For a given Diffie-Hellman group, the padding results in all public keys having the same length.",0,Skip,Skip
105,Public Key Validation,Peers must validate each other's public key Y by ensuring that 1 < Y < p-1. This check ensures that the remote peer is properly behaved and isn't forcing the local system into a small subgroup.,1,<CMC> <1> (Clients MUST validate the public key Y by ensuring that 1 < Y < p-1.) + <SMP> <0> (Servers MUST be properly behaved and not force the local system into a small subgroup.),<CMC> <1> (Clients MUST validate the public key Y by ensuring that 1 < Y < p-1.) + <SMP> <0> (Servers MUST be properly behaved and not force the local system into a small subgroup.)
106,Key Share ECDHE Parameters,ECDHE parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure.,0,Skip,Skip
107,Uncompressed Point Representation Structure,"For secp256r1, secp384r1, and secp521r1, the contents are the serialized value of the UncompressedPointRepresentation struct, which includes a legacy_form and the binary representations of the x and y values.",0,Skip,Skip
108,Binary Representation Details,"X and Y are the binary representations of the x and y values in network byte order, with each representation occupying octets as specified by the curve parameters. For P-256, each uses 32 octets; for P-384, 48 octets; and for P-521, 66 octets.",0,Skip,Skip
109,Validation of Public Values,"Peers must validate each other's public value Q by ensuring it is a valid point on the elliptic curve, following the procedures outlined in Section 4.3.7 of [ECDSA] and Section 5.6.2.3 of [KEYAGREEMENT]. This includes verifying that Q is not the point at infinity, that x and y are in the correct interval, and that (x, y) satisfies the elliptic curve equation.",1,"```markdown
<CMP> <1> (Clients MUST validate each other's public value Q is a valid point on the elliptic curve according to specified procedures.) + <SMP> <1> (Servers MUST ensure that the public value Q is a valid point on the elliptic curve following the same procedures.)
```",<CMP> <1> (Clients MUST validate each other's public value Q is a valid point on the elliptic curve according to specified procedures.) + <SMP> <1> (Servers MUST ensure that the public value Q is a valid point on the elliptic curve following the same procedures.)
110,Public Values for X25519 and X448,"For X25519 and X448, the public value consists of the byte string inputs and outputs defined in [RFC7748]: 32 bytes for X25519 and 56 bytes for X448.",0,Skip,Skip
111,Point Format Negotiation in TLS,"TLS versions prior to 1.3 allowed point format negotiation, but TLS 1.3 removes this feature, specifying a single point format for each curve.",0,Skip,Skip
112,PSK Key Exchange Modes Requirement,"In order to use PSKs, clients must send a ""psk_key_exchange_modes"" extension, indicating the supported modes. This restricts both the PSKs offered in the ClientHello and those the server might supply via NewSessionTicket.",1,"<CMC> <1> (Clients MUST send a ""psk_key_exchange_modes"" extension indicating supported modes to use PSKs.) + <SMP> <1> (Servers MUST restrict PSKs offered in the ClientHello and those supplied via NewSessionTicket based on the modes indicated by the client.)","<CMC> <1> (Clients MUST send a ""psk_key_exchange_modes"" extension indicating supported modes to use PSKs.) + <SMP> <1> (Servers MUST restrict PSKs offered in the ClientHello and those supplied via NewSessionTicket based on the modes indicated by the client.)"
113,Mandatory Extension for Pre-Shared Key,"A client must provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension. If a client offers ""pre_shared_key"" without this extension, servers must abort the handshake.",1,"<CMC> <1> (Clients MUST provide a ""psk_key_exchange_modes"" extension if offering a ""pre_shared_key"" extension.) + <SMP> <1> (Servers MUST abort the handshake if a client offers ""pre_shared_key"" without the ""psk_key_exchange_modes"" extension.)","<CMC> <1> (Clients MUST provide a ""psk_key_exchange_modes"" extension if offering a ""pre_shared_key"" extension.) + <SMP> <1> (Servers MUST abort the handshake if a client offers ""pre_shared_key"" without the ""psk_key_exchange_modes"" extension.)"
114,Server Mode Selection Restriction,"Servers must not select a key exchange mode not listed by the client. This extension also restricts modes for PSK resumption, and servers should not send NewSessionTicket with incompatible tickets, or else client resumption attempts will fail.",1,"<SMC> <1> (Servers MUST NOT select a key exchange mode not listed by the client.) + <CMP> <1> (Clients MUST ensure that the selected key exchange mode is listed by the server.)  
<SMC> <1> (Servers SHOULD NOT send NewSessionTicket with incompatible tickets.) + <CMP> <1> (Clients MUST verify that the NewSessionTicket received is compatible for successful resumption.)",<SMC> <1> (Servers MUST NOT select a key exchange mode not listed by the client.) + <CMP> <1> (Clients MUST ensure that the selected key exchange mode is listed by the server.)
,,,,,<SMC> <1> (Servers SHOULD NOT send NewSessionTicket with incompatible tickets.) + <CMP> <1> (Clients MUST verify that the NewSessionTicket received is compatible for successful resumption.)
115,"Prohibition of Server ""psk_key_exchange_modes""","The server must not send a ""psk_key_exchange_modes"" extension.",1,"<SMC> <1> (Servers MUST NOT send a ""psk_key_exchange_modes"" extension.) + <CMP> <0> (Clients MUST accept that the server does not send a ""psk_key_exchange_modes"" extension.)","<SMC> <1> (Servers MUST NOT send a ""psk_key_exchange_modes"" extension.) + <CMP> <0> (Clients MUST accept that the server does not send a ""psk_key_exchange_modes"" extension.)"
116,Definition of PSK Key Exchange Modes,"The enum defines two modes: psk_ke for PSK-only key establishment, where the server must not supply a ""key_share"" value, and psk_dhe_ke for PSK with (EC)DHE key establishment, where both parties must supply ""key_share"" values.",1,"<SMC> <1> (Servers MUST NOT supply a ""key_share"" value in psk_ke mode.) + <CMP> <1> (Clients MUST supply a ""key_share"" value in psk_dhe_ke mode.)  
<SMC> <1> (Servers MUST supply a ""key_share"" value in psk_dhe_ke mode.) + <CMP> <1> (Clients MUST supply a ""key_share"" value in psk_dhe_ke mode.)  ","<SMC> <1> (Servers MUST NOT supply a ""key_share"" value in psk_ke mode.) + <CMP> <1> (Clients MUST supply a ""key_share"" value in psk_dhe_ke mode.)"
,,,,,"<SMC> <1> (Servers MUST supply a ""key_share"" value in psk_dhe_ke mode.) + <CMP> <1> (Clients MUST supply a ""key_share"" value in psk_dhe_ke mode.)"
117,Future Protocol Indications,"Future values must ensure that protocol messages unambiguously identify the selected mode by the presence of ""key_share"" in the ServerHello.",1,"<SMC> <1> (Servers MUST ensure that protocol messages unambiguously identify the selected mode by including ""key_share"" in the ServerHello.) + <CMP> <0> (Clients MUST verify the presence of ""key_share"" in the ServerHello to identify the selected mode.)","<SMC> <1> (Servers MUST ensure that protocol messages unambiguously identify the selected mode by including ""key_share"" in the ServerHello.) + <CMP> <0> (Clients MUST verify the presence of ""key_share"" in the ServerHello to identify the selected mode.)"
118,Early Data with PSK,"When a PSK is used and early data is allowed, the client can send Application Data in its first flight of messages, supplying both the ""pre_shared_key"" and ""early_data"" extensions.",0,Skip,Skip
119,Early Data Indication Structure,"The ""extension_data"" field contains an ""EarlyDataIndication"" value, with a specific structure dependent on the handshake message type.",0,Skip,Skip
120,Max Early Data Size,Details regarding the use of the max_early_data_size field are specified in Section 4.6.1.,0,Skip,Skip
121,PSK and Associated Parameters,"The parameters for 0-RTT data, such as version and cipher suite, are linked to the PSK in use, either provisioned or negotiated during the connection.",0,Skip,Skip
122,Ticket Age Validation,"For PSKs from NewSessionTicket, the server must validate the ticket age against the time since issuance, rejecting 0-RTT if it fails.",1,<SMC> <1> (Servers MUST validate the ticket age against the time since issuance for PSKs from NewSessionTicket.) + <CMP> <1> (Clients MUST abort 0-RTT if the ticket age validation fails.),<SMC> <1> (Servers MUST validate the ticket age against the time since issuance for PSKs from NewSessionTicket.) + <CMP> <1> (Clients MUST abort 0-RTT if the ticket age validation fails.)
123,0-RTT Message Structure,"0-RTT messages share encrypted content types with other message types but use different keys, with an EndOfEarlyData message indicating key change.",0,Skip,Skip
124,Server Response to Early Data,"A server receiving an ""early_data"" extension may ignore it, request a new ClientHello, or accept it and process early data.",0,Skip,Skip
125,Requirements for Accepting Early Data,"To accept early data, the server must verify the TLS version, cipher suite, and ALPN protocol match those associated with the selected PSK.",1,"<SMC> <1> (Servers MUST verify the TLS version, cipher suite, and ALPN protocol to accept early data associated with the selected PSK.) + <CMP> <0> (Clients MUST ensure that the TLS version, cipher suite, and ALPN protocol match those associated with the selected PSK for early data acceptance.)","<SMC> <1> (Servers MUST verify the TLS version, cipher suite, and ALPN protocol to accept early data associated with the selected PSK.) + <CMP> <0> (Clients MUST ensure that the TLS version, cipher suite, and ALPN protocol match those associated with the selected PSK for early data acceptance.)"
126,Handling Failed Checks,"If checks fail, the server must discard first-flight data and revert to 1-RTT or 2-RTT.",1,<SMC> <1> (Servers MUST discard first-flight data if checks fail.) + <CMP> <0> (Clients MUST revert to 1-RTT or 2-RTT if the server discards first-flight data.),<SMC> <1> (Servers MUST discard first-flight data if checks fail.) + <CMP> <0> (Clients MUST revert to 1-RTT or 2-RTT if the server discards first-flight data.)
127,Error Handling for Early Data,"If the server accepts early data but fails to decrypt records, it must terminate the connection with a ""bad_record_mac"" alert.",1,"<SMC> <1> (Servers MUST terminate the connection with a ""bad_record_mac"" alert if they accept early data but fail to decrypt records.) + <SMP> <1> (Servers MUST accept early data before attempting to decrypt records.)","<SMC> <1> (Servers MUST terminate the connection with a ""bad_record_mac"" alert if they accept early data but fail to decrypt records.) + <SMP> <1> (Servers MUST accept early data before attempting to decrypt records.)"
128,Client Behavior on Rejection,"If the server rejects the ""early_data"" extension, the client may retransmit Application Data after the handshake, but must consider the connection state.",1,"<CMC> <1> (Clients may retransmit Application Data after the handshake if the server rejects the ""early_data"" extension.) + <SMP> <0> (Servers must reject the ""early_data"" extension if not allowed, impacting the client's connection state considerations.)","<CMC> <1> (Clients may retransmit Application Data after the handshake if the server rejects the ""early_data"" extension.) + <SMP> <0> (Servers must reject the ""early_data"" extension if not allowed, impacting the client's connection state considerations.)"
129,Guidance for TLS Implementations,A TLS implementation should not automatically resend early data; applications should decide when retransmission is appropriate.,0,Skip,Skip
130,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip
131,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip
132,PSK Binder Purpose,"The PSK binder value forms a binding between a PSK and the current handshake, as well as a binding between the handshake in which the PSK was generated and the current handshake.",0,Skip,Skip
133,Binder Computation Method,"Each entry in the binders list is computed as an HMAC over a transcript hash containing a partial ClientHello up to and including the PreSharedKeyExtension.identities field, excluding the binders list itself.",0,Skip,Skip
134,Message Length Fields,"The length fields for the message are set as if binders of the correct lengths were present, including overall length, extensions block length, and the ""pre_shared_key"" extension length.",0,Skip,Skip
135,PskBinderEntry Computation,"The PskBinderEntry is computed similarly to the Finished message, using the binder_key derived from the corresponding PSK offered.",0,Skip,Skip
136,Handling HelloRetryRequest,"If the handshake includes a HelloRetryRequest, the initial ClientHello and HelloRetryRequest are included in the transcript along with the new ClientHello, affecting binder computation.",0,Skip,Skip
137,Transcript Hash Examples,"For ClientHello1, its binder is computed over the truncated ClientHello; for ClientHello2 after a HelloRetryRequest, the binder includes the initial ClientHello, HelloRetryRequest, and the truncated new ClientHello.",0,Skip,Skip
138,Hash Computation Details,"In the first flight, Truncate(ClientHello1) is hashed directly, while in the second flight, ClientHello1 is hashed and reinjected as a ""message_hash"" message.",0,Skip,Skip
139,0-RTT Data Streaming,"Clients are permitted to ""stream"" 0-RTT data until they receive the server's Finished, only then sending the EndOfEarlyData message, followed by the rest of the handshake.",0,Skip,Skip
140,Server Processing of Early Data,"To avoid deadlocks, when accepting ""early_data"", servers must process the client's ClientHello and then immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending its ServerHello.",1,"<SMC> <1> (Servers MUST process the client's ClientHello and then immediately send their flight of messages when accepting ""early_data"".) + <CMP> <1> (Clients MUST send an EndOfEarlyData message after sending early data.)","<SMC> <1> (Servers MUST process the client's ClientHello and then immediately send their flight of messages when accepting ""early_data"".) + <CMP> <1> (Clients MUST send an EndOfEarlyData message after sending early data.)"
141,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip
142,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip
143,Certificate Request Purpose,"A server which is authenticating with a certificate may optionally request a certificate from the client. This message, if sent, must follow EncryptedExtensions.",1,"<SMC> <1> (Servers MAY optionally request a certificate from the client if they are authenticating with a certificate.) + <CMP> <1> (Clients MUST respond with their certificate if requested by the server, and this message MUST follow EncryptedExtensions.)","<SMC> <1> (Servers MAY optionally request a certificate from the client if they are authenticating with a certificate.) + <CMP> <1> (Clients MUST respond with their certificate if requested by the server, and this message MUST follow EncryptedExtensions.)"
144,CertificateRequest Structure,The structure of this message includes a certificate_request_context and a set of extensions.,0,Skip,Skip
145,certificate_request_context Details,"The certificate_request_context is an opaque string identifying the certificate request, which must be unique within the scope of the connection to prevent replay of client CertificateVerify messages. It shall be zero length unless used for post-handshake authentication, where it should be made unpredictable to prevent pre-computation of valid CertificateVerify messages.",1,"<CMP> <1> (Clients MUST ensure the certificate_request_context is unique within the scope of the connection to prevent replay of CertificateVerify messages.) + <SMC> <0> (Servers MUST validate that the certificate_request_context is unique within the connection to prevent replay of CertificateVerify messages.)
<CMP> <1> (Clients SHALL use a zero-length certificate_request_context unless it's for post-handshake authentication.) + <SMC> <0> (Servers MUST accept a zero-length certificate_request_context unless it's for post-handshake authentication.)
<CMP> <1> (Clients MUST make the certificate_request_context unpredictable for post-handshake authentication.) + <SMC> <0> (Servers MUST verify the unpredictability of the certificate_request_context during post-handshake authentication.)",<CMP> <1> (Clients MUST ensure the certificate_request_context is unique within the scope of the connection to prevent replay of CertificateVerify messages.) + <SMC> <0> (Servers MUST validate that the certificate_request_context is unique within the connection to prevent replay of CertificateVerify messages.)
,,,,,<CMP> <1> (Clients SHALL use a zero-length certificate_request_context unless it's for post-handshake authentication.) + <SMC> <0> (Servers MUST accept a zero-length certificate_request_context unless it's for post-handshake authentication.)
,,,,,<CMP> <1> (Clients MUST make the certificate_request_context unpredictable for post-handshake authentication.) + <SMC> <0> (Servers MUST verify the unpredictability of the certificate_request_context during post-handshake authentication.)
146,Extensions Specification,"The extensions describe the parameters of the requested certificate, with the ""signature_algorithms"" extension being mandatory. Clients must ignore unrecognized extensions.",1,"<CMC> <1> (Clients MUST include the ""signature_algorithms"" extension as it is mandatory.) + <SMP> <0> (Servers MUST accept the ""signature_algorithms"" extension as it is mandatory.)
<CMC> <1> (Clients MUST ignore unrecognized extensions.) + <SMP> <0> (Servers MUST not process unrecognized extensions sent by clients.)","<CMC> <1> (Clients MUST include the ""signature_algorithms"" extension as it is mandatory.) + <SMP> <0> (Servers MUST accept the ""signature_algorithms"" extension as it is mandatory.)"
,,,,,<CMC> <1> (Clients MUST ignore unrecognized extensions.) + <SMP> <0> (Servers MUST not process unrecognized extensions sent by clients.)
147,Changes in TLS 1.3,"In TLS 1.3, the CertificateRequest message expresses acceptable signature algorithms and certificate authorities through specific extensions, differing from prior versions.",0,Skip,Skip
148,PSK Authentication Constraints,"Servers authenticating with a PSK must not send the CertificateRequest message in the main handshake but may do so in post-handshake authentication if the client has sent the ""post_handshake_auth"" extension.",1,"<SMC> <1> (Servers MUST NOT send the CertificateRequest message in the main handshake when authenticating with a PSK.) + <CMP> <1> (Clients MAY receive a CertificateRequest message during post-handshake authentication if the ""post_handshake_auth"" extension was sent.)","<SMC> <1> (Servers MUST NOT send the CertificateRequest message in the main handshake when authenticating with a PSK.) + <CMP> <1> (Clients MAY receive a CertificateRequest message during post-handshake authentication if the ""post_handshake_auth"" extension was sent.)"
149,Authentication Messages Overview,"TLS generally uses a common set of messages for authentication, key confirmation, and handshake integrity: Certificate, CertificateVerify, and Finished. These messages are always sent as the last messages in their handshake flight.",0,Skip,Skip
150,Message Encryption,These messages are encrypted under keys derived from the sender's handshake traffic secret.,0,Skip,Skip
151,Input Computations for Authentication Messages,"The computations for the Authentication messages take the certificate and signing key, a Handshake Context consisting of the set of messages for the transcript hash, and a Base Key for computing a MAC key.",0,Skip,Skip
152,Certificate Message Details,The Certificate message includes the certificate for authentication and any supporting certificates in the chain. Note that certificate-based client authentication is not available in PSK handshake flows (including 0-RTT).,0,Skip,Skip
153,CertificateVerify Message Details,"The CertificateVerify message contains a signature over the value Transcript-Hash(Handshake Context, Certificate).",0,Skip,Skip
154,Finished Message Details,"The Finished message includes a MAC over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using a MAC key derived from the Base Key.",0,Skip,Skip
155,Handshake Context and MAC Base Key Definitions,"The table defines the Handshake Context and MAC Base Key for each scenario, including modes for Server, Client, and Post-Handshake.",0,Skip,Skip
156,Transcript Hash Purpose,"Many of the cryptographic computations in TLS make use of a transcript hash, computed by hashing the concatenation of each included handshake message, including the message header but not record layer headers.",0,Skip,Skip
157,Transcript Hash Computation,"The transcript hash is computed as Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn).",0,Skip,Skip
158,Handling HelloRetryRequest,"When the server responds to a ClientHello with a HelloRetryRequest, ClientHello1 is replaced with a synthetic handshake message of type ""message_hash"" containing Hash(ClientHello1).",0,Skip,Skip
159,Stateless HelloRetryRequest Explanation,"This construction allows the server to perform a stateless HelloRetryRequest by storing just the hash of ClientHello1 in the cookie, avoiding the need to export the entire intermediate hash state.",0,Skip,Skip
160,Sequence of Handshake Messages,"The transcript hash is taken from a specific sequence of handshake messages, starting at the first ClientHello and including messages such as ServerHello and client Finished.",0,Skip,Skip
161,Implementation Note,"Implementations can keep a running transcript hash value based on the negotiated hash, noting that post-handshake authentications do not include each other.",0,Skip,Skip
162,Error,Error: Sending request HandleBotLandingPageQuery failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip
163,OCSP Response Negotiation,"RFC6066 and RFC6961 provide extensions to negotiate the server sending OCSP responses to the client. In TLS 1.2 and below, the server replies with an empty extension to indicate negotiation of this extension, and the OCSP information is carried in a CertificateStatus message. In TLS 1.3, the server's OCSP information is carried in an extension in the CertificateEntry containing the associated certificate.",0,Skip,Skip
164,CertificateStatus Structure,"Specifically, the body of the ""status_request"" extension from the server MUST be a CertificateStatus structure as defined in RFC6066, which is interpreted as defined in RFC6960.",1,"<SMC> <1> (Servers MUST include a CertificateStatus structure in the body of the ""status_request"" extension.) + <CMP> <1> (Clients MUST interpret the CertificateStatus structure as defined in RFC6960.)","<SMC> <1> (Servers MUST include a CertificateStatus structure in the body of the ""status_request"" extension.) + <CMP> <1> (Clients MUST interpret the CertificateStatus structure as defined in RFC6960.)"
165,Deprecation of status_request_v2,"The status_request_v2 extension [RFC6961] is deprecated. TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients that wish to use it in earlier protocol versions.",1,"<SMC> <1> (Servers MUST NOT act upon the presence of the status_request_v2 extension in ClientHello messages.) + <CMP> <1> (Clients MAY send the status_request_v2 extension in ClientHello messages for earlier protocol versions.)  
<SMC> <1> (Servers MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.) + <CMP> <1> (Clients MAY include the status_request_v2 extension in ClientHello messages.)  
<SMC> <1> (Servers MUST be able to process ClientHello messages that include the status_request_v2 extension.) + <CMP> <1> (Clients MAY send the status_request_v2 extension in ClientHello messages for earlier protocol versions.)  ",<SMC> <1> (Servers MUST NOT act upon the presence of the status_request_v2 extension in ClientHello messages.) + <CMP> <1> (Clients MAY send the status_request_v2 extension in ClientHello messages for earlier protocol versions.)
,,,,,"<SMC> <1> (Servers MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.) + <CMP> <1> (Clients MAY include the status_request_v2 extension in ClientHello messages.)"
,,,,,<SMC> <1> (Servers MUST be able to process ClientHello messages that include the status_request_v2 extension.) + <CMP> <1> (Clients MAY send the status_request_v2 extension in ClientHello messages for earlier protocol versions.)
166,Client OCSP Response Request,"A server MAY request that a client present an OCSP response with its certificate by sending an empty ""status_request"" extension in its CertificateRequest message. If the client opts to send an OCSP response, the body of its ""status_request"" extension MUST be a CertificateStatus structure as defined in RFC6066.",1,"<SMC> <1> (Servers MAY request that a client present an OCSP response by sending an empty ""status_request"" extension in the CertificateRequest message.) + <CMP> <1> (Clients MUST send a CertificateStatus structure in the body of its ""status_request"" extension if opting to send an OCSP response.)","<SMC> <1> (Servers MAY request that a client present an OCSP response by sending an empty ""status_request"" extension in the CertificateRequest message.) + <CMP> <1> (Clients MUST send a CertificateStatus structure in the body of its ""status_request"" extension if opting to send an OCSP response.)"
167,Signed Certificate Timestamp Mechanism,"Similarly, RFC6962 provides a mechanism for a server to send a Signed Certificate Timestamp (SCT) as an extension in the ServerHello in TLS 1.2 and below. In TLS 1.3, the server's SCT information is carried in an extension in the CertificateEntry.",0,Skip,Skip
168,Certificate Type Requirement,"The certificate type must be X.509v3, unless explicitly negotiated otherwise.",1,"<CMC> <1> (Clients MUST use X.509v3 certificate type, unless explicitly negotiated otherwise.) + <SMP> <0> (Servers MUST accept X.509v3 certificate type, unless explicitly negotiated otherwise.)","<CMC> <1> (Clients MUST use X.509v3 certificate type, unless explicitly negotiated otherwise.) + <SMP> <0> (Servers MUST accept X.509v3 certificate type, unless explicitly negotiated otherwise.)"
169,Key Compatibility,"The server's end-entity certificate's public key must be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension.",1,"<SMC> <1> (Servers' end-entity certificate's public key MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension.) + <CMP> <0> (Clients MUST select an authentication algorithm that is compatible with the server's end-entity certificate's public key.)","<SMC> <1> (Servers' end-entity certificate's public key MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension.) + <CMP> <0> (Clients MUST select an authentication algorithm that is compatible with the server's end-entity certificate's public key.)"
170,Signing Capability,"The certificate must allow the key to be used for signing, indicated by the digitalSignature bit in the Key Usage extension.",1,"<CMC> <1> (Clients MUST ensure the certificate allows the key to be used for signing, indicated by the digitalSignature bit in the Key Usage extension.) + <SMP> <0> (Servers MUST verify that the certificate's key usage allows for signing as indicated by the digitalSignature bit.)","<CMC> <1> (Clients MUST ensure the certificate allows the key to be used for signing, indicated by the digitalSignature bit in the Key Usage extension.) + <SMP> <0> (Servers MUST verify that the certificate's key usage allows for signing as indicated by the digitalSignature bit.)"
171,Certificate Selection Guidance,"The ""server_name"" and ""certificate_authorities"" extensions guide certificate selection, with clients encouraged to send the ""server_name"" extension when applicable.",0,Skip,Skip
172,Signature Algorithm Validation,All certificates provided by the server must be signed by a signature algorithm advertised by the client if the client can provide such a chain.,1,<SMC> <1> (Servers MUST provide certificates signed by a signature algorithm advertised by the client if the client can provide such a chain.) + <CMP> <1> (Clients MUST ensure that the server's certificates are signed by an algorithm they have advertised.),<SMC> <1> (Servers MUST provide certificates signed by a signature algorithm advertised by the client if the client can provide such a chain.) + <CMP> <1> (Clients MUST ensure that the server's certificates are signed by an algorithm they have advertised.)
173,Fallback Certificate Chain,"If the server cannot produce a valid certificate chain, it should send a fallback chain that may include unsupported algorithms, avoiding deprecated SHA-1 unless permitted by the client.",0,Skip,Skip
174,Client Response to Invalid Chain,"If the client cannot construct an acceptable chain and aborts the handshake, it must do so with an appropriate certificate-related alert.",1,<CMC> <1> (Clients MUST abort the handshake with an appropriate certificate-related alert if they cannot construct an acceptable chain.) + <SMP> <0> (Servers MUST be prepared to handle a certificate-related alert if the client aborts the handshake.),<CMC> <1> (Clients MUST abort the handshake with an appropriate certificate-related alert if they cannot construct an acceptable chain.) + <SMP> <0> (Servers MUST be prepared to handle a certificate-related alert if the client aborts the handshake.)
175,Multiple Certificate Selection,"If the server has multiple certificates, it selects one based on the defined criteria and additional factors like local configuration.",0,Skip,Skip
176,Client Certificate Type Requirement,"The certificate type must be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).",1,<CMC> <1> (Clients MUST use X.509v3 certificates unless explicitly negotiated otherwise.) + <SMP> <0> (Servers MUST accept X.509v3 certificates unless explicitly negotiated otherwise.),<CMC> <1> (Clients MUST use X.509v3 certificates unless explicitly negotiated otherwise.) + <SMP> <0> (Servers MUST accept X.509v3 certificates unless explicitly negotiated otherwise.)
177,Certificate Authority Issuance,"If the ""certificate_authorities"" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain should be issued by one of the listed CAs.",0,Skip,Skip
178,Signature Algorithm Compliance,"The certificates must be signed using an acceptable signature algorithm, as described in Section 4.3.2, which relaxes constraints on certificate-signing algorithms found in prior versions of TLS.",1,<SMC> <1> (Servers MUST ensure that certificates are signed using an acceptable signature algorithm as specified in Section 4.3.2.) + <CMP> <0> (Clients MUST send certificates signed with acceptable signature algorithms.),<SMC> <1> (Servers MUST ensure that certificates are signed using an acceptable signature algorithm as specified in Section 4.3.2.) + <CMP> <0> (Clients MUST send certificates signed with acceptable signature algorithms.)
179,OID Filters Matching,"If the CertificateRequest message contained a non-empty ""oid_filters"" extension, the end-entity certificate must match the extension OIDs recognized by the client, as described in Section 4.2.5.",1,"<CMC> <1> (Clients MUST ensure that the end-entity certificate matches the OIDs recognized by them if the ""oid_filters"" extension is non-empty in the CertificateRequest message.) + <SMP> <0> (Servers MUST include the ""oid_filters"" extension in the CertificateRequest message when applicable.)","<CMC> <1> (Clients MUST ensure that the end-entity certificate matches the OIDs recognized by them if the ""oid_filters"" extension is non-empty in the CertificateRequest message.) + <SMP> <0> (Servers MUST include the ""oid_filters"" extension in the CertificateRequest message when applicable.)"
180,Certificate Validation Scope,"In general, detailed certificate validation procedures are out of scope for TLS. This section provides TLS-specific requirements.",0,Skip,Skip
181,Handling Empty Certificate Messages,"If the server supplies an empty Certificate message, the client must abort the handshake with a ""decode_error"" alert. If the client sends an empty Certificate message, the server may either continue the handshake or abort it with a ""certificate_required"" alert.",1,"<CMC> <1> (Clients MUST abort the handshake with a ""decode_error"" alert if the server supplies an empty Certificate message.) + <SMP> <1> (Servers MAY continue the handshake or abort it with a ""certificate_required"" alert if the client sends an empty Certificate message.)","<CMC> <1> (Clients MUST abort the handshake with a ""decode_error"" alert if the server supplies an empty Certificate message.) + <SMP> <1> (Servers MAY continue the handshake or abort it with a ""certificate_required"" alert if the client sends an empty Certificate message.)"
182,Unacceptable Certificate Chains,"If any aspect of the certificate chain is unacceptable, the server may choose to continue the handshake as unauthenticated or abort it.",0,Skip,Skip
183,Aborting for MD5 and SHA-1 Certificates,"Any endpoint receiving a certificate that requires validation using MD5 must abort the handshake with a ""bad_certificate"" alert. SHA-1 is deprecated, and endpoints should also abort the handshake for SHA-1 validation.",1,"<CMC> <1> (Clients MUST abort the handshake with a ""bad_certificate"" alert if receiving a certificate requiring MD5 validation.) + <SMP> <1> (Servers MUST abort the handshake with a ""bad_certificate"" alert if receiving a certificate requiring MD5 validation.)  
<CMC> <1> (Clients MUST abort the handshake if receiving a certificate requiring SHA-1 validation.) + <SMP> <1> (Servers MUST abort the handshake if receiving a certificate requiring SHA-1 validation.)","<CMC> <1> (Clients MUST abort the handshake with a ""bad_certificate"" alert if receiving a certificate requiring MD5 validation.) + <SMP> <1> (Servers MUST abort the handshake with a ""bad_certificate"" alert if receiving a certificate requiring MD5 validation.)"
,,,,,<CMC> <1> (Clients MUST abort the handshake if receiving a certificate requiring SHA-1 validation.) + <SMP> <1> (Servers MUST abort the handshake if receiving a certificate requiring SHA-1 validation.)
184,Recommendation for SHA-256 Transition,All endpoints are recommended to transition to SHA-256 or better to maintain interoperability with implementations phasing out SHA-1 support.,0,Skip,Skip
185,Signature Algorithm Variability,A certificate containing a key for one signature algorithm may be signed using a different signature algorithm.,0,Skip,Skip
186,Purpose of CertificateVerify Message,This message is used to provide explicit proof that an endpoint possesses the private key corresponding to its certificate and ensures integrity for the handshake up to this point. Servers and clients must send this message when authenticating via a certificate.,1,"```markdown
<CMC> <1> (Clients MUST send a message to provide proof of possession of the private key corresponding to its certificate.) + <SMP> <1> (Servers MUST send a message to provide proof of possession of the private key corresponding to its certificate.)
<CMC> <1> (Clients MUST ensure integrity for the handshake up to this point.) + <SMP> <1> (Servers MUST ensure integrity for the handshake up to this point.)
```",<CMC> <1> (Clients MUST send a message to provide proof of possession of the private key corresponding to its certificate.) + <SMP> <1> (Servers MUST send a message to provide proof of possession of the private key corresponding to its certificate.)
,,,,,<CMC> <1> (Clients MUST ensure integrity for the handshake up to this point.) + <SMP> <1> (Servers MUST ensure integrity for the handshake up to this point.)
187,Message Structure,"The CertificateVerify message has a defined structure including a signature scheme algorithm and an opaque signature. The algorithm field specifies the signature algorithm used, while the signature is a digital signature over a specific content.",0,Skip,Skip
188,Content Covered by Signature,The content covered under the signature includes the hash output derived from the handshake context and the certificate. This is crucial for ensuring the integrity of the handshake process.,0,Skip,Skip
189,Signature Calculation Process,"The digital signature is computed over a concatenation of a 64-byte padding, a context string, a separator byte, and the content to be signed. This structure mitigates potential attacks on previous TLS versions.",0,Skip,Skip
190,Context Strings for Signatures,"For server signatures, the context string is ""TLS 1.3, server CertificateVerify"", while for client signatures, it is ""TLS 1.3, client CertificateVerify"". This separation helps prevent cross-protocol attacks.",0,Skip,Skip
191,Signature Algorithm Requirements,"The signature algorithm used must be compatible with the client's ""signature_algorithms"" extension if sent by a server and must align with the supported algorithms in the CertificateRequest message if sent by a client. RSA signatures must use RSASSA-PSS, and SHA-1 is not permitted.",1,"<SMC> <1> (Servers MUST use a signature algorithm compatible with the client's ""signature_algorithms"" extension.) + <CMP> <1> (Clients MUST ensure the signature algorithm aligns with the supported algorithms in the CertificateRequest message.)
<SMC> <1> (Servers MUST use RSA signatures with RSASSA-PSS.) + <CMP> <1> (Clients MUST NOT use SHA-1 as a signature algorithm.)","<SMC> <1> (Servers MUST use a signature algorithm compatible with the client's ""signature_algorithms"" extension.) + <CMP> <1> (Clients MUST ensure the signature algorithm aligns with the supported algorithms in the CertificateRequest message.)"
,,,,,<SMC> <1> (Servers MUST use RSA signatures with RSASSA-PSS.) + <CMP> <1> (Clients MUST NOT use SHA-1 as a signature algorithm.)
192,Verification Process,"The receiver of a CertificateVerify message must verify the signature using the public key from the end-entity certificate and terminate the handshake with a ""decrypt_error"" alert if the verification fails.",1,"<CMC> <1> (Clients MUST verify the signature in the CertificateVerify message using the public key from the end-entity certificate.) + <SMP> <1> (Servers MUST terminate the handshake with a ""decrypt_error"" alert if the signature verification fails.)","<CMC> <1> (Clients MUST verify the signature in the CertificateVerify message using the public key from the end-entity certificate.) + <SMP> <1> (Servers MUST terminate the handshake with a ""decrypt_error"" alert if the signature verification fails.)"
193,Finished Message Purpose,"The Finished message is the final message in the Authentication Block, essential for providing authentication of the handshake and the computed keys.",0,Skip,Skip
194,Verification Requirement,"Recipients of Finished messages must verify their contents; if incorrect, they must terminate the connection with a ""decrypt_error"" alert.",1,"<CMC> <1> (Clients MUST verify the contents of Finished messages; if incorrect, they MUST terminate the connection with a ""decrypt_error"" alert.) + <SMP> <1> (Servers MUST verify the contents of Finished messages; if incorrect, they MUST terminate the connection with a ""decrypt_error"" alert.)","<CMC> <1> (Clients MUST verify the contents of Finished messages; if incorrect, they MUST terminate the connection with a ""decrypt_error"" alert.) + <SMP> <1> (Servers MUST verify the contents of Finished messages; if incorrect, they MUST terminate the connection with a ""decrypt_error"" alert.)"
195,Transition to Application Data,"Once a side has sent its Finished message and validated the peer's Finished message, it may begin to send and receive Application Data over the connection.",0,Skip,Skip
196,Early Data Sending Conditions,"Clients may send 0-RTT data as described in Section 4.2.10. Servers may send data after their first flight, but without assurance of the peer's identity or liveness.",0,Skip,Skip
197,Finished Message Key Computation,"The key used to compute the Finished message is derived from the Base Key using HKDF, specifically `finished_key = HKDF-Expand-Label(BaseKey, ""finished"", """", Hash.length)`.",0,Skip,Skip
198,Finished Message Structure,The structure of this message includes `struct { opaque verify_data[Hash.length]; ,0,Skip,Skip
199,Verify Data Calculation,The verify_data value is computed using HMAC with the finished_key and the transcript hash of the handshake context.,0,Skip,Skip
200,Length of Verify Data,"In TLS 1.3, the verify_data length is the size of the HMAC output for the Hash used for the handshake, differing from previous versions where it was always 12 octets long.",0,Skip,Skip
201,Post-Finished Message Records,"Any records following a Finished message must be encrypted under the appropriate application traffic key, including alerts sent by the server in response to client messages.",1,"<SMC> <1> (Servers MUST encrypt any records following a Finished message under the application traffic key, including alerts in response to client messages.) + <CMP> <1> (Clients MUST expect that any records following a Finished message will be encrypted under the appropriate application traffic key.)","<SMC> <1> (Servers MUST encrypt any records following a Finished message under the application traffic key, including alerts in response to client messages.) + <CMP> <1> (Clients MUST expect that any records following a Finished message will be encrypted under the appropriate application traffic key.)"
202,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip
203,Post-Handshake Messages,TLS allows other messages to be sent after the main handshake. These messages use a handshake content type and are encrypted under the appropriate application traffic key.,0,Skip,Skip
204,Error,Error: Sending request SendMessageMutation failed.  Error log: RemoteProtocolError('Server disconnected'),0,Skip,Skip
205,Post-Handshake Authentication Extension,"When the client has sent the ""post_handshake_auth"" extension, a server may request client authentication at any time after the handshake has completed by sending a CertificateRequest message.",0,Skip,Skip
206,Client Response Requirements,"The client must respond with the appropriate Authentication messages. If the client chooses to authenticate, it must send Certificate, CertificateVerify, and Finished. If it declines, it must send a Certificate message containing no certificates followed by Finished.",1,"<CMC> <1> (Clients MUST send Certificate, CertificateVerify, and Finished if choosing to authenticate.) + <SMP> <0> (Servers MUST process the Certificate, CertificateVerify, and Finished messages if they are sent by the client for authentication.)
<CMC> <1> (Clients MUST send a Certificate message containing no certificates followed by Finished if they decline to authenticate.) + <SMP> <0> (Servers MUST process the Certificate message containing no certificates and the Finished message if they are sent by the client.)","<CMC> <1> (Clients MUST send Certificate, CertificateVerify, and Finished if choosing to authenticate.) + <SMP> <0> (Servers MUST process the Certificate, CertificateVerify, and Finished messages if they are sent by the client for authentication.)"
,,,,,<CMC> <1> (Clients MUST send a Certificate message containing no certificates followed by Finished if they decline to authenticate.) + <SMP> <0> (Servers MUST process the Certificate message containing no certificates and the Finished message if they are sent by the client.)
207,Message Order for Client Responses,All of the client's messages for a given response must appear consecutively on the wire with no intervening messages of other types.,1,<CMC> <1> (Clients' messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.) + <SMP> <0> (Servers MUST process clients' messages only when they appear consecutively without intervening messages of other types.),<CMC> <1> (Clients' messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.) + <SMP> <0> (Servers MUST process clients' messages only when they appear consecutively without intervening messages of other types.)
208,Handling Unexpected Certificate Requests,"A client that receives a CertificateRequest message without having sent the ""post_handshake_auth"" extension must send an ""unexpected_message"" fatal alert.",1,"<CMC> <1> (Clients MUST send an ""unexpected_message"" fatal alert if they receive a CertificateRequest message without having sent the ""post_handshake_auth"" extension.) + <SMP> <0> (Servers MUST not expect a CertificateRequest message if the ""post_handshake_auth"" extension was not sent by the client.)","<CMC> <1> (Clients MUST send an ""unexpected_message"" fatal alert if they receive a CertificateRequest message without having sent the ""post_handshake_auth"" extension.) + <SMP> <0> (Servers MUST not expect a CertificateRequest message if the ""post_handshake_auth"" extension was not sent by the client.)"
209,Server Readiness for Delays,"Because client authentication could involve prompting the user, servers must be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response.",1,"<SMC> <1> (Servers MUST be prepared for some delay in client authentication, including receiving other messages between sending the CertificateRequest and receiving a response.) + <CMP> <0> (Clients MAY take time to respond to a CertificateRequest due to user prompting.)","<SMC> <1> (Servers MUST be prepared for some delay in client authentication, including receiving other messages between sending the CertificateRequest and receiving a response.) + <CMP> <0> (Clients MAY take time to respond to a CertificateRequest due to user prompting.)"
210,Response Order for Multiple Requests,"Clients which receive multiple CertificateRequests in close succession may respond to them in a different order than they were received, as the certificate_request_context value allows the server to disambiguate the responses.",0,Skip,Skip
211,KeyUpdate Message Purpose,The KeyUpdate handshake message indicates that the sender is updating its sending cryptographic keys. This message can be sent by either peer after it has sent a Finished message.,0,Skip,Skip
212,Handling Unexpected KeyUpdate,"Implementations that receive a KeyUpdate message prior to receiving a Finished message must terminate the connection with an ""unexpected_message"" alert.",1,"<CMC> <1> (Clients MUST terminate the connection with an ""unexpected_message"" alert if they receive a KeyUpdate message before the Finished message.) + <SMP> <1> (Servers MUST terminate the connection with an ""unexpected_message"" alert if they receive a KeyUpdate message before the Finished message.)","<CMC> <1> (Clients MUST terminate the connection with an ""unexpected_message"" alert if they receive a KeyUpdate message before the Finished message.) + <SMP> <1> (Servers MUST terminate the connection with an ""unexpected_message"" alert if they receive a KeyUpdate message before the Finished message.)"
213,KeyUpdate Message Protocol,"After sending a KeyUpdate message, the sender shall use the next generation of keys. Upon receiving a KeyUpdate, the receiver must update its receiving keys.",1,<CMC> <1> (Senders SHALL use the next generation of keys after sending a KeyUpdate message.) + <SMP> <1> (Receivers MUST update their receiving keys upon receiving a KeyUpdate.),<CMC> <1> (Senders SHALL use the next generation of keys after sending a KeyUpdate message.) + <SMP> <1> (Receivers MUST update their receiving keys upon receiving a KeyUpdate.)
214,KeyUpdateRequest Enumeration,"The KeyUpdateRequest enum indicates whether the recipient should respond with its own KeyUpdate, with values for update_not_requested and update_requested.",0,Skip,Skip
215,Response Mechanism for KeyUpdate,"If request_update is set to ""update_requested,"" the receiver must send a KeyUpdate of its own with request_update set to ""update_not_requested"" before sending its next Application Data record.",1,"<CMC> <1> (Clients MUST send a KeyUpdate with request_update set to ""update_not_requested"" before sending the next Application Data record if request_update is set to ""update_requested."") + <SMP> <0> (Servers MUST process the KeyUpdate with request_update set to ""update_not_requested"" before sending the next Application Data record.)","<CMC> <1> (Clients MUST send a KeyUpdate with request_update set to ""update_not_requested"" before sending the next Application Data record if request_update is set to ""update_requested."") + <SMP> <0> (Servers MUST process the KeyUpdate with request_update set to ""update_not_requested"" before sending the next Application Data record.)"
216,Handling Multiple KeyUpdates,"Implementations may receive multiple messages between sending a KeyUpdate and receiving the peer's KeyUpdate, but retaining the receive traffic secret ensures forward secrecy.",0,Skip,Skip
217,Crossing KeyUpdates,"If both sides send their own KeyUpdates with request_update set to ""update_requested"" and they cross in flight, each side will send a response, incrementing by two generations.",0,Skip,Skip
218,Encryption Requirement for KeyUpdate,Both sender and receiver must encrypt KeyUpdate messages with the old keys and ensure that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key to prevent message truncation attacks.,1,<CMC> <1> (Clients MUST encrypt KeyUpdate messages with the old keys.) + <SMP> <1> (Servers MUST ensure that a KeyUpdate with the old key is received before accepting messages encrypted with the new key to prevent message truncation attacks.),<CMC> <1> (Clients MUST encrypt KeyUpdate messages with the old keys.) + <SMP> <1> (Servers MUST ensure that a KeyUpdate with the old key is received before accepting messages encrypted with the new key to prevent message truncation attacks.)
