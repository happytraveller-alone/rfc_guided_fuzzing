index,Section,Title,Content,result
1,4.. Handshake Protocol,Message Order and Error Handling,"Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2. A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",waiting fill
2,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Server Parameter Selection,"If the server does not select a PSK, it independently selects a cipher suite, an (EC)DHE group and key share, and a signature algorithm/certificate pair. If there is no overlap in 'supported_groups', the server MUST abort the handshake with a 'handshake_failure' or 'insufficient_security' alert.",waiting fill
3,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,PSK Selection,"If the server selects a PSK, it MUST also select a key establishment mode from the client's 'psk_key_exchange_modes' extension. If the PSK can be used without (EC)DHE, non-overlap in 'supported_groups' is not fatal.",waiting fill
4,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,HelloRetryRequest Requirement,"If the server selects an (EC)DHE group and the client did not offer a compatible 'key_share', the server MUST respond with a HelloRetryRequest message.",waiting fill
5,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Handshake Failure Conditions,"If the server is unable to negotiate a supported set of parameters, it MUST abort the handshake with a 'handshake_failure' or 'insufficient_security' fatal alert.",waiting fill
6,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,ClientHello Message Overview,"When a client first connects to a server, it is REQUIRED to send the ClientHello as its first TLS message. The client will also send a ClientHello when the server has responded to its ClientHello with a HelloRetryRequest. In that case, the client MUST send the same ClientHello without modification, except as follows: - If a ""key_share"" extension was supplied in the HelloRetryRequest, replacing the list of shares with a list containing a single KeyShareEntry from the indicated group. - Removing the ""early_data"" extension if one was present. Early data is not permitted after a HelloRetryRequest. - Including a ""cookie"" extension if one was provided in the HelloRetryRequest. - Updating the ""pre_shared_key"" extension if present by recomputing the ""obfuscated_ticket_age"" and binder values and (optionally) removing any PSKs which are incompatible with the server's indicated cipher suite. - Optionally adding, removing, or changing the length of the ""padding"" extension [RFC7685]. - Other modifications that may be allowed by an extension defined in the future and present in the HelloRetryRequest.",waiting fill
7,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Connection Termination Rules,"Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an ""unexpected_message"" alert. If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version. In particular, it MUST NOT negotiate TLS 1.3.",waiting fill
8,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Field Descriptions,"1. legacy_version: Set to 0x0303 (TLS v1.2) for compatibility with middleboxes. The actual version is indicated using the ""supported_versions"" extension. 2. random: 32 bytes generated by a secure random number generator. 3. legacy_session_id: A cached session ID from a pre-TLS 1.3 server, or a new unpredictable value if none exists. 4. cipher_suites: A list of symmetric cipher options supported by the client. 5. legacy_compression_methods: Must contain exactly one byte, set to zero. 6. extensions: Clients request extended functionality from servers by sending data in the extensions field.",waiting fill
9,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Extension Handling,"Clients request extended functionality from servers by sending data in the extensions field. In TLS 1.3, the use of certain extensions is mandatory, and servers MUST ignore unrecognized extensions. TLS 1.3 ClientHello messages always contain extensions, minimally the ""supported_versions"" extension.",waiting fill
10,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Field Descriptions,"1. **legacy_version**: Set to 0x0303 (TLS v1.2) for compatibility with middleboxes. The actual version is indicated using the ""supported_versions"" extension.

2. **random**: 32 bytes generated by a secure random number generator. The last 8 bytes must be overwritten if negotiating TLS 1.2 or TLS 1.1, while the rest must be random.

3. **legacy_session_id_echo**: Echoes the client's legacy_session_id. If this does not match the client's sent value, the handshake must abort with an ""illegal_parameter"" alert.

4. **cipher_suite**: The selected cipher suite from the ClientHello. If not offered, the handshake must abort with an ""illegal_parameter"" alert.

5. **legacy_compression_method**: Must be set to 0.

6. **extensions**: Must include only those necessary for establishing the cryptographic context. All TLS 1.3 ServerHello messages must contain the ""supported_versions"" extension.",waiting fill
11,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Downgrade Protection Mechanism,"TLS 1.3 has a downgrade protection mechanism embedded in the server's random value. If negotiating TLS 1.2, the last 8 bytes of the Random value must be set to:

44 4F 57 4E 47 52 44 01

If negotiating TLS 1.1 or below, they should be set to:

44 4F 57 4E 47 52 44 00.

Clients must check these values and abort the handshake with an ""illegal_parameter"" alert if they match.",waiting fill
12,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Renegotiation Handling,"A legacy TLS client performing renegotiation with TLS 1.2 or prior that receives a TLS 1.3 ServerHello during renegotiation must abort the handshake with a ""protocol_version"" alert. Note that renegotiation is not possible when TLS 1.3 has been negotiated.",waiting fill
13,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Extensions Requirements,"The server's extensions MUST contain 'supported_versions'. Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair. A HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the 'cookie' extension.",waiting fill
14,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Client Processing of HelloRetryRequest,"Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using 'supported_versions'. Clients MUST abort the handshake with an 'illegal_parameter' alert if the HelloRetryRequest would not result in any change in the ClientHello. If a client receives a second HelloRetryRequest in the same connection, it MUST abort the handshake with an 'unexpected_message' alert.",waiting fill
15,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Extension Processing and Updated ClientHello,"Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello. The HelloRetryRequest extensions defined in this specification are: - supported_versions (see Section 4.2.1) - cookie (see Section 4.2.2) - key_share (see Section 4.2.8). A client which receives a cipher suite that was not offered MUST abort the handshake.",waiting fill
16,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Cipher Suite Negotiation,"Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello. Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an 'illegal_parameter' alert.",waiting fill
17,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Version Retention in ServerHello,"The value of selected_version in the HelloRetryRequest 'supported_versions' extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an 'illegal_parameter' alert if the value changes.",waiting fill
18,4.2.. Handshake Protocol_Extensions,Extension Handling Rules,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest. Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert.",waiting fill
19,4.2.. Handshake Protocol_Extensions,Extension Message Compatibility,"The table below indicates the messages where a given extension may appear, using the following notation: CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), and HRR (HelloRetryRequest). If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an ""illegal_parameter"" alert.",waiting fill
20,4.2.. Handshake Protocol_Extensions,Extension Order and Uniqueness,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" which MUST be the last extension in the ClientHello. There MUST NOT be more than one extension of the same type in a given extension block.",waiting fill
21,4.2.1.. Handshake Protocol_Extensions_Supported Versions,ClientHello Requirements,"Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which they are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, they MUST be present as well).",waiting fill
22,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Server Behavior Without the Extension,"If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.",waiting fill
23,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Server Behavior With the Extension,"If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension.",waiting fill
24,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Negotiation of Versions Prior to TLS 1.2,This mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.,waiting fill
25,4.2.1.. Handshake Protocol_Extensions_Supported Versions,ServerHello Version Negotiation,"A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2).",waiting fill
26,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Client Checks for the Supported Versions Extension,"Clients MUST check for this extension prior to processing the rest of the ServerHello. If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version. If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert.",waiting fill
27,4.2.2.. Handshake Protocol_Extensions_Cookie,HelloRetryRequest Cookie Extension,"When sending a HelloRetryRequest, the server MAY provide a ""cookie"" extension to the client (this is an exception to the usual rule that only extensions appearing in the ClientHello may be sent). When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a ""cookie"" extension in the new ClientHello. Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.",waiting fill
28,4.2.2.. Handshake Protocol_Extensions_Cookie,Stateless Server Behavior,"When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5). Since the server is not storing any state, this will appear as if it were the first message received. Servers operating statelessly MUST ignore these records.",waiting fill
29,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Client Requirements for Signature Algorithms,"Clients that desire server authentication via a certificate MUST send the ""signature_algorithms"" extension. If the server is authenticating via a certificate and the client has not sent this extension, the server MUST abort the handshake with a ""missing_extension"" alert.",waiting fill
30,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,RSASSA-PSS Algorithms,Indicates a signature algorithm using RSASSA-PSS with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST equal the output length of the digest algorithm.,waiting fill
31,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Legacy Algorithms,"Indicates algorithms being deprecated due to known weaknesses, specifically SHA-1 used with RSA or ECDSA. These values refer solely to signatures in certificates and should not be negotiated unless for backward compatibility. TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it.",waiting fill
32,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,TLS 1.2 Compatibility,"TLS 1.3 implementations willing to negotiate TLS 1.2 MUST comply with the requirements of [RFC5246]. In TLS 1.2, ClientHellos may omit the signature algorithms extension, which contained hash/signature pairs encoded in two octets. Legacy pairs are deprecated and MUST NOT be offered or negotiated.",waiting fill
33,4.2.5.. Handshake Protocol_Extensions_OID Filters,OID Filters Extension Overview,"The ""oid_filters"" extension allows servers to provide a set of OID/value pairs which it would like the client's certificate to match. This extension, if provided by the server, MUST only be sent in the CertificateRequest message.",waiting fill
34,4.2.5.. Handshake Protocol_Extensions_OID Filters,Filters List Description,"filters: A list of certificate extension OIDs [RFC5280] with their allowed value(s) and represented in DER-encoded [X690] format. Some certificate extension OIDs allow multiple values (e.g., Extended Key Usage). If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes.",waiting fill
35,4.2.5.. Handshake Protocol_Extensions_OID Filters,Client Certificate Requirements,"For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well). However, the client MUST ignore and skip any unrecognized certificate extension OIDs. If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an ""unsupported_certificate"" alert.",waiting fill
36,4.2.5.. Handshake Protocol_Extensions_OID Filters,OID Uniqueness and Matching Rules,"Any given OID MUST NOT appear more than once in the filters list. PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types. Depending on the type, matching certificate extension values are not necessarily bitwise-equal. This document defines matching rules for two standard certificate extensions defined in [RFC5280]:

- The Key Usage extension in a certificate matches the request when all key usage bits asserted in the request are also asserted in the Key Usage certificate extension.

- The Extended Key Usage extension in a certificate matches the request when all key purpose OIDs present in the request are also found in the Extended Key Usage certificate extension. The special anyExtendedKeyUsage OID MUST NOT be used in the request.",waiting fill
37,4.2.7.. Handshake Protocol_Extensions_Supported Groups,Server Behavior with Supported Groups,"As of TLS 1.3, servers are permitted to send the ""supported_groups"" extension to the client. Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections. If the server has a group it prefers to the ones in the ""key_share"" extension but is still willing to accept the ClientHello, it SHOULD send ""supported_groups"" to update the client's view of its preferences; this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client.",waiting fill
38,4.2.8.. Handshake Protocol_Extensions_Key Share,Client Shares Description,"client_shares: A list of offered KeyShareEntry values in descending order of client preference. This vector MAY be empty if the client is requesting a HelloRetryRequest. Each KeyShareEntry value MUST correspond to a group offered in the ""supported_groups"" extension and MUST appear in the same order.",waiting fill
39,4.2.8.. Handshake Protocol_Extensions_Key Share,KeyShare Entry Rules,"Clients can offer as many KeyShareEntry values as the number of supported groups it is offering, each representing a single set of key exchange parameters. Clients MUST NOT offer multiple KeyShareEntry values for the same group and MUST NOT offer any for groups not listed in the client's ""supported_groups"" extension. Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated.",waiting fill
40,4.2.8.. Handshake Protocol_Extensions_Key Share,Selected Group Verification,"Upon receipt of this extension in a HelloRetryRequest, the client MUST verify that (1) the selected_group field corresponds to a group provided in the ""supported_groups"" extension in the original ClientHello and (2) the selected_group field does not correspond to a group provided in the ""key_share"" extension in the original ClientHello. If either check fails, the client MUST abort the handshake with an ""illegal_parameter"" alert.",waiting fill
41,4.2.8.. Handshake Protocol_Extensions_Key Share,Server Share Requirements,"If using (EC)DHE key establishment, servers offer exactly one KeyShareEntry in the ServerHello. This value MUST be in the same group as the KeyShareEntry value offered by the client that the server has selected for the negotiated key exchange. Servers MUST NOT send a KeyShareEntry for any group not indicated in the client's ""supported_groups"" extension and MUST NOT send a KeyShareEntry when using the ""psk_ke"" PskKeyExchangeMode.",waiting fill
42,4.2.8.. Handshake Protocol_Extensions_Key Share,Verification of Selected NamedGroup,"If using (EC)DHE key establishment and a HelloRetryRequest containing a ""key_share"" extension was received by the client, the client MUST verify that the selected NamedGroup in the ServerHello is the same as that in the HelloRetryRequest. If this check fails, the client MUST abort the handshake with an ""illegal_parameter"" alert.",waiting fill
43,4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters,Public Key Validation,Peers MUST validate each other's public key Y by ensuring that 1 < Y < p-1. This check ensures that the remote peer is properly behaved and isn't forcing the local system into a small subgroup.,waiting fill
44,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Public Value Validation,"For the curves secp256r1, secp384r1, and secp521r1, peers MUST validate each other's public value Q by ensuring that the point is a valid point on the elliptic curve. The validation process consists of three steps:
1. Verify that Q is not the point at infinity (O).
2. Verify that both integers x and y are in the correct interval for Q = (x, y).
3. Ensure that (x, y) is a correct solution to the elliptic curve equation.
Implementors do not need to verify membership in the correct subgroup.",waiting fill
45,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,PSK Key Exchange Modes Extension Overview,"In order to use PSKs, clients MUST also send a ""psk_key_exchange_modes"" extension. The semantics of this extension are that the client only supports the use of PSKs with these modes, which restricts both the use of PSKs offered in this ClientHello and those which the server might supply via NewSessionTicket.",waiting fill
46,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Client Requirements for PSK Extensions,"A client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension. If clients offer ""pre_shared_key"" without a ""psk_key_exchange_modes"" extension, servers MUST abort the handshake. Servers MUST NOT select a key exchange mode that is not listed by the client. This extension also restricts the modes for use with PSK resumption. Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes; however, if a server does so, the impact will just be that the client's attempts at resumption fail.",waiting fill
47,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Server Restrictions on PSK Extensions,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",waiting fill
48,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Key Exchange Mode Descriptions,"1. psk_ke: PSK-only key establishment. In this mode, the server MUST NOT supply a ""key_share"" value.

2. psk_dhe_ke: PSK with (EC)DHE key establishment. In this mode, the client and server MUST supply ""key_share"" values as described in Section 4.2.8.",waiting fill
49,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Future Key Exchange Modes,"Any future values that are allocated must ensure that the transmitted protocol messages unambiguously identify which mode was selected by the server; at present, this is indicated by the presence of the ""key_share"" in the ServerHello.",waiting fill
50,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Early Data Indication Overview,"When a PSK is used and early data is allowed for that PSK, the client can send Application Data in its first flight of messages. If the client opts to do so, it MUST supply both the ""pre_shared_key"" and ""early_data"" extensions.",waiting fill
51,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Parameters for 0-RTT Data,"The parameters for the 0-RTT data (version, symmetric cipher suite, Application-Layer Protocol Negotiation (ALPN) [RFC7301] protocol, etc.) are those associated with the PSK in use. For externally provisioned PSKs, the associated values are those provisioned along with the key. For PSKs established via a NewSessionTicket message, the associated values are those which were negotiated in the connection which established the PSK. The PSK used to encrypt the early data MUST be the first PSK listed in the client's ""pre_shared_key"" extension.",waiting fill
52,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Server Validation of PSK Ticket Age,"For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued. If it is not, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.",waiting fill
53,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Server Response to Early Data Extension,"A server which receives an ""early_data"" extension MUST behave in one of three ways:

- Ignore the extension and return a regular 1-RTT response. The server then skips past early data by attempting to deprotect received records using the handshake traffic key, discarding records which fail deprotection (up to the configured max_early_data_size). Once a record is deprotected successfully, it is treated as the start of the client's second flight and the server proceeds as with an ordinary 1-RTT handshake.

- Request that the client send another ClientHello by responding with a HelloRetryRequest. A client MUST NOT include the ""early_data"" extension in its followup ClientHello. The server then ignores early data by skipping all records with an external content type of ""application_data"" (indicating that they are encrypted), up to the configured max_early_data_size.

- Return its own ""early_data"" extension in EncryptedExtensions, indicating that it intends to process the early data. It is not possible for the server to accept only a subset of the early data messages.",waiting fill
54,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Requirements for Accepting Early Data,"In order to accept early data, the server MUST have accepted a PSK cipher suite and selected the first key offered in the client's ""pre_shared_key"" extension. In addition, it MUST verify that the following values are the same as those associated with the selected PSK:

- The TLS version number
- The selected cipher suite
- The selected ALPN [RFC7301] protocol, if any

These requirements are a superset of those needed to perform a 1-RTT handshake using the PSK in question.",waiting fill
55,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Error Handling for Early Data,"If any of the checks fail, the server MUST NOT respond with the extension and must discard all the first-flight data using one of the first two mechanisms listed above (thus falling back to 1-RTT or 2-RTT). If the client attempts a 0-RTT handshake but the server rejects it, the server will generally not have the 0-RTT record protection keys and must instead use trial decryption to find the first non-0-RTT message.",waiting fill
56,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Error Handling Requirements,"If the server chooses to accept the ""early_data"" extension, then it MUST comply with the same error-handling requirements specified for all records when processing early data records. Specifically, if the server fails to decrypt a 0-RTT record following an accepted ""early_data"" extension, it MUST terminate the connection with a ""bad_record_mac"" alert as per Section 5.2.",waiting fill
57,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Field Descriptions,"1. identity: A label for a key, such as a ticket or a label for a pre-shared key established externally.

2. obfuscated_ticket_age: An obfuscated version of the age of the key. For identities established via the NewSessionTicket message, this is formed as described in Section 4.2.11.1. For externally established identities, an obfuscated_ticket_age of 0 SHOULD be used, and servers MUST ignore the value.

3. identities: A list of identities the client is willing to negotiate with the server. If sent alongside the ""early_data"" extension, the first identity is used for 0-RTT data.

4. binders: A series of HMAC values, one for each value in the identities list, computed as described below.

5. selected_identity: The server's chosen identity expressed as a (0-based) index into the identities in the client's list.",waiting fill
58,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,PSK Hash Algorithm,"Each PSK is associated with a single Hash algorithm. For PSKs established via the ticket mechanism, this is the KDF Hash algorithm on the connection where the ticket was established. For externally established PSKs, the Hash algorithm MUST be set when the PSK is established or default to SHA-256 if no such algorithm is defined. The server MUST ensure that it selects a compatible PSK (if any) and cipher suite.",waiting fill
59,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Binder Validation,"Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value. If this value is not present or does not validate, the server MUST abort the handshake. Servers SHOULD select a single PSK and validate solely the binder corresponding to that PSK.",waiting fill
60,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Client Verification,"Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server ""key_share"" extension is present if required by the ClientHello ""psk_key_exchange_modes"" extension. If these values are not consistent, the client MUST abort the handshake with an ""illegal_parameter"" alert.",waiting fill
61,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Early Data Handling,"If the server supplies an ""early_data"" extension, the client MUST verify that the server's selected_identity is 0. If any other value is returned, the client MUST abort the handshake with an ""illegal_parameter"" alert.",waiting fill
62,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Extension Positioning,"The ""pre_shared_key"" extension MUST be the last extension in the ClientHello. Servers MUST check that it is the last extension and otherwise fail the handshake with an ""illegal_parameter"" alert.",waiting fill
63,4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age,Client Ticket Age Handling,"The client's view of the age of a ticket is the time since the receipt of the NewSessionTicket message. Clients MUST NOT attempt to use tickets which have ages greater than the ""ticket_lifetime"" value provided with the ticket.",waiting fill
64,4.2.11.3.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Processing Order,0-RTT Data Streaming and Processing Order,"Clients are permitted to ""stream"" 0-RTT data until they receive the server's Finished message. Only after this should they send the EndOfEarlyData message, followed by the remainder of the handshake. To avoid deadlocks, when accepting early data, servers MUST process the client's ClientHello and then immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending its ServerHello.",waiting fill
65,4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,EncryptedExtensions Message Overview,"In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message. This is the first message that is encrypted under keys derived from the server_handshake_traffic_secret.",waiting fill
66,4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,Purpose of EncryptedExtensions,"The EncryptedExtensions message contains extensions that can be protected, i.e., any which are not needed to establish the cryptographic context but which are not associated with individual certificates. The client MUST check EncryptedExtensions for the presence of any forbidden extensions and if any are found MUST abort the handshake with an ""illegal_parameter"" alert.",waiting fill
67,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,CertificateRequest Message Overview,"A server which is authenticating with a certificate MAY optionally request a certificate from the client. This message, if sent, MUST follow EncryptedExtensions.",waiting fill
68,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Field Descriptions,"1. certificate_request_context: An opaque string which identifies the certificate request and will be echoed in the client's Certificate message. This context MUST be unique within the scope of the connection to prevent replay of client CertificateVerify messages. This field SHALL be zero length unless used for post-handshake authentication exchanges described in Section 4.6.2. When requesting post-handshake authentication, the server SHOULD make the context unpredictable to the client to prevent pre-computation of valid CertificateVerify messages by an attacker.

2. extensions: A set of extensions describing the parameters of the certificate being requested. The ""signature_algorithms"" extension MUST be specified, and other extensions may optionally be included if defined for this message. Clients MUST ignore unrecognized extensions.",waiting fill
69,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Restrictions for PSK Authentication,"Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6).",waiting fill
70,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate Message Overview,"This message conveys the endpoint's certificate chain to the peer. The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK). The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2). If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the ""certificate_list"" field having length 0). A Finished message MUST be sent regardless of whether the Certificate message is empty.",waiting fill
71,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Field Descriptions,"1. **certificate_request_context**: If this message is in response to a CertificateRequest, the value of certificate_request_context in that message. Otherwise (in the case of server authentication), this field SHALL be zero length.

2. **certificate_list**: A sequence (chain) of CertificateEntry structures, each containing a single certificate and set of extensions.

3. **extensions**: A set of extension values for the CertificateEntry. Valid extensions for server certificates include the OCSP Status extension [RFC6066] and the SignedCertificateTimestamp extension [RFC6962]. Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message, and those from the client MUST correspond to the CertificateRequest message from the server.",waiting fill
72,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate Chain Requirements,"If the corresponding certificate type extension (""server_certificate_type"" or ""client_certificate_type"") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate. The sender's certificate MUST come in the first CertificateEntry in the list. Each following certificate SHOULD directly certify the one immediately preceding it. A certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates.",waiting fill
73,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Handling Certificate List Ordering,"Prior to TLS 1.3, ""certificate_list"" ordering required each certificate to certify the one immediately preceding it; however, some implementations allowed flexibility. For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first.",waiting fill
74,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,RawPublicKey Certificate Type,"If the RawPublicKey certificate type was negotiated, then the certificate_list MUST contain no more than one CertificateEntry, which contains an ASN1_subjectPublicKeyInfo value as defined in [RFC7250], Section 3.",waiting fill
75,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,OpenPGP Certificate Type,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,waiting fill
76,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Server Certificate List Requirement,The server's certificate_list MUST always be non-empty. A client will send an empty certificate_list if it does not have an appropriate certificate to send in response to the server's authentication request.,waiting fill
77,4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,OCSP Status Extension in TLS 1.3,"In TLS 1.3, the server's OCSP information is carried in an extension within the CertificateEntry that contains the associated certificate. The body of the 'status_request' extension from the server MUST be a CertificateStatus structure as defined in [RFC6066], which is interpreted according to [RFC6960].",waiting fill
78,4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,Deprecation of status_request_v2 Extension,"The status_request_v2 extension [RFC6961] is deprecated. TLS 1.3 servers MUST NOT act upon its presence or the information contained within it when processing ClientHello messages. Specifically, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. However, TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients wishing to use it in earlier protocol versions.",waiting fill
79,4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,Client OCSP Response Request,"A server MAY request that a client present an OCSP response with its certificate by sending an empty 'status_request' extension in its CertificateRequest message. If the client opts to send an OCSP response, the body of its 'status_request' extension MUST be a CertificateStatus structure as defined in [RFC6066].",waiting fill
80,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Certificate Selection Rules,"The following rules apply to the certificates sent by the server:

- The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).

- The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension (currently RSA, ECDSA, or EdDSA).

- The certificate MUST allow the key to be used for signing (i.e., the digitalSignature bit MUST be set if the Key Usage extension is present) with a signature scheme indicated in the client's ""signature_algorithms""/""signature_algorithms_cert"" extensions (see Section 4.2.3).

- The ""server_name"" [RFC6066] and ""certificate_authorities"" extensions are used to guide certificate selection. As servers MAY require the presence of the ""server_name"" extension, clients SHOULD send this extension when applicable.",waiting fill
81,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Certificate Chain Signing Requirements,All certificates provided by the server MUST be signed by a signature algorithm advertised by the client if it is able to provide such a chain (see Section 4.2.3). Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.,waiting fill
82,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Fallback Certificate Chain Handling,"If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then it SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms that are not known to be supported by the client. This fallback chain SHOULD NOT use the deprecated SHA-1 hash algorithm in general, but MAY do so if the client's advertisement permits it, and MUST NOT do so otherwise.",waiting fill
83,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Client Handling of Certificate Chains,"If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then it MUST abort the handshake with an appropriate certificate-related alert (by default, ""unsupported_certificate""; see Section 6.2 for more information).",waiting fill
84,4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection,Client Certificate Selection Rules,"The following rules apply to certificates sent by the client:

- The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).

- If the ""certificate_authorities"" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.

- The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2. Note that this relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.

- If the CertificateRequest message contained a non-empty ""oid_filters"" extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client, as described in Section 4.2.5.",waiting fill
85,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Server Certificate Handling,"If the server supplies an empty Certificate message, the client MUST abort the handshake with a ""decode_error"" alert.",waiting fill
86,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Signature Algorithm Restrictions,"Any endpoint receiving any certificate which it would need to validate using any signature algorithm using an MD5 hash MUST abort the handshake with a ""bad_certificate"" alert. SHA-1 is deprecated, and it is RECOMMENDED that any endpoint receiving any certificate which it would need to validate using any signature algorithm using a SHA-1 hash abort the handshake with a ""bad_certificate"" alert. For clarity, this means that endpoints can accept these algorithms for certificates that are self-signed or are trust anchors.",waiting fill
87,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,CertificateVerify Message Overview,"This message is used to provide explicit proof that an endpoint possesses the private key corresponding to its certificate. The CertificateVerify message also provides integrity for the handshake up to this point. Servers MUST send this message when authenticating via a certificate. Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty). When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.",waiting fill
88,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Algorithm Requirements,"If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's ""signature_algorithms"" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3). If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the ""signature_algorithms"" extension in the CertificateRequest message.",waiting fill
89,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Algorithm Compatibility,"The signature algorithm MUST be compatible with the key in the sender's end-entity certificate. RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in ""signature_algorithms"". The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.",waiting fill
90,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Verification Process,"The receiver of a CertificateVerify message MUST verify the signature field. The verification process takes as input:

- The content covered by the digital signature
- The public key contained in the end-entity certificate found in the associated Certificate message
- The digital signature received in the signature field of the CertificateVerify message.",waiting fill
91,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Error Handling,"If the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert.",waiting fill
92,4.4.4.. Handshake Protocol_Authentication Messages_Finished,Finished Message Overview,"The Finished message is the final message in the Authentication Block. It is essential for providing authentication of the handshake and of the computed keys. Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a ""decrypt_error"" alert.",waiting fill
93,4.4.4.. Handshake Protocol_Authentication Messages_Finished,Post-Finished Message Requirements,"Any records following a Finished message MUST be encrypted under the appropriate application traffic key as described in Section 7.2. In particular, this includes any alerts sent by the server in response to client Certificate and CertificateVerify messages.",waiting fill
94,4.5.. Handshake Protocol_End of Early Data,EndOfEarlyData Message Overview,"struct {} EndOfEarlyData;

If the server sent an ""early_data"" extension in EncryptedExtensions, the client MUST send an EndOfEarlyData message after receiving the server Finished. If the server does not send an ""early_data"" extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message. This message indicates that all 0-RTT application_data messages, if any, have been transmitted and that the following records are protected under handshake traffic keys.",waiting fill
95,4.5.. Handshake Protocol_End of Early Data,Message Handling Requirements,"Servers MUST NOT send this message, and clients receiving it MUST terminate the connection with an ""unexpected_message"" alert. This message is encrypted under keys derived from the client_early_traffic_secret.",waiting fill
96,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Ticket Resumption Requirements,"Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection. Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session. If such an indication is provided (externally or by any other means), clients MAY resume with a different SNI value.",waiting fill
97,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,SNI Value Reporting,"On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session. Note that if a server implementation declines all PSK identities with different SNI values, these two values are always the same.",waiting fill
98,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Field Descriptions,"1. ticket_lifetime: Indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance. Servers MUST NOT use any value greater than 604800 seconds (7 days). The value of zero indicates that the ticket should be discarded immediately.

2. ticket_age_add: A securely generated, random 32-bit value that obscures the age of the ticket included in the ""pre_shared_key"" extension. The server MUST generate a fresh value for each ticket it sends.

3. ticket_nonce: A per-ticket value that is unique across all tickets issued on this connection.

4. ticket: The value of the ticket to be used as the PSK identity. It MAY be either a database lookup key or a self-encrypted and self-authenticated value.

5. extensions: A set of extension values for the ticket. Clients MUST ignore unrecognized extensions.",waiting fill
99,4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Post-Handshake Authentication Overview,"When the client has sent the ""post_handshake_auth"" extension, a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message. The client MUST respond with the appropriate Authentication messages. If the client chooses to authenticate, it MUST send Certificate, CertificateVerify, and Finished. If it declines, it MUST send a Certificate message containing no certificates followed by Finished. All of the client's messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.",waiting fill
100,4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,CertificateRequest Handling,"A client that receives a CertificateRequest message without having sent the ""post_handshake_auth"" extension MUST send an ""unexpected_message"" fatal alert.",waiting fill
101,4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Client Response Timing Considerations,"Because client authentication could involve prompting the user, servers MUST be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response. In addition, clients which receive multiple CertificateRequests in close succession MAY respond to them in a different order than they were received, as the certificate_request_context value allows the server to disambiguate the responses.",waiting fill
102,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,KeyUpdate Message Overview,"The KeyUpdate handshake message is used to indicate that the sender is updating its sending cryptographic keys. This message can be sent by either peer after it has sent a Finished message. Implementations that receive a KeyUpdate message prior to receiving a Finished message MUST terminate the connection with an 'unexpected_message' alert. After sending a KeyUpdate message, the sender SHALL send all its traffic using the next generation of keys, computed as described in Section 7.2. Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.",waiting fill
103,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,request_update Field Description,"The request_update field indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate. If an implementation receives any other value, it MUST terminate the connection with an 'illegal_parameter' alert.",waiting fill
104,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,KeyUpdate Response Mechanism,"If the request_update field is set to 'update_requested', then the receiver MUST send a KeyUpdate of its own with request_update set to 'update_not_requested' prior to sending its next Application Data record. This mechanism allows either side to force an update to the entire connection, but causes an implementation which receives multiple KeyUpdates while it is silent to respond with a single update.",waiting fill
105,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Encryption and KeyUpdate Order,"Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys. Additionally, both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key. Failure to do so may allow message truncation attacks.",waiting fill
