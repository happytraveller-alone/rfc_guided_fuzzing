ID,Section,Title,Content
1,Section: 4.. Handshake Protocol,Handshake Protocol Overview,"The handshake protocol is used to negotiate the security parameters of a connection. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext or TLSCiphertext structures which are processed and transmitted as specified by the current active connection state."
2,Section: 4.. Handshake Protocol,Handshake Message Types,"The following enumeration defines the types of handshake messages:
```
enum {
    client_hello(1),
    server_hello(2),
    new_session_ticket(4),
    end_of_early_data(5),
    encrypted_extensions(8),
    certificate(11),
    certificate_request(13),
    certificate_verify(15),
    finished(20),
    key_update(24),
    message_hash(254),
    (255)
"
3,Section: 4.. Handshake Protocol,Handshake Message Structure,"The structure of a handshake message is defined as follows:
```
struct {
    HandshakeType msg_type;    /* handshake type */
    uint24 length;             /* remaining bytes in message */
    select (Handshake.msg_type) {
        case client_hello:          ClientHello;
        case server_hello:          ServerHello;
        case end_of_early_data:     EndOfEarlyData;
        case encrypted_extensions:  EncryptedExtensions;
        case certificate_request:   CertificateRequest;
        case certificate:           Certificate;
        case certificate_verify:    CertificateVerify;
        case finished:              Finished;
        case new_session_ticket:    NewSessionTicket;
        case key_update:            KeyUpdate;
    "
4,Section: 4.. Handshake Protocol,Message Order Requirements,"Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2. A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert. New handshake message types are assigned by IANA as described in Section 11."
5,Section: 4.1.. Handshake Protocol_Key Exchange Messages,Key Exchange Messages Purpose,"The key exchange messages are used to determine the security capabilities of the client and the server and to establish shared secrets, including the traffic keys used to protect the rest of the handshake and the data."
6,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Cryptographic Negotiation Overview,"In TLS, the cryptographic negotiation proceeds by the client offering the following four sets of options in its ClientHello:"
7,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Cipher Suites,A list of cipher suites which indicates the AEAD algorithm/HKDF hash pairs which the client supports.
8,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Supported Groups and Key Shares,"A ""supported_groups"" (Section 4.2.7) extension which indicates the (EC)DHE groups supported by the client and a ""key_share"" (Section 4.2.8) extension which contains (EC)DHE shares for some or all of these groups."
9,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Signature Algorithms,"A ""signature_algorithms"" (Section 4.2.3) extension which indicates the signature algorithms the client can accept. A ""signature_algorithms_cert"" extension (Section 4.2.3) may also be added to indicate certificate-specific signature algorithms."
10,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Pre-Shared Keys,"A ""pre_shared_key"" (Section 4.2.11) extension which contains a list of symmetric key identities known to the client and a ""psk_key_exchange_modes"" (Section 4.2.9) extension which indicates the key exchange modes that may be used with PSKs."
11,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Server Parameter Selection,"If the server does not select a PSK, then the first three options are entirely orthogonal: the server independently selects a cipher suite, an (EC)DHE group and key share for key establishment, and a signature algorithm/certificate pair to authenticate itself to the client. If there is no overlap between the received ""supported_groups"" and the groups supported by the server, then the server MUST abort the handshake with a ""handshake_failure"" or an ""insufficient_security"" alert."
12,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,PSK Selection,"If the server selects a PSK, then it MUST also select a key establishment mode from the set indicated by the client's ""psk_key_exchange_modes"" extension. Note that if the PSK can be used without (EC)DHE, then non-overlap in the ""supported_groups"" parameters need not be fatal."
13,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,HelloRetryRequest Condition,"If the server selects an (EC)DHE group and the client did not offer a compatible ""key_share"" extension in the initial ClientHello, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message."
14,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,ServerHello Parameter Indication,"If the server successfully selects parameters and does not require a HelloRetryRequest, it indicates the selected parameters in the ServerHello as follows:"
15,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,PSK Extension,"If PSK is being used, then the server will send a ""pre_shared_key"" extension indicating the selected key."
16,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Key Share Extension,"When (EC)DHE is in use, the server will also provide a ""key_share"" extension. If PSK is not being used, then (EC)DHE and certificate-based authentication are always used."
17,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Certificate Authentication,"When authenticating via a certificate, the server will send the Certificate (Section 4.4.2) and CertificateVerify (Section 4.4.3) messages. In TLS 1.3 as defined by this document, either a PSK or a certificate is always used, but not both. Future documents may define how to use them together."
18,Section: 4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Negotiation Failure,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6)."
19,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,ClientHello Purpose,"When a client first connects to a server, it is REQUIRED to send the ClientHello as its first TLS message. The client will also send a ClientHello when the server has responded to its ClientHello with a HelloRetryRequest. In that case, the client MUST send the same ClientHello without modification, except as follows: - If a ""key_share"" extension was supplied in the HelloRetryRequest, replacing the list of shares with a list containing a single KeyShareEntry from the indicated group. - Removing the ""early_data"" extension if one was present. Early data is not permitted after a HelloRetryRequest. - Including a ""cookie"" extension if one was provided in the HelloRetryRequest. - Updating the ""pre_shared_key"" extension if present by recomputing the ""obfuscated_ticket_age"" and binder values and (optionally) removing any PSKs which are incompatible with the server's indicated cipher suite. - Optionally adding, removing, or changing the length of the ""padding"" extension [RFC7685]. - Other modifications that may be allowed by an extension defined in the future and present in the HelloRetryRequest. Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an ""unexpected_message"" alert. If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version. In particular, it MUST NOT negotiate TLS 1.3."
20,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Structure of ClientHello Message,Structure of this message: uint16 ProtocolVersion; opaque Random[32]; uint8 CipherSuite[2]; struct { ProtocolVersion legacy_version = 0x0303; /* TLS v1.2 */ Random random; opaque legacy_session_id<0..32>; CipherSuite cipher_suites<2..2^16-2>; opaque legacy_compression_methods<1..2^8-1>; Extension extensions<8..2^16-1>; 
21,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Legacy Version Field,"legacy_version: In previous versions of TLS, this field was used for version negotiation and represented the highest version number supported by the client. Experience has shown that many servers do not properly implement version negotiation, leading to ""version intolerance"" in which the server rejects an otherwise acceptable ClientHello with a version number higher than it supports. In TLS 1.3, the client indicates its version preferences in the ""supported_versions"" extension (Section 4.2.1) and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2. TLS 1.3 ClientHellos are identified as having a legacy_version of 0x0303 and a supported_versions extension present with 0x0304 as the highest version indicated therein. (See Appendix D for details about backward compatibility.)"
22,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Random Field Requirements,random: 32 bytes generated by a secure random number generator. See Appendix C for additional information.
23,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Session ID Requirements,"legacy_session_id: Versions of TLS before TLS 1.3 supported a ""session resumption"" feature which has been merged with pre-shared keys in this version (see Section 2.2). A client which has a cached session ID set by a pre-TLS 1.3 server SHOULD set this field to that value. In compatibility mode (see Appendix D.4), this field MUST be non-empty, so a client not offering a pre-TLS 1.3 session MUST generate a new 32-byte value. This value need not be random but SHOULD be unpredictable to avoid implementations fixating on a specific value (also known as ossification). Otherwise, it MUST be set as a zero-length vector (i.e., a zero-valued single byte length field)."
24,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Cipher Suites,"cipher_suites: A list of the symmetric cipher options supported by the client, specifically the record protection algorithm (including secret key length) and a hash to be used with HKDF, in descending order of client preference. Values are defined in Appendix B.4. If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual. If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK."
25,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Legacy Compression Methods,"legacy_compression_methods: Versions of TLS before 1.3 supported compression with the list of supported compression methods being sent in this field. For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS. If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an ""illegal_parameter"" alert. Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and (if negotiating such a prior version) MUST follow the procedures for the appropriate prior version of TLS."
26,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Extensions,"extensions: Clients request extended functionality from servers by sending data in the extensions field. The actual ""Extension"" format is defined in Section 4.2. In TLS 1.3, the use of certain extensions is mandatory, as functionality has moved into extensions to preserve ClientHello compatibility with previous versions of TLS. Servers MUST ignore unrecognized extensions."
27,Section: 4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,ClientHello Transmission,"After sending the ClientHello message, the client waits for a ServerHello or HelloRetryRequest message. If early data is in use, the client may transmit early Application Data (Section 2.3) while waiting for the next handshake message."
28,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,ServerHello Purpose,The server will send this message in response to a ClientHello message to proceed with the handshake if it is able to negotiate an acceptable set of handshake parameters based on the ClientHello.
29,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,ServerHello Structure,"The structure of this message is defined as follows:
```
struct {
    ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
    Random random;
    opaque legacy_session_id_echo<0..32>;
    CipherSuite cipher_suite;
    uint8 legacy_compression_method = 0;
    Extension extensions<6..2^16-1>;
"
30,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Legacy Version Field,"The legacy_version field is set to 0x0303, which corresponds to TLS v1.2. This field is critical for backward compatibility, as some middleboxes may not handle new values correctly. TLS 1.3 indicates version using the ""supported_versions"" extension (Section 4.2.1)."
31,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Random Field Requirements,The random field consists of 32 bytes generated by a secure random number generator. The last 8 bytes must be overwritten based on the negotiated TLS version. This structure must be generated independently of the ClientHello.random.
32,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Session ID Echo Requirements,"The legacy_session_id_echo field contains the client's legacy_session_id. A mismatch with the value sent in ClientHello causes the handshake to abort with an ""illegal_parameter"" alert."
33,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Cipher Suite Selection,"The cipher_suite field contains the single cipher suite selected by the server from the ClientHello.cipher_suites. If the suite was not offered, the client must abort the handshake with an ""illegal_parameter"" alert."
34,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Legacy Compression Method,The legacy_compression_method field must be set to 0.
35,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Extensions Requirements,"The extensions field includes necessary extensions for establishing the cryptographic context and negotiating the protocol version. All TLS 1.3 ServerHello messages must contain the ""supported_versions"" extension, and may include ""pre_shared_key"" or ""key_share"" extensions. Other extensions are sent in the EncryptedExtensions message (see Section 4.2)."
36,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,HelloRetryRequest Special Case,"The HelloRetryRequest message has the same structure as ServerHello but uses a specific Random value. Upon receiving a server_hello message, implementations must check the Random value as specified in Section 4.1.4."
37,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Downgrade Protection Mechanism,"TLS 1.3 embeds a downgrade protection mechanism in the Random value. If negotiating TLS 1.2, the last 8 bytes of Random must be set to 44 4F 57 4E 47 52 44 01. For TLS 1.1 or below, it must be set to 44 4F 57 4E 47 52 44 00. Clients receiving a ServerHello indicating TLS 1.2 or below must ensure these bytes do not match the specified values, or abort with an ""illegal_parameter"" alert."
38,Section: 4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Legacy Client Renegotiation,"A legacy TLS client that receives a TLS 1.3 ServerHello during renegotiation with TLS 1.2 or prior must abort the handshake with a ""protocol_version"" alert. Renegotiation is not permitted once TLS 1.3 is established."
39,Section: 4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Hello Retry Request Overview,"The server will send this message in response to a ClientHello if it can find an acceptable set of parameters but the ClientHello does not contain sufficient information to proceed with the handshake. The HelloRetryRequest has the same format as a ServerHello message, and the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields have the same meaning. However, it is discussed throughout this document as if it were a distinct message."
40,Section: 4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Extensions Requirements,"The server's extensions MUST contain ""supported_versions."" Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair. A HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, except for optionally the ""cookie"" extension."
41,Section: 4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Client Processing Rules,"Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3. The client MUST abort the handshake with an ""illegal_parameter"" alert if the HelloRetryRequest would not result in any change in the ClientHello. If a client receives a second HelloRetryRequest in the same connection, it MUST abort the handshake with an ""unexpected_message"" alert."
42,Section: 4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Extension Processing,The client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello. The HelloRetryRequest extensions defined in this specification are: - supported_versions (see Section 4.2.1) - cookie (see Section 4.2.2) - key_share (see Section 4.2.8).
43,Section: 4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Cipher Suite Consistency,"A client which receives a cipher suite that was not offered MUST abort the handshake. Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello. Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an ""illegal_parameter"" alert."
44,Section: 4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Pre-Shared Key Considerations,"In its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite. This allows the client to avoid having to compute partial hash transcripts for multiple hashes in the second ClientHello."
45,Section: 4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Version Retention Requirement,"The value of selected_version in the HelloRetryRequest ""supported_versions"" extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an ""illegal_parameter"" alert if the value changes."
46,Section: 4.2.. Handshake Protocol_Extensions,Extension Structure,"A number of TLS messages contain tag-length-value encoded extensions structures.

```c
struct {
    ExtensionType extension_type;
    opaque extension_data<0..2^16-1>;
"
47,Section: 4.2.. Handshake Protocol_Extensions,Extension Type Enumeration,"The list of extension types is maintained by IANA as described in Section 11.

```c
enum {
    server_name(0),                             /* RFC 6066 */
    max_fragment_length(1),                     /* RFC 6066 */
    status_request(5),                          /* RFC 6066 */
    supported_groups(10),                       /* RFC 8422, 7919 */
    signature_algorithms(13),                   /* RFC 8446 */
    use_srtp(14),                               /* RFC 5764 */
    heartbeat(15),                              /* RFC 6520 */
    application_layer_protocol_negotiation(16), /* RFC 7301 */
    signed_certificate_timestamp(18),           /* RFC 6962 */
    client_certificate_type(19),                /* RFC 7250 */
    server_certificate_type(20),                /* RFC 7250 */
    padding(21),                                /* RFC 7685 */
    pre_shared_key(41),                         /* RFC 8446 */
    early_data(42),                             /* RFC 8446 */
    supported_versions(43),                     /* RFC 8446 */
    cookie(44),                                 /* RFC 8446 */
    psk_key_exchange_modes(45),                 /* RFC 8446 */
    certificate_authorities(47),                /* RFC 8446 */
    oid_filters(48),                            /* RFC 8446 */
    post_handshake_auth(49),                    /* RFC 8446 */
    signature_algorithms_cert(50),              /* RFC 8446 */
    key_share(51),                              /* RFC 8446 */
    (65535)
"
48,Section: 4.2.. Handshake Protocol_Extensions,Extension Request/Response Model,"Extensions are generally structured in a request/response fashion, though some extensions are just indications with no corresponding response. The client sends its extension requests in the `ClientHello` message, and the server sends its extension responses in the `ServerHello`, `EncryptedExtensions`, `HelloRetryRequest`, and `Certificate` messages. The server sends extension requests in the `CertificateRequest` message, which a client MAY respond to with a `Certificate` message. The server MAY also send unsolicited extensions in the `NewSessionTicket`, though the client does not respond directly to these."
49,Section: 4.2.. Handshake Protocol_Extensions,Extension Response Constraints,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the `cookie` extension in the `HelloRetryRequest`. Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert. If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an ""illegal_parameter"" alert."
50,Section: 4.2.. Handshake Protocol_Extensions,Extension Message Table,"The table below indicates the messages where a given extension may appear, using the following notation: CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), and HRR (HelloRetryRequest).

| Extension                                        |     TLS 1.3     |
|--------------------------------------------------|-----------------|
| server_name [RFC6066]                            |      CH, EE     |
| max_fragment_length [RFC6066]                    |      CH, EE     |
| status_request [RFC6066]                         |  CH, CR, CT     |
| supported_groups [RFC7919]                       |      CH, EE     |
| signature_algorithms (RFC 8446)                  |      CH, CR     |
| use_srtp [RFC5764]                               |      CH, EE     |
| heartbeat [RFC6520]                              |      CH, EE     |
| application_layer_protocol_negotiation [RFC7301] |      CH, EE     |
| signed_certificate_timestamp [RFC6962]           |  CH, CR, CT     |
| client_certificate_type [RFC7250]                |      CH, EE     |
| server_certificate_type [RFC7250]                |      CH, EE     |
| padding [RFC7685]                                |          CH     |
| key_share (RFC 8446)                             | CH, SH, HRR     |
| pre_shared_key (RFC 8446)                        |      CH, SH     |
| psk_key_exchange_modes (RFC 8446)                |          CH     |
| early_data (RFC 8446)                            | CH, EE, NST     |
| cookie (RFC 8446)                                |     CH, HRR     |
| supported_versions (RFC 8446)                    | CH, SH, HRR     |
| certificate_authorities (RFC 8446)               |      CH, CR     |
| oid_filters (RFC 8446)                           |          CR     |
| post_handshake_auth (RFC 8446)                   |          CH     |
| signature_algorithms_cert (RFC 8446)             |      CH, CR     |
"
51,Section: 4.2.. Handshake Protocol_Extensions,Extension Negotiation Considerations,"In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each handshake even when in resumption-PSK mode. However, 0-RTT parameters are those negotiated in the previous handshake; mismatches may require rejecting 0-RTT (see Section 4.2.10)."
52,Section: 4.2.. Handshake Protocol_Extensions,Security Considerations for Extensions,"There are subtle (and not so subtle) interactions that may occur in this protocol between new features and existing features which may result in a significant reduction in overall security. The following considerations should be taken into account when designing new extensions:

- Some cases where a server does not agree to an extension are error conditions (e.g., the handshake cannot continue), and some are simply refusals to support particular features. In general, error alerts should be used for the former and a field in the server extension response for the latter.

- Extensions should, as far as possible, be designed to prevent any attack that forces use (or non-use) of a particular feature by manipulation of handshake messages. This principle should be followed regardless of whether the feature is believed to cause a security problem. Often the fact that the extension fields are included in the inputs to the Finished message hashes will be sufficient, but extreme care is needed when the extension changes the meaning of messages sent in the handshake phase. Designers and implementors should be aware of the fact that until the handshake has been authenticated, active attackers can modify messages and insert, remove, or replace extensions."
53,Section: 4.2.1.. Handshake Protocol_Extensions_Supported Versions,SupportedVersions Structure,"The ""supported_versions"" extension is used by the client to indicate which versions of TLS it supports and by the server to indicate which version it is using. The extension contains a list of supported versions in preference order, with the most preferred version first. Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which they are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, they MUST be present as well)."
54,Section: 4.2.1.. Handshake Protocol_Extensions_Supported Versions,Server Negotiation Requirements,"If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later."
55,Section: 4.2.1.. Handshake Protocol_Extensions_Supported Versions,ClientHello Extension Processing,"If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension. Note that this mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions."
56,Section: 4.2.1.. Handshake Protocol_Extensions_Supported Versions,ServerHello Requirements,"A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2). Clients MUST check for this extension prior to processing the rest of the ServerHello. If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version. If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert."
57,Section: 4.2.2.. Handshake Protocol_Extensions_Cookie,Cookie Structure,"The structure of a cookie is defined as follows:

```plaintext
struct {
    opaque cookie<1..2^16-1>;
"
58,Section: 4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Algorithms Extensions Overview,"TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures. The ""signature_algorithms_cert"" extension applies to signatures in certificates, and the ""signature_algorithms"" extension applies to signatures in CertificateVerify messages. The keys found in certificates MUST also be of appropriate type for the signature algorithms they are used with. If no ""signature_algorithms_cert"" extension is present, then the ""signature_algorithms"" extension also applies to signatures appearing in certificates. Clients which desire the server to authenticate itself via a certificate MUST send the ""signature_algorithms"" extension. If a server is authenticating via a certificate and the client has not sent a ""signature_algorithms"" extension, then the server MUST abort the handshake with a ""missing_extension"" alert (see Section 9.2)."
59,Section: 4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,"Purpose of ""signature_algorithms_cert""","The ""signature_algorithms_cert"" extension was added to allow implementations which supported different sets of algorithms for certificates and in TLS itself to clearly signal their capabilities. TLS 1.2 implementations SHOULD also process this extension. Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension."
60,Section: 4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,SignatureSchemeList Structure,"The ""extension_data"" field of these extensions contains a SignatureSchemeList value:

```plaintext
enum {
    /* RSASSA-PKCS1-v1_5 algorithms */
    rsa_pkcs1_sha256(0x0401),
    rsa_pkcs1_sha384(0x0501),
    rsa_pkcs1_sha512(0x0601),

    /* ECDSA algorithms */
    ecdsa_secp256r1_sha256(0x0403),
    ecdsa_secp384r1_sha384(0x0503),
    ecdsa_secp521r1_sha512(0x0603),

    /* RSASSA-PSS algorithms with public key OID rsaEncryption */
    rsa_pss_rsae_sha256(0x0804),
    rsa_pss_rsae_sha384(0x0805),
    rsa_pss_rsae_sha512(0x0806),

    /* EdDSA algorithms */
    ed25519(0x0807),
    ed448(0x0808),

    /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
    rsa_pss_pss_sha256(0x0809),
    rsa_pss_pss_sha384(0x080a),
    rsa_pss_pss_sha512(0x080b),

    /* Legacy algorithms */
    rsa_pkcs1_sha1(0x0201),
    ecdsa_sha1(0x0203),

    /* Reserved Code Points */
    private_use(0xFE00..0xFFFF),
    (0xFFFF)
"
61,Section: 4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Algorithm Definitions,"Note that a signature algorithm takes as input an arbitrary-length message, rather than a digest. Algorithms which traditionally act on a digest should be defined in TLS to first hash the input with a specified hash algorithm and then proceed as usual. The code point groups listed above have the following meanings:

- **RSASSA-PKCS1-v1_5 algorithms**: Indicates a signature algorithm using RSASSA-PKCS1-v1_5 [RFC8017] with the corresponding hash algorithm as defined in [SHS].
  
- **ECDSA algorithms**: Indicates a signature algorithm using ECDSA [ECDSA] and the corresponding curve as defined in ANSI X9.62 [ECDSA] and FIPS 186-4 [DSS].
  
- **RSASSA-PSS RSAE algorithms**: Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1.
  
- **EdDSA algorithms**: Indicates a signature algorithm using EdDSA as defined in [RFC8032].
  
- **RSASSA-PSS PSS algorithms**: Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1.

- **Legacy algorithms**: Indicates algorithms which are being deprecated, specifically SHA-1 used with either RSA or ECDSA."
62,Section: 4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Certificate Signature Validation,"The signatures on certificates that are self-signed or certificates that are trust anchors are not validated, since they begin a certification path (see [RFC5280], Section 3.2). A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the ""signature_algorithms"" extension."
63,Section: 4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,TLS 1.2 Compatibility Notes,"Note that TLS 1.2 defines this extension differently. TLS 1.3 implementations willing to negotiate TLS 1.2 MUST behave in accordance with the requirements of [RFC5246] when negotiating that version. In particular:
- TLS 1.2 ClientHellos MAY omit this extension.
- In TLS 1.2, the extension contained hash/signature pairs.
- ECDSA signature schemes align with TLS 1.2's ECDSA hash/signature pairs.
- Implementations that advertise support for RSASSA-PSS MUST be prepared to accept a signature using that scheme even when TLS 1.2 is negotiated."
64,Section: 4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Certificate Authorities Extension Purpose,"The ""certificate_authorities"" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection."
65,Section: 4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,CertificateAuthoritiesExtension Structure,"The body of the ""certificate_authorities"" extension consists of a CertificateAuthoritiesExtension structure."
66,Section: 4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,DistinguishedName Definition,opaque DistinguishedName<1..2^16-1>;
67,Section: 4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Certificate Authorities Structure,struct { DistinguishedName authorities<3..2^16-1>; 
68,Section: 4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Authorities Field Description,"authorities: A list of the distinguished names [X501] of acceptable certificate authorities, represented in DER-encoded [X690] format. These distinguished names specify a desired distinguished name for a trust anchor or subordinate CA; thus, this message can be used to describe known trust anchors as well as a desired authorization space."
69,Section: 4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Extension Usage,"The client MAY send the ""certificate_authorities"" extension in the ClientHello message. The server MAY send it in the CertificateRequest message."
70,Section: 4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Deprecated Extension Note,"The ""trusted_ca_keys"" extension [RFC6066], which serves a similar purpose but is more complicated, is not used in TLS 1.3 (although it may appear in ClientHello messages from clients which are offering prior versions of TLS)."
71,Section: 4.2.5.. Handshake Protocol_Extensions_OID Filters,OID Filters Extension Overview,"The ""oid_filters"" extension allows servers to provide a set of OID/value pairs which it would like the client's certificate to match. This extension, if provided by the server, MUST only be sent in the CertificateRequest message."
72,Section: 4.2.5.. Handshake Protocol_Extensions_OID Filters,OIDFilter Structure,"The structure for OID filters is defined as follows:
```c
struct {
    opaque certificate_extension_oid<1..2^8-1>;
    opaque certificate_extension_values<0..2^16-1>;
"
73,Section: 4.2.5.. Handshake Protocol_Extensions_OID Filters,OIDFilterExtension Structure,"The OID filter extension structure is defined as:
```c
struct {
    OIDFilter filters<0..2^16-1>;
"
74,Section: 4.2.5.. Handshake Protocol_Extensions_OID Filters,Filters List Requirements,"The filters consist of a list of certificate extension OIDs [RFC5280] with their allowed value(s), represented in DER-encoded [X690] format. If the server includes a non-empty filters list, the client certificate included in the response MUST contain all specified extension OIDs that the client recognizes. For recognized OIDs, all specified values MUST be present in the client certificate, though the certificate MAY have other values as well. Unrecognized OIDs MUST be ignored by the client."
75,Section: 4.2.5.. Handshake Protocol_Extensions_OID Filters,Server Actions on Certificate Validation,"If the client ignores some required certificate extension OIDs and supplies a certificate that does not satisfy the request, the server MAY either continue the connection without client authentication or abort the handshake with an ""unsupported_certificate"" alert."
76,Section: 4.2.5.. Handshake Protocol_Extensions_OID Filters,OID Uniqueness Requirement,Any given OID MUST NOT appear more than once in the filters list.
77,Section: 4.2.5.. Handshake Protocol_Extensions_OID Filters,Certificate Extension Matching Rules,"This document defines matching rules for two standard certificate extensions as per [RFC5280]:
- **Key Usage**: Matches when all key usage bits asserted in the request are also asserted in the Key Usage certificate extension.
- **Extended Key Usage**: Matches when all key purpose OIDs present in the request are found in the Extended Key Usage certificate extension. The special `anyExtendedKeyUsage` OID MUST NOT be used in the request."
78,Section: 4.2.5.. Handshake Protocol_Extensions_OID Filters,Additional Specifications,Separate specifications may define matching rules for other certificate extensions.
79,Section: 4.2.6.. Handshake Protocol_Extensions_Post-Handshake Client Authentication,Post-Handshake Authentication Extension,"The ""post_handshake_auth"" extension is used to indicate that a client is willing to perform post-handshake authentication (Section 4.6.2). Servers MUST NOT send a post-handshake CertificateRequest to clients which do not offer this extension. Servers MUST NOT send this extension."
80,Section: 4.2.6.. Handshake Protocol_Extensions_Post-Handshake Client Authentication,PostHandshakeAuth Structure,struct {
81,Section: 4.2.7.. Handshake Protocol_Extensions_Supported Groups,Supported Groups Extension Purpose,"When sent by the client, the ""supported_groups"" extension indicates the named groups which the client supports for key exchange, ordered from most preferred to least preferred. Note: In versions of TLS prior to TLS 1.3, this extension was named ""elliptic_curves"" and only contained elliptic curve groups. See [RFC8422] and [RFC7919]. This extension was also used to negotiate ECDSA curves. Signature algorithms are now negotiated independently (see Section 4.2.3)."
82,Section: 4.2.7.. Handshake Protocol_Extensions_Supported Groups,NamedGroupList Structure,"The ""extension_data"" field of this extension contains a ""NamedGroupList"" value:

```
enum {
    /* Elliptic Curve Groups (ECDHE) */
    secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
    x25519(0x001D), x448(0x001E),

    /* Finite Field Groups (DHE) */
    ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
    ffdhe6144(0x0103), ffdhe8192(0x0104),

    /* Reserved Code Points */
    ffdhe_private_use(0x01FC..0x01FF),
    ecdhe_private_use(0xFE00..0xFEFF),
    (0xFFFF)
"
83,Section: 4.2.7.. Handshake Protocol_Extensions_Supported Groups,Group Definitions,"Elliptic Curve Groups (ECDHE): Indicates support for the corresponding named curve, defined in either FIPS 186-4 [DSS] or [RFC7748]. Values 0xFE00 through 0xFEFF are reserved for Private Use [RFC8126]. Finite Field Groups (DHE): Indicates support for the corresponding finite field group, defined in [RFC7919]. Values 0x01FC through 0x01FF are reserved for Private Use."
84,Section: 4.2.7.. Handshake Protocol_Extensions_Supported Groups,Preference Order,Items in named_group_list are ordered according to the sender's preferences (most preferred choice first).
85,Section: 4.2.7.. Handshake Protocol_Extensions_Supported Groups,Server Behavior,"As of TLS 1.3, servers are permitted to send the ""supported_groups"" extension to the client. Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections. If the server has a group it prefers to the ones in the ""key_share"" extension but is still willing to accept the ClientHello, it SHOULD send ""supported_groups"" to update the client's view of its preferences; this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client."
86,Section: 4.2.8.. Handshake Protocol_Extensions_Key Share,Key Share Extension Purpose,"The ""key_share"" extension contains the endpoint's cryptographic parameters. Clients MAY send an empty client_shares vector in order to request group selection from the server, at the cost of an additional round trip (see Section 4.1.4)."
87,Section: 4.2.8.. Handshake Protocol_Extensions_Key Share,KeyShareEntry Structure,"The structure of a KeyShareEntry is defined as follows:
```plaintext
struct {
    NamedGroup group;
    opaque key_exchange<1..2^16-1>;
"
88,Section: 4.2.8.. Handshake Protocol_Extensions_Key Share,ClientHello Key Share Data Structure,"In the ClientHello message, the ""extension_data"" field contains a ""KeyShareClientHello"" value:
```plaintext
struct {
    KeyShareEntry client_shares<0..2^16-1>;
"
89,Section: 4.2.8.. Handshake Protocol_Extensions_Key Share,Key Share Entry Constraints,"Clients can offer as many KeyShareEntry values as the number of supported groups. Each KeyShareEntry MUST be generated independently. Clients MUST NOT offer multiple KeyShareEntry values for the same group or for groups not listed in the ""supported_groups"" extension. Servers MAY check for rule violations and abort the handshake with an ""illegal_parameter"" alert if any are found."
90,Section: 4.2.8.. Handshake Protocol_Extensions_Key Share,HelloRetryRequest Key Share Structure,"In a HelloRetryRequest message, the ""extension_data"" field contains a KeyShareHelloRetryRequest value:
```plaintext
struct {
    NamedGroup selected_group;
"
91,Section: 4.2.8.. Handshake Protocol_Extensions_Key Share,ServerHello Key Share Structure,"In a ServerHello message, the ""extension_data"" field contains a KeyShareServerHello value:
```plaintext
struct {
    KeyShareEntry server_share;
"
92,Section: 4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters,Diffie-Hellman Parameters Encoding,Diffie-Hellman [DH76] parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure. The opaque value contains the Diffie-Hellman public value (Y = g^X mod p) for the specified group (see [RFC7919] for group definitions) encoded as a big-endian integer and padded to the left with zeros to the size of p in bytes.
93,Section: 4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters,Public Key Length Consistency,"For a given Diffie-Hellman group, the padding results in all public keys having the same length."
94,Section: 4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters,Public Key Validation,Peers MUST validate each other's public key Y by ensuring that 1 < Y < p-1. This check ensures that the remote peer is properly behaved and isn't forcing the local system into a small subgroup.
95,Section: 4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,ECDHE Key Share Structure,ECDHE parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure.
96,Section: 4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Uncompressed Point Representation Structure,"For secp256r1, secp384r1, and secp521r1, the contents are the serialized value of the following struct:
```
struct {
    uint8 legacy_form = 4;
    opaque X[coordinate_length];
    opaque Y[coordinate_length];
"
97,Section: 4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Public Value Validation,"For the curves secp256r1, secp384r1, and secp521r1, peers MUST validate each other's public value Q by ensuring that the point is valid on the elliptic curve, following these steps:
1. Verify that Q is not the point at infinity (O).
2. Ensure both integers x and y are in the correct interval.
3. Confirm that (x, y) satisfies the elliptic curve equation.
Implementors do not need to verify membership in the correct subgroup."
98,Section: 4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,X25519 and X448 Public Value Format,"For X25519 and X448, the contents of the public value are the byte string inputs and outputs of the corresponding functions defined in [RFC7748]: 32 bytes for X25519 and 56 bytes for X448."
99,Section: 4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Point Format Negotiation Removal,Note: Versions of TLS prior to 1.3 permitted point format negotiation; TLS 1.3 removes this feature in favor of a single point format for each curve.
100,Section: 4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,PSK Key Exchange Modes Requirement,"In order to use PSKs, clients MUST also send a ""psk_key_exchange_modes"" extension. The semantics of this extension are that the client only supports the use of PSKs with these modes, restricting both the PSKs offered in this ClientHello and those the server might supply via NewSessionTicket. A client MUST provide this extension if it offers a ""pre_shared_key"" extension. If clients offer ""pre_shared_key"" without a ""psk_key_exchange_modes"" extension, servers MUST abort the handshake. Servers MUST NOT select a key exchange mode not listed by the client. This extension also restricts the modes for use with PSK resumption; servers SHOULD NOT send NewSessionTicket with tickets incompatible with the advertised modes. If a server does so, the impact will just be that the client's attempts at resumption fail. The server MUST NOT send a ""psk_key_exchange_modes"" extension."
101,Section: 4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,PskKeyExchangeMode Enumeration,"enum { psk_ke(0), psk_dhe_ke(1), (255) "
102,Section: 4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,PskKeyExchangeModes Structure,struct { PskKeyExchangeMode ke_modes<1..255>; 
103,Section: 4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Key Exchange Modes Details,"psk_ke: PSK-only key establishment. In this mode, the server MUST NOT supply a ""key_share"" value. psk_dhe_ke: PSK with (EC)DHE key establishment. In this mode, the client and server MUST supply ""key_share"" values as described in Section 4.2.8. Any future values allocated must ensure that the transmitted protocol messages unambiguously identify which mode was selected by the server; currently, this is indicated by the presence of the ""key_share"" in the ServerHello."
104,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Early Data Indication Overview,"When a PSK is used and early data is allowed for that PSK, the client can send Application Data in its first flight of messages. If the client opts to do so, it MUST supply both the ""pre_shared_key"" and ""early_data"" extensions."
105,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Early Data Indication Structure,"The ""extension_data"" field contains an ""EarlyDataIndication"" value defined as follows: 

```plaintext
struct {"
106,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,PSK Data Requirements,"The parameters for the 0-RTT data (version, symmetric cipher suite, Application-Layer Protocol Negotiation (ALPN) [RFC7301] protocol, etc.) are those associated with the PSK in use. The PSK used to encrypt early data MUST be the first PSK listed in the client's ""pre_shared_key"" extension."
107,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Ticket Age Validation,"For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity is within a small tolerance of the time since the ticket was issued. If the validation fails, the server SHOULD proceed with the handshake but reject 0-RTT and SHOULD NOT take any other action that assumes freshness."
108,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Early Data Handling,"0-RTT messages sent in the first flight have the same (encrypted) content types as messages sent in other flights but are protected under different keys. If the server accepts early data, an EndOfEarlyData message will be sent, encrypted with the 0-RTT traffic keys."
109,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Server Response Options,"A server which receives an ""early_data"" extension MUST either: 
- Ignore the extension and return a regular 1-RTT response, discarding records which fail deprotection.
- Request another ClientHello via a HelloRetryRequest, skipping early data.
- Return its own ""early_data"" extension in EncryptedExtensions, indicating acceptance of early data."
110,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Acceptance Conditions,"To accept early data, the server MUST verify that the TLS version number, selected cipher suite, and selected ALPN protocol match those associated with the selected PSK. If any checks fail, the server MUST discard early data and revert to 1-RTT or 2-RTT."
111,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Error Handling Requirements,"If the server fails to decrypt a 0-RTT record following acceptance of the ""early_data"" extension, it MUST terminate the connection with a ""bad_record_mac"" alert as per Section 5.2."
112,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Client Retransmission Options,"If the server rejects the ""early_data"" extension, the client application MAY opt to retransmit previously sent Application Data after the handshake is complete, but caution is advised regarding the state of the connection and ALPN protocol."
113,Section: 4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Implementation Recommendations,A TLS implementation SHOULD NOT automatically resend early data; applications are better positioned to determine appropriate retransmission scenarios. A TLS implementation MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol.
114,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Pre-Shared Key Extension Purpose,"The ""pre_shared_key"" extension is used to negotiate the identity of the pre-shared key to be used with a given handshake in association with PSK key establishment."
115,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,PreSharedKeyExtension Structure,"The ""extension_data"" field of this extension contains a ""PreSharedKeyExtension"" value:
```
struct {
    select (Handshake.msg_type) {
        case client_hello: OfferedPsks;
        case server_hello: uint16 selected_identity;
    "
116,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,PskIdentity Structure,"```
struct {
    opaque identity<1..2^16-1>;
    uint32 obfuscated_ticket_age;
"
117,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Identity and Ticket Age,"identity: A label for a key, such as a ticket (as defined in Appendix B.3.4) or a label for a pre-shared key established externally. obfuscated_ticket_age: An obfuscated version of the age of the key. For identities established externally, an obfuscated_ticket_age of 0 SHOULD be used, and servers MUST ignore the value."
118,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Client Offer and Server Response,"identities: A list of the identities that the client is willing to negotiate with the server. If sent alongside the ""early_data"" extension, the first identity is the one used for 0-RTT data. binders: A series of HMAC values, one for each value in the identities list, computed as described below. selected_identity: The server's chosen identity expressed as a (0-based) index into the identities in the client's list."
119,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Hash Algorithm Association,"Each PSK is associated with a single Hash algorithm. For PSKs established via the ticket mechanism, this is the KDF Hash algorithm on the connection where the ticket was established. For externally established PSKs, the Hash algorithm MUST be set when the PSK is established or default to SHA-256 if no such algorithm is defined."
120,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Server Name Indication,"In TLS 1.3, the SNI value is always explicitly specified in the resumption handshake, and there is no need for the server to associate an SNI value with the ticket. Clients, however, SHOULD store the SNI with the PSK to fulfill the requirements of Section 4.6.1."
121,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,PSK Matching Requirements,"When session resumption is the primary use case of PSKs, the straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and exclude any incompatible PSKs. If no acceptable PSKs are found, the server SHOULD perform a non-PSK handshake if possible."
122,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Binder Validation,"Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value. If this value is not present or does not validate, the server MUST abort the handshake. Servers SHOULD NOT attempt to validate multiple binders; rather, they SHOULD select a single PSK and validate solely the binder that corresponds to that PSK."
123,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Client Verification,"Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server ""key_share"" extension is present if required by the ClientHello ""psk_key_exchange_modes"" extension."
124,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Early Data and Selected Identity,"If the server supplies an ""early_data"" extension, the client MUST verify that the server's selected_identity is 0. If any other value is returned, the client MUST abort the handshake with an ""illegal_parameter"" alert."
125,Section: 4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Extension Position Requirement,"The ""pre_shared_key"" extension MUST be the last extension in the ClientHello. Servers MUST check that it is the last extension and otherwise fail the handshake with an ""illegal_parameter"" alert."
126,Section: 4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age,Ticket Age Definition,"The client's view of the age of a ticket is the time since the receipt of the NewSessionTicket message. Clients MUST NOT attempt to use tickets which have ages greater than the ""ticket_lifetime"" value which was provided with the ticket."
127,Section: 4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age,Obfuscated Ticket Age Calculation,"The ""obfuscated_ticket_age"" field of each PskIdentity contains an obfuscated version of the ticket age formed by taking the age in milliseconds and adding the ""ticket_age_add"" value that was included with the ticket (see Section 4.6.1), modulo 2^32. This addition prevents passive observers from correlating connections unless tickets are reused."
128,Section: 4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age,Field Units Clarification,"Note that the ""ticket_lifetime"" field in the NewSessionTicket message is in seconds but the ""obfuscated_ticket_age"" is in milliseconds. Because ticket lifetimes are restricted to a week, 32 bits is enough to represent any plausible age, even in milliseconds."
129,Section: 4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,PSK Binder Value Purpose,"The PSK binder value forms a binding between a PSK and the current handshake, as well as a binding between the handshake in which the PSK was generated (if via a NewSessionTicket message) and the current handshake."
130,Section: 4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,Binder Computation,"Each entry in the binders list is computed as an HMAC over a transcript hash (see Section 4.4.1) containing a partial ClientHello up to and including the PreSharedKeyExtension.identities field. This includes all of the ClientHello but not the binders list itself. The length fields for the message (including the overall length, the length of the extensions block, and the length of the ""pre_shared_key"" extension) are all set as if binders of the correct lengths were present."
131,Section: 4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,PskBinderEntry Computation,The PskBinderEntry is computed in the same way as the Finished message (Section 4.4.4) but with the BaseKey being the binder_key derived via the key schedule from the corresponding PSK which is being offered (see Section 7.1).
132,Section: 4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,Handling HelloRetryRequest,"If the handshake includes a HelloRetryRequest, the initial ClientHello and HelloRetryRequest are included in the transcript along with the new ClientHello. For example, if the client sends ClientHello1, its binder will be computed over: Transcript-Hash(Truncate(ClientHello1)), where Truncate() removes the binders list from the ClientHello."
133,Section: 4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,Binder Calculation Across Multiple ClientHellos,"If the server responds with a HelloRetryRequest and the client then sends ClientHello2, its binder will be computed over: Transcript-Hash(ClientHello1, HelloRetryRequest, Truncate(ClientHello2)). The full ClientHello1/ClientHello2 is included in all other handshake hash computations. Note that in the first flight, Truncate(ClientHello1) is hashed directly, but in the second flight, ClientHello1 is hashed and then reinjected as a ""message_hash"" message, as described in Section 4.4.1."
134,Section: 4.2.11.3.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Processing Order,0-RTT Data Handling,"Clients are permitted to ""stream"" 0-RTT data until they receive the server's Finished, only then sending the EndOfEarlyData message, followed by the rest of the handshake. In order to avoid deadlocks, when accepting ""early_data"", servers MUST process the client's ClientHello and then immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending its ServerHello."
135,Section: 4.3.. Handshake Protocol_Server Parameters,Server Messages Overview,"The next two messages from the server, EncryptedExtensions and CertificateRequest, contain information from the server that determines the rest of the handshake. These messages are encrypted with keys derived from the server_handshake_traffic_secret."
136,Section: 4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,EncryptedExtensions Message Requirements,"In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message. This is the first message that is encrypted under keys derived from the server_handshake_traffic_secret."
137,Section: 4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,Extension Content Guidelines,"The EncryptedExtensions message contains extensions that can be protected, i.e., any which are not needed to establish the cryptographic context but which are not associated with individual certificates. The client MUST check EncryptedExtensions for the presence of any forbidden extensions and if any are found MUST abort the handshake with an ""illegal_parameter"" alert."
138,Section: 4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,Structure Definition,"Structure of this message:

      struct {
          Extension extensions<0..2^16-1>;
      "
139,Section: 4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Certificate Request Purpose,"A server which is authenticating with a certificate MAY optionally request a certificate from the client. This message, if sent, MUST follow EncryptedExtensions."
140,Section: 4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Structure of CertificateRequest,"The structure of this message is as follows:

```plaintext
struct {
    opaque certificate_request_context<0..2^8-1>;
    Extension extensions<2..2^16-1>;
"
141,Section: 4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Certificate Request Context,"The `certificate_request_context` is an opaque string which identifies the certificate request and will be echoed in the client's Certificate message. It MUST be unique within the scope of this connection to prevent replay of client CertificateVerify messages. This field SHALL be zero length unless used for post-handshake authentication exchanges described in Section 4.6.2. When requesting post-handshake authentication, the server SHOULD make the context unpredictable (e.g., by randomly generating it) to prevent an attacker with temporary access to the client's private key from pre-computing valid CertificateVerify messages."
142,Section: 4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Extensions Requirements,"The `extensions` field is a set of extensions describing the parameters of the certificate being requested. The ""signature_algorithms"" extension MUST be specified, and other extensions may be included if defined for this message. Clients MUST ignore unrecognized extensions."
143,Section: 4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Differences from Previous Versions,"In prior versions of TLS, the CertificateRequest message included a list of signature algorithms and certificate authorities accepted by the server. In TLS 1.3, the signature algorithms are expressed through the ""signature_algorithms"" and optionally ""signature_algorithms_cert"" extensions, while the certificate authorities are expressed using the ""certificate_authorities"" extension (see Section 4.2.4)."
144,Section: 4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,PSK Authentication Restriction,"Servers authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, but they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6)."
145,Section: 4.4.. Handshake Protocol_Authentication Messages,Authentication Message Overview,"TLS generally uses a common set of messages for authentication, key confirmation, and handshake integrity: Certificate, CertificateVerify, and Finished. These three messages are always sent as the last messages in their handshake flight. The Certificate and CertificateVerify messages are only sent under certain circumstances, as defined below. The Finished message is always sent as part of the Authentication Block. These messages are encrypted under keys derived from the [sender]_handshake_traffic_secret."
146,Section: 4.4.. Handshake Protocol_Authentication Messages,Authentication Message Inputs,"The computations for the Authentication messages all uniformly take the following inputs:  
- The certificate and signing key to be used.  
- A Handshake Context consisting of the set of messages to be included in the transcript hash.  
- A Base Key to be used to compute a MAC key."
147,Section: 4.4.. Handshake Protocol_Authentication Messages,Message Definitions,"  
**Certificate:** The certificate to be used for authentication, along with any supporting certificates in the chain. Note that certificate-based client authentication is not available in PSK handshake flows (including 0-RTT).  
**CertificateVerify:** A signature over the value Transcript-Hash(Handshake Context, Certificate).  
**Finished:** A MAC over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using a MAC key derived from the Base Key."
148,Section: 4.4.. Handshake Protocol_Authentication Messages,Handshake Context and MAC Base Key Table,"  
The following table defines the Handshake Context and MAC Base Key for each scenario:

| Mode      | Handshake Context       | Base Key                    |
|-----------|-------------------------|-----------------------------|
| Server    | ClientHello ... later   | server_handshake_traffic_   |
|           | of EncryptedExtensions/ | secret                      |
|           | CertificateRequest      |                             |
| Client    | ClientHello ... later   | client_handshake_traffic_   |
|           | of server               | secret                      |
|           | Finished/EndOfEarlyData |                             |
| Post-     | ClientHello ... client  | client_application_traffic_ |
| Handshake | Finished +              | secret_N                    |
|           | CertificateRequest      |                             |
"
149,Section: 4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Transcript Hash Definition,"Many of the cryptographic computations in TLS make use of a transcript hash. This value is computed by hashing the concatenation of each included handshake message, including the handshake message header carrying the handshake message type and length fields, but not including record layer headers."
150,Section: 4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Transcript Hash Calculation,"Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)"
151,Section: 4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,HelloRetryRequest Exception,"As an exception to this general rule, when the server responds to a ClientHello with a HelloRetryRequest, the value of ClientHello1 is replaced with a special synthetic handshake message of handshake type ""message_hash"" containing Hash(ClientHello1)."
152,Section: 4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Specialized Transcript Hash Calculation,"Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) = Hash(message_hash || 00 00 Hash.length || Hash(ClientHello1) || HelloRetryRequest || ... || Mn)"
153,Section: 4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Reason for Construction,"The reason for this construction is to allow the server to do a stateless HelloRetryRequest by storing just the hash of ClientHello1 in the cookie, rather than requiring it to export the entire intermediate hash state (see Section 4.2.2)."
154,Section: 4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Message Sequence for Transcript Hash,"The transcript hash is always taken from the following sequence of handshake messages: ClientHello, HelloRetryRequest, ClientHello, ServerHello, EncryptedExtensions, server CertificateRequest, server Certificate, server CertificateVerify, server Finished, EndOfEarlyData, client Certificate, client CertificateVerify, client Finished."
155,Section: 4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Implementation Note,"In general, implementations can implement the transcript by keeping a running transcript hash value based on the negotiated hash. Note, however, that subsequent post-handshake authentications do not include each other, just the messages through the end of the main handshake."
156,Section: 4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate Message Purpose,"This message conveys the endpoint's certificate chain to the peer. The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK). The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2). If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the ""certificate_list"" field having length 0). A Finished message MUST be sent regardless of whether the Certificate message is empty."
157,Section: 4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate Structure,"Structure of this message:
```
enum {
    X509(0),
    RawPublicKey(2),
    (255)
"
158,Section: 4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate Request Context,"certificate_request_context: If this message is in response to a CertificateRequest, the value of certificate_request_context in that message. Otherwise (in the case of server authentication), this field SHALL be zero length."
159,Section: 4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate List,"certificate_list: A sequence (chain) of CertificateEntry structures, each containing a single certificate and set of extensions."
160,Section: 4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Extensions in Certificate,"extensions: A set of extension values for the CertificateEntry. The ""Extension"" format is defined in Section 4.2. Valid extensions for server certificates at present include the OCSP Status extension [RFC6066] and the SignedCertificateTimestamp extension [RFC6962]; future extensions may be defined for this message as well. Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message. Extensions in the Certificate message from the client MUST correspond to extensions in the CertificateRequest message from the server. If an extension applies to the entire chain, it SHOULD be included in the first CertificateEntry."
161,Section: 4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate Ordering Rules,"If the corresponding certificate type extension (""server_certificate_type"" or ""client_certificate_type"") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate. The sender's certificate MUST come in the first CertificateEntry in the list. Each following certificate SHOULD directly certify the one immediately preceding it. Because certificate validation requires that trust anchors be distributed independently, a certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates."
162,Section: 4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Compatibility Considerations,"Note: Prior to TLS 1.3, ""certificate_list"" ordering required each certificate to certify the one immediately preceding it; however, some implementations allowed some flexibility. Servers sometimes send both a current and deprecated intermediate for transitional purposes, and others are simply configured incorrectly, but these cases can nonetheless be validated properly. For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first."
163,Section: 4.4.2.. Handshake Protocol_Authentication Messages_Certificate,RawPublicKey Requirements,"If the RawPublicKey certificate type was negotiated, then the certificate_list MUST contain no more than one CertificateEntry, which contains an ASN1_subjectPublicKeyInfo value as defined in [RFC7250], Section 3."
164,Section: 4.4.2.. Handshake Protocol_Authentication Messages_Certificate,OpenPGP Certificate Restrictions,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.
165,Section: 4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Non-Empty Certificate List,The server's certificate_list MUST always be non-empty. A client will send an empty certificate_list if it does not have an appropriate certificate to send in response to the server's authentication request.
166,Section: 4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,OCSP Status Negotiation,"RFC6066 and RFC6961 provide extensions to negotiate the server sending OCSP responses to the client. In TLS 1.2 and below, the server replies with an empty extension to indicate negotiation of this extension, and the OCSP information is carried in a CertificateStatus message. In TLS 1.3, the server's OCSP information is carried in an extension in the CertificateEntry containing the associated certificate. Specifically, the body of the ""status_request"" extension from the server MUST be a CertificateStatus structure as defined in RFC6066, interpreted as defined in RFC6960."
167,Section: 4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,Status Request V2 Deprecation,"The status_request_v2 extension (RFC6961) is deprecated. TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients that wish to use it in earlier protocol versions."
168,Section: 4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,Client OCSP Response Request,"A server MAY request that a client present an OCSP response with its certificate by sending an empty ""status_request"" extension in its CertificateRequest message. If the client opts to send an OCSP response, the body of its ""status_request"" extension MUST be a CertificateStatus structure as defined in RFC6066."
169,Section: 4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,SCT Information in TLS 1.3,"Similarly, RFC6962 provides a mechanism for a server to send a Signed Certificate Timestamp (SCT) as an extension in the ServerHello in TLS 1.2 and below. In TLS 1.3, the server's SCT information is carried in an extension in the CertificateEntry."
170,Section: 4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Certificate Selection Rules,The following rules apply to the certificates sent by the server:
171,Section: 4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection,Client Certificate Rules,"
  - The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).
  
  - If the ""certificate_authorities"" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.

  - The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2. Note that this relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.

  - If the CertificateRequest message contained a non-empty ""oid_filters"" extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client, as described in Section 4.2.5.
"
172,Section: 4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Certificate Validation Requirements,"In general, detailed certificate validation procedures are out of scope for TLS (see [RFC5280]). This section provides TLS-specific requirements."
173,Section: 4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Empty Certificate Handling,"If the server supplies an empty Certificate message, the client MUST abort the handshake with a ""decode_error"" alert. If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a ""certificate_required"" alert."
174,Section: 4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Certificate Chain Acceptance,"If some aspect of the certificate chain was unacceptable (e.g., it was not signed by a known, trusted CA), the server MAY at its discretion either continue the handshake (considering the client unauthenticated) or abort the handshake."
175,Section: 4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Signature Algorithm Restrictions,"Any endpoint receiving any certificate which it would need to validate using any signature algorithm using an MD5 hash MUST abort the handshake with a ""bad_certificate"" alert. SHA-1 is deprecated, and it is RECOMMENDED that any endpoint receiving any certificate which it would need to validate using any signature algorithm using a SHA-1 hash abort the handshake with a ""bad_certificate"" alert. For clarity, this means that endpoints can accept these algorithms for certificates that are self-signed or are trust anchors."
176,Section: 4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Transition Recommendations,All endpoints are RECOMMENDED to transition to SHA-256 or better as soon as possible to maintain interoperability with implementations currently in the process of phasing out SHA-1 support.
177,Section: 4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Key and Signature Algorithm Flexibility,"Note that a certificate containing a key for one signature algorithm MAY be signed using a different signature algorithm (for instance, an RSA key signed with an ECDSA key)."
178,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,CertificateVerify Purpose,"This message is used to provide explicit proof that an endpoint possesses the private key corresponding to its certificate. The CertificateVerify message also provides integrity for the handshake up to this point. Servers MUST send this message when authenticating via a certificate. Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty). When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message."
179,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Structure Definition,"Structure of this message:
```
struct {
    SignatureScheme algorithm;
    opaque signature<0..2^16-1>;
"
180,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Algorithm Specification,"The algorithm field specifies the signature algorithm used (see Section 4.2.3 for the definition of this type). The signature is a digital signature using that algorithm. The content that is covered under the signature is the hash output as described in Section 4.4.1, namely: `Transcript-Hash(Handshake Context, Certificate)`."
181,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Content Concatenation,"The digital signature is computed over the concatenation of:
- A string that consists of octet 32 (0x20) repeated 64 times
- The context string
- A single 0 byte which serves as the separator
- The content to be signed"
182,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Context String Usage,"The context string for a server signature is ""TLS 1.3, server CertificateVerify"". The context string for a client signature is ""TLS 1.3, client CertificateVerify"". This separation helps prevent potential cross-protocol attacks."
183,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Example of Content Covered,"For example, if the transcript hash was 32 bytes of 01 (this length would make sense for SHA-256), the content covered by the digital signature for a server CertificateVerify would be:
```
2020202020202020202020202020202020202020202020202020202020202020
2020202020202020202020202020202020202020202020202020202020202020
544c5320312e332c207365727665722043657274696669636174655665726966
79
00
0101010101010101010101010101010101010101010101010101010101010101
```
"
184,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Computation Process,"The process for computing the signature field of the CertificateVerify message takes as input:
- The content covered by the digital signature
- The private signing key corresponding to the certificate sent in the previous message
"
185,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Algorithm Requirements,"If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's ""signature_algorithms"" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3). If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the ""signature_algorithms"" extension in the CertificateRequest message."
186,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,RSA Signature Constraints,"In addition, the signature algorithm MUST be compatible with the key in the sender's end-entity certificate. RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in ""signature_algorithms"". The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages. All SHA-1 signature algorithms in this specification are defined solely for use in legacy certificates and are not valid for CertificateVerify signatures."
187,Section: 4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Verification Process,"The receiver of a CertificateVerify message MUST verify the signature field. The verification process takes as input:
- The content covered by the digital signature
- The public key contained in the end-entity certificate found in the associated Certificate message
- The digital signature received in the signature field of the CertificateVerify message
If the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert."
188,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Finished Message Overview,The Finished message is the final message in the Authentication Block. It is essential for providing authentication of the handshake and of the computed keys.
189,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Verification Requirement,"Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a ""decrypt_error"" alert."
190,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Post-Finished Data Transmission,"Once a side has sent its Finished message and has received and validated the Finished message from its peer, it may begin to send and receive Application Data over the connection. There are two settings in which it is permitted to send data prior to receiving the peer's Finished: 1. Clients sending 0-RTT data as described in Section 4.2.10. 2. Servers MAY send data after sending their first flight, but because the handshake is not yet complete, they have no assurance of either the peer's identity or its liveness (i.e., the ClientHello might have been replayed)."
191,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Finished Key Computation,"The key used to compute the Finished message is computed from the Base Key defined in Section 4.4 using HKDF (see Section 7.1). Specifically: finished_key = HKDF-Expand-Label(BaseKey, ""finished"", """", Hash.length)."
192,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Message Structure,Structure of this message: struct { opaque verify_data[Hash.length]; 
193,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Verify Data Computation,"The verify_data value is computed as follows: verify_data = HMAC(finished_key, Transcript-Hash(Handshake Context, Certificate*, CertificateVerify*)). * Only included if present."
194,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,HMAC Implementation,"HMAC [RFC2104] uses the Hash algorithm for the handshake. As noted above, the HMAC input can generally be implemented by a running hash, i.e., just the handshake hash at this point."
195,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Length of Verify Data,"In previous versions of TLS, the verify_data was always 12 octets long. In TLS 1.3, it is the size of the HMAC output for the Hash used for the handshake."
196,Section: 4.4.4.. Handshake Protocol_Authentication Messages_Finished,Alert Handling Post-Finished,"Any records following a Finished message MUST be encrypted under the appropriate application traffic key as described in Section 7.2. In particular, this includes any alerts sent by the server in response to client Certificate and CertificateVerify messages."
197,Section: 4.5.. Handshake Protocol_End of Early Data,EndOfEarlyData Structure,struct {
198,Section: 4.5.. Handshake Protocol_End of Early Data,Message Sending Conditions,"If the server sent an ""early_data"" extension in EncryptedExtensions, the client MUST send an EndOfEarlyData message after receiving the server Finished. If the server does not send an ""early_data"" extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message."
199,Section: 4.5.. Handshake Protocol_End of Early Data,Purpose of EndOfEarlyData Message,"This message indicates that all 0-RTT application_data messages, if any, have been transmitted and that the following records are protected under handshake traffic keys."
200,Section: 4.5.. Handshake Protocol_End of Early Data,Server Restrictions,"Servers MUST NOT send this message, and clients receiving it MUST terminate the connection with an ""unexpected_message"" alert."
201,Section: 4.5.. Handshake Protocol_End of Early Data,Encryption Keying,This message is encrypted under keys derived from the client_early_traffic_secret.
202,Section: 4.6.. Handshake Protocol_Post-Handshake Messages,Post-Handshake Message Overview,TLS also allows other messages to be sent after the main handshake. These messages use a handshake content type and are encrypted under the appropriate application traffic key.
203,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,New Session Ticket Message Purpose,"At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message. This message creates a unique association between the ticket value and a secret PSK derived from the resumption master secret (see Section 7)."
204,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,PSK Usage by Client,"The client MAY use this PSK for future handshakes by including the ticket value in the ""pre_shared_key"" extension in its ClientHello (Section 4.2.11). Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events (see Appendix C.4)."
205,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Use Cases for Multiple Tickets,"Multiple tickets are useful for clients for a variety of purposes, including:
- Opening multiple parallel HTTP connections.
- Performing connection racing across interfaces and address families via (for example) Happy Eyeballs [RFC8305] or related techniques."
206,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Cipher Suite Resumption Requirement,Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection.
207,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,SNI Value Requirements,Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session.
208,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,SNI Reporting on Resumption,"On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session."
209,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Server Behavior on Client Authentication,"Note that if a server implementation declines all PSK identities with different SNI values, these two values are always the same."
210,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Early NewSessionTicket Issuance,A server which does not request client authentication MAY compute the remainder of the transcript independently and then send a NewSessionTicket immediately upon sending its Finished rather than waiting for the client Finished.
211,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,NewSessionTicket Structure,"struct {
    uint32 ticket_lifetime;
    uint32 ticket_age_add;
    opaque ticket_nonce<0..255>;
    opaque ticket<1..2^16-1>;
    Extension extensions<0..2^16-2>;
"
212,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,ticket_lifetime Definition,Indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance. Servers MUST NOT use any value greater than 604800 seconds (7 days). The value of zero indicates that the ticket should be discarded immediately.
213,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,ticket_age_add Definition,"A securely generated, random 32-bit value that is used to obscure the age of the ticket that the client includes in the ""pre_shared_key"" extension. The server MUST generate a fresh value for each ticket it sends."
214,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,ticket_nonce Definition,A per-ticket value that is unique across all tickets issued on this connection.
215,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,ticket Definition,The value of the ticket to be used as the PSK identity. The ticket itself is an opaque label.
216,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,extensions Definition,A set of extension values for the ticket. Clients MUST ignore unrecognized extensions.
217,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Early Data Extension,"The sole extension currently defined for NewSessionTicket is ""early_data"", indicating that the ticket may be used to send 0-RTT data (Section 4.2.10)."
218,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,0-RTT Data Size,"max_early_data_size: The maximum amount of 0-RTT data that the client is allowed to send when using this ticket, in bytes."
219,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,PSK Computation,"The PSK associated with the ticket is computed as:
HKDF-Expand-Label(resumption_master_secret, ""resumption"", ticket_nonce, Hash.length)"
220,Section: 4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Keying Material Lifetime Management,"It is RECOMMENDED that implementations place limits on the total lifetime of such keying material; these limits should take into account the lifetime of the peer's certificate, the likelihood of intervening revocation, and the time since the peer's online CertificateVerify signature."
221,Section: 4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Post-Handshake Authentication Process,"When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message. The client MUST respond with the appropriate Authentication messages (see Section 4.4). If the client chooses to authenticate, it MUST send Certificate, CertificateVerify, and Finished. If it declines, it MUST send a Certificate message containing no certificates followed by Finished. All of the client's messages for a given response MUST appear consecutively on the wire with no intervening messages of other types."
222,Section: 4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,CertificateRequest Handling,"A client that receives a CertificateRequest message without having sent the ""post_handshake_auth"" extension MUST send an ""unexpected_message"" fatal alert."
223,Section: 4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Response Timing Considerations,"Because client authentication could involve prompting the user, servers MUST be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response. In addition, clients which receive multiple CertificateRequests in close succession MAY respond to them in a different order than they were received (the certificate_request_context value allows the server to disambiguate the responses)."
224,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,KeyUpdate Message Overview,"The KeyUpdate handshake message is used to indicate that the sender is updating its sending cryptographic keys. This message can be sent by either peer after it has sent a Finished message. Implementations that receive a KeyUpdate message prior to receiving a Finished message MUST terminate the connection with an ""unexpected_message"" alert. After sending a KeyUpdate message, the sender SHALL send all its traffic using the next generation of keys, computed as described in Section 7.2. Upon receiving a KeyUpdate, the receiver MUST update its receiving keys."
225,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,KeyUpdateRequest Enumeration,"enum { update_not_requested(0), update_requested(1), (255) "
226,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,KeyUpdate Structure,struct { KeyUpdateRequest request_update; 
227,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Request Update Field,"request_update: Indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate. If an implementation receives any other value, it MUST terminate the connection with an ""illegal_parameter"" alert."
228,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Update Mechanism,"If the request_update field is set to ""update_requested"", then the receiver MUST send a KeyUpdate of its own with request_update set to ""update_not_requested"" prior to sending its next Application Data record. This mechanism allows either side to force an update to the entire connection, but causes an implementation which receives multiple KeyUpdates while it is silent to respond with a single update."
229,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Message Flow and Forward Secrecy,"Implementations may receive an arbitrary number of messages between sending a KeyUpdate with request_update set to ""update_requested"" and receiving the peer's KeyUpdate, because those messages may already be in flight. However, because send and receive keys are derived from independent traffic secrets, retaining the receive traffic secret does not threaten the forward secrecy of data sent before the sender changed keys."
230,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Crossed KeyUpdates,"If implementations independently send their own KeyUpdates with request_update set to ""update_requested"" and they cross in flight, then each side will also send a response, with the result that each side increments by two generations."
231,Section: 4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,KeyUpdate Message Encryption,"Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys. Additionally, both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key. Failure to do so may allow message truncation attacks."
