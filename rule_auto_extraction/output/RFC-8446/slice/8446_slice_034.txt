{
  "content": "The \"pre_shared_key\" extension is used to negotiate the identity of\n   the pre-shared key to be used with a given handshake in association\n   with PSK key establishment.\n\n   The \"extension_data\" field of this extension contains a\n   \"PreSharedKeyExtension\" value:\n\n      struct {\n          opaque identity<1..2^16-1>;\n          uint32 obfuscated_ticket_age;\n      } PskIdentity;\n\n      opaque PskBinderEntry<32..255>;\n\n      struct {\n          PskIdentity identities<7..2^16-1>;\n          PskBinderEntry binders<33..2^16-1>;\n      } OfferedPsks;\n\n      struct {\n          select (Handshake.msg_type) {\n              case client_hello: OfferedPsks;\n              case server_hello: uint16 selected_identity;\n          };\n      } PreSharedKeyExtension;\n\n   identity:  A label for a key.  For instance, a ticket (as defined in\n      Appendix B.3.4) or a label for a pre-shared key established\n      externally.\n\n   obfuscated_ticket_age:  An obfuscated version of the age of the key.\n      Section 4.2.11.1 describes how to form this value for identities\n      established via the NewSessionTicket message.  For identities\n      established externally, an obfuscated_ticket_age of 0 SHOULD be\n      used, and servers MUST ignore the value.\n\n   identities:  A list of the identities that the client is willing to\n      negotiate with the server.  If sent alongside the \"early_data\"\n      extension (see Section 4.2.10), the first identity is the one used\n      for 0-RTT data.\n\n   binders:  A series of HMAC values, one for each value in the\n      identities list and in the same order, computed as described\n      below.\n\n   selected_identity:  The server's chosen identity expressed as a\n      (0-based) index into the identities in the client's list.\n\n   Each PSK is associated with a single Hash algorithm.  For PSKs\n   established via the ticket mechanism (Section 4.6.1), this is the KDF\n   Hash algorithm on the connection where the ticket was established.\n   For externally established PSKs, the Hash algorithm MUST be set when\n\n   the PSK is established or default to SHA-256 if no such algorithm is\n   defined.  The server MUST ensure that it selects a compatible PSK\n   (if any) and cipher suite.\n\n   In TLS versions prior to TLS 1.3, the Server Name Identification\n   (SNI) value was intended to be associated with the session (Section 3\n   of [RFC6066]), with the server being required to enforce that the SNI\n   value associated with the session matches the one specified in the\n   resumption handshake.  However, in reality the implementations were\n   not consistent on which of two supplied SNI values they would use,\n   leading to the consistency requirement being de facto enforced by the\n   clients.  In TLS 1.3, the SNI value is always explicitly specified in\n   the resumption handshake, and there is no need for the server to\n   associate an SNI value with the ticket.  Clients, however, SHOULD\n   store the SNI with the PSK to fulfill the requirements of\n   Section 4.6.1.\n\n   Implementor's note: When session resumption is the primary use case\n   of PSKs, the most straightforward way to implement the PSK/cipher\n   suite matching requirements is to negotiate the cipher suite first\n   and then exclude any incompatible PSKs.  Any unknown PSKs (e.g., ones\n   not in the PSK database or encrypted with an unknown key) SHOULD\n   simply be ignored.  If no acceptable PSKs are found, the server\n   SHOULD perform a non-PSK handshake if possible.  If backward\n   compatibility is important, client-provided, externally established\n   PSKs SHOULD influence cipher suite selection.\n\n   Prior to accepting PSK key establishment, the server MUST validate\n   the corresponding binder value (see Section 4.2.11.2 below).  If this\n   value is not present or does not validate, the server MUST abort the\n   handshake.  Servers SHOULD NOT attempt to validate multiple binders;\n   rather, they SHOULD select a single PSK and validate solely the\n   binder that corresponds to that PSK.  See Section 8.2 and\n   Appendix E.6 for the security rationale for this requirement.  In\n   order to accept PSK key establishment, the server sends a\n   \"pre_shared_key\" extension indicating the selected identity.\n\n   Clients MUST verify that the server's selected_identity is within the\n   range supplied by the client, that the server selected a cipher suite\n   indicating a Hash associated with the PSK, and that a server\n   \"key_share\" extension is present if required by the ClientHello\n   \"psk_key_exchange_modes\" extension.  If these values are not\n   consistent, the client MUST abort the handshake with an\n   \"illegal_parameter\" alert.\n\n   If the server supplies an \"early_data\" extension, the client MUST\n   verify that the server's selected_identity is 0.  If any other value\n   is returned, the client MUST abort the handshake with an\n   \"illegal_parameter\" alert.\n\n   The \"pre_shared_key\" extension MUST be the last extension in the\n   ClientHello (this facilitates implementation as described below).\n   Servers MUST check that it is the last extension and otherwise fail\n   the handshake with an \"illegal_parameter\" alert.",
  "section": "4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"
}
