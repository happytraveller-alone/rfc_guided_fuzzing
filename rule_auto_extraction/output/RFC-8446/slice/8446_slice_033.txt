{
  "content": "When a PSK is used and early data is allowed for that PSK, the client\n   can send Application Data in its first flight of messages.  If the\n   client opts to do so, it MUST supply both the \"pre_shared_key\" and\n   \"early_data\" extensions.\n\n   The \"extension_data\" field of this extension contains an\n   \"EarlyDataIndication\" value.\n\n      struct {} Empty;\n\n      struct {\n          select (Handshake.msg_type) {\n              case new_session_ticket:   uint32 max_early_data_size;\n              case client_hello:         Empty;\n              case encrypted_extensions: Empty;\n          };\n      } EarlyDataIndication;\n\n   See Section 4.6.1 for details regarding the use of the\n   max_early_data_size field.\n\n   The parameters for the 0-RTT data (version, symmetric cipher suite,\n   Application-Layer Protocol Negotiation (ALPN) [RFC7301] protocol,\n   etc.) are those associated with the PSK in use.  For externally\n   provisioned PSKs, the associated values are those provisioned along\n   with the key.  For PSKs established via a NewSessionTicket message,\n   the associated values are those which were negotiated in the\n   connection which established the PSK.  The PSK used to encrypt the\n   early data MUST be the first PSK listed in the client's\n   \"pre_shared_key\" extension.\n\n   For PSKs provisioned via NewSessionTicket, a server MUST validate\n   that the ticket age for the selected PSK identity (computed by\n   subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age\n   modulo 2^32) is within a small tolerance of the time since the ticket\n   was issued (see Section 8).  If it is not, the server SHOULD proceed\n   with the handshake but reject 0-RTT, and SHOULD NOT take any other\n   action that assumes that this ClientHello is fresh.\n\n   0-RTT messages sent in the first flight have the same (encrypted)\n   content types as messages of the same type sent in other flights\n   (handshake and application_data) but are protected under different\n   keys.  After receiving the server's Finished message, if the server\n   has accepted early data, an EndOfEarlyData message will be sent to\n   indicate the key change.  This message will be encrypted with the\n   0-RTT traffic keys.\n\n   A server which receives an \"early_data\" extension MUST behave in one\n   of three ways:\n\n   -  Ignore the extension and return a regular 1-RTT response.  The\n      server then skips past early data by attempting to deprotect\n      received records using the handshake traffic key, discarding\n      records which fail deprotection (up to the configured\n      max_early_data_size).  Once a record is deprotected successfully,\n      it is treated as the start of the client's second flight and the\n      server proceeds as with an ordinary 1-RTT handshake.\n\n   -  Request that the client send another ClientHello by responding\n      with a HelloRetryRequest.  A client MUST NOT include the\n      \"early_data\" extension in its followup ClientHello.  The server\n      then ignores early data by skipping all records with an external\n      content type of \"application_data\" (indicating that they are\n      encrypted), up to the configured max_early_data_size.\n\n   -  Return its own \"early_data\" extension in EncryptedExtensions,\n      indicating that it intends to process the early data.  It is not\n      possible for the server to accept only a subset of the early data\n      messages.  Even though the server sends a message accepting early\n      data, the actual early data itself may already be in flight by the\n      time the server generates this message.\n\n   In order to accept early data, the server MUST have accepted a PSK\n   cipher suite and selected the first key offered in the client's\n   \"pre_shared_key\" extension.  In addition, it MUST verify that the\n   following values are the same as those associated with the\n   selected PSK:\n\n   -  The TLS version number\n\n   -  The selected cipher suite\n\n   -  The selected ALPN [RFC7301] protocol, if any\n\n   These requirements are a superset of those needed to perform a 1-RTT\n   handshake using the PSK in question.  For externally established\n   PSKs, the associated values are those provisioned along with the key.\n   For PSKs established via a NewSessionTicket message, the associated\n   values are those negotiated in the connection during which the ticket\n   was established.\n\n   Future extensions MUST define their interaction with 0-RTT.\n\n   If any of these checks fail, the server MUST NOT respond with the\n   extension and must discard all the first-flight data using one of the\n   first two mechanisms listed above (thus falling back to 1-RTT or\n   2-RTT).  If the client attempts a 0-RTT handshake but the server\n   rejects it, the server will generally not have the 0-RTT record\n   protection keys and must instead use trial decryption (either with\n   the 1-RTT handshake keys or by looking for a cleartext ClientHello in\n   the case of a HelloRetryRequest) to find the first non-0-RTT message.\n\n   If the server chooses to accept the \"early_data\" extension, then it\n   MUST comply with the same error-handling requirements specified for\n   all records when processing early data records.  Specifically, if the\n   server fails to decrypt a 0-RTT record following an accepted\n   \"early_data\" extension, it MUST terminate the connection with a\n   \"bad_record_mac\" alert as per Section 5.2.\n\n   If the server rejects the \"early_data\" extension, the client\n   application MAY opt to retransmit the Application Data previously\n   sent in early data once the handshake has been completed.  Note that\n   automatic retransmission of early data could result in incorrect\n   assumptions regarding the status of the connection.  For instance,\n   when the negotiated connection selects a different ALPN protocol from\n   what was used for the early data, an application might need to\n   construct different messages.  Similarly, if early data assumes\n   anything about the connection state, it might be sent in error after\n   the handshake completes.\n\n   A TLS implementation SHOULD NOT automatically resend early data;\n   applications are in a better position to decide when retransmission\n   is appropriate.  A TLS implementation MUST NOT automatically resend\n   early data unless the negotiated connection selects the same ALPN\n   protocol.",
  "section": "4.2.10.. Handshake Protocol_Extensions_Early Data Indication"
}
