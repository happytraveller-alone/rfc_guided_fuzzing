{
  "content": "This message is used to provide explicit proof that an endpoint\n   possesses the private key corresponding to its certificate.  The\n   CertificateVerify message also provides integrity for the handshake\n   up to this point.  Servers MUST send this message when authenticating\n   via a certificate.  Clients MUST send this message whenever\n   authenticating via a certificate (i.e., when the Certificate message\n   is non-empty).  When sent, this message MUST appear immediately after\n   the Certificate message and immediately prior to the Finished\n   message.\n\n   Structure of this message:\n\n      struct {\n          SignatureScheme algorithm;\n          opaque signature<0..2^16-1>;\n      } CertificateVerify;\n\n   The algorithm field specifies the signature algorithm used (see\n   Section 4.2.3 for the definition of this type).  The signature is a\n   digital signature using that algorithm.  The content that is covered\n   under the signature is the hash output as described in Section 4.4.1,\n   namely:\n\n      Transcript-Hash(Handshake Context, Certificate)\n\n   The digital signature is then computed over the concatenation of:\n\n   -  A string that consists of octet 32 (0x20) repeated 64 times\n\n   -  The context string\n\n   -  A single 0 byte which serves as the separator\n\n   -  The content to be signed\n\n   This structure is intended to prevent an attack on previous versions\n   of TLS in which the ServerKeyExchange format meant that attackers\n   could obtain a signature of a message with a chosen 32-byte prefix\n   (ClientHello.random).  The initial 64-byte pad clears that prefix\n   along with the server-controlled ServerHello.random.\n\n   The context string for a server signature is\n   \"TLS 1.3, server CertificateVerify\".  The context string for a\n   client signature is \"TLS 1.3, client CertificateVerify\".  It is\n   used to provide separation between signatures made in different\n   contexts, helping against potential cross-protocol attacks.\n\n   For example, if the transcript hash was 32 bytes of 01 (this length\n   would make sense for SHA-256), the content covered by the digital\n   signature for a server CertificateVerify would be:\n\n      2020202020202020202020202020202020202020202020202020202020202020\n      2020202020202020202020202020202020202020202020202020202020202020\n      544c5320312e332c207365727665722043657274696669636174655665726966\n      79\n      00\n      0101010101010101010101010101010101010101010101010101010101010101\n\n   On the sender side, the process for computing the signature field of\n   the CertificateVerify message takes as input:\n\n   -  The content covered by the digital signature\n\n   -  The private signing key corresponding to the certificate sent in\n      the previous message\n\n   If the CertificateVerify message is sent by a server, the signature\n   algorithm MUST be one offered in the client's \"signature_algorithms\"\n   extension unless no valid certificate chain can be produced without\n   unsupported algorithms (see Section 4.2.3).\n\n   If sent by a client, the signature algorithm used in the signature\n   MUST be one of those present in the supported_signature_algorithms\n   field of the \"signature_algorithms\" extension in the\n   CertificateRequest message.\n\n   In addition, the signature algorithm MUST be compatible with the key\n   in the sender's end-entity certificate.  RSA signatures MUST use an\n   RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5\n   algorithms appear in \"signature_algorithms\".  The SHA-1 algorithm\n   MUST NOT be used in any signatures of CertificateVerify messages.\n\n   All SHA-1 signature algorithms in this specification are defined\n   solely for use in legacy certificates and are not valid for\n   CertificateVerify signatures.\n\n   The receiver of a CertificateVerify message MUST verify the signature\n   field.  The verification process takes as input:\n\n   -  The content covered by the digital signature\n\n   -  The public key contained in the end-entity certificate found in\n      the associated Certificate message\n\n   -  The digital signature received in the signature field of the\n      CertificateVerify message\n\n   If the verification fails, the receiver MUST terminate the handshake\n   with a \"decrypt_error\" alert.",
  "section": "4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"
}
