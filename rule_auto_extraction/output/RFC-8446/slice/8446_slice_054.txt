{
  "content": "The KeyUpdate handshake message is used to indicate that the sender\n   is updating its sending cryptographic keys.  This message can be sent\n   by either peer after it has sent a Finished message.  Implementations\n   that receive a KeyUpdate message prior to receiving a Finished\n   message MUST terminate the connection with an \"unexpected_message\"\n   alert.  After sending a KeyUpdate message, the sender SHALL send all\n   its traffic using the next generation of keys, computed as described\n   in Section 7.2.  Upon receiving a KeyUpdate, the receiver MUST update\n   its receiving keys.\n\n      enum {\n          update_not_requested(0), update_requested(1), (255)\n      } KeyUpdateRequest;\n\n      struct {\n          KeyUpdateRequest request_update;\n      } KeyUpdate;\n\n   request_update:  Indicates whether the recipient of the KeyUpdate\n      should respond with its own KeyUpdate.  If an implementation\n      receives any other value, it MUST terminate the connection with an\n      \"illegal_parameter\" alert.\n\n   If the request_update field is set to \"update_requested\", then the\n   receiver MUST send a KeyUpdate of its own with request_update set to\n   \"update_not_requested\" prior to sending its next Application Data\n   record.  This mechanism allows either side to force an update to the\n   entire connection, but causes an implementation which receives\n\n   multiple KeyUpdates while it is silent to respond with a single\n   update.  Note that implementations may receive an arbitrary number of\n   messages between sending a KeyUpdate with request_update set to\n   \"update_requested\" and receiving the peer's KeyUpdate, because those\n   messages may already be in flight.  However, because send and receive\n   keys are derived from independent traffic secrets, retaining the\n   receive traffic secret does not threaten the forward secrecy of data\n   sent before the sender changed keys.\n\n   If implementations independently send their own KeyUpdates with\n   request_update set to \"update_requested\" and they cross in flight,\n   then each side will also send a response, with the result that each\n   side increments by two generations.\n\n   Both sender and receiver MUST encrypt their KeyUpdate messages with\n   the old keys.  Additionally, both sides MUST enforce that a KeyUpdate\n   with the old key is received before accepting any messages encrypted\n   with the new key.  Failure to do so may allow message truncation\n   attacks.",
  "section": "4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"
}
