{
  "content": "A number of TLS messages contain tag-length-value encoded extensions\n   structures.\n\n    struct {\n        ExtensionType extension_type;\n        opaque extension_data<0..2^16-1>;\n    } Extension;\n\n    enum {\n        server_name(0),                             /* RFC 6066 */\n        max_fragment_length(1),                     /* RFC 6066 */\n        status_request(5),                          /* RFC 6066 */\n        supported_groups(10),                       /* RFC 8422, 7919 */\n        signature_algorithms(13),                   /* RFC 8446 */\n        use_srtp(14),                               /* RFC 5764 */\n        heartbeat(15),                              /* RFC 6520 */\n        application_layer_protocol_negotiation(16), /* RFC 7301 */\n        signed_certificate_timestamp(18),           /* RFC 6962 */\n        client_certificate_type(19),                /* RFC 7250 */\n        server_certificate_type(20),                /* RFC 7250 */\n        padding(21),                                /* RFC 7685 */\n        pre_shared_key(41),                         /* RFC 8446 */\n        early_data(42),                             /* RFC 8446 */\n        supported_versions(43),                     /* RFC 8446 */\n        cookie(44),                                 /* RFC 8446 */\n        psk_key_exchange_modes(45),                 /* RFC 8446 */\n        certificate_authorities(47),                /* RFC 8446 */\n        oid_filters(48),                            /* RFC 8446 */\n        post_handshake_auth(49),                    /* RFC 8446 */\n        signature_algorithms_cert(50),              /* RFC 8446 */\n        key_share(51),                              /* RFC 8446 */\n        (65535)\n    } ExtensionType;\n\n   Here:\n\n   -  \"extension_type\" identifies the particular extension type.\n\n   -  \"extension_data\" contains information specific to the particular\n      extension type.\n\n   The list of extension types is maintained by IANA as described in\n   Section 11.\n\n   Extensions are generally structured in a request/response fashion,\n   though some extensions are just indications with no corresponding\n   response.  The client sends its extension requests in the ClientHello\n   message, and the server sends its extension responses in the\n   ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate\n   messages.  The server sends extension requests in the\n   CertificateRequest message which a client MAY respond to with a\n   Certificate message.  The server MAY also send unsolicited extensions\n   in the NewSessionTicket, though the client does not respond directly\n   to these.\n\n   Implementations MUST NOT send extension responses if the remote\n   endpoint did not send the corresponding extension requests, with the\n   exception of the \"cookie\" extension in the HelloRetryRequest.  Upon\n   receiving such an extension, an endpoint MUST abort the handshake\n   with an \"unsupported_extension\" alert.\n\n   The table below indicates the messages where a given extension may\n   appear, using the following notation: CH (ClientHello),\n   SH (ServerHello), EE (EncryptedExtensions), CT (Certificate),\n   CR (CertificateRequest), NST (NewSessionTicket), and\n   HRR (HelloRetryRequest).  If an implementation receives an extension\n   which it recognizes and which is not specified for the message in\n   which it appears, it MUST abort the handshake with an\n   \"illegal_parameter\" alert.\n\n   +--------------------------------------------------+-------------+\n   | Extension                                        |     TLS 1.3 |\n   +--------------------------------------------------+-------------+\n   | server_name [RFC6066]                            |      CH, EE |\n   |                                                  |             |\n   | max_fragment_length [RFC6066]                    |      CH, EE |\n   |                                                  |             |\n   | status_request [RFC6066]                         |  CH, CR, CT |\n   |                                                  |             |\n   | supported_groups [RFC7919]                       |      CH, EE |\n   |                                                  |             |\n   | signature_algorithms (RFC 8446)                  |      CH, CR |\n   |                                                  |             |\n   | use_srtp [RFC5764]                               |      CH, EE |\n   |                                                  |             |\n   | heartbeat [RFC6520]                              |      CH, EE |\n   |                                                  |             |\n   | application_layer_protocol_negotiation [RFC7301] |      CH, EE |\n   |                                                  |             |\n   | signed_certificate_timestamp [RFC6962]           |  CH, CR, CT |\n   |                                                  |             |\n   | client_certificate_type [RFC7250]                |      CH, EE |\n   |                                                  |             |\n   | server_certificate_type [RFC7250]                |      CH, EE |\n   |                                                  |             |\n   | padding [RFC7685]                                |          CH |\n   |                                                  |             |\n   | key_share (RFC 8446)                             | CH, SH, HRR |\n   |                                                  |             |\n   | pre_shared_key (RFC 8446)                        |      CH, SH |\n   |                                                  |             |\n   | psk_key_exchange_modes (RFC 8446)                |          CH |\n   |                                                  |             |\n   | early_data (RFC 8446)                            | CH, EE, NST |\n   |                                                  |             |\n   | cookie (RFC 8446)                                |     CH, HRR |\n   |                                                  |             |\n   | supported_versions (RFC 8446)                    | CH, SH, HRR |\n   |                                                  |             |\n   | certificate_authorities (RFC 8446)               |      CH, CR |\n   |                                                  |             |\n   | oid_filters (RFC 8446)                           |          CR |\n   |                                                  |             |\n   | post_handshake_auth (RFC 8446)                   |          CH |\n   |                                                  |             |\n   | signature_algorithms_cert (RFC 8446)             |      CH, CR |\n   +--------------------------------------------------+-------------+\n\n   When multiple extensions of different types are present, the\n   extensions MAY appear in any order, with the exception of\n   \"pre_shared_key\" (Section 4.2.11) which MUST be the last extension in\n   the ClientHello (but can appear anywhere in the ServerHello\n   extensions block).  There MUST NOT be more than one extension of the\n   same type in a given extension block.\n\n   In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each\n   handshake even when in resumption-PSK mode.  However, 0-RTT\n   parameters are those negotiated in the previous handshake; mismatches\n   may require rejecting 0-RTT (see Section 4.2.10).\n\n   There are subtle (and not so subtle) interactions that may occur in\n   this protocol between new features and existing features which may\n   result in a significant reduction in overall security.  The following\n   considerations should be taken into account when designing new\n   extensions:\n\n   -  Some cases where a server does not agree to an extension are error\n      conditions (e.g., the handshake cannot continue), and some are\n      simply refusals to support particular features.  In general, error\n      alerts should be used for the former and a field in the server\n      extension response for the latter.\n\n   -  Extensions should, as far as possible, be designed to prevent any\n      attack that forces use (or non-use) of a particular feature by\n      manipulation of handshake messages.  This principle should be\n      followed regardless of whether the feature is believed to cause a\n      security problem.  Often the fact that the extension fields are\n      included in the inputs to the Finished message hashes will be\n      sufficient, but extreme care is needed when the extension changes\n      the meaning of messages sent in the handshake phase.  Designers\n      and implementors should be aware of the fact that until the\n      handshake has been authenticated, active attackers can modify\n      messages and insert, remove, or replace extensions.",
  "section": "4.2.. Handshake Protocol_Extensions"
}
