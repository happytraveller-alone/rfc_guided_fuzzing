index,Section,Title,Content
1,4.. Handshake Protocol,Handshake Protocol Overview,"The handshake protocol is used to negotiate the security parameters of a connection. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext or TLSCiphertext structures which are processed and transmitted as specified by the current active connection state."
2,4.. Handshake Protocol,Handshake Message Types Enumeration,"enum {
    client_hello(1),
    server_hello(2),
    new_session_ticket(4),
    end_of_early_data(5),
    encrypted_extensions(8),
    certificate(11),
    certificate_request(13),
    certificate_verify(15),
    finished(20),
    key_update(24),
    message_hash(254),
    (255)
} HandshakeType;"
3,4.. Handshake Protocol,Handshake Message Structure,"struct {
    HandshakeType msg_type;    /* handshake type */
    uint24 length;             /* remaining bytes in message */
    select (Handshake.msg_type) {
        case client_hello:          ClientHello;
        case server_hello:          ServerHello;
        case end_of_early_data:     EndOfEarlyData;
        case encrypted_extensions:  EncryptedExtensions;
        case certificate_request:   CertificateRequest;
        case certificate:           Certificate;
        case certificate_verify:    CertificateVerify;
        case finished:              Finished;
        case new_session_ticket:    NewSessionTicket;
        case key_update:            KeyUpdate;
    };
} Handshake;"
4,4.. Handshake Protocol,Message Order and Error Handling,"Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2. A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert."
5,4.. Handshake Protocol,IANA Message Type Assignments,New handshake message types are assigned by IANA as described in Section 11.
6,4.1.. Handshake Protocol_Key Exchange Messages,Key Exchange Messages Overview,"The key exchange messages are used to determine the security capabilities of the client and the server and to establish shared secrets, including the traffic keys used to protect the rest of the handshake and the data."
7,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Cryptographic Negotiation Overview,"In TLS, the cryptographic negotiation proceeds by the client offering four sets of options in its ClientHello: a list of cipher suites, a 'supported_groups' extension, a 'signature_algorithms' extension, and a 'pre_shared_key' extension."
8,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Cipher Suites,The client offers a list of cipher suites which indicates the AEAD algorithm/HKDF hash pairs that it supports.
9,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Supported Groups and Key Share Extensions,"The client includes a 'supported_groups' extension which indicates the (EC)DHE groups it supports, and a 'key_share' extension which contains (EC)DHE shares for some or all of these groups."
10,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Signature Algorithms,"The client can also offer a 'signature_algorithms' extension indicating the signature algorithms it can accept. Additionally, a 'signature_algorithms_cert' extension may be included for certificate-specific signature algorithms."
11,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Pre-Shared Key Extensions,"The client may include a 'pre_shared_key' extension containing a list of symmetric key identities known to the client, along with a 'psk_key_exchange_modes' extension indicating the key exchange modes that may be used with PSKs."
12,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Server Parameter Selection,"If the server does not select a PSK, it independently selects a cipher suite, an (EC)DHE group and key share, and a signature algorithm/certificate pair. If there is no overlap in 'supported_groups', the server MUST abort the handshake with a 'handshake_failure' or 'insufficient_security' alert."
13,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,PSK Selection,"If the server selects a PSK, it MUST also select a key establishment mode from the client's 'psk_key_exchange_modes' extension. If the PSK can be used without (EC)DHE, non-overlap in 'supported_groups' is not fatal."
14,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,HelloRetryRequest Requirement,"If the server selects an (EC)DHE group and the client did not offer a compatible 'key_share', the server MUST respond with a HelloRetryRequest message."
15,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,ServerHello Parameter Indication,"If the server successfully selects parameters without requiring a HelloRetryRequest, it indicates the selected parameters in the ServerHello. If PSK is used, a 'pre_shared_key' extension is sent. When (EC)DHE is in use, a 'key_share' extension is also provided."
16,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Certificate Authentication,"When authenticating via a certificate, the server sends the Certificate and CertificateVerify messages. In TLS 1.3, either a PSK or a certificate is used, but not both."
17,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Handshake Failure Conditions,"If the server is unable to negotiate a supported set of parameters, it MUST abort the handshake with a 'handshake_failure' or 'insufficient_security' fatal alert."
18,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,ClientHello Message Overview,"When a client first connects to a server, it is REQUIRED to send the ClientHello as its first TLS message. The client will also send a ClientHello when the server has responded to its ClientHello with a HelloRetryRequest. In that case, the client MUST send the same ClientHello without modification, except as follows: - If a ""key_share"" extension was supplied in the HelloRetryRequest, replacing the list of shares with a list containing a single KeyShareEntry from the indicated group. - Removing the ""early_data"" extension if one was present. Early data is not permitted after a HelloRetryRequest. - Including a ""cookie"" extension if one was provided in the HelloRetryRequest. - Updating the ""pre_shared_key"" extension if present by recomputing the ""obfuscated_ticket_age"" and binder values and (optionally) removing any PSKs which are incompatible with the server's indicated cipher suite. - Optionally adding, removing, or changing the length of the ""padding"" extension [RFC7685]. - Other modifications that may be allowed by an extension defined in the future and present in the HelloRetryRequest."
19,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Connection Termination Rules,"Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an ""unexpected_message"" alert. If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version. In particular, it MUST NOT negotiate TLS 1.3."
20,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,ClientHello Message Structure,Structure of this message: uint16 ProtocolVersion; opaque Random[32]; uint8 CipherSuite[2]; struct { ProtocolVersion legacy_version = 0x0303; /* TLS v1.2 */ Random random; opaque legacy_session_id<0..32>; CipherSuite cipher_suites<2..2^16-2>; opaque legacy_compression_methods<1..2^8-1>; Extension extensions<8..2^16-1>; } ClientHello;
21,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Field Descriptions,"1. legacy_version: Set to 0x0303 (TLS v1.2) for compatibility with middleboxes. The actual version is indicated using the ""supported_versions"" extension. 2. random: 32 bytes generated by a secure random number generator. 3. legacy_session_id: A cached session ID from a pre-TLS 1.3 server, or a new unpredictable value if none exists. 4. cipher_suites: A list of symmetric cipher options supported by the client. 5. legacy_compression_methods: Must contain exactly one byte, set to zero. 6. extensions: Clients request extended functionality from servers by sending data in the extensions field."
22,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Extension Handling,"Clients request extended functionality from servers by sending data in the extensions field. In TLS 1.3, the use of certain extensions is mandatory, and servers MUST ignore unrecognized extensions. TLS 1.3 ClientHello messages always contain extensions, minimally the ""supported_versions"" extension."
23,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Message Reception and Processing,"After sending the ClientHello message, the client waits for a ServerHello or HelloRetryRequest message. If early data is in use, the client may transmit early Application Data while waiting for the next handshake message."
24,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,ServerHello Message Overview,The server will send this message in response to a ClientHello message to proceed with the handshake if it is able to negotiate an acceptable set of handshake parameters based on the ClientHello.
25,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,ServerHello Message Structure,"struct {
    ProtocolVersion legacy_version = 0x0303; /* TLS v1.2 */
    Random random;
    opaque legacy_session_id_echo<0..32>;
    CipherSuite cipher_suite;
    uint8 legacy_compression_method = 0;
    Extension extensions<6..2^16-1>;
} ServerHello;"
26,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Field Descriptions,"1. **legacy_version**: Set to 0x0303 (TLS v1.2) for compatibility with middleboxes. The actual version is indicated using the ""supported_versions"" extension.

2. **random**: 32 bytes generated by a secure random number generator. The last 8 bytes must be overwritten if negotiating TLS 1.2 or TLS 1.1, while the rest must be random.

3. **legacy_session_id_echo**: Echoes the client's legacy_session_id. If this does not match the client's sent value, the handshake must abort with an ""illegal_parameter"" alert.

4. **cipher_suite**: The selected cipher suite from the ClientHello. If not offered, the handshake must abort with an ""illegal_parameter"" alert.

5. **legacy_compression_method**: Must be set to 0.

6. **extensions**: Must include only those necessary for establishing the cryptographic context. All TLS 1.3 ServerHello messages must contain the ""supported_versions"" extension."
27,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,HelloRetryRequest Compatibility,"The HelloRetryRequest message uses the same structure as the ServerHello, but with Random set to the SHA-256 of ""HelloRetryRequest"":

CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91
C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C."
28,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Downgrade Protection Mechanism,"TLS 1.3 has a downgrade protection mechanism embedded in the server's random value. If negotiating TLS 1.2, the last 8 bytes of the Random value must be set to:

44 4F 57 4E 47 52 44 01

If negotiating TLS 1.1 or below, they should be set to:

44 4F 57 4E 47 52 44 00.

Clients must check these values and abort the handshake with an ""illegal_parameter"" alert if they match."
29,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Renegotiation Handling,"A legacy TLS client performing renegotiation with TLS 1.2 or prior that receives a TLS 1.3 ServerHello during renegotiation must abort the handshake with a ""protocol_version"" alert. Note that renegotiation is not possible when TLS 1.3 has been negotiated."
30,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,HelloRetryRequest Overview,"The server will send this message in response to a ClientHello message if it is able to find an acceptable set of parameters but the ClientHello does not contain sufficient information to proceed with the handshake. The HelloRetryRequest has the same format as a ServerHello message, and the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields have the same meaning. However, for convenience, this document discusses 'HelloRetryRequest' as if it were a distinct message."
31,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Extensions Requirements,"The server's extensions MUST contain 'supported_versions'. Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair. A HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the 'cookie' extension."
32,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Client Processing of HelloRetryRequest,"Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using 'supported_versions'. Clients MUST abort the handshake with an 'illegal_parameter' alert if the HelloRetryRequest would not result in any change in the ClientHello. If a client receives a second HelloRetryRequest in the same connection, it MUST abort the handshake with an 'unexpected_message' alert."
33,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Extension Processing and Updated ClientHello,"Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello. The HelloRetryRequest extensions defined in this specification are: - supported_versions (see Section 4.2.1) - cookie (see Section 4.2.2) - key_share (see Section 4.2.8). A client which receives a cipher suite that was not offered MUST abort the handshake."
34,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Cipher Suite Negotiation,"Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello. Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an 'illegal_parameter' alert."
35,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Pre-shared Key Considerations,"In its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite. This allows the client to avoid having to compute partial hash transcripts for multiple hashes in the second ClientHello."
36,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Version Retention in ServerHello,"The value of selected_version in the HelloRetryRequest 'supported_versions' extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an 'illegal_parameter' alert if the value changes."
37,4.2.. Handshake Protocol_Extensions,Extension Structure Overview,"A number of TLS messages contain tag-length-value encoded extensions structures.

struct {
    ExtensionType extension_type;
    opaque extension_data<0..2^16-1>;
} Extension;

Here:
- ""extension_type"" identifies the particular extension type.
- ""extension_data"" contains information specific to the particular extension type."
38,4.2.. Handshake Protocol_Extensions,ExtensionType Enumeration,"enum {
    server_name(0),                             /* RFC 6066 */
    max_fragment_length(1),                     /* RFC 6066 */
    status_request(5),                          /* RFC 6066 */
    supported_groups(10),                       /* RFC 8422, 7919 */
    signature_algorithms(13),                   /* RFC 8446 */
    use_srtp(14),                               /* RFC 5764 */
    heartbeat(15),                              /* RFC 6520 */
    application_layer_protocol_negotiation(16), /* RFC 7301 */
    signed_certificate_timestamp(18),           /* RFC 6962 */
    client_certificate_type(19),                /* RFC 7250 */
    server_certificate_type(20),                /* RFC 7250 */
    padding(21),                                /* RFC 7685 */
    pre_shared_key(41),                         /* RFC 8446 */
    early_data(42),                             /* RFC 8446 */
    supported_versions(43),                     /* RFC 8446 */
    cookie(44),                                 /* RFC 8446 */
    psk_key_exchange_modes(45),                 /* RFC 8446 */
    certificate_authorities(47),                /* RFC 8446 */
    oid_filters(48),                            /* RFC 8446 */
    post_handshake_auth(49),                    /* RFC 8446 */
    signature_algorithms_cert(50),              /* RFC 8446 */
    key_share(51),                              /* RFC 8446 */
    (65535)
} ExtensionType;"
39,4.2.. Handshake Protocol_Extensions,Extension Negotiation Process,"Extensions are generally structured in a request/response fashion. The client sends its extension requests in the ClientHello message, and the server sends its extension responses in the ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate messages. The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message."
40,4.2.. Handshake Protocol_Extensions,Extension Handling Rules,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest. Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert."
41,4.2.. Handshake Protocol_Extensions,Extension Message Compatibility,"The table below indicates the messages where a given extension may appear, using the following notation: CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), and HRR (HelloRetryRequest). If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an ""illegal_parameter"" alert."
42,4.2.. Handshake Protocol_Extensions,Extension Order and Uniqueness,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" which MUST be the last extension in the ClientHello. There MUST NOT be more than one extension of the same type in a given extension block."
43,4.2.. Handshake Protocol_Extensions,Security Considerations for Extensions,There are subtle interactions that may occur in this protocol between new features and existing features which may result in a significant reduction in overall security. Extensions should be designed to prevent any attack that forces use (or non-use) of a particular feature by manipulation of handshake messages.
44,4.2.1.. Handshake Protocol_Extensions_Supported Versions,SupportedVersions Structure,"struct {
    select (Handshake.msg_type) {
        case client_hello:
            ProtocolVersion versions<2..254>;

        case server_hello: /* and HelloRetryRequest */
            ProtocolVersion selected_version;
    };
} SupportedVersions;"
45,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Purpose of the Supported Versions Extension,"The ""supported_versions"" extension is used by the client to indicate which versions of TLS it supports and by the server to indicate which version it is using. The extension contains a list of supported versions in preference order, with the most preferred version first."
46,4.2.1.. Handshake Protocol_Extensions_Supported Versions,ClientHello Requirements,"Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which they are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, they MUST be present as well)."
47,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Server Behavior Without the Extension,"If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later."
48,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Server Behavior With the Extension,"If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension."
49,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Negotiation of Versions Prior to TLS 1.2,This mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.
50,4.2.1.. Handshake Protocol_Extensions_Supported Versions,ServerHello Version Negotiation,"A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2)."
51,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Client Checks for the Supported Versions Extension,"Clients MUST check for this extension prior to processing the rest of the ServerHello. If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version. If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert."
52,4.2.2.. Handshake Protocol_Extensions_Cookie,Cookie Structure,"struct {
    opaque cookie<1..2^16-1>;
} Cookie;"
53,4.2.2.. Handshake Protocol_Extensions_Cookie,Purpose of Cookies,"Cookies serve two primary purposes:

1. Allowing the server to force the client to demonstrate reachability at their apparent network address, thus providing a measure of DoS protection. This is primarily useful for non-connection-oriented transports (see [RFC6347] for an example).

2. Allowing the server to offload state to the client, enabling it to send a HelloRetryRequest without storing any state. The server can achieve this by storing the hash of the ClientHello in the HelloRetryRequest cookie, protected with a suitable integrity protection algorithm."
54,4.2.2.. Handshake Protocol_Extensions_Cookie,HelloRetryRequest Cookie Extension,"When sending a HelloRetryRequest, the server MAY provide a ""cookie"" extension to the client (this is an exception to the usual rule that only extensions appearing in the ClientHello may be sent). When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a ""cookie"" extension in the new ClientHello. Clients MUST NOT use cookies in their initial ClientHello in subsequent connections."
55,4.2.2.. Handshake Protocol_Extensions_Cookie,Stateless Server Behavior,"When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5). Since the server is not storing any state, this will appear as if it were the first message received. Servers operating statelessly MUST ignore these records."
56,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Algorithms Overview,"TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures. The ""signature_algorithms_cert"" extension applies to signatures in certificates, while the ""signature_algorithms"" extension applies to signatures in CertificateVerify messages. If no ""signature_algorithms_cert"" extension is present, then the ""signature_algorithms"" extension also applies to signatures appearing in certificates."
57,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Client Requirements for Signature Algorithms,"Clients that desire server authentication via a certificate MUST send the ""signature_algorithms"" extension. If the server is authenticating via a certificate and the client has not sent this extension, the server MUST abort the handshake with a ""missing_extension"" alert."
58,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Purpose of the Signature Algorithms Extensions,"The ""signature_algorithms_cert"" extension was added to allow implementations that support different sets of algorithms for certificates and in TLS to clearly signal their capabilities. TLS 1.2 implementations SHOULD also process this extension. Implementations with the same policy for both cases MAY omit this extension."
59,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Scheme Enumeration,"The ""extension_data"" field of these extensions contains a SignatureSchemeList value:

    enum {
        rsa_pkcs1_sha256(0x0401),
        rsa_pkcs1_sha384(0x0501),
        rsa_pkcs1_sha512(0x0601),
        ecdsa_secp256r1_sha256(0x0403),
        ecdsa_secp384r1_sha384(0x0503),
        ecdsa_secp521r1_sha512(0x0603),
        rsa_pss_rsae_sha256(0x0804),
        rsa_pss_rsae_sha384(0x0805),
        rsa_pss_rsae_sha512(0x0806),
        ed25519(0x0807),
        ed448(0x0808),
        rsa_pss_pss_sha256(0x0809),
        rsa_pss_pss_sha384(0x080a),
        rsa_pss_pss_sha512(0x080b),
        rsa_pkcs1_sha1(0x0201),
        ecdsa_sha1(0x0203),
        private_use(0xFE00..0xFFFF),
        (0xFFFF)
    } SignatureScheme;"
60,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Scheme List Structure,"struct {
    SignatureScheme supported_signature_algorithms<2..2^16-2>;
} SignatureSchemeList;"
61,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Algorithm Definitions,"Each SignatureScheme value lists a single signature algorithm that the client is willing to verify, indicated in descending order of preference. Notably, a signature algorithm takes an arbitrary-length message as input rather than a digest. Algorithms traditionally acting on a digest should hash the input with a specified hash algorithm before proceeding."
62,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,RSASSA-PKCS1-v1_5 Algorithms,"Indicates a signature algorithm using RSASSA-PKCS1-v1_5 with the corresponding hash algorithm as defined in [SHS]. These values refer solely to signatures in certificates and are not defined for signed TLS handshake messages, although they may appear in the extensions for backward compatibility with TLS 1.2."
63,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,ECDSA Algorithms,"Indicates a signature algorithm using ECDSA, the corresponding curve as defined in ANSI X9.62 and FIPS 186-4, and the corresponding hash algorithm as defined in [SHS]. The signature is represented as a DER-encoded ECDSA-Sig-Value structure."
64,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,RSASSA-PSS Algorithms,Indicates a signature algorithm using RSASSA-PSS with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST equal the output length of the digest algorithm.
65,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,EdDSA Algorithms,"Indicates a signature algorithm using EdDSA as defined in [RFC8032] or its successors. These correspond to the ""PureEdDSA"" algorithms, not the ""prehash"" variants."
66,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Legacy Algorithms,"Indicates algorithms being deprecated due to known weaknesses, specifically SHA-1 used with RSA or ECDSA. These values refer solely to signatures in certificates and should not be negotiated unless for backward compatibility. TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it."
67,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Validation for Trust Anchors,"Signatures on self-signed certificates or trust anchors are not validated since they begin a certification path. A certificate starting a certification path may use a signature algorithm not advertised in the ""signature_algorithms"" extension."
68,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,TLS 1.2 Compatibility,"TLS 1.3 implementations willing to negotiate TLS 1.2 MUST comply with the requirements of [RFC5246]. In TLS 1.2, ClientHellos may omit the signature algorithms extension, which contained hash/signature pairs encoded in two octets. Legacy pairs are deprecated and MUST NOT be offered or negotiated."
69,4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Certificate Authorities Extension Overview,"The ""certificate_authorities"" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection."
70,4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Certificate Authorities Extension Structure,"The body of the ""certificate_authorities"" extension consists of a CertificateAuthoritiesExtension structure:

plaintext
opaque DistinguishedName<1..2^16-1>;

struct {
    DistinguishedName authorities<3..2^16-1>;
} CertificateAuthoritiesExtension;
"
71,4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Authorities Field Description,"The `authorities` field contains a list of the distinguished names [X501] of acceptable certificate authorities, represented in DER-encoded [X690] format. These distinguished names specify a desired distinguished name for a trust anchor or subordinate CA; thus, this message can be used to describe known trust anchors as well as a desired authorization space."
72,4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Usage of the Certificate Authorities Extension,"The client MAY send the ""certificate_authorities"" extension in the ClientHello message. The server MAY send it in the CertificateRequest message."
73,4.2.4.. Handshake Protocol_Extensions_Certificate Authorities,Comparison with Trusted CA Keys Extension,"The ""trusted_ca_keys"" extension [RFC6066], which serves a similar purpose but is more complicated, is not used in TLS 1.3 (although it may appear in ClientHello messages from clients which are offering prior versions of TLS)."
74,4.2.5.. Handshake Protocol_Extensions_OID Filters,OID Filters Extension Overview,"The ""oid_filters"" extension allows servers to provide a set of OID/value pairs which it would like the client's certificate to match. This extension, if provided by the server, MUST only be sent in the CertificateRequest message."
75,4.2.5.. Handshake Protocol_Extensions_OID Filters,OIDFilter Structure,"struct {
    opaque certificate_extension_oid<1..2^8-1>;
    opaque certificate_extension_values<0..2^16-1>;
} OIDFilter;"
76,4.2.5.. Handshake Protocol_Extensions_OID Filters,OIDFilterExtension Structure,"struct {
    OIDFilter filters<0..2^16-1>;
} OIDFilterExtension;"
77,4.2.5.. Handshake Protocol_Extensions_OID Filters,Filters List Description,"filters: A list of certificate extension OIDs [RFC5280] with their allowed value(s) and represented in DER-encoded [X690] format. Some certificate extension OIDs allow multiple values (e.g., Extended Key Usage). If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes."
78,4.2.5.. Handshake Protocol_Extensions_OID Filters,Client Certificate Requirements,"For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well). However, the client MUST ignore and skip any unrecognized certificate extension OIDs. If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an ""unsupported_certificate"" alert."
79,4.2.5.. Handshake Protocol_Extensions_OID Filters,OID Uniqueness and Matching Rules,"Any given OID MUST NOT appear more than once in the filters list. PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types. Depending on the type, matching certificate extension values are not necessarily bitwise-equal. This document defines matching rules for two standard certificate extensions defined in [RFC5280]:

- The Key Usage extension in a certificate matches the request when all key usage bits asserted in the request are also asserted in the Key Usage certificate extension.

- The Extended Key Usage extension in a certificate matches the request when all key purpose OIDs present in the request are also found in the Extended Key Usage certificate extension. The special anyExtendedKeyUsage OID MUST NOT be used in the request."
80,4.2.7.. Handshake Protocol_Extensions_Supported Groups,Supported Groups Extension Overview,"When sent by the client, the ""supported_groups"" extension indicates the named groups which the client supports for key exchange, ordered from most preferred to least preferred. In versions of TLS prior to TLS 1.3, this extension was named ""elliptic_curves"" and only contained elliptic curve groups. This extension was also used to negotiate ECDSA curves. Signature algorithms are now negotiated independently (see Section 4.2.3)."
81,4.2.7.. Handshake Protocol_Extensions_Supported Groups,Extension Data Structure,"The ""extension_data"" field of this extension contains a ""NamedGroupList"" value:

plaintext
enum {
    /* Elliptic Curve Groups (ECDHE) */
    secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
    x25519(0x001D), x448(0x001E),

    /* Finite Field Groups (DHE) */
    ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
    ffdhe6144(0x0103), ffdhe8192(0x0104),

    /* Reserved Code Points */
    ffdhe_private_use(0x01FC..0x01FF),
    ecdhe_private_use(0xFE00..0xFEFF),
    (0xFFFF)
} NamedGroup;

struct {
    NamedGroup named_group_list<2..2^16-1>;
} NamedGroupList;
"
82,4.2.7.. Handshake Protocol_Extensions_Supported Groups,Group Types and Definitions,"Elliptic Curve Groups (ECDHE): Indicates support for the corresponding named curve, defined in either FIPS 186-4 or RFC 7748. Values 0xFE00 through 0xFEFF are reserved for Private Use.

Finite Field Groups (DHE): Indicates support for the corresponding finite field group, defined in RFC 7919. Values 0x01FC through 0x01FF are reserved for Private Use."
83,4.2.7.. Handshake Protocol_Extensions_Supported Groups,Ordering of Named Groups,Items in named_group_list are ordered according to the sender's preferences (most preferred choice first).
84,4.2.7.. Handshake Protocol_Extensions_Supported Groups,Server Behavior with Supported Groups,"As of TLS 1.3, servers are permitted to send the ""supported_groups"" extension to the client. Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections. If the server has a group it prefers to the ones in the ""key_share"" extension but is still willing to accept the ClientHello, it SHOULD send ""supported_groups"" to update the client's view of its preferences; this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client."
85,4.2.8.. Handshake Protocol_Extensions_Key Share,Key Share Extension Overview,"The ""key_share"" extension contains the endpoint's cryptographic parameters. Clients MAY send an empty client_shares vector in order to request group selection from the server, at the cost of an additional round trip (see Section 4.1.4)."
86,4.2.8.. Handshake Protocol_Extensions_Key Share,KeyShareEntry Structure,"struct {
    NamedGroup group;
    opaque key_exchange<1..2^16-1>;
} KeyShareEntry;"
87,4.2.8.. Handshake Protocol_Extensions_Key Share,KeyShareEntry Field Descriptions,"1. group: The named group for the key being exchanged.

2. key_exchange: Key exchange information. The contents of this field are determined by the specified group and its corresponding definition. Finite Field Diffie-Hellman [DH76] parameters are described in Section 4.2.8.1; Elliptic Curve Diffie-Hellman parameters are described in Section 4.2.8.2."
88,4.2.8.. Handshake Protocol_Extensions_Key Share,KeyShareClientHello Structure,"In the ClientHello message, the ""extension_data"" field of this extension contains a ""KeyShareClientHello"" value:

struct {
    KeyShareEntry client_shares<0..2^16-1>;
} KeyShareClientHello;"
89,4.2.8.. Handshake Protocol_Extensions_Key Share,Client Shares Description,"client_shares: A list of offered KeyShareEntry values in descending order of client preference. This vector MAY be empty if the client is requesting a HelloRetryRequest. Each KeyShareEntry value MUST correspond to a group offered in the ""supported_groups"" extension and MUST appear in the same order."
90,4.2.8.. Handshake Protocol_Extensions_Key Share,KeyShare Entry Rules,"Clients can offer as many KeyShareEntry values as the number of supported groups it is offering, each representing a single set of key exchange parameters. Clients MUST NOT offer multiple KeyShareEntry values for the same group and MUST NOT offer any for groups not listed in the client's ""supported_groups"" extension. Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated."
91,4.2.8.. Handshake Protocol_Extensions_Key Share,KeyShareHelloRetryRequest Structure,"In a HelloRetryRequest message, the ""extension_data"" field of this extension contains a KeyShareHelloRetryRequest value:

struct {
    NamedGroup selected_group;
} KeyShareHelloRetryRequest;"
92,4.2.8.. Handshake Protocol_Extensions_Key Share,Selected Group Verification,"Upon receipt of this extension in a HelloRetryRequest, the client MUST verify that (1) the selected_group field corresponds to a group provided in the ""supported_groups"" extension in the original ClientHello and (2) the selected_group field does not correspond to a group provided in the ""key_share"" extension in the original ClientHello. If either check fails, the client MUST abort the handshake with an ""illegal_parameter"" alert."
93,4.2.8.. Handshake Protocol_Extensions_Key Share,KeyShareServerHello Structure,"In a ServerHello message, the ""extension_data"" field of this extension contains a KeyShareServerHello value:

struct {
    KeyShareEntry server_share;
} KeyShareServerHello;"
94,4.2.8.. Handshake Protocol_Extensions_Key Share,Server Share Requirements,"If using (EC)DHE key establishment, servers offer exactly one KeyShareEntry in the ServerHello. This value MUST be in the same group as the KeyShareEntry value offered by the client that the server has selected for the negotiated key exchange. Servers MUST NOT send a KeyShareEntry for any group not indicated in the client's ""supported_groups"" extension and MUST NOT send a KeyShareEntry when using the ""psk_ke"" PskKeyExchangeMode."
95,4.2.8.. Handshake Protocol_Extensions_Key Share,Verification of Selected NamedGroup,"If using (EC)DHE key establishment and a HelloRetryRequest containing a ""key_share"" extension was received by the client, the client MUST verify that the selected NamedGroup in the ServerHello is the same as that in the HelloRetryRequest. If this check fails, the client MUST abort the handshake with an ""illegal_parameter"" alert."
96,4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters,Diffie-Hellman Key Exchange Parameters,"Diffie-Hellman (DH) parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure. The opaque value contains the Diffie-Hellman public value (Y = g^X mod p) for the specified group (see [RFC7919] for group definitions) encoded as a big-endian integer and padded to the left with zeros to the size of p in bytes.

Note: For a given Diffie-Hellman group, the padding results in all public keys having the same length."
97,4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters,Public Key Validation,Peers MUST validate each other's public key Y by ensuring that 1 < Y < p-1. This check ensures that the remote peer is properly behaved and isn't forcing the local system into a small subgroup.
98,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,ECDHE Parameters Encoding,ECDHE parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure.
99,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Uncompressed Point Representation,"For secp256r1, secp384r1, and secp521r1, the contents are the serialized value of the following struct:

struct {
    uint8 legacy_form = 4;
    opaque X[coordinate_length];
    opaque Y[coordinate_length];
} UncompressedPointRepresentation;"
100,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Coordinate Representations,"X and Y are the binary representations of the x and y values in network byte order. Each number representation occupies as many octets as implied by the curve parameters:
- For P-256, each of X and Y uses 32 octets, padded on the left by zeros if necessary.
- For P-384, they take 48 octets each.
- For P-521, they take 66 octets each."
101,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Public Value Validation,"For the curves secp256r1, secp384r1, and secp521r1, peers MUST validate each other's public value Q by ensuring that the point is a valid point on the elliptic curve. The validation process consists of three steps:
1. Verify that Q is not the point at infinity (O).
2. Verify that both integers x and y are in the correct interval for Q = (x, y).
3. Ensure that (x, y) is a correct solution to the elliptic curve equation.
Implementors do not need to verify membership in the correct subgroup."
102,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Public Value for X25519 and X448,"For X25519 and X448, the contents of the public value are the byte string inputs and outputs of the corresponding functions defined in [RFC7748]: 32 bytes for X25519 and 56 bytes for X448."
103,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Point Format Negotiation Removal,Note: Versions of TLS prior to 1.3 permitted point format negotiation; TLS 1.3 removes this feature in favor of a single point format for each curve.
104,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,PSK Key Exchange Modes Extension Overview,"In order to use PSKs, clients MUST also send a ""psk_key_exchange_modes"" extension. The semantics of this extension are that the client only supports the use of PSKs with these modes, which restricts both the use of PSKs offered in this ClientHello and those which the server might supply via NewSessionTicket."
105,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Client Requirements for PSK Extensions,"A client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension. If clients offer ""pre_shared_key"" without a ""psk_key_exchange_modes"" extension, servers MUST abort the handshake. Servers MUST NOT select a key exchange mode that is not listed by the client. This extension also restricts the modes for use with PSK resumption. Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes; however, if a server does so, the impact will just be that the client's attempts at resumption fail."
106,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Server Restrictions on PSK Extensions,"The server MUST NOT send a ""psk_key_exchange_modes"" extension."
107,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,PskKeyExchangeMode Enumeration,"enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;"
108,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,PskKeyExchangeModes Structure,"struct {
    PskKeyExchangeMode ke_modes<1..255>;
} PskKeyExchangeModes;"
109,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Key Exchange Mode Descriptions,"1. psk_ke: PSK-only key establishment. In this mode, the server MUST NOT supply a ""key_share"" value.

2. psk_dhe_ke: PSK with (EC)DHE key establishment. In this mode, the client and server MUST supply ""key_share"" values as described in Section 4.2.8."
110,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Future Key Exchange Modes,"Any future values that are allocated must ensure that the transmitted protocol messages unambiguously identify which mode was selected by the server; at present, this is indicated by the presence of the ""key_share"" in the ServerHello."
111,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Early Data Indication Overview,"When a PSK is used and early data is allowed for that PSK, the client can send Application Data in its first flight of messages. If the client opts to do so, it MUST supply both the ""pre_shared_key"" and ""early_data"" extensions."
112,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Early Data Indication Structure,"The ""extension_data"" field of this extension contains an ""EarlyDataIndication"" value.

struct {} Empty;

struct {
    select (Handshake.msg_type) {
        case new_session_ticket:   uint32 max_early_data_size;
        case client_hello:         Empty;
        case encrypted_extensions: Empty;
    };
} EarlyDataIndication;"
113,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Parameters for 0-RTT Data,"The parameters for the 0-RTT data (version, symmetric cipher suite, Application-Layer Protocol Negotiation (ALPN) [RFC7301] protocol, etc.) are those associated with the PSK in use. For externally provisioned PSKs, the associated values are those provisioned along with the key. For PSKs established via a NewSessionTicket message, the associated values are those which were negotiated in the connection which established the PSK. The PSK used to encrypt the early data MUST be the first PSK listed in the client's ""pre_shared_key"" extension."
114,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Server Validation of PSK Ticket Age,"For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued. If it is not, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh."
115,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Handling Early Data Messages,"0-RTT messages sent in the first flight have the same (encrypted) content types as messages of the same type sent in other flights (handshake and application_data) but are protected under different keys. After receiving the server's Finished message, if the server has accepted early data, an EndOfEarlyData message will be sent to indicate the key change. This message will be encrypted with the 0-RTT traffic keys."
116,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Server Response to Early Data Extension,"A server which receives an ""early_data"" extension MUST behave in one of three ways:

- Ignore the extension and return a regular 1-RTT response. The server then skips past early data by attempting to deprotect received records using the handshake traffic key, discarding records which fail deprotection (up to the configured max_early_data_size). Once a record is deprotected successfully, it is treated as the start of the client's second flight and the server proceeds as with an ordinary 1-RTT handshake.

- Request that the client send another ClientHello by responding with a HelloRetryRequest. A client MUST NOT include the ""early_data"" extension in its followup ClientHello. The server then ignores early data by skipping all records with an external content type of ""application_data"" (indicating that they are encrypted), up to the configured max_early_data_size.

- Return its own ""early_data"" extension in EncryptedExtensions, indicating that it intends to process the early data. It is not possible for the server to accept only a subset of the early data messages."
117,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Requirements for Accepting Early Data,"In order to accept early data, the server MUST have accepted a PSK cipher suite and selected the first key offered in the client's ""pre_shared_key"" extension. In addition, it MUST verify that the following values are the same as those associated with the selected PSK:

- The TLS version number
- The selected cipher suite
- The selected ALPN [RFC7301] protocol, if any

These requirements are a superset of those needed to perform a 1-RTT handshake using the PSK in question."
118,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Error Handling for Early Data,"If any of the checks fail, the server MUST NOT respond with the extension and must discard all the first-flight data using one of the first two mechanisms listed above (thus falling back to 1-RTT or 2-RTT). If the client attempts a 0-RTT handshake but the server rejects it, the server will generally not have the 0-RTT record protection keys and must instead use trial decryption to find the first non-0-RTT message."
119,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Error Handling Requirements,"If the server chooses to accept the ""early_data"" extension, then it MUST comply with the same error-handling requirements specified for all records when processing early data records. Specifically, if the server fails to decrypt a 0-RTT record following an accepted ""early_data"" extension, it MUST terminate the connection with a ""bad_record_mac"" alert as per Section 5.2."
120,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Client Handling of Rejected Early Data,"If the server rejects the ""early_data"" extension, the client application MAY opt to retransmit the Application Data previously sent in early data once the handshake has been completed. A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate."
121,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Pre-Shared Key Extension Overview,"The ""pre_shared_key"" extension is used to negotiate the identity of the pre-shared key to be used with a given handshake in association with PSK key establishment."
122,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,PreSharedKeyExtension Structure,"The ""extension_data"" field of this extension contains a ""PreSharedKeyExtension"" value:

struct {
    opaque identity<1..2^16-1>;
    uint32 obfuscated_ticket_age;
} PskIdentity;

opaque PskBinderEntry<32..255>;

struct {
    PskIdentity identities<7..2^16-1>;
    PskBinderEntry binders<33..2^16-1>;
} OfferedPsks;

struct {
    select (Handshake.msg_type) {
        case client_hello: OfferedPsks;
        case server_hello: uint16 selected_identity;
    };
} PreSharedKeyExtension;"
123,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Field Descriptions,"1. identity: A label for a key, such as a ticket or a label for a pre-shared key established externally.

2. obfuscated_ticket_age: An obfuscated version of the age of the key. For identities established via the NewSessionTicket message, this is formed as described in Section 4.2.11.1. For externally established identities, an obfuscated_ticket_age of 0 SHOULD be used, and servers MUST ignore the value.

3. identities: A list of identities the client is willing to negotiate with the server. If sent alongside the ""early_data"" extension, the first identity is used for 0-RTT data.

4. binders: A series of HMAC values, one for each value in the identities list, computed as described below.

5. selected_identity: The server's chosen identity expressed as a (0-based) index into the identities in the client's list."
124,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,PSK Hash Algorithm,"Each PSK is associated with a single Hash algorithm. For PSKs established via the ticket mechanism, this is the KDF Hash algorithm on the connection where the ticket was established. For externally established PSKs, the Hash algorithm MUST be set when the PSK is established or default to SHA-256 if no such algorithm is defined. The server MUST ensure that it selects a compatible PSK (if any) and cipher suite."
125,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,SNI Handling in TLS 1.3,"In TLS versions prior to TLS 1.3, the Server Name Identification (SNI) value was associated with the session. In TLS 1.3, the SNI value is always explicitly specified in the resumption handshake, and there is no need for the server to associate an SNI value with the ticket. Clients SHOULD store the SNI with the PSK to fulfill the requirements of Section 4.6.1."
126,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,PSK and Cipher Suite Matching,"When session resumption is the primary use case of PSKs, the most straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and then exclude any incompatible PSKs. Unknown PSKs should be ignored. If no acceptable PSKs are found, the server SHOULD perform a non-PSK handshake if possible."
127,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Binder Validation,"Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value. If this value is not present or does not validate, the server MUST abort the handshake. Servers SHOULD select a single PSK and validate solely the binder corresponding to that PSK."
128,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Client Verification,"Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server ""key_share"" extension is present if required by the ClientHello ""psk_key_exchange_modes"" extension. If these values are not consistent, the client MUST abort the handshake with an ""illegal_parameter"" alert."
129,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Early Data Handling,"If the server supplies an ""early_data"" extension, the client MUST verify that the server's selected_identity is 0. If any other value is returned, the client MUST abort the handshake with an ""illegal_parameter"" alert."
130,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Extension Positioning,"The ""pre_shared_key"" extension MUST be the last extension in the ClientHello. Servers MUST check that it is the last extension and otherwise fail the handshake with an ""illegal_parameter"" alert."
131,4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age,Client Ticket Age Handling,"The client's view of the age of a ticket is the time since the receipt of the NewSessionTicket message. Clients MUST NOT attempt to use tickets which have ages greater than the ""ticket_lifetime"" value provided with the ticket."
132,4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age,Obfuscated Ticket Age Calculation,"The ""obfuscated_ticket_age"" field of each PskIdentity contains an obfuscated version of the ticket age. This is formed by taking the age in milliseconds and adding the ""ticket_age_add"" value included with the ticket (see Section 4.6.1), modulo 2^32. This addition prevents passive observers from correlating connections unless tickets are reused."
133,4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age,Ticket Lifetime and Age Representation,"Note that the ""ticket_lifetime"" field in the NewSessionTicket message is in seconds, while the ""obfuscated_ticket_age"" is in milliseconds. Because ticket lifetimes are restricted to a week, 32 bits is sufficient to represent any plausible age, even in milliseconds."
134,4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,PSK Binder Overview,"The PSK binder value forms a binding between a PSK and the current handshake, as well as a binding between the handshake in which the PSK was generated (if via a NewSessionTicket message) and the current handshake."
135,4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,Binder Computation,"Each entry in the binders list is computed as an HMAC over a transcript hash containing a partial ClientHello up to and including the PreSharedKeyExtension.identities field. This includes all of the ClientHello but not the binders list itself. The length fields for the message (including the overall length, the length of the extensions block, and the length of the 'pre_shared_key' extension) are all set as if binders of the correct lengths were present."
136,4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,PskBinderEntry Calculation,The PskBinderEntry is computed in the same way as the Finished message but with the BaseKey being the binder_key derived via the key schedule from the corresponding PSK being offered.
137,4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,Handling HelloRetryRequest,"If the handshake includes a HelloRetryRequest, the initial ClientHello and HelloRetryRequest are included in the transcript along with the new ClientHello. For instance, if the client sends ClientHello1, its binder will be computed over: Transcript-Hash(Truncate(ClientHello1)), where Truncate() removes the binders list from the ClientHello."
138,4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,Binder Computation with HelloRetryRequest,"If the server responds with a HelloRetryRequest and the client then sends ClientHello2, its binder will be computed over: Transcript-Hash(ClientHello1, HelloRetryRequest, Truncate(ClientHello2)). The full ClientHello1/ClientHello2 is included in all other handshake hash computations."
139,4.2.11.2.. Handshake Protocol_Extensions_Pre-Shared Key Extension_PSK Binder,Hashing Process,"In the first flight, Truncate(ClientHello1) is hashed directly, but in the second flight, ClientHello1 is hashed and then reinjected as a 'message_hash' message, as described in Section 4.4.1."
140,4.2.11.3.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Processing Order,0-RTT Data Streaming and Processing Order,"Clients are permitted to ""stream"" 0-RTT data until they receive the server's Finished message. Only after this should they send the EndOfEarlyData message, followed by the remainder of the handshake. To avoid deadlocks, when accepting early data, servers MUST process the client's ClientHello and then immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending its ServerHello."
141,4.3.. Handshake Protocol_Server Parameters,Server Handshake Messages Overview,"The next two messages from the server, EncryptedExtensions and CertificateRequest, contain information from the server that determines the rest of the handshake. These messages are encrypted with keys derived from the server_handshake_traffic_secret."
142,4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,EncryptedExtensions Message Overview,"In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message. This is the first message that is encrypted under keys derived from the server_handshake_traffic_secret."
143,4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,Purpose of EncryptedExtensions,"The EncryptedExtensions message contains extensions that can be protected, i.e., any which are not needed to establish the cryptographic context but which are not associated with individual certificates. The client MUST check EncryptedExtensions for the presence of any forbidden extensions and if any are found MUST abort the handshake with an ""illegal_parameter"" alert."
144,4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,EncryptedExtensions Message Structure,"struct {
    Extension extensions<0..2^16-1>;
} EncryptedExtensions;"
145,4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,Extensions Field Description,"extensions: A list of extensions. For more information, see the table in Section 4.2."
146,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,CertificateRequest Message Overview,"A server which is authenticating with a certificate MAY optionally request a certificate from the client. This message, if sent, MUST follow EncryptedExtensions."
147,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,CertificateRequest Message Structure,"struct {
    opaque certificate_request_context<0..2^8-1>;
    Extension extensions<2..2^16-1>;
} CertificateRequest;"
148,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Field Descriptions,"1. certificate_request_context: An opaque string which identifies the certificate request and will be echoed in the client's Certificate message. This context MUST be unique within the scope of the connection to prevent replay of client CertificateVerify messages. This field SHALL be zero length unless used for post-handshake authentication exchanges described in Section 4.6.2. When requesting post-handshake authentication, the server SHOULD make the context unpredictable to the client to prevent pre-computation of valid CertificateVerify messages by an attacker.

2. extensions: A set of extensions describing the parameters of the certificate being requested. The ""signature_algorithms"" extension MUST be specified, and other extensions may optionally be included if defined for this message. Clients MUST ignore unrecognized extensions."
149,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Signature Algorithms and Certificate Authorities,"In prior versions of TLS, the CertificateRequest message carried a list of signature algorithms and certificate authorities which the server would accept. In TLS 1.3, the former is expressed by sending the ""signature_algorithms"" and optionally ""signature_algorithms_cert"" extensions. The latter is expressed by sending the ""certificate_authorities"" extension (see Section 4.2.4)."
150,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Restrictions for PSK Authentication,"Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6)."
151,4.4.. Handshake Protocol_Authentication Messages,Overview of Authentication Messages,"TLS generally uses a common set of messages for authentication, key confirmation, and handshake integrity: Certificate, CertificateVerify, and Finished. These three messages are always sent as the last messages in their handshake flight. The Certificate and CertificateVerify messages are only sent under certain circumstances, as defined below. The Finished message is always sent as part of the Authentication Block. These messages are encrypted under keys derived from the [sender]_handshake_traffic_secret."
152,4.4.. Handshake Protocol_Authentication Messages,Inputs for Authentication Messages,"The computations for the Authentication messages all uniformly take the following inputs:

- The certificate and signing key to be used.
- A Handshake Context consisting of the set of messages to be included in the transcript hash.
- A Base Key to be used to compute a MAC key."
153,4.4.. Handshake Protocol_Authentication Messages,Message Definitions,"1. **Certificate**: The certificate to be used for authentication, and any supporting certificates in the chain. Note that certificate-based client authentication is not available in PSK handshake flows (including 0-RTT).

2. **CertificateVerify**: A signature over the value Transcript-Hash(Handshake Context, Certificate).

3. **Finished**: A MAC over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using a MAC key derived from the Base Key."
154,4.4.. Handshake Protocol_Authentication Messages,Handshake Context and MAC Base Key,"The following table defines the Handshake Context and MAC Base Key for each scenario:

| Mode      | Handshake Context       | Base Key                    |
|-----------|-------------------------|-----------------------------|
| Server    | ClientHello ... later   | server_handshake_traffic_   |
|           | of EncryptedExtensions/ | secret                      |
|           | CertificateRequest      |                             |
| Client    | ClientHello ... later   | client_handshake_traffic_   |
|           | of server               | secret                      |
|           | Finished/EndOfEarlyData |                             |
| Post-     | ClientHello ... client  | client_application_traffic_ |
| Handshake | Finished +              | secret_N                    |
|           | CertificateRequest      |                             |"
155,4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Transcript Hash Overview,"Many of the cryptographic computations in TLS make use of a transcript hash. This value is computed by hashing the concatenation of each included handshake message, including the handshake message header carrying the handshake message type and length fields, but not including record layer headers. I.e.,

Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)"
156,4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Special Case for HelloRetryRequest,"As an exception to this general rule, when the server responds to a ClientHello with a HelloRetryRequest, the value of ClientHello1 is replaced with a special synthetic handshake message of handshake type ""message_hash"" containing Hash(ClientHello1). I.e.,

Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) = Hash(message_hash || /* Handshake type */
00 00 Hash.length || /* Handshake message length (bytes) */
Hash(ClientHello1) || /* Hash of ClientHello1 */
HelloRetryRequest || ... || Mn)"
157,4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Purpose of the Synthetic Message,"The reason for this construction is to allow the server to do a stateless HelloRetryRequest by storing just the hash of ClientHello1 in the cookie, rather than requiring it to export the entire intermediate hash state (see Section 4.2.2)."
158,4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Sequence of Handshake Messages for Transcript Hash,"For concreteness, the transcript hash is always taken from the following sequence of handshake messages, starting at the first ClientHello and including only those messages that were sent: ClientHello, HelloRetryRequest, ClientHello, ServerHello, EncryptedExtensions, server CertificateRequest, server Certificate, server CertificateVerify, server Finished, EndOfEarlyData, client Certificate, client CertificateVerify, client Finished."
159,4.4.1.. Handshake Protocol_Authentication Messages_The Transcript Hash,Implementation of the Transcript Hash,"In general, implementations can implement the transcript by keeping a running transcript hash value based on the negotiated hash. Note, however, that subsequent post-handshake authentications do not include each other, just the messages through the end of the main handshake."
160,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate Message Overview,"This message conveys the endpoint's certificate chain to the peer. The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK). The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2). If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the ""certificate_list"" field having length 0). A Finished message MUST be sent regardless of whether the Certificate message is empty."
161,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate Message Structure,"enum {
    X509(0),
    RawPublicKey(2),
    (255)
} CertificateType;

struct {
    select (certificate_type) {
        case RawPublicKey:
            /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
            opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;

        case X509:
            opaque cert_data<1..2^24-1>;
    };
    Extension extensions<0..2^16-1>;
} CertificateEntry;

struct {
    opaque certificate_request_context<0..2^8-1>;
    CertificateEntry certificate_list<0..2^24-1>;
} Certificate;"
162,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Field Descriptions,"1. **certificate_request_context**: If this message is in response to a CertificateRequest, the value of certificate_request_context in that message. Otherwise (in the case of server authentication), this field SHALL be zero length.

2. **certificate_list**: A sequence (chain) of CertificateEntry structures, each containing a single certificate and set of extensions.

3. **extensions**: A set of extension values for the CertificateEntry. Valid extensions for server certificates include the OCSP Status extension [RFC6066] and the SignedCertificateTimestamp extension [RFC6962]. Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message, and those from the client MUST correspond to the CertificateRequest message from the server."
163,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate Chain Requirements,"If the corresponding certificate type extension (""server_certificate_type"" or ""client_certificate_type"") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate. The sender's certificate MUST come in the first CertificateEntry in the list. Each following certificate SHOULD directly certify the one immediately preceding it. A certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates."
164,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Handling Certificate List Ordering,"Prior to TLS 1.3, ""certificate_list"" ordering required each certificate to certify the one immediately preceding it; however, some implementations allowed flexibility. For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first."
165,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,RawPublicKey Certificate Type,"If the RawPublicKey certificate type was negotiated, then the certificate_list MUST contain no more than one CertificateEntry, which contains an ASN1_subjectPublicKeyInfo value as defined in [RFC7250], Section 3."
166,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,OpenPGP Certificate Type,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.
167,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Server Certificate List Requirement,The server's certificate_list MUST always be non-empty. A client will send an empty certificate_list if it does not have an appropriate certificate to send in response to the server's authentication request.
168,4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,OCSP Status Extension in TLS 1.3,"In TLS 1.3, the server's OCSP information is carried in an extension within the CertificateEntry that contains the associated certificate. The body of the 'status_request' extension from the server MUST be a CertificateStatus structure as defined in [RFC6066], which is interpreted according to [RFC6960]."
169,4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,Deprecation of status_request_v2 Extension,"The status_request_v2 extension [RFC6961] is deprecated. TLS 1.3 servers MUST NOT act upon its presence or the information contained within it when processing ClientHello messages. Specifically, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. However, TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients wishing to use it in earlier protocol versions."
170,4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,Client OCSP Response Request,"A server MAY request that a client present an OCSP response with its certificate by sending an empty 'status_request' extension in its CertificateRequest message. If the client opts to send an OCSP response, the body of its 'status_request' extension MUST be a CertificateStatus structure as defined in [RFC6066]."
171,4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,Signed Certificate Timestamp (SCT) Extension,"Similarly, [RFC6962] provides a mechanism for a server to send a Signed Certificate Timestamp (SCT) as an extension in the ServerHello in TLS 1.2 and below. In TLS 1.3, the server's SCT information is carried in an extension within the CertificateEntry."
172,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Certificate Selection Rules,"The following rules apply to the certificates sent by the server:

- The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).

- The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension (currently RSA, ECDSA, or EdDSA).

- The certificate MUST allow the key to be used for signing (i.e., the digitalSignature bit MUST be set if the Key Usage extension is present) with a signature scheme indicated in the client's ""signature_algorithms""/""signature_algorithms_cert"" extensions (see Section 4.2.3).

- The ""server_name"" [RFC6066] and ""certificate_authorities"" extensions are used to guide certificate selection. As servers MAY require the presence of the ""server_name"" extension, clients SHOULD send this extension when applicable."
173,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Certificate Chain Signing Requirements,All certificates provided by the server MUST be signed by a signature algorithm advertised by the client if it is able to provide such a chain (see Section 4.2.3). Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.
174,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Fallback Certificate Chain Handling,"If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then it SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms that are not known to be supported by the client. This fallback chain SHOULD NOT use the deprecated SHA-1 hash algorithm in general, but MAY do so if the client's advertisement permits it, and MUST NOT do so otherwise."
175,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Client Handling of Certificate Chains,"If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then it MUST abort the handshake with an appropriate certificate-related alert (by default, ""unsupported_certificate""; see Section 6.2 for more information)."
176,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Certificate Selection Criteria,"If the server has multiple certificates, it chooses one of them based on the above-mentioned criteria (in addition to other criteria, such as transport-layer endpoint, local configuration, and preferences)."
177,4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection,Client Certificate Selection Rules,"The following rules apply to certificates sent by the client:

- The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).

- If the ""certificate_authorities"" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.

- The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2. Note that this relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.

- If the CertificateRequest message contained a non-empty ""oid_filters"" extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client, as described in Section 4.2.5."
178,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Certificate Validation Requirements,"In general, detailed certificate validation procedures are out of scope for TLS (see [RFC5280]). This section provides TLS-specific requirements."
179,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Server Certificate Handling,"If the server supplies an empty Certificate message, the client MUST abort the handshake with a ""decode_error"" alert."
180,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Client Certificate Handling,"If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a ""certificate_required"" alert. Additionally, if some aspect of the certificate chain was unacceptable (e.g., it was not signed by a known, trusted CA), the server MAY at its discretion either continue the handshake (considering the client unauthenticated) or abort the handshake."
181,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Signature Algorithm Restrictions,"Any endpoint receiving any certificate which it would need to validate using any signature algorithm using an MD5 hash MUST abort the handshake with a ""bad_certificate"" alert. SHA-1 is deprecated, and it is RECOMMENDED that any endpoint receiving any certificate which it would need to validate using any signature algorithm using a SHA-1 hash abort the handshake with a ""bad_certificate"" alert. For clarity, this means that endpoints can accept these algorithms for certificates that are self-signed or are trust anchors."
182,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Transition to Stronger Algorithms,All endpoints are RECOMMENDED to transition to SHA-256 or better as soon as possible to maintain interoperability with implementations currently in the process of phasing out SHA-1 support.
183,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Signature Algorithm Flexibility,"Note that a certificate containing a key for one signature algorithm MAY be signed using a different signature algorithm (for instance, an RSA key signed with an ECDSA key)."
184,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,CertificateVerify Message Overview,"This message is used to provide explicit proof that an endpoint possesses the private key corresponding to its certificate. The CertificateVerify message also provides integrity for the handshake up to this point. Servers MUST send this message when authenticating via a certificate. Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty). When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message."
185,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,CertificateVerify Message Structure,"struct {
    SignatureScheme algorithm;
    opaque signature<0..2^16-1>;
} CertificateVerify;"
186,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Algorithm and Content,"The algorithm field specifies the signature algorithm used (see Section 4.2.3 for the definition of this type). The signature is a digital signature using that algorithm. The content that is covered under the signature is the hash output as described in Section 4.4.1, namely:

    Transcript-Hash(Handshake Context, Certificate)

The digital signature is computed over the concatenation of:

- A string that consists of octet 32 (0x20) repeated 64 times
- The context string
- A single 0 byte which serves as the separator
- The content to be signed."
187,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Context Strings,"The context string for a server signature is ""TLS 1.3, server CertificateVerify"". The context string for a client signature is ""TLS 1.3, client CertificateVerify"". This separation helps against potential cross-protocol attacks."
188,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Calculation Example,"For example, if the transcript hash was 32 bytes of 01 (this length would make sense for SHA-256), the content covered by the digital signature for a server CertificateVerify would be:

    2020202020202020202020202020202020202020202020202020202020202020
    2020202020202020202020202020202020202020202020202020202020202020
    544c5320312e332c207365727665722043657274696669636174655665726966
    79
    00
    0101010101010101010101010101010101010101010101010101010101010101"
189,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Generation Process,"On the sender side, the process for computing the signature field of the CertificateVerify message takes as input:

- The content covered by the digital signature
- The private signing key corresponding to the certificate sent in the previous message."
190,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Algorithm Requirements,"If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's ""signature_algorithms"" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3). If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the ""signature_algorithms"" extension in the CertificateRequest message."
191,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Algorithm Compatibility,"The signature algorithm MUST be compatible with the key in the sender's end-entity certificate. RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in ""signature_algorithms"". The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages."
192,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Verification Process,"The receiver of a CertificateVerify message MUST verify the signature field. The verification process takes as input:

- The content covered by the digital signature
- The public key contained in the end-entity certificate found in the associated Certificate message
- The digital signature received in the signature field of the CertificateVerify message."
193,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Error Handling,"If the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert."
194,4.4.4.. Handshake Protocol_Authentication Messages_Finished,Finished Message Overview,"The Finished message is the final message in the Authentication Block. It is essential for providing authentication of the handshake and of the computed keys. Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a ""decrypt_error"" alert."
195,4.4.4.. Handshake Protocol_Authentication Messages_Finished,Sending Application Data,"Once a side has sent its Finished message and has received and validated the Finished message from its peer, it may begin to send and receive Application Data over the connection. There are two settings in which it is permitted to send data prior to receiving the peer's Finished: 1. Clients sending 0-RTT data as described in Section 4.2.10. 2. Servers MAY send data after sending their first flight, but because the handshake is not yet complete, they have no assurance of either the peer's identity or its liveness (i.e., the ClientHello might have been replayed)."
196,4.4.4.. Handshake Protocol_Authentication Messages_Finished,Finished Message Key Computation,"The key used to compute the Finished message is computed from the Base Key defined in Section 4.4 using HKDF (see Section 7.1). Specifically: finished_key = HKDF-Expand-Label(BaseKey, ""finished"", "", Hash.length)."
197,4.4.4.. Handshake Protocol_Authentication Messages_Finished,Finished Message Structure,struct { opaque verify_data[Hash.length]; } Finished;
198,4.4.4.. Handshake Protocol_Authentication Messages_Finished,Verify Data Calculation,"The verify_data value is computed as follows: verify_data = HMAC(finished_key, Transcript-Hash(Handshake Context, Certificate*, CertificateVerify*)). * Only included if present. HMAC [RFC2104] uses the Hash algorithm for the handshake. As noted above, the HMAC input can generally be implemented by a running hash, i.e., just the handshake hash at this point."
199,4.4.4.. Handshake Protocol_Authentication Messages_Finished,HMAC Output Size,"In previous versions of TLS, the verify_data was always 12 octets long. In TLS 1.3, it is the size of the HMAC output for the Hash used for the handshake."
200,4.4.4.. Handshake Protocol_Authentication Messages_Finished,Post-Finished Message Requirements,"Any records following a Finished message MUST be encrypted under the appropriate application traffic key as described in Section 7.2. In particular, this includes any alerts sent by the server in response to client Certificate and CertificateVerify messages."
201,4.5.. Handshake Protocol_End of Early Data,EndOfEarlyData Message Overview,"struct {} EndOfEarlyData;

If the server sent an ""early_data"" extension in EncryptedExtensions, the client MUST send an EndOfEarlyData message after receiving the server Finished. If the server does not send an ""early_data"" extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message. This message indicates that all 0-RTT application_data messages, if any, have been transmitted and that the following records are protected under handshake traffic keys."
202,4.5.. Handshake Protocol_End of Early Data,Message Handling Requirements,"Servers MUST NOT send this message, and clients receiving it MUST terminate the connection with an ""unexpected_message"" alert. This message is encrypted under keys derived from the client_early_traffic_secret."
203,4.6.. Handshake Protocol_Post-Handshake Messages,Post-Handshake Message Overview,TLS also allows other messages to be sent after the main handshake. These messages use a handshake content type and are encrypted under the appropriate application traffic key.
204,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,NewSessionTicket Message Overview,"At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message. This message creates a unique association between the ticket value and a secret PSK derived from the resumption master secret (see Section 7). The client MAY use this PSK for future handshakes by including the ticket value in the ""pre_shared_key"" extension in its ClientHello (Section 4.2.11). Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events (see Appendix C.4)."
205,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Purpose of Multiple Tickets,"Multiple tickets are useful for clients for a variety of purposes, including:

- Opening multiple parallel HTTP connections.
- Performing connection racing across interfaces and address families via (for example) Happy Eyeballs [RFC8305] or related techniques."
206,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Ticket Resumption Requirements,"Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection. Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session. If such an indication is provided (externally or by any other means), clients MAY resume with a different SNI value."
207,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,SNI Value Reporting,"On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session. Note that if a server implementation declines all PSK identities with different SNI values, these two values are always the same."
208,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,NewSessionTicket Structure,"struct {
    uint32 ticket_lifetime;
    uint32 ticket_age_add;
    opaque ticket_nonce<0..255>;
    opaque ticket<1..2^16-1>;
    Extension extensions<0..2^16-2>;
} NewSessionTicket;"
209,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Field Descriptions,"1. ticket_lifetime: Indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance. Servers MUST NOT use any value greater than 604800 seconds (7 days). The value of zero indicates that the ticket should be discarded immediately.

2. ticket_age_add: A securely generated, random 32-bit value that obscures the age of the ticket included in the ""pre_shared_key"" extension. The server MUST generate a fresh value for each ticket it sends.

3. ticket_nonce: A per-ticket value that is unique across all tickets issued on this connection.

4. ticket: The value of the ticket to be used as the PSK identity. It MAY be either a database lookup key or a self-encrypted and self-authenticated value.

5. extensions: A set of extension values for the ticket. Clients MUST ignore unrecognized extensions."
210,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Early Data Extension,"The sole extension currently defined for NewSessionTicket is ""early_data"", indicating that the ticket may be used to send 0-RTT data (Section 4.2.10). It contains the value max_early_data_size, which is the maximum amount of 0-RTT data that the client is allowed to send when using this ticket, in bytes."
211,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,PSK Derivation,"The PSK associated with the ticket is computed as:

    HKDF-Expand-Label(resumption_master_secret, ""resumption"", ticket_nonce, Hash.length)

Because the ticket_nonce value is distinct for each NewSessionTicket message, a different PSK will be derived for each ticket."
212,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Keying Material Lifetime,"It is RECOMMENDED that implementations place limits on the total lifetime of keying material derived from an initial non-PSK handshake. These limits should consider the lifetime of the peer's certificate, the likelihood of intervening revocation, and the time since the peer's online CertificateVerify signature."
213,4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Post-Handshake Authentication Overview,"When the client has sent the ""post_handshake_auth"" extension, a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message. The client MUST respond with the appropriate Authentication messages. If the client chooses to authenticate, it MUST send Certificate, CertificateVerify, and Finished. If it declines, it MUST send a Certificate message containing no certificates followed by Finished. All of the client's messages for a given response MUST appear consecutively on the wire with no intervening messages of other types."
214,4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,CertificateRequest Handling,"A client that receives a CertificateRequest message without having sent the ""post_handshake_auth"" extension MUST send an ""unexpected_message"" fatal alert."
215,4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Client Response Timing Considerations,"Because client authentication could involve prompting the user, servers MUST be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response. In addition, clients which receive multiple CertificateRequests in close succession MAY respond to them in a different order than they were received, as the certificate_request_context value allows the server to disambiguate the responses."
216,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,KeyUpdate Message Overview,"The KeyUpdate handshake message is used to indicate that the sender is updating its sending cryptographic keys. This message can be sent by either peer after it has sent a Finished message. Implementations that receive a KeyUpdate message prior to receiving a Finished message MUST terminate the connection with an 'unexpected_message' alert. After sending a KeyUpdate message, the sender SHALL send all its traffic using the next generation of keys, computed as described in Section 7.2. Upon receiving a KeyUpdate, the receiver MUST update its receiving keys."
217,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,KeyUpdateRequest Enumeration,"enum {
    update_not_requested(0), update_requested(1), (255)
} KeyUpdateRequest;"
218,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,KeyUpdate Structure,"struct {
    KeyUpdateRequest request_update;
} KeyUpdate;"
219,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,request_update Field Description,"The request_update field indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate. If an implementation receives any other value, it MUST terminate the connection with an 'illegal_parameter' alert."
220,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,KeyUpdate Response Mechanism,"If the request_update field is set to 'update_requested', then the receiver MUST send a KeyUpdate of its own with request_update set to 'update_not_requested' prior to sending its next Application Data record. This mechanism allows either side to force an update to the entire connection, but causes an implementation which receives multiple KeyUpdates while it is silent to respond with a single update."
221,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Handling Multiple KeyUpdates,"Implementations may receive an arbitrary number of messages between sending a KeyUpdate with request_update set to 'update_requested' and receiving the peer's KeyUpdate, because those messages may already be in flight. However, because send and receive keys are derived from independent traffic secrets, retaining the receive traffic secret does not threaten the forward secrecy of data sent before the sender changed keys."
222,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Crossing KeyUpdates,"If implementations independently send their own KeyUpdates with request_update set to 'update_requested' and they cross in flight, then each side will also send a response, resulting in each side incrementing by two generations."
223,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Encryption and KeyUpdate Order,"Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys. Additionally, both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key. Failure to do so may allow message truncation attacks."
