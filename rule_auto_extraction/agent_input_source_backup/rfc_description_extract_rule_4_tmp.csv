index,Section,Title,Content,result
1,4.. Handshake Protocol,Message Order and Error Handling,"Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2. A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.","""[
  {
    ""section"": ""4.. Handshake Protocol"",
    ""title"": ""Message Order and Error Handling"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST/SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Protocol messages MUST be sent in the order defined in Section 4.4.1 and illustrated in the diagrams in Section 2.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC/CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""A peer which receives a handshake message in an unexpected order MUST abort the handshake with an 'unexpected_message' alert.""
    }
  }
]"""
2,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Server Parameter Selection,"If the server does not select a PSK, it independently selects a cipher suite, an (EC)DHE group and key share, and a signature algorithm/certificate pair. If there is no overlap in 'supported_groups', the server MUST abort the handshake with a 'handshake_failure' or 'insufficient_security' alert.","""[
  {
    ""section"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""Server Parameter Selection"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The server MUST independently select a cipher suite, an (EC)DHE group, a key share, and a signature algorithm/certificate pair if it does not select a PSK.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""The server MUST abort the handshake with a 'handshake_failure' or 'insufficient_security' alert if there is no overlap in 'supported_groups'.""
    }
  }
]"""
3,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,PSK Selection,"If the server selects a PSK, it MUST also select a key establishment mode from the client's 'psk_key_exchange_modes' extension. If the PSK can be used without (EC)DHE, non-overlap in 'supported_groups' is not fatal.","""[
  {
    ""section"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""PSK Selection"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""When a server selects a PSK, it MUST also select a key establishment mode from the client's 'psk_key_exchange_modes' extension.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST ensure their 'psk_key_exchange_modes' extension is included to facilitate server's PSK selection.""
    }
  },
  {
    ""section"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""PSK Selection"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 0,
      ""construction_base"": ""If a PSK can be used without (EC)DHE, the non-overlap in 'supported_groups' is not fatal.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Clients should not consider non-overlap in 'supported_groups' fatal if PSK is usable without (EC)DHE.""
    }
  }
]"""
4,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,HelloRetryRequest Requirement,"If the server selects an (EC)DHE group and the client did not offer a compatible 'key_share', the server MUST respond with a HelloRetryRequest message.","""[
  {
    ""section"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""HelloRetryRequest Requirement"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""If the server selects an (EC)DHE group and the client did not offer a compatible 'key_share', the server MUST send a HelloRetryRequest message.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Clients should expect a HelloRetryRequest message if their 'key_share' is not compatible.""
    }
  }
]"""
5,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Handshake Failure Conditions,"If the server is unable to negotiate a supported set of parameters, it MUST abort the handshake with a 'handshake_failure' or 'insufficient_security' fatal alert.","""[
  {
    ""section"": ""4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation"",
    ""title"": ""Handshake Failure Conditions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The server MUST abort the handshake if it cannot negotiate a supported set of parameters.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Upon failure to negotiate parameters, the server MUST send a 'handshake_failure' or 'insufficient_security' fatal alert.""
    }
  }
]"""
6,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,ClientHello Message Overview,"When a client first connects to a server, it is REQUIRED to send the ClientHello as its first TLS message. The client will also send a ClientHello when the server has responded to its ClientHello with a HelloRetryRequest. In that case, the client MUST send the same ClientHello without modification, except as follows: - If a ""key_share"" extension was supplied in the HelloRetryRequest, replacing the list of shares with a list containing a single KeyShareEntry from the indicated group. - Removing the ""early_data"" extension if one was present. Early data is not permitted after a HelloRetryRequest. - Including a ""cookie"" extension if one was provided in the HelloRetryRequest. - Updating the ""pre_shared_key"" extension if present by recomputing the ""obfuscated_ticket_age"" and binder values and (optionally) removing any PSKs which are incompatible with the server's indicated cipher suite. - Optionally adding, removing, or changing the length of the ""padding"" extension [RFC7685]. - Other modifications that may be allowed by an extension defined in the future and present in the HelloRetryRequest.","""[
  {
    ""section"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""ClientHello Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST send the ClientHello as the first TLS message when connecting to a server. If a HelloRetryRequest is received, the client MUST resend the same ClientHello, modifying only as specified.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST expect the ClientHello as the first message and MUST handle a HelloRetryRequest by validating the modifications made by the client.""
    }
  },
  {
    ""section"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""ClientHello Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST replace the list of shares in the \""key_share\"" extension with a single KeyShareEntry from the indicated group if specified in the HelloRetryRequest.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST validate that the \""key_share\"" extension contains a single KeyShareEntry as indicated in the HelloRetryRequest.""
    }
  },
  {
    ""section"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""ClientHello Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST remove the \""early_data\"" extension if it was present when sending ClientHello after a HelloRetryRequest.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST reject any ClientHello that includes the \""early_data\"" extension after a HelloRetryRequest.""
    }
  },
  {
    ""section"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""ClientHello Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST include a \""cookie\"" extension if provided in the HelloRetryRequest.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST process the \""cookie\"" extension if present in the ClientHello after a HelloRetryRequest.""
    }
  },
  {
    ""section"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""ClientHello Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST update the \""pre_shared_key\"" extension by recomputing the \""obfuscated_ticket_age\"" and binder values, and may remove incompatible PSKs as indicated by the server's cipher suite.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST validate the updated \""pre_shared_key\"" extension for correctness according to the cipher suite.""
    }
  },
  {
    ""section"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""ClientHello Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 0,
      ""construction_base"": ""Clients MAY optionally add, remove, or change the length of the \""padding\"" extension.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Servers MAY handle modifications to the \""padding\"" extension as specified by the client.""
    }
  }
]"""
7,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Connection Termination Rules,"Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an ""unexpected_message"" alert. If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version. In particular, it MUST NOT negotiate TLS 1.3.","""[
  {
    ""section"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""Connection Termination Rules"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST terminate the connection with an 'unexpected_message' alert if they receive a ClientHello after negotiating TLS 1.3.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST retain the previous protocol version if a TLS 1.3 ClientHello is received during a renegotiation of a prior TLS version, and MUST NOT negotiate TLS 1.3.""
    }
  }
]"""
8,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Field Descriptions,"1. legacy_version: Set to 0x0303 (TLS v1.2) for compatibility with middleboxes. The actual version is indicated using the ""supported_versions"" extension. 2. random: 32 bytes generated by a secure random number generator. 3. legacy_session_id: A cached session ID from a pre-TLS 1.3 server, or a new unpredictable value if none exists. 4. cipher_suites: A list of symmetric cipher options supported by the client. 5. legacy_compression_methods: Must contain exactly one byte, set to zero. 6. extensions: Clients request extended functionality from servers by sending data in the extensions field.","""[
  {
    ""section"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The 'legacy_version' field MUST be set to 0x0303 for compatibility with middleboxes; the actual version is indicated using the 'supported_versions' extension.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST accept 'legacy_version' set to 0x0303 and refer to the 'supported_versions' extension for the actual version.""
    }
  },
  {
    ""section"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The 'random' field MUST contain 32 bytes generated by a secure random number generator.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST validate that the 'random' field contains 32 bytes.""
    }
  },
  {
    ""section"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The 'legacy_session_id' field MUST be either a cached session ID from a pre-TLS 1.3 server or a new unpredictable value if none exists.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST handle 'legacy_session_id' by accepting either a cached session ID or a new unpredictable value.""
    }
  },
  {
    ""section"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The 'cipher_suites' field MUST contain a list of symmetric cipher options supported by the client.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST validate the 'cipher_suites' field to ensure it contains supported symmetric cipher options.""
    }
  },
  {
    ""section"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The 'legacy_compression_methods' field MUST contain exactly one byte, set to zero.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST check that the 'legacy_compression_methods' field contains exactly one byte, set to zero.""
    }
  },
  {
    ""section"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The 'extensions' field is used by clients to request extended functionality from servers.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST process the 'extensions' field to fulfill the extended functionality requests from clients.""
    }
  }
]"""
9,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Extension Handling,"Clients request extended functionality from servers by sending data in the extensions field. In TLS 1.3, the use of certain extensions is mandatory, and servers MUST ignore unrecognized extensions. TLS 1.3 ClientHello messages always contain extensions, minimally the ""supported_versions"" extension.","""[
  {
    ""section"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""Extension Handling"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST include extensions in ClientHello messages, with at least the 'supported_versions' extension.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST ignore any unrecognized extensions in ClientHello messages.""
    }
  },
  {
    ""section"": ""4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello"",
    ""title"": ""Extension Handling"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST include mandatory extensions as specified in the TLS 1.3 protocol.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST process ClientHello messages while adhering to the mandatory extension requirements.""
    }
  }
]"""
10,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Field Descriptions,"1. **legacy_version**: Set to 0x0303 (TLS v1.2) for compatibility with middleboxes. The actual version is indicated using the ""supported_versions"" extension.

2. **random**: 32 bytes generated by a secure random number generator. The last 8 bytes must be overwritten if negotiating TLS 1.2 or TLS 1.1, while the rest must be random.

3. **legacy_session_id_echo**: Echoes the client's legacy_session_id. If this does not match the client's sent value, the handshake must abort with an ""illegal_parameter"" alert.

4. **cipher_suite**: The selected cipher suite from the ClientHello. If not offered, the handshake must abort with an ""illegal_parameter"" alert.

5. **legacy_compression_method**: Must be set to 0.

6. **extensions**: Must include only those necessary for establishing the cryptographic context. All TLS 1.3 ServerHello messages must contain the ""supported_versions"" extension.","""[
  {
    ""section"": ""4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The legacy_version field MUST be set to 0x0303 for compatibility with middleboxes.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Clients MUST recognize that the actual version is indicated using the supported_versions extension.""
    }
  },
  {
    ""section"": ""4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The random field MUST consist of 32 bytes generated by a secure random number generator, with the last 8 bytes overwritten if negotiating TLS 1.2 or TLS 1.1.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Clients MUST ensure random bytes are provided according to the specified rules.""
    }
  },
  {
    ""section"": ""4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The legacy_session_id_echo field MUST echo the client's legacy_session_id. If it does not match, the handshake MUST abort with an illegal_parameter alert.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Clients MUST abort the handshake if the legacy_session_id_echo does not match the sent value.""
    }
  },
  {
    ""section"": ""4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The cipher_suite field MUST contain a selected cipher suite from the ClientHello. If not offered, the handshake MUST abort with an illegal_parameter alert.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Clients MUST recognize and abort if the selected cipher suite is not offered.""
    }
  },
  {
    ""section"": ""4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The legacy_compression_method field MUST be set to 0.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Clients MUST ensure the legacy_compression_method is set to 0.""
    }
  },
  {
    ""section"": ""4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The extensions field MUST include only those necessary for establishing the cryptographic context and MUST contain the supported_versions extension.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Clients MUST ensure that only necessary extensions are included in the message.""
    }
  }
]"""
11,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Downgrade Protection Mechanism,"TLS 1.3 has a downgrade protection mechanism embedded in the server's random value. If negotiating TLS 1.2, the last 8 bytes of the Random value must be set to:

44 4F 57 4E 47 52 44 01

If negotiating TLS 1.1 or below, they should be set to:

44 4F 57 4E 47 52 44 00.

Clients must check these values and abort the handshake with an ""illegal_parameter"" alert if they match.","""[
  {
    ""section"": ""4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello"",
    ""title"": ""Downgrade Protection Mechanism"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST check the last 8 bytes of the server's Random value during the handshake. If they are set to '44 4F 57 4E 47 52 44 01' (indicating a negotiation of TLS 1.2) or '44 4F 57 4E 47 52 44 00' (indicating TLS 1.1 or below), they MUST abort the handshake.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST set the last 8 bytes of the Random value to '44 4F 57 4E 47 52 44 01' when negotiating TLS 1.2 and to '44 4F 57 4E 47 52 44 00' when negotiating TLS 1.1 or below.""
    }
  }
]"""
12,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Renegotiation Handling,"A legacy TLS client performing renegotiation with TLS 1.2 or prior that receives a TLS 1.3 ServerHello during renegotiation must abort the handshake with a ""protocol_version"" alert. Note that renegotiation is not possible when TLS 1.3 has been negotiated.","""[
  {
    ""section"": ""4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello"",
    ""title"": ""Renegotiation Handling"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""A legacy TLS client performing renegotiation with TLS 1.2 or prior MUST abort the handshake upon receiving a TLS 1.3 ServerHello, issuing a 'protocol_version' alert.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""The server MUST not allow renegotiation when TLS 1.3 has been negotiated.""
    }
  }
]"""
13,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Extensions Requirements,"The server's extensions MUST contain 'supported_versions'. Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair. A HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the 'cookie' extension.","""[
  {
    ""section"": ""4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request"",
    ""title"": ""Extensions Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The server's extensions MUST contain 'supported_versions' and SHOULD include the minimal set of extensions necessary for the client to generate a correct ClientHello.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Clients should be prepared to handle a HelloRetryRequest without extensions not offered in the initial ClientHello, except for the optional 'cookie' extension.""
    }
  },
  {
    ""section"": ""4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request"",
    ""title"": ""Extensions Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""A HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, except optionally the 'cookie' extension.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST reject any HelloRetryRequest that contains extensions not offered in its initial ClientHello, except for the 'cookie' extension.""
    }
  }
]"""
14,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Client Processing of HelloRetryRequest,"Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using 'supported_versions'. Clients MUST abort the handshake with an 'illegal_parameter' alert if the HelloRetryRequest would not result in any change in the ClientHello. If a client receives a second HelloRetryRequest in the same connection, it MUST abort the handshake with an 'unexpected_message' alert.","""[
  {
    ""section"": ""4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request"",
    ""title"": ""Client Processing of HelloRetryRequest"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method upon receipt of a HelloRetryRequest.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST process the extensions and determine the version using 'supported_versions'.""
    }
  },
  {
    ""section"": ""4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request"",
    ""title"": ""Client Processing of HelloRetryRequest"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST abort the handshake with an 'illegal_parameter' alert if the HelloRetryRequest would not result in any change in the ClientHello.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST abort the handshake with an 'unexpected_message' alert if a second HelloRetryRequest is received in the same connection.""
    }
  }
]"""
15,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Extension Processing and Updated ClientHello,"Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello. The HelloRetryRequest extensions defined in this specification are: - supported_versions (see Section 4.2.1) - cookie (see Section 4.2.2) - key_share (see Section 4.2.8). A client which receives a cipher suite that was not offered MUST abort the handshake.","""[
  {
    ""section"": ""4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request"",
    ""title"": ""Extension Processing and Updated ClientHello"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST ensure that the ClientHello includes only the extensions defined in the HelloRetryRequest.""
    }
  },
  {
    ""section"": ""4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request"",
    ""title"": ""Extension Processing and Updated ClientHello"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST include the supported_versions, cookie, and key_share extensions as defined in the HelloRetryRequest.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST abort the handshake if a cipher suite not offered is received.""
    }
  }
]"""
16,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Cipher Suite Negotiation,"Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello. Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an 'illegal_parameter' alert.","""[
  {
    ""section"": ""4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request"",
    ""title"": ""Cipher Suite Negotiation"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST negotiate the same cipher suite when receiving a conformant updated ClientHello.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST check that the cipher suite in the ServerHello matches that in the HelloRetryRequest, and abort the handshake with an 'illegal_parameter' alert if they do not match.""
    }
  }
]"""
17,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Version Retention in ServerHello,"The value of selected_version in the HelloRetryRequest 'supported_versions' extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an 'illegal_parameter' alert if the value changes.","""[
  {
    ""section"": ""4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request"",
    ""title"": ""Version Retention in ServerHello"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST retain the value of selected_version in the HelloRetryRequest 'supported_versions' extension.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST ensure the value of selected_version in the HelloRetryRequest is the same in the ServerHello; otherwise, clients MUST abort the handshake with an 'illegal_parameter' alert.""
    }
  }
]"""
18,4.2.. Handshake Protocol_Extensions,Extension Handling Rules,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest. Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert.","""[
  {
    ""section"": ""4.2.. Handshake Protocol_Extensions"",
    ""title"": ""Extension Handling Rules"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST/SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, except for the 'cookie' extension in HelloRetryRequest.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC/CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Upon receiving an unsupported extension, an endpoint MUST abort the handshake with an 'unsupported_extension' alert.""
    }
  }
]"""
19,4.2.. Handshake Protocol_Extensions,Extension Message Compatibility,"The table below indicates the messages where a given extension may appear, using the following notation: CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), and HRR (HelloRetryRequest). If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an ""illegal_parameter"" alert.","""[
  {
    ""section"": ""4.2.. Handshake Protocol_Extensions"",
    ""title"": ""Extension Message Compatibility"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST ensure that extensions are only included in messages where they are specified to appear.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST abort the handshake with an 'illegal_parameter' alert if an extension is received in an unexpected message.""
    }
  }
]"""
20,4.2.. Handshake Protocol_Extensions,Extension Order and Uniqueness,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" which MUST be the last extension in the ClientHello. There MUST NOT be more than one extension of the same type in a given extension block.","""[
  {
    ""section"": ""4.2.. Handshake Protocol_Extensions"",
    ""title"": ""Extension Order and Uniqueness"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MAY place extensions in any order in the ClientHello, except the \""pre_shared_key\"" extension which MUST be last.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST ensure the \""pre_shared_key\"" extension is the last extension in ClientHello.""
    }
  },
  {
    ""section"": ""4.2.. Handshake Protocol_Extensions"",
    ""title"": ""Extension Order and Uniqueness"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST NOT include more than one extension of the same type in any extension block.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST reject ClientHello messages with duplicate extension types.""
    }
  }
]"""
21,4.2.1.. Handshake Protocol_Extensions_Supported Versions,ClientHello Requirements,"Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which they are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, they MUST be present as well).","""[
  {
    ""section"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""ClientHello Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST send the 'Supported Versions' extension in ClientHello, containing all TLS versions they are prepared to negotiate, including at least 0x0304.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST process the 'Supported Versions' extension and validate that it includes all versions of TLS that the client is prepared to negotiate.""
    }
  },
  {
    ""section"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""ClientHello Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""If previous versions of TLS are allowed for negotiation, they MUST also be included in the 'Supported Versions' extension.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST ensure that any previous TLS versions permitted for negotiation are present in the 'Supported Versions' extension.""
    }
  }
]"""
22,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Server Behavior Without the Extension,"If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.","""[
  {
    ""section"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""Server Behavior Without the Extension"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST negotiate TLS 1.2 or prior if the Supported Versions extension is not present, regardless of ClientHello.legacy_version being 0x0304 or later.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later if the Supported Versions extension is absent.""
    }
  }
]"""
23,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Server Behavior With the Extension,"If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension.","""[
  {
    ""section"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""Server Behavior With the Extension"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST include the \""supported_versions\"" extension in ClientHello for server version negotiation.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST NOT use ClientHello.legacy_version for version negotiation if the \""supported_versions\"" extension is present; they MUST use the versions specified in that extension.""
    }
  },
  {
    ""section"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""Server Behavior With the Extension"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST ensure that the \""supported_versions\"" extension lists all TLS versions they support.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST select a TLS version from the \""supported_versions\"" extension and MUST ignore any unknown versions present.""
    }
  }
]"""
24,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Negotiation of Versions Prior to TLS 1.2,This mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.,"""[
  {
    ""section"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""Negotiation of Versions Prior to TLS 1.2"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients that support prior versions of TLS SHOULD include TLS 1.2 in their supported versions list.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST be prepared to receive ClientHellos with this extension, and handle cases where 0x0304 (TLS 1.3) is not included in the list of versions.""
    }
  }
]"""
25,4.2.1.. Handshake Protocol_Extensions_Supported Versions,ServerHello Version Negotiation,"A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2).","""[
  {
    ""section"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""ServerHello Version Negotiation"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers negotiating a version prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the \""supported_versions\"" extension.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers negotiating TLS 1.3 MUST include a \""supported_versions\"" extension with the selected version value (0x0304) and set ServerHello.legacy_version to 0x0303 (TLS 1.2).""
    }
  }
]"""
26,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Client Checks for the Supported Versions Extension,"Clients MUST check for this extension prior to processing the rest of the ServerHello. If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version. If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert.","""[
  {
    ""section"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""Client Checks for the Supported Versions Extension"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST check for the 'supported_versions' extension prior to processing the rest of the ServerHello.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""If the 'supported_versions' extension is present, clients MUST ignore the ServerHello.legacy_version value.""
    }
  },
  {
    ""section"": ""4.2.1.. Handshake Protocol_Extensions_Supported Versions"",
    ""title"": ""Client Checks for the Supported Versions Extension"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST use only the 'supported_versions' extension to determine the selected version.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""If the 'supported_versions' extension contains a version not offered by the client or a version prior to TLS 1.3, clients MUST abort the handshake with an 'illegal_parameter' alert.""
    }
  }
]"""
27,4.2.2.. Handshake Protocol_Extensions_Cookie,HelloRetryRequest Cookie Extension,"When sending a HelloRetryRequest, the server MAY provide a ""cookie"" extension to the client (this is an exception to the usual rule that only extensions appearing in the ClientHello may be sent). When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a ""cookie"" extension in the new ClientHello. Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.","""[
  {
    ""section"": ""4.2.2.. Handshake Protocol_Extensions_Cookie"",
    ""title"": ""HelloRetryRequest Cookie Extension"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST copy the contents of the 'cookie' extension received in the HelloRetryRequest into a 'cookie' extension in the new ClientHello.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MAY include a 'cookie' extension in the HelloRetryRequest to the client.""
    }
  },
  {
    ""section"": ""4.2.2.. Handshake Protocol_Extensions_Cookie"",
    ""title"": ""HelloRetryRequest Cookie Extension"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""No server-side processing rule regarding the prohibition of using cookies in initial ClientHello messages.""
    }
  }
]"""
28,4.2.2.. Handshake Protocol_Extensions_Cookie,Stateless Server Behavior,"When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5). Since the server is not storing any state, this will appear as if it were the first message received. Servers operating statelessly MUST ignore these records.","""[
  {
    ""section"": ""4.2.2.. Handshake Protocol_Extensions_Cookie"",
    ""title"": ""Stateless Server Behavior"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers operating statelessly MUST ignore unprotected records of type change_cipher_spec received between the first and second ClientHello.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""When a server receives an unprotected change_cipher_spec record while operating statelessly, it must treat it as if it were the first message received and ignore it.""
    }
  }
]"""
29,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Client Requirements for Signature Algorithms,"Clients that desire server authentication via a certificate MUST send the ""signature_algorithms"" extension. If the server is authenticating via a certificate and the client has not sent this extension, the server MUST abort the handshake with a ""missing_extension"" alert.","""[
  {
    ""section"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""Client Requirements for Signature Algorithms"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST send the \""signature_algorithms\"" extension if they desire server authentication via a certificate.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST abort the handshake with a \""missing_extension\"" alert if the client has not sent the \""signature_algorithms\"" extension while authenticating via a certificate.""
    }
  }
]"""
30,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,RSASSA-PSS Algorithms,Indicates a signature algorithm using RSASSA-PSS with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST equal the output length of the digest algorithm.,"""[
  {
    ""section"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""RSASSA-PSS Algorithms"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST specify a signature algorithm using RSASSA-PSS with mask generation function 1, ensuring that the Salt length equals the output length of the digest algorithm.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST validate that the Salt length matches the output length of the specified digest algorithm.""
    }
  }
]"""
31,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Legacy Algorithms,"Indicates algorithms being deprecated due to known weaknesses, specifically SHA-1 used with RSA or ECDSA. These values refer solely to signatures in certificates and should not be negotiated unless for backward compatibility. TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it.","""[
  {
    ""section"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""Legacy Algorithms"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients should be aware that SHA-1 signed certificates are deprecated and should not be negotiated unless for backward compatibility.""
    }
  }
]"""
32,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,TLS 1.2 Compatibility,"TLS 1.3 implementations willing to negotiate TLS 1.2 MUST comply with the requirements of [RFC5246]. In TLS 1.2, ClientHellos may omit the signature algorithms extension, which contained hash/signature pairs encoded in two octets. Legacy pairs are deprecated and MUST NOT be offered or negotiated.","""[
  {
    ""section"": ""4.2.3.. Handshake Protocol_Extensions_Signature Algorithms"",
    ""title"": ""TLS 1.2 Compatibility"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients negotiating TLS 1.2 MUST comply with the requirements of RFC5246. Clients MAY omit the signature algorithms extension in ClientHellos.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST ensure that legacy signature algorithm pairs, which are deprecated, MUST NOT be offered or negotiated.""
    }
  }
]"""
33,4.2.5.. Handshake Protocol_Extensions_OID Filters,OID Filters Extension Overview,"The ""oid_filters"" extension allows servers to provide a set of OID/value pairs which it would like the client's certificate to match. This extension, if provided by the server, MUST only be sent in the CertificateRequest message.","""[
  {
    ""section"": ""4.2.5.. Handshake Protocol_Extensions_OID Filters"",
    ""title"": ""OID Filters Extension Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST include the \""oid_filters\"" extension only in the CertificateRequest message.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST ensure that the \""oid_filters\"" extension is processed only if it appears in the CertificateRequest message.""
    }
  }
]"""
34,4.2.5.. Handshake Protocol_Extensions_OID Filters,Filters List Description,"filters: A list of certificate extension OIDs [RFC5280] with their allowed value(s) and represented in DER-encoded [X690] format. Some certificate extension OIDs allow multiple values (e.g., Extended Key Usage). If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes.","""[
  {
    ""section"": ""4.2.5.. Handshake Protocol_Extensions_OID Filters"",
    ""title"": ""Filters List Description"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST include all specified certificate extension OIDs in the client certificate if the server provides a non-empty filters list.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST ensure that the client certificate contains all specified extension OIDs that the client recognizes from the filters list.""
    }
  }
]"""
35,4.2.5.. Handshake Protocol_Extensions_OID Filters,Client Certificate Requirements,"For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well). However, the client MUST ignore and skip any unrecognized certificate extension OIDs. If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an ""unsupported_certificate"" alert.","""[
  {
    ""section"": ""4.2.5.. Handshake Protocol_Extensions_OID Filters"",
    ""title"": ""Client Certificate Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST ensure that all specified values for recognized extension OIDs are present in the client certificate, although the certificate MAY contain additional values.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MAY choose to continue the connection without client authentication or abort the handshake with an 'unsupported_certificate' alert if the client ignores required certificate extension OIDs.""
    }
  },
  {
    ""section"": ""4.2.5.. Handshake Protocol_Extensions_OID Filters"",
    ""title"": ""Client Certificate Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST ignore and skip any unrecognized certificate extension OIDs.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST handle the absence of required certificate extension OIDs appropriately, based on the client's compliance.""
    }
  }
]"""
36,4.2.5.. Handshake Protocol_Extensions_OID Filters,OID Uniqueness and Matching Rules,"Any given OID MUST NOT appear more than once in the filters list. PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types. Depending on the type, matching certificate extension values are not necessarily bitwise-equal. This document defines matching rules for two standard certificate extensions defined in [RFC5280]:

- The Key Usage extension in a certificate matches the request when all key usage bits asserted in the request are also asserted in the Key Usage certificate extension.

- The Extended Key Usage extension in a certificate matches the request when all key purpose OIDs present in the request are also found in the Extended Key Usage certificate extension. The special anyExtendedKeyUsage OID MUST NOT be used in the request.","""[
  {
    ""section"": ""4.2.5.. Handshake Protocol_Extensions_OID Filters"",
    ""title"": ""OID Uniqueness and Matching Rules"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST NOT include the same OID more than once in the filters list.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST ensure that no OID appears more than once in the filters list.""
    }
  },
  {
    ""section"": ""4.2.5.. Handshake Protocol_Extensions_OID Filters"",
    ""title"": ""OID Uniqueness and Matching Rules"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST assert all key usage bits in the request that are also in the Key Usage certificate extension.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST verify that all key usage bits asserted in the request are present in the Key Usage certificate extension.""
    }
  },
  {
    ""section"": ""4.2.5.. Handshake Protocol_Extensions_OID Filters"",
    ""title"": ""OID Uniqueness and Matching Rules"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST assert all key purpose OIDs present in the request that are found in the Extended Key Usage certificate extension.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST check that all key purpose OIDs in the request are present in the Extended Key Usage certificate extension.""
    }
  },
  {
    ""section"": ""4.2.5.. Handshake Protocol_Extensions_OID Filters"",
    ""title"": ""OID Uniqueness and Matching Rules"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST NOT use the anyExtendedKeyUsage OID in the request.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST reject requests using the anyExtendedKeyUsage OID.""
    }
  }
]"""
37,4.2.7.. Handshake Protocol_Extensions_Supported Groups,Server Behavior with Supported Groups,"As of TLS 1.3, servers are permitted to send the ""supported_groups"" extension to the client. Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections. If the server has a group it prefers to the ones in the ""key_share"" extension but is still willing to accept the ClientHello, it SHOULD send ""supported_groups"" to update the client's view of its preferences; this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client.","""[
  {
    ""section"": ""4.2.7.. Handshake Protocol_Extensions_Supported Groups"",
    ""title"": ""Server Behavior with Supported Groups"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST send the \""supported_groups\"" extension to the client, containing all groups supported by the server.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST NOT act upon the information in \""supported_groups\"" until the handshake is successfully completed.""
    }
  },
  {
    ""section"": ""4.2.7.. Handshake Protocol_Extensions_Supported Groups"",
    ""title"": ""Server Behavior with Supported Groups"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""If the server prefers a group not present in the \""key_share\"" extension but is willing to accept the ClientHello, it SHOULD send the \""supported_groups\"" extension.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MAY use the information from a successfully completed handshake to adjust the groups used in the \""key_share\"" extension for future connections.""
    }
  }
]"""
38,4.2.8.. Handshake Protocol_Extensions_Key Share,Client Shares Description,"client_shares: A list of offered KeyShareEntry values in descending order of client preference. This vector MAY be empty if the client is requesting a HelloRetryRequest. Each KeyShareEntry value MUST correspond to a group offered in the ""supported_groups"" extension and MUST appear in the same order.","""[
  {
    ""section"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""Client Shares Description"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST offer KeyShareEntry values corresponding to groups in the 'supported_groups' extension, listed in descending order of preference. The client_shares vector MAY be empty if requesting a HelloRetryRequest.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST validate that each KeyShareEntry corresponds to a group in the 'supported_groups' extension and appears in the correct order.""
    }
  }
]"""
39,4.2.8.. Handshake Protocol_Extensions_Key Share,KeyShare Entry Rules,"Clients can offer as many KeyShareEntry values as the number of supported groups it is offering, each representing a single set of key exchange parameters. Clients MUST NOT offer multiple KeyShareEntry values for the same group and MUST NOT offer any for groups not listed in the client's ""supported_groups"" extension. Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated.","""[
  {
    ""section"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""KeyShare Entry Rules"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST offer KeyShareEntry values only for groups listed in the 'supported_groups' extension and MUST NOT offer multiple KeyShareEntry values for the same group.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MAY check for violations of KeyShareEntry rules and abort the handshake with an 'illegal_parameter' alert if any rule is violated.""
    }
  }
]"""
40,4.2.8.. Handshake Protocol_Extensions_Key Share,Selected Group Verification,"Upon receipt of this extension in a HelloRetryRequest, the client MUST verify that (1) the selected_group field corresponds to a group provided in the ""supported_groups"" extension in the original ClientHello and (2) the selected_group field does not correspond to a group provided in the ""key_share"" extension in the original ClientHello. If either check fails, the client MUST abort the handshake with an ""illegal_parameter"" alert.","""[
  {
    ""section"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""Selected Group Verification"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST verify that the selected_group field in HelloRetryRequest corresponds to a group in the 'supported_groups' extension of the original ClientHello and does not correspond to a group in the 'key_share' extension of the original ClientHello.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST ensure that clients abort the handshake with an 'illegal_parameter' alert if the selected_group verification fails.""
    }
  }
]"""
41,4.2.8.. Handshake Protocol_Extensions_Key Share,Server Share Requirements,"If using (EC)DHE key establishment, servers offer exactly one KeyShareEntry in the ServerHello. This value MUST be in the same group as the KeyShareEntry value offered by the client that the server has selected for the negotiated key exchange. Servers MUST NOT send a KeyShareEntry for any group not indicated in the client's ""supported_groups"" extension and MUST NOT send a KeyShareEntry when using the ""psk_ke"" PskKeyExchangeMode.","""[
  {
    ""section"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""Server Share Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST offer exactly one KeyShareEntry in the ServerHello, which MUST be in the same group as the KeyShareEntry offered by the client.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST validate that the KeyShareEntry in ServerHello matches the group of their offered KeyShareEntry.""
    }
  },
  {
    ""section"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""Server Share Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST NOT send a KeyShareEntry for any group not indicated in the client's 'supported_groups' extension.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST reject ServerHello messages that include a KeyShareEntry for unsupported groups.""
    }
  },
  {
    ""section"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""Server Share Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST NOT send a KeyShareEntry when using the 'psk_ke' PskKeyExchangeMode.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST ensure that no KeyShareEntry is present when 'psk_ke' is used.""
    }
  }
]"""
42,4.2.8.. Handshake Protocol_Extensions_Key Share,Verification of Selected NamedGroup,"If using (EC)DHE key establishment and a HelloRetryRequest containing a ""key_share"" extension was received by the client, the client MUST verify that the selected NamedGroup in the ServerHello is the same as that in the HelloRetryRequest. If this check fails, the client MUST abort the handshake with an ""illegal_parameter"" alert.","""[
  {
    ""section"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""Verification of Selected NamedGroup"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST verify that the selected NamedGroup in the ServerHello matches the NamedGroup in the HelloRetryRequest when using (EC)DHE key establishment.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST ensure that the NamedGroup selection is consistent between the HelloRetryRequest and ServerHello.""
    }
  },
  {
    ""section"": ""4.2.8.. Handshake Protocol_Extensions_Key Share"",
    ""title"": ""Verification of Selected NamedGroup"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""If the NamedGroup verification fails, the client MUST abort the handshake and send an 'illegal_parameter' alert.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Servers should be prepared to handle ClientHello messages that may lead to an 'illegal_parameter' alert due to NamedGroup mismatch.""
    }
  }
]"""
43,4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters,Public Key Validation,Peers MUST validate each other's public key Y by ensuring that 1 < Y < p-1. This check ensures that the remote peer is properly behaved and isn't forcing the local system into a small subgroup.,"""[
  {
    ""section"": ""4.2.8.1.. Handshake Protocol_Extensions_Key Share_Diffie-Hellman Parameters"",
    ""title"": ""Public Key Validation"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST validate that their own public key Y satisfies the condition 1 < Y < p-1.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST also validate that the public key Y of the remote peer satisfies the condition 1 < Y < p-1.""
    }
  }
]"""
44,4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters,Public Value Validation,"For the curves secp256r1, secp384r1, and secp521r1, peers MUST validate each other's public value Q by ensuring that the point is a valid point on the elliptic curve. The validation process consists of three steps:
1. Verify that Q is not the point at infinity (O).
2. Verify that both integers x and y are in the correct interval for Q = (x, y).
3. Ensure that (x, y) is a correct solution to the elliptic curve equation.
Implementors do not need to verify membership in the correct subgroup.","""[
  {
    ""section"": ""4.2.8.2.. Handshake Protocol_Extensions_Key Share_ECDHE Parameters"",
    ""title"": ""Public Value Validation"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Peers MUST validate each other's public value Q by ensuring Q is a valid point on the elliptic curve, specifically checking that Q is not the point at infinity, that both integers x and y are within the correct interval, and that (x, y) satisfies the elliptic curve equation.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST verify the public value Q following the specified steps: ensuring Q is not the point at infinity, confirming x and y are in the correct interval, and checking that (x, y) satisfies the elliptic curve equation.""
    }
  }
]"""
45,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,PSK Key Exchange Modes Extension Overview,"In order to use PSKs, clients MUST also send a ""psk_key_exchange_modes"" extension. The semantics of this extension are that the client only supports the use of PSKs with these modes, which restricts both the use of PSKs offered in this ClientHello and those which the server might supply via NewSessionTicket.","""[
  {
    ""section"": ""4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes"",
    ""title"": ""PSK Key Exchange Modes Extension Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST send a 'psk_key_exchange_modes' extension to indicate the supported modes for PSK usage.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST interpret the 'psk_key_exchange_modes' extension to restrict PSK options based on the client's capabilities.""
    }
  }
]"""
46,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Client Requirements for PSK Extensions,"A client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension. If clients offer ""pre_shared_key"" without a ""psk_key_exchange_modes"" extension, servers MUST abort the handshake. Servers MUST NOT select a key exchange mode that is not listed by the client. This extension also restricts the modes for use with PSK resumption. Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes; however, if a server does so, the impact will just be that the client's attempts at resumption fail.","""[
  {
    ""section"": ""4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes"",
    ""title"": ""Client Requirements for PSK Extensions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST provide a 'psk_key_exchange_modes' extension if they offer a 'pre_shared_key' extension.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST abort the handshake if clients offer 'pre_shared_key' without a 'psk_key_exchange_modes' extension.""
    }
  },
  {
    ""section"": ""4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes"",
    ""title"": ""Client Requirements for PSK Extensions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST ensure that the key exchange mode offered is compatible with the modes advertised.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST NOT select a key exchange mode that is not listed by the client.""
    }
  },
  {
    ""section"": ""4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes"",
    ""title"": ""Client Requirements for PSK Extensions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 0,
      ""construction_base"": ""Clients SHOULD be aware that if a server sends NewSessionTicket with incompatible tickets, the client's attempts at resumption may fail.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes.""
    }
  }
]"""
47,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Server Restrictions on PSK Extensions,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.","""[
  {
    ""section"": ""4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes"",
    ""title"": ""Server Restrictions on PSK Extensions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST NOT send a \""psk_key_exchange_modes\"" extension.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 0,
      ""processing_base"": ""Clients should be aware that servers do not send a \""psk_key_exchange_modes\"" extension.""
    }
  }
]"""
48,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Key Exchange Mode Descriptions,"1. psk_ke: PSK-only key establishment. In this mode, the server MUST NOT supply a ""key_share"" value.

2. psk_dhe_ke: PSK with (EC)DHE key establishment. In this mode, the client and server MUST supply ""key_share"" values as described in Section 4.2.8.","""[
  {
    ""section"": ""4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes"",
    ""title"": ""Key Exchange Mode Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""In the psk_ke mode, the server MUST NOT supply a 'key_share' value.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST not expect a 'key_share' value from the server in psk_ke mode.""
    }
  },
  {
    ""section"": ""4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes"",
    ""title"": ""Key Exchange Mode Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""In the psk_dhe_ke mode, both the client and server MUST supply 'key_share' values.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST provide 'key_share' values in psk_dhe_ke mode as specified in Section 4.2.8.""
    }
  }
]"""
49,4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes,Future Key Exchange Modes,"Any future values that are allocated must ensure that the transmitted protocol messages unambiguously identify which mode was selected by the server; at present, this is indicated by the presence of the ""key_share"" in the ServerHello.","""[
  {
    ""section"": ""4.2.9.. Handshake Protocol_Extensions_Pre-Shared Key Exchange Modes"",
    ""title"": ""Future Key Exchange Modes"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST ensure that any future values allocated in protocol messages clearly indicate the selected mode.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST indicate the selected mode in ServerHello by including the \""key_share\"" extension.""
    }
  }
]"""
50,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Early Data Indication Overview,"When a PSK is used and early data is allowed for that PSK, the client can send Application Data in its first flight of messages. If the client opts to do so, it MUST supply both the ""pre_shared_key"" and ""early_data"" extensions.","""[
  {
    ""section"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Early Data Indication Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST supply both the \""pre_shared_key\"" and \""early_data\"" extensions when using PSK with early data.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 0,
      ""processing_base"": ""Servers must handle the early data if both extensions are provided, but no specific requirement is detailed.""
    }
  }
]"""
51,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Parameters for 0-RTT Data,"The parameters for the 0-RTT data (version, symmetric cipher suite, Application-Layer Protocol Negotiation (ALPN) [RFC7301] protocol, etc.) are those associated with the PSK in use. For externally provisioned PSKs, the associated values are those provisioned along with the key. For PSKs established via a NewSessionTicket message, the associated values are those which were negotiated in the connection which established the PSK. The PSK used to encrypt the early data MUST be the first PSK listed in the client's ""pre_shared_key"" extension.","""[
  {
    ""section"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Parameters for 0-RTT Data"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST use the first PSK listed in the 'pre_shared_key' extension to encrypt early data.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST validate that the PSK used to encrypt early data is the first PSK listed in the client's 'pre_shared_key' extension.""
    }
  }
]"""
52,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Server Validation of PSK Ticket Age,"For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued. If it is not, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.","""[
  {
    ""section"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Server Validation of PSK Ticket Age"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST validate that the ticket age for the selected PSK identity is within a small tolerance of the time since the ticket was issued.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""If the ticket age is not valid, servers SHOULD proceed with the handshake but reject 0-RTT and SHOULD NOT assume the ClientHello is fresh.""
    }
  }
]"""
53,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Server Response to Early Data Extension,"A server which receives an ""early_data"" extension MUST behave in one of three ways:

- Ignore the extension and return a regular 1-RTT response. The server then skips past early data by attempting to deprotect received records using the handshake traffic key, discarding records which fail deprotection (up to the configured max_early_data_size). Once a record is deprotected successfully, it is treated as the start of the client's second flight and the server proceeds as with an ordinary 1-RTT handshake.

- Request that the client send another ClientHello by responding with a HelloRetryRequest. A client MUST NOT include the ""early_data"" extension in its followup ClientHello. The server then ignores early data by skipping all records with an external content type of ""application_data"" (indicating that they are encrypted), up to the configured max_early_data_size.

- Return its own ""early_data"" extension in EncryptedExtensions, indicating that it intends to process the early data. It is not possible for the server to accept only a subset of the early data messages.","""[
  {
    ""section"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Server Response to Early Data Extension"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST behave in one of three ways upon receiving an 'early_data' extension: ignore it and process as normal 1-RTT, request a new ClientHello, or return their own 'early_data' extension in EncryptedExtensions.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST skip early data records that fail deprotection using the handshake traffic key, up to max_early_data_size, and should handle responses based on the chosen behavior.""
    }
  },
  {
    ""section"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Server Response to Early Data Extension"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""If the server responds with a HelloRetryRequest, the client MUST NOT include the 'early_data' extension in the follow-up ClientHello.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST ignore all early data records with an external content type of 'application_data' during the HelloRetryRequest process.""
    }
  },
  {
    ""section"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Server Response to Early Data Extension"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""If the server intends to process early data, it MUST include its own 'early_data' extension in the EncryptedExtensions message.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""The server MUST NOT accept only a subset of the early data messages; all messages must be processed if the 'early_data' extension is acknowledged.""
    }
  }
]"""
54,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Requirements for Accepting Early Data,"In order to accept early data, the server MUST have accepted a PSK cipher suite and selected the first key offered in the client's ""pre_shared_key"" extension. In addition, it MUST verify that the following values are the same as those associated with the selected PSK:

- The TLS version number
- The selected cipher suite
- The selected ALPN [RFC7301] protocol, if any

These requirements are a superset of those needed to perform a 1-RTT handshake using the PSK in question.","""[
  {
    ""section"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Requirements for Accepting Early Data"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The server MUST accept a PSK cipher suite and select the first key offered in the client's 'pre_shared_key' extension to accept early data.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""The server MUST verify that the TLS version number, selected cipher suite, and selected ALPN protocol match those associated with the selected PSK.""
    }
  },
  {
    ""section"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Requirements for Accepting Early Data"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""These requirements are a superset of those needed to perform a 1-RTT handshake using the PSK.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""No specific processing rules defined for this superset requirement.""
    }
  }
]"""
55,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Error Handling for Early Data,"If any of the checks fail, the server MUST NOT respond with the extension and must discard all the first-flight data using one of the first two mechanisms listed above (thus falling back to 1-RTT or 2-RTT). If the client attempts a 0-RTT handshake but the server rejects it, the server will generally not have the 0-RTT record protection keys and must instead use trial decryption to find the first non-0-RTT message.","""[
  {
    ""section"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Error Handling for Early Data"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST handle the case where the server rejects a 0-RTT handshake by ensuring that no 0-RTT records are sent if the server does not support them.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST NOT respond with the extension if any checks fail and MUST discard all first-flight data, falling back to 1-RTT or 2-RTT.""
    }
  },
  {
    ""section"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Error Handling for Early Data"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST expect that if the server rejects the 0-RTT handshake, it will not have the 0-RTT record protection keys.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST use trial decryption to find the first non-0-RTT message when rejecting 0-RTT handshakes.""
    }
  }
]"""
56,4.2.10.. Handshake Protocol_Extensions_Early Data Indication,Error Handling Requirements,"If the server chooses to accept the ""early_data"" extension, then it MUST comply with the same error-handling requirements specified for all records when processing early data records. Specifically, if the server fails to decrypt a 0-RTT record following an accepted ""early_data"" extension, it MUST terminate the connection with a ""bad_record_mac"" alert as per Section 5.2.","""[
  {
    ""section"": ""4.2.10.. Handshake Protocol_Extensions_Early Data Indication"",
    ""title"": ""Error Handling Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""If the server accepts the 'early_data' extension, it MUST comply with error-handling requirements for processing early data records.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""If the server fails to decrypt a 0-RTT record, it MUST terminate the connection with a 'bad_record_mac' alert.""
    }
  }
]"""
57,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Field Descriptions,"1. identity: A label for a key, such as a ticket or a label for a pre-shared key established externally.

2. obfuscated_ticket_age: An obfuscated version of the age of the key. For identities established via the NewSessionTicket message, this is formed as described in Section 4.2.11.1. For externally established identities, an obfuscated_ticket_age of 0 SHOULD be used, and servers MUST ignore the value.

3. identities: A list of identities the client is willing to negotiate with the server. If sent alongside the ""early_data"" extension, the first identity is used for 0-RTT data.

4. binders: A series of HMAC values, one for each value in the identities list, computed as described below.

5. selected_identity: The server's chosen identity expressed as a (0-based) index into the identities in the client's list.","""[
  {
    ""section"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST provide a label for a key, which can be a ticket or a pre-shared key label.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST recognize and utilize the identity label provided by the client.""
    }
  },
  {
    ""section"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients SHOULD use an obfuscated_ticket_age of 0 for externally established identities, which servers MUST ignore.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST ignore the obfuscated_ticket_age value when it is 0.""
    }
  },
  {
    ""section"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST send a list of identities they are willing to negotiate, using the first identity for 0-RTT data if 'early_data' is also sent.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST select the first identity from the identities list for processing 0-RTT data if the 'early_data' extension is present.""
    }
  },
  {
    ""section"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST provide binders as HMAC values for each identity in the identities list.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST validate the binders against the identities provided.""
    }
  },
  {
    ""section"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST indicate the server's chosen identity as a (0-based) index into the identities list.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST confirm the selected_identity index corresponds to an identity in the client's list.""
    }
  }
]"""
58,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,PSK Hash Algorithm,"Each PSK is associated with a single Hash algorithm. For PSKs established via the ticket mechanism, this is the KDF Hash algorithm on the connection where the ticket was established. For externally established PSKs, the Hash algorithm MUST be set when the PSK is established or default to SHA-256 if no such algorithm is defined. The server MUST ensure that it selects a compatible PSK (if any) and cipher suite.","""[
  {
    ""section"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""PSK Hash Algorithm"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Externally established PSKs MUST have the Hash algorithm set during establishment or default to SHA-256 if no algorithm is defined.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""The server MUST ensure that it selects a compatible PSK and cipher suite.""
    }
  },
  {
    ""section"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""PSK Hash Algorithm"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""For PSKs established via the ticket mechanism, the Hash algorithm is the KDF Hash algorithm from the connection where the ticket was established.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Servers use the KDF Hash algorithm from the connection for PSKs established via the ticket mechanism.""
    }
  }
]"""
59,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Binder Validation,"Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value. If this value is not present or does not validate, the server MUST abort the handshake. Servers SHOULD select a single PSK and validate solely the binder corresponding to that PSK.","""[
  {
    ""section"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Binder Validation"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST ensure the binder value is present and valid before accepting PSK key establishment.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""If the binder value is missing or invalid, the server MUST abort the handshake.""
    }
  },
  {
    ""section"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Binder Validation"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers SHOULD select a single PSK and validate only the corresponding binder for that PSK.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST validate solely the binder associated with the selected PSK.""
    }
  }
]"""
60,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Client Verification,"Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server ""key_share"" extension is present if required by the ClientHello ""psk_key_exchange_modes"" extension. If these values are not consistent, the client MUST abort the handshake with an ""illegal_parameter"" alert.","""[
  {
    ""section"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Client Verification"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST verify that the selected_identity is within the supplied range, that the selected cipher suite indicates a Hash associated with the PSK, and that a server 'key_share' extension is present if required by the 'psk_key_exchange_modes' extension.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST ensure the selected_identity, cipher suite, and 'key_share' extension are consistent with the ClientHello parameters.""
    }
  },
  {
    ""section"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Client Verification"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST abort the handshake with an 'illegal_parameter' alert if the verification of the selected_identity, cipher suite, or 'key_share' extension fails.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST handle the 'illegal_parameter' alert appropriately, ensuring the handshake is terminated correctly.""
    }
  }
]"""
61,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Early Data Handling,"If the server supplies an ""early_data"" extension, the client MUST verify that the server's selected_identity is 0. If any other value is returned, the client MUST abort the handshake with an ""illegal_parameter"" alert.","""[
  {
    ""section"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Early Data Handling"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST verify that the server's selected_identity is 0 if the server supplies an \""early_data\"" extension.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""If the server supplies an \""early_data\"" extension, it must ensure the selected_identity is set appropriately.""
    }
  },
  {
    ""section"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Early Data Handling"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST abort the handshake with an \""illegal_parameter\"" alert if any value other than 0 is returned for selected_identity.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Servers must ensure proper handling of selected_identity values to avoid handshake failures.""
    }
  }
]"""
62,4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension,Extension Positioning,"The ""pre_shared_key"" extension MUST be the last extension in the ClientHello. Servers MUST check that it is the last extension and otherwise fail the handshake with an ""illegal_parameter"" alert.","""[
  {
    ""section"": ""4.2.11.. Handshake Protocol_Extensions_Pre-Shared Key Extension"",
    ""title"": ""Extension Positioning"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST place the \""pre_shared_key\"" extension last in the ClientHello.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST check that the \""pre_shared_key\"" extension is the last extension in ClientHello and fail the handshake with an \""illegal_parameter\"" alert if it is not.""
    }
  }
]"""
63,4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age,Client Ticket Age Handling,"The client's view of the age of a ticket is the time since the receipt of the NewSessionTicket message. Clients MUST NOT attempt to use tickets which have ages greater than the ""ticket_lifetime"" value provided with the ticket.","""[
  {
    ""section"": ""4.2.11.1.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Ticket Age"",
    ""title"": ""Client Ticket Age Handling"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST consider the ticket age as the time since receiving the NewSessionTicket message and MUST NOT use tickets with ages greater than the 'ticket_lifetime' value.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers must ensure that clients do not use tickets exceeding the specified 'ticket_lifetime' during session resumption.""
    }
  }
]"""
64,4.2.11.3.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Processing Order,0-RTT Data Streaming and Processing Order,"Clients are permitted to ""stream"" 0-RTT data until they receive the server's Finished message. Only after this should they send the EndOfEarlyData message, followed by the remainder of the handshake. To avoid deadlocks, when accepting early data, servers MUST process the client's ClientHello and then immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending its ServerHello.","""[
  {
    ""section"": ""4.2.11.3.. Handshake Protocol_Extensions_Pre-Shared Key Extension_Processing Order"",
    ""title"": ""0-RTT Data Streaming and Processing Order"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients are permitted to stream 0-RTT data until they receive the server's Finished message. They must send the EndOfEarlyData message after receiving this.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST process the client's ClientHello and immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending its ServerHello.""
    }
  }
]"""
65,4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,EncryptedExtensions Message Overview,"In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message. This is the first message that is encrypted under keys derived from the server_handshake_traffic_secret.","""[
  {
    ""section"": ""4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions"",
    ""title"": ""EncryptedExtensions Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST send the EncryptedExtensions message immediately after the ServerHello message.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST expect to receive the EncryptedExtensions message immediately following the ServerHello.""
    }
  }
]"""
66,4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions,Purpose of EncryptedExtensions,"The EncryptedExtensions message contains extensions that can be protected, i.e., any which are not needed to establish the cryptographic context but which are not associated with individual certificates. The client MUST check EncryptedExtensions for the presence of any forbidden extensions and if any are found MUST abort the handshake with an ""illegal_parameter"" alert.","""[
  {
    ""section"": ""4.3.1.. Handshake Protocol_Server Parameters_Encrypted Extensions"",
    ""title"": ""Purpose of EncryptedExtensions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST check the EncryptedExtensions message for forbidden extensions.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""If forbidden extensions are found in the EncryptedExtensions message, clients MUST abort the handshake with an 'illegal_parameter' alert.""
    }
  }
]"""
67,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,CertificateRequest Message Overview,"A server which is authenticating with a certificate MAY optionally request a certificate from the client. This message, if sent, MUST follow EncryptedExtensions.","""[
  {
    ""section"": ""4.3.2.. Handshake Protocol_Server Parameters_Certificate Request"",
    ""title"": ""CertificateRequest Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MAY optionally request a certificate from the client, and this request MUST follow the EncryptedExtensions message.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Clients may respond to a certificate request if one is received after the EncryptedExtensions.""
    }
  }
]"""
68,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Field Descriptions,"1. certificate_request_context: An opaque string which identifies the certificate request and will be echoed in the client's Certificate message. This context MUST be unique within the scope of the connection to prevent replay of client CertificateVerify messages. This field SHALL be zero length unless used for post-handshake authentication exchanges described in Section 4.6.2. When requesting post-handshake authentication, the server SHOULD make the context unpredictable to the client to prevent pre-computation of valid CertificateVerify messages by an attacker.

2. extensions: A set of extensions describing the parameters of the certificate being requested. The ""signature_algorithms"" extension MUST be specified, and other extensions may optionally be included if defined for this message. Clients MUST ignore unrecognized extensions.","""[
  {
    ""section"": ""4.3.2.. Handshake Protocol_Server Parameters_Certificate Request"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The server MUST ensure that 'certificate_request_context' is unique within the connection scope to prevent replay of client CertificateVerify messages.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Clients MUST verify that 'certificate_request_context' is unique and should respond accordingly to avoid replay attacks.""
    }
  },
  {
    ""section"": ""4.3.2.. Handshake Protocol_Server Parameters_Certificate Request"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The 'signature_algorithms' extension MUST be specified in the certificate request, and other extensions MAY be included if defined.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Clients MUST ignore any unrecognized extensions in the certificate request.""
    }
  },
  {
    ""section"": ""4.3.2.. Handshake Protocol_Server Parameters_Certificate Request"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""When requesting post-handshake authentication, the server SHOULD make 'certificate_request_context' unpredictable to prevent pre-computation of valid CertificateVerify messages.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Clients SHOULD be prepared to handle unpredictable 'certificate_request_context' values when post-handshake authentication is requested.""
    }
  }
]"""
69,4.3.2.. Handshake Protocol_Server Parameters_Certificate Request,Restrictions for PSK Authentication,"Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6).","""[
  {
    ""section"": ""4.3.2.. Handshake Protocol_Server Parameters_Certificate Request"",
    ""title"": ""Restrictions for PSK Authentication"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST NOT send the CertificateRequest message in the main handshake when authenticating with a PSK.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Clients do not expect a CertificateRequest during the main handshake when PSK is being used.""
    }
  },
  {
    ""section"": ""4.3.2.. Handshake Protocol_Server Parameters_Certificate Request"",
    ""title"": ""Restrictions for PSK Authentication"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 0,
      ""construction_base"": ""Servers MAY send the CertificateRequest message in post-handshake authentication if the client has sent the 'post_handshake_auth' extension.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Clients may receive a CertificateRequest in post-handshake authentication if they have sent the 'post_handshake_auth' extension.""
    }
  }
]"""
70,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate Message Overview,"This message conveys the endpoint's certificate chain to the peer. The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK). The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2). If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the ""certificate_list"" field having length 0). A Finished message MUST be sent regardless of whether the Certificate message is empty.","""[
  {
    ""section"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Certificate Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The server MUST send a Certificate message when using a key exchange method that requires certificates for authentication, excluding PSK.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""The client MUST send a Certificate message only if the server has requested client authentication via a CertificateRequest message.""
    }
  },
  {
    ""section"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Certificate Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message with an empty certificate_list.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""The server MUST accept a Certificate message with an empty certificate_list when the client has no certificates.""
    }
  },
  {
    ""section"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Certificate Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""A Finished message MUST be sent by both parties regardless of whether the Certificate message is empty.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""The server MUST send a Finished message after processing the Certificate message.""
    }
  }
]"""
71,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Field Descriptions,"1. **certificate_request_context**: If this message is in response to a CertificateRequest, the value of certificate_request_context in that message. Otherwise (in the case of server authentication), this field SHALL be zero length.

2. **certificate_list**: A sequence (chain) of CertificateEntry structures, each containing a single certificate and set of extensions.

3. **extensions**: A set of extension values for the CertificateEntry. Valid extensions for server certificates include the OCSP Status extension [RFC6066] and the SignedCertificateTimestamp extension [RFC6962]. Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message, and those from the client MUST correspond to the CertificateRequest message from the server.","""[
  {
    ""section"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The server's Certificate message MUST include the certificate_request_context if responding to a CertificateRequest; otherwise, it SHALL be of zero length.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST ensure that the certificate_request_context is correctly handled based on the type of response received.""
    }
  },
  {
    ""section"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The server's Certificate message MUST contain a sequence of CertificateEntry structures in the certificate_list.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST process the certificate_list, which contains the chain of certificates presented by the server.""
    }
  },
  {
    ""section"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The server's Certificate message MUST include valid extensions for each CertificateEntry, such as OCSP Status and SignedCertificateTimestamp.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST verify that the extensions in the server's Certificate message correspond to those in the ClientHello.""
    }
  }
]"""
72,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Certificate Chain Requirements,"If the corresponding certificate type extension (""server_certificate_type"" or ""client_certificate_type"") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate. The sender's certificate MUST come in the first CertificateEntry in the list. Each following certificate SHOULD directly certify the one immediately preceding it. A certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates.","""[
  {
    ""section"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Certificate Chain Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST/SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Each CertificateEntry MUST contain a DER-encoded X.509 certificate if negotiated. The sender's certificate MUST be the first CertificateEntry in the list.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST verify that the first CertificateEntry is the sender's certificate and each following certificate SHOULD directly certify the one immediately preceding it.""
    }
  },
  {
    ""section"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Certificate Chain Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST/SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""A certificate that specifies a trust anchor MAY be omitted from the chain if supported peers are known to possess any omitted certificates.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST account for potentially omitted trust anchor certificates when validating the certificate chain.""
    }
  }
]"""
73,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Handling Certificate List Ordering,"Prior to TLS 1.3, ""certificate_list"" ordering required each certificate to certify the one immediately preceding it; however, some implementations allowed flexibility. For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first.","""[
  {
    ""section"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Handling Certificate List Ordering"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, but the end-entity certificate MUST be first.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST ensure that the end-entity certificate is the first in the certificate_list.""
    }
  }
]"""
74,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,RawPublicKey Certificate Type,"If the RawPublicKey certificate type was negotiated, then the certificate_list MUST contain no more than one CertificateEntry, which contains an ASN1_subjectPublicKeyInfo value as defined in [RFC7250], Section 3.","""[
  {
    ""section"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""RawPublicKey Certificate Type"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""If the RawPublicKey certificate type is negotiated, the certificate_list MUST contain no more than one CertificateEntry.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST validate that the certificate_list contains at most one CertificateEntry with an ASN1_subjectPublicKeyInfo value.""
    }
  }
]"""
75,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,OpenPGP Certificate Type,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,"""[
  {
    ""section"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""OpenPGP Certificate Type"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST NOT use the OpenPGP certificate type with TLS 1.3.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST reject any authentication message that includes the OpenPGP certificate type.""
    }
  }
]"""
76,4.4.2.. Handshake Protocol_Authentication Messages_Certificate,Server Certificate List Requirement,The server's certificate_list MUST always be non-empty. A client will send an empty certificate_list if it does not have an appropriate certificate to send in response to the server's authentication request.,"""[
  {
    ""section"": ""4.4.2.. Handshake Protocol_Authentication Messages_Certificate"",
    ""title"": ""Server Certificate List Requirement"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The server's certificate_list MUST always be non-empty.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Clients will send an empty certificate_list if they do not have an appropriate certificate to respond to the server's authentication request.""
    }
  }
]"""
77,4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,OCSP Status Extension in TLS 1.3,"In TLS 1.3, the server's OCSP information is carried in an extension within the CertificateEntry that contains the associated certificate. The body of the 'status_request' extension from the server MUST be a CertificateStatus structure as defined in [RFC6066], which is interpreted according to [RFC6960].","""[
  {
    ""section"": ""4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions"",
    ""title"": ""OCSP Status Extension in TLS 1.3"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The server MUST include the OCSP information in a 'status_request' extension within the CertificateEntry associated with the certificate.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""The 'status_request' extension body MUST be a CertificateStatus structure defined in [RFC6066] and interpreted according to [RFC6960].""
    }
  }
]"""
78,4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,Deprecation of status_request_v2 Extension,"The status_request_v2 extension [RFC6961] is deprecated. TLS 1.3 servers MUST NOT act upon its presence or the information contained within it when processing ClientHello messages. Specifically, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. However, TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients wishing to use it in earlier protocol versions.","""[
  {
    ""section"": ""4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions"",
    ""title"": ""Deprecation of status_request_v2 Extension"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MAY include the status_request_v2 extension in ClientHello messages, but it is deprecated.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST NOT act upon the presence of the status_request_v2 extension in ClientHello messages and MUST NOT include it in EncryptedExtensions, CertificateRequest, or Certificate messages.""
    }
  },
  {
    ""section"": ""4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions"",
    ""title"": ""Deprecation of status_request_v2 Extension"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MAY send the status_request_v2 extension in ClientHello, intending to use it with earlier TLS versions.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST be able to process ClientHello messages that include the deprecated status_request_v2 extension.""
    }
  }
]"""
79,4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions,Client OCSP Response Request,"A server MAY request that a client present an OCSP response with its certificate by sending an empty 'status_request' extension in its CertificateRequest message. If the client opts to send an OCSP response, the body of its 'status_request' extension MUST be a CertificateStatus structure as defined in [RFC6066].","""[
  {
    ""section"": ""4.4.2.1.. Handshake Protocol_Authentication Messages_Certificate_OCSP Status and SCT Extensions"",
    ""title"": ""Client OCSP Response Request"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MAY send an OCSP response if a server requests it via an empty 'status_request' extension in the CertificateRequest message. If sent, the body of the 'status_request' extension MUST be a CertificateStatus structure as defined in [RFC6066].""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST process the 'status_request' extension and validate the CertificateStatus structure if the client opts to send an OCSP response.""
    }
  }
]"""
80,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Certificate Selection Rules,"The following rules apply to the certificates sent by the server:

- The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).

- The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension (currently RSA, ECDSA, or EdDSA).

- The certificate MUST allow the key to be used for signing (i.e., the digitalSignature bit MUST be set if the Key Usage extension is present) with a signature scheme indicated in the client's ""signature_algorithms""/""signature_algorithms_cert"" extensions (see Section 4.2.3).

- The ""server_name"" [RFC6066] and ""certificate_authorities"" extensions are used to guide certificate selection. As servers MAY require the presence of the ""server_name"" extension, clients SHOULD send this extension when applicable.","""[
  {
    ""section"": ""4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection"",
    ""title"": ""Certificate Selection Rules"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST send certificates of type X.509v3 unless negotiated otherwise. The server's end-entity certificate's public key MUST be compatible with the selected authentication algorithm from the client's \""signature_algorithms\"" extension.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients SHOULD include the \""server_name\"" extension to assist in certificate selection when applicable.""
    }
  },
  {
    ""section"": ""4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection"",
    ""title"": ""Certificate Selection Rules"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The server's end-entity certificate MUST allow the key to be used for signing, with the digitalSignature bit set if the Key Usage extension is present and a signature scheme indicated in the client's \""signature_algorithms\""/\""signature_algorithms_cert\"" extensions.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Clients MUST ensure that the certificate received allows for the indicated signing capabilities.""
    }
  },
  {
    ""section"": ""4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection"",
    ""title"": ""Certificate Selection Rules"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 0,
      ""construction_base"": ""Servers MAY require the presence of the \""server_name\"" extension for certificate selection.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients SHOULD send the \""server_name\"" extension when applicable to guide certificate selection.""
    }
  }
]"""
81,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Certificate Chain Signing Requirements,All certificates provided by the server MUST be signed by a signature algorithm advertised by the client if it is able to provide such a chain (see Section 4.2.3). Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.,"""[
  {
    ""section"": ""4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection"",
    ""title"": ""Certificate Chain Signing Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST provide certificates signed by a signature algorithm that the client has advertised, if the client is able to provide such a chain.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST verify that the server's certificate chain is signed by an algorithm they support.""
    }
  },
  {
    ""section"": ""4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection"",
    ""title"": ""Certificate Chain Signing Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Self-signed certificates or trust anchor certificates MAY be signed with any algorithm.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Clients MAY accept self-signed or trust anchor certificates without validation against the advertised algorithms.""
    }
  }
]"""
82,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Fallback Certificate Chain Handling,"If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then it SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms that are not known to be supported by the client. This fallback chain SHOULD NOT use the deprecated SHA-1 hash algorithm in general, but MAY do so if the client's advertisement permits it, and MUST NOT do so otherwise.","""[
  {
    ""section"": ""4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection"",
    ""title"": ""Fallback Certificate Chain Handling"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers SHOULD send a certificate chain of their choice if they cannot produce a chain signed only via the indicated supported algorithms.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Clients MUST check the received certificate chain for compatibility with the supported algorithms.""
    }
  },
  {
    ""section"": ""4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection"",
    ""title"": ""Fallback Certificate Chain Handling"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Fallback chains SHOULD NOT use the deprecated SHA-1 hash algorithm in general, but MAY do so if permitted by the client's advertisement.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Clients MUST reject fallback chains that use SHA-1 if their advertisement does not permit it.""
    }
  }
]"""
83,4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection,Client Handling of Certificate Chains,"If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then it MUST abort the handshake with an appropriate certificate-related alert (by default, ""unsupported_certificate""; see Section 6.2 for more information).","""[
  {
    ""section"": ""4.4.2.2.. Handshake Protocol_Authentication Messages_Certificate_Server Certificate Selection"",
    ""title"": ""Client Handling of Certificate Chains"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST construct an acceptable chain using provided certificates or decide to abort the handshake.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""If the client aborts the handshake, it MUST send an appropriate certificate-related alert, defaulting to 'unsupported_certificate'.""
    }
  }
]"""
84,4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection,Client Certificate Selection Rules,"The following rules apply to certificates sent by the client:

- The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).

- If the ""certificate_authorities"" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.

- The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2. Note that this relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.

- If the CertificateRequest message contained a non-empty ""oid_filters"" extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client, as described in Section 4.2.5.","""[
  {
    ""section"": ""4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection"",
    ""title"": ""Client Certificate Selection Rules"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST send certificates of type X.509v3 unless explicitly negotiated otherwise.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST validate that the client certificate is of type X.509v3 unless a different type has been negotiated.""
    }
  },
  {
    ""section"": ""4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection"",
    ""title"": ""Client Certificate Selection Rules"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""If the \""certificate_authorities\"" extension in the CertificateRequest message is present, at least one certificate in the chain SHOULD be issued by one of the listed CAs.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers SHOULD check that at least one certificate in the chain is issued by one of the CAs listed in the \""certificate_authorities\"" extension.""
    }
  },
  {
    ""section"": ""4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection"",
    ""title"": ""Client Certificate Selection Rules"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST ensure that certificates are signed using an acceptable signature algorithm as specified in Section 4.3.2.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST verify that the signature algorithm used to sign the certificates is acceptable as defined in Section 4.3.2.""
    }
  },
  {
    ""section"": ""4.4.2.3.. Handshake Protocol_Authentication Messages_Certificate_Client Certificate Selection"",
    ""title"": ""Client Certificate Selection Rules"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""If the CertificateRequest message contains a non-empty \""oid_filters\"" extension, the end-entity certificate MUST match the recognized OIDs.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST check that the end-entity certificate matches the OIDs specified in the \""oid_filters\"" extension.""
    }
  }
]"""
85,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Server Certificate Handling,"If the server supplies an empty Certificate message, the client MUST abort the handshake with a ""decode_error"" alert.","""[
  {
    ""section"": ""4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message"",
    ""title"": ""Server Certificate Handling"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST abort the handshake if the server supplies an empty Certificate message.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST ensure that they do not send an empty Certificate message to avoid client handshake abort.""
    }
  }
]"""
86,4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message,Signature Algorithm Restrictions,"Any endpoint receiving any certificate which it would need to validate using any signature algorithm using an MD5 hash MUST abort the handshake with a ""bad_certificate"" alert. SHA-1 is deprecated, and it is RECOMMENDED that any endpoint receiving any certificate which it would need to validate using any signature algorithm using a SHA-1 hash abort the handshake with a ""bad_certificate"" alert. For clarity, this means that endpoints can accept these algorithms for certificates that are self-signed or are trust anchors.","""[
  {
    ""section"": ""4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message"",
    ""title"": ""Signature Algorithm Restrictions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Endpoints MUST abort the handshake with a \""bad_certificate\"" alert if they receive a certificate requiring validation using an MD5 hash.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST reject any certificate using MD5 for validation with a \""bad_certificate\"" alert.""
    }
  },
  {
    ""section"": ""4.4.2.4.. Handshake Protocol_Authentication Messages_Certificate_Receiving a Certificate Message"",
    ""title"": ""Signature Algorithm Restrictions"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""It is RECOMMENDED that endpoints abort the handshake with a \""bad_certificate\"" alert if they receive a certificate requiring validation using a SHA-1 hash.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers are RECOMMENDED to reject certificates validated using SHA-1 with a \""bad_certificate\"" alert.""
    }
  }
]"""
87,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,CertificateVerify Message Overview,"This message is used to provide explicit proof that an endpoint possesses the private key corresponding to its certificate. The CertificateVerify message also provides integrity for the handshake up to this point. Servers MUST send this message when authenticating via a certificate. Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty). When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.","""[
  {
    ""section"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""CertificateVerify Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST/SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients and servers MUST send a CertificateVerify message when authenticating via a certificate. This message MUST appear immediately after the Certificate message and immediately prior to the Finished message.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC/CLI-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST send a CertificateVerify message when authenticating via a certificate, and clients MUST send this message when the Certificate message is non-empty.""
    }
  }
]"""
88,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Algorithm Requirements,"If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's ""signature_algorithms"" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3). If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the ""signature_algorithms"" extension in the CertificateRequest message.","""[
  {
    ""section"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""Signature Algorithm Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's \""signature_algorithms\"" extension unless no valid certificate chain can be produced without unsupported algorithms.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Clients MUST validate that the signature algorithm used in the CertificateVerify message is one of those present in the supported_signature_algorithms field of the \""signature_algorithms\"" extension in the CertificateRequest message.""
    }
  },
  {
    ""section"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""Signature Algorithm Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""If the CertificateVerify message is sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the \""signature_algorithms\"" extension in the CertificateRequest message.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST validate that the signature algorithm used in the client's CertificateVerify message corresponds to the supported signature algorithms from the client's CertificateRequest.""
    }
  }
]"""
89,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Algorithm Compatibility,"The signature algorithm MUST be compatible with the key in the sender's end-entity certificate. RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in ""signature_algorithms"". The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.","""[
  {
    ""section"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""Signature Algorithm Compatibility"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The signature algorithm MUST be compatible with the key in the sender's end-entity certificate.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST verify that the signature algorithm used is compatible with the key in the sender's end-entity certificate.""
    }
  },
  {
    ""section"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""Signature Algorithm Compatibility"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""RSA signatures MUST use an RSASSA-PSS algorithm, regardless of the presence of RSASSA-PKCS1-v1_5 algorithms in 'signature_algorithms'.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST ensure that RSA signatures use the RSASSA-PSS algorithm.""
    }
  },
  {
    ""section"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""Signature Algorithm Compatibility"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST reject CertificateVerify messages that use the SHA-1 algorithm in signatures.""
    }
  }
]"""
90,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Signature Verification Process,"The receiver of a CertificateVerify message MUST verify the signature field. The verification process takes as input:

- The content covered by the digital signature
- The public key contained in the end-entity certificate found in the associated Certificate message
- The digital signature received in the signature field of the CertificateVerify message.","""[
  {
    ""section"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""Signature Verification Process"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The server MUST verify the signature field in the CertificateVerify message using the specified components.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""The verification process must use the content covered by the digital signature, the public key from the end-entity certificate, and the digital signature from the CertificateVerify message.""
    }
  }
]"""
91,4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify,Error Handling,"If the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert.","""[
  {
    ""section"": ""4.4.3.. Handshake Protocol_Authentication Messages_Certificate Verify"",
    ""title"": ""Error Handling"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The receiver MUST terminate the handshake if verification fails.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST send a \""decrypt_error\"" alert to terminate the handshake upon verification failure.""
    }
  }
]"""
92,4.4.4.. Handshake Protocol_Authentication Messages_Finished,Finished Message Overview,"The Finished message is the final message in the Authentication Block. It is essential for providing authentication of the handshake and of the computed keys. Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a ""decrypt_error"" alert.","""[
  {
    ""section"": ""4.4.4.. Handshake Protocol_Authentication Messages_Finished"",
    ""title"": ""Finished Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST ensure the Finished message is correctly constructed to provide authentication of the handshake and computed keys.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST verify the correctness of the Finished message contents and terminate the connection with a \""decrypt_error\"" alert if incorrect.""
    }
  }
]"""
93,4.4.4.. Handshake Protocol_Authentication Messages_Finished,Post-Finished Message Requirements,"Any records following a Finished message MUST be encrypted under the appropriate application traffic key as described in Section 7.2. In particular, this includes any alerts sent by the server in response to client Certificate and CertificateVerify messages.","""[
  {
    ""section"": ""4.4.4.. Handshake Protocol_Authentication Messages_Finished"",
    ""title"": ""Post-Finished Message Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST/SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Any records following a Finished message MUST be encrypted under the appropriate application traffic key.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC/CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST ensure that any alerts sent in response to client Certificate and CertificateVerify messages are encrypted under the appropriate application traffic key.""
    }
  }
]"""
94,4.5.. Handshake Protocol_End of Early Data,EndOfEarlyData Message Overview,"struct {} EndOfEarlyData;

If the server sent an ""early_data"" extension in EncryptedExtensions, the client MUST send an EndOfEarlyData message after receiving the server Finished. If the server does not send an ""early_data"" extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message. This message indicates that all 0-RTT application_data messages, if any, have been transmitted and that the following records are protected under handshake traffic keys.","""[
  {
    ""section"": ""4.5.. Handshake Protocol_End of Early Data"",
    ""title"": ""EndOfEarlyData Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST send an EndOfEarlyData message after receiving the server's Finished if the server sent an 'early_data' extension in EncryptedExtensions.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST ensure the EndOfEarlyData message is sent only if the 'early_data' extension was included in EncryptedExtensions.""
    }
  },
  {
    ""section"": ""4.5.. Handshake Protocol_End of Early Data"",
    ""title"": ""EndOfEarlyData Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST NOT send an EndOfEarlyData message if the server did not send an 'early_data' extension in EncryptedExtensions.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST reject any EndOfEarlyData messages received if the 'early_data' extension was not sent.""
    }
  }
]"""
95,4.5.. Handshake Protocol_End of Early Data,Message Handling Requirements,"Servers MUST NOT send this message, and clients receiving it MUST terminate the connection with an ""unexpected_message"" alert. This message is encrypted under keys derived from the client_early_traffic_secret.","""[
  {
    ""section"": ""4.5.. Handshake Protocol_End of Early Data"",
    ""title"": ""Message Handling Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST NOT send this message.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients receiving this message MUST terminate the connection with an 'unexpected_message' alert.""
    }
  },
  {
    ""section"": ""4.5.. Handshake Protocol_End of Early Data"",
    ""title"": ""Message Handling Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""This message is encrypted under keys derived from the client_early_traffic_secret.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Clients process this message as part of handling early data.""
    }
  }
]"""
96,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Ticket Resumption Requirements,"Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection. Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session. If such an indication is provided (externally or by any other means), clients MAY resume with a different SNI value.","""[
  {
    ""section"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""Ticket Resumption Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST only attempt to resume a session with a cipher suite that uses the same KDF hash algorithm as the original connection.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST verify that the cipher suite used for resumption matches the KDF hash algorithm of the original session.""
    }
  },
  {
    ""section"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""Ticket Resumption Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST ensure the new SNI value is valid for the certificate used in the original session.""
    }
  },
  {
    ""section"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""Ticket Resumption Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 0,
      ""construction_base"": ""Clients SHOULD only resume if the SNI value matches the one used in the original session.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Servers SHOULD prefer to validate that the SNI value matches the original session's SNI.""
    }
  },
  {
    ""section"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""Ticket Resumption Requirements"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 0,
      ""construction_base"": ""Clients MAY resume with a different SNI value if indicated externally or by other means.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Servers MAY accept a session resume with a different SNI value if appropriately indicated.""
    }
  }
]"""
97,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,SNI Value Reporting,"On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session. Note that if a server implementation declines all PSK identities with different SNI values, these two values are always the same.","""[
  {
    ""section"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""SNI Value Reporting"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST use the SNI value sent in the resumption ClientHello when reporting to the calling application.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST ensure that the SNI value reported corresponds to the value sent in the resumption ClientHello.""
    }
  },
  {
    ""section"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""SNI Value Reporting"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 0,
      ""construction_base"": ""If all PSK identities with different SNI values are declined, both SNI values must be the same.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Servers must ensure consistency between the SNI values when all PSK identities are declined.""
    }
  }
]"""
98,4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message,Field Descriptions,"1. ticket_lifetime: Indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance. Servers MUST NOT use any value greater than 604800 seconds (7 days). The value of zero indicates that the ticket should be discarded immediately.

2. ticket_age_add: A securely generated, random 32-bit value that obscures the age of the ticket included in the ""pre_shared_key"" extension. The server MUST generate a fresh value for each ticket it sends.

3. ticket_nonce: A per-ticket value that is unique across all tickets issued on this connection.

4. ticket: The value of the ticket to be used as the PSK identity. It MAY be either a database lookup key or a self-encrypted and self-authenticated value.

5. extensions: A set of extension values for the ticket. Clients MUST ignore unrecognized extensions.","""[
  {
    ""section"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST specify a ticket_lifetime as a 32-bit unsigned integer, not exceeding 604800 seconds, with a value of zero indicating immediate ticket discard.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST discard tickets with a ticket_lifetime of zero.""
    }
  },
  {
    ""section"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST generate a fresh ticket_age_add value for each ticket, which is a securely generated random 32-bit value.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Clients process the ticket_age_add but do not validate its freshness.""
    }
  },
  {
    ""section"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST assign a unique ticket_nonce for each ticket issued on the connection.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Clients utilize the ticket_nonce but do not perform validation checks.""
    }
  },
  {
    ""section"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 0,
      ""construction_base"": ""Servers MAY use the ticket value as either a database key or a self-encrypted and self-authenticated value.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Clients MAY use the ticket value as a PSK identity but do not require specific validation.""
    }
  },
  {
    ""section"": ""4.6.1.. Handshake Protocol_Post-Handshake Messages_New Session Ticket Message"",
    ""title"": ""Field Descriptions"",
    ""message_construction"": {
      ""construction_rule_type"": ""SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Servers MUST include extension values for the ticket, and clients MUST ignore any unrecognized extensions.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Clients MUST ignore any unrecognized extensions present in the New Session Ticket message.""
    }
  }
]"""
99,4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Post-Handshake Authentication Overview,"When the client has sent the ""post_handshake_auth"" extension, a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message. The client MUST respond with the appropriate Authentication messages. If the client chooses to authenticate, it MUST send Certificate, CertificateVerify, and Finished. If it declines, it MUST send a Certificate message containing no certificates followed by Finished. All of the client's messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.","""[
  {
    ""section"": ""4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication"",
    ""title"": ""Post-Handshake Authentication Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST respond to a CertificateRequest with appropriate Authentication messages, including Certificate, CertificateVerify, and Finished if they choose to authenticate.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MAY request client authentication at any time after the handshake completion by sending a CertificateRequest message.""
    }
  },
  {
    ""section"": ""4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication"",
    ""title"": ""Post-Handshake Authentication Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""If the client declines to authenticate, it MUST send a Certificate message containing no certificates followed by Finished.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Servers MUST ensure that all of the client's messages for a given response appear consecutively on the wire with no intervening messages of other types.""
    }
  }
]"""
100,4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,CertificateRequest Handling,"A client that receives a CertificateRequest message without having sent the ""post_handshake_auth"" extension MUST send an ""unexpected_message"" fatal alert.","""[
  {
    ""section"": ""4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication"",
    ""title"": ""CertificateRequest Handling"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MUST send an 'unexpected_message' fatal alert if they receive a CertificateRequest message without having sent the 'post_handshake_auth' extension.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Servers sending a CertificateRequest must ensure that clients can handle the request appropriately based on the 'post_handshake_auth' extension.""
    }
  }
]"""
101,4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication,Client Response Timing Considerations,"Because client authentication could involve prompting the user, servers MUST be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response. In addition, clients which receive multiple CertificateRequests in close succession MAY respond to them in a different order than they were received, as the certificate_request_context value allows the server to disambiguate the responses.","""[
  {
    ""section"": ""4.6.2.. Handshake Protocol_Post-Handshake Messages_Post-Handshake Authentication"",
    ""title"": ""Client Response Timing Considerations"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Clients MAY respond to multiple CertificateRequests in a different order than they were received.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Servers MUST be prepared for delays and the possibility of receiving other messages between sending the CertificateRequest and receiving a response.""
    }
  }
]"""
102,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,KeyUpdate Message Overview,"The KeyUpdate handshake message is used to indicate that the sender is updating its sending cryptographic keys. This message can be sent by either peer after it has sent a Finished message. Implementations that receive a KeyUpdate message prior to receiving a Finished message MUST terminate the connection with an 'unexpected_message' alert. After sending a KeyUpdate message, the sender SHALL send all its traffic using the next generation of keys, computed as described in Section 7.2. Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.","""[
  {
    ""section"": ""4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"",
    ""title"": ""KeyUpdate Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST/SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The sender MUST indicate key updates using the KeyUpdate handshake message after sending a Finished message.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC/SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Receivers MUST terminate the connection with an 'unexpected_message' alert if a KeyUpdate message is received before a Finished message.""
    }
  },
  {
    ""section"": ""4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"",
    ""title"": ""KeyUpdate Message Overview"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST/SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""After sending a KeyUpdate message, the sender SHALL use the newly computed keys for all subsequent traffic.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""CLI-MSG-PROC/SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""Upon receiving a KeyUpdate message, the receiver MUST update its receiving keys.""
    }
  }
]"""
103,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,request_update Field Description,"The request_update field indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate. If an implementation receives any other value, it MUST terminate the connection with an 'illegal_parameter' alert.","""[
  {
    ""section"": ""4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"",
    ""title"": ""request_update Field Description"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The request_update field indicates whether the recipient should respond with its own KeyUpdate.""
    },
    ""message_processing"": {
      ""processing_rule_type"": ""SRV-MSG-PROC"",
      ""processing_explicitness"": 1,
      ""processing_base"": ""If an implementation receives any value other than the expected value, it MUST terminate the connection with an 'illegal_parameter' alert.""
    }
  }
]"""
104,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,KeyUpdate Response Mechanism,"If the request_update field is set to 'update_requested', then the receiver MUST send a KeyUpdate of its own with request_update set to 'update_not_requested' prior to sending its next Application Data record. This mechanism allows either side to force an update to the entire connection, but causes an implementation which receives multiple KeyUpdates while it is silent to respond with a single update.","""[
  {
    ""section"": ""4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"",
    ""title"": ""KeyUpdate Response Mechanism"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST/SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""If the request_update field is set to 'update_requested', the sender MUST prepare to send a KeyUpdate with request_update set to 'update_not_requested' before sending the next Application Data record.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC/CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""The receiver MUST send a KeyUpdate in response to 'update_requested' prior to sending its next Application Data record.""
    }
  },
  {
    ""section"": ""4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"",
    ""title"": ""KeyUpdate Response Mechanism"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST/SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""The mechanism allows either side to force an update to the entire connection.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""SRV-MSG-PROC/CLI-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""If multiple KeyUpdates are received while silent, the implementation MUST respond with a single update.""
    }
  }
]"""
105,4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update,Encryption and KeyUpdate Order,"Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys. Additionally, both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key. Failure to do so may allow message truncation attacks.","""[
  {
    ""section"": ""4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"",
    ""title"": ""Encryption and KeyUpdate Order"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST/SRV-MSG-CONST"",
      ""construction_explicitness"": 1,
      ""construction_base"": ""Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC/SRV-MSG-PROC"",
      ""processing_explicitness"": 1, 
      ""processing_base"": ""Both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key.""
    }
  },
  {
    ""section"": ""4.6.3.. Handshake Protocol_Post-Handshake Messages_Key and Initialization Vector Update"",
    ""title"": ""Encryption and KeyUpdate Order"",
    ""message_construction"": {
      ""construction_rule_type"": ""CLI-MSG-CONST/SRV-MSG-CONST"",
      ""construction_explicitness"": 0,
      ""construction_base"": ""Failure to enforce the order of KeyUpdate messages may allow message truncation attacks.""
    },
    ""message_processing"": { 
      ""processing_rule_type"": ""CLI-MSG-PROC/SRV-MSG-PROC"",
      ""processing_explicitness"": 0, 
      ""processing_base"": ""Systems should mitigate the risk of message truncation attacks by following the KeyUpdate order.""
    }
  }
]"""
