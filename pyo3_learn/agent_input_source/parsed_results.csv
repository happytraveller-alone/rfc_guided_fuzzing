index,section_name,title,content
1,4.. Handshake Protocol,Handshake Protocol Overview,"The handshake protocol is used to negotiate the security parameters of a connection. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext or TLSCiphertext structures which are processed and transmitted as specified by the current active connection state."
2,4.. Handshake Protocol,Handshake Message Types Enumeration,"enum {
    client_hello(1),
    server_hello(2),
    new_session_ticket(4),
    end_of_early_data(5),
    encrypted_extensions(8),
    certificate(11),
    certificate_request(13),
    certificate_verify(15),
    finished(20),
    key_update(24),
    message_hash(254),
    (255)
} HandshakeType;"
3,4.. Handshake Protocol,Handshake Message Structure,"struct {
    HandshakeType msg_type;    /* handshake type */
    uint24 length;             /* remaining bytes in message */
    select (Handshake.msg_type) {
        case client_hello:          ClientHello;
        case server_hello:          ServerHello;
        case end_of_early_data:     EndOfEarlyData;
        case encrypted_extensions:  EncryptedExtensions;
        case certificate_request:   CertificateRequest;
        case certificate:           Certificate;
        case certificate_verify:    CertificateVerify;
        case finished:              Finished;
        case new_session_ticket:    NewSessionTicket;
        case key_update:            KeyUpdate;
    };
} Handshake;"
4,4.. Handshake Protocol,Message Order Requirements,"Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2. A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert."
5,4.. Handshake Protocol,IANA Message Type Assignments,New handshake message types are assigned by IANA as described in Section 11.
6,4.1.. Handshake Protocol_Key Exchange Messages,Key Exchange Messages Overview,"The key exchange messages are used to determine the security capabilities of the client and the server and to establish shared secrets, including the traffic keys used to protect the rest of the handshake and the data."
7,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Cryptographic Negotiation Overview,"In TLS, the cryptographic negotiation proceeds by the client offering the following four sets of options in its ClientHello:

- A list of cipher suites which indicates the AEAD algorithm/HKDF hash pairs which the client supports.

- A ""supported_groups"" (Section 4.2.7) extension which indicates the (EC)DHE groups which the client supports and a ""key_share"" (Section 4.2.8) extension which contains (EC)DHE shares for some or all of these groups.

- A ""signature_algorithms"" (Section 4.2.3) extension which indicates the signature algorithms which the client can accept. A ""signature_algorithms_cert"" extension (Section 4.2.3) may also be added to indicate certificate-specific signature algorithms.

- A ""pre_shared_key"" (Section 4.2.11) extension which contains a list of symmetric key identities known to the client and a ""psk_key_exchange_modes"" (Section 4.2.9) extension which indicates the key exchange modes that may be used with PSKs."
8,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Server Parameter Selection,"If the server does not select a PSK, then the first three of these options are entirely orthogonal: the server independently selects a cipher suite, an (EC)DHE group and key share for key establishment, and a signature algorithm/certificate pair to authenticate itself to the client. If there is no overlap between the received ""supported_groups"" and the groups supported by the server, then the server MUST abort the handshake with a ""handshake_failure"" or an ""insufficient_security"" alert."
9,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,PSK Selection and Key Establishment Modes,"If the server selects a PSK, then it MUST also select a key establishment mode from the set indicated by the client's ""psk_key_exchange_modes"" extension (at present, PSK alone or with (EC)DHE). Note that if the PSK can be used without (EC)DHE, then non-overlap in the ""supported_groups"" parameters need not be fatal, as it is in the non-PSK case discussed in the previous paragraph."
10,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,HelloRetryRequest Requirement,"If the server selects an (EC)DHE group and the client did not offer a compatible ""key_share"" extension in the initial ClientHello, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message."
11,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Parameters Indication in ServerHello,"If the server successfully selects parameters and does not require a HelloRetryRequest, it indicates the selected parameters in the ServerHello as follows:

- If PSK is being used, then the server will send a ""pre_shared_key"" extension indicating the selected key.

- When (EC)DHE is in use, the server will also provide a ""key_share"" extension. If PSK is not being used, then (EC)DHE and certificate-based authentication are always used.

- When authenticating via a certificate, the server will send the Certificate (Section 4.4.2) and CertificateVerify (Section 4.4.3) messages. In TLS 1.3 as defined by this document, either a PSK or a certificate is always used, but not both. Future documents may define how to use them together."
12,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Abort Conditions,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6)."
13,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,ClientHello Purpose,"When a client first connects to a server, it is REQUIRED to send the ClientHello as its first TLS message. The client will also send a ClientHello when the server has responded to its ClientHello with a HelloRetryRequest."
14,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,ClientHello Modifications After HelloRetryRequest,"In case of a HelloRetryRequest, the client MUST send the same ClientHello without modification, except as follows: - If a 'key_share' extension was supplied in the HelloRetryRequest, replace the list of shares with a single KeyShareEntry from the indicated group. - Remove the 'early_data' extension if present. Early data is not permitted after a HelloRetryRequest. - Include a 'cookie' extension if provided in the HelloRetryRequest. - Update the 'pre_shared_key' extension by recomputing the 'obfuscated_ticket_age' and binder values, and optionally remove incompatible PSKs. - Optionally add, remove, or change the length of the 'padding' extension. - Other modifications allowed by future extensions present in the HelloRetryRequest."
15,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Connection Termination Conditions,"Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an 'unexpected_message' alert. If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version and MUST NOT negotiate TLS 1.3."
16,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Structure Definition,Structure of this message: uint16 ProtocolVersion; opaque Random[32]; uint8 CipherSuite[2]; struct { ProtocolVersion legacy_version = 0x0303; /* TLS v1.2 */ Random random; opaque legacy_session_id<0..32>; CipherSuite cipher_suites<2..2^16-2>; opaque legacy_compression_methods<1..2^8-1>; Extension extensions<8..2^16-1>; } ClientHello;
17,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Legacy Version Field,"In previous versions of TLS, this field was used for version negotiation and represented the highest version number supported by the client. In TLS 1.3, the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2."
18,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Random Field Requirements,The random field consists of 32 bytes generated by a secure random number generator. See Appendix C for additional information.
19,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Legacy Session ID,"A client which has a cached session ID set by a pre-TLS 1.3 server SHOULD set this field to that value. In compatibility mode, this field MUST be non-empty, so a client not offering a pre-TLS 1.3 session MUST generate a new 32-byte value."
20,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Cipher Suites,"The cipher_suites field lists the symmetric cipher options supported by the client. If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites."
21,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Legacy Compression Methods,"For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the 'null' compression method. If a TLS 1.3 ClientHello is received with any other value, the server MUST abort the handshake with an 'illegal_parameter' alert."
22,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Extensions Field,"Clients request extended functionality from servers by sending data in the extensions field. In TLS 1.3, the use of certain extensions is mandatory, as functionality has moved into extensions."
23,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Client Behavior After ClientHello,"After sending the ClientHello message, the client waits for a ServerHello or HelloRetryRequest message. If early data is in use, the client may transmit early Application Data while waiting for the next handshake message."
24,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,ServerHello Purpose,The server will send this message in response to a ClientHello message to proceed with the handshake if it is able to negotiate an acceptable set of handshake parameters based on the ClientHello.
25,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Structure Definition,"struct {
    ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
    Random random;
    opaque legacy_session_id_echo<0..32>;
    CipherSuite cipher_suite;
    uint8 legacy_compression_method = 0;
    Extension extensions<6..2^16-1>;
} ServerHello;"
26,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Legacy Version Field,"In previous versions of TLS, this field was used for version negotiation and represented the selected version number for the connection. Unfortunately, some middleboxes fail when presented with new values. In TLS 1.3, the TLS server indicates its version using the ""supported_versions"" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2. (See Appendix D for details about backward compatibility.)"
27,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Random Field Requirements,"32 bytes generated by a secure random number generator. The last 8 bytes MUST be overwritten as described below if negotiating TLS 1.2 or TLS 1.1, but the remaining bytes MUST be random. This structure is generated by the server and MUST be generated independently of the ClientHello.random."
28,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Session ID Echo Requirements,"The contents of the client's legacy_session_id field. Note that this field is echoed even if the client's value corresponded to a cached pre-TLS 1.3 session which the server has chosen not to resume. A client which receives a legacy_session_id_echo field that does not match what it sent in the ClientHello MUST abort the handshake with an ""illegal_parameter"" alert."
29,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Cipher Suite Selection,"The single cipher suite selected by the server from the list in ClientHello.cipher_suites. A client which receives a cipher suite that was not offered MUST abort the handshake with an ""illegal_parameter"" alert."
30,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Extensions Requirements,"A list of extensions. The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version. All TLS 1.3 ServerHello messages MUST contain the ""supported_versions"" extension. Current ServerHello messages additionally contain either the ""pre_shared_key"" extension or the ""key_share"" extension, or both (when using a PSK with (EC)DHE key establishment). Other extensions (see Section 4.2) are sent separately in the EncryptedExtensions message."
31,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,HelloRetryRequest Special Case,"For reasons of backward compatibility with middleboxes, the HelloRetryRequest message uses the same structure as the ServerHello, but with Random set to the special value of the SHA-256 of ""HelloRetryRequest"": CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91 C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C. Upon receiving a message with type server_hello, implementations MUST first examine the Random value and, if it matches this value, process it as described in Section 4.1.4."
32,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Downgrade Protection Mechanism,TLS 1.3 has a downgrade protection mechanism embedded in the server's random value. TLS 1.3 servers which negotiate TLS 1.2 or below in response to a ClientHello MUST set the last 8 bytes of their Random value specially in their ServerHello.
33,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Downgrade Values Specifics,"If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of their Random value to the bytes: 44 4F 57 4E 47 52 44 01. If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes: 44 4F 57 4E 47 52 44 00."
34,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Client Verification Responsibilities,"TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values. If a match is found, the client MUST abort the handshake with an ""illegal_parameter"" alert. This mechanism provides limited protection against downgrade attacks over and above what is provided by the Finished exchange."
35,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Legacy Client Renegotiation,"A legacy TLS client performing renegotiation with TLS 1.2 or prior and which receives a TLS 1.3 ServerHello during renegotiation MUST abort the handshake with a ""protocol_version"" alert. Note that renegotiation is not possible when TLS 1.3 has been negotiated."
36,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,HelloRetryRequest Purpose,The server will send this message in response to a ClientHello message if it is able to find an acceptable set of parameters but the ClientHello does not contain sufficient information to proceed with the handshake.
37,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Message Structure Similarity,"As discussed in Section 4.1.3, the HelloRetryRequest has the same format as a ServerHello message, and the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields have the same meaning. However, for convenience, ""HelloRetryRequest"" is discussed throughout this document as if it were a distinct message."
38,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Required Extensions,"The server's extensions MUST contain ""supported_versions"". Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair. A HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the ""cookie"" extension."
39,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Client Response Requirements,"Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using ""supported_versions""."
40,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Handshake Abort Conditions,"Clients MUST abort the handshake with an ""illegal_parameter"" alert if the HelloRetryRequest would not result in any change in the ClientHello. If a client receives a second HelloRetryRequest in the same connection, it MUST abort the handshake with an ""unexpected_message"" alert."
41,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Extension Processing,"Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello. The HelloRetryRequest extensions defined in this specification are: - supported_versions (see Section 4.2.1) - cookie (see Section 4.2.2) - key_share (see Section 4.2.8)."
42,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Cipher Suite Negotiation,A client which receives a cipher suite that was not offered MUST abort the handshake. Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello.
43,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,ClientHello Update Requirements,"Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an ""illegal_parameter"" alert."
44,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Pre-Shared Key Considerations,"In its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite. This allows the client to avoid having to compute partial hash transcripts for multiple hashes in the second ClientHello."
45,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Version Retention,"The value of selected_version in the HelloRetryRequest ""supported_versions"" extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an ""illegal_parameter"" alert if the value changes."
46,4.2.. Handshake Protocol_Extensions,Extension Overview,A number of TLS messages contain tag-length-value encoded extensions structures.
47,4.2.. Handshake Protocol_Extensions,Extension Structure Definition,"struct {
    ExtensionType extension_type;
    opaque extension_data<0..2^16-1>;
} Extension;"
48,4.2.. Handshake Protocol_Extensions,Extension Types Enumeration,"enum {
    server_name(0),                             /* RFC 6066 */
    max_fragment_length(1),                     /* RFC 6066 */
    status_request(5),                          /* RFC 6066 */
    supported_groups(10),                       /* RFC 8422, 7919 */
    signature_algorithms(13),                   /* RFC 8446 */
    use_srtp(14),                               /* RFC 5764 */
    heartbeat(15),                              /* RFC 6520 */
    application_layer_protocol_negotiation(16), /* RFC 7301 */
    signed_certificate_timestamp(18),           /* RFC 6962 */
    client_certificate_type(19),                /* RFC 7250 */
    server_certificate_type(20),                /* RFC 7250 */
    padding(21),                                /* RFC 7685 */
    pre_shared_key(41),                         /* RFC 8446 */
    early_data(42),                             /* RFC 8446 */
    supported_versions(43),                     /* RFC 8446 */
    cookie(44),                                 /* RFC 8446 */
    psk_key_exchange_modes(45),                 /* RFC 8446 */
    certificate_authorities(47),                /* RFC 8446 */
    oid_filters(48),                            /* RFC 8446 */
    post_handshake_auth(49),                    /* RFC 8446 */
    signature_algorithms_cert(50),              /* RFC 8446 */
    key_share(51),                              /* RFC 8446 */
    (65535)
} ExtensionType;"
49,4.2.. Handshake Protocol_Extensions,Extension Fields,"- ""extension_type"" identifies the particular extension type.
- ""extension_data"" contains information specific to the particular extension type."
50,4.2.. Handshake Protocol_Extensions,IANA Extension Management,The list of extension types is maintained by IANA as described in Section 11.
51,4.2.. Handshake Protocol_Extensions,Extension Request/Response Structure,"Extensions are generally structured in a request/response fashion, though some extensions are just indications with no corresponding response. The client sends its extension requests in the ClientHello message, and the server sends its extension responses in the ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate messages."
52,4.2.. Handshake Protocol_Extensions,Server Extension Requests,"The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message. The server MAY also send unsolicited extensions in the NewSessionTicket, though the client does not respond directly to these."
53,4.2.. Handshake Protocol_Extensions,Extension Response Restrictions,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest. Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert."
54,4.2.. Handshake Protocol_Extensions,Extension Placement in Messages,"If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an ""illegal_parameter"" alert."
55,4.2.. Handshake Protocol_Extensions,Extension Message Compatibility Table,"The table below indicates the messages where a given extension may appear:

+--------------------------------------------------+-------------+
| Extension                                        |     TLS 1.3 |
+--------------------------------------------------+-------------+
| server_name [RFC6066]                            |      CH, EE |
| max_fragment_length [RFC6066]                    |      CH, EE |
| status_request [RFC6066]                         |  CH, CR, CT |
| supported_groups [RFC7919]                       |      CH, EE |
| signature_algorithms (RFC 8446)                  |      CH, CR |
| use_srtp [RFC5764]                               |      CH, EE |
| heartbeat [RFC6520]                              |      CH, EE |
| application_layer_protocol_negotiation [RFC7301] |      CH, EE |
| signed_certificate_timestamp [RFC6962]           |  CH, CR, CT |
| client_certificate_type [RFC7250]                |      CH, EE |
| server_certificate_type [RFC7250]                |      CH, EE |
| padding [RFC7685]                                |          CH |
| key_share (RFC 8446)                             | CH, SH, HRR |
| pre_shared_key (RFC 8446)                        |      CH, SH |
| psk_key_exchange_modes (RFC 8446)                |          CH |
| early_data (RFC 8446)                            | CH, EE, NST |
| cookie (RFC 8446)                                |     CH, HRR |
| supported_versions (RFC 8446)                    | CH, SH, HRR |
| certificate_authorities (RFC 8446)               |      CH, CR |
| oid_filters (RFC 8446)                           |          CR |
| post_handshake_auth (RFC 8446)                   |          CH |
| signature_algorithms_cert (RFC 8446)             |      CH, CR |
+--------------------------------------------------+-------------+"
56,4.2.. Handshake Protocol_Extensions,Extension Ordering Rules,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block). There MUST NOT be more than one extension of the same type in a given extension block."
57,4.2.. Handshake Protocol_Extensions,Negotiation and Resumption,"In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each handshake even when in resumption-PSK mode. However, 0-RTT parameters are those negotiated in the previous handshake; mismatches may require rejecting 0-RTT (see Section 4.2.10)."
58,4.2.. Handshake Protocol_Extensions,Security Considerations for Extensions,"There are subtle (and not so subtle) interactions that may occur in this protocol between new features and existing features which may result in a significant reduction in overall security. The following considerations should be taken into account when designing new extensions:

- Some cases where a server does not agree to an extension are error conditions, and some are simply refusals to support particular features. In general, error alerts should be used for the former and a field in the server extension response for the latter.

- Extensions should, as far as possible, be designed to prevent any attack that forces use (or non-use) of a particular feature by manipulation of handshake messages. This principle should be followed regardless of whether the feature is believed to cause a security problem."
59,4.2.. Handshake Protocol_Extensions,Extension Design Considerations,"Often the fact that the extension fields are included in the inputs to the Finished message hashes will be sufficient, but extreme care is needed when the extension changes the meaning of messages sent in the handshake phase. Designers and implementors should be aware of the fact that until the handshake has been authenticated, active attackers can modify messages and insert, remove, or replace extensions."
60,4.2.1.. Handshake Protocol_Extensions_Supported Versions,SupportedVersions Structure,"struct {
    select (Handshake.msg_type) {
        case client_hello:
            ProtocolVersion versions<2..254>;
        case server_hello: /* and HelloRetryRequest */
            ProtocolVersion selected_version;
    };
} SupportedVersions;"
61,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Purpose of the Supported Versions Extension,"The ""supported_versions"" extension is used by the client to indicate which versions of TLS it supports and by the server to indicate which version it is using. The extension contains a list of supported versions in preference order, with the most preferred version first."
62,4.2.1.. Handshake Protocol_Extensions_Supported Versions,ClientHello Requirements,"Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which they are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, they MUST be present as well)."
63,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Server Negotiation Behavior,"If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later."
64,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Version Negotiation with Supported Versions,"If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension."
65,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Compatibility with TLS Versions,Note that this mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.
66,4.2.1.. Handshake Protocol_Extensions_Supported Versions,ServerHello Behavior for Version Negotiation,"A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2)."
67,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Client Processing of ServerHello,"Clients MUST check for this extension prior to processing the rest of the ServerHello. If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version."
68,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Abort Conditions for Clients,"If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert."
69,4.2.2.. Handshake Protocol_Extensions_Cookie,Cookie Structure Definition,"struct {
    opaque cookie<1..2^16-1>;
} Cookie;"
70,4.2.2.. Handshake Protocol_Extensions_Cookie,Purpose of Cookies,"Cookies serve two primary purposes:
- Allowing the server to force the client to demonstrate reachability at their apparent network address, thus providing a measure of DoS protection. This is primarily useful for non-connection-oriented transports (see [RFC6347] for an example of this).
- Allowing the server to offload state to the client, allowing it to send a HelloRetryRequest without storing any state. The server can do this by storing the hash of the ClientHello in the HelloRetryRequest cookie, protected with some suitable integrity protection algorithm."
71,4.2.2.. Handshake Protocol_Extensions_Cookie,HelloRetryRequest Cookie Extension,"When sending a HelloRetryRequest, the server MAY provide a ""cookie"" extension to the client. This is an exception to the usual rule that only extensions appearing in the ClientHello may be sent. When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a ""cookie"" extension in the new ClientHello. Clients MUST NOT use cookies in their initial ClientHello in subsequent connections."
72,4.2.2.. Handshake Protocol_Extensions_Cookie,Stateless Server Behavior,"When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5). Since the server is not storing any state, this will appear as if it were the first message received. Servers operating statelessly MUST ignore these records."
73,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Algorithms Overview,"TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures. The ""signature_algorithms_cert"" extension applies to signatures in certificates, and the ""signature_algorithms"" extension applies to signatures in CertificateVerify messages. The keys found in certificates MUST also be of appropriate type for the signature algorithms they are used with, particularly for RSA keys and PSS signatures. If no ""signature_algorithms_cert"" extension is present, then the ""signature_algorithms"" extension also applies to signatures appearing in certificates."
74,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Client Requirements for Signature Algorithms,"Clients which desire the server to authenticate itself via a certificate MUST send the ""signature_algorithms"" extension. If a server is authenticating via a certificate and the client has not sent a ""signature_algorithms"" extension, then the server MUST abort the handshake with a ""missing_extension"" alert (see Section 9.2)."
75,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Purpose of the Signature Algorithms Extensions,"The ""signature_algorithms_cert"" extension was added to allow implementations which supported different sets of algorithms for certificates and in TLS itself to clearly signal their capabilities. TLS 1.2 implementations SHOULD also process this extension. Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension."
76,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,SignatureScheme Enumeration Definition,"enum { /* RSASSA-PKCS1-v1_5 algorithms */ rsa_pkcs1_sha256(0x0401), rsa_pkcs1_sha384(0x0501), rsa_pkcs1_sha512(0x0601), /* ECDSA algorithms */ ecdsa_secp256r1_sha256(0x0403), ecdsa_secp384r1_sha384(0x0503), ecdsa_secp521r1_sha512(0x0603), /* RSASSA-PSS algorithms with public key OID rsaEncryption */ rsa_pss_rsae_sha256(0x0804), rsa_pss_rsae_sha384(0x0805), rsa_pss_rsae_sha512(0x0806), /* EdDSA algorithms */ ed25519(0x0807), ed448(0x0808), /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */ rsa_pss_pss_sha256(0x0809), rsa_pss_pss_sha384(0x080a), rsa_pss_pss_sha512(0x080b), /* Legacy algorithms */ rsa_pkcs1_sha1(0x0201), ecdsa_sha1(0x0203), /* Reserved Code Points */ private_use(0xFE00..0xFFFF), (0xFFFF) } SignatureScheme;"
77,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,SignatureSchemeList Structure Definition,struct { SignatureScheme supported_signature_algorithms<2..2^16-2>; } SignatureSchemeList;
78,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Scheme Preferences,"Each SignatureScheme value lists a single signature algorithm that the client is willing to verify, indicated in descending order of preference. A signature algorithm takes as input an arbitrary-length message, rather than a digest. Algorithms which traditionally act on a digest should be defined in TLS to first hash the input with a specified hash algorithm and then proceed as usual."
79,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,RSASSA-PKCS1-v1_5 Algorithms,"Indicates a signature algorithm using RSASSA-PKCS1-v1_5 [RFC8017] with the corresponding hash algorithm as defined in [SHS]. These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2."
80,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,ECDSA Algorithms,"Indicates a signature algorithm using ECDSA [ECDSA], the corresponding curve as defined in ANSI X9.62 [ECDSA] and FIPS 186-4 [DSS], and the corresponding hash algorithm as defined in [SHS]. The signature is represented as a DER-encoded [X690] ECDSA-Sig-Value structure."
81,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,RSASSA-PSS RSAE Algorithms,Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST be equal to the length of the output of the digest algorithm.
82,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,EdDSA Algorithms,"Indicates a signature algorithm using EdDSA as defined in [RFC8032] or its successors. Note that these correspond to the ""PureEdDSA"" algorithms and not the ""prehash"" variants."
83,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,RSASSA-PSS PSS Algorithms,Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST be equal to the length of the digest algorithm.
84,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Legacy Algorithms,"Indicates algorithms which are being deprecated due to known weaknesses, specifically SHA-1 which is used in this context with either RSA using RSASSA-PKCS1-v1_5 or ECDSA. These values refer solely to signatures which appear in certificates and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2."
85,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Self-Signed Certificates and Trust Anchors,"The signatures on certificates that are self-signed or certificates that are trust anchors are not validated, since they begin a certification path. A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the ""signature_algorithms"" extension."
86,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Backward Compatibility with TLS 1.2,"Note that TLS 1.2 defines this extension differently. TLS 1.3 implementations willing to negotiate TLS 1.2 MUST behave in accordance with the requirements of [RFC5246] when negotiating that version. In particular, TLS 1.2 ClientHellos MAY omit this extension."
87,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Deprecated Signature Algorithms in TLS 1.2,"In TLS 1.2, the extension contained hash/signature pairs. These pairs are encoded in two octets, so SignatureScheme values have been allocated to align with TLS 1.2's encoding. Some legacy pairs are left unallocated. These algorithms are deprecated as of TLS 1.3 and MUST NOT be offered or negotiated by any implementation."
88,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,ECDSA Signature Schemes Compatibility,"ECDSA signature schemes align with TLS 1.2's ECDSA hash/signature pairs. However, the old semantics did not constrain the signing curve. If TLS 1.2 is negotiated, implementations MUST be prepared to accept a signature that uses any curve that they advertised in the ""supported_groups"" extension."
89,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,RSASSA-PSS Support in TLS 1.2,Implementations that advertise support for RSASSA-PSS (which is mandatory in TLS 1.3) MUST be prepared to accept a signature using that scheme even when TLS 1.2 is negotiated.
