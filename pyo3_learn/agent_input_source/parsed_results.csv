index,section_name,title,content
1,4.. Handshake Protocol,Handshake Protocol Overview,"The handshake protocol is used to negotiate the security parameters of a connection. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext or TLSCiphertext structures which are processed and transmitted as specified by the current active connection state."
2,4.. Handshake Protocol,Handshake Message Types Enumeration,"enum {
    client_hello(1),
    server_hello(2),
    new_session_ticket(4),
    end_of_early_data(5),
    encrypted_extensions(8),
    certificate(11),
    certificate_request(13),
    certificate_verify(15),
    finished(20),
    key_update(24),
    message_hash(254),
    (255)
} HandshakeType;"
3,4.. Handshake Protocol,Handshake Message Structure,"struct {
    HandshakeType msg_type;    /* handshake type */
    uint24 length;             /* remaining bytes in message */
    select (Handshake.msg_type) {
        case client_hello:          ClientHello;
        case server_hello:          ServerHello;
        case end_of_early_data:     EndOfEarlyData;
        case encrypted_extensions:  EncryptedExtensions;
        case certificate_request:   CertificateRequest;
        case certificate:           Certificate;
        case certificate_verify:    CertificateVerify;
        case finished:              Finished;
        case new_session_ticket:    NewSessionTicket;
        case key_update:            KeyUpdate;
    };
} Handshake;"
4,4.. Handshake Protocol,Message Order and Error Handling,"Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2. A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert."
5,4.. Handshake Protocol,IANA Message Type Assignments,New handshake message types are assigned by IANA as described in Section 11.
6,4.1.. Handshake Protocol_Key Exchange Messages,Purpose of Key Exchange Messages,"The key exchange messages are used to determine the security capabilities of the client and the server and to establish shared secrets, including the traffic keys used to protect the rest of the handshake and the data."
7,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Cryptographic Negotiation Overview,"In TLS, the cryptographic negotiation proceeds by the client offering the following four sets of options in its ClientHello:"
8,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Cipher Suites,- A list of cipher suites which indicates the AEAD algorithm/HKDF hash pairs which the client supports.
9,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Supported Groups and Key Share,"- A ""supported_groups"" (Section 4.2.7) extension which indicates the (EC)DHE groups which the client supports and a ""key_share"" (Section 4.2.8) extension which contains (EC)DHE shares for some or all of these groups."
10,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Signature Algorithms,"- A ""signature_algorithms"" (Section 4.2.3) extension which indicates the signature algorithms which the client can accept. A ""signature_algorithms_cert"" extension (Section 4.2.3) may also be added to indicate certificate-specific signature algorithms."
11,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Pre-Shared Key Extensions,"- A ""pre_shared_key"" (Section 4.2.11) extension which contains a list of symmetric key identities known to the client and a ""psk_key_exchange_modes"" (Section 4.2.9) extension which indicates the key exchange modes that may be used with PSKs."
12,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Non-PSK Negotiation,"If the server does not select a PSK, then the first three of these options are entirely orthogonal: the server independently selects a cipher suite, an (EC)DHE group and key share for key establishment, and a signature algorithm/certificate pair to authenticate itself to the client. If there is no overlap between the received ""supported_groups"" and the groups supported by the server, then the server MUST abort the handshake with a ""handshake_failure"" or an ""insufficient_security"" alert."
13,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,PSK Negotiation,"If the server selects a PSK, then it MUST also select a key establishment mode from the set indicated by the client's ""psk_key_exchange_modes"" extension (at present, PSK alone or with (EC)DHE). Note that if the PSK can be used without (EC)DHE, then non-overlap in the ""supported_groups"" parameters need not be fatal, as it is in the non-PSK case discussed in the previous paragraph."
14,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,HelloRetryRequest Response,"If the server selects an (EC)DHE group and the client did not offer a compatible ""key_share"" extension in the initial ClientHello, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message."
15,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,ServerHello Parameter Indication,"If the server successfully selects parameters and does not require a HelloRetryRequest, it indicates the selected parameters in the ServerHello as follows:"
16,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,PSK Selection in ServerHello,"- If PSK is being used, then the server will send a ""pre_shared_key"" extension indicating the selected key."
17,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Key Share in ServerHello,"- When (EC)DHE is in use, the server will also provide a ""key_share"" extension. If PSK is not being used, then (EC)DHE and certificate-based authentication are always used."
18,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Certificate Authentication,"- When authenticating via a certificate, the server will send the Certificate (Section 4.4.2) and CertificateVerify (Section 4.4.3) messages. In TLS 1.3 as defined by this document, either a PSK or a certificate is always used, but not both. Future documents may define how to use them together."
19,4.1.1.. Handshake Protocol_Key Exchange Messages_Cryptographic Negotiation,Handshake Failure Conditions,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6)."
20,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,ClientHello Purpose,"When a client first connects to a server, it is REQUIRED to send the ClientHello as its first TLS message. The client will also send a ClientHello when the server has responded to its ClientHello with a HelloRetryRequest."
21,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,ClientHello Modifications After HelloRetryRequest,"In the case of a HelloRetryRequest, the client MUST send the same ClientHello without modification, except as follows: - If a ""key_share"" extension was supplied in the HelloRetryRequest, replacing the list of shares with a list containing a single KeyShareEntry from the indicated group. - Removing the ""early_data"" extension if one was present. Early data is not permitted after a HelloRetryRequest. - Including a ""cookie"" extension if one was provided in the HelloRetryRequest. - Updating the ""pre_shared_key"" extension if present by recomputing the ""obfuscated_ticket_age"" and binder values and (optionally) removing any PSKs which are incompatible with the server's indicated cipher suite. - Optionally adding, removing, or changing the length of the ""padding"" extension. - Other modifications that may be allowed by an extension defined in the future and present in the HelloRetryRequest."
22,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Connection Termination Requirements,"Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an ""unexpected_message"" alert."
23,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Legacy TLS Version Retention,"If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version. In particular, it MUST NOT negotiate TLS 1.3."
24,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,ClientHello Message Structure,Structure of this message: uint16 ProtocolVersion; opaque Random[32]; uint8 CipherSuite[2]; struct { ProtocolVersion legacy_version = 0x0303; /* TLS v1.2 */ Random random; opaque legacy_session_id<0..32>; CipherSuite cipher_suites<2..2^16-2>; opaque legacy_compression_methods<1..2^8-1>; Extension extensions<8..2^16-1>; } ClientHello;
25,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Legacy Version Field,"In previous versions of TLS, this field was used for version negotiation and represented the highest version number supported by the client. In TLS 1.3, the client indicates its version preferences in the ""supported_versions"" extension, and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2."
26,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Random Field Requirements,random: 32 bytes generated by a secure random number generator. See Appendix C for additional information.
27,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Legacy Session ID,"legacy_session_id: Versions of TLS before TLS 1.3 supported a ""session resumption"" feature which has been merged with pre-shared keys in this version. A client with a cached session ID set by a pre-TLS 1.3 server SHOULD set this field to that value."
28,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Cipher Suites,"cipher_suites: A list of the symmetric cipher options supported by the client. If the list contains cipher suites that the server does not recognize or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual."
29,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Legacy Compression Methods,"legacy_compression_methods: This vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS. If a TLS 1.3 ClientHello is received with any other value, the server MUST abort the handshake with an ""illegal_parameter"" alert."
30,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Extensions,"extensions: Clients request extended functionality from servers by sending data in the extensions field. TLS 1.3 ClientHello messages always contain extensions, minimally the ""supported_versions"" extension."
31,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Handling ClientHello and Extensions,"TLS 1.3 servers will check for the presence of the ""supported_versions"" extension to negotiate TLS 1.3. If negotiating a version prior to 1.3, a server MUST check that the message either contains no data after legacy_compression_methods or that it contains a valid extensions block."
32,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Client Response to Unsupported Extensions,"In the event that a client requests additional functionality using extensions and this functionality is not supplied by the server, the client MAY abort the handshake."
33,4.1.2.. Handshake Protocol_Key Exchange Messages_Client Hello,Waiting for Server Response,"After sending the ClientHello message, the client waits for a ServerHello or HelloRetryRequest message."
34,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,ServerHello Purpose,The server will send this message in response to a ClientHello message to proceed with the handshake if it is able to negotiate an acceptable set of handshake parameters based on the ClientHello.
35,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Structure Definition,"struct {
    ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
    Random random;
    opaque legacy_session_id_echo<0..32>;
    CipherSuite cipher_suite;
    uint8 legacy_compression_method = 0;
    Extension extensions<6..2^16-1>;
} ServerHello;"
36,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Legacy Version Field,"In previous versions of TLS, this field was used for version negotiation and represented the selected version number for the connection. Unfortunately, some middleboxes fail when presented with new values. In TLS 1.3, the TLS server indicates its version using the ""supported_versions"" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2. (See Appendix D for details about backward compatibility.)"
37,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Random Field Requirements,"32 bytes generated by a secure random number generator. See Appendix C for additional information. The last 8 bytes MUST be overwritten as described below if negotiating TLS 1.2 or TLS 1.1, but the remaining bytes MUST be random. This structure is generated by the server and MUST be generated independently of the ClientHello.random."
38,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Session ID Echo Requirements,"The contents of the client's legacy_session_id field. Note that this field is echoed even if the client's value corresponded to a cached pre-TLS 1.3 session which the server has chosen not to resume. A client which receives a legacy_session_id_echo field that does not match what it sent in the ClientHello MUST abort the handshake with an ""illegal_parameter"" alert."
39,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Cipher Suite Selection,"The single cipher suite selected by the server from the list in ClientHello.cipher_suites. A client which receives a cipher suite that was not offered MUST abort the handshake with an ""illegal_parameter"" alert."
40,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Extensions Requirements,"A list of extensions. The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version. All TLS 1.3 ServerHello messages MUST contain the ""supported_versions"" extension. Current ServerHello messages additionally contain either the ""pre_shared_key"" extension or the ""key_share"" extension, or both (when using a PSK with (EC)DHE key establishment). Other extensions (see Section 4.2) are sent separately in the EncryptedExtensions message."
41,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,HelloRetryRequest Special Case,"For reasons of backward compatibility with middleboxes (see Appendix D.4), the HelloRetryRequest message uses the same structure as the ServerHello, but with Random set to the special value of the SHA-256 of ""HelloRetryRequest"":

    CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91
    C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C

Upon receiving a message with type server_hello, implementations MUST first examine the Random value and, if it matches this value, process it as described in Section 4.1.4."
42,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Downgrade Protection Mechanism,TLS 1.3 has a downgrade protection mechanism embedded in the server's random value. TLS 1.3 servers which negotiate TLS 1.2 or below in response to a ClientHello MUST set the last 8 bytes of their Random value specially in their ServerHello.
43,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Downgrade Values Specifics,"If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of their Random value to the bytes:

    44 4F 57 4E 47 52 44 01

If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes:

    44 4F 57 4E 47 52 44 00."
44,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Client Verification Responsibilities,"TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values. TLS 1.2 clients SHOULD also check that the last 8 bytes are not equal to the second value if the ServerHello indicates TLS 1.1 or below. If a match is found, the client MUST abort the handshake with an ""illegal_parameter"" alert."
45,4.1.3.. Handshake Protocol_Key Exchange Messages_Server Hello,Legacy Client Renegotiation,"A legacy TLS client performing renegotiation with TLS 1.2 or prior and which receives a TLS 1.3 ServerHello during renegotiation MUST abort the handshake with a ""protocol_version"" alert. Note that renegotiation is not possible when TLS 1.3 has been negotiated."
46,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,HelloRetryRequest Purpose,"The server will send this message in response to a ClientHello message if it is able to find an acceptable set of parameters but the ClientHello does not contain sufficient information to proceed with the handshake. As discussed in Section 4.1.3, the HelloRetryRequest has the same format as a ServerHello message, and the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields have the same meaning. However, for convenience, we discuss 'HelloRetryRequest' throughout this document as if it were a distinct message."
47,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Extension Requirements,"The server's extensions MUST contain 'supported_versions'. Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair. A HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the 'cookie' extension."
48,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Client Processing of HelloRetryRequest,"Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using 'supported_versions'. Clients MUST abort the handshake with an 'illegal_parameter' alert if the HelloRetryRequest would not result in any change in the ClientHello."
49,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Handling Multiple HelloRetryRequests,"If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), it MUST abort the handshake with an 'unexpected_message' alert."
50,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Required Extensions in HelloRetryRequest,"The HelloRetryRequest extensions defined in this specification are:

- supported_versions (see Section 4.2.1)
- cookie (see Section 4.2.2)
- key_share (see Section 4.2.8)"
51,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Cipher Suite Verification,"A client which receives a cipher suite that was not offered MUST abort the handshake. Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello. Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an 'illegal_parameter' alert."
52,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Pre-Shared Key Considerations,"In its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite. This allows the client to avoid having to compute partial hash transcripts for multiple hashes in the second ClientHello."
53,4.1.4.. Handshake Protocol_Key Exchange Messages_Hello Retry Request,Version Retention Requirement,"The value of selected_version in the HelloRetryRequest 'supported_versions' extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an 'illegal_parameter' alert if the value changes."
54,4.2.. Handshake Protocol_Extensions,Extension Structure,"A number of TLS messages contain tag-length-value encoded extensions structures.

    struct {
        ExtensionType extension_type;
        opaque extension_data<0..2^16-1>;
    } Extension;

    enum {
        server_name(0),                             /* RFC 6066 */
        max_fragment_length(1),                     /* RFC 6066 */
        status_request(5),                          /* RFC 6066 */
        supported_groups(10),                       /* RFC 8422, 7919 */
        signature_algorithms(13),                   /* RFC 8446 */
        use_srtp(14),                               /* RFC 5764 */
        heartbeat(15),                              /* RFC 6520 */
        application_layer_protocol_negotiation(16), /* RFC 7301 */
        signed_certificate_timestamp(18),           /* RFC 6962 */
        client_certificate_type(19),                /* RFC 7250 */
        server_certificate_type(20),                /* RFC 7250 */
        padding(21),                                /* RFC 7685 */
        pre_shared_key(41),                         /* RFC 8446 */
        early_data(42),                             /* RFC 8446 */
        supported_versions(43),                     /* RFC 8446 */
        cookie(44),                                 /* RFC 8446 */
        psk_key_exchange_modes(45),                 /* RFC 8446 */
        certificate_authorities(47),                /* RFC 8446 */
        oid_filters(48),                            /* RFC 8446 */
        post_handshake_auth(49),                    /* RFC 8446 */
        signature_algorithms_cert(50),              /* RFC 8446 */
        key_share(51),                              /* RFC 8446 */
        (65535)
    } ExtensionType;"
55,4.2.. Handshake Protocol_Extensions,Extension Fields,"-  ""extension_type"" identifies the particular extension type.

-  ""extension_data"" contains information specific to the particular extension type."
56,4.2.. Handshake Protocol_Extensions,Extension Request/Response Structure,"Extensions are generally structured in a request/response fashion, though some extensions are just indications with no corresponding response. The client sends its extension requests in the ClientHello message, and the server sends its extension responses in the ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate messages. The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message. The server MAY also send unsolicited extensions in the NewSessionTicket, though the client does not respond directly to these."
57,4.2.. Handshake Protocol_Extensions,Extension Response Constraints,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest. Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert."
58,4.2.. Handshake Protocol_Extensions,Extension Message Compatibility,"If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an ""illegal_parameter"" alert."
59,4.2.. Handshake Protocol_Extensions,Extension Appearances Table,"+--------------------------------------------------+-------------+
| Extension                                        |     TLS 1.3 |
+--------------------------------------------------+-------------+
| server_name [RFC6066]                            |      CH, EE |
| max_fragment_length [RFC6066]                    |      CH, EE |
| status_request [RFC6066]                         |  CH, CR, CT |
| supported_groups [RFC7919]                       |      CH, EE |
| signature_algorithms (RFC 8446)                  |      CH, CR |
| use_srtp [RFC5764]                               |      CH, EE |
| heartbeat [RFC6520]                              |      CH, EE |
| application_layer_protocol_negotiation [RFC7301] |      CH, EE |
| signed_certificate_timestamp [RFC6962]           |  CH, CR, CT |
| client_certificate_type [RFC7250]                |      CH, EE |
| server_certificate_type [RFC7250]                |      CH, EE |
| padding [RFC7685]                                |          CH |
| key_share (RFC 8446)                             | CH, SH, HRR |
| pre_shared_key (RFC 8446)                        |      CH, SH |
| psk_key_exchange_modes (RFC 8446)                |          CH |
| early_data (RFC 8446)                            | CH, EE, NST |
| cookie (RFC 8446)                                |     CH, HRR |
| supported_versions (RFC 8446)                    | CH, SH, HRR |
| certificate_authorities (RFC 8446)               |      CH, CR |
| oid_filters (RFC 8446)                           |          CR |
| post_handshake_auth (RFC 8446)                   |          CH |
| signature_algorithms_cert (RFC 8446)             |      CH, CR |
+--------------------------------------------------+-------------+"
60,4.2.. Handshake Protocol_Extensions,Extension Order and Uniqueness,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block). There MUST NOT be more than one extension of the same type in a given extension block."
61,4.2.. Handshake Protocol_Extensions,Extension Negotiation in Resumption,"In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each handshake even when in resumption-PSK mode. However, 0-RTT parameters are those negotiated in the previous handshake; mismatches may require rejecting 0-RTT."
62,4.2.. Handshake Protocol_Extensions,Extension Security Considerations,"There are subtle (and not so subtle) interactions that may occur in this protocol between new features and existing features which may result in a significant reduction in overall security. The following considerations should be taken into account when designing new extensions:

-  Some cases where a server does not agree to an extension are error conditions (e.g., the handshake cannot continue), and some are simply refusals to support particular features. In general, error alerts should be used for the former and a field in the server extension response for the latter.

-  Extensions should, as far as possible, be designed to prevent any attack that forces use (or non-use) of a particular feature by manipulation of handshake messages. This principle should be followed regardless of whether the feature is believed to cause a security problem."
63,4.2.1.. Handshake Protocol_Extensions_Supported Versions,SupportedVersions Structure,"struct {
    select (Handshake.msg_type) {
        case client_hello:
            ProtocolVersion versions<2..254>;

        case server_hello: /* and HelloRetryRequest */
            ProtocolVersion selected_version;
    };
} SupportedVersions;"
64,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Purpose of the Supported Versions Extension,"The ""supported_versions"" extension is used by the client to indicate which versions of TLS it supports and by the server to indicate which version it is using. The extension contains a list of supported versions in preference order, with the most preferred version first."
65,4.2.1.. Handshake Protocol_Extensions_Supported Versions,ClientHello Requirements,"Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which they are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, they MUST be present as well)."
66,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Server Behavior Without the Extension,"If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later."
67,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Server Behavior With the Extension,"If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension."
68,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Version Negotiation Flexibility,This mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.
69,4.2.1.. Handshake Protocol_Extensions_Supported Versions,ServerHello Version Negotiation,"A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2)."
70,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Client Processing Requirements,"Clients MUST check for this extension prior to processing the rest of the ServerHello. If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version."
71,4.2.1.. Handshake Protocol_Extensions_Supported Versions,Error Handling for Version Mismatches,"If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert."
72,4.2.2.. Handshake Protocol_Extensions_Cookie,Cookie Structure Definition,"struct {
    opaque cookie<1..2^16-1>;
} Cookie;"
73,4.2.2.. Handshake Protocol_Extensions_Cookie,Purpose of Cookies,"Cookies serve two primary purposes:

- Allowing the server to force the client to demonstrate reachability at their apparent network address (thus providing a measure of DoS protection). This is primarily useful for non-connection-oriented transports (see [RFC6347] for an example of this).

- Allowing the server to offload state to the client, thus allowing it to send a HelloRetryRequest without storing any state. The server can do this by storing the hash of the ClientHello in the HelloRetryRequest cookie (protected with some suitable integrity protection algorithm)."
74,4.2.2.. Handshake Protocol_Extensions_Cookie,HelloRetryRequest Cookie Extension,"When sending a HelloRetryRequest, the server MAY provide a ""cookie"" extension to the client (this is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello). When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a ""cookie"" extension in the new ClientHello. Clients MUST NOT use cookies in their initial ClientHello in subsequent connections."
75,4.2.2.. Handshake Protocol_Extensions_Cookie,Stateless Server Behavior,"When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5). Since the server is not storing any state, this will appear as if it were the first message to be received. Servers operating statelessly MUST ignore these records."
76,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Algorithms Overview,"TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures. The ""signature_algorithms_cert"" extension applies to signatures in certificates, and the ""signature_algorithms"" extension, which originally appeared in TLS 1.2, applies to signatures in CertificateVerify messages. The keys found in certificates MUST also be of appropriate type for the signature algorithms they are used with."
77,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Extension Requirements,"If no ""signature_algorithms_cert"" extension is present, then the ""signature_algorithms"" extension also applies to signatures appearing in certificates. Clients which desire the server to authenticate itself via a certificate MUST send the ""signature_algorithms"" extension. If a server is authenticating via a certificate and the client has not sent a ""signature_algorithms"" extension, then the server MUST abort the handshake with a ""missing_extension"" alert (see Section 9.2)."
78,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Purpose of Signature Algorithms Cert Extension,"The ""signature_algorithms_cert"" extension was added to allow implementations which supported different sets of algorithms for certificates and in TLS itself to clearly signal their capabilities. TLS 1.2 implementations SHOULD also process this extension. Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension."
79,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Scheme Enumeration,"The ""extension_data"" field of these extensions contains a SignatureSchemeList value:

plaintext
enum {
    /* RSASSA-PKCS1-v1_5 algorithms */
    rsa_pkcs1_sha256(0x0401),
    rsa_pkcs1_sha384(0x0501),
    rsa_pkcs1_sha512(0x0601),

    /* ECDSA algorithms */
    ecdsa_secp256r1_sha256(0x0403),
    ecdsa_secp384r1_sha384(0x0503),
    ecdsa_secp521r1_sha512(0x0603),

    /* RSASSA-PSS algorithms with public key OID rsaEncryption */
    rsa_pss_rsae_sha256(0x0804),
    rsa_pss_rsae_sha384(0x0805),
    rsa_pss_rsae_sha512(0x0806),

    /* EdDSA algorithms */
    ed25519(0x0807),
    ed448(0x0808),

    /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
    rsa_pss_pss_sha256(0x0809),
    rsa_pss_pss_sha384(0x080a),
    rsa_pss_pss_sha512(0x080b),

    /* Legacy algorithms */
    rsa_pkcs1_sha1(0x0201),
    ecdsa_sha1(0x0203),

    /* Reserved Code Points */
    private_use(0xFE00..0xFFFF),
    (0xFFFF)
} SignatureScheme;

"
80,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Algorithm Definitions,"Each SignatureScheme value lists a single signature algorithm that the client is willing to verify. The values are indicated in descending order of preference. Note that a signature algorithm takes as input an arbitrary-length message, rather than a digest. Algorithms which traditionally act on a digest should be defined in TLS to first hash the input with a specified hash algorithm and then proceed as usual."
81,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,RSASSA-PKCS1-v1_5 Algorithms,"Indicates a signature algorithm using RSASSA-PKCS1-v1_5 [RFC8017] with the corresponding hash algorithm as defined in [SHS]. These values refer solely to signatures which appear in certificates and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2."
82,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,ECDSA Algorithms,"Indicates a signature algorithm using ECDSA [ECDSA], the corresponding curve as defined in ANSI X9.62 [ECDSA] and FIPS 186-4 [DSS], and the corresponding hash algorithm as defined in [SHS]. The signature is represented as a DER-encoded [X690] ECDSA-Sig-Value structure."
83,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,RSASSA-PSS Algorithms,Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST be equal to the length of the output of the digest algorithm.
84,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,EdDSA Algorithms,"Indicates a signature algorithm using EdDSA as defined in [RFC8032] or its successors. Note that these correspond to the ""PureEdDSA"" algorithms and not the ""prehash"" variants."
85,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Legacy Algorithms,"Indicates algorithms which are being deprecated because they use algorithms with known weaknesses, specifically SHA-1 which is used in this context with either (1) RSA using RSASSA-PKCS1-v1_5 or (2) ECDSA. These values refer solely to signatures which appear in certificates and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2."
86,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,Signature Validation Notes,"The signatures on certificates that are self-signed or certificates that are trust anchors are not validated, since they begin a certification path. A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the ""signature_algorithms"" extension."
87,4.2.3.. Handshake Protocol_Extensions_Signature Algorithms,TLS 1.2 Compatibility,Note that TLS 1.2 defines this extension differently. TLS 1.3 implementations willing to negotiate TLS 1.2 MUST behave in accordance with the requirements of [RFC5246] when negotiating that version.
